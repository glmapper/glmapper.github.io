<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>SpringCloud-配置中心 spring-cloud-config-zookeeper</title>
      <link href="/2019/01/05/springcloud-config-zk-project/"/>
      <url>/2019/01/05/springcloud-config-zk-project/</url>
      
        <content type="html"><![CDATA[<p>SpringCloud 除了config自己的client/server 这套配置中心之外，还可以集成使用 zookeeper 。本篇将演示如何使用 spring-cloud-confg-zookeeper。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK<br></td><td>1.8.0_162<br></td></tr><tr><td>SOFABoot/SpringBoot<br></td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE<br></td></tr><tr><td>SpringCloud<br></td><td>Finchley.RC1<br></td></tr><tr><td>IDE<br></td><td>IDEA<br></td></tr></tbody></table><h2 id="zk-amp-zkui"><a href="#zk-amp-zkui" class="headerlink" title="zk &amp; zkui"></a>zk &amp; zkui</h2><p>这里我是把 zk 和 zkui 部署在一台 linux 服务器上的。</p><h3 id="zk"><a href="#zk" class="headerlink" title="zk"></a>zk</h3><p><br><br>从 ZooKeeper官网 下载 zookeeper-3.4.13.tar.gz。</p><ul><li>解压</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf zookeeper-3.4.13.tar.gz</span><br></pre></td></tr></table></figure><ul><li>目录重命名(可选)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv zookeeper-3.4.13 zookeeper</span><br></pre></td></tr></table></figure><ul><li>在 zookeeper 下加一个data目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">cd</span> zookeeper</span><br><span class="line">&gt; mkdir data</span><br></pre></td></tr></table></figure><ul><li>修改 zoo.cfg</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim zoo.cfg</span><br></pre></td></tr></table></figure><p>修改 dataDir 地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/$&#123;your path&#125;/zookeeper/data</span><br></pre></td></tr></table></figure><ul><li>其他随意，启动 zk</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure><h3 id="zkui"><a href="#zkui" class="headerlink" title="zkui"></a>zkui</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://gitee.com/ilanni/zkui.git</span><br><span class="line">$ <span class="built_in">cd</span> zkui/ </span><br><span class="line">$ mvn clean install <span class="comment"># 进行maven打包，执行成功后会生成target文件夹，其中有jar文件。</span></span><br></pre></td></tr></table></figure><p>执行结束后在zkui文件夹下生成一个target文件夹。<br><br></p><ul><li>将config.cfg文件复制到target文件夹下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp config.cfg target/</span><br></pre></td></tr></table></figure><p>target文件夹中有两个jar包，我们只需要启动<code>zkui-2.0-SNAPSHOT-jar-with-dependencies.jar</code>就可以了。</p><ul><li>修改 config.cfg文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">cd</span> target</span><br><span class="line">&gt; vim config.cfg</span><br></pre></td></tr></table></figure><p>按需修改serverPort、zkServer、userSet 等。</p><ul><li>启动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar zkui-2.0-SNAPSHOT-jar-with-dependencies.jar</span><br><span class="line"><span class="comment"># nohup java -jar zkui-2.0-SNAPSHOT-jar-with-dependencies.jar &amp;   #退出窗口不退出进程</span></span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>既然是以 zk 作为配置中，那么就需要将测试用的配置数据先在zk上进行初始化。有两种方式（均基于zkui）：</p><ul><li>zkui 界面通过 import 进行导入，这里新建一个 config.txt ，内容如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/config/sofa/sofa-config-zk,dev=server.port=8085</span><br></pre></td></tr></table></figure><p>设置当前应用启动的端口，这里的 root 为 /config/sofa，应用名是 sofa-config-zk，dev是环境 ，server.port=8085 是具体的配置kv。</p><ul><li>手动 add node</li></ul><p>这里为了方便，采用import的方式，结果如下：<br><br><img src="https://github.com/glmapper/glmapper.github.io/blob/master/images/self/spring-cloud-zk/zkui.png" alt="image.png"></p><h2 id="新建-sofa-config-zookeeper"><a href="#新建-sofa-config-zookeeper" class="headerlink" title="新建 sofa-config-zookeeper"></a>新建 sofa-config-zookeeper</h2><p>新建一个 SOFABoot 工程，项目为 sofa-config-zookeeper。</p><h3 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring-cloud-config zk 的依赖，必选--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- spring-cloud-config zk 的依赖，为了自动刷新监听等--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sofa-config-zk</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">  cloud:</span><br><span class="line">    zookeeper:</span><br><span class="line">      enabled: true  # true:开启zookeeper外部化配置, false:读取本地配置;</span><br><span class="line">      connect-string: sofa.cloud.alipay.net:2181</span><br><span class="line">      config:</span><br><span class="line">        root: /config/sofa   #指定zookeeper中属性的根目录</span><br><span class="line">        enabled: true</span><br><span class="line">        watcher:</span><br><span class="line">          enabled: true    #默认值是true, 监控配置变更后是否自动更新，需配合Spring Boot Actuators 使用</span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaConfigZookeeperApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaConfigZookeeperApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有任何特殊，不需要加额外的注解。</p><h3 id="资源类"><a href="#资源类" class="headerlink" title="资源类"></a>资源类</h3><p>其实这里可以完全不用通过rest来打印这个属性值，但是为了方便看，还是写一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperConfigController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/config"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serverPort;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动-amp-验证"><a href="#启动-amp-验证" class="headerlink" title="启动&amp;验证"></a>启动&amp;验证</h3><p>启动应用，如果成功的话，会有如下的日志：State change: CONNECTED<br></p><p><img src="https://github.com/glmapper/glmapper.github.io/blob/master/images/self/spring-cloud-zk/statue.png" alt="image.png"></p><p>tomcat 启动端口:<br><br><img src="https://github.com/glmapper/glmapper.github.io/blob/master/images/self/spring-cloud-zk/start.png" alt="image.png"></p><p>因为在上面配置文件部分是没有指定 server.port 的，通常情况下默认是 8080 ，所以可以确定，已经拿到了配置中心的数据了。</p><h2 id="动态刷新"><a href="#动态刷新" class="headerlink" title="动态刷新"></a>动态刷新</h2><p>这里还是需要依赖 actuator 的 /refresh 。上面依赖中已经加入了 actuator的相关依赖，所以只需要在资源类上加一个 <a href="#">@RefreshScope</a> 注解即可。</p><ul><li>在 ZookeeperConfigController 类上加 <a href="#">@RefreshScope</a>  注解，然后重启应用</li><li>通过 zkui 修改 server.port 为 8086</li><li>访问 <a href="http://localhost:8065/config" target="_blank" rel="noopener">http://localhost:8085/config</a> ，返回8086</li></ul><blockquote><p>需要注意，这里因为我们启动时应用时拿到的配置是8085，所以当前服务对外提供服务暴露的端口就是8085 ，当我们修改了zk上的值之后，他会改变 当前运行环境中 Enviroment 的值，但是不会使得服务的端口发生变化，除非重启。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> spring cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
            <tag> Config </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 下安装 Mysql 数据库</title>
      <link href="/2019/01/05/mysql-on-linux/"/>
      <url>/2019/01/05/mysql-on-linux/</url>
      
        <content type="html"><![CDATA[<p>最近在搞 Apollo ，熟悉的同学应该知道，Apollo 需要依赖 Mysql。本以为很容易搞定，但是却踩了一路坑，眼高手低，也参考了网上很多博客，果然是残缺就是美！本篇就简单记录一下这个过程，以便后面参考。</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li><p>linux：centOS 7</p></li><li><p>jdk：8</p></li><li><p>Mysql：5.7.24</p></li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>安装前，我们可以检测系统是否自带安装 MySQL:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep mysql</span><br></pre></td></tr></table></figure><p>如果你系统有安装，那可以选择进行卸载，有两种模式：</p><ul><li><p>普通删除模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e mysql</span><br></pre></td></tr></table></figure></li><li><p>强力删除模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps mysql</span><br></pre></td></tr></table></figure><p>如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除</p></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>下载mysql安装包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm</span><br><span class="line"></span><br><span class="line">-2018-06-06 16:41:46--  https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm</span><br><span class="line">正在解析主机 dev.mysql.com (dev.mysql.com)... xxxx</span><br><span class="line">正在连接 dev.mysql.com (dev.mysql.com)|xxxxx|:443... 已连接。</span><br><span class="line">已发出 HTTP 请求，正在等待回应... 302 Found</span><br><span class="line">位置：https://repo.mysql.com//mysql57-community-release-el7-9.noarch.rpm [跟随至新的 URL]</span><br><span class="line">--2018-06-06 16:41:48--  https://repo.mysql.com//mysql57-community-release-el7-9.noarch.rpm</span><br><span class="line">正在解析主机 repo.mysql.com (repo.mysql.com)... xxxxx</span><br><span class="line">正在连接 repo.mysql.com (repo.mysql.com)|xxxx|:443... 已连接。</span><br><span class="line">已发出 HTTP 请求，正在等待回应... 200 OK</span><br><span class="line">长度：9224 (9.0K) [application/x-redhat-package-manager]</span><br><span class="line">正在保存至: “mysql57-community-release-el7-9.noarch.rpm”</span><br><span class="line"></span><br><span class="line">100%[==========================================================&gt;] 9,224       --.-K/s 用时 0s      </span><br><span class="line"></span><br><span class="line">2018-06-06 16:41:48 (169 MB/s) - 已保存 “mysql57-community-release-el7-9.noarch.rpm” [9224/9224])</span><br></pre></td></tr></table></figure><ul><li>安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql57-community-release-el7-9.noarch.rpm</span><br><span class="line"></span><br><span class="line">准备中...                          ################################# [100%]</span><br><span class="line">正在升级/安装...</span><br><span class="line">   1:mysql57-community-release-el7-9  ################################# [100%]</span><br></pre></td></tr></table></figure><ul><li>下载安装依赖包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql-server</span><br><span class="line"></span><br><span class="line">已加载插件：fastestmirror, langpacks</span><br><span class="line">mysql-connectors-community                                                   | 2.5 kB  00:00:00     </span><br><span class="line">mysql-tools-community                                                        | 2.5 kB  00:00:00     </span><br><span class="line">mysql57-community                                                            | 2.5 kB  00:00:00     </span><br><span class="line">(1/3): mysql-connectors-community/x86_64/primary_db                          |  20 kB  00:00:00     </span><br><span class="line">(2/3): mysql-tools-community/x86_64/primary_db                               |  41 kB  00:00:00     </span><br><span class="line">(3/3): mysql57-community/x86_64/primary_db                                   | 144 kB  00:00:00     </span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.cn99.com</span><br><span class="line"> * extras: mirrors.cn99.com</span><br><span class="line"> * updates: mirrors.cn99.com</span><br><span class="line">正在解决依赖关系 </span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>第一次下载这里会比较慢</p><ul><li><p>验证是否安装成功</p><ul><li>mysqladmin –version</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin  Ver 8.42 Distrib 5.7.22, for Linux on x86_64</span><br></pre></td></tr></table></figure><ul><li>mysql -V</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql  Ver 14.14 Distrib 5.7.24, for Linux (x86_64) using  EditLine wrapper</span><br></pre></td></tr></table></figure></li><li><p>启动MySQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start mysqld</span><br></pre></td></tr></table></figure></li><li><p>查看 MySQL 运行状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status mysqld</span><br></pre></td></tr></table></figure></li><li><p>停止 MySQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop mysqld</span><br></pre></td></tr></table></figure></li><li><p>重启 MySQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart mysqld</span><br></pre></td></tr></table></figure></li></ul><h3 id="关于密码"><a href="#关于密码" class="headerlink" title="关于密码"></a>关于密码</h3><p>Mysql 5.7 默认安装之后 root 是有密码的，获取 MySQL 的临时密码 为了加强安全性，MySQL 5.7 为 root 用户随机生成了一个密码，在 error log 中，关于 error log 的位置，如果安装的是 RPM 包，则默认是 /var/log/mysqld.log 。 只有启动过一次 mysql 才可以查看临时密码。</p><p>在利用 YUM 安装 mysql 数据库过程中，系统会自动生成一个临时密码，获取方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &apos;temporary password&apos; /var/log/mysqld.log</span><br></pre></td></tr></table></figure><ul><li><p>没有密码</p><p>如果以前安装过 mysql，这时的 mysqld.log 中就不会有 temporary password<br>这时就需要删除 mysql 残留的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /var/lib/mysql</span><br></pre></td></tr></table></figure><p>执行完毕后需要重新启动MySQL服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart mysqld</span><br></pre></td></tr></table></figure><p>这时就可以通过上面的命令去查找数据库生成的临时密码了</p></li></ul><h3 id="mysql-1130-错误"><a href="#mysql-1130-错误" class="headerlink" title="mysql 1130 错误"></a>mysql 1130 错误</h3><p>可能是你的帐号不允许从远程登陆，只能在 localhost。这个时候只要在 localhost 的那台电脑，登入 mysql 后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称”%”</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -pvmwaremysql&gt;use mysql;</span><br><span class="line">mysql&gt; update user set host = '%' where user = 'root';</span><br><span class="line">mysql&gt; select host, user from user;</span><br></pre></td></tr></table></figure><p>使得我们当前的账户和密码能够应用的所有的远程主机连接：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; GRANT ALL PRIVILEGES ON . TO 'myuser'@'%' IDENTIFIED BY 'mypassword' WITH GRANT OPTION;</span><br><span class="line">&gt; FLUSH   PRIVILEGES;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringCloud-Spring Cloud Context</title>
      <link href="/2018/12/31/springcoud-context-analysis/"/>
      <url>/2018/12/31/springcoud-context-analysis/</url>
      
        <content type="html"><![CDATA[<h2 id="引导程序应用上下文"><a href="#引导程序应用上下文" class="headerlink" title="引导程序应用上下文"></a>引导程序应用上下文</h2><blockquote><p>A Spring Cloud application operates by creating a “bootstrap” context, which is a parent context for the main application. It is responsible for loading configuration properties from the external sources and for decrypting properties in the local external configuration files. The two contexts share an Environment, which is the source of external properties for any Spring application.</p><p>By default, bootstrap properties (not bootstrap.properties but properties that are loaded during the bootstrap phase) are added with high precedence, so they cannot be overridden by local configuration.</p><p>The bootstrap context uses a different convention for locating external configuration than the main application context. Instead of application.yml (or .properties), you can use bootstrap.yml, keeping the external configuration for bootstrap and main context nicely separate.</p></blockquote><blockquote><p>释文：Spring Cloud 应用程序通过创建“引导程序”上下文来运行，<strong>该上下文是主应用程序的父上下文</strong>共享一个 Environment**，它是任何Spring应用程序的外部属性的来源。</p><p>默认情况下，引导属性（不是bootstrap.properties，而是在引导阶段加载的属性）以<strong>高优先级添加</strong>，因此本地配置无法覆盖它们。</p><p>引导上下文使用与主应用程序上下文不同的外部配置约定。 因此使用 bootstrap.yml application.yml（或.properties）代替引导和主上下文的外部配置，保持引导程序和主上下文的外部配置很好地分开。</p></blockquote><p><br><br>上面是 SpringCloud 关于引导上下文的一个解释，详见 <a href="https://cloud.spring.io/spring-cloud-static/Finchley.SR2/single/spring-cloud.html#_the_bootstrap_application_context" target="_blank" rel="noopener">这里</a>。</p><p>spring cloud 有自己的一套配置初始化机制，所以它实际上是自己启动了一个Spring 上下文，也就是我们说的引导上文。在上面的描述中有提到，引导上下文会以应用上下文的父类存在；在Spring中，如果上下文存在父子关系，也就意味着子上下文会集成父上下文的属性源和配置文件。在SpringBoot的启动过程中，prepareContext 这个操作会进行父子上下文的关系设置，调用栈如下:</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2018/png/97619/1546070770372-d7a4ec62-f29b-477f-adc0-844709415a32.png#wh=561x165" alt="image.png"></p><p>setParent 方法代码片段如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParent</span><span class="params">(@Nullable ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.parent = parent;</span><br><span class="line">       <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Environment parentEnvironment = parent.getEnvironment();</span><br><span class="line">           <span class="keyword">if</span> (parentEnvironment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">               <span class="keyword">this</span>.getEnvironment().merge((ConfigurableEnvironment)parentEnvironment);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>这个可以看到，子上下文会合并掉父上下文的 Environment 。关于父子上下文是怎么关联起来的，下面来看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(context.getParent() != <span class="keyword">null</span> &amp;&amp; context.getParent() != context) &#123;</span><br><span class="line">  context = (ConfigurableApplicationContext)context.getParent();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.reorderSources(context.getEnvironment());</span><br><span class="line">  (<span class="keyword">new</span> ParentContextApplicationContextInitializer(<span class="keyword">this</span>.parent)).initialize(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="BootstrapApplicationListener"><a href="#BootstrapApplicationListener" class="headerlink" title="BootstrapApplicationListener"></a>BootstrapApplicationListener</h3><p>上面的代码片段定位在 org.springframework.cloud.bootstrap.BootstrapApplicationListener 这个类；这个监听器监听的事件是  ApplicationEnvironmentPreparedEvent ，对应在SpringBoot启动过程，就是在执行 prepareEnvironment 时触发事件调用。</p><p>BootstrapApplicationListener 的 onApplicationEvent 回调方法中实际上就是用够构建和启动 Spring Cloud  context 的。<br>spring cloud context 算是一个特殊的 spring boot context， 在分析代码的过程中（bootstrapServiceContext方法中）发现，它只扫描 BootstrapConfiguration 这个注解标注的组件。</p><p>这里就着重分析下 SpringCloud Context 的启动过程。</p><h3 id="SpringCloud-Context-启动过程"><a href="#SpringCloud-Context-启动过程" class="headerlink" title="SpringCloud Context 启动过程"></a>SpringCloud Context 启动过程</h3><p><br></p><h4 id="通过-spring-cloud-bootstrap-enabled-配置来禁用引导上下文"><a href="#通过-spring-cloud-bootstrap-enabled-配置来禁用引导上下文" class="headerlink" title="通过 spring.cloud.bootstrap.enabled 配置来禁用引导上下文"></a>通过 spring.cloud.bootstrap.enabled 配置来禁用引导上下文</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!environment.getProperty(<span class="string">"spring.cloud.bootstrap.enabled"</span>, Boolean.class,<span class="keyword">true</span>)) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调函数的开始就会对 spring.cloud.bootstrap.enabled 这个配置值进行校验，来决定是否需要禁止引导。这个在官方文档里面也有明确提到。</p><h4 id="获取-configName"><a href="#获取-configName" class="headerlink" title="获取 configName"></a>获取 configName</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String configName = environment</span><br><span class="line">.resolvePlaceholders(<span class="string">"$&#123;spring.cloud.bootstrap.name:bootstrap&#125;"</span>);</span><br></pre></td></tr></table></figure><p><br><br>可以使用 spring.cloud.bootstrap.name（默认“bootstrap”）或spring.cloud.bootstrap.location（默认为空）指定bootstrap.yml（或.properties）位置，例如在系统属性中。<br><br></p><h4 id="bootstrapServiceContext-创建-amp-启动"><a href="#bootstrapServiceContext-创建-amp-启动" class="headerlink" title="bootstrapServiceContext 创建&amp;启动"></a>bootstrapServiceContext 创建&amp;启动</h4><p>bootstrapServiceContext 是完成此过程的核心方法。</p><ul><li>加载 BootstrapConfiguration 自动配置类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Bootstrap components</span><br><span class="line">org.springframework.cloud.bootstrap.BootstrapConfiguration=\</span><br><span class="line">org.springframework.cloud.bootstrap.config.PropertySourceBootstrapConfiguration,\</span><br><span class="line">org.springframework.cloud.bootstrap.encrypt.EncryptionBootstrapConfiguration,\</span><br><span class="line">org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration</span><br></pre></td></tr></table></figure><p>PropertySourceBootstrapConfiguration 将会把 PropertySourceLocator 自定义属性值添加到引导上下文的环境当中，包括如何从远端仓库拉取配置等过程。</p><ul><li><p>构建 SpringApplicationBuilder 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SpringApplicationBuilder builder = <span class="keyword">new</span> SpringApplicationBuilder()</span><br><span class="line">.profiles(environment.getActiveProfiles()).bannerMode(Mode.OFF)</span><br><span class="line">.environment(bootstrapEnvironment)</span><br><span class="line"><span class="comment">// Don't use the default properties in this builder</span></span><br><span class="line">.registerShutdownHook(<span class="keyword">false</span>).logStartupInfo(<span class="keyword">false</span>)</span><br><span class="line">.web(WebApplicationType.NONE);</span><br></pre></td></tr></table></figure></li><li><p>构建 引导上下文并 run</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ConfigurableApplicationContext context = builder.run();</span><br></pre></td></tr></table></figure></li></ul><p>这个 build.run 实际执行的就是 SpringApplication.run 方法。</p><ul><li>为关联父子上下文准备<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addAncestorInitializer(application, context);</span><br></pre></td></tr></table></figure></li></ul><p>这里会把 ParentContextApplicationContextInitializer 加到应用的 spring context 里，来把自己设置为应用的context 的 parent，具体是在SpringBoot启动过程的 prepareContext 中完成 。</p><h2 id="重载远程属性"><a href="#重载远程属性" class="headerlink" title="重载远程属性"></a>重载远程属性</h2><p>通过Bootstrap 上下文添加到应用程序的属性源通常是远程的，比如说来自配置中心的，一般情况下本地的配置文件不能覆盖这些远程属性源。</p><p>那么如果想覆盖远程属性源怎么办呢？可以通过启动命令行参数方式设定（启动命令行参数的优先级高于远程配置的优先级）。</p><p>如果想使用应用程序的系统属性或者配置文件覆盖远程属性，那么远程属性源必须设置为 spring.cloud.config.allowOverride = true，这个配置在本地设置时不会生效的。在远程属性源中设定上述配置后，就可以通过更为细粒度的设置来控制远程属性是否能被重载，具体配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">overrideNone:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      overrideSystemProperties:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li>overrideNone true，本地属性覆盖所有的远程属性</li><li>overrideSystemProperties ，仅覆盖远程属性源中的系统属性和环境变量</li></ul><h2 id="自定义-Bootstrap-属性源"><a href="#自定义-Bootstrap-属性源" class="headerlink" title="自定义 Bootstrap 属性源"></a>自定义 Bootstrap 属性源</h2><p>默认情况下，Bootstrap 的外部配置属性源是 spring cloud config server ，也就是使用配置中心加载外部属性，但是Spring中也允许用户通过将 ProoertySourceLocator 类型的Bean实例添加到 Bootstrap 上下文，也就是在 spring.factories 中添加相应的配置类，来添加额外的属性源来源。这里可以通过SpringCloud里面提供的测试用例来看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertySourceConfiguration</span> <span class="keyword">implements</span> <span class="title">PropertySourceLocator</span> </span>&#123;</span><br><span class="line"><span class="comment">// 省略其他代码</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertySource&lt;?&gt; locate(Environment environment) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.name != <span class="keyword">null</span>) &#123;</span><br><span class="line">      assertEquals(<span class="keyword">this</span>.name,</span><br><span class="line">                   environment.getProperty(<span class="string">"spring.application.name"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fail) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Planned"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MapPropertySource(<span class="string">"testBootstrap"</span>, MAP);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码段中传入的Envirement 参数用于创建应用上下文，它具有 SpringBoot 提供的属性源，可以使用它们来加载指定的属性源。</p><p>最后将这个自定义的 PropertySourceLocator 配置到 spring.factories 中，这样应用程序就可以使用这个 PropertySourceConfiguration 作为其属性源了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.cloud.bootstrap.BootstrapConfiguration=\</span><br><span class="line">xx.xx.x.x.PropertySourceConfiguration</span><br></pre></td></tr></table></figure><h2 id="关于Enviroment-的变化"><a href="#关于Enviroment-的变化" class="headerlink" title="关于Enviroment 的变化"></a>关于Enviroment 的变化</h2><p>配置中心客户端（Spring Cloud Config Client） 应用会监听  EnviromentChangeEvent 事件，当监听到这个事件时，它将持有一个被改变的键值对列表，然后客户端应用会使用这些值来做一些事情：</p><ul><li>重新绑定所有的@ConfigurationProperties的Bean<a href="#">@ConfigurationProperties</a> 实例，更新本地的配置属性。</li><li>设置日志等级（logging.level.* 相关配置）</li></ul><p>Spring Cloud 中，配置中心服务端使用 Spring Cloud Bus 将EnviromentChangeEvent 事件广播到所有的客户端中，通过这种方式来通过它们 Enviroment 发生变化。<br><br></p><h2 id="RefreshScope"><a href="#RefreshScope" class="headerlink" title="RefreshScope"></a>RefreshScope</h2><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>RefreshScope 注解的作用是，当被这个注解标记的Bean实例在配置发生变化时可以重新进行初始化，可参考 <a href="https://yuque.antfin-inc.com/guolei.sgl/springcloud/krv1v3#43d58bbd" target="_blank" rel="noopener">动态刷新配置</a> 这个demo。这个注解很好的解决了状态Bean实例只能在初始化的时候才能进行属性注入的问题。</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>org.springframework.cloud.context.scope.refresh.RefreshScope 是上下文中的一个Bean实例，在它的 refreshAll 这个方法中，可以通过清除目标缓存来刷新作用域中的所有Bean实例。RefreshScope中也提供了一个 refresh方法，可以按照名字来刷新单个Bean。</p>]]></content>
      
      
      <categories>
          
          <category> spring cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring cloud </tag>
            
            <tag> commons </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringCloud-配置中心 Config</title>
      <link href="/2018/12/31/springcoud-config-project/"/>
      <url>/2018/12/31/springcoud-config-project/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Cloug-Config-简介"><a href="#Spring-Cloug-Config-简介" class="headerlink" title="Spring Cloug Config 简介"></a>Spring Cloug Config 简介</h2><p>Spring Cloud 提供的配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git以及Subversion<br><br></p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK<br></td><td>1.8.0_162<br></td></tr><tr><td>SOFABoot/SpringBoot<br></td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE<br></td></tr><tr><td>SpringCloud<br></td><td>Finchley.RC1<br></td></tr><tr><td>IDE<br></td><td>IDEA<br></td></tr></tbody></table><h2 id="工程背景"><a href="#工程背景" class="headerlink" title="工程背景"></a>工程背景</h2><p>本节将通过 SOFABoot 来集成 Spring Cloud Config ，以 git 作为存储，来实现分布式环境下的配置管理。本工程的父工程仍然是《SpringCloud-Eureka 服务注册》中构建的父工程。 </p><p>由于我们是以 git 来存储配置文件的，因此我们需要在 github 上新建一个存储配置文件的空间，为了更方面的模拟，这里创建了两个配置文件：</p><ul><li>glmapper-dev.properties</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=leishu@glmapper_dev</span><br><span class="line">blog=http://www.glmapper.com</span><br><span class="line">version=dev</span><br></pre></td></tr></table></figure><ul><li>glmapper-pre.properties</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=leishu@glmapper_pre</span><br><span class="line">blog=http://www.glmapper.com</span><br><span class="line">version=pre</span><br></pre></td></tr></table></figure><blockquote><p>github 地址：<a href="https://github.com/glmapper/glmapper-config-repository" target="_blank" rel="noopener">https://github.com/glmapper/glmapper-config-repository</a></p></blockquote><h2 id="新建-sofa-config-server"><a href="#新建-sofa-config-server" class="headerlink" title="新建 sofa-config-server"></a>新建 sofa-config-server</h2><p><br><br>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p><ul><li>artifactId：sofa-config-server</li></ul><h3 id="修改-pom-文件"><a href="#修改-pom-文件" class="headerlink" title="修改 pom 文件"></a>修改 pom 文件</h3><p>这里直接引入 config 的依赖即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8091</span></span><br><span class="line">  <span class="comment">#服务名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">sofa-config-server</span></span><br><span class="line">  <span class="comment">#服务的git仓库地址</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      server:</span></span><br><span class="line"><span class="attr">        git:</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">https://github.com/glmapper/glmapper-config-repository</span></span><br><span class="line"><span class="attr">          search-paths:</span> <span class="string">/**</span></span><br><span class="line"><span class="attr">          username:</span> <span class="string">glmapper_2018@163.com</span></span><br><span class="line"><span class="attr">          password:</span> <span class="string">******</span></span><br><span class="line">      <span class="comment">#指定分支</span></span><br><span class="line"><span class="attr">      label:</span> <span class="string">master</span></span><br><span class="line"><span class="comment">#服务注册中心</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><blockquote><p>如果你的 github 仓库是公开的话，就不需要输入账户和密码就可以访问。</p></blockquote><p>### </p><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>在启动类上加 @EnableConfigServer 注解，激活对配置中心的支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaConfigServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaConfigServerApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动-amp-验证"><a href="#启动-amp-验证" class="headerlink" title="启动 &amp; 验证"></a>启动 &amp; 验证</h3><p>因为配置中心作为一个独立的服务，所以不需要依赖其他服务的先启动，直接运行当前程序即可。这里我们首先需要验证下 server 端是否已经成功拉取到了 github 上面的配置信息：<br><br><br>访问：<a href="http://localhost:8091/glmapper/pre/master" target="_blank" rel="noopener">http://localhost:8091/glmapper/pre/master</a><br><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"glmapper"</span>,</span><br><span class="line">    <span class="attr">"profiles"</span>: [</span><br><span class="line">        <span class="string">"pre"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"label"</span>: <span class="string">"master"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"f9e8c1f2825d23031cb13d40e396a23c0f975d2d"</span>,</span><br><span class="line">    <span class="attr">"state"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"propertySources"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"https://github.com/glmapper/glmapper-config-repository/glmapper-pre.properties"</span>,</span><br><span class="line">            <span class="attr">"source"</span>: &#123;</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"leishu@glmapper-pre"</span>,</span><br><span class="line">                <span class="attr">"blog"</span>: <span class="string">"http://www.glmapper.com"</span>,</span><br><span class="line">                <span class="attr">"version"</span>: <span class="string">"pre"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>OK ，说明服务端已经成功拉取到了github上的配置文件了。</p><blockquote><p>关于地址的说明：<a href="http://localhost:8091/glmapper/pre/master" target="_blank" rel="noopener">http://localhost:8091/glmapper/pre/master</a> 。前半部分是ip和端口，没什么好说的。<br>glmapper/pre/master，因为我在github上新建的配置文件名是 glmapper-dev.properties 和 glmapper-pre .properties ;所以这里地址的规则就是 /glmapper/pre ，后面的 master 可带可不带，区别在于返回的 JSON 数据 label 是 null 还是 master，label 指向分支。</p></blockquote><p><br></p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>本节构建一个简单的客户端工程 sofa-config-client ，用于从 sofa-config-server 上获取配置文件并展示。sofa-config-client 同样基于《SpringCloud-Eureka 服务注册》中构建的父工程。 </p><h3 id="修改-pom-文件-1"><a href="#修改-pom-文件-1" class="headerlink" title="修改 pom 文件"></a>修改 pom 文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-config-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入 spring-cloud-starter-config 和  spring-boot-starter-web 依赖。</p><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件包括两个，一个是 application.yml ，另一个是 bootstrap.yml</p><ul><li>application.yml</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sofa-config-client</span><br><span class="line">server:</span><br><span class="line">  port: 8099</span><br></pre></td></tr></table></figure><ul><li>bootstrap.yml</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      name: glmapper</span><br><span class="line">      profile: pre</span><br><span class="line">      uri: http://localhost:8091/   #指向配置中心的地址</span><br><span class="line">      label: master</span><br></pre></td></tr></table></figure><h3 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h3><p>启动类不需要做什么修改，也不需要额外加什么注解<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaConfigClientApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaConfigClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="资源类"><a href="#资源类" class="headerlink" title="资源类"></a>资源类</h3><p>新建一个资源类，用于输出展示拉取到的配置信息<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;blog&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span>  String blog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;version&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span>  String version;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/config"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">config</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name:"</span>+name+<span class="string">" ,blog:"</span>+blog+<span class="string">" ,version:"</span>+version;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="启动和运行"><a href="#启动和运行" class="headerlink" title="启动和运行"></a>启动和运行</h3><p>先后启动配置中心服务端和客户端程序。在浏览器中输入：<a href="http://localhost:8099/config" target="_blank" rel="noopener">http://localhost:8099/config</a> ，返回如下：</p><p>name:leishu@glmapper-pre ,blog:<a href="http://www.glmapper.com">http://www.glmapper.com</a> ,version:pre<br><br><br>我们尝试下将 github 中 glmapper-pre.properties 这个配置文件进行修改，看下是否在这能获取到最新的依赖，修改之后，如下：<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=leishu@glmapper_pre_update</span><br><span class="line">blog=http://www.glmapper.com</span><br><span class="line">version=pre</span><br></pre></td></tr></table></figure></p><p><br>重新刷新浏览器地址，返回如下：</p><p>name:leishu@glmapper-pre ,blog:<a href="http://www.glmapper.com">http://www.glmapper.com</a> ,version:pre<br><br><br>这里并没有发生任何变换，因为 SpringBoot 项目只会在项目启动时才会获取一次配置文件信息，当我们修改了 github 上的配置文件之后，当前的配置中心客户端并没有主动去获取配置值，所以不会有新的值，我们获取到的还是旧的值。那么下面通过修改和增加一些组件和配置来实现不停服动态更新配置。<br><br></p><h3 id="配置动态更新"><a href="#配置动态更新" class="headerlink" title="配置动态更新"></a>配置动态更新</h3><p>要实现配置的动态更新，需要借助于 springboot 的 actuator 监控模块。所有需要在客户端pom文件中引入 actuator 的依赖信息。<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><br>配置文件 application.yml 中增加配置，将/actuator/refresh 断点暴露出来，注意不要配置在 boostrap.yml 中。<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sofa-config-client</span><br><span class="line">server:</span><br><span class="line">  port: 8099</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: refresh</span><br></pre></td></tr></table></figure></p><p><br>资源类中开启更新机制，在 ConfigClientController 类中增加 @RefreshScope 注解，然后重启客户端。<br>首先执行：<a href="http://localhost:8099/config" target="_blank" rel="noopener">http://localhost:8099/config</a> ，得到结果如下：<br>name:leishu@glmapper-pre ,blog:<a href="http://www.glmapper.com">http://www.glmapper.com</a> ,version:pre<br><br><br>更新 github 上配置文件的值，将 name 改为 name:leishu@glmapper-pre，通过 curl 或者 postman 执行下 刷新：<br><br><br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2018/png/97619/1545916724515-4772f92b-94f3-4162-ba19-580545efe5e2.png#wh=482x49" alt="image.png"></p><p>再次刷新执行 <a href="http://localhost:8099/config" target="_blank" rel="noopener">http://localhost:8099/config</a> ，结果如下：<br>name:leishu@glmapper-pre-update ,blog:<a href="http://www.glmapper.com">http://www.glmapper.com</a> ,version:pre</p>]]></content>
      
      
      <categories>
          
          <category> spring cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Config </tag>
            
            <tag> spring cloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringCloud-负载均衡器 Ribbon</title>
      <link href="/2018/12/31/springcoud-ribbon-project/"/>
      <url>/2018/12/31/springcoud-ribbon-project/</url>
      
        <content type="html"><![CDATA[<h2 id="Ribbon-简介"><a href="#Ribbon-简介" class="headerlink" title="Ribbon 简介"></a>Ribbon 简介</h2><p>Ribbon 是管理HTTP和TCP服务客户端的负载均衡器。Ribbon 具有一些列带有名称的客户端，也就是带有名称的Ribbon 客户端。每个客户端由可配置的组件构成，负责一类服务的调用请求。Spring Cloud 通过RibbonClientConfiguration 为每个Ribbon 客户端创建一个ApplicationContext 上下文来进行组件装配。Ribbon 作为 Spring Cloud的负载均衡机制的实现，可以与OpenFeign 和 RestTemplate 进行无缝集成，让二者也具有负载均衡的能力。<br><br></p><h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><table><thead><tr><th><strong>策略类</strong><br></th><th><strong>命名</strong><br></th><th>备注<br></th></tr></thead><tbody><tr><td>RoundRobinRule<br></td><td>轮训策略<br></td><td>按顺序循环选择 Server<br></td></tr><tr><td>RandomRule<br></td><td>随机策略<br></td><td>随机选择 Server<br></td></tr><tr><td>RetryRule<br></td><td>重试策略<br></td><td>在一个配置时问段内当选择 Server 不成功，则一直尝试选择一个可用的 Server<br></td></tr><tr><td>BestAvailableRule<br></td><td>最低并发策略<br></td><td>逐个考察 Server，如果 Server 断路器打开，则忽略，再选择其中并发连接最低的 Server    <br></td></tr><tr><td>AvailabilityFilteringRule<br></td><td>可用过滤策略<br></td><td>过滤掉一直连接失败并被标记为 <code>circuit tripped</code> 的 Server，过滤掉那些高并发连接的 Server（active connections 超过配置的网值）<br></td></tr><tr><td>ResponseTimeWeightedRule<br></td><td>响应时间加权策略<br></td><td>根据 Server 的响应时间分配权重。响应时间越长，权重越低，被选择到的概率就越低；响应时间越短，权重越高，被选择到的概率就越高。这个策略很贴切，综合了各种因素，如：网络、磁盘、IO等，这些因素直接影响着响应时间<br></td></tr><tr><td>ZoneAvoidanceRule<br></td><td>区域权衡策略<br></td><td>综合判断 Server 所在区域的性能和 Server 的可用性轮询选择 Server，并且判定一个 AWS Zone 的运行性能是否可用，剔除不可用的 Zone 中的所有 Server<br></td></tr></tbody></table><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK<br></td><td>1.8.0_162<br></td></tr><tr><td>SOFABoot/SpringBoot<br></td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE<br></td></tr><tr><td>SpringCloud<br></td><td>Finchley.RC1<br></td></tr><tr><td>IDE<br></td><td>IDEA<br></td></tr></tbody></table><h2 id="工程背景"><a href="#工程背景" class="headerlink" title="工程背景"></a>工程背景</h2><p>本节将会创建一个 sofa-eureka-consumer-Ribbon 工程，通过Spring Cloud 提供的负载均衡器 Ribbon 实现服务的负载均衡，并对 Ribbon 中的负载均衡策略进行验证。<br><br></p><h2 id="新建-sofa-eureka-consumer-ribbon"><a href="#新建-sofa-eureka-consumer-ribbon" class="headerlink" title="新建 sofa-eureka-consumer-ribbon"></a>新建 sofa-eureka-consumer-ribbon</h2><p>本工程继续使用《SpringCloud-Eureka 服务注册》中的父工程来构建。</p><p>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p><ul><li>artifactId：sofa-eurek-consumer-ribbon</li></ul><p>前面我们已经对feign进行的实际操作，因此本节使用 Ribbon + RestTemplate 组合实现具体的负载均衡实验。</p><h3 id="修改-pom-文件"><a href="#修改-pom-文件" class="headerlink" title="修改 pom 文件"></a>修改 pom 文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-consumer-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8889</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka-consumer-ribbon</span></span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>这里需要引入 @EnableEurekaClient 注解，表示当前是一个客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaEurekaConsumerRibbonApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaEurekaConsumerRibbonApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@LoadBalanced ： Spring Cloud 为客户端负载均衡创建了特定的注解，被该注解修饰的 RestTemplate Bean实例，Spring Cloud 就会让 RestTemplate 使用相关的负载均衡策略，默认情况下使用的就是 Ribbon。</p><h3 id="资源类"><a href="#资源类" class="headerlink" title="资源类"></a>资源类</h3><p>这里我们通过 restTemplate 去访问 Provider 提供的服务，需要注意，这里为了演示作用，直接将资源Url固定写成：<a href="http://HELLOSOFASERVICE/hello" target="_blank" rel="noopener">http://HELLOSOFASERVICE/hello</a> ，<a href="http://hellosofaservice/hello" target="_blank" rel="noopener">HELLOSOFASERVICE</a> 为 Provider 提供的服务的实例名称，也就是Eureka服务端界面上对应的 <strong>Application。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://HELLOSOFASERVICE/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>这里正常先后启动 服务注册中心 sofa-eureka-server-center ；服务提供方 sofa-eureka-provider ，服务提供方为了方便演示，这里启动4个实例，对应的端口分别为：8081，8082，8083，8084，如下：</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2018/png/97619/1545884540300-7d0f7177-832c-4bf7-a652-52db00c91a82.png#wh=1572x152" alt="image.png"></p><p>然后启动当前 sofa-eurek-consumer-ribbon 工程。默认情况下，不指定任何负载均衡策略，使用的是轮询策略。</p><p>浏览器输入 <a href="http://localhost:8889/hello" target="_blank" rel="noopener">http://localhost:8889/hello</a> ，调用10次：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8082</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8084</span> And hostname is HelloSOFAService</span><br><span class="line">  </span><br><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8082</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8084</span> And hostname is HelloSOFAService</span><br><span class="line">  </span><br><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8082</span> And hostname is HelloSOFAService</span><br></pre></td></tr></table></figure></p><p>从结果来看，默认策略应该是轮询（不用情况下，调用顺序不一定是1-2-3-4，但是以每4组为一组来看，存在周期性）。</p><h2 id="负载均衡策略设置"><a href="#负载均衡策略设置" class="headerlink" title="负载均衡策略设置"></a>负载均衡策略设置</h2><h3 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h3><p>全局设置就是自己定义一个配置类，然后在配置类中指定具体的负载均衡策略。在com.alipay.sofa.cloud.configuration 包下面新建一个配置类，这里使用的策略是随机策略：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonGlobalLoadBalancingConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>浏览器输入 <a href="http://localhost:8889/hello" target="_blank" rel="noopener">http://localhost:8889/hello</a> ，调用10次：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8084</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8084</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">  </span><br><span class="line">Hello SOFA! Now Port is <span class="number">8082</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8082</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8084</span> And hostname is HelloSOFAService</span><br><span class="line">  </span><br><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br></pre></td></tr></table></figure></p><p>从结果来看，具有随机属性。<br><br></p><h3 id="针对单个服务的-Ribbon-负载均衡策略"><a href="#针对单个服务的-Ribbon-负载均衡策略" class="headerlink" title="针对单个服务的 Ribbon 负载均衡策略"></a>针对单个服务的 Ribbon 负载均衡策略</h3><p>新建一个 RibbonRandomLBConfiguration 配置类，这里有个前提是需要删除 全局配置类  。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonRandomLBConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><br>修改启动类，增加 @RibbonClient 注解，并且通过 configuration 指定负载均衡策略。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@RibbonClient</span>(name=<span class="string">"HELLOSOFASERVICE"</span>,configuration = RibbonRandomLBConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaEurekaConsumerRibbonApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaEurekaConsumerRibbonApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br>浏览器输入 <a href="http://localhost:8889/hello" target="_blank" rel="noopener">http://localhost:8889/hello</a> ，调用10次：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">  </span><br><span class="line">Hello SOFA! Now Port is <span class="number">8084</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8082</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8082</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br><span class="line">  </span><br><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br></pre></td></tr></table></figure></p><p><br>从结果来看，具有随机属性。</p><p>@RibbonClient 注解属性中，name并非是一个数组，也就是说只能指定一个服务实例。那么基于上述情况，如果还存在另外一个服务，比如 SOFABOOTHELLOSERVICE ，那么对于此服务的调用会是什么情况呢？<br><br><br>先向注册中心注册两个服务：<strong>HELLOSOFABOOTSERVICE 和 </strong>HELLOSOFASERVICE<em>**</em></p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2018/png/97619/1545893497944-09c15478-13ed-4480-a9ae-cfb6ffebef05.png#wh=1464x179" alt="image.png"></p><p>修改 RibbonController ，增加一个 /helloBoot 资源地址：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://HELLOSOFASERVICE/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/helloBoot"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloBoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://HELLOSOFABOOTSERVICE/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重启启动当前服务。</p><p>浏览器中输入：<a href="http://localhost:8889/hello" target="_blank" rel="noopener">http://localhost:8889/hello</a> ，验证结果满足随机调用。<br>浏览器中输入：<a href="http://localhost:8889/helloBoot" target="_blank" rel="noopener">http://localhost:8889/helloBoot</a> ，验证结果满足轮询调用。<br><br></p><h3 id="基于配置文件的负载均衡策略设置"><a href="#基于配置文件的负载均衡策略设置" class="headerlink" title="基于配置文件的负载均衡策略设置"></a>基于配置文件的负载均衡策略设置</h3><p>个人感觉基于配置文件配置方式更加直观，而且对于多个服务对应不同的负载策略设置也更加清晰，下面对HELLOSOFASERVICE 和  HELLOSOFABOOTSERVICE 均使用随机策略。<br><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">HELLOSOFASERVICE:</span></span><br><span class="line"><span class="attr">  ribbon:</span></span><br><span class="line"><span class="attr">    NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br><span class="line"></span><br><span class="line"><span class="attr">HELLOSOFABOOTSERVICE:</span></span><br><span class="line"><span class="attr">  ribbon:</span></span><br><span class="line"><span class="attr">    NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure></p><p><br>启动类中删除以下注解配置：<br>@RibbonClient(name = “HELLOSOFASERVICE”, configuration = RibbonRandomLBConfiguration.class)</p><p>重启启动当前服务。</p><p>浏览器中输入：<a href="http://localhost:8889/hello" target="_blank" rel="noopener">http://localhost:8889/hello</a> ，验证结果满足随机调用。<br>浏览器中输入：<a href="http://localhost:8889/helloBoot" target="_blank" rel="noopener">http://localhost:8889/helloBoot</a> ，验证结果满足随机调用。</p>]]></content>
      
      
      <categories>
          
          <category> spring cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring cloud </tag>
            
            <tag> Ribbon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringCloud-声明式服务调用 Feign</title>
      <link href="/2018/12/31/springcoud-feign-project/"/>
      <url>/2018/12/31/springcoud-feign-project/</url>
      
        <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK<br></td><td>1.8.0_162<br></td></tr><tr><td>SOFABoot/SpringBoot<br></td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE<br></td></tr><tr><td>SpringCloud<br></td><td>Finchley.RC1<br></td></tr><tr><td>IDE<br></td><td>IDEA<br></td></tr></tbody></table><h2 id="工程背景"><a href="#工程背景" class="headerlink" title="工程背景"></a>工程背景</h2><p>本节将会创建一个 sofa-eureka-consumer-feign 工程，使用 Feign 提供的 web 客户端来访问 sofa-eureka-provider 发布的服务。同时也基于此工程验证基于 Feign 实现的负载均衡。<br><br></p><h2 id="新建-sofa-eureka-consumer-feign"><a href="#新建-sofa-eureka-consumer-feign" class="headerlink" title="新建 sofa-eureka-consumer-feign"></a>新建 sofa-eureka-consumer-feign</h2><p><br><br>本工程继续使用《SpringCloud-Eureka 服务注册》中的父工程来构建。<br><br><br>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p><ul><li>artifactId：sofa-eurek-consumer-feign</li></ul><h3 id="修改pom文件"><a href="#修改pom文件" class="headerlink" title="修改pom文件"></a>修改pom文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-server-center<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencys</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencys</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.port=8888</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:8761/eureka/</span><br><span class="line">spring.application.name=eureka-consumer-feign</span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>这里需要添加 @EnableEurekaClient 和 @EnableFeignClients 两个注解。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaEurekaConsumerFeignApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaEurekaConsumerFeignApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="资源类"><a href="#资源类" class="headerlink" title="资源类"></a>资源类</h3><ul><li>com.alipay.sofa.cloud.service 包下新建  HelloSOFAService</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"helloSOFAService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloSOFAService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>com.alipay.sofa.cloud.controller 包下新建  FeignController</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloSOFAService helloSOFAService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloSOFAService.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动-amp-验证"><a href="#启动-amp-验证" class="headerlink" title="启动 &amp; 验证"></a>启动 &amp; 验证</h3><p>启动当前工程，在此之前请以此启动 注册中心 sofa-eureka-server-center 和 sofa-eureka-provider 两个工程。</p><blockquote><p>注：这里我启动了两个 provider 工程</p></blockquote><p>浏览器输入：http:localhost:8888/hello，观察到浏览器中依次展示：</p><p>Hello SOFA! Now Port is 8081 And hostname is HelloSOFAService<br>Hello SOFA! Now Port is 8082 And hostname is HelloSOFAService<br>Hello SOFA! Now Port is 8081 And hostname is HelloSOFAService<br>Hello SOFA! Now Port is 8082 And hostname is HelloSOFAService<br><br><br>这里可以看待 通过 feign 提供的客户端能力已经访问到了远程服务，由于 feign 集成了 ribbon 因此也就默认实现了负载均衡的能力。从结果来看，默认的负载均衡策略是轮询。</p>]]></content>
      
      
      <categories>
          
          <category> spring cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring cloud </tag>
            
            <tag> Feign </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Cloud-Eureka Client 原理解析</title>
      <link href="/2018/12/31/springcoud-eureka-client-analysis/"/>
      <url>/2018/12/31/springcoud-eureka-client-analysis/</url>
      
        <content type="html"><![CDATA[<p>前面一些 demo 中已经介绍了如何使用SOFABoot 来集成 Spring Cloud Netflix Eureka 组件。本篇将来先解析下 Eureka Client 的工作原理。</p><h2 id="Netflix-和-SpringCloud"><a href="#Netflix-和-SpringCloud" class="headerlink" title="Netflix 和 SpringCloud"></a>Netflix 和 SpringCloud</h2><p>spring-cloud-commons 模块是 spring 在分布式领域上(服务发现，服务注册，断路器，负载均衡)的规范定义。spring-cloud-netflix 是基于此规范的具体实现，Netflix OSS 里的各种组件也都实现了这个 commons 规范。关系如下：<br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2018/png/97619/1545979991419-08ae3e7c-3125-4a3e-8a9d-f43ab6c3322b.png#wh=626x332" alt="image.png"></p><h2 id="Spring-Cloud-Netflix-Eureka-服务发现实现原理"><a href="#Spring-Cloud-Netflix-Eureka-服务发现实现原理" class="headerlink" title="Spring Cloud Netflix Eureka 服务发现实现原理"></a>Spring Cloud Netflix Eureka 服务发现实现原理</h2><p>基于上图，这里以 Eureka 中的服务发现为例，来具体讲下是如何实现的。Spring Cloud common 中提供了用于服务发现的两个关键类：DiscoveryClient 接口 和 EnableDiscoveryClient 注解。<br><br></p><h3 id="DiscoveryClient-接口"><a href="#DiscoveryClient-接口" class="headerlink" title="DiscoveryClient 接口"></a>DiscoveryClient 接口</h3><p>下面这张图描述的是在服务发现这个功能上，SpringCloud 是如何与 Netflix 整合的。<br>在 spring-cloud-netflix-eureka-client 中对 Spring Cloud Common 中的 DiscoveryClient 接口进行了实现，实现类是 EurekaDiscoveryClient 。<br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2018/png/97619/1545981516158-eabcaa30-83e2-439c-9198-77c1f14b6c79.png#wh=577x416" alt="image.png"><br>DiscoveryClient 的接口定义与方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DiscoveryClient表示服务发现常用的读取操作，例如Netflix Eureka或consul.io</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spencer Gibb</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscoveryClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现描述</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the description</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">description</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取与特定serviceId关联的所有ServiceInstances</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> serviceId the serviceId to query</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a List of ServiceInstance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;ServiceInstance&gt; <span class="title">getInstances</span><span class="params">(String serviceId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回所有已知的服务ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getServices</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EurekaDiscoveryClient 中实现了这几个方法，但是 EurekaDiscoveryClient 自身没有实现如何与服务端交互的逻辑，而是通过 com.netflix.DiscoveryClient 类来完成。所以 spring-cloud-netflix-eureka-client 干的事情就是实现了 Spring Cloud Common 规范，然后在实现上包装了 netflix 。</p><h3 id="EnableDiscoveryClient-注解"><a href="#EnableDiscoveryClient-注解" class="headerlink" title="@EnableDiscoveryClient 注解"></a>@EnableDiscoveryClient 注解</h3><p><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import</span>(EnableDiscoveryClientImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableDiscoveryClient &#123;</span><br><span class="line">  <span class="comment">//是否自动注册，默认是true。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">autoRegister</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>EnableDiscoveryClientImportSelector 将会从 META-INF/spring.factories 里找出 key 为org.springframework.cloud.client.discovery.EnableDiscoveryClient 的类。</p><p>对于 autoRegister ：</p><ul><li>如果自动注册属性为true，会在找出的这些类里再加上一个类：AutoServiceRegistrationConfiguration， AutoServiceRegistrationConfiguration 内部会使用@EnableConfigurationProperties(AutoServiceRegistrationProperties.class) 触发构造AutoServiceRegistrationProperties 这个 bean。像eureka，nacos，它们的自动化配置类里都使用了@ConditionalOnBean(AutoServiceRegistrationProperties.class) 来确保存在AutoServiceRegistrationProperties 这个 bean 存在的时候才会构造 AutoServiceRegistration 进行注册。</li><li>如果自动注册属性为 false，在Environment 里加一个 PropertySource，内部的配置项是spring.cloud.service-registry.auto-registration.enabled，值是false(代表不构造AutoServiceRegistrationProperties.class)。这样 eureka 就不会注册。</li></ul><p><br><br>对应上面这段逻辑的代码如下：</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2018/png/97619/1545982472444-7e4995bb-af73-4ca2-9942-5c5ee1ea9901.png#wh=655x204" alt="image.png"></p><p>spring-cloud-netflix-eureka-client 自己也提供了一个注解 EnableEurekaClient，其作用于这个注解一样</p><h2 id="Eureka-架构图"><a href="#Eureka-架构图" class="headerlink" title="Eureka 架构图"></a>Eureka 架构图</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2018/png/97619/1545978817975-4b633117-66eb-4806-90a1-c6a1d419f494.png#wh=712x323" alt="image.png"></p><ul><li>consumer  : 服务消费方，eureka client 角色，可以从 eureka server 上拉取到其他已注册服务的信息，从而根据这些信息找到自己所需的服务，然后发起远程调用。</li><li>provider : 服务提供方，eureka client 角色，可以向 eureka server 上注册和更新自己的信息，当然作为 eureka client ，它也可以从server 上获取到其他服务的信息。<br></li><li>Eureka server : 服务注册中心，提供服务注册和服务发现功能；</li><li>同步复制 ： eureka server 之间进行注册服务信息的同步，这样可以保证集群中每个server 都能提供完整的服务信息。</li></ul><blockquote><p>关于 AWS 上 Regin 和 Availability Zone 的概念，请自行查阅相关资料</p></blockquote><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="配置信息读取"><a href="#配置信息读取" class="headerlink" title="配置信息读取"></a>配置信息读取</h3><p>Eureka Client的自动配置类是 org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration ，这里面主要就负责了一些配置信息的服务诸如 DiscoveryClient 、EurekaServiceRegistry等主要bean的初始化工作。</p><p>另外还有一个 EurekaDiscoveryClientConfiguration 类，负责配置自动注册和应用的健康检查器初始化。</p><h4 id="读取-eureka-client"><a href="#读取-eureka-client" class="headerlink" title="读取 eureka.client.*"></a>读取 eureka.client.*</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = EurekaClientConfig.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="function"><span class="keyword">public</span> EurekaClientConfigBean <span class="title">eurekaClientConfigBean</span><span class="params">(ConfigurableEnvironment env)</span> </span>&#123;</span><br><span class="line">EurekaClientConfigBean client = <span class="keyword">new</span> EurekaClientConfigBean();</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"bootstrap"</span>.equals(<span class="keyword">this</span>.env.getProperty(<span class="string">"spring.config.name"</span>))) &#123;</span><br><span class="line">    <span class="comment">// 默认情况下，我们不会在引导过程中注册，但是以后会有另一个机会。</span></span><br><span class="line">    client.setRegisterWithEureka(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EurekaClientConfigBean 封装的是 eureka client 和 eureka server 交互所需要的配置信息，比如前面demo工程中的 eureka.client.service-url.defaultZone 的配置。</p><h4 id="读取-eureka-instance"><a href="#读取-eureka-instance" class="headerlink" title="读取 eureka.instance.*"></a>读取 eureka.instance.*</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = EurekaInstanceConfig.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="function"><span class="keyword">public</span> EurekaInstanceConfigBean <span class="title">eurekaInstanceConfigBean</span><span class="params">(InetUtils inetUtils,</span></span></span><br><span class="line"><span class="function"><span class="params">ManagementMetadataProvider managementMetadataProvider)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 代码较长，此处省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EurekaInstanceConfigBean 封装的是 eureka client 自身实例的配置信息，提供服务注册的基本元数据信息。</p><h3 id="核心组件-bean-初始化"><a href="#核心组件-bean-初始化" class="headerlink" title="核心组件 bean 初始化"></a>核心组件 bean 初始化</h3><p>这里也实例化了一些核心的组件bean。</p><h4 id="ApplicationInfoManager"><a href="#ApplicationInfoManager" class="headerlink" title="ApplicationInfoManager"></a>ApplicationInfoManager</h4><ul><li>EurekaClientConfiguration#eurekaApplicationInfoManager</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = ApplicationInfoManager.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApplicationInfoManager <span class="title">eurekaApplicationInfoManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">EurekaInstanceConfig config)</span> </span>&#123;</span><br><span class="line">  InstanceInfo instanceInfo = <span class="keyword">new</span> InstanceInfoFactory().create(config);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ApplicationInfoManager(config, instanceInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>RefreshableEurekaClientConfiguration#eurekaApplicationInfoManager<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = ApplicationInfoManager.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="meta">@org</span>.springframework.cloud.context.config.annotation.RefreshScope</span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ApplicationInfoManager <span class="title">eurekaApplicationInfoManager</span><span class="params">(EurekaInstanceConfig config)</span> </span>&#123;</span><br><span class="line">  InstanceInfo instanceInfo = <span class="keyword">new</span> InstanceInfoFactory().create(config);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ApplicationInfoManager(config, instanceInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>RefreshScope ，被此注解标注的情况下，将会被动态刷新。包括属性信息等，注意，对于动态刷新，被RefreshScope标记的类不能是final的。</p></blockquote><p><br><br>ApplicationInfoManager 是应用信息管理器，用于管理服务实例的信息类 InstanceInfo 和服务实例的配置信息类 EurekaInstanceConfig 。</p><h4 id="DiscoveryClient"><a href="#DiscoveryClient" class="headerlink" title="DiscoveryClient"></a>DiscoveryClient</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DiscoveryClient <span class="title">discoveryClient</span><span class="params">(EurekaInstanceConfig config, EurekaClient client)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> EurekaDiscoveryClient(config, client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DiscoveryClient ，前面说到，这个类是Spring Cloud 中用于服务发现使用的客户端接口。注意这里是SpringCloud提供的接口，不是netflix中的类。</p><h4 id="EurekaServiceRegistry"><a href="#EurekaServiceRegistry" class="headerlink" title="EurekaServiceRegistry"></a>EurekaServiceRegistry</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EurekaServiceRegistry <span class="title">eurekaServiceRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> EurekaServiceRegistry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EurekaServiceRegistry 是 ServiceRegistry 的实现类。ServiceRegistry 是 SpringCloud 提供了注册和注销等方法，这些方法允许用户提供自定义注册服务。</p><h4 id="EurekaRegistration"><a href="#EurekaRegistration" class="headerlink" title="EurekaRegistration"></a>EurekaRegistration</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(AutoServiceRegistrationProperties.class)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"spring.cloud.service-registry.auto-registration.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> EurekaRegistration <span class="title">eurekaRegistration</span><span class="params">(EurekaClient eurekaClient, CloudEurekaInstanceConfig instanceConfig, ApplicationInfoManager applicationInfoManager, ObjectProvider&lt;HealthCheckHandler&gt; healthCheckHandler)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> EurekaRegistration.builder(instanceConfig)</span><br><span class="line">.with(applicationInfoManager)</span><br><span class="line">.with(eurekaClient)</span><br><span class="line">.with(healthCheckHandler)</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 ServiceRegistry 实现都有自己的 Registry 实现。</p><ul><li>ZookeeperRegistration -&gt; ZookeeperServiceRegistry</li><li>ZookeeperRegistration -&gt; EurekaServiceRegistry</li><li>ConsulRegistration       -&gt; ConsulServiceRegistry</li></ul><p>如果你需要自定义实现 ServiceRegistry ，则也不要提供一个 Registration  的实现。<br><br></p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>服务发现的基本情况在上面已经提到了，但是由于 SpingCloud 中并没有提供具体的交互操作而是由 com.netflix.discovery.DiscoveryClient 来完成具体工作。所以关于服务服务发现这里就直接围绕这个类来展开。</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2018/png/97619/1545987763227-a43b1417-492e-4a33-a19a-1d5aefec0ea1.png#wh=298x167" alt="image.png"></p><h3 id="LookopService"><a href="#LookopService" class="headerlink" title="LookopService"></a>LookopService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LookupService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 根据服务实例注册的appName 来获取 Application</span></span><br><span class="line">    <span class="function">Application <span class="title">getApplication</span><span class="params">(String appName)</span></span>;</span><br><span class="line">    <span class="comment">// 返回当前注册表中所有的服务实例信息</span></span><br><span class="line">    <span class="function">Applications <span class="title">getApplications</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 根据服务实例Id获取服务实例信息</span></span><br><span class="line">    <span class="function">List&lt;InstanceInfo&gt; <span class="title">getInstancesById</span><span class="params">(String id)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个可能的服务器，以处理来自从eureka接收到的注册表信息的请求。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@virtualHostname</span> 与服务器关联的虚拟主机名。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@secure</span> 指示是HTTP还是HTTPS请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">InstanceInfo <span class="title">getNextServerFromEureka</span><span class="params">(String virtualHostname, <span class="keyword">boolean</span> secure)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LookupService 接口的作用就是用于查找活动服务实例；总共提供了四个方法，很好理解。每个方法的作用见注释。</p><h3 id="EurekaClient"><a href="#EurekaClient" class="headerlink" title="EurekaClient"></a>EurekaClient</h3><p>EurekaClient 也是一个接口，集成并且扩展了 LookupService。<br><br></p><blockquote><p>This interface does NOT try to clean up the current client interface for eureka 1.x. Rather it tries<br>to provide an easier transition path from eureka 1.x to eureka 2.x.<br>从这来看，EurekaClient 的存在是为了给 Eureka1.x 向 Eureka 2.x 升级提供容错能力。</p></blockquote><p>EurekaClient 在 LookupService 基础上扩展了很多方法，如下：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EurekaClient</span> <span class="keyword">extends</span> <span class="title">LookupService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 省去@Deprecated方法和获取服务实例信息的接口方法</span></span><br><span class="line"><span class="comment">// 注册健康检查处理器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerHealthCheck</span><span class="params">(HealthCheckHandler healthCheckHandler)</span></span>;</span><br><span class="line"><span class="comment">// 监听client服务信息的更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerEventListener</span><span class="params">(EurekaEventListener eventListener)</span></span>;</span><br><span class="line">   <span class="comment">// 取消监听</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unregisterEventListener</span><span class="params">(EurekaEventListener eventListener)</span></span>;</span><br><span class="line"> <span class="comment">// 获取当前健康检查处理器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HealthCheckHandler <span class="title">getHealthCheckHandler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 关闭 eureka 客户端。还向eureka服务器发送撤销注册请求。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// EurekaClientConfig</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EurekaClientConfig <span class="title">getEurekaClientConfig</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="comment">// ApplicationInfoManager</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationInfoManager <span class="title">getApplicationInfoManager</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>HealthCheckHandler 这个是用于检查当前客户端状态的，这个在后面心跳机制里面会说道。</p><h3 id="DiscoveryClient-1"><a href="#DiscoveryClient-1" class="headerlink" title="DiscoveryClient"></a>DiscoveryClient</h3><p>com.netflix.discovery.DiscoveryClient，这个类会在构造函数中完成一系列重要的操作，如：拉取注册表信息，服务注册，初始化心跳机制，缓存刷新，按需注册定时任务等等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DiscoveryClient(ApplicationInfoManager applicationInfoManager, </span><br><span class="line"> EurekaClientConfig config, </span><br><span class="line">                AbstractDiscoveryClientOptionalArgs args,</span><br><span class="line">                Provider&lt;BackupRegistry&gt; backupRegistryProvider) &#123;</span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>几个参数的释义如下：</p><ul><li>applicationInfoManager ：应用信息管理器</li><li>config ：client 与 server 交互的配置信息</li><li>args ：客户端提供的过滤器类型(支持jersey1和jersey2)，后面用来构建 EurekaTransport</li><li>backupRegistryProvider ： 备份注册中心</li></ul><h3 id="服务发现-1"><a href="#服务发现-1" class="headerlink" title="服务发现"></a>服务发现</h3><p>下面代码片段也是在 DiscoveryClient 的构造函数里面的，这里就是拉取注册服务信息的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(<span class="keyword">false</span>)) &#123;</span><br><span class="line">fetchRegistryFromBackup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clientConfig.shouldFetchRegistry() 这个方法拿到的就是配置文件中 eureka.client.fetch-registry 的值，默认为true，表示从 eureka server 拉取注册表信息。<br><br><br>fetchRegistry(boolean)是从 eureka server 拉取注册信息的方法，参数用于表示是否是强制拉取全量的注册信息；此方法除非在协调eureka服务器和客户端注册表信息方面存在问题，否则此方法只尝试在第一次进行全量获取，后面均是增量获取。</p><p>fetchRegistryFromBackup() 如果 eureka server 服务不可用，则采用的备用方案。<br><br></p><h4 id="底层通信实现-EurekaTransport"><a href="#底层通信实现-EurekaTransport" class="headerlink" title="底层通信实现 EurekaTransport"></a>底层通信实现 EurekaTransport</h4><p><br><br>EurekaTransport 是 DiscoveryClient 的内部类，EurekaTransport 封装了具体的基于 jersey 的底层通信实现。<br><br></p><h4 id="FetchRegistry"><a href="#FetchRegistry" class="headerlink" title="FetchRegistry"></a>FetchRegistry</h4><p><br><br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2018/png/97619/1545996920110-1317ecc6-231e-4184-b534-c2dd9d69b6ba.png#wh=512x383" alt="image.png"><br>上图为拉取注册信息的整个过程。对于黄色贴条上的条件，如果满足其中一个，则都会进行全量拉取；否则进行增量拉取。计算 hash 值是为了后面可以与server端应用信息的进行对比，用于感知是否需要重新进行拉取操作。<br><br></p><h4 id="全量拉取"><a href="#全量拉取" class="headerlink" title="全量拉取"></a>全量拉取</h4><h4 id="增量拉取"><a href="#增量拉取" class="headerlink" title="增量拉取"></a>增量拉取</h4><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><p>服务注册逻辑也是在 DiscoveryClient 的构造函数中完成，代码片段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka() &amp;&amp; clientConfig.shouldEnforceRegistrationAtInit()) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!register() ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Registration error at startup. Invalid server response."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">    logger.error(<span class="string">"Registration error at startup: &#123;&#125;"</span>, th.getMessage());</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(th);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向server端注册需要满足的两个条件是：1、允许向server端注册  2、是否在客户端初始化期间强制注册<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">register</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  logger.info(PREFIX + <span class="string">"&#123;&#125;: registering service..."</span>, appPathIdentifier);</span><br><span class="line">  EurekaHttpResponse&lt;Void&gt; httpResponse;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  httpResponse = eurekaTransport.registrationClient.register(instanceInfo);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.warn(PREFIX + <span class="string">"&#123;&#125; - registration failed &#123;&#125;"</span>, appPathIdentifier, e.getMessage(), e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">  logger.info(PREFIX + <span class="string">"&#123;&#125; - registration status: &#123;&#125;"</span>, appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> httpResponse.getStatusCode() == <span class="number">204</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过 eurekaTransport 对象，基于 REST 调用向 eureka server 进行服务注册。</p><h2 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h2><p>心跳机制的初始化工作也是在 DiscoveryClient 构造函数中完成。在DiscoveryClient构造函数的最后，有一个初始化调度任务的方法，在这个方法里就包括心跳的初始化。</p><p>heartbeatExecutor 心跳线程池：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">heartbeatExecutor = new ThreadPoolExecutor(</span><br><span class="line">                    1, clientConfig.getHeartbeatExecutorThreadPoolSize(), 0, TimeUnit.SECONDS,</span><br><span class="line">                    new SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                    new ThreadFactoryBuilder()</span><br><span class="line">                            .setNameFormat(&quot;DiscoveryClient-HeartbeatExecutor-%d&quot;)</span><br><span class="line">                            .setDaemon(true)</span><br><span class="line">                            .build()</span><br></pre></td></tr></table></figure><p>scheduler 提交周期执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Heartbeat timer</span></span><br><span class="line">scheduler.schedule(</span><br><span class="line">                  <span class="keyword">new</span> TimedSupervisorTask(</span><br><span class="line">                  <span class="string">"heartbeat"</span>,</span><br><span class="line">                  scheduler,</span><br><span class="line">                  heartbeatExecutor,</span><br><span class="line">                  renewalIntervalInSecs,</span><br><span class="line">                  TimeUnit.SECONDS,</span><br><span class="line">                  expBackOffBound,</span><br><span class="line">                  <span class="keyword">new</span> HeartbeatThread()</span><br><span class="line">                  ),</span><br><span class="line">renewalIntervalInSecs, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></p><p>TimedSupervisorTask 是 eureka 中自动调节间隔的周期性任务类。HeartbeatThread 是具体执行任何的线程，run方法中执行的就是 renew() 续期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">renew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 eurekaTransport 来与 server 通信续期</span></span><br><span class="line">    httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, <span class="keyword">null</span>);</span><br><span class="line">    logger.debug(PREFIX + <span class="string">"&#123;&#125; - Heartbeat status: &#123;&#125;"</span>, appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">    <span class="comment">// 404 标识当前服务实例不存在</span></span><br><span class="line">    <span class="keyword">if</span> (httpResponse.getStatusCode() == <span class="number">404</span>) &#123;</span><br><span class="line">      <span class="comment">// 记录心跳次数</span></span><br><span class="line">      REREGISTER_COUNTER.increment();</span><br><span class="line">      logger.info(PREFIX + <span class="string">"&#123;&#125; - Re-registering apps/&#123;&#125;"</span>, appPathIdentifier, instanceInfo.getAppName());</span><br><span class="line">      <span class="keyword">long</span> timestamp = instanceInfo.setIsDirtyWithTime();</span><br><span class="line">      <span class="comment">// 重新注册</span></span><br><span class="line">      <span class="keyword">boolean</span> success = register();</span><br><span class="line">      <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      instanceInfo.unsetIsDirty(timestamp);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 200 状态正常</span></span><br><span class="line">    <span class="keyword">return</span> httpResponse.getStatusCode() == <span class="number">200</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    logger.error(PREFIX + <span class="string">"&#123;&#125; - was unable to send heartbeat!"</span>, appPathIdentifier, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务下线"><a href="#服务下线" class="headerlink" title="服务下线"></a>服务下线</h2><p>关闭 eureka client，还向 eureka server 发送撤销注册请求。该方法在DiscoveryClient#shutdown 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 保证原子操作</span></span><br><span class="line">        <span class="keyword">if</span> (isShutdown.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            logger.info(<span class="string">"Shutting down DiscoveryClient ..."</span>);</span><br><span class="line">            <span class="keyword">if</span> (statusChangeListener != <span class="keyword">null</span> &amp;&amp; applicationInfoManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 应用管理器取消状态监听</span></span><br><span class="line">                applicationInfoManager.unregisterStatusChangeListener(statusChangeListener.getId());</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 清理任务调度执行</span></span><br><span class="line">            cancelScheduledTasks();</span><br><span class="line">            <span class="comment">// If APPINFO was registered</span></span><br><span class="line">            <span class="keyword">if</span> (applicationInfoManager != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; clientConfig.shouldRegisterWithEureka()</span><br><span class="line">                    &amp;&amp; clientConfig.shouldUnregisterOnShutdown()) &#123;</span><br><span class="line">              <span class="comment">//设置服务实例状态为 DOWN</span></span><br><span class="line">                applicationInfoManager.setInstanceStatus(InstanceStatus.DOWN);</span><br><span class="line">              <span class="comment">//注销注册</span></span><br><span class="line">                unregister();</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 关闭 jersey 客户端</span></span><br><span class="line">            <span class="keyword">if</span> (eurekaTransport != <span class="keyword">null</span>) &#123;</span><br><span class="line">                eurekaTransport.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">            heartbeatStalenessMonitor.shutdown();</span><br><span class="line">            registryStalenessMonitor.shutdown();</span><br><span class="line">            logger.info(<span class="string">"Completed shut down of DiscoveryClient"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring cloud </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringCloud-Eureka 服务发现</title>
      <link href="/2018/12/31/springcoud-eureka-discovery/"/>
      <url>/2018/12/31/springcoud-eureka-discovery/</url>
      
        <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK<br></td><td>1.8.0_162<br></td></tr><tr><td>SOFABoot/SpringBoot<br></td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE<br></td></tr><tr><td>SpringCloud<br></td><td>Finchley.RC1<br></td></tr><tr><td>IDE<br></td><td>IDEA<br></td></tr></tbody></table><h2 id="工程背景"><a href="#工程背景" class="headerlink" title="工程背景"></a>工程背景</h2><p>本案例使用 SOFABoot 3.0.x 版本集成 SringCloud F版。工程如下：</p><ul><li>sofa-eureka-consumer-feign      服务消费方</li></ul><p>本工程的父工程继续使用《SpringCloud-Eureka 服务注册》文中新建的父工程。</p><h2 id="新建-sofa-eureka-consumer-discovery"><a href="#新建-sofa-eureka-consumer-discovery" class="headerlink" title="新建 sofa-eureka-consumer-discovery"></a>新建 sofa-eureka-consumer-discovery</h2><p>这里我们通过 sofa-eureka-consumer-discovery 这个工程来手动发现服务。<br><br><br>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p><ul><li>artifactId：sofa-eureka-consumer-discovery。</li></ul><h3 id="修改-pom-文件"><a href="#修改-pom-文件" class="headerlink" title="修改 pom 文件"></a>修改 pom 文件</h3><p>引入 spring-cloud-starter-netflix-eureka-client 依赖。<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-consumer-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.port=8088</span><br><span class="line">spring.application.name=sofa-eureka-discovery</span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/</span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaEurekaConsumerDiscoveryApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaEurekaConsumerDiscoveryApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务获取"><a href="#服务获取" class="headerlink" title="服务获取"></a>服务获取</h3><p>这里通过 DiscoveryClient 对像手动获取到 HELLOSOFASERVICE 服务对应的所有实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscoveryController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/instance"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(<span class="string">"HELLOSOFASERVICE"</span>);</span><br><span class="line">        System.out.println(<span class="string">"current service size = "</span> + discoveryClient.getServices().size());</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>( String s :  discoveryClient.getServices())&#123;</span><br><span class="line">            stringBuilder.append(<span class="string">"services="</span> + s).append(<span class="string">"\n"</span>);</span><br><span class="line">            List&lt;ServiceInstance&gt; serviceInstances =  discoveryClient.getInstances(s);</span><br><span class="line">            <span class="keyword">for</span>(ServiceInstance si : serviceInstances)&#123;</span><br><span class="line">                stringBuilder.append(<span class="string">"url="</span>).append(si.getUri()).append(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuilder.append(<span class="string">"instance num"</span>).append(<span class="string">"="</span>).append(list.size());</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动-amp-验证"><a href="#启动-amp-验证" class="headerlink" title="启动 &amp; 验证"></a>启动 &amp; 验证</h3><p>启动当前工程，在此之前确保 注册中心和服务提供工程均已正常启动。然后在浏览器中输入：http:localhost:8088/instance</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2018/png/97619/1545834220248-d001f258-de55-44a1-a94b-e67761fa2159.png#wh=871x104" alt="image.png"><br>可以看到获取到的实例信息与注册中心上的实例信息是匹配的。</p>]]></content>
      
      
      <categories>
          
          <category> spring cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring cloud </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringCloud-Eureka 服务注册</title>
      <link href="/2018/12/31/springcoud-eureka-register/"/>
      <url>/2018/12/31/springcoud-eureka-register/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JDK 8 + SpringBoot 2.0.7 + SpringCloud Finchley.RC1</p></blockquote><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK<br></td><td>1.8.0_162<br></td></tr><tr><td>SOFABoot/SpringBoot<br></td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE<br></td></tr><tr><td>SpringCloud<br></td><td>Finchley.RC1<br></td></tr><tr><td>IDE<br></td><td>IDEA<br></td></tr></tbody></table><h2 id="工程背景"><a href="#工程背景" class="headerlink" title="工程背景"></a>工程背景</h2><p>本案例使用 SOFABoot 3.0.x 版本集成 SringCloud F版。工程如下：</p><ul><li>sofa-eureka-server         服务注册中心</li><li>sofa-eureka-provider      服务提供方</li><li>sofa-eureka-comsumer   服务消费方</li></ul><p>本工程都是在同一个父工程下面的，因此工程构建开始会新建一个 SOFABoot 工程作为父工程。</p><h2 id="新建父工程"><a href="#新建父工程" class="headerlink" title="新建父工程"></a>新建父工程</h2><p>这里父工程直接新建一个SpringBoot 工程。可以使用 IDEA 的生成，也可以通过 <a href="http://www.sofastack.tech/sofa-boot/docs/QuickStart" target="_blank" rel="noopener">SOFABoot 快速开始</a> 新建一个 SpringBoot 工程，删除 src 目录，然后修改 pom.xml 文件。</p><ul><li>gourpId : com.alipay.sofa</li><li>artifactId : sofa-eureka-parent</li></ul><h3 id="parent-依赖修改"><a href="#parent-依赖修改" class="headerlink" title="parent 依赖修改"></a><strong>parent 依赖修改</strong></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofaboot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="管控-SpringCloud-依赖"><a href="#管控-SpringCloud-依赖" class="headerlink" title="管控 SpringCloud 依赖"></a>管控 SpringCloud 依赖</h3><p>在主 pom 里面加入 SpringCloud 的依赖管控。版本为 Finchley.RC1<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.RC1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="配置-SpringCloud-仓库"><a href="#配置-SpringCloud-仓库" class="headerlink" title="配置 SpringCloud 仓库"></a>配置 SpringCloud 仓库</h3><p>在主pom.xml 中添加如下配置<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Milestones<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>OK，到这里，父工程创建完毕。</p><h2 id="新建-sofa-eureka-server-center"><a href="#新建-sofa-eureka-server-center" class="headerlink" title="新建 sofa-eureka-server-center"></a>新建 sofa-eureka-server-center</h2><p>sofa-eureka-server-center 作为注册中心的服务端。</p><p>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p><ul><li>artifactId：sofa-eureka-server-center。</li></ul><h3 id="pom-文件修改"><a href="#pom-文件修改" class="headerlink" title="pom 文件修改"></a>pom 文件修改</h3><p>引入 spring-cloud-starter-netflix-eureka-server 依赖，如下：<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-server-center<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="新建资源文件-application-yml"><a href="#新建资源文件-application-yml" class="headerlink" title="新建资源文件 application.yml"></a>新建资源文件 application.yml</h3><p>在 /src/main/resources 目录下新建 application.yml 或者 application.properties。这里以.yml文件为例：<br><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span>    <span class="comment">#指定服务端口</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">sofa-eureka-server</span></span><br></pre></td></tr></table></figure></p><blockquote><p>配置文件后面统一说明</p></blockquote><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>在 /src/main/resources 目录下新建 com.alipay.sofa.cloud 包目录，并且在当前包路劲下新建 SofaEurekaServerApplication 类，并且类上加上 @EnableEurekaServer 注解。<br><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaEurekaServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaEurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="启动程序-amp-验证"><a href="#启动程序-amp-验证" class="headerlink" title="启动程序 &amp; 验证"></a>启动程序 &amp; 验证</h3><p>启动当前应用。并且浏览器中输入：<a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a></p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2018/png/97619/1545831064461-b02a8aeb-cecc-4e07-95a2-1501a8fbd211.png#wh=902x453" alt="image.png"></p><p>服务正常运行，界面如上图所示；此时还没有服务注册进来，因此红色框内显示 ：No instances available</p><h2 id="新建-sofa-eureka-provider"><a href="#新建-sofa-eureka-provider" class="headerlink" title="新建 sofa-eureka-provider"></a>新建 sofa-eureka-provider</h2><p>sofa-eureka-provider 作为服务提供方，将会向注册中心 sofa-eureka-server-center 上注册服务。</p><p>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p><ul><li>artifactId：sofa-eureka-provider。</li></ul><h3 id="pom-文件修改-1"><a href="#pom-文件修改-1" class="headerlink" title="pom 文件修改"></a>pom 文件修改</h3><p>引入 spring-cloud-starter-netflix-eureka-client 和 spring-boot-starter-web 依赖，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="新建资源文件"><a href="#新建资源文件" class="headerlink" title="新建资源文件"></a>新建资源文件</h3><p>在 /src/main/resources 目录下新建 application.yml 或者 application.properties。这里以.yml文件为例：<br><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span>  <span class="comment">#指定注册中心地址</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">HelloSOFAService</span>   <span class="comment">#服务名称</span></span><br></pre></td></tr></table></figure></p><h3 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h3><p>在 /src/main/resources 目录下新建 com.alipay.sofa.cloud 包目录，并且在当前包路劲下新建 SofaEurekaProviderApplication 类，并且类上加上 @EnableEurekaClient 注解。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaEurekaProviderApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaEurekaProviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="服务提供类"><a href="#服务提供类" class="headerlink" title="服务提供类"></a>服务提供类</h3><p>这里在  com.alipay.sofa.cloud.controller 包下新建 SofaController 类。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.application.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String hostname;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello SOFA! Now Port is "</span>+port +<span class="string">" And hostname is "</span> +hostname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br>这里在接口中返回 hostname 和 port ，方便后面验证负载均衡测试使用。</p><h3 id="启动程序-amp-验证-1"><a href="#启动程序-amp-验证-1" class="headerlink" title="启动程序 &amp; 验证"></a>启动程序 &amp; 验证</h3><p>在启动 sofa-eureka-provider 之前，需要先启动 sofa-wureka-server-center 。两个都启动成功之后，浏览器输入：<a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a> <br><br><br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2018/png/97619/1545831934420-aeb021ad-170b-44c5-a031-418c2ed70a20.png#wh=894x84" alt="image.png"></p><p>此时我将 sofa-eureka-provider 中的配置文件的端口修改为 8081，再注册一个。<br><br><br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2018/png/97619/1545832150528-4e73d5c5-41cc-4ccc-a016-4c8f0e5e0407.png#wh=670x80" alt="image.png"><br><br><br>可以看到 服务为 HELLOSOFASERVICE 的有两个服务提供方。</p>]]></content>
      
      
      <categories>
          
          <category> spring cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring cloud </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringCloud 总览</title>
      <link href="/2018/12/31/springcloud-overview/"/>
      <url>/2018/12/31/springcloud-overview/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列基于Spring Cloud <strong>Finchley SR2 &amp; SpringBoot 2.0.7.</strong>RELEASE</p></blockquote><p>Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性令牌、全局锁、leader选举、分布式session、集群状态）。分布式系统的协调导致了样板模式, 使用 Spring Cloud 开发人员可以快速地支持实现这些模式的服务和应用程序。它们可以在任何分布式环境中很好地工作，包括开发人员自己的笔记本电脑，裸机数据中心，以及Cloud Foundry等托管平台。</p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><hr><p>Spring Cloud专注于为典型用例提供良好的开箱即用体验，并为其他用户提供可扩展性机制。</p><ul><li>Distributed/versioned configuration       分布式/版本化配置</li><li>Service registration and discovery         服务注册和发现</li><li>Routing                                                  智能路由</li><li>Service-to-service calls                         service-to-service调用</li><li>Load balancing                                       负载均衡</li><li>Circuit Breakers                                      断路器</li><li>Global locks                                            全局锁</li><li>Leadership election and cluster state     leader选举和集群状态管理</li><li>Distributed messaging                            分布式消息</li></ul><h2 id="主要项目"><a href="#主要项目" class="headerlink" title="主要项目"></a>主要项目</h2><hr><table><thead><tr><th>项目名称<br></th><th>项目职能<br></th></tr></thead><tbody><tr><td>Spring Cloud Config<br></td><td>Spring Cloud 提供的分布式配置中心，为外部配置提供了客户端和服务端的支持。<br></td></tr><tr><td>Spring Cloud Netflix<br></td><td>与各种Netflix OSS组件集成（Eureka，Hystrix，Zuul，Archaius等）。<br></td></tr><tr><td>Spring Cloud Bus<br></td><td>用于将服务和服务实例与分布式消息传递连接在一起的事件总线。用于跨群集传播状态更改（例如，配置更改事件）。<br></td></tr><tr><td>Spring Cloud Cloudfoundry<br></td><td>提供应用程序与 Pivotal Cloud Foundry 集成。提供服务发现实现，还可以轻松实现受SSO和OAuth2保护的资源。<br></td></tr><tr><td>Spring Cloud Open Service Broker<br></td><td>为构建实现 Open service broker API 的服务代理提供了一个起点。    <br></td></tr><tr><td>Spring Cloud Cluster<br></td><td>提供Leadership选举，如：Zookeeper, Redis, Hazelcast, Consul等常见状态模式的抽象和实现。<br></td></tr><tr><td>Spring Cloud Consul<br></td><td>封装了Consul操作，consul 是一个服务发现与配置工具，与Docker容器可以无缝集成。<br></td></tr><tr><td>Spring Cloud Security<br></td><td>基于spring security的安全工具包，为你的应用程序添加安全控制。在Zuul代理中为负载平衡的OAuth2 rest客户端和身份验证头中继提供支持。<br></td></tr><tr><td>Spring Cloud Sleuth<br></td><td>Spring Cloud 提供的分布式链路跟踪组件，兼容zipkin、HTracer和基于日志的跟踪（ELK）<br></td></tr><tr><td>Spring Cloud Data Flow<br></td><td>大数据操作工具，作为Spring XD的替代产品，它是一个混合计算模型，结合了流数据与批量数据的处理方式。<br></td></tr><tr><td>Spring Cloud Stream<br></td><td>数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。<br></td></tr><tr><td>Spring Cloud CLI<br></td><td>基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。<br></td></tr><tr><td>Spring Cloud OpenFeign<br></td><td>一个http client客户端，致力于减少http client客户端构建的复杂性。<br></td></tr><tr><td>Spring Cloud Gateway<br></td><td>Spring Cloud 提供的网关服务组件<br></td></tr><tr><td>Spring Cloud Stream App Starters<br></td><td>Spring Cloud Stream App Starters是基于Spring Boot的Spring 集成应用程序，可提供与外部系统的集成。<br></td></tr><tr><td>Spring Cloud Task</td><td>提供云端计划任务管理、任务调度。<br></td></tr><tr><td>Spring Cloud Task App Starters<br></td><td>Spring Cloud任务应用程序启动器是SpringBoot应用程序，它可以是任何进程，包括不会永远运行的Spring批处理作业，并且在有限的数据处理周期后结束/停止。<br></td></tr><tr><td>Spring Cloud Zookeeper<br></td><td>操作Zookeeper的工具包，用于使用zookeeper方式的服务发现和配置管理。<br></td></tr><tr><td>Spring Cloud AWS<br></td><td>提供与托管的AWS集成<br></td></tr><tr><td>Spring Cloud Connectors<br></td><td>便于云端应用程序在各种PaaS平台连接到后端，如：数据库和消息代理服务。<br></td></tr><tr><td>Spring Cloud Starters<br></td><td>Spring Boot式的启动项目，为Spring Cloud提供开箱即用的依赖管理。<br></td></tr><tr><td>Spring Cloud Contract<br></td><td>Spring Cloud Contract是一个总体项目，其中包含帮助用户成功实施消费者驱动合同方法的解决方案。<br></td></tr><tr><td>Spring Cloud Pipelines<br></td><td>Spring Cloud Pipelines提供了一个固定意见的部署管道，其中包含确保您的应用程序可以零停机方式部署并轻松回滚出错的步骤。<br></td></tr><tr><td>Spring Cloud Function<br></td><td>Spring Cloud Function通过函数促进业务逻辑的实现。 它支持Serverless 提供商之间的统一编程模型，以及独立运行（本地或PaaS）的能力。<br></td></tr></tbody></table><h2 id="SpringCloud-与-SpringBoot-版本兼容关系"><a href="#SpringCloud-与-SpringBoot-版本兼容关系" class="headerlink" title="SpringCloud 与 SpringBoot 版本兼容关系"></a>SpringCloud 与 SpringBoot 版本兼容关系</h2><table><thead><tr><th>Release Train</th><th>Boot Version</th></tr></thead><tbody><tr><td>Greenwich<br></td><td>2.1.x<br></td></tr><tr><td>Finchley<br></td><td>2.0.x<br></td></tr><tr><td>Edgware<br></td><td>1.5.x<br></td></tr><tr><td>Dalston<br></td><td>1.5.x<br></td></tr></tbody></table><h2 id="SpringCloud-与子工程版本关系"><a href="#SpringCloud-与子工程版本关系" class="headerlink" title="SpringCloud 与子工程版本关系"></a>SpringCloud 与子工程版本关系</h2><table><thead><tr><th>Component</th><th>Edgware.SR5</th><th>Finchley.SR2</th><th>Finchley.BUILD-SNAPSHOT</th></tr></thead><tbody><tr><td>spring-cloud-aws<br></td><td>1.2.3.RELEASE<br></td><td>2.0.1.RELEASE<br></td><td>2.0.1.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-bus<br></td><td>1.3.3.RELEASE<br></td><td>2.0.0.RELEASE<br></td><td>2.0.1.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-cli<br></td><td>1.4.1.RELEASE<br></td><td>2.0.0.RELEASE<br></td><td>2.0.1.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-commons<br></td><td>1.3.5.RELEASE<br></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-contract<br></td><td>1.2.6.RELEASE<br></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-config<br></td><td>1.4.5.RELEASE<br></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-netflix<br></td><td>1.4.6.RELEASE<br></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-security<br></td><td>1.2.3.RELEASE<br></td><td>2.0.1.RELEASE<br></td><td>2.0.1.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-cloudfoundry<br></td><td>1.1.2.RELEASE<br></td><td>2.0.1.RELEASE<br></td><td>2.0.1.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-consul<br></td><td>1.3.5.RELEASE<br></td><td>2.0.1.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-sleuth<br></td><td>1.3.5.RELEASE<br></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-stream<br></td><td>Ditmars.SR4<br></td><td>Elmhurst.SR1<br></td><td>Elmhurst.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-zookeeper<br></td><td>1.2.2.RELEASE<br></td><td>2.0.0.RELEASE<br></td><td>2.0.1.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-boot<br></td><td>1.5.16.RELEASE<br></td><td>2.0.6.RELEASE<br></td><td>2.0.7.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-task<br></td><td>1.2.3.RELEASE<br></td><td>2.0.0.RELEASE<br></td><td>2.0.1.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-vault<br></td><td>1.1.2.RELEASE<br></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-gateway<br></td><td>1.0.2.RELEASE<br></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-openfeign<br></td><td></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-function<br></td><td>1.0.1.RELEASE<br></td><td>1.0.0.RELEASE<br></td><td>1.0.1.BUILD-SNAPSHOT<br></td></tr></tbody></table><ul><li>Finchley 构建并使用Spring Boot 2.0.x，与 Spring Boot 1.5.x 不兼容。</li><li>Dalston 和 Edgware 基于 Spring Boot 1.5.x 构建，不兼容 SpringBoot 2.0.x </li><li>Camden 版本迭代正式结束，Dalston 将于2018年12月结束使用，Edgware 将遵循 Spring Boot 1.5.x 的生命周期结束。</li><li>Camden 基于SpringBoot 1.4.x 构建，但是也会支持 1.5.x 版本</li><li>Brixton 和 Angel 迭代结束时间是2017年7月，Brixton 基于SpringBoot 1.3.x ，同时也支持 1.4.x 版本</li><li>Angel 基于 SpringBoot 1.2.x ,在某些方式不兼容 SpringBoot 1.3.x 。</li><li>Brixton 构建在SpringBoot 1.3.x ，不兼容 SpringBoot 1.2.x 。一些基于Angel的库和大多数应用程序可以在Brixton上正常运行，但如果OAuth2具备spring-cloud-security 1.0的特性，则需要在任何地方进行更改。x被使用(它们大多在1.3.0中被移到Spring Boot中)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> spring cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring cloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringSession系列-sessionId解析和Cookie读写策略</title>
      <link href="/2018/12/23/springsession-id-resolver/"/>
      <url>/2018/12/23/springsession-id-resolver/</url>
      
        <content type="html"><![CDATA[<blockquote><p>首先需求在这里说明下，SpringSession的版本迭代的过程中肯定会伴随着一些类的移除和一些类的加入，目前本系列使用的版本是github上对象的master的代码流版本。如果有同学对其他版本中的一些类或者处理有疑惑，欢迎交流。</p></blockquote><p>本篇将来介绍下<code>SpringSession</code>中两种<code>sessionId</code>解析的策略，这个在之前的文章中其实是有提到过的，这里再拿出来和<code>SpringSession</code>中<code>Cookie</code>相关策略一起学习下。</p><h1 id="sessionId-解析策略"><a href="#sessionId-解析策略" class="headerlink" title="sessionId 解析策略"></a>sessionId 解析策略</h1><p><code>SpringSession</code>中对于<code>sessionId</code>的解析相关的策略是通过<code>HttpSessionIdResolver</code>这个接口来体现的。<code>HttpSessionIdResolver</code>有两个实现类：<br><img src="https://img-blog.csdnimg.cn/20181216224001789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzI1NTE4MzQ5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这两个类就分别对应<code>SpringSession</code>解析<code>sessionId</code>的两种不同的实现策略。再深入了解不同策略的实现细节之前，先来看下<code>HttpSessionIdResolver</code>接口定义的一些行为有哪些。</p><h2 id="HttpSessionIdResolver"><a href="#HttpSessionIdResolver" class="headerlink" title="HttpSessionIdResolver"></a>HttpSessionIdResolver</h2><p><code>HttpSessionIdResolver</code>定义了<code>sessionId</code>解析策略的契约（<code>Contract</code>）。允许通过请求解析sessionId，并通过响应发送sessionId或终止会话。接口定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpSessionIdResolver</span> </span>&#123;</span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">resolveSessionIds</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSessionId</span><span class="params">(HttpServletRequest request, HttpServletResponse response,String sessionId)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">expireSession</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>HttpSessionIdResolver</code>中有三个方法：</p><ul><li><code>resolveSessionIds</code>：解析与当前请求相关联的<code>sessionId</code>。<code>sessionId</code>可能来自<code>Cookie</code>或请求头。</li><li><code>setSessionId</code>：将给定的<code>sessionId</code>发送给客户端。这个方法是在创建一个新<code>session</code>时被调用，并告知客户端新<code>sessionId</code>是什么。</li><li><code>expireSession</code>：指示客户端结束当前<code>session</code>。当<code>session</code>无效时调用此方法，并应通知客户端<code>sessionId</code>不再有效。比如，它可能删除一个包含<code>sessionId</code>的<code>Cookie</code>，或者设置一个<code>HTTP</code>响应头，其值为空就表示客户端不再提交<code>sessionId</code>。</li></ul><p>下面就针对上面提到的两种策略来进行详细的分析。</p><h2 id="基于Cookie解析sessionId"><a href="#基于Cookie解析sessionId" class="headerlink" title="基于Cookie解析sessionId"></a>基于Cookie解析sessionId</h2><p>这种策略对应的实现类是<code>CookieHttpSessionIdResolver</code>，通过从<code>Cookie</code>中获取<code>session</code>；具体来说，这个实现将允许使用<code>CookieHttpSessionIdResolver#setCookieSerializer(CookieSerializer)</code>指定<code>Cookie</code>序列化策略。默认的<code>Cookie</code>名称是“<code>SESSION</code>”。创建一个<code>session</code>时，<code>HTTP</code>响应中将会携带一个指定 <code>Cookie name</code>且<code>value</code>是<code>sessionId</code>的<code>Cookie</code>。<code>Cookie</code> 将被标记为一个 <code>session cookie</code>，<code>Cookie</code> 的 <code>domain path</code> 使用 <code>context path</code>，且被标记为<code>HttpOnly</code>，如果<code>HttpServletRequest#isSecure()</code>返回<code>true</code>，那么<code>Cookie</code>将标记为安全的。如下：</p><blockquote><p>关于<code>Cookie</code>，可以参考：<a href="http://www.glmapper.com/2018/11/10/sessionone/">聊一聊session和cookie</a>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Set-Cookie: SESSION=f81d4fae-7dec-11d0-a765-00a0c91e6bf6; Path=/context-root; Secure; HttpOnly</span><br></pre></td></tr></table></figure><p>这个时候，客户端应该通过在每个请求中指定相同的<code>Cookie</code>来包含<code>session</code>信息。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /messages/ HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Cookie: SESSION=f81d4fae-7dec-11d0-a765-00a0c91e6bf6</span><br></pre></td></tr></table></figure></p><p>当会话无效时，服务器将发送过期的<code>HTTP</code>响应<code>Cookie</code>，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Set-Cookie: SESSION=f81d4fae-7dec-11d0-a765-00a0c91e6bf6; Expires=Thur, 1 Jan 1970 00:00:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure><p><code>CookieHttpSessionIdResolver</code> 类的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieHttpSessionIdResolver</span> <span class="keyword">implements</span> <span class="title">HttpSessionIdResolver</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WRITTEN_SESSION_ID_ATTR = CookieHttpSessionIdResolver.class</span><br><span class="line">.getName().concat(<span class="string">".WRITTEN_SESSION_ID_ATTR"</span>);</span><br><span class="line"><span class="comment">// Cookie序列化策略，默认是 DefaultCookieSerializer</span></span><br><span class="line"><span class="keyword">private</span> CookieSerializer cookieSerializer = <span class="keyword">new</span> DefaultCookieSerializer();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">resolveSessionIds</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据提供的cookieSerializer从请求中获取sessionId</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.cookieSerializer.readCookieValues(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSessionId</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">String sessionId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sessionId.equals(request.getAttribute(WRITTEN_SESSION_ID_ATTR))) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">request.setAttribute(WRITTEN_SESSION_ID_ATTR, sessionId);</span><br><span class="line"><span class="comment">// 根据提供的cookieSerializer将sessionId回写到cookie中</span></span><br><span class="line"><span class="keyword">this</span>.cookieSerializer</span><br><span class="line">.writeCookieValue(<span class="keyword">new</span> CookieValue(request, response, sessionId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireSession</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 这里因为是过期，所以回写的sessionId的值是“”，当请求下次进来时，就会取不到sessionId，也就意味着当前会话失效了</span></span><br><span class="line"><span class="keyword">this</span>.cookieSerializer.writeCookieValue(<span class="keyword">new</span> CookieValue(request, response, <span class="string">""</span>));</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 指定Cookie序列化的方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCookieSerializer</span><span class="params">(CookieSerializer cookieSerializer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cookieSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"cookieSerializer cannot be null"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.cookieSerializer = cookieSerializer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里可以看到<code>CookieHttpSessionIdResolver</code> 中的读取操作都是围绕<code>CookieSerializer</code>来完成的。<code>CookieSerializer</code> 是<code>SpringSession</code>中对于<code>Cookie</code>操作提供的一种机制。下面细说。</p><h2 id="基于请求头解析sessionId"><a href="#基于请求头解析sessionId" class="headerlink" title="基于请求头解析sessionId"></a>基于请求头解析sessionId</h2><p>这种策略对应的实现类是<code>HeaderHttpSessionIdResolver</code>，通过从请求头<code>header</code>中解析出<code>sessionId</code>。具体地说，这个实现将允许使用<code>HeaderHttpSessionIdResolver(String)</code>来指定头名称。还可以使用便利的工厂方法来创建使用公共头名称(例如<code>“X-Auth-Token”</code>和<code>“authenticing-info”</code>)的实例。创建会话时，<code>HTTP</code>响应将具有指定名称和<code>sessionId</code>值的响应头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用X-Auth-Token作为headerName</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeaderHttpSessionIdResolver <span class="title">xAuthToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HeaderHttpSessionIdResolver(HEADER_X_AUTH_TOKEN);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用Authentication-Info作为headerName</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeaderHttpSessionIdResolver <span class="title">authenticationInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HeaderHttpSessionIdResolver(HEADER_AUTHENTICATION_INFO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HeaderHttpSessionIdResolver</code>在处理<code>sessionId</code>上相比较于<code>CookieHttpSessionIdResolver</code>来说简单很多。就是围绕<code>request.getHeader(String)</code>和<code>request.setHeader(String,String)</code><br>两个方法来玩的。</p><p><code>HeaderHttpSessionIdResolver</code>这种策略通常会在无线端来使用，以弥补对于无<code>Cookie</code>场景的支持。</p><h1 id="Cookie-序列化策略"><a href="#Cookie-序列化策略" class="headerlink" title="Cookie 序列化策略"></a>Cookie 序列化策略</h1><p>基于<code>Cookie</code>解析<code>sessionId</code>的实现类<code>CookieHttpSessionIdResolver</code> 中实际对于<code>Cookie</code>的读写操作都是通过<code>CookieSerializer</code>来完成的。<code>SpringSession</code> 提供了<code>CookieSerializer</code>接口的默认实现<code>DefaultCookieSerializer</code>，当然在实际应用中，我们也可以自己实现这个接口，然后通过<code>CookieHttpSessionIdResolver#setCookieSerializer(CookieSerializer)</code>方法来指定我们自己的实现方式。</p><blockquote><p>PS：不得不说，强大的用户扩展能力真的是<code>Spring</code>家族的优良家风。</p></blockquote><p>篇幅有限，这里就只看下两个点：</p><ul><li><code>CookieValue</code> 存在的意义是什么</li><li><code>DefaultCookieSerializer</code>回写<code>Cookie</code>的的具体实现，读<code>Cookie</code>在 <a href="http://www.glmapper.com/2018/11/24/springsessiontwo/">SpringSession系列-请求与响应重写</a> 这篇文章中有介绍过，这里不再赘述。</li><li>jvm_router的处理</li></ul><h2 id="CookieValue"><a href="#CookieValue" class="headerlink" title="CookieValue"></a>CookieValue</h2><p><code>CookieValue</code>是<code>CookieSerializer</code>中的内部类，封装了向<code>HttpServletResponse</code>写入所需的所有信息。其实<code>CookieValue</code>的存在并没有什么特殊的意义，个人觉得作者一开始只是想通过<code>CookieValue</code>的封装来简化回写<code>cookie</code>链路中的参数传递的问题，但是实际上貌似并没有什么减少多少工作量。</p><h2 id="Cookie-回写"><a href="#Cookie-回写" class="headerlink" title="Cookie 回写"></a>Cookie 回写</h2><p><code>Cookie</code> 回写我觉得对于分布式<code>session</code>的实现来说是必不可少的；基于标准<code>servlet</code>实现的<code>HttpSession</code>，我们在使用时实际上是不用关心回写<code>cookie</code>这个事情的，因为<code>servlet</code>容器都已经做了。但是对于分布式<code>session</code>来说，由于重写了<code>response</code>，所以需要在返回<code>response</code>时需要将当前<code>session</code>信息通过<code>cookie</code>的方式塞到<code>response</code>中返回给客户端-这就是<code>Cookie</code>回写。下面是<code>DefaultCookieSerializer</code>中回写<code>Cookie</code>的逻辑，细节在代码中通过注释标注出来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeCookieValue</span><span class="params">(CookieValue cookieValue)</span> </span>&#123;</span><br><span class="line">HttpServletRequest request = cookieValue.getRequest();</span><br><span class="line">HttpServletResponse response = cookieValue.getResponse();</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.append(<span class="keyword">this</span>.cookieName).append(<span class="string">'='</span>);</span><br><span class="line">String value = getValue(cookieValue);</span><br><span class="line"><span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">validateValue(value);</span><br><span class="line">sb.append(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxAge = getMaxAge(cookieValue);</span><br><span class="line"><span class="keyword">if</span> (maxAge &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">sb.append(<span class="string">"; Max-Age="</span>).append(cookieValue.getCookieMaxAge());</span><br><span class="line">OffsetDateTime expires = (maxAge != <span class="number">0</span>)</span><br><span class="line">? OffsetDateTime.now().plusSeconds(maxAge)</span><br><span class="line">: Instant.EPOCH.atOffset(ZoneOffset.UTC);</span><br><span class="line">sb.append(<span class="string">"; Expires="</span>)</span><br><span class="line">.append(expires.format(DateTimeFormatter.RFC_1123_DATE_TIME));</span><br><span class="line">&#125;</span><br><span class="line">String domain = getDomainName(request);</span><br><span class="line"><span class="keyword">if</span> (domain != <span class="keyword">null</span> &amp;&amp; domain.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">validateDomain(domain);</span><br><span class="line">sb.append(<span class="string">"; Domain="</span>).append(domain);</span><br><span class="line">&#125;</span><br><span class="line">String path = getCookiePath(request);</span><br><span class="line"><span class="keyword">if</span> (path != <span class="keyword">null</span> &amp;&amp; path.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">validatePath(path);</span><br><span class="line">sb.append(<span class="string">"; Path="</span>).append(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isSecureCookie(request)) &#123;</span><br><span class="line">sb.append(<span class="string">"; Secure"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.useHttpOnlyCookie) &#123;</span><br><span class="line">sb.append(<span class="string">"; HttpOnly"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.sameSite != <span class="keyword">null</span>) &#123;</span><br><span class="line">sb.append(<span class="string">"; SameSite="</span>).append(<span class="keyword">this</span>.sameSite);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response.addHeader(<span class="string">"Set-Cookie"</span>, sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这上面就是拼凑字符串，然后塞到Header里面去，最终再浏览器中显示大体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: SESSION=f81d4fae-7dec-11d0-a765-00a0c91e6bf6; Path=/context-root; Secure; HttpOnly</span><br></pre></td></tr></table></figure><h2 id="jvm-router的处理"><a href="#jvm-router的处理" class="headerlink" title="jvm_router的处理"></a>jvm_router的处理</h2><p>在<code>Cookie</code>的读写代码中都涉及到对于<code>jvmRoute</code>这个属性的判断及对应的处理逻辑。</p><p>1、读取<code>Cookie</code>中的代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.jvmRoute != <span class="keyword">null</span> &amp;&amp; sessionId.endsWith(<span class="keyword">this</span>.jvmRoute)) &#123;</span><br><span class="line">sessionId = sessionId.substring(<span class="number">0</span>,</span><br><span class="line">sessionId.length() - <span class="keyword">this</span>.jvmRoute.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、回写<code>Cookie</code>中的代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.jvmRoute != <span class="keyword">null</span>) &#123;</span><br><span class="line">actualCookieValue = requestedCookieValue + <span class="keyword">this</span>.jvmRoute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>jvm_route</code>是<code>Nginx</code>中的一个模块，其作用是通过<code>session cookie</code>的方式来获取<code>session</code>粘性。如果在<code>cookie</code>和<code>url</code>中并没有<code>session</code>，则这只是个简单的 <code>round-robin</code> 负载均衡。其具体过程分为以下几步：</p><ul><li>1.第一个请求过来，没有带<code>session</code>信息，<code>jvm_route</code>就根据<code>round robin</code>策略发到一台<code>tomcat</code>上面。</li><li>2.<code>tomcat</code>添加上 <code>session</code> 信息，并返回给客户。</li><li>3.用户再次请求，<code>jvm_route</code>看到<code>session</code>中有后端服务器的名称，它就把请求转到对应的服务器上。</li></ul><p>从本质上来说，<code>jvm_route</code>也是解决<code>session</code>共享的一种解决方式。这种和 <a href="http://www.glmapper.com/2018/11/24/springsessionthree/">SpringSession系列-分布式Session实现方案</a> 中提到的基于<code>IP-HASH</code>的方式有点类似。那么同样，这里存在的问题是无法解决宕机后<code>session</code>数据转移的问题，既宕机就丢失。</p><p><code>DefaultCookieSerializer</code> 中除了<code>Cookie</code>的读写之后，还有一些细节也值得关注下，比如对<code>Cookie</code>中值的验证、<code>remember-me</code>的实现等。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://docs.spring.io/spring-session/docs/2.1.2.RELEASE/reference/html5/" target="_blank" rel="noopener">SpringSession官方文档</a></li><li><a href="https://blog.csdn.net/cao_j/article/details/51191764" target="_blank" rel="noopener">jvm_router原理</a></li><li><a href="https://github.com/glmapper/spring-session/tree/cn-spring-session" target="_blank" rel="noopener">SpringSession中文注释持续更新代码分支</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> session </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> session </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>20181216-书法练习</title>
      <link href="/2018/12/16/shufa-20181216/"/>
      <url>/2018/12/16/shufa-20181216/</url>
      
        <content type="html"><![CDATA[<blockquote><p>春江花月夜 -张若虚<br>春江潮水连海平，海上明月共潮生。<br>滟滟随波千万里，何处春江无月明！<br>江流宛转绕芳甸，月照花林皆似霰；<br>空里流霜不觉飞，汀上白沙看不见。<br>江天一色无纤尘，皎皎空中孤月轮。<br>江畔何人初见月？江月何年初照人？<br>人生代代无穷已，江月年年只相似。<br>不知江月待何人，但见长江送流水。<br>白云一片去悠悠，青枫浦上不胜愁。<br>谁家今夜扁舟子？何处相思明月楼？<br>可怜楼上月徘徊，应照离人妆镜台。<br>玉户帘中卷不去，捣衣砧上拂还来。<br>此时相望不相闻，愿逐月华流照君。<br>鸿雁长飞光不度，鱼龙潜跃水成文。<br>昨夜闲潭梦落花，可怜春半不还家。<br>江水流春去欲尽，江潭落月复西斜。<br>斜月沉沉藏海雾，碣石潇湘无限路。<br>不知乘月几人归，落月摇情满江树。</p></blockquote><p><img src="https://github.com/glmapper/glmapper.github.io/blob/master/images/self/shufa-yb-chunjianghuayueye.jpg?raw=true" alt=""></p><p><img src="https://github.com/glmapper/glmapper.github.io/blob/master/images/self/shufa-rb-chunjianghuayueye.jpg?raw=true" alt=""></p><blockquote><p>闻王昌龄左迁龙标遥有此寄 -李白<br>杨花落尽子规啼，闻道龙标过五溪。<br>我寄愁心与明月，随风直到夜郎西。</p></blockquote><p><img src="https://github.com/glmapper/glmapper.github.io/blob/master/images/self/shufa-yanghualuojinziguiti.jpg?raw=true" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 书法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringSession系列-存储机制之Redis&amp;Map</title>
      <link href="/2018/12/16/spring-session-redis-map/"/>
      <url>/2018/12/16/spring-session-redis-map/</url>
      
        <content type="html"><![CDATA[<p>@<a href="SpringSession：存储机制设计">TOC</a><br>在之前的文章中已经对<code>SpringSession</code>的功能结构，请求/响应重写等做了介绍。本文将继续来介绍下<code>SpringSession</code>中存储部分的设计。存储是分布式<code>session</code>中算是最核心的部分，通过引入三方的存储容器来实现<code>session</code>的存储，从而有效的解决<code>session</code>共享的问题。</p><h2 id="1、SpringSession存储的顶级抽象接口"><a href="#1、SpringSession存储的顶级抽象接口" class="headerlink" title="1、SpringSession存储的顶级抽象接口"></a>1、SpringSession存储的顶级抽象接口</h2><p><code>SpringSession</code>存储的顶级抽象接口是<code>org.springframework.session</code>包下的<code>SessionRepository</code>这个接口。<code>SessionRepository</code>的类图结构如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef7ce8c6b58?w=1662&amp;h=600&amp;f=png&amp;s=66844" alt=""></p><p>这里先来看下<code>SessionRepository</code>这个顶层接口中定义了哪些方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SessionRepository</span>&lt;<span class="title">S</span> <span class="keyword">extends</span> <span class="title">Session</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个session</span></span><br><span class="line"><span class="function">S <span class="title">createSession</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//保存session</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(S session)</span></span>;</span><br><span class="line"><span class="comment">//通过ID查找session</span></span><br><span class="line"><span class="function">S <span class="title">findById</span><span class="params">(String id)</span></span>;</span><br><span class="line"><span class="comment">//通过ID删除一个session</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码来看还是很简单的，就是增删查。下面看具体实现。在2.0版本开始<code>SpringSession</code>中也提供了一个和<code>SessionRepository</code>具体相同能力的<code>ReactiveSessionRepository</code>，用于支持响应式编程模式。</p><h2 id="2、MapSessionRepository"><a href="#2、MapSessionRepository" class="headerlink" title="2、MapSessionRepository"></a>2、MapSessionRepository</h2><p>基于HashMap实现的基于内存存储的存储器实现，这里就主要看下对于接口中几个方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapSessionRepository</span> <span class="keyword">implements</span> <span class="title">SessionRepository</span>&lt;<span class="title">MapSession</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer defaultMaxInactiveInterval;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Session&gt; sessions;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到就是一个<code>Map</code>，那后面关于增删查其实就是操作这个<code>Map</code>了。</p><h3 id="createSession"><a href="#createSession" class="headerlink" title="createSession"></a>createSession</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MapSession <span class="title">createSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MapSession result = <span class="keyword">new</span> MapSession();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.defaultMaxInactiveInterval != <span class="keyword">null</span>) &#123;</span><br><span class="line">result.setMaxInactiveInterval(</span><br><span class="line">Duration.ofSeconds(<span class="keyword">this</span>.defaultMaxInactiveInterval));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很直接，就是<code>new</code>了一个<code>MapSession</code>，然后设置了<code>session</code>的有效期。</p><h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(MapSession session)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!session.getId().equals(session.getOriginalId())) &#123;</span><br><span class="line"><span class="keyword">this</span>.sessions.remove(session.getOriginalId());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.sessions.put(session.getId(), <span class="keyword">new</span> MapSession(session));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面先判断了<code>session</code>中的两个<code>ID</code>，一个<code>originalId</code>，一个当前<code>id</code>。<code>originalId</code>是第一次生成<code>session</code>对象时创建的，后面都不会在变化。通过源码来看，对于<code>originalId</code>，只提供了<code>get</code>方法。对于<code>id</code>呢，其实是可以通过<code>changeSessionId</code>来改变的。</p><p>这里的这个操作实际上是一种优化行为，及时的清除掉老的<code>session</code>数据来释放内存空间。</p><h3 id="findById"><a href="#findById" class="headerlink" title="findById"></a>findById</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MapSession <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">Session saved = <span class="keyword">this</span>.sessions.get(id);</span><br><span class="line"><span class="keyword">if</span> (saved == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (saved.isExpired()) &#123;</span><br><span class="line">deleteById(saved.getId());</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MapSession(saved);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个逻辑也很简单，先从<code>Map</code>中根据<code>id</code>取出<code>session</code>数据，如果没有就返回<code>null</code>，如果有则再判断下是否过期了，如果过期了就删除掉，然后返回<code>null</code>。如果查到了，并且没有过期的话，则构建一个<code>MapSession</code>返回。</p><p>OK，基于内存存储的实现系列就是这些了，下面继续来看其他存储的实现。</p><h2 id="3、FindByIndexNameSessionRepository"><a href="#3、FindByIndexNameSessionRepository" class="headerlink" title="3、FindByIndexNameSessionRepository"></a>3、FindByIndexNameSessionRepository</h2><p><code>FindByIndexNameSessionRepository</code>继承了<code>SessionRepository</code>接口，用于扩展对第三方存储的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FindByIndexNameSessionRepository</span>&lt;<span class="title">S</span> <span class="keyword">extends</span> <span class="title">Session</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">SessionRepository</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">String PRINCIPAL_NAME_INDEX_NAME = FindByIndexNameSessionRepository.class.getName()</span><br><span class="line">.concat(<span class="string">".PRINCIPAL_NAME_INDEX_NAME"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">Map&lt;String, S&gt; <span class="title">findByIndexNameAndIndexValue</span><span class="params">(String indexName, String indexValue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> Map&lt;String, S&gt; <span class="title">findByPrincipalName</span><span class="params">(String principalName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> findByIndexNameAndIndexValue(PRINCIPAL_NAME_INDEX_NAME, principalName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FindByIndexNameSessionRepository</code>添加一个单独的方法为指定用户查询所有会话。这是通过设置名为<code>FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME</code>的<code>Session</code>的属性值为指定用户的<code>username</code>来完成的。开发人员有责任确保属性被赋值，因为<code>SpringSession</code>不会在意被使用的认证机制。官方文档中给出的例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String username = <span class="string">"username"</span>;</span><br><span class="line"><span class="keyword">this</span>.session.setAttribute(</span><br><span class="line">FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME, username);</span><br></pre></td></tr></table></figure><p><code>FindByIndexNameSessionRepository</code>的一些实现会提供一些钩子自动的索引其他的<code>session</code>属性。比如，很多实现都会自动的确保当前的<code>Spring Security</code>用户名称可通过索引名称<code>FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME</code>进行索引。一旦会话被索引，就可以通过下面的代码检索：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String username = <span class="string">"username"</span>;</span><br><span class="line">Map&lt;String, Session&gt; sessionIdToSession = </span><br><span class="line"><span class="keyword">this</span>.sessionRepository.findByIndexNameAndIndexValue(</span><br><span class="line">FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME,username);</span><br></pre></td></tr></table></figure><p>下图是<code>FindByIndexNameSessionRepository</code>接口的三个实现类：<br><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef0284d86a5?w=1624&amp;h=258&amp;f=png&amp;s=66960" alt="FindByIndexNameSessionRepository"></p><p>下面来分别分析下这三个存储的实现细节。</p><h3 id="3-1-RedisOperationsSessionRepository"><a href="#3-1-RedisOperationsSessionRepository" class="headerlink" title="3.1 RedisOperationsSessionRepository"></a>3.1 RedisOperationsSessionRepository</h3><p><code>RedisOperationsSessionRepository</code>的类图结构如下，<code>MessageListener</code>是<code>redis</code>消息订阅的监听接口。<br><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef029530952?w=1128&amp;h=596&amp;f=png&amp;s=67475" alt="在这里插入图片描述"></p><p>代码有点长，就不在这里面贴了，一些注释可以在这个 <a href="https://github.com/glmapper/spring-session/tree/cn-spring-session" target="_blank" rel="noopener">SpringSession中文分支</a> 来看。这里还是主要来看下对于那几个方法的实现。</p><h4 id="3-1-1-createSession"><a href="#3-1-1-createSession" class="headerlink" title="3.1.1 createSession"></a>3.1.1 createSession</h4><p>这里和<code>MapSessionRepository</code>的实现基本一样的，那区别就在于<code>Session</code>的封装模型不一样，这里是<code>RedisSession</code>，实际上<code>RedisSession</code>的实现是对<code>MapSession</code>又包了一层。下面会分析<code>RedisSession</code>这个类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisSession <span class="title">createSession</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// RedisSession,这里和MapSession区别开</span></span><br><span class="line">RedisSession redisSession = <span class="keyword">new</span> RedisSession();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.defaultMaxInactiveInterval != <span class="keyword">null</span>) &#123;</span><br><span class="line">redisSession.setMaxInactiveInterval(</span><br><span class="line">Duration.ofSeconds(<span class="keyword">this</span>.defaultMaxInactiveInterval));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> redisSession;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在看其他两个方法之前，先来看下<code>RedisSession</code>这个类。</p><h4 id="3-1-2-RedisSession"><a href="#3-1-2-RedisSession" class="headerlink" title="3.1.2 RedisSession"></a>3.1.2 RedisSession</h4><p>这个在模型上是对<code>MapSession</code>的扩展，增加了<code>delta</code>这个东西。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSession</span> <span class="keyword">implements</span> <span class="title">Session</span> </span>&#123;</span><br><span class="line">       <span class="comment">// MapSession 实例对象，主要存数据的地方</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MapSession cached;</span><br><span class="line"><span class="comment">// 原始最后访问时间</span></span><br><span class="line"><span class="keyword">private</span> Instant originalLastAccessTime;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; delta = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 是否是新的session对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isNew;</span><br><span class="line"><span class="comment">// 原始主名称</span></span><br><span class="line"><span class="keyword">private</span> String originalPrincipalName;</span><br><span class="line"><span class="comment">// 原始sessionId</span></span><br><span class="line"><span class="keyword">private</span> String originalSessionId;</span><br></pre></td></tr></table></figure></p><p><code>delta</code>是一个Map结构，那么这里面到底是放什么的呢？具体细节见 <a href="https://github.com/glmapper/spring-session/blob/cn-spring-session/spring-session-data-redis/src/main/java/org/springframework/session/data/redis/RedisOperationsSessionRepository.java" target="_blank" rel="noopener">saveDelta</a> 这个方法。<code>saveDelta</code> 这个方法会在两个地方被调用，一个是下面要说道的<code>save</code>方法，另外一个是 <code>flushImmediateIfNecessary</code> 这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushImmediateIfNecessary</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (RedisOperationsSessionRepository.<span class="keyword">this</span>.redisFlushMode == RedisFlushMode.IMMEDIATE) &#123;</span><br><span class="line">saveDelta();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>RedisFlushMode</code>提供了两种推送模式：</p><ul><li>ON_SAVE：只有在调用<code>save</code>方法时执行，在<code>web</code>环境中这样做通常是尽快提交HTTP响应</li><li>IMMEDIATE：只要有变更就会直接写到<code>redis</code>中，不会像<code>ON_SAVE</code>一样，在最后<code>commit</code>时一次性写入</li></ul><p>追踪<code>flushImmediateIfNecessary</code> 方法调用链如下：<br><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef032721690?w=1008&amp;h=258&amp;f=png&amp;s=89571" alt="在这里插入图片描述"><br>那么到这里基本就清楚了，首先<code>save</code>这个方法，当主动调用<code>save</code>时就是将数据推到<code>redis</code>中去的，也就是<code>ON_SAVE</code>这种情况。那么对于<code>IMMEDIATE</code>这种情况，只有调用了上面的四个方法，<code>SpringSession</code> 才会将数据推送到<code>redis</code>。</p><p>所以<code>delta</code>里面存的是当前一些变更的 <code>key-val</code> 键值对象，而这些变更是由<code>setAttribute</code>、<code>removeAttribute</code>、<code>setMaxInactiveIntervalInSeconds</code>、<code>setLastAccessedTime</code>这四个方法触发的；比如<code>setAttribute(k,v)</code>，那么这个<code>k-&gt;v</code>就会被保存到<code>delta</code>里面。</p><h4 id="3-1-3-save"><a href="#3-1-3-save" class="headerlink" title="3.1.3 save"></a>3.1.3 save</h4><p>在理解了<code>saveDelta</code>方法之后再来看<code>save</code>方法就简单多了。<code>save</code> 对应的就是<code>RedisFlushMode.ON_SAVE</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(RedisSession session)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 直接调用 saveDelta推数据到redis</span></span><br><span class="line">session.saveDelta();</span><br><span class="line"><span class="keyword">if</span> (session.isNew()) &#123;</span><br><span class="line">   <span class="comment">// sessionCreatedKey-&gt;channl</span></span><br><span class="line">String sessionCreatedKey = getSessionCreatedChannel(session.getId());</span><br><span class="line"><span class="comment">// 发布一个消息事件，新增 session，以供 MessageListener 回调处理。</span></span><br><span class="line"><span class="keyword">this</span>.sessionRedisOperations.convertAndSend(sessionCreatedKey, session.delta);</span><br><span class="line">session.setNew(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-4-findById"><a href="#3-1-4-findById" class="headerlink" title="3.1.4 findById"></a>3.1.4 findById</h4><p>查询这部分和基于<code>Map</code>的差别比较大，因为这里并不是直接操作<code>Map</code>，而是与<code>Redis</code> 进行一次交互。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisSession <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getSession(id, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用<code>getSession</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RedisSession <span class="title">getSession</span><span class="params">(String id, <span class="keyword">boolean</span> allowExpired)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据ID从redis中取出数据</span></span><br><span class="line">Map&lt;Object, Object&gt; entries = getSessionBoundHashOperations(id).entries();</span><br><span class="line"><span class="keyword">if</span> (entries.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转换成MapSession</span></span><br><span class="line">MapSession loaded = loadSession(id, entries);</span><br><span class="line"><span class="keyword">if</span> (!allowExpired &amp;&amp; loaded.isExpired()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转换成RedisSession</span></span><br><span class="line">RedisSession result = <span class="keyword">new</span> RedisSession(loaded);</span><br><span class="line">result.originalLastAccessTime = loaded.getLastAccessedTime();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>loadSession</code>中构建<code>MapSession</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MapSession <span class="title">loadSession</span><span class="params">(String id, Map&lt;Object, Object&gt; entries)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 生成MapSession实例</span></span><br><span class="line">MapSession loaded = <span class="keyword">new</span> MapSession(id);</span><br><span class="line"><span class="comment">//遍历数据</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entries.entrySet()) &#123;</span><br><span class="line">String key = (String) entry.getKey();</span><br><span class="line"><span class="keyword">if</span> (CREATION_TIME_ATTR.equals(key)) &#123;</span><br><span class="line">    <span class="comment">// 设置创建时间</span></span><br><span class="line">loaded.setCreationTime(Instant.ofEpochMilli((<span class="keyword">long</span>) entry.getValue()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (MAX_INACTIVE_ATTR.equals(key)) &#123;</span><br><span class="line"> <span class="comment">// 设置最大有效时间</span></span><br><span class="line">loaded.setMaxInactiveInterval(Duration.ofSeconds((<span class="keyword">int</span>) entry.getValue()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (LAST_ACCESSED_ATTR.equals(key)) &#123;</span><br><span class="line"><span class="comment">// 设置最后访问时间</span></span><br><span class="line">loaded.setLastAccessedTime(Instant.ofEpochMilli((<span class="keyword">long</span>) entry.getValue()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key.startsWith(SESSION_ATTR_PREFIX)) &#123;</span><br><span class="line"><span class="comment">// 设置属性</span></span><br><span class="line">loaded.setAttribute(key.substring(SESSION_ATTR_PREFIX.length()),</span><br><span class="line">entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> loaded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-5-deleteById"><a href="#3-1-5-deleteById" class="headerlink" title="3.1.5 deleteById"></a>3.1.5 deleteById</h4><p>根据<code>sessionId</code>删除<code>session</code>数据。具体过程看代码注释。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(String sessionId)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取 RedisSession</span></span><br><span class="line">RedisSession session = getSession(sessionId, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">if</span> (session == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// 清楚当前session数据的索引</span></span><br><span class="line">cleanupPrincipalIndex(session);</span><br><span class="line"><span class="comment">//执行删除操作</span></span><br><span class="line"><span class="keyword">this</span>.expirationPolicy.onDelete(session);</span><br><span class="line">String expireKey = getExpiredKey(session.getId());</span><br><span class="line"><span class="comment">//删除expireKey</span></span><br><span class="line"><span class="keyword">this</span>.sessionRedisOperations.delete(expireKey);</span><br><span class="line"><span class="comment">//session有效期设置为0</span></span><br><span class="line">session.setMaxInactiveInterval(Duration.ZERO);</span><br><span class="line">save(session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-1-6-onMessage"><a href="#3-1-6-onMessage" class="headerlink" title="3.1.6 onMessage"></a>3.1.6 onMessage</h4><p>最后来看下这个订阅回调处理。这里看下核心的一段逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isDeleted = channel.equals(<span class="keyword">this</span>.sessionDeletedChannel);</span><br><span class="line"><span class="comment">// Deleted 还是 Expired ？</span></span><br><span class="line"><span class="keyword">if</span> (isDeleted || channel.equals(<span class="keyword">this</span>.sessionExpiredChannel)) &#123;</span><br><span class="line"><span class="comment">// 此处省略无关代码</span></span><br><span class="line"><span class="comment">// Deleted</span></span><br><span class="line"><span class="keyword">if</span> (isDeleted) &#123;</span><br><span class="line">   <span class="comment">// 发布一个 SessionDeletedEvent 事件</span></span><br><span class="line">handleDeleted(session);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Expired</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 发布一个 SessionExpiredEvent 事件</span></span><br><span class="line">handleExpired(session);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-Redis-存储的一些思考"><a href="#3-2-Redis-存储的一些思考" class="headerlink" title="3.2 Redis 存储的一些思考"></a>3.2 Redis 存储的一些思考</h3><p>首先按照我们自己常规的思路来设计的话，我们会怎么来考虑这个事情。这里首先要声明下，我对 <code>Redis</code> 这个东西不是很熟，没有做过深入的研究；那如果是我来做，可能也就仅仅限于存储。</p><ul><li><code>findByIndexNameAndIndexValue</code>的设计，这个的作用是通过<code>indexName</code>和<code>indexValue</code>来返回当前用户的所有会话。但是这里需要考虑的一个事情是，通常情况下，一个用户只会关联到一个会话上面去，那这种设计很显然，我的理解是为了支持单用户多会话的场景。<ul><li>indexName：FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME</li><li>indexValue：username</li></ul></li><li><p>实现 <code>MessageListener</code> 接口，增加事件通知能力。通过监听这些事件，可以做一些<code>session</code>操作管控。但是实际上 <code>SpringSession</code> 中并没有做任何事情，从代码来看，<code>publishEvent</code>方法是空实现。等待回复中 <a href="https://github.com/spring-projects/spring-session/issues/1287" target="_blank" rel="noopener">#issue 1287</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ApplicationEventPublisher eventPublisher = <span class="keyword">new</span> ApplicationEventPublisher() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>RedisFlushMode</code> ，<code>SpringSession</code>中提供了两种模式的推送，一种是<code>ON_SAVE</code>，另外一种是<code>IMMEDIATE</code>。默认是<code>ON_SAVE</code>，也就是常规的在请求处理结束时进行一次<code>sessionCommit</code>操作。<code>RedisFlushMode</code> 的设计感觉是为<code>session</code>数据持久化的时机提供了另外一种思路。</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>存储机制设计部分就一基于内存和基于<code>Redis</code>两种来分析；另外基于<code>jdbc</code>和<code>hazelcast</code>有兴趣的同学可以自己查看源码。</p><p>最后也欢迎访问我的个人博客：<a href="http://www.glmapper.com">www.glmapper.com</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/zyhlwzy/article/details/78062646" target="_blank" rel="noopener">https://blog.csdn.net/zyhlwzy/article/details/78062646</a></li><li><a href="https://docs.spring.io/spring-session/docs/2.0.0.M4/reference/html5/#api" target="_blank" rel="noopener">https://docs.spring.io/spring-session/docs/2.0.0.M4/reference/html5/#api</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> session </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> session </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SOFATracer 插件埋点机制详解</title>
      <link href="/2018/12/07/sofatracer-mvc-plugin/"/>
      <url>/2018/12/07/sofatracer-mvc-plugin/</url>
      
        <content type="html"><![CDATA[<blockquote><p>SOFATracer 是一个用于分布式系统调用跟踪的组件，通过统一的 <code>traceId</code> 将调用链路中的各种网络调用情况以日志的方式记录下来，以达到透视化网络调用的目的。这些日志可用于故障的快速发现，服务治理等。</p></blockquote><p>从 <a href="http://www.sofastack.tech/sofa-tracer/docs/roadmap" target="_blank" rel="noopener">RoadMap</a> 和 <a href="https://github.com/alipay/sofa-tracer/pulls" target="_blank" rel="noopener">PR</a> 来看，目前 SOFATracer 已经支持了丰富的组件插件埋点。</p><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543318400761-682a9d1a-b194-4a87-9fac-9e1a38a9247e.png" alt="img"></p><p>目前还未支持的主要是 Dubbo、MQ 以及 Redis 等。本文将从 SOFATracer 已提供的一个插件源码来分析下 SOFATracer 插件的埋点实现。</p><h2 id="1-SOFATracer-插件埋点机制"><a href="#1-SOFATracer-插件埋点机制" class="headerlink" title="1 SOFATracer 插件埋点机制"></a>1 SOFATracer 插件埋点机制</h2><p>SOFATracer 插件的作用实际上就是对于不同组件进行埋点，以便于收集这些组件的链路数据。SOFATracer 埋点方式一般是通过 Filter、Interceptor 机制实现的。</p><p>另一个是，SOFATracer 的埋点方式并不是基于 OT-api 进行埋点的，而是基于 SOFATracer 自己的 api 进行埋点的，详见 <a href="https://github.com/alipay/sofa-tracer/issues/126" target="_blank" rel="noopener">issue#126</a>。</p><h3 id="1-1-Filter-or-Interceptor"><a href="#1-1-Filter-or-Interceptor" class="headerlink" title="1.1 Filter or Interceptor"></a>1.1 Filter or Interceptor</h3><p>目前已实现的插件中，像 MVC 插件是基于 Filter 进行埋点的，httpclient、resttemplate 等是基于Interceptor进行埋点的。在实现插件时，要根据不同插件的特性来选择具体的埋点方式。</p><p> 当然除了这两种方式之外还可以通过静态代理的方式来实现埋点。比如 sofa-tracer-datasource-plugin 插件就是将不同的数据源进行统一代理给 SmartDatasource，从而实现埋点的。</p><h3 id="1-2-AbstractTracer-API"><a href="#1-2-AbstractTracer-API" class="headerlink" title="1.2 AbstractTracer API"></a>1.2 AbstractTracer API</h3><p>SOFATracer 中所有的插件均需要实现自己的 Tracer 实例，如 Mvc 的 SpringMvcTracer 、HttpClient的 HttpClientTracer 等，这一点与基于 Opentracing-api 接口埋点的实现有所区别。</p><ul><li>1、基于 SOFATracer api 埋点方式插件扩展</li></ul><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543324415543-aba1c5fe-7cb4-46ae-9aee-2fe5441a5f98.png" alt="img"></p><p>AbstractTracer 是 SOFATracer 用于插件扩展使用的一个抽象类，根据插件类型不同，又可以分为 clientTracer 和 serverTracer，分别对应于：AbstractClientTracer 和 AbstractServerTracer，再通过 AbstractClientTracer 和 AbstractServerTracer 衍生出具体的组件 Tracer 实现。这种方式的好处在于，所有的插件实现均由 SOFATracer 本身来管控，对于不同的组件可以轻松的实现差异化和定制化。缺点也源于此，每增加一个组件都需要做一些重复工作。</p><ul><li>2、基于 OpenTracing-api 埋点方式插件扩展</li></ul><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543324680485-cdb3793c-b830-490e-832f-b58e12091f7d.png" alt="img"></p><p>这种埋点方式不基于 SOFATracer  自身提供的 API，而是基于 OpenTracing-api 接口。因为均遵循 OpenTracing-api 规范，所以组件和 Tracer 实现可以独立分开来维护。这样就可以对接开源的一些基于 OpenTracing-api 规范实现的组件。例如：<a href="https://github.com/opentracing-contrib" target="_blank" rel="noopener">OpenTracing API Contributions</a>。</p><p>SOFATracer 在后面将会在 4.0 版本中支持基于 OT-api 的埋点方式，对外部组件接入扩展提供支持。</p><h3 id="1-3-AbstractTracer"><a href="#1-3-AbstractTracer" class="headerlink" title="1.3 AbstractTracer"></a>1.3 AbstractTracer</h3><p>这里先来看下 AbstractTracer  这个抽象类中具体提供了哪些抽象方法，也就是对于 AbstractClientTracer 和 AbstractServerTracer 需要分别扩展哪些能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取client端 摘要日志日志名</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getClientDigestReporterLogName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取client端 摘要日志滚动策略key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getClientDigestReporterRollingKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取client端 摘要日志日志名key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getClientDigestReporterLogNameKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取client端 摘要日志编码器</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getClientDigestEncoder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 创建client端 统计日志Reporter类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> AbstractSofaTracerStatisticReporter <span class="title">generateClientStatReporter</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志日志名</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getServerDigestReporterLogName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志滚动策略key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getServerDigestReporterRollingKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志日志名key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getServerDigestReporterLogNameKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志编码器</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getServerDigestEncoder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 创建server端 统计日志Reporter类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> AbstractSofaTracerStatisticReporter <span class="title">generateServerStatReporter</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>从  AbstractTracer 类提供的抽象方法来看，不管是 client 还是 server，在具体的 Tracer 组件实现中，都必须提供以下实现：</p><ul><li>DigestReporterLogName :当前组件摘要日志的日志名称</li><li>DigestReporterRollingKey : 当前组件摘要日志的滚动策略</li><li>SpanEncoder：对摘要日志进行编码的编码器实现</li><li>AbstractSofaTracerStatisticReporter : 统计日志 reporter 类的实现类。</li></ul><h2 id="2-SpringMVC-插件埋点分析"><a href="#2-SpringMVC-插件埋点分析" class="headerlink" title="2 SpringMVC 插件埋点分析"></a>2 SpringMVC 插件埋点分析</h2><p>这里我们以 SpringMVC 插件为例，来分析下如何实现一个埋点插件的。这里是官方给出的案例工程：基于 <a href="https://github.com/alipay/sofa-tracer/blob/master/tracer-samples/tracer-sample-with-springmvc" target="_blank" rel="noopener">Spring MVC 示例落地日志</a> 。</p><h3 id="2-1-实现-Tracer-实例"><a href="#2-1-实现-Tracer-实例" class="headerlink" title="2.1 实现 Tracer 实例"></a>2.1 实现 Tracer 实例</h3><p>SpringMvcTracer 继承了 AbstractServerTracer 类，是对 serverTracer 的扩展。</p><blockquote><p>PS：如何确定一个组件是client端还是server端呢？就是看当前组件是请求的发起方还是请求的接受方，如果是请求发起方则一般是client端，如果是请求接收方则是 server 端。那么对于 MVC 来说，是请求接受方，因此这里实现了 AbstractServerTracer 类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcTracer</span> <span class="keyword">extends</span> <span class="title">AbstractServerTracer</span></span></span><br></pre></td></tr></table></figure><h4 id="2-1-1-构造函数与单例对象"><a href="#2-1-1-构造函数与单例对象" class="headerlink" title="2.1.1 构造函数与单例对象"></a>2.1.1 构造函数与单例对象</h4><p>在构造函数中，需要传入当前 Tracer 的 traceType，SpringMvcTracer 的 traceType 为 “springmvc”。这里也可以看到，tracer 实例是一个单例对象，对于其他插件也是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SpringMvcTracer springMvcTracer = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * Spring MVC Tracer Singleton</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> singleton</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SpringMvcTracer <span class="title">getSpringMvcTracerSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (springMvcTracer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SpringMvcTracer.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (springMvcTracer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                springMvcTracer = <span class="keyword">new</span> SpringMvcTracer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> springMvcTracer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SpringMvcTracer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"springmvc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-AbstractServerTracer-抽象类"><a href="#2-1-2-AbstractServerTracer-抽象类" class="headerlink" title="2.1.2 AbstractServerTracer 抽象类"></a>2.1.2 AbstractServerTracer 抽象类</h4><p>在看 SpringMvcTracer 实现之前，先来看下 AbstractServerTracer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractServerTracer</span> <span class="keyword">extends</span> <span class="title">AbstractTracer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数，子类必须提供一个构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractServerTracer</span><span class="params">(String tracerType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(tracerType, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为是server端，所以Client先关的提供了默认实现，返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getClientDigestReporterLogName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getClientDigestReporterRollingKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getClientDigestReporterLogNameKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getClientDigestEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AbstractSofaTracerStatisticReporter <span class="title">generateClientStatReporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合上面  AbstractTracer 小节中抽象方法分析，这里在 AbstractServerTracer 中将 client 对应的抽象方法提供了默认实现，也就是说如果要继承 AbstractServerTracer 类，那么就必须实现 server 对应的所有抽象方法。</p><h4 id="2-1-3-SpringMVCTracer-实现"><a href="#2-1-3-SpringMVCTracer-实现" class="headerlink" title="2.1.3 SpringMVCTracer 实现"></a>2.1.3 SpringMVCTracer 实现</h4><p>下面是 SpringMvcTracer 部分对 server 部分抽象方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getServerDigestReporterLogName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SpringMvcLogEnum.SPRING_MVC_DIGEST.getDefaultLogName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getServerDigestReporterRollingKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SpringMvcLogEnum.SPRING_MVC_DIGEST.getRollingKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getServerDigestReporterLogNameKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SpringMvcLogEnum.SPRING_MVC_DIGEST.getLogNameKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getServerDigestEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Boolean.TRUE.toString().equalsIgnoreCase(</span><br><span class="line">        SofaTracerConfiguration.getProperty(SPRING_MVC_JSON_FORMAT_OUTPUT))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringMvcDigestJsonEncoder();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringMvcDigestEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AbstractSofaTracerStatisticReporter <span class="title">generateServerStatReporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> generateSofaMvcStatReporter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前 SOFATracer 日志名、滚动策略key等都是通过枚举类来定义的，也就是一个组件会对应这样一个枚举类，在枚举类里面定义这些常量。</p><h3 id="2-2-SpringMvcLogEnum-类实现"><a href="#2-2-SpringMvcLogEnum-类实现" class="headerlink" title="2.2 SpringMvcLogEnum 类实现"></a>2.2 SpringMvcLogEnum 类实现</h3><p>SpringMVC 插件中的枚举类是 SpringMvcLogEnum。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SpringMvcLogEnum &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 摘要日志相关</span></span><br><span class="line">    SPRING_MVC_DIGEST(<span class="string">"spring_mvc_digest_log_name"</span>, </span><br><span class="line">                      <span class="string">"spring-mvc-digest.log"</span>,</span><br><span class="line">                      <span class="string">"spring_mvc_digest_rolling"</span>), </span><br><span class="line">    <span class="comment">// 统计日志相关</span></span><br><span class="line">    SPRING_MVC_STAT(<span class="string">"spring_mvc_stat_log_name"</span>, </span><br><span class="line">                    <span class="string">"spring-mvc-stat.log"</span>, </span><br><span class="line">                    <span class="string">"spring_mvc_stat_rolling"</span>);</span><br><span class="line">    <span class="comment">// 省略部分代码....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 XXXLogEnum 枚举类中定义了当前组件对应的摘要日志和统计日志的日志名和滚动策略，因为 SOFATracer 目前还没有服务端的能力，链路数据不是直接上报给 server 的，因此 SOFATracer 提供了落到磁盘的能力。不同插件的链路日志也会通过 XXXLogEnum 指定的名称将链路日志输出到各个组件对应的日志目录下。</p><h3 id="2-3-统计日志-Reportor-实现"><a href="#2-3-统计日志-Reportor-实现" class="headerlink" title="2.3 统计日志 Reportor 实现"></a>2.3 统计日志 Reportor 实现</h3><p>SOFATracer 中统计日志打印的实现需要各个组件自己来完成，具体就是需要实现一个AbstractSofaTracerStatisticReporter 的子类，然后实现 doReportStat 这个方法。当然对于目前的实现来说，我们也会重写 print 方法。</p><h4 id="2-3-1-doReportStat"><a href="#2-3-1-doReportStat" class="headerlink" title="2.3.1 doReportStat"></a>2.3.1 doReportStat</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doReportStat</span><span class="params">(SofaTracerSpan sofaTracerSpan)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; tagsWithStr = sofaTracerSpan.getTagsWithStr();</span><br><span class="line">    <span class="comment">// 构建StatMapKey对象</span></span><br><span class="line">    StatMapKey statKey = <span class="keyword">new</span> StatMapKey();</span><br><span class="line">    <span class="comment">// 增加 key:当前应用名</span></span><br><span class="line">    statKey.addKey(CommonSpanTags.LOCAL_APP, tagsWithStr.get(CommonSpanTags.LOCAL_APP));</span><br><span class="line">    <span class="comment">// 增加 key:请求 url</span></span><br><span class="line">    statKey.addKey(CommonSpanTags.REQUEST_URL, tagsWithStr.get(CommonSpanTags.REQUEST_URL));</span><br><span class="line">    <span class="comment">// 增加 key:请求方法</span></span><br><span class="line">    statKey.addKey(CommonSpanTags.METHOD, tagsWithStr.get(CommonSpanTags.METHOD));</span><br><span class="line">    <span class="comment">// 压测标志</span></span><br><span class="line">    statKey.setLoadTest(TracerUtils.isLoadTest(sofaTracerSpan));</span><br><span class="line">    <span class="comment">// 请求响应码</span></span><br><span class="line">    String resultCode = tagsWithStr.get(CommonSpanTags.RESULT_CODE);</span><br><span class="line">    <span class="comment">// 请求成功标识</span></span><br><span class="line">    <span class="keyword">boolean</span> success = (resultCode != <span class="keyword">null</span> &amp;&amp; resultCode.length() &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span></span><br><span class="line">        .isHttpOrMvcSuccess(resultCode));</span><br><span class="line">    statKey.setResult(success ? <span class="string">"true"</span> : <span class="string">"false"</span>);</span><br><span class="line">    <span class="comment">//end</span></span><br><span class="line">    statKey.setEnd(TracerUtils.getLoadTestMark(sofaTracerSpan));</span><br><span class="line">    <span class="comment">//value the count and duration</span></span><br><span class="line">    <span class="keyword">long</span> duration = sofaTracerSpan.getEndTime() - sofaTracerSpan.getStartTime();</span><br><span class="line">    <span class="keyword">long</span> values[] = <span class="keyword">new</span> <span class="keyword">long</span>[] &#123; <span class="number">1</span>, duration &#125;;</span><br><span class="line">    <span class="comment">// reserve</span></span><br><span class="line">    <span class="keyword">this</span>.addStat(statKey, values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里就是就是将统计日志添加到日志槽里，等待被消费(输出到日志)。具体可以参考：SofaTracerStatisticReporterManager.StatReporterPrinter。</p><h4 id="2-3-2-print"><a href="#2-3-2-print" class="headerlink" title="2.3.2 print"></a>2.3.2 print</h4><p>print 方法是实际将数据写入到磁盘的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(StatKey statKey, <span class="keyword">long</span>[] values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isClosePrint.get()) &#123;</span><br><span class="line">        <span class="comment">//关闭统计日志输出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(statKey <span class="keyword">instanceof</span> StatMapKey)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StatMapKey statMapKey = (StatMapKey) statKey;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 构建需要打印的数据串</span></span><br><span class="line">        jsonBuffer.reset();</span><br><span class="line">        jsonBuffer.appendBegin();</span><br><span class="line">        jsonBuffer.append(<span class="string">"time"</span>, Timestamp.currentTime());</span><br><span class="line">        jsonBuffer.append(<span class="string">"stat.key"</span>, <span class="keyword">this</span>.statKeySplit(statMapKey));</span><br><span class="line">        jsonBuffer.append(<span class="string">"count"</span>, values[<span class="number">0</span>]);</span><br><span class="line">        jsonBuffer.append(<span class="string">"total.cost.milliseconds"</span>, values[<span class="number">1</span>]);</span><br><span class="line">        jsonBuffer.append(<span class="string">"success"</span>, statMapKey.getResult());</span><br><span class="line">        <span class="comment">//压测</span></span><br><span class="line">        jsonBuffer.appendEnd(<span class="string">"load.test"</span>, statMapKey.getEnd());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (appender <span class="keyword">instanceof</span> LoadTestAwareAppender) &#123;</span><br><span class="line">            ((LoadTestAwareAppender) appender).append(jsonBuffer.toString(),</span><br><span class="line">                statMapKey.isLoadTest());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            appender.append(jsonBuffer.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里强制刷一次</span></span><br><span class="line">        appender.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        SelfLog.error(<span class="string">"统计日志&lt;"</span> + statTracerName + <span class="string">"&gt;输出异常"</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>print 这个方法里面就是将 statMapKey 中，也就是 doReportStat 中塞进来的数据转换成  json 格式，然后刷到磁盘。需要注意的是这里是强制 flush 了一次。如果没有重写 print 这个方法的话，则是在SofaTracerStatisticReporterManager.StatReporterPrinter 里面调用 print 方法刷到磁盘。</p><h3 id="2-4-数据传播格式实现"><a href="#2-4-数据传播格式实现" class="headerlink" title="2.4 数据传播格式实现"></a>2.4 数据传播格式实现</h3><p>SOFATracer 支持使用 OpenTracing 的内建格式进行上下文传播。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcHeadersCarrier</span> <span class="keyword">implements</span> <span class="title">TextMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, String&gt; headers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpringMvcHeadersCarrier</span><span class="params">(HashMap&lt;String, String&gt; headers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.headers = headers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        headers.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> headers.entrySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-自定义编码格式实现"><a href="#2-5-自定义编码格式实现" class="headerlink" title="2.5 自定义编码格式实现"></a>2.5 自定义编码格式实现</h3><p>这个决定了摘要日志打印的格式，和在统计日志里面的实现要有所区分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcDigestJsonEncoder</span> <span class="keyword">extends</span> <span class="title">AbstractDigestSpanEncoder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重写encode,对span进行编码处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(SofaTracerSpan span)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        JsonStringBuilder jsonStringBuilder = <span class="keyword">new</span> JsonStringBuilder();</span><br><span class="line">        <span class="comment">//日志打印时间</span></span><br><span class="line">        jsonStringBuilder.appendBegin(<span class="string">"time"</span>, Timestamp.format(span.getEndTime()));</span><br><span class="line">        appendSlot(jsonStringBuilder, span);</span><br><span class="line">        <span class="keyword">return</span> jsonStringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具体字段处理</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendSlot</span><span class="params">(JsonStringBuilder jsonStringBuilder, SofaTracerSpan sofaTracerSpan)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        SofaTracerSpanContext context = sofaTracerSpan.getSofaTracerSpanContext();</span><br><span class="line">        Map&lt;String, String&gt; tagWithStr = sofaTracerSpan.getTagsWithStr();</span><br><span class="line">        Map&lt;String, Number&gt; tagWithNumber = sofaTracerSpan.getTagsWithNumber();</span><br><span class="line">        <span class="comment">//当前应用名</span></span><br><span class="line">        jsonStringBuilder</span><br><span class="line">            .append(CommonSpanTags.LOCAL_APP, tagWithStr.get(CommonSpanTags.LOCAL_APP));</span><br><span class="line">        <span class="comment">//TraceId</span></span><br><span class="line">        jsonStringBuilder.append(<span class="string">"traceId"</span>, context.getTraceId());</span><br><span class="line">        <span class="comment">//RpcId</span></span><br><span class="line">        jsonStringBuilder.append(<span class="string">"spanId"</span>, context.getSpanId());</span><br><span class="line">        <span class="comment">//请求 URL</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.REQUEST_URL,</span><br><span class="line">            tagWithStr.get(CommonSpanTags.REQUEST_URL));</span><br><span class="line">        <span class="comment">//请求方法</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.METHOD, tagWithStr.get(CommonSpanTags.METHOD));</span><br><span class="line">        <span class="comment">//Http 状态码</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.RESULT_CODE,</span><br><span class="line">            tagWithStr.get(CommonSpanTags.RESULT_CODE));</span><br><span class="line">        Number requestSize = tagWithNumber.get(CommonSpanTags.REQ_SIZE);</span><br><span class="line">        <span class="comment">//Request Body 大小 单位为byte</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.REQ_SIZE,</span><br><span class="line">            (requestSize == <span class="keyword">null</span> ? <span class="number">0L</span> : requestSize.longValue()));</span><br><span class="line">        Number responseSize = tagWithNumber.get(CommonSpanTags.RESP_SIZE);</span><br><span class="line">        <span class="comment">//Response Body 大小，单位为byte</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.RESP_SIZE, (responseSize == <span class="keyword">null</span> ? <span class="number">0L</span></span><br><span class="line">            : responseSize.longValue()));</span><br><span class="line">        <span class="comment">//请求耗时（MS）</span></span><br><span class="line">        jsonStringBuilder.append(<span class="string">"time.cost.milliseconds"</span>,</span><br><span class="line">            (sofaTracerSpan.getEndTime() - sofaTracerSpan.getStartTime()));</span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.CURRENT_THREAD_NAME,</span><br><span class="line">            tagWithStr.get(CommonSpanTags.CURRENT_THREAD_NAME));</span><br><span class="line">        <span class="comment">//穿透数据放在最后</span></span><br><span class="line">        jsonStringBuilder.appendEnd(<span class="string">"baggage"</span>, baggageSerialized(context));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里其实也可以看出，统计日志和摘要日志的不同点。统计日志里面核心的数据是 span 里面的 tags 数据，但是其主要作用是统计当前组件的次数。摘要日志里面除了 tags 里面的数据之外还会包括例如 traceId 和 spanId 等信息。</p><ul><li>统计日志</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"time"</span>:<span class="string">"2018-11-28 14:42:25.127"</span>,<span class="attr">"stat.key"</span>:&#123;<span class="attr">"method"</span>:<span class="string">"GET"</span>,<span class="attr">"local.app"</span>:<span class="string">"SOFATracerSpringMVC"</span>,<span class="attr">"request.url"</span>:<span class="string">"http://localhost:8080/springmvc"</span>&#125;,<span class="attr">"count"</span>:<span class="number">3</span>,<span class="attr">"total.cost.milliseconds"</span>:<span class="number">86</span>,<span class="attr">"success"</span>:<span class="string">"true"</span>,<span class="attr">"load.test"</span>:<span class="string">"F"</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>摘要日志</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"time"</span>:<span class="string">"2018-11-28 14:46:08.216"</span>,<span class="attr">"local.app"</span>:<span class="string">"SOFATracerSpringMVC"</span>,<span class="attr">"traceId"</span>:<span class="string">"0a0fe91b1543387568214100259231"</span>,<span class="attr">"spanId"</span>:<span class="string">"0.1"</span>,<span class="attr">"request.url"</span>:<span class="string">"http://localhost:8080/springmvc"</span>,<span class="attr">"method"</span>:<span class="string">"GET"</span>,<span class="attr">"result.code"</span>:<span class="string">"200"</span>,<span class="attr">"req.size.bytes"</span>:<span class="number">-1</span>,<span class="attr">"resp.size.bytes"</span>:<span class="number">0</span>,<span class="attr">"time.cost.milliseconds"</span>:<span class="number">2</span>,<span class="attr">"current.thread.name"</span>:<span class="string">"http-nio-8080-exec-2"</span>,<span class="attr">"baggage"</span>:<span class="string">""</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-请求拦截埋点"><a href="#2-6-请求拦截埋点" class="headerlink" title="2.6 请求拦截埋点"></a>2.6 请求拦截埋点</h3><p>对于基于标准 servlet 实现的组件，要实现对请求的拦截过滤，通常就是 Filter 了。sofa-tracer-springmvc-plugin 插件埋点的实现就是基于 Filter 机制完成的。</p><p>SpringMvcSofaTracerFilter 实现了 javax.servlet.Filter 接口，因此遵循标准的 servlet 规范的容器也可以通过此插件进行埋点。参考文档：<a href="https://github.com/alipay/sofa-tracer/tree/master/tracer-samples/tracer-sample-with-springmvc" target="_blank" rel="noopener">对于标准 servlet 容器的支持（ tomcat/jetty 等）</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcSofaTracerFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span></span><br></pre></td></tr></table></figure><h4 id="2-6-1-基本埋点思路"><a href="#2-6-1-基本埋点思路" class="headerlink" title="2.6.1 基本埋点思路"></a>2.6.1 基本埋点思路</h4><p>对于一个组件来说，一次处理过程一般是产生一个 span。这个span的生命周期是从接收到请求到返回响应这段过程。</p><p>但是这里需要考虑的问题是如何与上下游链路关联起来呢？在 Opentracing 规范中，可以在 Tracer 中 extract 出一个跨进程传递的 SpanContext 。然后通过这个 SpanContext 所携带的信息将当前节点关联到整个 tracer 链路中去。当然有提取(extract)就会有对应的注入(inject)。</p><p>链路的构建一般是 client-server-client-server 这种模式的，那这里就很清楚了，就是会在 client 端进行注入(inject)，然后再 server 端进行提取(extract)，反复进行，然后一直传递下去。</p><p> 在拿到 SpanContext 之后，此时当前的 span 就可以关联到这条链路中了，那么剩余的事情就是收集当前组件的一些数据。</p><p>整个过程大概分为以下几个阶段：</p><ul><li>从请求中提取 spanContext</li><li>构建 span，并将当前 span 存入当前 tracer上下文中（SofaTraceContext.push(span)） 。</li><li>设置一些信息到span中</li><li>返回响应</li><li>span结束&amp;上报</li></ul><p>下面逐一分析下这几个过程。</p><h4 id="2-6-2-从请求中提取-spanContext"><a href="#2-6-2-从请求中提取-spanContext" class="headerlink" title="2.6.2 从请求中提取 spanContext"></a>2.6.2 从请求中提取 spanContext</h4><p>这里的提取用到了上面我们提到的#数据传播格式实现#SpringMvcHeadersCarrier 这个类。上面分析到，因为mvc 做作为 server 端存在的，所以在 server 端就是从请求中 extract 出 SpanContext。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SofaTracerSpanContext <span class="title">getSpanContextFromRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="comment">// 获取请求头信息 </span></span><br><span class="line">    Enumeration headerNames = request.getHeaderNames();</span><br><span class="line">    <span class="keyword">while</span> (headerNames.hasMoreElements()) &#123;</span><br><span class="line">        String key = (String) headerNames.nextElement();</span><br><span class="line">        String value = request.getHeader(key);</span><br><span class="line">        headers.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿到 SofaTracer 实例对象</span></span><br><span class="line">    SofaTracer tracer = springMvcTracer.getSofaTracer();</span><br><span class="line">    <span class="comment">// 解析出 SofaTracerSpanContext（SpanContext的实现类）</span></span><br><span class="line">    SofaTracerSpanContext spanContext = (SofaTracerSpanContext) tracer.extract(</span><br><span class="line">        ExtendFormat.Builtin.B3_HTTP_HEADERS, <span class="keyword">new</span> SpringMvcHeadersCarrier(headers));</span><br><span class="line">    spanContext.setSpanId(spanContext.nextChildContextId());</span><br><span class="line">    <span class="keyword">return</span> spanContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-3-获取-span-amp-数据获取"><a href="#2-6-3-获取-span-amp-数据获取" class="headerlink" title="2.6.3 获取 span &amp; 数据获取"></a>2.6.3 获取 span &amp; 数据获取</h4><p>serverReceive 这个方法是在 AbstractTracer 类中提供了实现，子类不需要关注这个。在 SOFATracer 中将请求大致分为以下几个过程：</p><ul><li>客户端发送请求  clientSend      cs</li><li>服务端接受请求  serverReceive sr</li><li>服务端返回结果  serverSend     ss</li><li>客户端接受结果  clientReceive  cr</li></ul><p>无论是哪个插件，在请求处理周期内都可以从上述几个阶段中找到对应的处理方法。因此，SOFATracer 对这几个阶段处理进行了封装。这四个阶段实际上会产生两个 span，第一个 span 的起点是 cs，到 cr 结束；第二个 span是从 sr 开始，到 ss 结束。也就是说当执行 clientSend 和 serverReceive 时会返回一个 span 对象。来看下MVC中的实现：</p><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543395049905-22e60dd7-1b88-4d94-9b2d-39c94ce909c7.png" alt="img"></p><p>红色框内对应的服务端接受请求，也就是 sr 阶段，产生了一个 span 。红色框下面的这段代码是为当前这个 span 设置一些基本的信息，包括当前应用的应用名、当前请求的url、当前请求的请求方法以及请求大小。</p><h4 id="2-6-4-返回响应与结束-span"><a href="#2-6-4-返回响应与结束-span" class="headerlink" title="2.6.4 返回响应与结束 span"></a>2.6.4 返回响应与结束 span</h4><p>在 filter 链执行结束之后，在 finally 块中又补充了当前请求响应结果的一些信息到 span 中去。然后调用serverSend 结束当前 span。这里关于 serverSend 里面的逻辑就不展开说了，不过能够想到的是这里肯定是调用span.finish 这个方法( opentracing 规范中，span.finish 的执行标志着一个 span 的结束)，当前也会包括对于数据上报的一些逻辑处理等。</p><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543395799817-68deb1fd-e481-4230-a338-3bbf8512a8f8.png" alt="img"></p><h2 id="3-思路总结与插件编写流程"><a href="#3-思路总结与插件编写流程" class="headerlink" title="3 思路总结与插件编写流程"></a>3 思路总结与插件编写流程</h2><p>在第2节中以 SpringMVC 插件为例，分析了下  SOFATracer 插件埋点实现的一些细节。那么本节则从整体思路上来总结下如何编写一个 SOFATracer 的插件。</p><ul><li>1、确定所要实现的插件，然后确定以哪种方式来埋点</li><li>2、实现当前插件的 Tracer 实例，这里需要明确当前插件是以 client 存在还是以 server 存在。</li><li>3、实现一个枚举类，用来描述当前组件的日志名称和滚动策略 key 值等</li><li>4、实现插件摘要日志的 encoder ，实现当前组件的定制化输出</li><li>5、实现插件的统计日志 Reporter 实现类，通过继承 AbstractSofaTracerStatisticReporter 类并重写doReportStat。</li><li><p>6、定义当前插件的传播格式</p><p>当然最重要的还是对于要实现插件的理解，要明确我们需要收集哪些数据。</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文先介绍了SOFATracer的埋点方式与标准OT-api 埋点方式的区别，然后对 SOFATracer 中 SpringMVC 插件的埋点实现进行了分析。希望通过本文能够让更多的同学理解埋点实现这样一个过程以及需要关注的一些点。如果有兴趣或者有什么实际的需求，欢迎来讨论。</p>]]></content>
      
      
      <categories>
          
          <category> SOFA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenTracing </tag>
            
            <tag> SOFATracer </tag>
            
            <tag> Disruptor </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringSession系列-分布式Session实现方案</title>
      <link href="/2018/11/24/springsessionthree/"/>
      <url>/2018/11/24/springsessionthree/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章 <a href="https://juejin.im/post/5bdd449b6fb9a04a09557a40" target="_blank" rel="noopener">SpringSession：集成SpringBoot</a> 中介绍了如何在<code>SpringBoot</code>中来集成 <code>SpringSession</code>，整个过程非常简单，同时也简单分析了下<code>SpringSession</code>的作用原理。继上一篇实践之后，本文主要来分析 <code>SpringSession</code> 的原理。</p><h2 id="1、从-session-的一致性方案说起"><a href="#1、从-session-的一致性方案说起" class="headerlink" title="1、从 session 的一致性方案说起"></a>1、从 session 的一致性方案说起</h2><p>关于 <code>session</code> 和<code>cookie</code> 的一些知识，大家可以参考下我之前写的一篇文章：<a href="https://juejin.im/post/5aede266f265da0ba266e0ef" target="_blank" rel="noopener">聊一聊session和cookie</a>。</p><p><code>Session</code>作为服务器端使用的一种记录客户端状态的机制，其对客户端是透明的；但是<code>Session</code> 的正常运作仍然需要客户端浏览器的支持。我们都知道，<code>HTTP</code>协议是无状态的，<code>Session</code>不能依据<code>HTTP</code>连接来判断是否为同一客户，因此服务器需要向客户端浏览器发送一个识别标志（<code>sessionId</code>）,这个识别标志通过是通过<code>Cookie</code>机制来完成。</p><h3 id="1-1、session-一致性问题的由来"><a href="#1-1、session-一致性问题的由来" class="headerlink" title="1.1、session 一致性问题的由来"></a>1.1、session 一致性问题的由来</h3><p>当用户首次访问我们的<code>Servlet</code>时，应用服务器端会给用户创建一个独立的<code>Session</code>，并且存储在内存中。这种情况在单应用服务器场景下是可以满足的（这里不讨论其一个弊端，就是内存占用给服务器带来的压力的问题）。在集群场景下，这种机制就会到来问题：</p><h4 id="1-1-1、单机场景"><a href="#1-1-1、单机场景" class="headerlink" title="1.1.1、单机场景"></a>1.1.1、单机场景</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/4/166dee5cad0e35b8?w=968&amp;h=250&amp;f=png&amp;s=21829" alt=""></p><p>因为是一台应用服务器，用户的每次请求都是由这台机器来处理，所以不会有<code>session</code>共享问题。</p><h4 id="1-1-2、集群场景"><a href="#1-1-2、集群场景" class="headerlink" title="1.1.2、集群场景"></a>1.1.2、集群场景</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/4/166dee88ddb7d0ee?w=960&amp;h=608&amp;f=png&amp;s=42547" alt=""></p><p>假设现在集群中有三台机器，（从上到下：A-&gt;B-&gt;C）。当前用户首次发起访问时，请求被分配到 A 机器处理，<code>Session</code>数据被写入 A 机器的内存中；当再次发起访问 时，请求被分配的 B 处理，但此时 B 内存中并没有当前用户的任何数据，这样就出现了<code>session</code>不一致的情况了。</p><h3 id="1-2、Session-一致性问题的方案"><a href="#1-2、Session-一致性问题的方案" class="headerlink" title="1.2、Session 一致性问题的方案"></a>1.2、Session 一致性问题的方案</h3><p>对于当前服务化、单元化应用盛行的时代，简单的内存型的 <code>Session</code> 已经不能够满足我们的要求了。那么我们就需要寻求一种方案来替换目前单机内存存储实现的方案。</p><h4 id="1-2-1-基于-IP-HASH-的实现机制"><a href="#1-2-1-基于-IP-HASH-的实现机制" class="headerlink" title="1.2.1 基于 IP-HASH 的实现机制"></a>1.2.1 基于 IP-HASH 的实现机制</h4><p>在 1.1.2 中因为我们无法知道请求会被分配到哪台机器来处理，所以会导致<code>session</code>不一致的问题出现。如果我们可以解决让每个用户的请求能够固定的打到某一台机器上，那么上面提到的问题其实也就不存在了。<code>IP-HASH</code> 就是这样一种方案。通过对请求的客户端 <code>IP</code> 进行 <code>HASH</code> 计算，并将计算结果映射到具体一台机器，这样就可以将请求固定分配到某一台机器上，从而有效的避免<code>session</code>一致性问题的出现。</p><p>这种方案的好处在于:</p><ul><li>不需要修改任何应用代码，0 侵入。</li><li>安全性高，不依赖其他三方缓存框架带来的风险</li><li>成本低</li></ul><p>但是问题也很明显，这种方式实际上是规避了<code>session</code>一致性问题的出现，并非是针对<code>session</code>一致性问题给出的解决方案。主要问题：</p><ul><li>基于应用内存，会给应用服务器带来一定的压力</li><li>服务重启会导致<code>session</code>数据丢失</li><li>不利于水平扩展，水平扩展也可能丢失<code>session</code></li><li>存在单点负载高的情况，就是多数请求经过<code>HASH</code>计算之后打到同一台机器，而其他机器处于空闲状态。</li></ul><h4 id="1-2-2-session-复制"><a href="#1-2-2-session-复制" class="headerlink" title="1.2.2 session 复制"></a>1.2.2 session 复制</h4><p>这种方式的实现原理是应用服务器创建<code>session</code>之后通过组播的方式将<code>session</code>发送到组播地址内的其他应用服务器上。这种方式相较于<code>IP-HASH</code> 的方式要靠谱一点：</p><ul><li>同样不需要更改任何业务代码</li><li>能够适应多种负载策略</li><li>机器重启或者宕机之后不怕丢失，因为有冗余备份</li></ul><p>但是这种方式也有比较大的问题：</p><ul><li>首先就是服务器之间同步<code>session</code>会占用一定的网络资源，同时<code>session</code>在不同的机器之间进行同步存在延迟。</li><li>还是基于内存存储，局限于机器内存容量影响，水平扩展能力差</li><li>服务器内存因为需要存储其他机器上的<code>session</code>数据，对内存的消耗会随着集群的规模变大而变大，可能会导致机器频繁触发<code>GC</code>。</li></ul><h4 id="1-2-3-借助三方缓存框架实现-session-集中管理"><a href="#1-2-3-借助三方缓存框架实现-session-集中管理" class="headerlink" title="1.2.3 借助三方缓存框架实现 session 集中管理"></a>1.2.3 借助三方缓存框架实现 session 集中管理</h4><p>上面两种方式都是有服务器自己来管理<code>session</code>的，主要问题还是在于对于性能和内存的影响。而这种方式的原理是将<code>session</code>托管给三方软件（如<code>redis</code>）来统一管理。这种方式可以有效的解决性能、内存占用以及水平扩展等问题。但是因为引入了三方软件，在实现复杂度、运维成本等方面会有所增加。</p><p>目前所接触到的分布式<code>session</code>的实现方案，大多都是基于这种方式来实现的；<code>SpringSession</code> 也不例外。</p><h2 id="2、SpringSession-功能结构分析"><a href="#2、SpringSession-功能结构分析" class="headerlink" title="2、SpringSession 功能结构分析"></a>2、SpringSession 功能结构分析</h2><p>前面对分布式场景下的 <code>Session</code>一致性问题进行了说明，并对解决<code>Session</code>一致性的问题的几种策略进行的分析（有点糙，网上这些知识有很多）。在了解这些背景之后，我们来看下 <code>SpringSession</code> 的实现原理。</p><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p><code>Spring Session</code> 提供了用于管理用户会话信息的<code>API</code>和实现，在不依赖特定于应用程序容器的解决方案的情况下，使得支持群集会话变得更加简单。它还提供了透明的集成：</p><ul><li>允许以应用程序容器（<code>Tomcat</code>等）中立的方式替换 <code>HttpSesseion</code>，支持在 <code>headers</code>中提供 <code>session IDs</code>来使用 <code>RESTful API</code>。</li><li>提供在接收 <code>WebSocket</code> 消息时保持<code>HTTP</code> 会话存活的能力</li><li>允许以应用程序容器中立的方式替换 <code>Spring WebFlux</code> 的 <code>WebSession</code>。</li></ul><blockquote><p>以上来自官网文档翻译 <a href="https://github.com/spring-projects/spring-session" target="_blank" rel="noopener">Spring Session </a></p></blockquote><h3 id="2-2-模块"><a href="#2-2-模块" class="headerlink" title="2.2 模块"></a>2.2 模块</h3><p><code>Spring Session</code> 主要包括 4 个模块：</p><ul><li><code>spring-session-core</code> ：提供了 <code>Spring Session</code> 核心功能和<code>API</code></li><li><code>spring-session-data-redis</code>：以 <code>redis</code> 作为存储机制的 <code>SessionRepository</code> 实现</li><li><code>spring-session-hazelcast</code>：以 <code>Hazelcast</code> 作为存储机制的 <code>SessionRepository</code> 实现</li><li><code>spring-session-jdbc</code>：以关系型数据库作为存储机制的 <code>SessionRepository</code> 实现</li></ul><p>总体来说就是 核心<code>API</code>+存储实现；工程模块截图如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/4/166dec2555f6da9e?w=1070&amp;h=530&amp;f=png&amp;s=77929" alt=""></p><h3 id="2-3-功能结构"><a href="#2-3-功能结构" class="headerlink" title="2.3 功能结构"></a>2.3 功能结构</h3><p>SpringSession整体上可以分为三块：</p><ul><li>对于Web层的处理，这里包括对于请求的重写，自定义的filter加入到filter chain，cookie处理，http header处理等</li><li>公共基础封装，比如存储类的顶层抽象接口定义，自定配置，事件处理等。</li><li>存储部分，这部分实际上是对公共基础封装接口的实现，提供了丰富的存储实现，包括redis，内存存储，jdbc等。</li></ul><h3 id="2-4-多-session-支持"><a href="#2-4-多-session-支持" class="headerlink" title="2.4 多 session 支持"></a>2.4 多 session 支持</h3><p>对于常用的分布式session，在实现上一般会依赖于 cookie。但是在 springsession 中提供了基于header来传递jessionID的策略实现。同时在 2.0.4 版本之前，对于同一个浏览器同一个网站，springsession 支持多个<code>session</code>问题，但是在此版本之后抛弃了对于对 session 的支持。关于更多关于多session支持可以查看 SpringSession 的<a href="https://docs.spring.io/spring-session/docs/1.3.5.BUILD-SNAPSHOT/reference/html5/" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文对分布式 session 的几种实现策略进行了简单的介绍。对于分布式 session 而言，如何解决一致性问题是关键，目前我见过的绝大多数方案均是以 【借助三方缓存框架实现 session 集中管理】 这种来实现的，包括本系列文章中所要介绍的 SpringSession。</p><p>除分布式session一致性方式解决方案的介绍之外，作为SpringSession 的第二篇文章，在这里简单分析了下Springsession的功能模块，以便后续展开对源码的分析。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> session </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> session </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringSession系列-请求与响应重写</title>
      <link href="/2018/11/24/springsessiontwo/"/>
      <url>/2018/11/24/springsessiontwo/</url>
      
        <content type="html"><![CDATA[<p>我们知道，<code>HttpServletRequset</code>和<code>HttpServletResponse</code>是<code>Servlet</code>标准所指定的<code>Java</code>语言与<code>Web</code>容器进行交互的接口。接口本身只规定<code>java</code>语言对<code>web</code>容器进行访问的行为方式，而具体的实现是由不同的<code>web</code>容器在其内部实现的。</p><p>那么在运行期，当我们需要对<code>HttpServletRequset</code>和<code>HttpServletResponse</code>的默认实例进行扩展时，我们就可以继承<code>HttpServletRequestWrapper</code>和<code>HttpServletResponseWrapper</code>来实现。<br>　　<br>在 <code>SpringSession</code>中因为我们要实现不依赖容器本身的<code>getSession</code> 实现，因此需要扩展 <code>HttpServletRequset</code>，通过重写<code>getSession</code>来实现分布式<code>session</code>的能力。下面就来看下<code>SpringSession</code>中对于<code>HttpServletRequset</code>的扩展。</p><h2 id="1、请求重写"><a href="#1、请求重写" class="headerlink" title="1、请求重写"></a>1、请求重写</h2><p><code>SpringSession</code> 中对于请求重写，在能力上主要体现在存储方面，也就是<code>getSession</code>方法上。在 <code>SessionRepositoryFilter</code> 这个类中，是通过内部类的方式实现了对<code>HttpServletRequset</code>和<code>HttpServletResponse</code>的扩展。</p><h3 id="1-1-HttpServletRequset-扩展实现"><a href="#1-1-HttpServletRequset-扩展实现" class="headerlink" title="1.1 HttpServletRequset 扩展实现"></a>1.1 HttpServletRequset 扩展实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionRepositoryRequestWrapper</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line"><span class="comment">// HttpServletResponse 实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HttpServletResponse response;</span><br><span class="line"><span class="comment">// ServletContext 实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServletContext servletContext;</span><br><span class="line">        <span class="comment">// requestedSession session对象</span></span><br><span class="line">        <span class="keyword">private</span> S requestedSession; </span><br><span class="line">        <span class="comment">// 是否缓存 session</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> requestedSessionCached;</span><br><span class="line"><span class="comment">// sessionId</span></span><br><span class="line"><span class="keyword">private</span> String requestedSessionId;</span><br><span class="line"><span class="comment">// sessionId 是否有效</span></span><br><span class="line"><span class="keyword">private</span> Boolean requestedSessionIdValid;</span><br><span class="line"><span class="comment">// sessionId 是否失效</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> requestedSessionInvalidated;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SessionRepositoryRequestWrapper</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response, ServletContext servletContext)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(request);</span><br><span class="line"><span class="keyword">this</span>.response = response;</span><br><span class="line"><span class="keyword">this</span>.servletContext = servletContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法里面将 <code>HttpServletRequest</code>、<code>HttpServletResponse</code> 以及 <code>ServletContext</code> 实例传递进来，以便于后续扩展使用。</p><h3 id="1-3-getSession-方法"><a href="#1-3-getSession-方法" class="headerlink" title="1.3 getSession 方法"></a>1.3 getSession 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpSessionWrapper <span class="title">getSession</span><span class="params">(<span class="keyword">boolean</span> create)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从当前请求线程中获取 session</span></span><br><span class="line">HttpSessionWrapper currentSession = getCurrentSession();</span><br><span class="line"><span class="comment">// 如果有直接返回</span></span><br><span class="line"><span class="keyword">if</span> (currentSession != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> currentSession;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从请求中获取 session，这里面会涉及到从缓存中拿session的过程</span></span><br><span class="line">S requestedSession = getRequestedSession();</span><br><span class="line"><span class="keyword">if</span> (requestedSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 无效的会话id(不支持的会话存储库)请求属性名称。</span></span><br><span class="line">    <span class="comment">// 这里看下当前的sessionId是否有效</span></span><br><span class="line"><span class="keyword">if</span> (getAttribute(INVALID_SESSION_ID_ATTR) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置当前session的最后访问时间，用于延迟session的有效期</span></span><br><span class="line">requestedSession.setLastAccessedTime(Instant.now());</span><br><span class="line"><span class="comment">// 将requestedSessionIdValid置为true</span></span><br><span class="line"><span class="keyword">this</span>.requestedSessionIdValid = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 包装session</span></span><br><span class="line">currentSession = <span class="keyword">new</span> HttpSessionWrapper(requestedSession, getServletContext());</span><br><span class="line"><span class="comment">// 不是新的session，如果是新的session则需要改变sessionId</span></span><br><span class="line">currentSession.setNew(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 将session设置到当前请求上下文</span></span><br><span class="line">setCurrentSession(currentSession);</span><br><span class="line"><span class="comment">// 返回session</span></span><br><span class="line"><span class="keyword">return</span> currentSession;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 这里处理的是无效的sessionId的情况，但是当前请求线程 session有效</span></span><br><span class="line"><span class="keyword">if</span> (SESSION_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">SESSION_LOGGER.debug(</span><br><span class="line"><span class="string">"No session found by id: Caching result for getSession(false) for this HttpServletRequest."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将invalidSessionId置为true</span></span><br><span class="line">setAttribute(INVALID_SESSION_ID_ATTR, <span class="string">"true"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 是否需要创建新的session</span></span><br><span class="line"><span class="keyword">if</span> (!create) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (SESSION_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">SESSION_LOGGER.debug(</span><br><span class="line"><span class="string">"A new session was created. To help you troubleshoot where the session was created we provided a StackTrace (this is not an error). You can prevent this from appearing by disabling DEBUG logging for "</span></span><br><span class="line">+ SESSION_LOGGER_NAME,</span><br><span class="line"><span class="keyword">new</span> RuntimeException(</span><br><span class="line"><span class="string">"For debugging purposes only (not an error)"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建新的session</span></span><br><span class="line">S session = SessionRepositoryFilter.<span class="keyword">this</span>.sessionRepository.createSession();</span><br><span class="line"><span class="comment">// 设置最后访问时间，也就是指定了当前session的有效期限</span></span><br><span class="line">session.setLastAccessedTime(Instant.now());</span><br><span class="line"><span class="comment">// 包装下当前session</span></span><br><span class="line">currentSession = <span class="keyword">new</span> HttpSessionWrapper(session, getServletContext());</span><br><span class="line"><span class="comment">//设置到当前请求线程</span></span><br><span class="line">setCurrentSession(currentSession);</span><br><span class="line"><span class="keyword">return</span> currentSession;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码有几个点，这里单独来解释下。</p><ul><li><code>getCurrentSession</code><ul><li>这是为了在同一个请求过程中不需要重复的去从存储中获取session，在一个新的进来时，将当前的 session 设置到当前请求中，在后续处理过程如果需要getSession就不需要再去存储介质中再拿一次。</li></ul></li><li><code>getRequestedSession</code><ul><li>这个是根据请求信息去取<code>session</code>，这里面就包括了<code>sessionId</code>解析，从存储获取<code>session</code>对象等过程。</li></ul></li><li>是否创建新的<code>session</code>对象   <ul><li>在当前请求中和存储中都没有获取到<code>session</code>信息的情况下，这里会根据<code>create</code>参数来判断是否创建新的<code>session</code>。这里一般用户首次登录时或者<code>session</code>失效时会走到。</li></ul></li></ul><h3 id="1-4-getRequestedSession"><a href="#1-4-getRequestedSession" class="headerlink" title="1.4 getRequestedSession"></a>1.4 getRequestedSession</h3><p>根据请求信息来获取<code>session</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> S <span class="title">getRequestedSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存的请求session是否存在</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.requestedSessionCached) &#123;</span><br><span class="line">            <span class="comment">// 获取 sessionId</span></span><br><span class="line">            List&lt;String&gt; sessionIds = SessionRepositoryFilter.<span class="keyword">this</span>.httpSessionIdResolver</span><br><span class="line">            .resolveSessionIds(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 通过sessionId来从存储中获取session</span></span><br><span class="line">            <span class="keyword">for</span> (String sessionId : sessionIds) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.requestedSessionId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.requestedSessionId = sessionId;</span><br><span class="line">            &#125;</span><br><span class="line">            S session = SessionRepositoryFilter.<span class="keyword">this</span>.sessionRepository</span><br><span class="line">            .findById(sessionId);</span><br><span class="line">            <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.requestedSession = session;</span><br><span class="line">            <span class="keyword">this</span>.requestedSessionId = sessionId;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.requestedSessionCached = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.requestedSession;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码还是很有意思的，这里获取<code>sessionId</code>返回的是个列表。当然这里是<code>SpringSession</code>的实现策略，因为支持<code>session</code>，所以这里以列表的形式返回的。OK，继续来看如何解析<code>sessionId</code>的：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744a467ce2ada6?w=1394&amp;h=200&amp;f=png&amp;s=80360" alt=""></p><p>这里可以看到<code>SpringSession</code>对于<code>sessionId</code>获取的两种策略，一种是基于<code>cookie</code>，一种是基于<code>header</code>；分别来看下具体实现。</p><h4 id="1-4-1-CookieHttpSessionIdResolver-获取-sessionId"><a href="#1-4-1-CookieHttpSessionIdResolver-获取-sessionId" class="headerlink" title="1.4.1 CookieHttpSessionIdResolver 获取 sessionId"></a>1.4.1 CookieHttpSessionIdResolver 获取 sessionId</h4><p><code>CookieHttpSessionIdResolver</code> 中获取<code>sessionId</code>的核心代码如下：<br><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744a7c7c05a32f?w=1360&amp;h=710&amp;f=png&amp;s=152689" alt=""><br>其实这里没啥好说的，就是读<code>cookie</code>。从<code>request</code>将<code>cookie</code>信息拿出来，然后遍历找当前<code>sessionId</code>对应的<code>cookie</code>,这里的判断也很简单， 如果是以<code>SESSION</code>开头，则表示是 <code>SessionId</code>，毕竟<code>cookie</code>是共享的，不只有<code>sessionId</code>，还有可能存储其他内容。</p><p>另外这里面有个 jvmRoute，这个东西实际上很少能够用到，因为大多数情况下这个值都是null。这个我们在分析<code>CookieSerializer</code>时再来解释。</p><h4 id="1-4-2-HeaderHttpSessionIdResolver-获取-sessionId"><a href="#1-4-2-HeaderHttpSessionIdResolver-获取-sessionId" class="headerlink" title="1.4.2 HeaderHttpSessionIdResolver 获取 sessionId"></a>1.4.2 HeaderHttpSessionIdResolver 获取 sessionId</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744b76477e1904?w=1144&amp;h=196&amp;f=png&amp;s=51550" alt=""><br>这个获取更直接粗暴，就是根据 <code>headerName</code> 从 <code>header</code> 中取值。</p><p>回到<code>getRequestedSession</code>，剩下的代码中核心的都是和<code>sessionRepository</code>这个有关系，这部分就会涉及到存储部分。不在本篇的分析范围之内，会在存储实现部分来分析。</p><h3 id="1-5-HttpSessionWrapper"><a href="#1-5-HttpSessionWrapper" class="headerlink" title="1.5 HttpSessionWrapper"></a>1.5 HttpSessionWrapper</h3><p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744bd83bd21c65?w=1436&amp;h=416&amp;f=png&amp;s=96267" alt=""></p><p>上面的代码中当我们拿到<code>session</code>实例是通常会包装下，那么用到的就是这个<code>HttpSessionWrapper</code>。</p><p><code>HttpSessionWrapper</code> 继承了 <code>HttpSessionAdapter</code>，这个<code>HttpSessionAdapter</code>就是将SpringSession 转换成一个标准<code>HttpSession</code>的适配类。<code>HttpSessionAdapter</code> 实现了标准<code>servlet</code>规范的<code>HttpSession</code>接口。</p><h4 id="1-5-1-HttpSessionWrapper"><a href="#1-5-1-HttpSessionWrapper" class="headerlink" title="1.5.1 HttpSessionWrapper"></a>1.5.1 HttpSessionWrapper</h4><p><code>HttpSessionWrapper</code> 重写了 <code>invalidate</code>方法。从代码来看，调用该方法产生的影响是：</p><ul><li><code>requestedSessionInvalidated</code> 置为<code>true</code>，标识当前 <code>session</code> 失效。</li><li>将当前请求中的<code>session</code>设置为<code>null</code>，那么在请求的后续调用中通过<code>getCurrentSession</code>将拿不到<code>session</code>信息。</li><li>当前缓存的 session 清楚，包括sessionId，session实例等。</li><li>删除存储介质中的session对象。</li></ul><h4 id="1-5-2-HttpSessionAdapter"><a href="#1-5-2-HttpSessionAdapter" class="headerlink" title="1.5.2 HttpSessionAdapter"></a>1.5.2 HttpSessionAdapter</h4><p><code>SpringSession</code>和标准<code>HttpSession</code>的配置器类。这个怎么理解呢，来看下一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getAttribute</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">checkState();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.session.getAttribute(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于基于容器本身实现的<code>HttpSession</code>来说，<code>getAttribute</code>的实现也是有容器本身决定。但是这里做了转换之后，<code>getAttribute</code>将会通过<code>SpringSession</code>中实现的方案来获取。其他的<code>API</code>适配也是基于此实现。</p><h3 id="SessionCommittingRequestDispatcher"><a href="#SessionCommittingRequestDispatcher" class="headerlink" title="SessionCommittingRequestDispatcher"></a>SessionCommittingRequestDispatcher</h3><p>实现了 <code>RequestDispatcher</code> 接口。关于<code>RequestDispatcher</code>可以参考这篇文章<a href="https://www.cnblogs.com/lulipro/p/7471987.html" target="_blank" rel="noopener">【Servlet】关于RequestDispatcher的原理</a>。<code>SessionCommittingRequestDispatcher</code>对<code>forward</code>的行为并没有改变。<br>对于<code>include</code>则是在<code>include</code>之前提交<code>session</code>。为什么这么做呢？</p><p> 因为<code>include</code>方法使原先的<code>Servlet</code>和转发到的<code>Servlet</code>都可以输出响应信息，即原先的<code>Servlet</code>还可以继续输出响应信息；即请求转发后，原先的<code>Servlet</code>还可以继续输出响应信息，转发到的<code>Servlet</code>对请求做出的响应将并入原先<code>Servlet</code>的响应对象中。 </p><p> 所以这个在<code>include</code>调用之前调用<code>commit</code>，这样可以确保被包含的<code>Servlet</code>程序不能改变响应消息的状态码和响应头。</p><h2 id="2-响应重写"><a href="#2-响应重写" class="headerlink" title="2 响应重写"></a>2 响应重写</h2><p>响应重写的目的是确保在请求提交时能够把session保存起来。来看下<code>SessionRepositoryResponseWrapper</code>类的实现：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744deabbf838ec?w=1140&amp;h=678&amp;f=png&amp;s=148489" alt=""><br>这里面实现还就是重写<code>onResponseCommitted</code>，也就是上面说的，在请求提交时能够通过这个回调函数将<code>session</code>保存到存储容器中。</p><h3 id="2-1-session-提交"><a href="#2-1-session-提交" class="headerlink" title="2.1 session 提交"></a>2.1 session 提交</h3><p>最后来看下 commitSession</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744e0fea8b3996?w=1374&amp;h=610&amp;f=png&amp;s=139692" alt=""></p><p>这个过程不会再去存储容器中拿<code>session</code>信息，而是直接从当前请求中拿。如果拿不到，则在回写<code>cookie</code>时会将当前<code>session</code>对应的<code>cookie</code>值设置为空，这样下次请求过来时携带的<code>sessionCookie</code>就是空，这样就会重新触发登陆。</p><p>如果拿到，则清空当前请求中的<code>session</code>信息，然后将<code>session</code>保存到存储容器中，并且将<code>sessionId</code>回写到<code>cookie</code>中。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇主要对<code>SpringSession</code>中重写<code>Request</code>和<code>Response</code>进行了分析。通过重写<code>Request</code>请求来将<code>session</code>的存储与存储容器关联起来，通过重写<code>Response</code>来处理<code>session</code>提交，将<code>session</code>保存到存储容器中。</p><p>后面我们会继续来分析<code>SpringSession</code>的源码。最近也在学习链路跟踪相关的技术，也准备写一写，有兴趣的同学可以一起讨论。</p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><ul><li><a href="https://github.com/alipay" target="_blank" rel="noopener">SOFA 开源社区</a></li><li><a href="https://github.com/alipay/sofa-tracer" target="_blank" rel="noopener">SOFATracer</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> session </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> session </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SOFABoot 健康检查能力分析</title>
      <link href="/2018/11/16/sofaboot-health-one/"/>
      <url>/2018/11/16/sofaboot-health-one/</url>
      
        <content type="html"><![CDATA[<h2 id="Liveness-Check-amp-Readiness-Check"><a href="#Liveness-Check-amp-Readiness-Check" class="headerlink" title="Liveness Check &amp;  Readiness Check"></a>Liveness Check &amp;  Readiness Check</h2><p><code>Spring Boot</code> 提供了一个基础的健康检查的能力，中间件和应用都可以扩展来实现自己的健康检查逻辑。但是 Spring Boot 的健康检查只有 <code>Liveness Check</code> 的能力，缺少 <code>Readiness Check</code> 的能力，这样会有比较致命的问题。当一个微服务应用启动的时候，必须要先保证启动后应用是健康的，才可以将上游的流量放进来（来自于 RPC，网关，定时任务等等流量），否则就可能会导致一定时间内大量的错误发生。</p><p>针对 <code>Spring Boot</code> 缺少 <code>Readiness Check</code> 能力的情况，<code>SOFABoot</code> 增加了 <code>Spring Boot</code> 现有的健康检查的能力，提供了 <code>Readiness Check</code> 的能力。利用 <code>Readiness Check</code> 的能力，<code>SOFA</code> 中间件中的各个组件只有在 <code>Readiness Check</code> 通过之后，才将流量引入到应用的实例中，比如 <code>RPC</code>，只有在 <code>Readiness Check</code> 通过之后，才会向服务注册中心注册，后面来自上游应用的流量才会进入。</p><p>除了中间件可以利用 <code>Readiness Check</code> 的事件来控制流量的进入之外，<code>PAAS</code> 系统也可以通过访问 <code>http://localhost:8080/actuator/readiness</code> 来获取应用的 <code>Readiness Check</code> 的状况，用来控制例如负载均衡设备等等流量的进入。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p><code>SOFABoot</code> 的健康检查能力需要引入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>healthcheck-sofa-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>区别于<code>SpringBoot</code>的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>详细工程科参考：<a href="https://github.com/alipay/" target="_blank" rel="noopener">sofa-boot</a></p></blockquote><h3 id="健康检查启动日志"><a href="#健康检查启动日志" class="headerlink" title="健康检查启动日志"></a>健康检查启动日志</h3><p><img src="https://user-gold-cdn.xitu.io/2018/11/16/1671b3e9d1e81110?w=1592&amp;h=322&amp;f=png&amp;s=360160" alt=""></p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>既然是个Starter，那么就先从 <strong>spring.factories</strong> 文件来看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">com.alipay.sofa.healthcheck.initializer.SofaBootHealthCheckInitializer</span><br><span class="line"></span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.alipay.sofa.healthcheck.configuration.SofaBootHealthCheckAutoConfiguration</span><br></pre></td></tr></table></figure><h4 id="SofaBootHealthCheckInitializer"><a href="#SofaBootHealthCheckInitializer" class="headerlink" title="SofaBootHealthCheckInitializer"></a>SofaBootHealthCheckInitializer</h4><p><code>SofaBootHealthCheckInitializer</code> 实现了 <code>ApplicationContextInitializer</code> 接口。</p><p><code>ApplicationContextInitializer</code> 是 <code>Spring</code> 框架原有的概念，这个类的主要目的就是在            <code>ConfigurableApplicationContext</code> 类型（或者子类型）的 <code>ApplicationContext</code> 做 <code>refresh</code> 之前，允许我们                   对 <code>ConfigurableApplicationContext</code> 的实例做进一步的设置或者处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaBootHealthCheckInitializer</span> <span class="keyword">implements</span> <span class="title">ApplicationContextInitializer</span>&lt;<span class="title">ConfigurableApplicationContext</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        Environment environment = applicationContext.getEnvironment();</span><br><span class="line">        <span class="keyword">if</span> (SOFABootEnvUtils.isSpringCloudBootstrapEnvironment(environment)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// init logging.level.com.alipay.sofa.runtime argument</span></span><br><span class="line">        String healthCheckLogLevelKey = Constants.LOG_LEVEL_PREFIX</span><br><span class="line">                                        + HealthCheckConstants.SOFABOOT_HEALTH_LOG_SPACE;</span><br><span class="line">        SofaBootLogSpaceIsolationInit.initSofaBootLogger(environment, healthCheckLogLevelKey);</span><br><span class="line">      SofaBootHealthCheckLoggerFactory.getLogger(SofaBootHealthCheckInitializer.class).info(</span><br><span class="line">            <span class="string">"SOFABoot HealthCheck Starting!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SofaBootHealthCheckInitializer</code> 在 <code>initialize</code> 方法中主要做了两件事：</p><ul><li>验证当前 <code>environment</code> 是否是 <code>SpringCloud</code> 的（3.0.0 开始支持 <code>springCloud</code>，之前版本无此 <code>check</code>）</li><li>初始化 <code>logging.level</code> </li></ul><p>这两件事和健康检查没有什么关系，但是既然放在这个模块里面还是来看下。</p><h4 id="1、springCloud-环境验证"><a href="#1、springCloud-环境验证" class="headerlink" title="1、springCloud 环境验证"></a>1、springCloud 环境验证</h4><p>首先就是为什么会有这个验证。<code>SOFABoot</code> 在支持 <code>SpringcLoud</code> 时遇到一个问题，就是当在 <code>classpath</code> 中添加<code>spring-cloud-context</code> 依赖关系时,<code>org.springframework.context.ApplicationContextInitializer</code>会被调用两次。具体背景可参考 <a href="https://github.com/spring-cloud/spring-cloud-config/issues/1151" target="_blank" rel="noopener"># issue1151</a>  &amp;&amp; <a href="https://github.com/alipay/sofa-boot/issues/232" target="_blank" rel="noopener"># issue 232</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SPRING_CLOUD_MARK_NAME = <span class="string">"org.springframework.cloud.bootstrap.BootstrapConfiguration"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSpringCloudBootstrapEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">        <span class="keyword">return</span> !((ConfigurableEnvironment) environment).getPropertySources().contains(</span><br><span class="line">            SofaBootInfraConstants.SOFA_BOOTSTRAP)</span><br><span class="line">               &amp;&amp; isSpringCloud();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSpringCloud</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ClassUtils.isPresent(SPRING_CLOUD_MARK_NAME, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码是 <code>SOFABoot</code> 提供的一个用于区分 引导上下文  和 应用上下文 的方法：</p><ul><li>检验是否有<code>&quot;org.springframework.cloud.bootstrap.BootstrapConfiguration&quot;</code>这个类来判断当前是否引入了<code>spingCloud</code>的引导配置类</li><li>从<code>environment</code> 中获取 <code>MutablePropertySources</code> 实例，验证 <code>MutablePropertySources</code> 中是否包括 <code>sofaBootstrap</code> （ 如果当前环境是 <code>SOFA bootstrap environment</code>，则包含 <code>sofaBootstrap</code>；这个是在 <code>SofaBootstrapRunListener</code> 回调方法中设置进行的 ）</li></ul><h4 id="2、初始化-logging-level"><a href="#2、初始化-logging-level" class="headerlink" title="2、初始化 logging.level"></a>2、初始化 logging.level</h4><p>这里是处理 <code>SOFABoot</code> 日志空间隔离的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initSofaBootLogger</span><span class="params">(Environment environment, String runtimeLogLevelKey)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 logging.path 参数</span></span><br><span class="line">    String loggingPath = environment.getProperty(Constants.LOG_PATH);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(loggingPath)) &#123;</span><br><span class="line">        System.setProperty(Constants.LOG_PATH, environment.getProperty(Constants.LOG_PATH));</span><br><span class="line">        ReportUtil.report(<span class="string">"Actual "</span> + Constants.LOG_PATH + <span class="string">" is [ "</span> + loggingPath + <span class="string">" ]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for example : init logging.level.com.alipay.sofa.runtime argument</span></span><br><span class="line">    String runtimeLogLevelValue = environment.getProperty(runtimeLogLevelKey);</span><br><span class="line">    <span class="keyword">if</span> (runtimeLogLevelValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.setProperty(runtimeLogLevelKey, runtimeLogLevelValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init file.encoding</span></span><br><span class="line">    String fileEncoding = environment.getProperty(Constants.LOG_ENCODING_PROP_KEY);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(fileEncoding)) &#123;</span><br><span class="line">        System.setProperty(Constants.LOG_ENCODING_PROP_KEY, fileEncoding);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SofaBootHealthCheckAutoConfiguration"><a href="#SofaBootHealthCheckAutoConfiguration" class="headerlink" title="SofaBootHealthCheckAutoConfiguration"></a>SofaBootHealthCheckAutoConfiguration</h3><p>这个类是 <code>SOFABoot</code> 健康检查机制的自动化配置实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaBootHealthCheckAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** ReadinessCheckListener: 容器刷新之后回调 */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReadinessCheckListener <span class="title">readinessCheckListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReadinessCheckListener();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** HealthCheckerProcessor: HealthChecker处理器 */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HealthCheckerProcessor <span class="title">healthCheckerProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HealthCheckerProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** HealthCheckerProcessor: HealthIndicator处理器 */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HealthIndicatorProcessor <span class="title">healthIndicatorProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HealthIndicatorProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** AfterReadinessCheckCallbackProcessor: ReadinessCheck之后的回调处理器 */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AfterReadinessCheckCallbackProcessor <span class="title">afterReadinessCheckCallbackProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AfterReadinessCheckCallbackProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 返回 SofaBoot健康检查指标类 实例*/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SofaBootHealthIndicator <span class="title">sofaBootHealthIndicator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SofaBootHealthIndicator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(Endpoint.class)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionReadinessEndpointConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnEnabledEndpoint</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SofaBootReadinessCheckEndpoint <span class="title">sofaBootReadinessCheckEndpoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SofaBootReadinessCheckEndpoint();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(Endpoint.class)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadinessCheckExtensionConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="meta">@ConditionalOnEnabledEndpoint</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ReadinessEndpointWebExtension <span class="title">readinessEndpointWebExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReadinessEndpointWebExtension();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReadinessCheckListener"><a href="#ReadinessCheckListener" class="headerlink" title="ReadinessCheckListener"></a>ReadinessCheckListener</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadinessCheckListener</span> <span class="keyword">implements</span> <span class="title">PriorityOrdered</span>,</span></span><br><span class="line"><span class="class">                                   <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从代码来看，<code>ReadinessCheckListener</code> 实现了 <code>ApplicationListener</code> 监听器接口，其所监听的事件对象是<code>ContextRefreshedEvent</code>，即当容器上下文刷新完成之后回调。 <code>SOFABoot</code> 中通过这个监听器来完成 <code>readniess check</code> 的处理。</p><p><code>onApplicationEvent</code> 回调方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// healthCheckerProcessor init</span></span><br><span class="line">    healthCheckerProcessor.init();</span><br><span class="line">    <span class="comment">// healthIndicatorProcessor init</span></span><br><span class="line">    healthIndicatorProcessor.init();</span><br><span class="line">    <span class="comment">// afterReadinessCheckCallbackProcessor init</span></span><br><span class="line">    afterReadinessCheckCallbackProcessor.init();</span><br><span class="line">    <span class="comment">// readiness health check execute</span></span><br><span class="line">    readinessHealthCheck();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化 <code>healthCheckerProcessor</code>，这个里面就是将当前所有的<code>HealthChecker</code>类型的<code>bean</code>找出来，然后放在一个<code>map</code>中，等待后面的 <code>readiness check</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否已经初始化了</span></span><br><span class="line">    <span class="keyword">if</span> (isInitiated.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// applicationContext 应用上下文不能为null</span></span><br><span class="line">        Assert.notNull(applicationContext, () -&gt; <span class="string">"Application must not be null"</span>);</span><br><span class="line">        <span class="comment">// 获取所有类型是 HealthChecker 的bean</span></span><br><span class="line">        Map&lt;String, HealthChecker&gt; beansOfType = applicationContext</span><br><span class="line">                .getBeansOfType(HealthChecker.class);</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        healthCheckers = HealthCheckUtils.sortMapAccordingToValue(beansOfType,</span><br><span class="line">                applicationContext.getAutowireCapableBeanFactory());</span><br><span class="line">        <span class="comment">// 构建日志信息，对应在健康检查日志里面打印出来的是：</span></span><br><span class="line">        <span class="comment">// ./logs/health-check/common-default.log:Found 0 HealthChecker implementation</span></span><br><span class="line">        StringBuilder healthCheckInfo = <span class="keyword">new</span> StringBuilder(<span class="number">512</span>).append(<span class="string">"Found "</span>)</span><br><span class="line">                .append(healthCheckers.size()).append(<span class="string">" HealthChecker implementation:"</span>)</span><br><span class="line">                .append(String.join(<span class="string">","</span>, healthCheckers.keySet()));</span><br><span class="line">        logger.info(healthCheckInfo.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化 <code>healthIndicatorProcessor</code>，将所有的<code>healthIndicator</code> 类型的<code>bean</code> 找出来，然后放在一个<code>map</code>中等待<code>readiness check</code>。如果想要在 <code>SOFABoot</code> 的 <code>Readiness Check</code> 里面增加一个检查项，那么可以直接扩展 <code>Spring Boot</code> 的<code>HealthIndicator</code>这个接口。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否已经初始化</span></span><br><span class="line">    <span class="keyword">if</span> (isInitiated.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// applicationContext 验证</span></span><br><span class="line">        Assert.notNull(applicationContext, () -&gt; <span class="string">"Application must not be null"</span>);</span><br><span class="line">        <span class="comment">// 获取所有HealthIndicator类型的bean</span></span><br><span class="line">        Map&lt;String, HealthIndicator&gt; beansOfType = applicationContext</span><br><span class="line">                .getBeansOfType(HealthIndicator.class);</span><br><span class="line">        <span class="comment">// 支持 Reactive 方式</span></span><br><span class="line">        <span class="keyword">if</span> (ClassUtils.isPresent(REACTOR_CLASS, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            applicationContext.getBeansOfType(ReactiveHealthIndicator.class).forEach(</span><br><span class="line">                    (name, indicator) -&gt; beansOfType.put(name, () -&gt; indicator.health().block()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        healthIndicators = HealthCheckUtils.sortMapAccordingToValue(beansOfType,</span><br><span class="line">                applicationContext.getAutowireCapableBeanFactory());</span><br><span class="line">        <span class="comment">// 构建日志信息</span></span><br><span class="line">        <span class="comment">// Found 2 HealthIndicator implementation:</span></span><br><span class="line">        <span class="comment">// sofaBootHealthIndicator, diskSpaceHealthIndicator</span></span><br><span class="line">        StringBuilder healthIndicatorInfo = <span class="keyword">new</span> StringBuilder(<span class="number">512</span>).append(<span class="string">"Found "</span>)</span><br><span class="line">                .append(healthIndicators.size()).append(<span class="string">" HealthIndicator implementation:"</span>)</span><br><span class="line">                .append(String.join(<span class="string">","</span>, healthIndicators.keySet()));</span><br><span class="line">        logger.info(healthIndicatorInfo.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化 <code>afterReadinessCheckCallbackProcessor</code>。如果想要在 <code>Readiness Check</code> 之后做一些事情，那么可以扩展 <code>SOFABoot</code> 的这个接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  是否已经初始化</span></span><br><span class="line">    <span class="keyword">if</span> (isInitiated.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// applicationContext 验证</span></span><br><span class="line">        Assert.notNull(applicationContext, () -&gt; <span class="string">"Application must not be null"</span>);</span><br><span class="line">        <span class="comment">// 找到所有 ReadinessCheckCallback 类型的 bean </span></span><br><span class="line">        Map&lt;String, ReadinessCheckCallback&gt; beansOfType = applicationContext</span><br><span class="line">                .getBeansOfType(ReadinessCheckCallback.class);</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        readinessCheckCallbacks = HealthCheckUtils.sortMapAccordingToValue(beansOfType,</span><br><span class="line">                applicationContext.getAutowireCapableBeanFactory());</span><br><span class="line">        <span class="comment">// 构建日志</span></span><br><span class="line">        StringBuilder applicationCallbackInfo = <span class="keyword">new</span> StringBuilder(<span class="number">512</span>).append(<span class="string">"Found "</span>)</span><br><span class="line">                .append(readinessCheckCallbacks.size())</span><br><span class="line">                .append(<span class="string">" ReadinessCheckCallback implementation: "</span>)</span><br><span class="line">                .append(String.join(<span class="string">","</span>, beansOfType.keySet()));</span><br><span class="line">        logger.info(applicationCallbackInfo.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>readinessHealthCheck</code>，前面的几个<code>init</code>方法中均是为<code>readinessHealthCheck</code>做准备的，到这里<code>SOFABoot</code>已经拿到了当前多有的<code>HealthChecker</code>、<code>HealthIndicator</code> 和 <code>ReadinessCheckCallback</code> 类型的 <code>bean</code> 信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readiness health check</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readinessHealthCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否跳过所有check,可以通过 com.alipay.sofa.healthcheck.skip.all 配置项配置决定</span></span><br><span class="line">    <span class="keyword">if</span> (skipAllCheck()) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Skip all readiness health check."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 是否跳过所有 HealthChecker 类型bean的 readinessHealthCheck,</span></span><br><span class="line">        <span class="comment">// 可以通过com.alipay.sofa.healthcheck.skip.component配置项配置</span></span><br><span class="line">        <span class="keyword">if</span> (skipComponent()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Skip HealthChecker health check."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//HealthChecker 的 readiness check</span></span><br><span class="line">            healthCheckerStatus = healthCheckerProcessor</span><br><span class="line">                .readinessHealthCheck(healthCheckerDetails);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否跳过所有HealthIndicator 类型bean的readinessHealthCheck</span></span><br><span class="line">        <span class="comment">// 可以通过 com.alipay.sofa.healthcheck.skip.indicator配置项配置</span></span><br><span class="line">        <span class="keyword">if</span> (skipIndicator()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Skip HealthIndicator health check."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//HealthIndicator 的 readiness check</span></span><br><span class="line">            healthIndicatorStatus = healthIndicatorProcessor</span><br><span class="line">                .readinessHealthCheck(healthIndicatorDetails);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ReadinessCheck 之后的回调函数，做一些后置处理</span></span><br><span class="line">    healthCallbackStatus = afterReadinessCheckCallbackProcessor</span><br><span class="line">        .afterReadinessCheckCallback(healthCallbackDetails);</span><br><span class="line">    <span class="keyword">if</span> (healthCheckerStatus &amp;&amp; healthIndicatorStatus &amp;&amp; healthCallbackStatus) &#123;</span><br><span class="line">        logger.info(<span class="string">"Readiness check result: success"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.error(<span class="string">"Readiness check result: fail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Readiness-Check-做了什么"><a href="#Readiness-Check-做了什么" class="headerlink" title="Readiness Check 做了什么"></a>Readiness Check 做了什么</h4><p>前面是 <code>SOFABoot</code> 健康检查组件处理健康检查逻辑的一个大体流程，了解到了 <code>Readiness</code> 包括检查 <code>HealthChecker</code> 类型的<code>bean</code>和<code>HealthIndicator</code> 类型的 <code>bean</code>。其中<code>HealthIndicator</code>是<code>SpringBoot</code>自己的接口 ，而 <code>HealthChecker</code> 是 <code>SOFABoot</code> 提供的接口。下面继续通过 <code>XXXProcess</code> 来看下 <code>Readiness Check</code> 到底做了什么？</p><h4 id="HealthCheckerProcessor"><a href="#HealthCheckerProcessor" class="headerlink" title="HealthCheckerProcessor"></a>HealthCheckerProcessor</h4><p><code>HealthChecker</code> 的健康检查处理器，<code>readinessHealthCheck</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readinessHealthCheck</span><span class="params">(Map&lt;String, Health&gt; healthMap)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(healthCheckers, <span class="string">"HealthCheckers must not be null."</span>);</span><br><span class="line">    logger.info(<span class="string">"Begin SOFABoot HealthChecker readiness check."</span>);</span><br><span class="line">    <span class="keyword">boolean</span> result = healthCheckers.entrySet().stream()</span><br><span class="line">            .map(entry -&gt; doHealthCheck(entry.getKey(), entry.getValue(), <span class="keyword">true</span>, healthMap, <span class="keyword">true</span>))</span><br><span class="line">            .reduce(<span class="keyword">true</span>, BinaryOperators.andBoolean());</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        logger.info(<span class="string">"SOFABoot HealthChecker readiness check result: success."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.error(<span class="string">"SOFABoot HealthChecker readiness check result: failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里每个<code>HealthChecker</code>又委托给<code>doHealthCheck</code>来检查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doHealthCheck</span><span class="params">(String beanId, HealthChecker healthChecker, <span class="keyword">boolean</span> isRetry,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Map&lt;String, Health&gt; healthMap, <span class="keyword">boolean</span> isReadiness)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(healthMap, <span class="string">"HealthMap must not be null"</span>);</span><br><span class="line">    Health health;</span><br><span class="line">    <span class="keyword">boolean</span> result;</span><br><span class="line">    <span class="keyword">int</span> retryCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// check 类型  readiness ？ liveness</span></span><br><span class="line">    String checkType = isReadiness ? <span class="string">"readiness"</span> : <span class="string">"liveness"</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 Health 对象</span></span><br><span class="line">        health = healthChecker.isHealthy();</span><br><span class="line">        <span class="comment">// 获取 健康检查状态结果</span></span><br><span class="line">        result = health.getStatus().equals(Status.UP);</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            logger.info(<span class="string">"HealthChecker[&#123;&#125;] &#123;&#125; check success with &#123;&#125; retry."</span>, beanId, checkType,retryCount);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.info(<span class="string">"HealthChecker[&#123;&#125;] &#123;&#125; check fail with &#123;&#125; retry."</span>, beanId, checkType,retryCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重试 &amp;&amp; 等待</span></span><br><span class="line">        <span class="keyword">if</span> (isRetry &amp;&amp; retryCount &lt; healthChecker.getRetryCount()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                retryCount += <span class="number">1</span>;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(healthChecker.getRetryTimeInterval());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                logger</span><br><span class="line">                    .error(</span><br><span class="line">                        String</span><br><span class="line">                            .format(</span><br><span class="line">                                <span class="string">"Exception occurred while sleeping of %d retry HealthChecker[%s] %s check."</span>,</span><br><span class="line">                                retryCount, beanId, checkType), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (isRetry &amp;&amp; retryCount &lt; healthChecker.getRetryCount());</span><br><span class="line">    <span class="comment">// 将当前 实例 bean 的健康检查结果存到结果集healthMap中</span></span><br><span class="line">    healthMap.put(beanId, health);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            logger</span><br><span class="line">                .error(</span><br><span class="line">                    <span class="string">"HealthChecker[&#123;&#125;] &#123;&#125; check fail with &#123;&#125; retry; fail details:&#123;&#125;; strict mode:&#123;&#125;"</span>,</span><br><span class="line">                    beanId, checkType, retryCount,</span><br><span class="line">                    objectMapper.writeValueAsString(health.getDetails()),</span><br><span class="line">                    healthChecker.isStrictCheck());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException ex) &#123;</span><br><span class="line">        logger.error(</span><br><span class="line">            String.format(<span class="string">"Error occurred while doing HealthChecker %s check."</span>, checkType), ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回健康检查结果</span></span><br><span class="line">    <span class="keyword">return</span> !healthChecker.isStrictCheck() || result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>doHealthCheck</code> 结果需要依赖具体 <code>HealthChecker</code> 实现类的处理。通过这样一种方式可以<code>SOFABoot</code>可以很友好的实现对所以 <code>HealthChecker</code> 的健康检查。<code>HealthIndicatorProcessor</code> 的 <code>readinessHealthCheck</code> 和<code>HealthChecker</code>的基本差不多；有兴趣的可以自行阅读源码 <a href="https://github.com/alipay/sofa-boot" target="_blank" rel="noopener">Alipay-SOFABoot</a>。</p><h4 id="AfterReadinessCheckCallbackProcessor"><a href="#AfterReadinessCheckCallbackProcessor" class="headerlink" title="AfterReadinessCheckCallbackProcessor"></a>AfterReadinessCheckCallbackProcessor</h4><p>这个接口是 <code>SOFABoot</code> 提供的一个扩展接口， 用于在 <code>Readiness Check</code> 之后做一些事情。其实现思路和前面的<code>XXXXProcessor</code> 是一样的，对之前初始化时得到的所有的<code>ReadinessCheckCallbacks</code>实例<code>bean</code>逐一进行回调处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">afterReadinessCheckCallback</span><span class="params">(Map&lt;String, Health&gt; healthMap)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"Begin ReadinessCheckCallback readiness check"</span>);</span><br><span class="line">    Assert.notNull(readinessCheckCallbacks, <span class="string">"ReadinessCheckCallbacks must not be null."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = readinessCheckCallbacks.entrySet().stream()</span><br><span class="line">            .map(entry -&gt; doHealthCheckCallback(entry.getKey(), entry.getValue(), healthMap))</span><br><span class="line">            .reduce(<span class="keyword">true</span>, BinaryOperators.andBoolean());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        logger.info(<span class="string">"ReadinessCheckCallback readiness check result: success."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.error(<span class="string">"ReadinessCheckCallback readiness check result: failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样也是委托给了<code>doHealthCheckCallback</code>来处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doHealthCheckCallback</span><span class="params">(String beanId,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      ReadinessCheckCallback readinessCheckCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Map&lt;String, Health&gt; healthMap)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(healthMap, () -&gt; <span class="string">"HealthMap must not be null"</span>);</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    Health health = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        health = readinessCheckCallback.onHealthy(applicationContext);</span><br><span class="line">        result = health.getStatus().equals(Status.UP);</span><br><span class="line">        <span class="comment">// print log 省略</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 存入 healthMap</span></span><br><span class="line">        healthMap.put(beanId, health);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展-Readiness-Check-能力"><a href="#扩展-Readiness-Check-能力" class="headerlink" title="扩展 Readiness Check 能力"></a>扩展 Readiness Check 能力</h4><p>按照上面的分析，我们可以自己来实现下这几个扩展。</p><h4 id="实现-HealthChecker-接口"><a href="#实现-HealthChecker-接口" class="headerlink" title="实现 HealthChecker 接口"></a>实现 HealthChecker 接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperHealthChecker</span> <span class="keyword">implements</span> <span class="title">HealthChecker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Health <span class="title">isHealthy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以检测数据库连接是否成功</span></span><br><span class="line">        <span class="comment">// 可以检测zookeeper是否启动成功</span></span><br><span class="line">        <span class="comment">// 可以检测redis客户端是否启动成功</span></span><br><span class="line">        <span class="comment">// everything you want ...</span></span><br><span class="line">        <span class="keyword">if</span>(OK)&#123;</span><br><span class="line">            <span class="keyword">return</span> Health.up().build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Health.down().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getComponentName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 组件名</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"GlmapperComponent"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRetryCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重试次数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getRetryTimeInterval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重试间隔</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStrictCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现-ReadinessCheckCallback-接口"><a href="#实现-ReadinessCheckCallback-接口" class="headerlink" title="实现 ReadinessCheckCallback 接口"></a>实现 ReadinessCheckCallback 接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperReadinessCheckCallback</span> <span class="keyword">implements</span> <span class="title">ReadinessCheckCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Health <span class="title">onHealthy</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        Object glmapperHealthChecker = applicationContext.getBean(<span class="string">"glmapperHealthChecker"</span>);</span><br><span class="line">        <span class="keyword">if</span> (glmapperHealthChecker <span class="keyword">instanceof</span> GlmapperHealthChecker)&#123;</span><br><span class="line">            <span class="keyword">return</span> Health.up().build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Health.down().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看下健康检查日志：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/16/1671b484144d1d65?w=1590&amp;h=386&amp;f=png&amp;s=475058" alt=""></p><p>可以看到我们自己定义的检查类型<code>ready</code>了。</p><p>从日志看到有一个 <code>sofaBootHealthIndicator</code>，实现了<code>HealthIndicator</code> 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaBootHealthIndicator</span> <span class="keyword">implements</span> <span class="title">HealthIndicator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String    CHECK_RESULT_PREFIX = <span class="string">"Middleware"</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HealthCheckerProcessor healthCheckerProcessor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Health <span class="title">health</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Health&gt; healths = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 调用了 healthCheckerProcessor 的 livenessHealthCheck</span></span><br><span class="line">        <span class="keyword">boolean</span> checkSuccessful = healthCheckerProcessor.livenessHealthCheck(healths);</span><br><span class="line">        <span class="keyword">if</span> (checkSuccessful) &#123;</span><br><span class="line">            <span class="keyword">return</span> Health.up().withDetail(CHECK_RESULT_PREFIX, healths).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Health.down().withDetail(CHECK_RESULT_PREFIX, healths).build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>livenessHealthCheck</code> 和 <code>readinessHealthCheck</code> 两个方法都是交给 <code>doHealthCheck</code> 来处理的，没有看出来有什么区别。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文基于 <code>SOFABoot 3.0.0</code> 版本，与之前版本有一些区别。详细变更见：<a href="http://www.sofastack.tech/sofa-boot/docs/upgrade_3_x" target="_blank" rel="noopener">SOFABoot upgrade_3_x</a>。本篇文章简单介绍了 <code>SOFABoot</code> 对 <code>SpringBoot</code> 健康检查能力扩展的具体实现细节。</p><p>最后再来补充下 <code>liveness</code> 和 <code>readiness</code>，从字面意思来理解，<code>liveness</code>就是是否是活的，<code>readiness</code> 就是意思是否可访问的。</p><ul><li><code>readiness</code>：应用即便已经正在运行了，它仍然需要一定时间才能 提供 服务，这段时间可能用来加载数据，可能用来构建缓存，可能用来注册服务，可能用来选举 <code>Leader</code>等等。总之 <code>Readiness</code> 检查通过前是不会有流量发给应用的。目前 <code>SOFARPC</code> 就是在 <code>readiness check</code> 之后才会将所有的服务注册到注册中心去。</li><li><code>liveness</code>：检测应用程序是否正在运行</li></ul>]]></content>
      
      
      <categories>
          
          <category> SOFA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SOFABoot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>20181111-书法练习</title>
      <link href="/2018/11/10/shufa-20181111/"/>
      <url>/2018/11/10/shufa-20181111/</url>
      
        <content type="html"><![CDATA[<blockquote><p>黄鹤楼送孟浩然之广陵 -李白<br>故人西辞黄鹤楼，烟花三月下扬州<br>孤帆远影碧空尽，唯见长江天际流</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/15/16715f8dc079617e?w=1080&amp;h=1440&amp;f=jpeg&amp;s=101229" alt=""></p><blockquote><p>将进酒 -李白<br>君不见，黄河之水天上来，奔流到海不复回。<br>君不见，高堂明镜悲白发，朝如青丝暮成雪。<br>人生得意须尽欢，莫使金樽空对月。<br>天生我材必有用，千金散尽还复来。<br>烹羊宰牛且为乐，会须一饮三百杯。<br>岑夫子，丹丘生，将进酒，杯莫停。<br>与君歌一曲，请君为我倾耳听。(倾耳听 一作：侧耳听)<br>钟鼓馔玉不足贵，但愿长醉不复醒。(不足贵 一作：何足贵；不复醒 一作：不愿醒/不用醒)<br>古来圣贤皆寂寞，惟有饮者留其名。(古来 一作：自古；惟 通：唯)<br>陈王昔时宴平乐，斗酒十千恣欢谑。<br>主人何为言少钱，径须沽取对君酌。<br>五花马，千金裘，呼儿将出换美酒，与尔同销万古愁。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/15/16715f905c481e3f?w=1440&amp;h=1080&amp;f=jpeg&amp;s=110473" alt=""></p><blockquote><p>青玉案·元夕 -辛弃疾<br>东风夜放花千树。更吹落、星如雨。<br>宝马雕车香满路。凤箫声动，玉壶光转，一夜鱼龙舞。<br>蛾儿雪柳黄金缕。笑语盈盈暗香去。<br>众里寻他千百度。<br>蓦然回首，那人却在，灯火阑珊处。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/15/16715f92aee8f1b7?w=1440&amp;h=1080&amp;f=jpeg&amp;s=131383" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 书法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>菜鸟成长系列-策略模式</title>
      <link href="/2018/11/10/java-design-model-strategy/"/>
      <url>/2018/11/10/java-design-model-strategy/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上次在模板方法模式中有提及到，模板方法模式通常不会单独来试用，在一些实际的应用中会搭配其他的模式来使用，比如说今天要学习的策略模式。</p></blockquote><p>一直我都很喜欢策略这个词，有种莫名的高大上，对三国有了解的小伙伴肯定会知道，有的谋士是比较直接的，献计就是献计，有话当面说；但是也有的谋士就是比较喜欢搞一种神秘感，弄个小布袋子里面塞个小布条（简称：锦囊）；对于一件很棘手的事情，在交代下去的时候就会有这样的嘱咐：“此事关系重大，还望XXX（昵称）务必处理妥帖；这里有三个锦囊，如果XXXX，你就拆开第X个锦囊，然后XXXX”；有时候我就很不解，假如真在遇到事情的时候来看，那路上丢了怎么办？一摸口袋就懵逼了有木有？</p><p>扯远了，不过意思就是这个意思，一个锦囊其实就是一种策略；然后它有一个总的背景（我们称之为上下文环境），这个大背景下，每个不同的场景都会有一中策略来对应处理；</p><p>我们先以上面的列子为背景来撸一个小的例子，然后再去看一个spring中比较典型的策略模式使用，最后再来探讨下策略模式的类图，并以此来说明策略模式中的一些基本角色及其职责。</p><h3 id="锦囊妙计"><a href="#锦囊妙计" class="headerlink" title="锦囊妙计"></a>锦囊妙计</h3><blockquote><p>兵马未动，粮草先行；但是这个运输粮草到底是走水路还是走陆地呢？那这得看往哪运…</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.policy;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 大背景，运输粮草</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/5/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransportFood</span> </span>&#123;</span><br><span class="line">    <span class="comment">//持有一个运输策略的对象</span></span><br><span class="line">    <span class="keyword">private</span> TransportFoodStrategy strategy;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，传入一个具体策略对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strategy    具体策略对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TransportFood</span><span class="params">(TransportFoodStrategy strategy)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 策略方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trasportFood</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        strategy.trasport();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是我们的总体背景，就是运输粮草；但是这个只是说要运输粮草，但是并没有说是怎么运？这就得TransportFoodStrategy这个运输策略有具体的运输方案。</p><ul><li>运输方案1：如果粮草是从武汉到南京，OK，那就走水运吧。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 运输粮草的策略之水运运输</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/5/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaterTransportStrategy</span> <span class="keyword">implements</span> <span class="title">TransportFoodStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trasport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用船，走水运"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运输方案2：如果从内蒙到北京；那就走陆运吧。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 运输粮草的策略之陆地运输</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/5/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LandTransportStrategy</span> <span class="keyword">implements</span> <span class="title">TransportFoodStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trasport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用马车，走陆运"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，来看下妙计使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 决策制定-客户端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/5/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        TransportFoodStrategy strategy =</span><br><span class="line">        getTransportFoodStrategy(<span class="string">"内蒙到北京"</span>);</span><br><span class="line"></span><br><span class="line">        TransportFood transportFood = <span class="keyword">new</span> TransportFood(strategy);</span><br><span class="line">        transportFood.trasportFood();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取运输方案</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lineType 运输路线</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TransportFoodStrategy <span class="title">getTransportFoodStrategy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String lineType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lineType.equals(<span class="string">"内蒙到北京"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LandTransportStrategy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lineType.equals(<span class="string">"武汉到南京"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WaterTransportStrategy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-&gt; 用马车，走陆运</span><br></pre></td></tr></table></figure><p>粮草运完了，真正的表演开始了…</p><h3 id="Spring中典型的策略模式使用"><a href="#Spring中典型的策略模式使用" class="headerlink" title="Spring中典型的策略模式使用"></a>Spring中典型的策略模式使用</h3><p>我们知道spring加载资源文件是通过ResourceLoader来搞定的。在ResourceLoader中提供了一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>;</span><br></pre></td></tr></table></figure><p>这个方法的注解中说道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//允许多个资源调用。</span><br><span class="line">allowing for multiple &#123;@link Resource#getInputStream()&#125; calls.</span><br></pre></td></tr></table></figure><p>这里就很赤裸裸了，他告诉了你要获取资源，但是如果获取资源呢？这就得看有哪些具体的获取策略了。</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/5/1633103f6010a684?w=1724&amp;h=642&amp;f=png&amp;s=329841" alt=""></p><p>上图就是Resource的具体子类实现，也就是一些具体的策略。我们比较常见的应该算是UrlResource（加载URL指定的资源）和ClasspathResource（加载类路径中的资源）这两个。再来看下这个getResource这个方法的实现：</p><blockquote><p>getResource方法是在DefaultResourceLoader中具体实现的；DefaultResourceLoader是ResourceLoader的默认实现。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">Assert.notNull(location, <span class="string">"Location must not be null"</span>);</span><br><span class="line"><span class="comment">//首先使用ProtocolResolver来通过location参数创建Resource对象</span></span><br><span class="line"><span class="comment">// spring4.3.x开始才有的</span></span><br><span class="line"><span class="keyword">for</span> (ProtocolResolver protocolResolver : <span class="keyword">this</span>.protocolResolvers) &#123;</span><br><span class="line">            Resource resource = protocolResolver.resolve(location,<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> resource;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//指定路径的</span></span><br><span class="line"><span class="keyword">if</span> (location.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以classpath开头的</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(</span><br><span class="line">CLASSPATH_URL_PREFIX.length()), getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里是先尝试解析是否是带有网络协议的资源，</span></span><br><span class="line"><span class="comment">//如果解析异常，则是在异常处理中使用了一种默认的机制。</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Try to parse the location as a URL...</span></span><br><span class="line">URL url = <span class="keyword">new</span> URL(location);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line"><span class="comment">// No URL -&gt; resolve as resource path.</span></span><br><span class="line"><span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/io/ProtocolResolver.html" target="_blank" rel="noopener">ProtocolResolver</a></p><p>其实我们可以发现，这里的location其实和我们上面那个例子中的lineType的作用是一样的，根据这个来确定具体使用哪个策略方法。</p><ul><li>策略1：使用ProtocolResolver来通过location参数创建Resource对象，在<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/io/ProtocolResolver.html" target="_blank" rel="noopener">ProtocolResolver</a>中关于ProtocolResolver的解释是：A resolution strategy for protocol-specific resource handles-协议专用资源句柄的解析策略。</li><li>策略2：返回给定路径上资源的资源句柄。</li><li>策略3：以classpath:为前缀的，这种location参数直接返回一个ClassPathResource对象，表示加载classes路径下的资源；</li><li>策略4：使用网络协议作为前缀的，比如http、ftp等，这种直接返回一个UrlResource对象；</li><li>策略5：无前缀的，在默认实现中和第三种一样是加载classes路径下的资源，不同的是此处当作是ClassPathContextResource来处理的。</li></ul><p>Spring中Resource的策(tao)略(lu)说完了，再回过头来看下策略模式的一些具体理论知识。</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><blockquote><p>定义：策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。</p></blockquote><p>结合前面的例子分析和这段定义，可以知道，其实策略模式真的意图不是如何实现策略算法，它更在意的是如何组织这些算法。</p><p>这也是策略模式的使用可以让程序结构更灵活，具有更好的维护性和扩展性的重要因素。</p><p><strong>类图：</strong><br><img src="https://user-gold-cdn.xitu.io/2018/5/6/1633122266b7c893?w=1232&amp;h=570&amp;f=png&amp;s=36574" alt="类图"><br><code>这个类图画的确实是有点丑，但是为了亲手绘制一下，所以还请多多见谅！</code></p><p><strong>类图中的一些角色：</strong></p><ul><li>context：策略背景，也就是需要使用策略的主体；它持有一个strategy类的引用</li><li>strategy：抽象策略，这个角色给出了所有具体策略类所需的接口。所以通常是一个抽象类或者接口。</li><li>strategyPolicy：具体策略，它的作用就是包装具体的算法或者行为</li></ul><p>那么在实际的应用中，策略模式到底给我们带来的好处是什么，它能够帮助我们解决什么样的问题呢？这个需要从模式本身的优缺点来看：</p><p><strong>优点</strong></p><ul><li><p>策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。</p></li><li><p>策略模式可以避免使用多重条件(if-else)语句。通常对于一个背景主体，一般只会有一种策略算法可供使用，使用多重条件句的话不易维护；因为它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起了。</p></li></ul><p><strong>缺点</strong></p><ul><li><p>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。</p></li><li><p>由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。–如果策略很多，通常会采用一些混合策略来避免策略类的不断膨胀。</p></li></ul><p>在了解其优缺点的情况下，我们就可以合理的将其放在一些适当的场景中来；如以下场景：</p><ul><li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 </li><li>一个系统需要动态地在几种算法中选择一种。   </li><li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li></ul><p><strong>参考</strong></p><ul><li>《JAVA与模式》</li><li><a href="http://www.cnblogs.com/java-my-life/archive/2012/05/10/2491891.html" target="_blank" rel="noopener">《JAVA与模式》之策略模式</a></li><li><a href="http://www.runoob.com/design-pattern/strategy-pattern.html" target="_blank" rel="noopener">策略模式</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 架构之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>菜鸟成长系列-模板方法模式</title>
      <link href="/2018/11/10/java-design-model-modulemethod/"/>
      <url>/2018/11/10/java-design-model-modulemethod/</url>
      
        <content type="html"><![CDATA[<blockquote><p>模板方法模式在sring中有大量的应用，一般我们会使用模板方法来将当前的实现委托给子类来实现，增强代码的可扩展性和复用性。因为涉及到父子类关系，所以模板方法模式是基于“继承”来实现的；模板方法模式属于行为型模式。</p></blockquote><p><code>简单地说就是，通过父类来定义一系列的算法骨架，并且约定这些方法及其调用顺序，而具体的某些特定方法由子类实现。</code></p><p>先来看一个小demo；我们以写博客来举例子，一般我们写博客的步骤如下：</p><ul><li>打开目标网站</li><li>打开编辑器</li><li>写文章</li><li>发布文章</li></ul><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><p>首先是定义一个父类，并且提供一个模板方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.mudolmethod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 抽象模板父类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTemplateMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流程方法1：抽象方法，供子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">openTargetWebSite</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流程方法2：子类可选择重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openMarkDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开编辑器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流程方法3：抽象方法，供子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeBlog</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流程方法4：子类可选择重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publisher</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发布文章"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法，此处申明为final，是不希望子类覆盖这个方法，防止更改流程的执行顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">templateWriteBlog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        openTargetWebSite();</span><br><span class="line">        openMarkDown();</span><br><span class="line">        writeBlog();</span><br><span class="line">        publisher();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中我们提供了一个templateWriteBlog方法，这里方法中包括了写博客的一些流程。在这些流程方法中有些方法父类提供了默认实现，而一些具有差异性的方法则让子类来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.mudolmethod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 子类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JueJinTemplateMethodPolicy</span> <span class="keyword">extends</span> <span class="title">AbstractTemplateMethod</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openTargetWebSite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开掘金网站"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBlog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"写一篇Spring相关的文章"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类1：JueJinTemplateMethodPolicy，这个子类中实现了父类中的部分方法，包括：openTargetWebSite和writeBlog。（一般情况下不会去重写父类默认已经实现的方法，仅实现父类中预留的抽象方法来实现）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.mudolmethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 子类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CSDNTemplateMethodPolicy</span> <span class="keyword">extends</span> <span class="title">AbstractTemplateMethod</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openTargetWebSite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开CSDN网站"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBlog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"写一篇设计模式文章"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类2：CSDNTemplateMethodPolicy,这个子类的作用其实和子类1是一样的，只不过是提供了另外的一种实现策略；（很多情况下，模板方法模式都是和策略模式来联合使用的，通过一套模板机制，对于模板中的部分流程通过不同的策略来实现不同的功能）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.mudolmethod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 子类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractTemplateMethod csdnTemplate = <span class="keyword">new</span> CSDNTemplateMethodPolicy();</span><br><span class="line">        csdnTemplate.templateWriteBlog();</span><br><span class="line"></span><br><span class="line">        AbstractTemplateMethod juejinTemplate = <span class="keyword">new</span> JueJinTemplateMethodPolicy();</span><br><span class="line">        juejinTemplate.templateWriteBlog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打开CSDN网站</span><br><span class="line">打开编辑器</span><br><span class="line">写一篇设计模式文章</span><br><span class="line">发布文章</span><br><span class="line"></span><br><span class="line">打开掘金网站</span><br><span class="line">打开编辑器</span><br><span class="line">写一篇Spring相关的文章</span><br><span class="line">发布文章</span><br></pre></td></tr></table></figure><p>上面是客户端代码及输出结果。通过输出我们可以明显的看出，模板中的一些方法将延迟到子类中去实现，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。因此对于模板方法这个模式来说，父类是始终控制着整个流程主动权的，而子类只是辅助父类实现某些可定制的步骤。 </p><h2 id="模式解析"><a href="#模式解析" class="headerlink" title="模式解析"></a>模式解析</h2><p>先看下模板方法模式的类图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/30/163148bb2155fca2?w=459&amp;h=315&amp;f=png&amp;s=85263" alt=""></p><p>从类图中可以看出，模板方法模式中的角色也是很简单的，主要包括两个角色：</p><ul><li><p>抽象模板（AbstractTemplate）：</p><ul><li>定义一个或者多个抽象操作，以便于让子类实现。这些抽象操作就是流程中的基本操作（对应的是模板方法中的某个具体的操作方法）；这些基本操作是一个顶级逻辑的组成步骤</li><li>定义并且实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类中取实现，当然，在这个顶级逻辑中，部分方法也可以由父类来提供默认实现的。</li></ul></li><li><p>具体类（SubTemplateImpl)：</p><ul><li>实现父类所定义的一个或者多个抽象方法</li><li>每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法的不同实现。</li></ul></li></ul><p>模板方法中的这个方法的概念拆开来说包括两种，一种是模板方法，还有一种是模板方法里面的基本方法。模板方法定义游戏规则，基本方法实现规则中的每个部分。</p><p>模板方法带来的优势是显而易见的，它可以帮助我们有效的帮助我们搞定下面的这些场景问题：</p><ul><li>封装不变部分，扩展可变部分。 </li><li>提取公共代码，便于维护。 </li><li>行为由父类控制，子类实现。</li></ul><p>但是缺点也很明显，因为对于每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p><h3 id="典型的模板方法模式的应用"><a href="#典型的模板方法模式的应用" class="headerlink" title="典型的模板方法模式的应用"></a>典型的模板方法模式的应用</h3><p>最先想到的就是servlet，servlet的生命周期(以前经常遇到的面试点，现在已经没人问了吧)</p><ul><li>初始化 init</li><li>处理   service</li><li>销毁   destroy</li></ul><blockquote><p>其实这里我觉得也是模板方法的一种体现，虽然在servlet中没有定义顶层的模板方法来控制这个流程(我的想法是这个流程是由容器来控制的，也可能是一种默认的约定)。</p></blockquote><p>在其子类GenericServlet中对init和destroy有了默认的实现，而service方法则是交由子类来实现的，也就是说任何servlet类均必须实现service方法。</p><p>这里的service方法就是一个模板方法。service方法中调用了7个do方法中的一个或者几个，完成对客户端的响应，这些do方法需要由HttpServlet的具体子类提供。</p><p>HttpServlet中的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse</span></span></span><br><span class="line"><span class="function"><span class="params">resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String method = req.getMethod();</span><br><span class="line">        <span class="keyword">long</span> lastModified;</span><br><span class="line">        <span class="keyword">if</span> (method.equals(<span class="string">"GET"</span>)) &#123;</span><br><span class="line">            lastModified = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">            <span class="keyword">if</span> (lastModified == -<span class="number">1L</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> ifModifiedSince =</span><br><span class="line">                req.getDateHeader(<span class="string">"If-Modified-Since"</span>);</span><br><span class="line">                <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">                    <span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp.setStatus(<span class="number">304</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"HEAD"</span>)) &#123;</span><br><span class="line">            lastModified = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">            <span class="keyword">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">            <span class="keyword">this</span>.doHead(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"POST"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"PUT"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doPut(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"DELETE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doDelete(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"OPTIONS"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doOptions(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"TRACE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doTrace(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String errMsg =</span><br><span class="line">            lStrings.getString(<span class="string">"http.method_not_implemented"</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> Object[]&#123;method&#125;;</span><br><span class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">            resp.sendError(<span class="number">501</span>, errMsg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>FrameworkServlet中的实现(FrameworkServlet是SpringMVC核心控制器DispatchServlet的父类)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Override the parent class implementation in order to intercept</span></span><br><span class="line"><span class="comment"> PATCH requests.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class="line"><span class="keyword">if</span> (HttpMethod.PATCH == httpMethod || httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">super</span>.service(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于模板方法模式的学习就到这里了。</p>]]></content>
      
      
      <categories>
          
          <category> 架构之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>菜鸟成长系列-观察者模式</title>
      <link href="/2018/11/10/java-design-model-obs/"/>
      <url>/2018/11/10/java-design-model-obs/</url>
      
        <content type="html"><![CDATA[<p><code>最近想深入研究下响应式编程，作为基础很有必要来把观察者模式撸一遍；一开始我是觉得很easy,然后就直接开撸了，撸着撸着发现撸不动了。因为我突然不太明白这个模式了，说好的观察者，到底发布-订阅的两者执行者谁才是观察者？又或者说还有其他角色？但是根据《JAVA与模式》一书中的结构，并没有额外的角色出现。</code></p><p>思考中….，好吧想不出来….，跑步去…</p><p>跑步时我给自己罗列了几个问题：</p><blockquote><p>这里先抛出定义：GOF给观察者模式如下定义：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p></blockquote><ul><li>既然是对象状态发生变更，那么到底是谁的状态发生了变更，又导致了谁被通知。</li><li>观察者模式既然又可以称之为“发布-订阅模式”，那么对应起来，观察者到底承当了“发布”的角色还是“订阅”的角色。就是说观察者到底是主动的还是被动的？</li><li>被观察者又干了什么事？它是主动的还是被动的角色？</li></ul><p>这里由于一些定式思维，总会觉得既然是“被观察者”，那么这个“被”字就是不是就表明“被观察者”是被动接受变更的一方，也就是接受通知的一方呢？</p><p>之前我也是走到这个胡同里了，程序写完总觉得哪里不对；回过头看，还是自己太年轻，没有get到哪些大佬们的点。</p><p>先来看程序；这里用掘金来打个比方，我的博客glmmaper作为被观察者，也就是发布者。掘金小伙伴们作为观察者，也就是订阅者。</p><p>具体逻辑：小伙伴们（订阅者）关注（订阅）了我的博客（发布者），如果我发布了一篇文章（状态变更），就会通知（推送消息）所有关注我的小伙伴。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.observor;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 抽象主题接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增关注者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer 关注的小伙伴</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFocusObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消关注</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer 取消关注的小伙伴</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeFocusObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知机制，通知机制由相关事件来触发，比如说发布文章</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> blogName          博客名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> articleName       文章名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(String blogName,String articleName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个方法，一个是博客主页增加了一个关注者；一个是博客主页有小伙伴取消的关注（对于博客来说就是移除一个关注者，这里不知道是否也会觉得别扭？明明你取消的关注，为啥说成是我移除你，也就是不让你关注了，还能这么玩?这里肯定是需要在引入其他的一些辅助机制，比如说你在客户端发起了一个取消关注的请求，后端处理的时候掘金的工程师们就是在我的关注列表中将你移除的，嗯，这么一想确实是我不让你关注了。😄….）；最后一个方法是发起一个通知。下面是一个具体的博客，比如说是glmapper；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.observor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 这个是具体发布者，这里比喻成我的博客glmapper</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span>  <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 我的当前关注列表 */</span></span><br><span class="line">    List&lt;Observer&gt; Observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">/** 我的博客名 ：求关注 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String blogName = <span class="string">"glmapper"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFocusObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        Observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeFocusObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        Observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(String blogName,String articleName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer:Observers) &#123;</span><br><span class="line">            observer.update(blogName,articleName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里是发布文章，触发通知事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishArticle</span><span class="params">(String articleName)</span></span>&#123;</span><br><span class="line">        notifyObservers(blogName,articleName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面提到，通知事件肯定是由于某些状态发生变更了，才会进行通知，这里就可以比方为我发布了一篇博客，然后通知你（这里只能假如你关注了）。再来看观察者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.observor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 订阅者抽象接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用此方法会更新状态，做出相应的动作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> blogName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> articleName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String blogName,String articleName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象订阅者，有一个update方法，通知你去做出相应的动作，具体动作每个观察者都可能不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.observor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 这个是具体订阅者,这里可以比喻成博客关注者，</span></span><br><span class="line"><span class="comment"> * 收到变更信息之后需要做出相应的动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String blogName,String articleName)</span> </span>&#123;</span><br><span class="line">        System.out.println(blogName+<span class="string">"发布了新的文章，文章名为："</span>+articleName);</span><br><span class="line">        read(articleName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String articleName)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"即将阅读 "</span>+articleName+<span class="string">" 这篇文章"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个具体的关注者，加入说就是你。博客更新之后发了一个通知给你(掘金app推送的消息)，然后你点了一下，这个也是一种动作。例子中举的是read,就是关注者做出阅读的动作。</p><p>看下最后的运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.observor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: [描述文本]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMainIndex</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//博客主体</span></span><br><span class="line">        ConcreteSubject subject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        <span class="comment">//关注者：handSome是帅气的意思</span></span><br><span class="line">        Observer handSome = <span class="keyword">new</span> ConcreteObserver();</span><br><span class="line">        <span class="comment">//增加一个关注者</span></span><br><span class="line">        subject.addFocusObserver(handSome);</span><br><span class="line">        <span class="comment">//发一篇文章</span></span><br><span class="line">        subject.publishArticle(<span class="string">"设计模式-观察者模式"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">glmapper发布了新的文章，文章名为：设计模式-观察者模式</span><br><span class="line">即将阅读 设计模式-观察者模式 这篇文章</span><br></pre></td></tr></table></figure><p><strong>酒桶说：啊，欢乐时光总是短暂的</strong></p><p>所以作为积累，还是需要将一些基本的概念来罗列一下的。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/22/162eddecf0e6a860?w=607&amp;h=253&amp;f=jpeg&amp;s=27115" alt="观察者模式类图"></p><p><strong>主要角色：</strong></p><ul><li>抽象主题角色（Subject：主题角色将所有对观察者对象的引用保存在一个集合中，每个主题可以有任意多个观察者。抽象主题提供了增加和删除等观察者对象的接口。</li><li>抽象观察者角色（Observer）：为所有的具体观察者定义一个接口，在观察的主题发生改变时更新自己。</li><li>具体主题角色（ConcreteSubject）(1个)：存储相关状态到具体观察者对象，当具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个具体子类实现。</li><li>具体观察者角色（ConcretedObserver）(多个)：存储一个具体主题对象，存储相关状态，实现抽象观察者角色所要求的更新接口，以使得其自身状态和主题的状态保持一致。</li></ul><p><strong>具体关系：</strong></p><ul><li><p>抽象主题（Subject）(接口)–&gt;被具体主题（ConcreteSubject）角色(1个)实现</p></li><li><p>抽象观察者（Observer）(接口)–&gt;被具体观察者（ConcretedObserver）角色(N个)实现</p></li><li><p>观察者对象载入主题方法,并在主题方法中调用观察者对象实现的接口方法update来让自己发生变更响应。</p></li></ul><p><strong>一些场景：</strong></p><ul><li>当对一个对象的的改动会引发其他对象的变动时，而且你无法预测有多少个对象需要被改动。</li><li>当一个对象需要有能力通知其他对象，且不需要了解这些对象是什么类型时。</li></ul><p>基于发布订阅的具体实现例子还是很多的，比较典型的就是这种订阅一个博客，然后博客更新推送；还有微信公众号，服务号这些。</p><p>到这里我们再回过头来看一开始留下的几个问题：</p><ul><li>被观察者的状态发生变更，然后“主动通知”观察者，并不是说，观察者主动去获取通知。</li><li>被观察者是消息发布者，观察者是消息订阅者；观察者是被动接受者。</li><li>被观察者的作用就是存储当前的观察者列表，然后提供一些通知机制来告诉观察者自己发生了状态变更，是主动者。</li></ul><p>OK，观察者模式就撸到这里，也欢迎小伙伴们提出自己珍贵的意见；有写的不当之处烦请及时提出。</p>]]></content>
      
      
      <categories>
          
          <category> 架构之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC源码系列：九大组件小记</title>
      <link href="/2018/11/10/spring-base-webmvc5/"/>
      <url>/2018/11/10/spring-base-webmvc5/</url>
      
        <content type="html"><![CDATA[<p>前面几篇文章都是针对于SpringMVC中的具体组件进行源码分析的；本文主要用于补充记录一下关于SpringMVC中九大组件的学习。这个会牵扯出除之前的几篇<code>HandlerMapping</code>之外的其他一些基础组件。</p><p>之前简单的有介绍过<code>DispatcherServlet</code>这个类的体系结构，此处就不再赘述了。在<code>DispatcherServlet</code>类中，其在mvc子容器进行初始化时就会完成对九大组件的初始化工作，具体哪九大组件后面会慢慢说到。先来看下在<code>DispatcherServlet</code>中是通过哪些方法来完成初始化工作的,先贴一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.initMultipartResolver(context);</span><br><span class="line">    <span class="keyword">this</span>.initLocaleResolver(context);</span><br><span class="line">    <span class="keyword">this</span>.initThemeResolver(context);</span><br><span class="line">    <span class="keyword">this</span>.initHandlerMappings(context);</span><br><span class="line">    <span class="keyword">this</span>.initHandlerAdapters(context);</span><br><span class="line">    <span class="keyword">this</span>.initHandlerExceptionResolvers(context);</span><br><span class="line">    <span class="keyword">this</span>.initRequestToViewNameTranslator(context);</span><br><span class="line">    <span class="keyword">this</span>.initViewResolvers(context);</span><br><span class="line">    <span class="keyword">this</span>.initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的<code>onRefresh</code>方法就是<code>DispatcherServlet</code>的入口方法。在<code>onRefresh</code>中又通过调用<code>initStrategies</code>方法来将各个组件的初始化逻辑进行整合，个人理解其实就是策略套策略，在一个就是职责也明确。</p><p>在<code>initStrategies</code>方法中又通过调用组件各自的初始化方法来完成具体的初始化工作。从这个地方其实就可以清楚的看出SpringMVC中的9个组件名称了。下面就来捋一捋这九大组件的基本职责。</p><h2 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h2><p>关于handlermapping在下面几篇文章中做过一些基本介绍，但是还不是很全，对于handlermapping的子类还没有分析完，这个会后期更新的。</p><ul><li><a href="https://juejin.im/post/5a5700705188257323350f42" target="_blank" rel="noopener">SpringMVC源码系列：HandlerMapping</a></li><li><a href="https://juejin.im/post/5a5700db6fb9a01cbf38427a" target="_blank" rel="noopener">SpringMVC源码系列：AbstractHandlerMapping</a></li><li><a href="https://juejin.im/post/5a8e2c486fb9a06357750b12" target="_blank" rel="noopener">SpringMVC源码系列：AbstractUrlHandlerMapping</a></li></ul><p>对于<code>HandlerMapping</code>来说，其作用就是根据<code>request</code>找到相应的处理器<code>Handler</code>和<code>Intecepter</code>拦截器。具体细节参数上面第一篇文章。</p><h2 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h2><p>如果说<code>HandlerMapping</code>是一支笔，那么<code>HandlerAdapter</code>就是用笔的人。也就是说<code>HandlerAdapter</code>就是使用处理器干活的人。为什么呢？来看下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">    <span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, Object var3)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest var1, Object var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是一目了然了，在<code>HandlerAdapter</code>接口中提供了<code>handle</code>这样一个方法，参数中Object handler第三个参数其实就是一个处理器，那我们就知道了，<code>handle</code>方法就是使用<code>handler</code>来处理逻辑的。处理之后返回一个<code>ModelAndView</code>。</p><h2 id="HandlerExceptionResolver"><a href="#HandlerExceptionResolver" class="headerlink" title="HandlerExceptionResolver"></a>HandlerExceptionResolver</h2><p>这个是<code>SpringMVC</code>中的异常处理组件，<code>HandlerExceptionResolver</code>这个组件的作用就是根据异常设置<code>ModelAndView</code>，然后再将处理结果交给<code>render</code>方法进行渲染。当然<code>render</code>也仅仅只是负责将<code>ModelAndView</code>渲染成页面，<code>ModelAndView</code>的具体来源它不关心。</p><p>这里需要说明一下，加入在渲染过程中发生异常怎么办？从上面的分析我们可以清楚的知道，<code>HandlerExceptionResolver</code>这个组件对异常的处理结果是<code>ModelAndView</code>，然后再由<code>render</code>方法进行渲染，也就是说<code>HandlerExceptionResolver</code>是在渲染之前工作的，因此渲染过程中发生异常，<code>HandlerExceptionResolver</code>是不会处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="function">ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, Object var3, Exception var4)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>HandlerExceptionResolver</code>中也只有一个方法，这个方法就是从异常中解析出<code>ModelAndView</code>。</p><h2 id="ViewResolver"><a href="#ViewResolver" class="headerlink" title="ViewResolver"></a>ViewResolver</h2><p><code>ViewResolver</code>的作用是将<code>String</code>类型的逻辑视图根据local解析为<code>View</code>视图的。下面是<code>ViewResolver</code>的源码接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewResolver</span> </span>&#123;</span><br><span class="line">    <span class="function">View <span class="title">resolveViewName</span><span class="params">(String viewName, Locale local)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看到，在<code>ViewResolver</code>中也是只有一个方法，从<code>resolveViewName</code>方法的参数和返回结果就很好的解释了其作用。</p><ul><li>viewName String类型的视图名</li><li>local 区域，可以用来做国际化。</li></ul><p><code>View</code>实际上是用来渲染页面的，也就是说将程序返回的结果填入到具体的模板里面，生成具体的视图文件，比如：jsp，ftl，html等。</p><p>但是这里又会牵扯出两个问题：</p><ul><li>用什么模板？</li><li>参数怎么填入？</li></ul><p>当然，这两个问题也就是本小节说的<code>ViewResolver</code>需要解决的问题。大体分为两种：</p><h3 id="针对单一视图类型的解析器"><a href="#针对单一视图类型的解析器" class="headerlink" title="针对单一视图类型的解析器"></a>针对单一视图类型的解析器</h3><ul><li>InternalResourceViewResolver</li><li>FreeMarkerViewResolver</li></ul><p>上面两种是用的最多的两种，<code>InternalResourceViewResolver</code>用来解析jsp，而<code>FreeMarkerViewResolver</code>则是针对FreeMarker。</p><h3 id="针对同时解析多种类型视图的解析器"><a href="#针对同时解析多种类型视图的解析器" class="headerlink" title="针对同时解析多种类型视图的解析器"></a>针对同时解析多种类型视图的解析器</h3><ul><li><p>BeanNameViewResolver</p><p>  需要同时使用视图名和对应的local来解析视图。它需要将每一个视图名和对应的视图类型配置到相应的properties文件中。（后面讲组件实现细节时给出列子）</p></li><li><p>XmlViewResolver</p><p>  XmlViewResolver和BeanNameViewResolver有点差不多，BeanNameViewResolver使用的是xml格式的配置文件。</p></li><li><p>ResourceBundleViewResolver</p><p>  这个其实就是根据viewName从Spring容器中查找bean，再根据这个bean来找到对应的视图。</p></li></ul><h2 id="LocalResolver"><a href="#LocalResolver" class="headerlink" title="LocalResolver"></a>LocalResolver</h2><p>在上面的<code>ViewResolver</code>中提到，解析视图需要两个参数，一个是String类型的逻辑视图名，另外一个是local。<code>LocalResolver</code>的作用就是从request中解析出local的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LocaleResolver</span> </span>&#123;</span><br><span class="line">    <span class="function">Locale <span class="title">resolveLocale</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLocale</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Locale local)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个方法是从request中解析出local，第二个方法是将local设置到request中。</p><p>关于local大多数情况下都是用来做国际化处理的。</p><h2 id="ThemeResolver"><a href="#ThemeResolver" class="headerlink" title="ThemeResolver"></a>ThemeResolver</h2><p>解析主题的。这个我平时除了SpringMVC自己提供的功能外，很少自己去扩展使用，即使是换主题也没有做过。不过既然存在肯定是有存在的原因的。对于我们常见的网页界面活着手机界面来说，一套主题无非就是换一套图片，活着css样式文件等等。我们通过<code>ThemeResolver</code>这个就可以实现这样的功能。具体使用其实也就是配一套properties文件供系统在不同的时候读取切换；当然使用这个也是可以实现国际化的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThemeResolver</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">resolveThemeName</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setThemeName</span><span class="params">(HttpServletRequest request, HttpServletResponse response, String themeName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RequestToViewNameTranslator"><a href="#RequestToViewNameTranslator" class="headerlink" title="RequestToViewNameTranslator"></a>RequestToViewNameTranslator</h2><p>这个其实还是挺有意思的，就是将request请求转换为视图名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface RequestToViewNameTranslator &#123;</span><br><span class="line">    String getViewName(HttpServletRequest request) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RequestToViewNameTranslator</code>只有一个默认的实现类<code>DefaultRequestToViewNameTranslator</code>。</p><p>在<code>DefaultRequestToViewNameTranslator</code>具体实现了getViewName(HttpServletRequest request)方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getViewName</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    String lookupPath = <span class="keyword">this</span>.urlPathHelper.getLookupPathForRequest(request);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.prefix + <span class="keyword">this</span>.transformPath(lookupPath) + <span class="keyword">this</span>.suffix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是委派给urlPathHelper帮助类得到请求的后缀名称，比如通过 请求路径比如/glmapper/login.do转换得到/login.do  ；具体怎么转换成视图也会在后面的组件介绍中给出具体的例子。</p><h2 id="MultipartResolver"><a href="#MultipartResolver" class="headerlink" title="MultipartResolver"></a>MultipartResolver</h2><p>这个相应小伙伴们也不陌生，做网站多多少少会涉及到文件上传。<code>MultipartResolver</code>就是用来处理上传请求的。其处理方式就是将request包装成<code>MultipartHttpServletRequest</code>。然后我们就可以用<code>MultipartHttpServletRequest</code>这个直接调用getFile获取的文件了。</p><h2 id="FlashMapManager"><a href="#FlashMapManager" class="headerlink" title="FlashMapManager"></a>FlashMapManager</h2><p>这个在redirect是进行参数传递需要用到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlashMapManager</span> </span>&#123;</span><br><span class="line">    <span class="function">FlashMap <span class="title">retrieveAndUpdate</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveOutputFlashMap</span><span class="params">(FlashMap flashMap, HttpServletRequest request, HttpServletResponse response)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>retrieveAndUpdate</code>这个方法是用来恢复参数的，对于恢复过的和超时的参数将都会被删除掉。</p><p><code>saveOutputFlashMap</code>这个方法是用来保存参数的。</p><p><code>FlashMapManager</code>的默认实现机制中参数的存储是放在session中的。我之前在一个项目中就有遇到过这种情况，对于一些我们不想暴露在url中的参数，在进行请求转发时，可以使用@RedirectAttributes将参数保存，然后在下一个处理器中获取到。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇主要是来对九大组件做一个笼统的介绍，细节实现及案例均不涉及；在后续的SpringMVC源码系列中对各个组件的实现细节分析时再一探究竟吧。</p>]]></content>
      
      
      <categories>
          
          <category> spring mvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> web </tag>
            
            <tag> mvc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC源码系列：AbstractUrlHandlerMapping</title>
      <link href="/2018/11/10/spring-base-webmvc4/"/>
      <url>/2018/11/10/spring-base-webmvc4/</url>
      
        <content type="html"><![CDATA[<p><code>AbstractUrlHandlerMapping</code>是通过url来进行匹配的，也就是说通过url与对应的Handler包存到一个Map中，然后在getHandlerInternal方法中使用url作为key从Map中获取我们的handler。</p><p><code>AbstractUrlHandlerMapping</code>实现了从url获取handler的过程，具体的映射关系，也就是handlerMap则是交给具体子类来去完成的。<code>AbstractUrlHandlerMapping</code>中定义了handlerMap用来维护映射关系，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; handlerMap = </span><br><span class="line"><span class="keyword">new</span> LinkedHashMap&lt;String, Object&gt;();</span><br></pre></td></tr></table></figure></p><p>除此之外，还有一个rootHandler,这个用于处理“/”请求。</p><p>在前面三篇文章中提到过，handler的获取是通过getHandlerInternal方法完成的，下面看下具体的源码，分析下handler的获取和handlerMap的构建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找给定请求的URL路径的Handler。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">Exception </span>&#123;</span><br><span class="line">    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">    <span class="comment">//使用lookupPath从Map中查找handler</span></span><br><span class="line">    Object handler = lookupHandler(lookupPath, request);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//临时变量，保存原始的handler</span></span><br><span class="line">    Object rawHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//是否是‘/’根路径</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"/"</span>.equals(lookupPath)) &#123;</span><br><span class="line">        <span class="comment">//获取rootHandler</span></span><br><span class="line">    rawHandler = getRootHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果rawHandler是null</span></span><br><span class="line">    <span class="keyword">if</span> (rawHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取默认的handler</span></span><br><span class="line">    rawHandler = getDefaultHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果rawHandler不是null</span></span><br><span class="line">    <span class="keyword">if</span> (rawHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是string类型，则到容器中查找具体的bean</span></span><br><span class="line">    <span class="keyword">if</span> (rawHandler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    String handlerName = (String) rawHandler;</span><br><span class="line">    <span class="comment">//容器中获取</span></span><br><span class="line">    rawHandler = getApplicationContext().getBean(handlerName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//校验handler和request是否匹配</span></span><br><span class="line">    validateHandler(rawHandler, request);</span><br><span class="line">    <span class="comment">//注册拦截器</span></span><br><span class="line">    handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//日志debug</span></span><br><span class="line">    <span class="keyword">if</span> (handler != <span class="keyword">null</span> &amp;&amp; logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">"Mapping ["</span> + lookupPath + <span class="string">"] to "</span> + handler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (handler == <span class="keyword">null</span> &amp;&amp; logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">"No handler mapping found for ["</span> + lookupPath + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回handler</span></span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>getHandlerInternal</code>方法中有几个方法调用，像getLookupPathForRequest、getRootHandler、getDefaultHandler、lookupHandler、buildPathExposingHandler等。其中getLookupPathForRequest、getRootHandler、getDefaultHandler这几个没啥好说的；比较核心的就是lookupHandler、buildPathExposingHandler这两个方法。</p><ul><li><p>lookupHandler</p><p>  lookupHandler使用getUrlPathHelper().getLookupPathForRequest(request)获取到的lookupPath从Map中查找需要的Handler,通常情况下是直接get不到的。为什么呢？原因在于很多的handler都是使用了Pattern的匹配模式，比如说“/user/*”,星号表示匹配任意内容，并非是指定url串中的字符。如果Pattern中包含了PathVariable,也不能直接从Map中获取到。</p><p>  除此之外，一个url还可能和多个Pattern相匹配，那么这个时候咱们肯定就需要选择最优的，所以说查找过程其实并不是直接从map中获取那么简单。那么就来看下在lookupHandler中都干了哪些事情：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">lookupHandler</span><span class="params">(String urlPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 直接匹配，直接从Map中获取</span></span><br><span class="line">    Object handler = <span class="keyword">this</span>.handlerMap.get(urlPath);</span><br><span class="line">    <span class="comment">//取到了</span></span><br><span class="line">    <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是string类型，则从容器中获取Bean</span></span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    String handlerName = (String) handler;</span><br><span class="line">    handler = getApplicationContext().getBean(handlerName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//验证是否匹配</span></span><br><span class="line">    validateHandler(handler, request);</span><br><span class="line">    <span class="comment">//注册拦截器</span></span><br><span class="line">    <span class="keyword">return</span> buildPathExposingHandler(handler, urlPath, urlPath, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Pattern 匹配，带*号的模式与url进行匹配</span></span><br><span class="line">    List&lt;String&gt; matchingPatterns = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String registeredPattern : <span class="keyword">this</span>.handlerMap.keySet()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getPathMatcher().match(registeredPattern, urlPath)) &#123;</span><br><span class="line">    matchingPatterns.add(registeredPattern);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (useTrailingSlashMatch()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!registeredPattern.endsWith(<span class="string">"/"</span>) &amp;&amp; getPathMatcher().match(registeredPattern + <span class="string">"/"</span>, urlPath)) &#123;</span><br><span class="line">    matchingPatterns.add(registeredPattern +<span class="string">"/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取最佳匹配</span></span><br><span class="line">    String bestPatternMatch = <span class="keyword">null</span>;</span><br><span class="line">    Comparator&lt;String&gt; patternComparator = getPathMatcher().getPatternComparator(urlPath);</span><br><span class="line">    <span class="keyword">if</span> (!matchingPatterns.isEmpty()) &#123;</span><br><span class="line">    Collections.sort(matchingPatterns, patternComparator);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">"Matching patterns for request ["</span> + urlPath + <span class="string">"] are "</span> + matchingPatterns);</span><br><span class="line">    &#125;</span><br><span class="line">    bestPatternMatch = matchingPatterns.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最佳匹配不为null</span></span><br><span class="line">    <span class="keyword">if</span> (bestPatternMatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从Map中看看是否有对应的Handler  </span></span><br><span class="line">    handler = <span class="keyword">this</span>.handlerMap.get(bestPatternMatch);</span><br><span class="line">    <span class="comment">//如果Map中没有</span></span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//是否以/结尾</span></span><br><span class="line">    Assert.isTrue(bestPatternMatch.endsWith(<span class="string">"/"</span>));</span><br><span class="line">    <span class="comment">//去除/之后再获取一次</span></span><br><span class="line">    handler = <span class="keyword">this</span>.handlerMap.get(bestPatternMatch.substring(<span class="number">0</span>, bestPatternMatch.length() - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是String类型，则从容器中获取Bean?</span></span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    String handlerName = (String) handler;</span><br><span class="line">    handler = getApplicationContext().getBean(handlerName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//验证是否匹配</span></span><br><span class="line">    validateHandler(handler, request);</span><br><span class="line">    String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestPatternMatch, urlPath);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可能有多种最佳模式，让我们确保我们有正确的URI模板变量（译）</span></span><br><span class="line">    Map&lt;String, String&gt; uriTemplateVariables = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String matchingPattern : matchingPatterns) &#123;</span><br><span class="line">    <span class="keyword">if</span> (patternComparator.compare(bestPatternMatch, matchingPattern) == <span class="number">0</span>) &#123;</span><br><span class="line">    Map&lt;String, String&gt; vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, urlPath);</span><br><span class="line">    Map&lt;String, String&gt; decodedVars = getUrlPathHelper().decodePathVariables(request, vars);</span><br><span class="line">    uriTemplateVariables.putAll(decodedVars);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">"URI Template variables for request ["</span> + urlPath + <span class="string">"] are "</span> + uriTemplateVariables);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildPathExposingHandler(handler, bestPatternMatch, pathWithinMapping, uriTemplateVariables);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No handler found...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，关于译注的部分需要说一下；代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; uriTemplateVariables = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">for</span> (String matchingPattern : matchingPatterns) &#123;</span><br><span class="line">    <span class="keyword">if</span> (patternComparator.compare(bestPatternMatch, matchingPattern) == <span class="number">0</span>) &#123;</span><br><span class="line">    Map&lt;String, String&gt; vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, urlPath);</span><br><span class="line">    Map&lt;String, String&gt; decodedVars =</span><br><span class="line">    getUrlPathHelper().decodePathVariables(request, vars);</span><br><span class="line">    uriTemplateVariables.putAll(decodedVars);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前是通过sort方法进行排序的，然后将第一个作为bestPatternMatch，但是如果多个pattern的顺序相同，也就是说sort返回的是0,存在多种最佳匹配，那就需要确保我们有正确的URI模板变量。上面代码就是处理这种情况的。</p><ul><li><p>buildPathExposingHandler</p><p>  这个方法在上面的两段代码中都频繁出现，那么这个方法到底有什么作用呢？代码中我注释的是注册拦截器，那么注册的又是什么拦截器？带着这两个问题，我们来看下代码。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//buildPathExposingHandler为给定的rawHandler构建一个Handler对象，并在执</span></span><br><span class="line"><span class="comment">//行处理程序之前暴露实际的处理程序PATH_WITHIN_HANDLER_MAPPING_ATTRIBUT</span></span><br><span class="line"><span class="comment">//E以及URI_TEMPLATE_VARIABLES_ATTRIBUTE。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认实现用一个特殊的拦截器构建一个HandlerExecutionChain，该拦截器暴露</span></span><br><span class="line"><span class="comment">//path属性和uri模板变量。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">buildPathExposingHandler</span><span class="params">(Object rawHandler, </span></span></span><br><span class="line"><span class="function"><span class="params">    String bestMatchingPattern,</span></span></span><br><span class="line"><span class="function"><span class="params">    String pathWithinMapping, </span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;String, String&gt; uriTemplateVariables)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    HandlerExecutionChain chain = <span class="keyword">new</span> HandlerExecutionChain(rawHandler);</span><br><span class="line">    chain.addInterceptor(<span class="keyword">new</span> PathExposingHandlerInterceptor(bestMatchingPattern, pathWithinMapping));</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(uriTemplateVariables)) &#123;</span><br><span class="line">    chain.addInterceptor(<span class="keyword">new</span> UriTemplateVariablesHandlerInterceptor(uriTemplateVariables));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四个参数：</p><ul><li>rawHandler 原始处理程序</li><li>bestMatchingPattern 最佳匹配模式</li><li>pathWithinMapping 在执行Handler之前公开的路径</li><li>uriTemplateVariables 如果没有找到变量，URI模板变量可以是{null}</li></ul><p>从代码注释翻译及代码内容可以了解到，buildPathExposingHandler的作用就是给已经查找到的handler注册两个拦截器</p><ul><li>ExposingHandlerInterceptor</li><li>UriTemplateVariablesHandlerInterceptor</li></ul><p>这两个类均是<code>AbstractUrlHandlerMapping</code>的内部类，也就是两个内部拦截器。这两个拦截器的主要作用就是将与当前url实际匹配的pattern、匹配条件以及url模板参数等设置到request的属性里面去，这样在后面的处理过程中就可以直接从request属性中获取。看下两个内部类的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PathExposingHandlerInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String bestMatchingPattern;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String pathWithinMapping;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathExposingHandlerInterceptor</span><span class="params">(String bestMatchingPattern, String pathWithinMapping)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bestMatchingPattern = bestMatchingPattern;</span><br><span class="line">    <span class="keyword">this</span>.pathWithinMapping = pathWithinMapping;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> </span>&#123;</span><br><span class="line">    exposePathWithinMapping(<span class="keyword">this</span>.bestMatchingPattern,</span><br><span class="line">    <span class="keyword">this</span>.pathWithinMapping, request);</span><br><span class="line">    <span class="comment">//设置request属性</span></span><br><span class="line">    request.setAttribute(HandlerMapping.INTROSPECT_TYPE_LEVEL_MAPPING, supportsTypeLevelMappings());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">UriTemplateVariablesHandlerInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; uriTemplateVariables;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UriTemplateVariablesHandlerInterceptor</span><span class="params">(Map&lt;String, String&gt; uriTemplateVariables)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.uriTemplateVariables = uriTemplateVariables;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">    HttpServletResponse response, Object handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这exposeUriTemplateVariables种设置request属性</span></span><br><span class="line">    exposeUriTemplateVariables(<span class="keyword">this</span>.uriTemplateVariables, request);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从内部类的代码可以看出，这两个内部类是通过在preHandle方法中调用exposePathWithinMapping和exposeUriTemplateVariables完成属性设置到request中的。</p><p>对于查找handler的关键其实就是维护url和handler的映射关系，也就是handlerMap的构建。在<code>AbstractUrlHandlerMapping</code>中是通过registerHandler这个方法来构建handlerMap的。<code>AbstractUrlHandlerMapping</code>提供了两个registerHandler方法，下面就通过代码来看下具体的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandler</span><span class="params">(String[] urlPaths, String beanName)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    Assert.notNull(urlPaths, <span class="string">"URL path array must not be null"</span>);</span><br><span class="line">    <span class="keyword">for</span> (String urlPath : urlPaths) &#123;</span><br><span class="line">    registerHandler(urlPath, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个registerHandler是将多个url注册到一个处理器。beanName其实就是咱们处理器的名称，可以通过beanName到容器中去找到真正的处理器Bean。具体处理就是通过遍历所有的url，然后再通过调用第二个registerHandler将handler注册到handlerMap中。来看第二个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandler</span><span class="params">(String urlPath, Object handler)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    Assert.notNull(urlPath, <span class="string">"URL path must not be null"</span>);</span><br><span class="line">    Assert.notNull(handler, <span class="string">"Handler object must not be null"</span>);</span><br><span class="line">    Object resolvedHandler = handler;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果的handler是string类型，并且不是lazyInitHandlers，则从SpringMV</span></span><br><span class="line">    <span class="comment">//C容器中获取handler</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.lazyInitHandlers &amp;&amp; handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    String handlerName = (String) handler;</span><br><span class="line">    <span class="keyword">if</span> (getApplicationContext().isSingleton(handlerName)) &#123;</span><br><span class="line">    resolvedHandler = getApplicationContext().getBean(handlerName);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Object mappedHandler = <span class="keyword">this</span>.handlerMap.get(urlPath);</span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != resolvedHandler) &#123;</span><br><span class="line">    <span class="comment">//异常处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//是否是跟路径</span></span><br><span class="line">    <span class="keyword">if</span> (urlPath.equals(<span class="string">"/"</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">    logger.info(<span class="string">"Root mapping to "</span> +</span><br><span class="line">    getHandlerDescription(handler));</span><br><span class="line">    &#125;</span><br><span class="line">    setRootHandler(resolvedHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否是*模式</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (urlPath.equals(<span class="string">"/*"</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">    logger.info(<span class="string">"Default mapping to "</span> +</span><br><span class="line">    getHandlerDescription(handler));</span><br><span class="line">    &#125;</span><br><span class="line">    setDefaultHandler(resolvedHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加入到handlerMap中</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.handlerMap.put(urlPath, resolvedHandler);</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Mapped URL path ["</span> + urlPath + <span class="string">"] onto "</span> +</span><br><span class="line">        getHandlerDescription(handler));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个里面首先是看Map中是否有原来传入的url，如果没有就加入，如果有就看下原来保存的和当前注册的handler是否是同一个，如果不是同一个就抛出异常。（同一个url不可能存在两个不同的handler）。</p><p>在put之前，也做了一些“/”和“/*”的验证处理，如果是这两种路径的话就不保存到handlerMap中了。</p><ul><li>“/”：setRootHandler(resolvedHandler);</li><li>“/*”：setDefaultHandler(resolvedHandler);</li></ul><p>OK，到这<code>AbstractUrlHandlerMapping</code>这个类就分析完了，其实<code>AbstractUrlHandlerMapping</code>做的事情就是定义了一个框子，子类只要完成对Map的初始化就可以了。关于<code>AbstractUrlHandlerMapping</code>的子类后续再谈。</p>]]></content>
      
      
      <categories>
          
          <category> spring mvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> web </tag>
            
            <tag> mvc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring源码系列：注解说明</title>
      <link href="/2018/11/10/springbase13/"/>
      <url>/2018/11/10/springbase13/</url>
      
        <content type="html"><![CDATA[<p>因为要看Spring中注解的具体定义，所以在说之前，先来简单说下JAVA中注解的一些基本知识。</p><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>什么是元注解呢，就是注解的注解。java中提供了以下几种：</p><ul><li>@Target</li></ul><pre><code>注解的作用域描述<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</span><br><span class="line">    <span class="comment">/** 类, 接口 或者枚举 */</span></span><br><span class="line">    TYPE,</span><br><span class="line">    <span class="comment">/** 字段 */</span></span><br><span class="line">    FIELD,</span><br><span class="line">    <span class="comment">/** 方法 */</span></span><br><span class="line">    METHOD,</span><br><span class="line">    <span class="comment">/** 参数 */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line">    <span class="comment">/** 构造方法 */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line">    <span class="comment">/** 局部变量 */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line">    <span class="comment">/** 注解类型 */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line">    <span class="comment">/** 包 */</span></span><br><span class="line">    PACKAGE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>@Retention</p><p>  生命周期描述</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在原文件中有效，被编译器丢弃。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在class文件有效，可能会被虚拟机忽略。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在运行时有效。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Inherited</p><p>  标识性的元注解，它允许子注解继承它。</p></li><li><p>@Documented</p><p>  用于标准生成javadoc时会包含的注解。</p></li></ul><h2 id="JAVA中注解的定义方式"><a href="#JAVA中注解的定义方式" class="headerlink" title="JAVA中注解的定义方式"></a>JAVA中注解的定义方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名 &#123;定义体&#125;</span><br></pre></td></tr></table></figure><hr><p>上面试一些基本概念点，关注注解其他的一些特性和用法就不细说了。直接看Spring中的注解吧。</p><h2 id="1、-Component"><a href="#1、-Component" class="headerlink" title="1、@Component"></a>1、@Component</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Component &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">     * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the suggested component name, if any</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指示注释类是“组件”。 当使用基于注释的配置和类路径扫描时，这些类被认为是自动检测的候选对象。</p><h2 id="2、-Controller"><a href="#2、-Controller" class="headerlink" title="2、@Controller"></a>2、@Controller</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用过Spring mvc的小伙伴对于这个注解肯定不陌生。@Controller表示注释的类是“控制器”（例如Web控制器）。这个注解作为@Component的一个特定方式存在，允许通过类路径扫描来自动检测实现类。通常情况下会结合RequestMapping注解使用。从它的定义层面来看，这个注解只能用于接口或者类上面，不能用于方法或者属性字段上面。</p><h2 id="3、-Service"><a href="#3、-Service" class="headerlink" title="3、@Service"></a>3、@Service</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示注释类是一个“服务”，最初由Domain-Driven Design （Evans，2003）定义为“作为模型中独立的接口提供的操作，没有封装状态”。</p><p>在一般情况下，我们把他用在标准我们的service服务接口的实现类上面，实际上这相当于缩小它们的语义和适当的使用。</p><p>@Service这个注释作为 @Component的一个特例，允许通过类路径扫描来自动检测实现类。</p><h2 id="4、-Repository"><a href="#4、-Repository" class="headerlink" title="4、@Repository"></a>4、@Repository</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Repository &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">     * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the suggested component name, if any</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于标注数据访问组件，即DAO组件</p><h2 id="5、-RequestMapping"><a href="#5、-RequestMapping" class="headerlink" title="5、@RequestMapping"></a>5、@RequestMapping</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Mapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"path"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] path() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    RequestMethod[] method() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    String[] params() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    String[] headers() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    String[] consumes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    String[] produces() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@RequestMapping是一个用来处理地址映射请求的注解，从定义可以看出，可作用于方法或者类上。</p><ul><li>用于类上，大多数是为了进行区分controller</li><li>用于方法上则是对方法进行注解以产生访问的路径。</li></ul><p>它包括了几个属性：</p><ul><li>value 用于设置方法或者类的映射路径，可以直接写路径。我们通常都是直接写，例如：@RequestMapping(“/XXX”);</li><li>method 用于指定请求的方法，可以设置单个或多个，如果请求方法不满足条件则会请求失败。</li><li>params  指定request中必须包含某些参数值是，才让该方法处理。</li><li>name 此映射指定一个名称</li><li>path 仅在Servlet环境中：路径映射URI（例如“/myPath.do”）。也支持Ant风格的路径模式（例如“/myPath/*.do”）。在方法级别，在类型级别表示的主映射内支持相对路径（例如“edit.do”）。 路径映射URI可能包含占位符（例如“/ $ {connect}”）</li><li>consumes 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</li><li>produces 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</li><li>headers 指定request中必须包含某些指定的header值，才能让该方法处理请求。</li></ul><p>其他的几个没怎么用过，确实不了解，有知道的小伙伴，欢迎留言。</p><h2 id="6、-ResponseBody"><a href="#6、-ResponseBody" class="headerlink" title="6、@ResponseBody"></a>6、@ResponseBody</h2><p>@ResponseBody这个我一般是用在做异步请求调用的方法上来使用的。因为在使用@RequestMapping后，返回值通常解析为跳转路径。加上@responsebody后，返回结果直接写入HTTP response body中，不会被解析为跳转路径。</p><p>对于异步请求，我们不希望返回解析视图，二是希望响应的结果是json数据，那么加上@responsebody后，就会直接返回json数据。</p><h2 id="7、-Autowired"><a href="#7、-Autowired" class="headerlink" title="7、@Autowired"></a>7、@Autowired</h2><p>Autowired就是自动装配的意思，其作用是为了消除代码Java代码里面的getter/setter与bean属性中的property。当然，getter看个人需求，如果私有属性需要对外提供的话，就应该保留。</p><p>@Autowired默认按类型匹配的方式，在容器查找匹配的Bean，当有且仅有一个匹配的Bean时，Spring将其注入@Autowired标注的变量中。</p><p>但是当接口存在两个实现类的时候必须使用@Qualifier指定注入哪个实现类，否则可以省略，只写@Autowired。</p><h2 id="8、-Qualifier"><a href="#8、-Qualifier" class="headerlink" title="8、@Qualifier"></a>8、@Qualifier</h2><p>@Qualifier用于指定注入Bean的名称，就是上面说到的，如果容器中有一个以上匹配的Bean，则可以通过@Qualifier注解限定Bean的名称。</p><h2 id="9、-Resource"><a href="#9、-Resource" class="headerlink" title="9、@Resource"></a>9、@Resource</h2><p>这个注解不是Spring的，放在这里是为了和@Autowired做一个区别。<br>@Resource默认按名称装配，当找不到与名称匹配的bean才会按类型装配。</p><h2 id="10、-PathVariable"><a href="#10、-PathVariable" class="headerlink" title="10、@PathVariable"></a>10、@PathVariable</h2><p>当使用@RequestMapping URI template 样式映射时， 即 someUrl/{paramId}, 这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user/&#123;userId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">userCenter</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                            HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                            @PathVariable String userId)</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果方法参数名称和需要绑定的uri template中变量名称不一致，需要在@PathVariable(“name”)指定uri template中的名称。</p><h2 id="11、-RequestParam"><a href="#11、-RequestParam" class="headerlink" title="11、@RequestParam"></a>11、@RequestParam</h2><p>@RequestParam注解有两个属性： value、required；</p><ul><li>value用来指定要传入值的id名称</li><li>required用来指示参数是否必须绑定；</li></ul><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/t_rparam1"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">t_rparam1</span><span class="params">(@RequestParam  Long userId)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//do something   </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/t_rparam2"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">t_rparam2</span><span class="params">(Long userId)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//do something   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>t_rparam1 必须带有参数,也就是说你直接输入localhost:8080/t_rparam1 会报错只能输入localhost:8080/t_rparam1?userId=? 才能执行相应的方法</li><li>t_rparam2  可带参数也可不带参数;也就是说输入localhost:8080/t_rparam2和输入 localhost:8080/t_rparam2?userId=?都可以正常运行</li></ul><p>当然我们也可以设置 @RequestParam 里面的required为false(默认为true 代表必须带参数) 这样t_rparam1就跟t_rparam2是一样的了。</p><h2 id="12、-RequestHeader"><a href="#12、-RequestHeader" class="headerlink" title="12、@RequestHeader"></a>12、@RequestHeader</h2><p>利用@RequestHeader 注解可以把Request请求header部分的值绑定到方法的参数上。</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/9/16179c7273eff4d0?w=636&amp;h=94&amp;f=png&amp;s=46122" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/t_heander"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getRequestHeaderTest</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                            HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                            @RequestHeader(<span class="string">"Accept-Encoding"</span>)</span>String encoding)  </span>&#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//do something </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13、-CookieValue"><a href="#13、-CookieValue" class="headerlink" title="13、@CookieValue"></a>13、@CookieValue</h2><p>@CookieValue就是把Request header中cookie的值绑定到方法的参数上。比如说我们的cookie如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie:JSESSIONID=ka8A5L5t7WTUPXbaLupBieqOdmc0ZpD5MyKvea6oQr7JJSIZzM;userId=001;sysFlag=glmapper</span><br></pre></td></tr></table></figure><p>获取如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/t_cookie"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCookieValueTest</span><span class="params">(@CookieValue(<span class="string">"JSESSIONID"</span>)</span> String cookie)  </span>&#123;  </span><br><span class="line">  <span class="comment">//do something </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="14、-RequestBody"><a href="#14、-RequestBody" class="headerlink" title="14、@RequestBody"></a>14、@RequestBody</h2><p>@RequestBody这个注解常用来处理Content-Type不是application/x-www-form-urlencoded编码的内容，比如说：application/json, application/xml等等；这个和ResonseBody可以反过来理解。</p><h2 id="15、-ModelAttribute"><a href="#15、-ModelAttribute" class="headerlink" title="15、@ModelAttribute"></a>15、@ModelAttribute</h2><ul><li><p>方法上</p><p>  通常用来在处理@RequestMapping之前，为请求绑定需要从后台查询的model；</p></li><li><p>参数上</p><p>  用来通过名称对应，把相应名称的值绑定到注解的参数bean上；</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《Spring技术内幕》</li><li><a href="https://www.cnblogs.com/FrankLei/p/6579843.html" target="_blank" rel="noopener">https://www.cnblogs.com/FrankLei/p/6579843.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JUC·ThreadPoolExecutor 线程池</title>
      <link href="/2018/11/10/java-up-juc2/"/>
      <url>/2018/11/10/java-up-juc2/</url>
      
        <content type="html"><![CDATA[<p>ThreadPoolExecutor算是JUC中最常用的类之一了。ThreadPoolExecutor，顾名思义，thread-pool-executor,硬翻译就是“线程-池-执行者”；java中，通过ThreadPoolExecutor可以很容易的创建一个线程池。但是我们为什么要使用线程池？呢？它能够带来什么样的优势呢？它又是怎么实现的呢？OK，带着这几个问题，我们来学习一下JAVA中的线程池技术。</p><h2 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h2><p>关于这个问题其实有点鸡肋，我觉得再问这个问题之前更应该问为什么要有线程池。那为什么呢?</p><hr><p>this is a 例子：</p><p><code>快递行业最近两年发展的灰常火热，听说工资也非常的高，搞得我一天天的都没有心思去好好写代码了...</code></p><p><code>之前的小快递公司都是没有固定的快递员的，就是说，每次去送一件快递，站点负责人就需要去找一个人来帮忙送，送完之后就没有然后了(当然，钱还是要给的)。</code></p><p><code>但是后来随着货越来越多，找人给钱成本太大，而且农忙时还需要花很长时间去找人，所以就雇用了5个人，签了合同，长期为站点配送。</code></p><p>以前都是随时用随时找，现在不是，现在是成立了一个物流公司，开了一个配送部，配送部门规定正式配送员最多只能有五个人。</p><p><strong>之前配送的缺点是什么：</strong></p><ul><li>每次有货，我都会去临时找一个人，然后签订临时合同，送完之后解除合同。很麻烦。<br>这也是不用线程池的缺点，就是任务来了，我们需要频繁的去创建新的线程，用完之后还需要释放线程资源，对于系统的消耗是很大的。</li><li>因为配送的货车只有那么几个，如果临时签订的人多了，车子不够用，其他人只能等着车子送完之后才能用。</li></ul><p><strong>成立配送部之后解决的问题</strong></p><ul><li>成立配送部之后呢，因为签订的是劳务合同，我们可以重复的让配送员配送不同的货物。达到线程资源的复用。</li><li>因为限定了最多招聘的人数，可以很好的避免招过多无用的人。</li></ul><hr><p>OK，我们以上述例子来对应理解线程池的基本原理</p><p>先来看下，JAVA对ThreadPoolExecutor的类申明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span></span><br></pre></td></tr></table></figure><p>在<a href="https://juejin.im/post/5a7578a05188257a59119951" target="_blank" rel="noopener">【初识】-JUC·Executor框架</a>中给出了Executor的继承体系。ThreadPoolExecutor就是具备线程池功能的集成者。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法一</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">                          </span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">         </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//构造方法二</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         threadFactory, defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造方法三</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造方法四</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，构造方法（一、二、三）都是通过调用（四）来做具体属性初始化的。那么我们直接来看构造方法四；在构造方法四中总共需要7个参数，先来看下每个参数的具体含义：</p><ul><li><p>corePoolSize</p><p>  核心线程数大小。那么什么是核心线程数呢，我们可以类比于上面例子中的配送部中签订劳动合同的人的个数。</p></li><li><p>maximumPoolSize</p><p>  最大线程数。加入说现在是双十一期间，快递异常的多，配送部的5个人完全忙不过来，而且仓库也满了，怎么办呢？这个时候就需要再招聘一些临时配送员，假设maximumPoolSize为10，那么也就是说，临时招聘可以招5个人，配送部签订正式劳动合同的人和签订临时合同的人加一块不能超过配送部规定的最大人数（10人）。所以说，maximumPoolSize就是线程池能够允许的存在的最大线程的数量。</p></li><li><p>keepAliveTime</p><p>  存活时间。为什么要有这个呢？想一下，双十一过去了，货物已经配送的差不多了。临时合同写的是如果临时配送员2天没有配送了，那配送部就有权利终止临时合同，现在已经达到2天这个点了，需要开除这些临时配送专员了。对于线程池来说，keepAliveTime就是用来表示，当除核心线程池之外的线程超过keepAliveTime时间之后，就需要被系统回收了。</p></li><li><p>unit</p><p>  keepAliveTime的时间单位。</p></li><li><p>workQueue</p><p>  工作队列。这个就相当于一个仓库，现在配送部5个人都在配送，但是还不断的有新的快递达到，这个时候就需要一个仓库来存放这些快递。对于线程池来说，当核心线程都有自己的任务处理，并且还有任务进来的时候，就会将任务添加到工作队列中去。</p></li><li><p>threadFactory</p><p>  线程工厂。就是用来创建线程的。可以类比成招聘组，会给每个线程分配名字或者编号这样。</p></li><li><p>handler</p><p>  RejectedExecutionHandler 用来描述拒绝策略的。假设现在我的仓库也满足，并且配送部已经达到10个人了。怎么办呢，那么只能采用一些策略来拒绝任务了。</p><h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="comment">//RUNNING；该状态的线程池接收新任务，并且处理阻塞队列中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//SHUTDOWN；该状态的线程池不接收新任务，但会处理阻塞队列中的任务；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//STOP；不接收新任务，也不处理阻塞队列中的任务，并且会中断正在运行的任务；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//线程池彻底终止，就变成TERMINATED状态。 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><p>下面是在网上发现的一位大牛的图；感觉可以较为直观的描述状态的变更</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/7/161702fd7393291e?w=1033&amp;h=406&amp;f=jpeg&amp;s=82514" alt=""></p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616ff08ec07b0e9?w=543&amp;h=443&amp;f=png&amp;s=136351" alt="线程池执行原理"></p><p>有几个点需要注意。</p><h3 id="1、如何提交一个任务到线程池？"><a href="#1、如何提交一个任务到线程池？" class="headerlink" title="1、如何提交一个任务到线程池？"></a>1、如何提交一个任务到线程池？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//任务为null,直接抛出空指针异常</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//如果线程数大于等于基本线程数，将任务加入队列</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果少于corePoolSize线程正在运行，请尝试使用给定命令启动一个新线程作为其第一个任务。 对addWorker的调用会自动检查runState和workerCount，从而防止错误报警，在不应该的时候通过返回false来添加线程。</li><li>如果一个任务能够成功排队，那么我们仍然需要再次检查是否应该添加一个线程（因为现有的线程自上次检查以来已经死掉）或者自从进入这个方法以来，池关闭了。所以我们重新检查状态，如果当前command已经stop了，那么就退出工作队列，如果没有的话就开始一个新的线程。</li><li>如果队列满了，会想尝试去创建一个新的线程去执行，如果创建不了，那就执行拒绝策略。</li></ul><h3 id="2、如何创建一个线程去处理任务？"><a href="#2、如何创建一个线程去处理任务？" class="headerlink" title="2、如何创建一个线程去处理任务？"></a>2、如何创建一个线程去处理任务？</h3><p>通过实现这个接口去创建一个新的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、如何将任务添加到队列？"><a href="#3、如何将任务添加到队列？" class="headerlink" title="3、如何将任务添加到队列？"></a>3、如何将任务添加到队列？</h3><p>通过addWorker方法来添加，其实在excute中只是作为一个提交任务的入口，实际的处理逻辑都是在addWorker这个方法里来完成的。addWorker有两个参数：</p><ul><li>firstTask 当前任务</li><li>core 用来标注当前需要创建的线程是否是核心线程，如果core为true，则表明创建的是核心线程，也就是说当前还没有达到最大核心线程数。</li></ul><p>先来看下这个方法的前半部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">//自旋方式</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取当前线程池的状态</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//如果状态是STOP，TIDYING,TERMINATED状态的话，则会返回false</span></span><br><span class="line">        <span class="comment">//如果状态是SHUTDOWN，但是firstTask不为空或者workQueue为空的话，那么直接返回false。</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//通过自旋的方式，判断要添加的worker是否为corePool范畴之内的</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>//如果超过CAPACITY限制了则直接返回false<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc &gt;= CAPACITY</span><br></pre></td></tr></table></figure></p><p>//判断当前的workerCount是否大于corePoolsize，否则则判断是否大于maximumPoolSize<br>//具体的比较取决于入参core是true还是false。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc &gt;= (core ? corePoolSize : maximumPoolSize)</span><br></pre></td></tr></table></figure></p><p>如果上面两个有一个满足了，则直接返回false。</p><p>下面是判断WorkerCount通过CAS操作增加1是否成功，成功的话就到此结束<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">    <span class="keyword">break</span> retry;</span><br></pre></td></tr></table></figure></p><p>如果不成功，则再次判断当前线程池的状态，如果现在获取到的状态与进入自旋的状态不一致的话，那么则通过continue retry重新进行状态的判断。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line"><span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">    <span class="keyword">continue</span> retry;</span><br></pre></td></tr></table></figure></p><p><br><br>再来看下这个方法的后面半个部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">Worker w = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    <span class="comment">//创建一个新的Worker对象</span></span><br><span class="line">    w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">    <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在锁定的情况下重新检查。</span></span><br><span class="line">            <span class="comment">// 在一下情况退出：ThreadFactory 创建失败或者在获取锁之前shut down了</span></span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">           <span class="comment">//状态校验</span></span><br><span class="line">            <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.isAlive()) <span class="comment">// 预先检查t是可以启动的</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                <span class="comment">//添加至workers中</span></span><br><span class="line">                workers.add(w);</span><br><span class="line">                <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                <span class="comment">//如果超过了历史最大线程数，则将当前池数量设置为历史最大线程记录数</span></span><br><span class="line">                <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                    largestPoolSize = s;</span><br><span class="line">                <span class="comment">//标识添加工作线程成功</span></span><br><span class="line">                workerAdded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果添加成功则启动当前工作线程</span></span><br><span class="line">        <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">            <span class="comment">//并将当前线程状态设置为已启动</span></span><br><span class="line">            workerStarted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//添加失败</span></span><br><span class="line">    <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">        addWorkerFailed(w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拒绝策略有哪些？"><a href="#拒绝策略有哪些？" class="headerlink" title="拒绝策略有哪些？"></a>拒绝策略有哪些？</h3><p><img src="https://user-gold-cdn.xitu.io/2018/2/7/16170281c265a605?w=591&amp;h=155&amp;f=png&amp;s=75622" alt=""></p><ul><li>1、AbortPolicy：直接抛出异常，默认策略；</li><li>2、CallerRunsPolicy：使用调用者自己的当前线程来执行任务；</li><li>3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li><li>4、DiscardPolicy：直接丢弃任务；</li></ul><p>当然我们也可以自定义拒绝策略。</p><h3 id="常用工作队列类型"><a href="#常用工作队列类型" class="headerlink" title="常用工作队列类型"></a>常用工作队列类型</h3><p><strong>1、ArrayBlockingQueue</strong></p><p>基于数组的阻塞队列，长度有限</p><p><strong>2、LinkedBlockingQuene</strong></p><p>基于链表的阻塞队列，长度无限，使用这个可能会导致我们的拒绝策略失效。因为可以无限的创建新的工作线程。</p><p><strong>3、PriorityBlockingQueue</strong></p><p>具有优先级的无界阻塞队列；</p><p><strong>3、SynchronousQuene</strong></p><p>SynchronousQuene是一个是一个不存储元素的BlockingQueue；每一个put操作必须要等待一个take操作，否则不能继续添加元素。所以这个比较特殊，它不存我们的任务，也就说说它的每个put操作必须等到另一个线程调用take操作，否则put操作一直处于阻塞状态。</p><h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><p>这个是ThreadPoolExecutor的一个内部类，表示一个工作线程。重要的是这个内部类实现了AbstractQueuedSynchronizer（AQS:抽象队列同步器）抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当前work持有的线程 */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** 运行的初始任务。 可能为空。*/</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** 每个线程完成任务的计数器 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">    <span class="comment">// 禁止中断，直到runWorker</span></span><br><span class="line">        setState(-<span class="number">1</span>); </span><br><span class="line">        <span class="comment">//想提交的任务交给当前工作线程</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">//通过线程工厂创建一个新的线程</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将run方法的执行委托给外部runWorker */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否锁定</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 0代表解锁状态。</span></span><br><span class="line">    <span class="comment">// 1代表锁定状态。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试获取锁（重写AQS的方法）</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试释放锁（重写AQS的方法）</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">//尝试加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">//是否锁定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line">    <span class="comment">//如果启动则中断</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h2><p>最后来看下runWorker这个方法（ThreadPoolExecutor中的方法）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = null;</span><br><span class="line">    w.unlock(); // allow interrupts</span><br><span class="line">    boolean completedAbruptly = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            // If pool is stopping, ensure thread is interrupted;</span><br><span class="line">            // if not, ensure thread is not interrupted.  This</span><br><span class="line">            // requires a recheck in second case to deal with</span><br><span class="line">            // shutdownNow race while clearing interrupt</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    thrown = x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                task = null;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>下面是对注释的蹩脚翻译，欢迎吐槽，但注意尺度，O(∩_∩)O哈哈~</code></p><p>主要工作循环运行。重复地从队列中获取任务并执行它们，同时处理一些问题: </p><ul><li>我们可能会从最初的任务开始，在这种情况下，我们不需要得到第一个任务。否则，只要池正在运行，我们就从getTask获得任务。 如果它返回null，则由于更改池状态或配置参数而导致worker退出。其他退出的结果是在外部代码中抛出的异常，在这种情况下completeAbruptly成立，这通常会导致processWorkerExit来取代这个线程。</li><li>在运行任何任务之前，获取锁以防止任务正在执行时发生其他池中断，调用clearInterruptsForTaskRun确保除非池正在停止，则此线程没有设置其中断。</li><li>每个任务运行之前都会调用beforeExecute，这可能会引发一个异常，在这种情况下，我们会导致线程死亡（断开循环completeAbruptly为true），而不处理任务。</li><li>假设beforeExecute正常完成，我们运行任务，收集任何抛出的异常发送到afterExecute。 我们分别处理RuntimeException，Error（这两个规范保证我们陷阱）和任意的Throwables。 因为我们不能在Runnable.run中重新抛出Throwable，所以我们把它们封装在Errors中（到线程的UncaughtExceptionHandler）。 任何抛出的异常也保守地导致线程死亡。</li><li>task.run完成后，我们调用afterExecute，这也可能会抛出一个异常，这也会导致线程死亡。 根据JLS Sec 14.20，即使task.run抛出，这个异常也是有效的。</li></ul><p>异常机制的最终效果是afterExecute和线程的UncaughtExceptionHandler拥有关于用户代码遇到的任何问题的准确信息。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文是JUC的第二篇，意在通过查看源码来了解线程池的具体工作原理。文中如果存在不当的描述，希望小伙伴们能够及时提出。灰常感谢！</p><p><code>欢迎关注微信公众号，干货满满哦~</code><br><img src="https://user-gold-cdn.xitu.io/2018/2/7/161704e6a5057ad6?w=258&amp;h=258&amp;f=jpeg&amp;s=15516" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 线程 </tag>
            
            <tag> thread </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JUC·Executor 框架</title>
      <link href="/2018/11/10/java-up-juc1/"/>
      <url>/2018/11/10/java-up-juc1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>多线程和并发这两个东西真的是向往已久，总是有一种神秘的感觉，想去探索一波，又担心水平不够无法驾驭。想以读书笔记的方式来写，但是又觉得缺少自己的一些思考；但是在没有足够并发编程经验的情况下又没法去写出很深刻的东西，毕竟没有踩过坑。所以在阅读spring源码的同时，也想抽点时间来看一看JUC的东西，关于这块只能说是记录自己学习JUC的一个过程，尝试用一些具体的代码demo来加深理解。所以就把本系列写成《【 初识】-JUC·XXXX》，用来让自己打开并发编程的大门。</p><h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><p>JUC即java.util.concurrent；也就是java提供的并发包。JUC中从包结构上来看主要是：</p><ul><li><p>java.util.concurrent</p><p>  在这个包下面主要是线程池、并发集合以及一些并发工具类。线程池相关是围绕Excetor框架来构建；这也是本文下面部分的重点。</p></li><li><p>java.util.concurrent.atomic</p><p>  这个包下面是一些原子操作类，算是并发辅助工具类，基本实现依赖于CAS；</p></li><li><p>java.util.concurrent.locks</p><p>  这个从名字就可以知道它的作用，就是提供锁。</p></li></ul><h2 id="JUC各个模块的类"><a href="#JUC各个模块的类" class="headerlink" title="JUC各个模块的类"></a>JUC各个模块的类</h2><ul><li>整体框架</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/2/6/16169e20a66c9495?w=533&amp;h=297&amp;f=png&amp;s=78638" alt=""></p><ul><li>atomic</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/2/6/16169e2d7ef5a81d?w=411&amp;h=384&amp;f=png&amp;s=87131" alt=""></p><ul><li>locks</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/2/6/16169e3528be1404?w=411&amp;h=297&amp;f=png&amp;s=65720" alt=""></p><ul><li>并发集合</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/2/6/16169e3a4b53404b?w=440&amp;h=563&amp;f=png&amp;s=138892" alt=""></p><ul><li>并发工具</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/2/6/16169e3eca541b38?w=406&amp;h=260&amp;f=png&amp;s=52976" alt=""></p><ul><li><p>forkJoin</p><p>  fork-join在JUC中有下面三个类：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span></span><br></pre></td></tr></table></figure></li></ul><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt;, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinWorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br></pre></td></tr></table></figure></code></pre><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>Future提供了可以获取异步执行结果的方法，区别于Runnable的run方法，run是不提供返回结果的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//取消</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="comment">//如果任务完成前被取消，则返回true。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//如果任务执行结束，无论是正常结束或是中途取消还是发生异常，都返回true。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取异步执行的结果，如果没有结果可用，此方法会阻塞直到异步计算完成。</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="comment">//获取异步执行结果，如果没有结果可用，此方法会阻塞，但是会有时间限制，</span></span><br><span class="line">    <span class="comment">//如果阻塞时间超过设定的timeout时间，该方法将抛出异常。</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, </span></span><br><span class="line"><span class="function">    ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>声明了一个名称为call()的方法，同时这个方法可以有返回值V，也可以抛出异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123; </span><br><span class="line">  <span class="function">V   <span class="title">call</span><span class="params">()</span>   <span class="keyword">throws</span> Exception</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于Callable和Future的使用一般情况下都是结合我们的线程池来使用的。</p><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>Executor接口是线程池实现的顶级接口，其和spring中的BeanFactory所承担的角色差不多，就是提供顶级的功能约束，具体实现交于不同子类来完成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given command at some time in the future.  The command</span></span><br><span class="line"><span class="comment">     * may execute in a new thread, in a pooled thread, or in the calling</span></span><br><span class="line"><span class="comment">     * thread, at the discretion of the &lt;tt&gt;Executor&lt;/tt&gt; implementation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command the runnable task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if this task cannot be</span></span><br><span class="line"><span class="comment">     * accepted for execution.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if command is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是JUC中Executor框架的整体结构：</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/6/16169fcf02873970?w=544&amp;h=381&amp;f=png&amp;s=111229" alt=""></p><h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//关闭线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//是否为Shutdown状态</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//是否为Terminated状态</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//超过超时时间时，会监测ExecutorService是否已经关闭</span></span><br><span class="line">    <span class="comment">//若关闭则返回true，否则返回false。</span></span><br><span class="line">    <span class="comment">//一般情况下会和shutdown方法组合使用。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回一个Future对象，参数接收的是一个Callable的实现</span></span><br><span class="line">    <span class="comment">//Callable接口中的call()方法有一个返回值，可以返回任务的执行结果</span></span><br><span class="line">    <span class="comment">//区别于Runnable接口中的run()方法（void修饰，没有返回值）。</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">    </span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    <span class="comment">//返回一个Future对象，通过返回的Future对象，我们可以检查提交的任务是否执行完成了。 </span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回一个Future的List，其中对应着每个Callable任务执行后的Future对象。</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="comment">//增加了超时控制    </span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="comment">//接收参数是一个Callable的集合，</span></span><br><span class="line">    <span class="comment">//返回的是所有Callable集合任务中某一个任务的执行结果</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="comment">//增加了超时控制</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExecutorService 再Executor接口的基础上扩展了对线程池状态的控制以及提交任务执行的超时控制。线程池的基本功能还不够完善，不能真正的具备处理具体业务的能力（毕竟是个接口，O(∩_∩)O哈哈~）。</p><p>开个篇，慢慢学~</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 线程 </tag>
            
            <tag> thread </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring源码系列：BeanWrapper</title>
      <link href="/2018/11/10/springbase12/"/>
      <url>/2018/11/10/springbase12/</url>
      
        <content type="html"><![CDATA[<p>BeanWrapper 是Spring提供的一个用来操作javaBean属性的工具，使用它可以直接修改一个对象的属性。</p><p>对于bean属性的操作，大家熟知的主要有下面这些工具类：</p><ul><li>1.Apache的BeanUtils和PropertyUtils</li><li>2.cglib的BeanMap和BeanCopier</li><li>3.spring的BeanUtils</li></ul><p>Spring中BeanWrapper 的主要功能在于：</p><ul><li>1.支持设置嵌套属性</li><li>2.支持属性值的类型转换（设置ConversionService）</li><li>3.提供分析和操作标准JavaBean的操作：获取和设置属性值（单独或批量），获取属性描述符以及查询属性的可读性/可写性的能力。</li></ul><p>BeanWrapper本身是一个接口，它提供了一整套处理Bean的方法。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanWrapper</span> <span class="keyword">extends</span> <span class="title">ConfigurablePropertyAccessor</span> </span>&#123;</span><br><span class="line"> <span class="comment">//为数组和集合自动增长指定一个限制。在普通的BeanWrapper上默认是无限的。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAutoGrowCollectionLimit</span><span class="params">(<span class="keyword">int</span> autoGrowCollectionLimit)</span></span>;</span><br><span class="line"><span class="comment">//返回数组和集合自动增长的限制。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAutoGrowCollectionLimit</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//如果有的话,返回由此对象包装的bean实例</span></span><br><span class="line"><span class="function">Object <span class="title">getWrappedInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回被包装的JavaBean对象的类型。</span></span><br><span class="line">Class&lt;?&gt; getWrappedClass();</span><br><span class="line"><span class="comment">//获取包装对象的PropertyDescriptors（由标准JavaBeans自省确定）。</span></span><br><span class="line">PropertyDescriptor[] getPropertyDescriptors();</span><br><span class="line"><span class="comment">//获取包装对象的特定属性的属性描述符。</span></span><br><span class="line"><span class="function">PropertyDescriptor <span class="title">getPropertyDescriptor</span><span class="params">(String propertyName)</span> <span class="keyword">throws</span> InvalidPropertyException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的BeanWrapper是基于4.3.6版本的，这个接口在4.1版本之后略有改动。BeanWrapperImpl是BeanWrapper的实现类，BeanWrapperImpl的父类是AbstractNestablePropertyAccessor，通过这个使得BeanWrapper具有处理属性的能力。</p><p>下面是一个使用BeanWrapper 包装对象的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.spring.test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeanWrapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.PropertyAccessorFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.PropertyValue;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BeanWrapper 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanWrapperTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user=<span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">//通过PropertyAccessorFactory将user对象封装成BeanWrapper</span></span><br><span class="line">        BeanWrapper bw=PropertyAccessorFactory.forBeanPropertyAccess(user);</span><br><span class="line">        <span class="comment">//方式一：直接对属性值进行设置</span></span><br><span class="line">        bw.setPropertyValue(<span class="string">"userName"</span>, <span class="string">"张三"</span>);</span><br><span class="line">        <span class="comment">//方式二：通过PropertyValue进行设置</span></span><br><span class="line">        PropertyValue pv=<span class="keyword">new</span> PropertyValue(<span class="string">"userName"</span>,<span class="string">"李四"</span>);</span><br><span class="line">        bw.setPropertyValue(pv);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        System.out.println(user.getUserName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个User类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Spring中，有很多Bean属性的操作都是通过BeanWrapper来完成的，比如常见的HttpServletBean的属性设置就是。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring源码系列：依赖注入（四）-总结</title>
      <link href="/2018/11/10/springbase11/"/>
      <url>/2018/11/10/springbase11/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://juejin.im/post/5a7532746fb9a0633a70d57f" target="_blank" rel="noopener">Spring源码系列：依赖注入（一）getBean</a></li><li><a href="https://juejin.im/post/5a77d6256fb9a063606eb538" target="_blank" rel="noopener">Spring源码系列：依赖注入（二）createBean</a></li><li><a href="https://juejin.im/post/5a7a655d5188257a5d2b1a35" target="_blank" rel="noopener">Spring源码系列：依赖注入（三）-属性注入</a></li></ul><p>在上面三篇文章中对依赖注入做了一个大致的梳理；里面都是大量代码的分析，本文在此基础上进行一个总结归纳。</p><h2 id="依赖注入调用过程"><a href="#依赖注入调用过程" class="headerlink" title="依赖注入调用过程"></a>依赖注入调用过程</h2><p><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616f3c6ef426da7?w=771&amp;h=470&amp;f=png&amp;s=181652" alt=""></p><p>如前几篇文章所述，依赖注入是由getBean来触发的；然后涉及到bean实例的创建、依赖关系的建立、属性注入等子过程。</p><ul><li>getBean 方法触发依赖注入</li><li>doGetBean 从容器中查找Bean（BeanFactory链，当前容器-&gt;双亲容器-双亲容器…）</li></ul><p>当然，在获取到某个Bean的时候也会通过递归的方式来依赖注入依赖的bean</p><ul><li><p>createBeanInstance 生成了Bean所包含的Java对象，Spring中用SimpleInstantiationStrategy类来生成Bean对象的实例，实例化Java对象的方法有两种（CGlib是默认方式）：</p><ul><li>通过BeanUtils，它使用了JVM的反射功能来生成Java对象实例</li><li>用CGLIB来生成，CGLIB是一种常用的字节码生成器的类库</li></ul></li><li><p>populateBean 设置Bean对象的依赖关系</p></li><li>resolveValueIfNecessary 注入类型的处理；解析不同类型的属性</li><li>setPropertyValues 属性注入</li></ul><h2 id="关于lazy-init"><a href="#关于lazy-init" class="headerlink" title="关于lazy-init"></a>关于lazy-init</h2><p>Ioc容器的初始化过程中，主要的工作就是对BeanDefinition的定位、载入、解析和注册；但是就像之前说过的，此时依赖注入还没有发生。在<a href="https://juejin.im/post/5a7532746fb9a0633a70d57f" target="_blank" rel="noopener">Spring源码系列：依赖注入（一）getBean</a>文中提到，依赖注入发生在应用第一次向容器获取Bean的时候；也就是上面说到的通过getBean来触发。</p><p>当然，依赖注入也可以在容器初始化的过程中就完成。这个就是lazy-init属性的存在意义了。就是说我们可以通过设置Bean的lazy-init属性来控制预实例化的过程。</p><p><code>预实例化：在初始化容器时完成Bean的依赖注入</code></p><p>这种做法的好处在于提高了我们第一次获取Bean的的效率，但是它也降低了容器初始化的速度。（这个其实很好理解的，因为第一次获取Bean的时候，依赖注入已经完成了，直接拿过来用就行）</p><p>关于lazy-init属性的处理也是在wac.refresh这个方法中完成的，具体是在finishBeanFactoryInitialization方法中。如果继续追溯的话，最终是交给DefaultListableBeanFactory容器中的preInstantiateSingletons方法中完成。</p><p>lazy-init这种实例化方式就是通过将依赖注入委托给容器来处理，而不是在用户第一向容器申请的Bean的时候完成依赖注入，不同的阶段，也有不同的优劣。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring源码系列：依赖注入（三）-属性注入</title>
      <link href="/2018/11/10/springbase10/"/>
      <url>/2018/11/10/springbase10/</url>
      
        <content type="html"><![CDATA[<p>前面文章中对依赖注入的触发和bean的创建做了学习记录，本文将来记录一下bean的属性注入过程。Bean的属性注入发生在<code>BeanDefinitionValueResolver</code>这个类中，<code>BeanDefinitionValueResolver</code>这类是用于bean工厂实现的Helper类，职责就是将bean定义对象中包含的值解析为应用于目标bean实例的实际值。</p><p><code>BeanDefinitionValueResolver</code>类中的<code>resolveValueIfNecessary()</code>方法包含了对所有注入类型的处理。所以本文主要围绕这个方法展开来说。</p><h2 id="resolveValueIfNecessary方法"><a href="#resolveValueIfNecessary方法" class="headerlink" title="resolveValueIfNecessary方法"></a>resolveValueIfNecessary方法</h2><p><code>resolveValueIfNecessary()</code>:给定一个PropertyValue，返回一个value，解析对工厂中其他bean的引用。 value可能是：</p><ul><li>RuntimeBeanReference : 在解析到依赖的Bean的时侯，解析器会依据依赖bean的name创建一个RuntimeBeanReference对像，将这个对像放入BeanDefinition的MutablePropertyValues中。</li><li>ManagedList：用来保存它所管理的List元素，它可以包含运行时期的bean引用(将被解析为bean对象). </li><li>ManagedSet ：用来保存它所管理的set值，它可以包含运行时期的bean引用(将被解析为bean对象) </li><li>ManagedMap ：用来保存它所管理的map值，它可以包含运行时期的bean引用(将被解析为bean对象) </li></ul><p><strong>1、方法申明</strong></p><p>argName ：为其定义的参数的名称</p><p>value   ：要解析的值对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveValueIfNecessary</span><span class="params">(Object argName, Object value)</span></span></span><br></pre></td></tr></table></figure></p><p><strong>2、RuntimeBeanReference</strong></p><p>当在beanfactory中作为另外一个<strong>bean的引用时</strong>，作为属性值对象，将在运行时进行解析。 RuntimeBeanReference是在对BeanDefinition进行解析时生成的数据对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> RuntimeBeanReference) &#123;</span><br><span class="line">    RuntimeBeanReference ref = (RuntimeBeanReference) value;</span><br><span class="line">    <span class="keyword">return</span> resolveReference(argName, ref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>3、RuntimeBeanNameReference</strong></p><p>当在beanfactory中作为另外一个<strong>bean名称的引用时</strong>，作为属性值对象，将在运行时进行解析。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> RuntimeBeanNameReference) &#123;</span><br><span class="line">    String refName = ((RuntimeBeanNameReference) value).getBeanName();</span><br><span class="line">    refName = String.valueOf(doEvaluate(refName));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.beanFactory.containsBean(refName)) &#123;</span><br><span class="line">        <span class="comment">//异常：Invalid bean name '" + refName + "' in bean reference for " + argName</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> refName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>4、BeanDefinitionHolder</strong></p><p>解析BeanDefinitionHolder：包含具有名称和别名的BeanDefinition。BeanDefinitionHolder就是使用名称或者别名来保存BeanDefinition的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> BeanDefinitionHolder) &#123;</span><br><span class="line">    BeanDefinitionHolder bdHolder = (BeanDefinitionHolder) value;</span><br><span class="line">    <span class="keyword">return</span> resolveInnerBean(argName, bdHolder.getBeanName(), bdHolder.getBeanDefinition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>5、BeanDefinition</strong></p><p>解析纯粹的BeanDefinition<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> BeanDefinition) &#123;</span><br><span class="line">    <span class="comment">// Resolve plain BeanDefinition, without contained name: use dummy name.</span></span><br><span class="line">    BeanDefinition bd = (BeanDefinition) value;</span><br><span class="line">    String innerBeanName = <span class="string">"(inner bean)"</span> + BeanFactoryUtils.GENERATED_BEAN_NAME_SEPARATOR +</span><br><span class="line">    ObjectUtils.getIdentityHexString(bd);</span><br><span class="line">    <span class="keyword">return</span> resolveInnerBean(argName, innerBeanName, bd);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>6、ManagedArray</strong></p><p>包含运行时期的bean引用(将被解析为bean对象)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedArray) &#123;</span><br><span class="line">    <span class="comment">// May need to resolve contained runtime references.</span></span><br><span class="line">    ManagedArray array = (ManagedArray) value;</span><br><span class="line">    Class&lt;?&gt; elementType = array.resolvedElementType;</span><br><span class="line">    <span class="keyword">if</span> (elementType == <span class="keyword">null</span>) &#123;</span><br><span class="line">    String elementTypeName = array.getElementTypeName();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(elementTypeName)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        elementType = ClassUtils.forName(elementTypeName,</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.getBeanClassLoader());</span><br><span class="line">        array.resolvedElementType = elementType;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// Improve the message by showing the context.</span></span><br><span class="line">        <span class="comment">//异常：Error resolving array type for " + argName</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    elementType = Object.class;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resolveManagedArray(argName, (List&lt;?&gt;) value, elementType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>7、ManagedList，ManagedSet，ManagedMap</strong></p><p>包含运行时期的bean引用(将被解析为bean对象)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对ManagedList进行解析</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedList) &#123;</span><br><span class="line">    <span class="keyword">return</span> resolveManagedList(argName, (List&lt;?&gt;) value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对ManagedSet进行解析</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedSet) &#123;</span><br><span class="line">    <span class="keyword">return</span> resolveManagedSet(argName, (Set&lt;?&gt;) value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对ManagedMap进行解析</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedMap) &#123;</span><br><span class="line">    <span class="keyword">return</span> resolveManagedMap(argName, (Map&lt;?, ?&gt;) value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>8、ManagedProperties</strong></p><p>ManagedProperties表示的是一个spring管理的属性实例，它支持父/子 definition的合并。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对ManagedProperties进行解析</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedProperties) &#123;</span><br><span class="line">    Properties original = (Properties) value;</span><br><span class="line">    Properties copy = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; propEntry : original.entrySet()) &#123;</span><br><span class="line">    Object propKey = propEntry.getKey();</span><br><span class="line">    Object propValue = propEntry.getValue();</span><br><span class="line">    <span class="keyword">if</span> (propKey <span class="keyword">instanceof</span> TypedStringValue) &#123;</span><br><span class="line">    propKey = evaluate((TypedStringValue) propKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (propValue <span class="keyword">instanceof</span> TypedStringValue) &#123;</span><br><span class="line">    propValue = evaluate((TypedStringValue) propValue);</span><br><span class="line">    &#125;</span><br><span class="line">    copy.put(propKey, propValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>9、TypedStringValue</strong></p><p>TypedStringValue保存的是一个类型的属性值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对TypedStringValue进行解析</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> TypedStringValue) &#123;</span><br><span class="line">    <span class="comment">// Convert value to target type here.</span></span><br><span class="line">    TypedStringValue typedStringValue = (TypedStringValue) value;</span><br><span class="line">    Object valueObject = evaluate(typedStringValue);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; resolvedTargetType = resolveTargetType(typedStringValue);</span><br><span class="line">    <span class="keyword">if</span> (resolvedTargetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.typeConverter.convertIfNecessary(valueObject, resolvedTargetType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> valueObject;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">// Improve the message by showing the context.</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">    <span class="comment">//异常：Error converting typed String value for " + argName</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>10、作为表达式进行评估</strong></p><p>将给定的值作为表达式进行评估。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">    return evaluate(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在完成上述解析之后，已经为我们的依赖注入做好了准备。这是真正把Bean对象设置到它所依赖的另一个Bean的属性中去的地方，可以看到，处理的属性也是各式各样的。具体属性的注入是在之前提到的BeanWrapper接口的实现类BeanWrapperImpl的setPropertyValue方法来完成。</p><h2 id="setPropertyValue方法"><a href="#setPropertyValue方法" class="headerlink" title="setPropertyValue方法"></a>setPropertyValue方法</h2><h3 id="a、方法声明"><a href="#a、方法声明" class="headerlink" title="a、方法声明"></a>a、方法声明</h3><p>这个方法是私有的，是BeanWrapperImpl实际处理的方法，其对外也提供了setPropertyValue的其它重载方法来提供服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setPropertyValue</span><span class="params">(PropertyTokenHolder tokens, PropertyValue pv)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException</span></span><br></pre></td></tr></table></figure><h3 id="b、PropertyTokenHolder是BeanWrapperImpl的内部类"><a href="#b、PropertyTokenHolder是BeanWrapperImpl的内部类" class="headerlink" title="b、PropertyTokenHolder是BeanWrapperImpl的内部类"></a>b、PropertyTokenHolder是BeanWrapperImpl的内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static class PropertyTokenHolder &#123;</span><br><span class="line">    public String canonicalName;</span><br><span class="line">    public String actualName;</span><br><span class="line">    public String[] keys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在setPropertyValue方法中会根据tokens变量是否为null,有两个不同的分支。其中当tokens为null时，则会对属性名进行递归调用分析处理，返回分析处理后的BeanWrapImpl对象nestedBw。如果nestedBw==this,则会设置pv的resolvedTokens属性值，最后将调用nestedBw对象的设置属性值方法设置属性。来具体看看：</p><p><hr></p><h3 id="c、其中当tokens为null时，即对集合类的域进行注入"><a href="#c、其中当tokens为null时，即对集合类的域进行注入" class="headerlink" title="c、其中当tokens为null时，即对集合类的域进行注入"></a>c、其中当tokens为null时，即对集合类的域进行注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置tokens的索引和keys</span></span><br><span class="line">PropertyTokenHolder getterTokens = <span class="keyword">new</span> PropertyTokenHolder();</span><br><span class="line">getterTokens.canonicalName = tokens.canonicalName;</span><br><span class="line">getterTokens.actualName = tokens.actualName;</span><br><span class="line">getterTokens.keys = <span class="keyword">new</span> String[tokens.keys.length - <span class="number">1</span>];</span><br><span class="line">System.arraycopy(tokens.keys, <span class="number">0</span>, getterTokens.keys, <span class="number">0</span>, tokens.keys.length - <span class="number">1</span>);</span><br><span class="line">Object propValue;</span><br><span class="line"><span class="comment">//getPropertyValue用来获取Bean中对对象注入的引用；</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">propValue = getPropertyValue(getterTokens);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NotReadablePropertyException ex) &#123;</span><br><span class="line"><span class="comment">//异常：Cannot access indexed value in property referenced </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1、propValue为null</strong></p><p>propValue为null<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (propValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 空值映射的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.autoGrowNestedPaths) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> cleanup, this is pretty hacky</span></span><br><span class="line">    <span class="keyword">int</span> lastKeyIndex = tokens.canonicalName.lastIndexOf(<span class="string">'['</span>);</span><br><span class="line">    getterTokens.canonicalName = tokens.canonicalName.substring(<span class="number">0</span>, lastKeyIndex);</span><br><span class="line">    propValue = setDefaultValue(getterTokens);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//异常：Cannot access indexed value in property referenced " +</span></span><br><span class="line"><span class="string">"in indexed property path '"</span> + propertyName + <span class="string">"': returned null"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2、对array进行注入</strong></p><p>对array进行注入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (propValue.getClass().isArray()) &#123;</span><br><span class="line">    PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);</span><br><span class="line">    Class requiredType = propValue.getClass().getComponentType();</span><br><span class="line">    <span class="keyword">int</span> arrayIndex = Integer.parseInt(key);</span><br><span class="line">    Object oldValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isExtractOldValueForEditor() &amp;&amp; arrayIndex &lt; Array.getLength(propValue)) &#123;</span><br><span class="line">    oldValue = Array.get(propValue, arrayIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),</span><br><span class="line">    requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));</span><br><span class="line">    Array.set(propValue, arrayIndex, convertedValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">    <span class="comment">//异常：Invalid array index in property path '" + propertyName</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2、对list进行注入</strong></p><p>对list进行注入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (propValue <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">    PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);</span><br><span class="line">    Class requiredType = GenericCollectionTypeResolver.getCollectionReturnType(</span><br><span class="line">    pd.getReadMethod(), tokens.keys.length);</span><br><span class="line">    List list = (List) propValue;</span><br><span class="line">    <span class="keyword">int</span> index = Integer.parseInt(key);</span><br><span class="line">    Object oldValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isExtractOldValueForEditor() &amp;&amp; index &lt; list.size()) &#123;</span><br><span class="line">    oldValue = list.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">    Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),</span><br><span class="line">    requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));</span><br><span class="line">    <span class="keyword">int</span> size = list.size();</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size &amp;&amp; index &lt; <span class="keyword">this</span>.autoGrowCollectionLimit) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &lt; index; i++) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    list.add(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NullPointerException ex) &#123;</span><br><span class="line">        <span class="comment">//异常：InvalidPropertyException</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(convertedValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    list.set(index, convertedValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">    <span class="comment">//异常：Invalid list index in property path '" + propertyName + "'"</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2、对map进行注入</strong></p><p>对map进行注入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (propValue <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">    PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);</span><br><span class="line">    Class mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(</span><br><span class="line">    pd.getReadMethod(), tokens.keys.length);</span><br><span class="line">    Class mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(</span><br><span class="line">    pd.getReadMethod(), tokens.keys.length);</span><br><span class="line">    Map map = (Map) propValue;</span><br><span class="line">    <span class="comment">//重要提示：不要在这里传递完整的属性名称</span></span><br><span class="line">    TypeDescriptor typeDescriptor = (mapKeyType != <span class="keyword">null</span> ?</span><br><span class="line">    TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));</span><br><span class="line">    Object convertedMapKey = convertIfNecessary(<span class="keyword">null</span>, <span class="keyword">null</span>, key, mapKeyType, typeDescriptor);</span><br><span class="line">    Object oldValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isExtractOldValueForEditor()) &#123;</span><br><span class="line">    oldValue = map.get(convertedMapKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在这里传递完整的属性名称和旧值，因为希望对map值有完整的转换能力。</span></span><br><span class="line">    Object convertedMapValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),</span><br><span class="line">    mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));</span><br><span class="line">    map.put(convertedMapKey, convertedMapValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="其中当tokens不为null时，即对非集合类的域进行注入"><a href="#其中当tokens不为null时，即对非集合类的域进行注入" class="headerlink" title="其中当tokens不为null时，即对非集合类的域进行注入"></a>其中当tokens不为null时，即对非集合类的域进行注入</h3><p>这里是核心的地方，取得注入属性的set方法，通过反射机制，把对象注入进去。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Method writeMethod = (pd <span class="keyword">instanceof</span> GenericTypeAwarePropertyDescriptor ?</span><br><span class="line">    ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :</span><br><span class="line">    pd.getWriteMethod());</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的几篇分析我们大概的熟悉了Bean创建和对象依赖注入的一个过程，在这个过程中，spring需要根据Beandefinition中的信息来递归完成依赖注入。并且这些递归的入口都是getBean这个方法。</p><p>一个递归是在上下文体系中查找需要的Bean和创建Bean的递归调用；</p><p>另一个递归是在依赖注入时通过递归调用容器的getBean方法，得到当前Bean的依赖Bean，同时也触发对依赖Bean的创建和注入。</p><p>在对Bean的属性进行依赖注入时解析的过程也是一个递归的过程。这样就可以根据依赖关系，一层一层的完成Bean的创建和注入，直到最后完成当前Bean的创建。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p>《Spring技术内幕》</p></li><li><p><a href="https://www.cnblogs.com/davidwang456/p/4213652.html" target="_blank" rel="noopener">https://www.cnblogs.com/davidwang456/p/4213652.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring源码系列：依赖注入（二）createBean</title>
      <link href="/2018/11/10/springbase9/"/>
      <url>/2018/11/10/springbase9/</url>
      
        <content type="html"><![CDATA[<p>在<a href="https://juejin.im/post/5a7532746fb9a0633a70d57f" target="_blank" rel="noopener">Spring源码系列：依赖注入（一）（AbstractBeanFactory-getBean）</a>最后说道getBean是依赖注入的起点，bean的创建都是通过createBean来完成具体的创建的。createBean的具体实现是在AbstractAutowireCapableBeanFactory中的。本篇就捋一捋这个方法看下bean的创建过程。</p><p>这个方法是AbstractAutowireCapableBeanFactory这个类的中心方法，其作用就是创建一个bean实例，填充bean实例，后置处理等。</p><p>在createBean中主要做了三件事：</p><ul><li>判断需要创建的Bean是否可以实例化，这个类是否可以通过类装载器来载入</li><li>是否配置了后置处理器相关处理（如果配置了则返回一个代理）</li><li>创建Bean</li></ul><p>具体来看方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"><span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line"><span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line"><span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line"><span class="comment">//判断需要创建的Bean是否可以实例化，这个类是否可以通过类装载器来载入</span></span><br><span class="line">Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"><span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare method overrides.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">mbdToUse.prepareMethodOverrides();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="comment">//异常：Validation of method overrides failed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target </span></span><br><span class="line"><span class="comment">//bean instance.</span></span><br><span class="line"><span class="comment">//是否配置了后置处理器相关处理（如果配置了则返回一个代理）</span></span><br><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">//异常:BeanPostProcessor before instantiation of bean failed</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//创建Bean</span></span><br><span class="line">Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中可以看到，创建bean是交给doCreateBean方法来创建的。继续看doCreateBean这个方法：<br>（这里面涉及到一个BeanWrapper这个接口，小伙伴可以移步了解一下《<a href="https://juejin.im/post/5a77f3eb6fb9a06361085451" target="_blank" rel="noopener">Spring源码系列：BeanWrapper</a>》）</p><p><strong>代码 1：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用BeanWrapper来持有创建出来的Bean对象</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//如果是单例的话，则先把缓存中的同名bean清除</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际创建的交给createBeanInstance来完成，</span></span><br><span class="line"><span class="comment">//bean的生成，这里会使用默认的类生成器，包装成BeanWrapperImpl类，</span></span><br><span class="line"><span class="comment">//为了下面的populateBean方法的属性注入做准备  </span></span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line">Class&lt;?&gt; beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br></pre></td></tr></table></figure></p><p><strong>代码 2：</strong> </p><p>允许后处理器修改合并的bean定义。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">//异常：Post-processing of merged bean definition failed</span></span><br><span class="line">    &#125;</span><br><span class="line">    mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>代码 3 ：</strong></p><p>即使被BeanFactoryAware等生命周期接口触发，也要尽快地缓存singletons 以便能够解析循环引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">if (earlySingletonExposure) &#123;</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(&quot;Eagerly caching bean &apos;&quot; + beanName +</span><br><span class="line">&quot;&apos; to allow for resolving potential circular references&quot;);</span><br><span class="line">&#125;</span><br><span class="line">addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public Object getObject() throws BeansException &#123;</span><br><span class="line">return getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>代码 4:</strong></p><p>这里是对bean的初始化的地方，一般情况下依赖注入就在这里发生；这个exposedObject变量保存的是在初始化处理完以后返回的作为依赖注入完成之后的bean。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">//抛出</span></span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException)</span><br><span class="line">    ex).getBeanName())) &#123;</span><br><span class="line"><span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//异常:Initialization of bean failed</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>代码 5:</strong></p><p>这里是注册bean<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line">catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">    //异常处理</span><br><span class="line">&#125;</span><br><span class="line">//返回结果</span><br><span class="line">return exposedObject;</span><br></pre></td></tr></table></figure></p><p>上面的5个代码段均是doCreateBean中的处理逻辑，有兴趣的小伙伴可以自行查阅源码。从上面的代码中我们依然没有得到具体创建的过程，因为在doCreateBean中又依赖：<code>createBeanInstance</code>和<code>populateBean</code>两个方法。</p><p>在<code>createBeanInstance</code>中生成了Bean所包含的java对象。来看是怎么生成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 确保bean类实际上已经解析过了，可以实例化</span></span><br><span class="line">Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line"><span class="comment">//异常：Bean class isn't public, and non-public access not allowed:beanName</span></span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">//1. 使用工厂方法来进行bean的实例化</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>)  &#123;</span><br><span class="line"><span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新创建相同的bean时快捷方式...</span></span><br><span class="line"><span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">resolved = <span class="keyword">true</span>;</span><br><span class="line">autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (resolved) &#123;</span><br><span class="line"><span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.需要确定构造函数...,使用构造函数进行bean实例化</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.没有特殊的处理：只需使用无参数构造函数。（默认构造函数）</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面这段代码可以看出，对象的生成有许多不同的方式，有通过工厂的，也有通过容器的autowire特性生成的。当然这些生成方式都是由相关的BeanDefinition来指定的。</p><p><strong>Spring中配置Bean的方式我们常用的一种是通过xml文件来配置，还有就是通过注解的方式来配置</strong>。</p><ul><li><strong>demo1</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.glmapper.test.User"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"glmapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>       </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式，通过class提供的权限定名，spring就可以利用反射机制创建这个bean。</p><ul><li><strong>demo2</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.glmapper.test.UserFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getUser"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"glmapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>           </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种是利用静态工厂方法来创建的，提供的class并非是类的权限定名， 而是静态工厂的全类名；除此之外还需要指定获取bean的方法（此处是getUser）和参数（参数是glmapper）。</p><ul><li><strong>demo3</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userFactory&quot; class=&quot;com.glmapper.test.UserInstanceFactory&quot;&gt;</span><br><span class="line">    &lt;!--用一个集合来保存我当前的对象实例--&gt;</span><br><span class="line">    &lt;property name=&quot;map&quot;&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=&quot;user1&quot;&gt;</span><br><span class="line">                &lt;bean class=&quot;com.glmapper.test.User&quot;&gt;</span><br><span class="line">                    &lt;property name=&quot;name&quot; value=&quot;glmapper1&quot;&gt;&lt;/property&gt;        </span><br><span class="line">                &lt;/bean&gt;</span><br><span class="line">            &lt;/entry&gt;    </span><br><span class="line"></span><br><span class="line">            &lt;entry key=&quot;user2&quot;&gt;</span><br><span class="line">                &lt;bean class=&quot;com.glmapper.test.User&quot;&gt;</span><br><span class="line">                    &lt;property name=&quot;name&quot; value=&quot;glmapper2&quot;&gt;&lt;/property&gt;   </span><br><span class="line">                &lt;/bean&gt;</span><br><span class="line">            &lt;/entry&gt;</span><br><span class="line">        &lt;/map&gt;  </span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"> &lt;/bean&gt;</span><br><span class="line"> </span><br><span class="line"> //实例1</span><br><span class="line"> &lt;bean id=&quot;user1&quot; factory-bean=&quot;userFactory&quot; factory-method=&quot;getUserInstance&quot;&gt;</span><br><span class="line">    &lt;constructor-arg value=&quot;user1&quot;&gt;&lt;/constructor-arg&gt;           </span><br><span class="line"> &lt;/bean&gt;</span><br><span class="line">//实例2</span><br><span class="line"> &lt;bean id=&quot;user2&quot; factory-bean=&quot;userFactory&quot; factory-method=&quot;getUserInstance&quot;&gt;</span><br><span class="line">    &lt;constructor-arg value=&quot;user2&quot;&gt;&lt;/constructor-arg&gt;           </span><br><span class="line"> &lt;/bean</span><br></pre></td></tr></table></figure><p>这种方式和静态工厂的区别在于我们需要先实例化一个工厂对象，然后才能使用这个工厂对象来创建我们的bean。getUserInstance通过key值来获取我们已经实例化好的对象（当然方式有很多，此处以map来举个例子）。<code>关于注解的和使用FactoryBean接口的这里就暂时不说，后期再聊</code></p><p>OK，继续来分钟，上面说到的是以工厂方法创建bean，具体的源码有点长，这里就不放了，大概思路就如上面所提到的那几种方式。接下来看下常见的使用instantiateBean方式（使用它的默认构造函数）来构建bean的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object beanInstance;</span><br><span class="line"><span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//获取系统安全接口。</span></span><br><span class="line">    <span class="comment">//如果已经为当前应用程序建立了安全管理器，则返回该安全管理器; </span></span><br><span class="line">    <span class="comment">//否则，返回null。</span></span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">beanInstance = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">&#125;</span><br><span class="line">BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line"><span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">//异常：Instantiation of bean failed</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，上面的创建都是通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br></pre></td></tr></table></figure><p>这样一段代码来完成的，是的，这里已经快接近真相了。从语义上来分析，先是获取了一种策略，然后利用当前获取的策略再去执行实例化。OK，我们看下getInstantiationStrategy()拿到的是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回实例化策略用于创建bean实例。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> InstantiationStrategy <span class="title">getInstantiationStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.instantiationStrategy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认的实例化测试是使用CGLIB代理</span></span><br><span class="line"><span class="keyword">private</span> InstantiationStrategy instantiationStrategy = <span class="keyword">new</span> CglibSubclassingInstantiationStrategy();</span><br></pre></td></tr></table></figure><p>看到这里我们清楚了，默认构造函数的情况下，在spring中会使用Cglib来进行bean的实例化（关于cglib此处不再赘述）。我们看下CglibSubclassingInstantiationStrategy这个类的申明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibSubclassingInstantiationStrategy</span> <span class="keyword">extends</span> <span class="title">SimpleInstantiationStrategy</span></span></span><br></pre></td></tr></table></figure><p>它继承自SimpleInstantiationStrategy ，这个又是什么鬼呢？</p><p><code>SimpleInstantiationStrategy是Spring用来生成Bean对象的默认类，在这个类中提供了两种实例化java对象的方法，一种是基于java自身反射机制的BeanUtils，还有一种就是基于Cglib</code>。</p><p>如何创建的就不说了；到这里createBeanInstance就说完了（Bean已经创建了）；但是仅仅是创建，spring还没有处理它们，比如说bean对象的属性，依赖关系等等。这些就是上面提到的另外一个方法populateBean；</p><p>这个方法其实就做了一件事：<strong>使用bean定义中的属性值在给定的BeanWrapper中填充bean实例。</strong>分段来看：<br>下面这段代码是先将BeanDefinition中设置的property值封装成PropertyValues，然后检测我们的BeanWrapper是否为Null，如果为null则抛出异常或者跳过当前空实例赋值阶段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取到BeanDefinition中设置的property值，封装成PropertyValues</span></span><br><span class="line">PropertyValues pvs = mbd.getPropertyValues();</span><br><span class="line"><span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line"><span class="comment">//异常：Cannot apply property values to null instance</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面这段代码的意思是给任何InstantiationAwareBeanPostProcessors提供在设置属性之前修改bean状态的机会。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">    <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">    continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面就是对具体注入方式的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理autowire的注入；可以根据bean的名称和类型来注入</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">    MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 则根据名称添加基于自动装配的属性值。</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">    autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据类型添加基于自动装配的属性值。</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">    autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pvs = newPvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个判断条件，在满足的情况下做的处理分别是：</p><ul><li>在工厂将给定属性值应用到给定的bean后，对其进行后处理。 允许检查所有的依赖关系是否被满足，例如基于bean属性设置器上的“Required”注解。还允许替换要应用的属性值，通常通过创建基于原始PropertyValues的新MutablePropertyValues实例，添加或删除特定值。</li><li>执行依赖性检查    </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回这个工厂是否拥有一个InstantiationAwareBeanPostProcessor</span></span><br><span class="line"><span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line"><span class="comment">//返回依赖检查代码。</span></span><br><span class="line"><span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line"><span class="comment">//从给定的BeanWrapper中提取一组已过滤的PropertyDescriptors，</span></span><br><span class="line"><span class="comment">//不包括在被忽略的依赖性接口上定义的被忽略的依赖类型或属性（译注）。</span></span><br><span class="line">PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">        InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">        pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是对属性进行注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applyPropertyValues(beanName, mbd, bw, pvs);</span><br></pre></td></tr></table></figure><p>这个方法描述的是对属性进行解析然后注入的过程；先来分析下applyPropertyValues的申明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(String beanName</span></span></span><br><span class="line"><span class="function"><span class="params">, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span></span></span><br></pre></td></tr></table></figure></p><ul><li>beanName bean名称</li><li>mbd 合并的bean definition</li><li>bw 包装目标对象的BeanWrapper</li><li>pvs 新的属性值</li></ul><p>代码分段来看：</p><ul><li><p>参数验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pvs == <span class="keyword">null</span> || pvs.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>pvs参数处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">    mpvs = (MutablePropertyValues) pvs;</span><br><span class="line">    <span class="keyword">if</span> (mpvs.isConverted()) &#123;</span><br><span class="line">    <span class="comment">// 使用预先转换后的值。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    bw.setPropertyValues(mpvs);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">    <span class="comment">//异常：Error setting property values</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    original = mpvs.getPropertyValueList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>valueResolver来解析BeanDefinition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionValueResolver valueResolver = </span><br><span class="line"><span class="keyword">new</span> BeanDefinitionValueResolver(<span class="keyword">this</span>, beanName, mbd, converter);</span><br></pre></td></tr></table></figure></li><li><p>为解析值创建一个副本，注入到bean中的是副本的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a deep copy, resolving any references for values.</span></span><br><span class="line">List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> ArrayList&lt;PropertyValue&gt;(original.size());</span><br></pre></td></tr></table></figure></li><li><p>遍历处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> resolveNecessary = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line">    <span class="comment">//返回此持有者是否已经包含转换后的值（true），还是需要转换值（false）。</span></span><br><span class="line">    <span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">    deepCopy.add(pv);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    String propertyName = pv.getName();</span><br><span class="line">    Object originalValue = pv.getValue();</span><br><span class="line">    <span class="comment">//看下面的注释resolveValueIfNecessary</span></span><br><span class="line">    Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">    Object convertedValue = resolvedValue;</span><br><span class="line">    <span class="keyword">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">    !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line">    <span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">    convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可能将转换的值存储在合并的bean定义中，以避免为每个创建的bean实例重新转换。</span></span><br><span class="line">    <span class="keyword">if</span> (resolvedValue == originalValue) &#123;</span><br><span class="line">    <span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">    pv.setConvertedValue(convertedValue);</span><br><span class="line">    &#125;</span><br><span class="line">    deepCopy.add(pv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue &amp;&amp;</span><br><span class="line">    !((TypedStringValue) originalValue).isDynamic() &amp;&amp;</span><br><span class="line">    !(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;</span><br><span class="line">    pv.setConvertedValue(convertedValue);</span><br><span class="line">    deepCopy.add(pv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    resolveNecessary = <span class="keyword">true</span>;</span><br><span class="line">    deepCopy.add(<span class="keyword">new</span> PropertyValue(pv, convertedValue));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>resolveValueIfNecessary</p><p>  给定一个PropertyValue，返回一个value，必要时解析对工厂中其他bean的引用。value可以是：</p><ul><li>一个BeanDefinition，它导致创建一个相应的新的bean实例。 Singleton标志和这样的”inner beans”的名字被忽略：内部beans是匿名原型。</li><li>RuntimeBeanReference(必须解析)</li><li>ManagedList</li><li>ManagedSet</li><li>ManagedMap</li><li>一个普通的对象或null，在这种情况下，它是孤立的。</li></ul></li></ul><p>下面这段代码时依赖注入发生的地方，其实际上是在BeanWrapperImpl中来完成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    bw.setPropertyValues(<span class="keyword">new</span> MutablePropertyValues(deepCopy));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">    <span class="comment">//异常：Error setting property values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面说到spring是通过BeanDefinitionValueResolver来解析BeanDefinition的，然后再注入到property中，关于这个过程在下一篇中来说。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring源码系列：依赖注入（一）getBean</title>
      <link href="/2018/11/10/springbase8/"/>
      <url>/2018/11/10/springbase8/</url>
      
        <content type="html"><![CDATA[<p>在<a href="https://juejin.im/post/5a6eff066fb9a01cbb3963a9" target="_blank" rel="noopener">Spring源码系列：BeanFactory的创建</a>文章中我们谈到了BeanFactory这容器，这个里面提供了注入的实现接口。其具体的实现还需要从AbstractBeanFactory和DefaultListableBeanFactory中来看。今天就先撸一下AbstractBeanFactory这个类中的getBean这个方法。</p><p><strong>1、getBean方法</strong></p><p>getBean提供了四个重载方法，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过name获取Bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过name和类型获取Bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> doGetBean(name, requiredType, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过name和对象参数获取Bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, args, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过name、类型和参数获取Bean</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> doGetBean(name, requiredType, args, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从这四个重载方法的方法体中可以看出，他们都是通过doGetBean来实现的。所以doGetBean其实才是真正获取Bean的地方，也是触发依赖注入发生的地方。（这个方法比较长，分段来说）</p><p><strong>2、doGetBean</strong></p><p>先来看下方法的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br></pre></td></tr></table></figure><ul><li>name 要检索的bean的名称</li><li>requiredType 要检索的bean所需的类型</li><li>args 使用显式参数创建bean实例时使用的参数（仅在创建新实例时应用，而不是在检索现有实例时应用）</li><li>typeCheckOnly 是否为类型检查而获得实例，而不是实际使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回bean名称，剥离工厂引用前缀，并将别名解析为规范名称。</span></span><br><span class="line"><span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line"><span class="comment">//声明当前需要返回的bean对象</span></span><br><span class="line">Object bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先从缓存中获取bean，处理已经被创建的单例模式的bean，</span></span><br><span class="line"><span class="comment">//对于此类bean的请求不需要重复的创建(singleton)</span></span><br><span class="line">Object sharedInstance = getSingleton(beanName);</span><br></pre></td></tr></table></figure><p>如果当前获取到的sharedInstance不为null并且参数为空，则进行FactoryBean的相关处理，并获取FactoryBean的处理结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    <span class="comment">//返回指定的singleton bean是否正在创建（在整个工厂内）。</span></span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">logger.debug(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> </span><br><span class="line">+ beanName +<span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完成FactoryBean的相关处理，并用来获取FactoryBean的处理结果</span></span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果当前获取到的sharedInstance为null，我们再来看下做了哪些处理（下面的都在一个大的else里面）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//分解到下面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在当前线程中，返回指定的prototype bean是否正在创建。</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这段的作用是对Ioc容器中的BeanDefinition是否存在进行检测，先是检测当前BeanFactory中是否能够获取到，如果取不到则继续到双亲容器中进行尝试获取，如果双亲还是取不到，则继续向上一级父容器中尝试获取。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查该工厂是否存在bean定义。</span></span><br><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line"><span class="comment">// 如果没有，则继续检查父类</span></span><br><span class="line">String nameToLookup = originalBeanName(name);</span><br><span class="line"><span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 用明确的参数代表父项。</span></span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果没有args - &gt;委托给标准的getBean方法。</span></span><br><span class="line"><span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将指定的bean标记为已经创建（或即将创建）；这里允许bean工厂优化其缓存以重复创建指定的bean。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先根据beanName来获取BeanDefinition，然后获取当前bean的所有依赖bean，这里是通过递归调用getBean来完成，直到没有任何依赖的bean为止。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="comment">//检查给定的合并bean定义，可能抛出验证异常。</span></span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"><span class="comment">// 保证当前bean依赖的bean的初始化。</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line"><span class="comment">//递归处理依赖bean</span></span><br><span class="line">getBean(dep);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面这段就是创建一个bean实例；这里通过调用getSingleton方法来创建一个单例bean实例；从代码中可以看到，getSingleton的调用是通过getObject这个回调函数来间接调用createBean完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line"><span class="comment">//回调函数getObject</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建bean</span></span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">//发生异常则销毁</span></span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//获取给定bean实例的对象，无论是bean实例本身，还是FactoryBean创建的对象。</span></span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是创建prototype bean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">    Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    beforePrototypeCreation(beanName);</span><br><span class="line">    <span class="comment">//创建prototype bean</span></span><br><span class="line">    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">    afterPrototypeCreation(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后是对创建的bean进行类型检查，没有问题就返回已经创建好的bean；此时这个bean是包含依赖关系的bean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">return getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">&#125;</span><br><span class="line">catch (TypeMismatchException ex) &#123;</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(&quot;Failed to convert bean &apos;&quot; + name + &quot;&apos; to required type &apos;&quot; +</span><br><span class="line">ClassUtils.getQualifiedName(requiredType) + &quot;&apos;&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//返回bean</span><br><span class="line">return (T) bean;</span><br></pre></td></tr></table></figure><p>getBean是依赖注入的起点，从上面的分析可以看出，bean的创建都是通过createBean来完成具体的创建的。createBean的具体实现是在AbstractAutowireCapableBeanFactory中的，这里createBean不仅仅负责创建bean，还需要完成对bean的初始化。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring源码系列：依赖注入-引言</title>
      <link href="/2018/11/10/springbase7/"/>
      <url>/2018/11/10/springbase7/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://juejin.im/post/5a62e99e6fb9a01c9950e667" target="_blank" rel="noopener">Spring源码系列：BeanDefinition源码解析</a></li><li><a href="https://juejin.im/post/5a6f0e8bf265da3e303cc302" target="_blank" rel="noopener">Spring源码系列：BeanDefinition载入(上)</a></li><li><a href="https://juejin.im/post/5a74563f5188257a5b043736" target="_blank" rel="noopener">Spring源码系列：BeanDefinition载入(中)</a></li><li><a href="https://juejin.im/post/5a73c4d3f265da4e7a78266c" target="_blank" rel="noopener">Spring源码系列：BeanDefinition载入(下)</a></li></ul><p>在上面四篇文章中大概分析了一下Bean的载入，其实这个过程就是在Ioc容器中建立BeanDefinition的数据映射。但是对于Bean的实例化并未涉及，在之前的分析中也提到，bean的实例化是在依赖注入是才具体完成。</p><h2 id="关于依赖注入"><a href="#关于依赖注入" class="headerlink" title="关于依赖注入"></a>关于依赖注入</h2><p>关于Spring，我们最先想到的就两个Ioc和Aop；然后关于Ioc我们又能牵扯出两个：控制反转和依赖注入。<br>控制反转和依赖注入在网上被无数大神亦或菜鸟解读过，这里就不罗列那些概念了，直接看：</p><p><strong>不使用Spring</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//手动new一个</span></span><br><span class="line">    UserDao userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userDao.insertUser(userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>使用Spring(以注解方式)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userDao.insertUser(userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来貌似没有啥很大的改变，区别呢？</p><p>我们先来分析下在一个类中这两种申明的区别：</p><p><code>UserDao userDao;</code></p><p>userDao是UserDao类型的引用名称。仅仅是声明了一个变量引用名称。并没有做实例化，userDao的实例化可以通过set方法进行设置（Spring中之前常用的就是set方法注入）；当我们初始化持有userDao的这个类时我们还不知道userDao到底具体指向哪个堆中的对象地址。</p><p><code>UserDao userDao = new UserDaoImpl();</code></p><p>而这个，申明一个变量名称，并将userDao直接指向new UserDaoImpl()创建的对象。</p><p>我们来看Spring中关于注入之后对象地址以及不使用注入方式对象的地址：</p><p><strong>1、直接注入</strong><br><img src="https://user-gold-cdn.xitu.io/2018/2/3/16159c3902ee9323?w=835&amp;h=255&amp;f=png&amp;s=105686" alt=""><br><strong>2、注入覆盖了我自己的对象</strong><br><img src="https://user-gold-cdn.xitu.io/2018/2/3/16159c1cd7a9401c?w=887&amp;h=283&amp;f=png&amp;s=27716" alt=""><br><strong>3、自己手动new</strong><br><img src="https://user-gold-cdn.xitu.io/2018/2/3/16159c2b21b3bbb5?w=845&amp;h=254&amp;f=png&amp;s=17465" alt=""></p><p>通过上面三幅图可以明显的看出，自己手动new的对象没有使用代理的方式，而托管给Spring注入的对象均是通过动态代理来完成的。</p><p>关于动态代理：<a href="https://juejin.im/post/5a5c48d2518825733d690ab0" target="_blank" rel="noopener">《猪弟拱Java》连载番外篇：Java代理（中）</a></p><p>总结：当某个角色(可能是一个Java实例，调用者)需要另一个角色(另一个Java实例，被调用者)的协助时，在未使用Spring来管理Bean的程序设计过程中，通常由调用者来创建被调用者的实例。但在Spring里，创建被调用者的工作不再由调用者来完成，因此称为控制反转;创建被调用者实例的工作通常由Spring容器来完成，然后注入调用者，因此也称为依赖注入。</p><h2 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题"></a>三个问题</h2><p>那么现在要考虑问题就是，<strong>什么时候会触发我们的依赖注入呢？Bean的实例化是否必须在依赖注入时才能完成呢？在Spring中又是通过哪些类来完成注入工作的呢？</strong></p><p><strong>1、什么时候会触发我们的依赖注入</strong></p><p>答：用户第一次向容器获取Bean的时候出发。</p><p><strong>2、Bean的实例化是否必须在依赖注入时才能完成</strong></p><p>这个其实不是必须的，咱们都知道BeanDefinition中有lazy-init这样一个属性，我们可以通过控制这个属性的设置来让容器完成对Bean的预实例化。预实例化就是说它的依赖注入是在实例化过程中完成的。</p><p><code>第一和第二个问题将会在分析第三个问题的时候慢慢的细化分析。所以第三个问题其实没啥鸟用，但也是最最最核心的，就是为了引出后面关于一些具体类的分析的。</code></p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring源码系列：Spring的版本变更</title>
      <link href="/2018/11/10/springbase0/"/>
      <url>/2018/11/10/springbase0/</url>
      
        <content type="html"><![CDATA[<p>Spring是一个开放源代码的设计层面框架，它解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson创建。简单来说，Spring是一个分层的JavaSE/EEfull-stack(一站式) 轻量级开源框架【来自百度百科】。</p><p>目前Spring已经发展到5.0.4 版本了，今天咱们就来聊一聊spring各个版本都提供了哪些新的特性。</p><h2 id="spring-2-x"><a href="#spring-2-x" class="headerlink" title="spring 2.x"></a>spring 2.x</h2><p>spring的2.x包括下面两个：</p><ul><li>2.0.0-2.0.8</li><li>2.5.0-2.5.6<br>此时的spring还是很年轻的，所包含的模块也不是很多。如下图：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/1/31/1614be600a754d65?w=555&amp;h=438&amp;f=png&amp;s=71797" alt=""></p><p><strong>2.0 新特性</strong></p><ul><li>XML Schema的新XML配置语法的出现</li><li><p>新的Bean的作用域</p><p>  以前的Spring版本对IoC容器级支持两个不同的bean作用域（singleton和prototype）。Spring 2.0在这方面进行了改进，不仅根据部署Spring的环境（例如Web环境中的请求和会话作用域Bean）提供了一些额外的作用域，还提供了“挂钩”），使Spring用户可以创建自己的范围。<br>  应该注意的是，虽然singleton和prototype作用域bean的底层（和内部）实现已经改变，但是所述改变对于最终用户是完全透明的…不需要改变现有的配置，并且不存在现有的配置将会中断。<br><img src="https://user-gold-cdn.xitu.io/2018/1/31/1614be8dc0897ca1?w=573&amp;h=425&amp;f=png&amp;s=143803" alt=""></p></li><li>可扩展的XML</li><li>支持@AspectJ方面</li><li>更加简单XML配置(aop&amp;事务)</li><li>异步JMS</li><li>Spring MVC的表单标签库</li><li>Java 5（Tiger）支持</li><li>Spring 2.0现在支持用Java以外的语言编写的bean，目前支持的动态语言是JRuby，Groovy和BeanShell</li><li>提供了一个关于任务调度的抽象概念</li><li>引入了对各种注释的支持，用于配置目的，例如@ Transactional， @Required和@PersistenceContext / @PersistenceUnit。</li><li><strong>2.5 新特性</strong></li><li>在Spring 2.0在整个框架中对Java 5的深入支持之后，Spring 2.5引入了对Java 6的专门支持。</li><li>@Autowired结合对JSR-250注释@Resource，@ PostConstruct和@PreDestroy的支持 。</li><li><p>在类路径中自动检测组件</p><p>  Spring 2.5引入了支持组件扫描：在类路径中自动检测带注释的组件。典型地，这样的组件类将与定型如进行注释@Component， @Repository，@Service， @Controller。根据应用程序的上下文配置，这些组件类将被自动检测并转换为Spring bean定义，而不需要为每个这样的bean显式配置。</p></li><li><p>支持bean名称切入点元素</p><p>  Spring 2.5引入了对bean（…） pointcut元素的支持，根据Spring定义的bean名称匹配特定的命名bean</p></li><li>支持AspectJ加载时织入</li><li>Spring 2.5显着扩展了SimpleJdbcTemplate的功能， 并引入了 SimpleJdbcCall和SimpleJdbcInsert 操作对象。</li><li><p>基于注释的控制器。</p><p>  Spring 2.5为MVC控制器引入了一个基于注释的编程模型，使用@ RequestMapping，@ RequestParam，@ ModelAttribute等注解。这个注解支持可用于Servlet MVC和Portlet MVC。以这种风格实现的控制器不必扩展特定的基类或实现特定的接口。此外，他们通常不直接依赖于Servlet或Portlet API，尽管他们可以很容易地访问Servlet或Portlet设施。</p></li><li>引入了Spring TestContext框架</li></ul><h2 id="Spring-3-x"><a href="#Spring-3-x" class="headerlink" title="Spring 3.x"></a>Spring 3.x</h2><p>spring 3.x包括以下几个系列：</p><ul><li>3.0.0-3.0.7</li><li>3.1.0-3.1.4</li><li>3.2.0-3.2.18</li></ul><p>在2.x的模块上页拓展了新的模块</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/31/1614bf499bb3d118?w=555&amp;h=428&amp;f=png&amp;s=83101" alt=""></p><p><strong>3.0.x 新特性</strong></p><ul><li>针对Java 5更新的核心API</li><li>spring 表达语言</li><li>基于Java的bean元数据和在组件中定义bean元数据</li><li>通用型转换系统和现场格式化系统</li><li>全面的REST支持</li><li>声明式模型验证</li><li>早期支持Java EE 6</li><li>支持嵌入式数据库</li></ul><p><strong>3.1.x 新特性</strong></p><ul><li>缓存抽象</li><li>Bean定义配置文件</li><li>环境抽象</li><li>PropertySource抽象</li><li>Spring的XML名称空间的代码等价物</li><li>支持Hibernate 4.x</li><li>TestContext框架支持@Configuration类和bean定义配置文件</li><li>更简洁的构造函数注入的命名空间</li><li>支持针对非标准JavaBeans设置器的注入</li><li>支持Servlet 3基于代码的Servlet Container配置</li><li>支持Servlet 3 MultipartResolver</li><li>没有persistence.xml的JPA EntityManagerFactory引导</li><li>用于注释的控制器处理的新的基于HandlerMethod的支持类</li><li>Flash属性和RedirectAttributes(请求重定向参数的支持)</li><li><p>“consumes” and “produces” conditions in @RequestMapping</p><p>  改进了对通过’Content-Type’标题指定方法消耗的媒体类型以及通过标题指定的可生成类型的支持’Accept’ </p></li><li>URI模板变量增强</li><li>@Valid on @RequestBody控制器方法参数</li><li>控制器方法参数上的@RequestPart注释</li><li>UriComponentsBuilder和UriComponents</li></ul><p><strong>3.2.x 新特性</strong></p><ul><li>支持基于Servlet 3的异步请求处理</li><li>Spring MVC测试框架</li><li>@ControllerAdvice注解</li><li>基于代码的Servlet 3+容器初始化的抽象基类</li><li>ResponseEntityExceptionHandler类引入</li><li>在RestTemplate和中的 @RequestBody参数支持泛型类型</li><li>JackJSON 2和相关的改进</li><li>@RequestBody改进</li><li>HTTP PATCH方法</li><li>使用注释点和bean定义方法的元注释</li><li>初步支持JCache 0.5</li><li>全球日期和时间格式</li><li>整个框架的并发优化</li><li>新的基于Gradle的构建和移动到GitHub</li><li>精炼的Java SE 7 / OpenJDK 7支持</li></ul><h2 id="Spring-4-x"><a href="#Spring-4-x" class="headerlink" title="Spring 4.x"></a>Spring 4.x</h2><p>spring 4包括以下系列版本：</p><ul><li>4.0.0-4.0.9</li><li>4.1.0-4.1.9</li><li>4.2.0-4.2.9</li><li>4.3.0-4.3.13</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/1/31/1614c0070748eada?w=720&amp;h=540&amp;f=png&amp;s=42346" alt=""><br><strong>spring 4.0.x 新特性</strong></p><ul><li><p>删除弃用的软件包和方法</p><p>  可选的第三方依赖已被提升到2010/2011最低（即Spring 4通常只支持2010年末或之后发布的版本）：特别是，Hibernate 3.6+，EhCache 2.1+，Quartz 1.8+，Groovy 1.8+和Joda-Time 2.0+。作为规则的一个例外，Spring 4需要最近的Hibernate Validator 4.3+，并且对Jackson的支持已经集中在2.0+以上（当前Spring 3.2已经保留了对Jackson 1.8 / 1.9的支持;现在只是弃用了形成）。</p></li><li><p>Java 8（以及6和7）</p><p>  可以使用Spring的回调接口使用 lambda表达式和方法引用</p></li><li><p>Java EE 6和7</p><p>  Java EE 6或更高版本现在被认为是Spring Framework 4的基准，JPA 2.0和Servlet 3.0规范特别相关。为了与Google App Engine和较早的应用程序服务器保持兼容，可以将Spring 4应用程序部署到Servlet 2.5环境中。不过，强烈建议使用Servlet 3.0+，这是Spring开发环境中测试设置的测试和模拟包中的先决条件。</p></li><li>Groovy Bean定义DSL</li><li><p>核心容器改进</p><ul><li>Spring现在将泛型类型作为注入Beans时限定符的形式 。例如，如果您正在使用Spring Data Repository，则现在可以轻松注入一个特定的实现： @Autowired Repository<customer> customerRepository。</customer></li><li>如果您使用Spring的元注释支持，现在可以开发自定义注释来 显示源注释中的特定属性。</li><li>bean现在可以在自动装配到列表和数组中时进行排序。无论是标注和接口的支持。 @OrderOrdered</li><li>该@Lazy注释现在可以在注入点使用，以及对@Bean 定义。</li><li>该@Description批注已经推出了使用基于Java的配置开发。</li><li>已经通过注释添加 了有条件地过滤bean的通用模型@Conditional。这与@Profile支持类似，但允许以编程方式开发用户定义的策略。</li><li>基于CGLIB的代理类不再需要默认的构造函数。支持通过提供objenesis 其重新打包库在线，并将其作为Spring框架的一部分。有了这个策略，所有的构造函数都不再被调用代理实例。</li><li>整个框架现在都有管理时区的支持，例如LocaleContext。</li></ul></li><li><p>web 模块支持</p><ul><li>可以在Spring MVC应用程序中使用新的@RestController注释，不需要添加@ResponseBody到每个 @RequestMapping方法中。</li><li>该AsyncRestTemplate已添加，允许异步非阻塞支持开发REST客户端时。</li><li>开发Spring MVC应用程序时提供了全面的时区支持。</li></ul></li><li><p>测试改进</p></li><li>WebSocket，SockJS和STOMP消息传递</li></ul><p><strong>spring 4.1.x 新特性</strong></p><ul><li>JMS改进</li><li>缓存改进</li><li>网络改进</li><li>WebSocket消息传递改进</li><li>测试改进</li></ul><p><strong>spring 4.2.x 新特性</strong></p><p><a href="https://docs.spring.io/spring/docs/4.3.9.RELEASE/spring-framework-reference/html/new-in-4.2.html#v4_2-Core-Container-Improvements" target="_blank" rel="noopener">Spring 4 官方文档</a></p><ul><li>核心容器改进</li><li>数据访问改进</li></ul><p><strong>spring 4.3.x 新特性</strong></p><ul><li>支持新的包和服务</li><li>相关改进</li></ul><p>目前还没有用过spring5，总会有憧憬。当我们使用spring越来越简单时，危机也在一步步逼近；看到表象，进一步，再进一步！</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring源码系列：BeanDefinition载入(下)</title>
      <link href="/2018/11/10/springbase5/"/>
      <url>/2018/11/10/springbase5/</url>
      
        <content type="html"><![CDATA[<div class="output_wrapper" id="output_wrapper_id" style="font-size: 16px; color: rgb(62, 62, 62); line-height: 1.6; word-spacing: 0px; letter-spacing: 0px; font-family: 'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', Arial, sans-serif;"><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">在<a href="https://juejin.im/post/5a6f0e8bf265da3e303cc302" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; text-decoration: none; color: rgb(30, 107, 184); word-wrap: break-word;" target="_blank" rel="noopener">Spring源码系列：BeanDefinition载入(上)</a>中已经大概捋了一下解析过程，本篇将记录一下bean的注册过程。</p><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">bean的注册就是DefaultListableBeanFactory中registerBeanDefinition方法来完成的。那我就来看registerBeanDefinition这个方法的具体逻辑。</p><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;"><strong style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold;">1、beanDefinition类型判断和验证</strong></p><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">这里的验证主要是验证不能将静态工厂方法与方法重写相结合(静态工厂方法必须创建实例);</p><br><pre style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><code class="java language-java hljs" style="margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; color: rgb(169, 183, 198); background: rgb(40, 43, 46); overflow-x: auto; padding: 0.5em; display: block !important; word-wrap: normal !important; word-break: normal !important; white-space: pre !important; overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (beanDefinition <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">instanceof</span> AbstractBeanDefinition) {<br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">try</span> {<br>        ((AbstractBeanDefinition) beanDefinition).validate();<br>    }<br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">catch</span> (BeanDefinitionValidationException ex) {<br>        <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">throw</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(),<br>        beanName,<span class="hljs-string" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(238, 220, 112); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">“Validation of bean definition failed”</span>, ex);<br>    }<br>}<br></code></pre><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;"><strong style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold;">2、尝试从beanDefinitionMap中获取老的bean</strong></p><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">这里就是先根据beanName从beanDefinitionMap去取BeanDefinition，并将结果给oldBeanDefinition。</p><br><pre style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><code class="java language-java hljs" style="margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; color: rgb(169, 183, 198); background: rgb(40, 43, 46); overflow-x: auto; padding: 0.5em; display: block !important; word-wrap: normal !important; word-break: normal !important; white-space: pre !important; overflow: auto !important;">BeanDefinition oldBeanDefinition;<br>oldBeanDefinition = <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>.beanDefinitionMap.get(beanName);<br></code></pre><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;"><strong style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold;">3、beanDefinitionMap中已经存在名为beanName的Beandefinition</strong></p><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">如果当前beanDefinitionMap中已经存在名为beanName的Beandefinition了(即检查是否有相同名称的beanDefinition已经在Ioc容器中注册过了)。，如果有，则进行以下具体策略：</p><br><ul style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;"><br><li style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;"><span style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">如果不允许bean被覆盖，则直接抛出不能重新注册，bean已经存在这样的异常信息</span></li><br><li style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;"><span style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">使用框架生成的Bean来代替用户自定义的bean</span></li><br><li style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;"><span style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">覆盖原有的Beandefinition</span></li><br></ul><br><pre style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><code class="java language-java hljs" style="margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; color: rgb(169, 183, 198); background: rgb(40, 43, 46); overflow-x: auto; padding: 0.5em; display: block !important; word-wrap: normal !important; word-break: normal !important; white-space: pre !important; overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (oldBeanDefinition != <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">null</span>) {<br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (!isAllowBeanDefinitionOverriding()) {<br>        <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//省略异常代码</span><br>    }<br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">else</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) {<br>        <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//省略异常代码</span><br>    }<br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">else</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (!beanDefinition.equals(oldBeanDefinition)) {<br>        <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//提示覆盖log信息</span><br>    }<br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">else</span> {<br>        <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//提示覆盖log信息</span><br>    }<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//覆盖原有的Beandefinition</span><br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>.beanDefinitionMap.put(beanName, beanDefinition);<br>}<br></code></pre><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;"><strong style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold;">4、beanDefinitionMap不存在名为beanName的Beandefinition</strong></p><br><pre style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><code class="java language-java hljs" style="margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; color: rgb(169, 183, 198); background: rgb(40, 43, 46); overflow-x: auto; padding: 0.5em; display: block !important; word-wrap: normal !important; word-break: normal !important; white-space: pre !important; overflow: auto !important;"><span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//检查bean的创建阶段是否已经开始，也就是说是否已经创建了</span><br><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (hasBeanCreationStarted()) {<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//Cannot modify startup-time collection elements anymore (for stable iteration)</span><br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">// 无法修改启动时间收集元素（用于稳定迭代）（译注）</span><br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//注册过程需要保证数据的一致性，所有需要加锁同步</span><br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">synchronized</span> (<span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>.beanDefinitionMap) {<br>        <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//注册到beanDefinitionMap中</span><br>        <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>.beanDefinitionMap.put(beanName, beanDefinition);<br>        <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//下面就是将当前beanName存放到beanDefinitionNames中</span><br>        List&lt;String&gt; updatedDefinitions = <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">new</span> ArrayList&lt;String&gt;(<br>        <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>.beanDefinitionNames.size() + <span class="hljs-number" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(174, 135, 250); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">1</span>);<br>        updatedDefinitions.addAll(<span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>.beanDefinitionNames);<br>        updatedDefinitions.add(beanName);<br>        <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>.beanDefinitionNames = updatedDefinitions;<br>        <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//如果单例模式的bean名单中有该bean的name，那么移除掉它。</span><br>        <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//也就是说着，将一个原本是单例模式的bean重新注册成一个普通的bean</span><br>        <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (<span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>.manualSingletonNames.contains(beanName)) {<br>            Set&lt;String&gt; updatedSingletons = <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">new</span><br>            LinkedHashSet&lt;String&gt;(<span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>.manualSingletonNames);<br>            updatedSingletons.remove(beanName);<br>            <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>.manualSingletonNames = updatedSingletons;<br>        }<br>    }<br>}<br><span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">// 仍处于启动阶段，bean还没有开始注册</span><br><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">else</span> {<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">// Still in startup registration phase</span><br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>.beanDefinitionMap.put(beanName, beanDefinition);<br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>.beanDefinitionNames.add(beanName);<br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>.manualSingletonNames.remove(beanName);<br>}<br><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>.frozenBeanDefinitionNames = <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">null</span>;<br></code></pre><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;"><strong style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold;">5、执行缓存清除</strong></p><br><ul style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;"><br><li style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;"><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">1：oldBeanDefinition如果存在，且执行到了这里也没有抛出异常，说明该BeanDefinition已经被覆盖，缓存需要更新。</p></li><br><li style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;"><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">2：如果是单例模式的bean对象则Set中包含该beanName，执行到这里说明该BeanDefinition已经从一个单例模式的bean变为了一个普通的bean，所以缓存也需要更新。</p></li><br></ul><br><pre style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><code class="java language-java hljs" style="margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; color: rgb(169, 183, 198); background: rgb(40, 43, 46); overflow-x: auto; padding: 0.5em; display: block !important; word-wrap: normal !important; word-break: normal !important; white-space: pre !important; overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (oldBeanDefinition != <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">null</span> || containsSingleton(beanName)) {<br>    resetBeanDefinition(beanName);<br>}<br></code></pre><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">OK，我们来看下resetBeanDefinition这个方法:</p><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;"><code style="font-size: inherit; line-height: inherit; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(233, 105, 0); background: rgb(248, 248, 248);">这个方法的作用就是重置给定bean的所有bean定义缓存，包括从它派生的bean的缓存。</code></p><br><pre style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><code class="java language-java hljs" style="margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; color: rgb(169, 183, 198); background: rgb(40, 43, 46); overflow-x: auto; padding: 0.5em; display: block !important; word-wrap: normal !important; word-break: normal !important; white-space: pre !important; overflow: auto !important;"><span class="hljs-function" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;"><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">protected</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">void</span> <span class="hljs-title" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(165, 218, 45); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">resetBeanDefinition</span><span class="hljs-params" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(255, 152, 35); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">(String beanName)</span> </span>{<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">// 如果已经创建，则删除给定bean的合并bean定义。</span><br>    clearMergedBeanDefinition(beanName);<br><br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">// 如果有的话，从singleton 高速缓存中删除相应的bean。</span><br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//但是这也不是必须的，而只是为了覆盖上下文的默认bean</span><br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//（就是从manualSingletonNames中移除）</span><br>    destroySingleton(beanName);<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//递归的方式来 重置具有给定bean作为父项的所有bean定义。</span><br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">for</span> (String bdName : <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>.beanDefinitionNames) {<br>        <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (!beanName.equals(bdName)) {<br>            BeanDefinition bd = <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>.beanDefinitionMap.get(bdName);<br>            <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (beanName.equals(bd.getParentName())) {<br>                resetBeanDefinition(bdName);<br>            }<br>        }<br>    }<br>}<br></code></pre><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">Bean的注册就到这里了，下一篇学习的是DefaultListableBeanFactory这个集大成者容器。</p></div>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring源码系列：BeanDefinition载入（中）</title>
      <link href="/2018/11/10/springbase6/"/>
      <url>/2018/11/10/springbase6/</url>
      
        <content type="html"><![CDATA[<p>上一篇是将Bean的解析注册流程进行了梳理，对于一些细节问题没有进行细究，比如说元素属性值的处理，构造函数的处理等等。本篇就学习记录一下相关点。</p><p>首先来看下是在哪个地方具体生成BeanDefinitiond的。下面是方法请求的顺序。</p><ul><li><ol><li>DefaultBeanDefinitionDocumentReader.parseDefaultElement</li></ol></li><li><ol start="2"><li>DefaultBeanDefinitionDocumentReader.processBeanDefinition</li></ol></li><li><ol start="3"><li>BeanDefinitionParserDelegate.parseBeanDefinitionElement</li></ol></li></ul><p>关于元素的解析绝大多数都是在BeanDefinitionParserDelegate及其子类中完成的。OK，来看下parseBeanDefinitionElement这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Element ele, String beanName, BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line">String className = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//在这里是读取&lt;bean&gt;的class名字，然后载入到BeanDefinition中，并未做实例化</span></span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String parent = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成BeanDefinition对象</span></span><br><span class="line">AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"><span class="comment">//解析当前bean的属性</span></span><br><span class="line">parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line"><span class="comment">//设置description信息</span></span><br><span class="line">bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"><span class="comment">//对bean的元素信息进行解析</span></span><br><span class="line">parseMetaElements(ele, bd);</span><br><span class="line">parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"><span class="comment">//解析bean的构造函数设置</span></span><br><span class="line">parseConstructorArgElements(ele, bd);</span><br><span class="line"><span class="comment">//解析property设置</span></span><br><span class="line">parsePropertyElements(ele, bd);</span><br><span class="line">parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//异常1：ClassNotFoundException</span></span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">error(<span class="string">"Bean class ["</span> + className + <span class="string">"] not found"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//异常2：NoClassDefFoundError</span></span><br><span class="line"><span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">error(<span class="string">"Class that bean class ["</span> + className + <span class="string">"] depends on not found"</span>, ele, err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他未知错误</span></span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">error(<span class="string">"Unexpected failure during bean definition parsing"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.parseState.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处我们以解析property为例，看下具体的处理细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析给定bean元素的属性子元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parsePropertyElements</span><span class="params">(Element beanEle, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取子元素节点</span></span><br><span class="line">    NodeList nl = beanEle.getChildNodes();</span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">    Node node = nl.item(i);</span><br><span class="line">    <span class="comment">//是否包含property标识</span></span><br><span class="line">    <span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) &#123;</span><br><span class="line">    parsePropertyElement((Element) node, bd);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是执行具体property,在parsePropertyElement中完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析一个property元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parsePropertyElement</span><span class="params">(Element ele, BeanDefinition bd)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//首先获取到property的名称</span></span><br><span class="line">String propertyName = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"><span class="comment">//检查是否有name</span></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(propertyName)) &#123;</span><br><span class="line">error(<span class="string">"Tag 'property' must have a 'name' attribute"</span>, ele);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> PropertyEntry(propertyName));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">//验证在同一个bean中存在同名的property，存在的话就不解析了，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (bd.getPropertyValues().contains(propertyName)) &#123;</span><br><span class="line">error(<span class="string">"Multiple 'property' definitions for property '"</span> + propertyName + <span class="string">"'"</span>, ele);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析出property的值</span></span><br><span class="line">Object val = parsePropertyValue(ele, bd, propertyName);</span><br><span class="line"><span class="comment">//封装成PropertyValue对象</span></span><br><span class="line">PropertyValue pv = <span class="keyword">new</span> PropertyValue(propertyName, val);</span><br><span class="line">parseMetaElements(ele, pv);</span><br><span class="line">pv.setSource(extractSource(ele));</span><br><span class="line">bd.getPropertyValues().addPropertyValue(pv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.parseState.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在parsePropertyValue中，是对所有的property子元素进行具体解析的。我们知道property中除了单值之外，还会包括如：list，set，map，prop等集合元素；这些都会被封装成对应的Managerd对象。比如：ManagedList等。不同的集合类型页同样对应一种解析方法，比如解析list的是使用parseListElement。这些解析都是在BeanDefinitionParserDelegate类中完成的。这个后面我会抽一篇来学习BeanDefinitionParserDelegate这个类。</p><p>Bean的载入过程就是这样通过层层解析来完成的，但是对于目前的Ioc容器来说，仅仅是完成了对Bean对象管理的一些数据准备工作，也就是初始化工作，目前的BeanDefginiton中包含的就是一些静态的配置信息，Bean的实例化还没有进行，这个实例化的过程是在依赖注入时候完成的。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring源码系列：BeanDefinition载入(上)</title>
      <link href="/2018/11/10/springbase4/"/>
      <url>/2018/11/10/springbase4/</url>
      
        <content type="html"><![CDATA[<div class="output_wrapper" id="output_wrapper_id" style="font-size: 16px; color: rgb(62, 62, 62); line-height: 1.6; word-spacing: 0px; letter-spacing: 0px; font-family: 'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', Arial, sans-serif;"><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">继上一篇BeanFactory的创建之后，其实就是BeanDefinition载入了。同样也是在AbstractRefreshableApplicationContext类的refreshBeanFactory方法中完成：</p><br><pre style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><code class="java language-java hljs" style="margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; color: rgb(169, 183, 198); background: rgb(40, 43, 46); overflow-x: auto; padding: 0.5em; display: block !important; word-wrap: normal !important; word-break: normal !important; white-space: pre !important; overflow: auto !important;"><span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//创建默认的DefaultListableBeanFactory工厂</span><br>DefaultListableBeanFactory beanFactory = createBeanFactory();<br><span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//设置Id</span><br>beanFactory.setSerializationId(getId());<br><span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//这个方法其实就是设置了allowBeanDefinitionOverriding和allowCircularReferences两个属性</span><br>customizeBeanFactory(beanFactory);<br><br><span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//调用子类的加载bean定义方法，这里会调用XmlWebApplicationContext子类的复写方法</span><br>loadBeanDefinitions(beanFactory);<br></code></pre><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">这里的loadBeanDefinitions也是一个抽象方法，AbstractRefreshableApplicationContext类中并没有给出具体的实现，二是通过子类XmlWebApplicationContext的loadBeanDefinitions完成具体实现。</p><br><pre style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><code class="java language-java hljs" style="margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; color: rgb(169, 183, 198); background: rgb(40, 43, 46); overflow-x: auto; padding: 0.5em; display: block !important; word-wrap: normal !important; word-break: normal !important; white-space: pre !important; overflow: auto !important;"><span class="hljs-function" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;"><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">protected</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">void</span> <span class="hljs-title" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(165, 218, 45); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">loadBeanDefinitions</span><span class="hljs-params" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(255, 152, 35); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">(DefaultListableBeanFactory beanFactory)</span> <br>        <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">throws</span> BeansException, IOException </span>{<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//创建XmlBeanDefinitionReader，并通过回调设置到BeanFactory中</span><br>    XmlBeanDefinitionReader beanDefinitionReader = <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">new</span> XmlBeanDefinitionReader(beanFactory);<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//为XmlBeanDefinitionReader配置Environment</span><br>    beanDefinitionReader.setEnvironment(getEnvironment());<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//为XmlBeanDefinitionReader配置ResourceLoader，</span><br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//因为DefaultResourceLoader是父类，所以this可以直接被使用</span><br>    beanDefinitionReader.setResourceLoader(<span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>);<br>    beanDefinitionReader.setEntityResolver(<span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">new</span> ResourceEntityResolver(<span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>));<br><br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">// 允许子类提供reader的自定义初始化，然后继续实际加载bean定义。</span><br>    initBeanDefinitionReader(beanDefinitionReader);<br>    loadBeanDefinitions(beanDefinitionReader);<br>}<br></code></pre><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">initBeanDefinitionReader初始化用于加载此上下文的bean定义的bean定义读取器；默认实现是空的。然后下面通过重载的loadBeanDefinitions来做具体的bean解析（这里用到的是XmlBeanDefinitionReader这个解析器）；使用给定的XmlBeanDefinitionReader加载bean definitions。</p><br><pre style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><code class="java language-java hljs" style="margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; color: rgb(169, 183, 198); background: rgb(40, 43, 46); overflow-x: auto; padding: 0.5em; display: block !important; word-wrap: normal !important; word-break: normal !important; white-space: pre !important; overflow: auto !important;"><span class="hljs-function" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;"><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">protected</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">void</span> <span class="hljs-title" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(165, 218, 45); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">loadBeanDefinitions</span><span class="hljs-params" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(255, 152, 35); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">(XmlBeanDefinitionReader reader)</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">throws</span> IOException </span>{<br>    String[] configLocations = getConfigLocations();<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//遍历xml文件</span><br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (configLocations != <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">null</span>) {<br>        <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">for</span> (String configLocation : configLocations) {<br>            reader.loadBeanDefinitions(configLocation);<br>        }<br>    }<br>}<br></code></pre><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">此时会将我们的applicationContext.xml读入（当然如何还有其他的spring配置文件，同样会一块拿到路径），如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/1/30/1614658d1b8432d5?w=651&amp;h=156&amp;f=png&amp;s=74598" alt="" style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;"><br>然后继续通过loadBeanDefinitions的重载方法继续委托调用。最后交给AbstractBeanDefinitionReader的loadBeanDefinitions来完成；这个代码比较长，拆开一步一步来说，先看下整体的：</p><br><pre style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><code class="java language-java hljs" style="margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; color: rgb(169, 183, 198); background: rgb(40, 43, 46); overflow-x: auto; padding: 0.5em; display: block !important; word-wrap: normal !important; word-break: normal !important; white-space: pre !important; overflow: auto !important;"><span class="hljs-function" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;"><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">public</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">int</span> <span class="hljs-title" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(165, 218, 45); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">loadBeanDefinitions</span><span class="hljs-params" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(255, 152, 35); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">(String location, Set&lt;Resource&gt; actualResources)</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">throws</span> BeanDefinitionStoreException </span>{<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//获取ResourceLoader资源定位器</span><br>    ResourceLoader resourceLoader = getResourceLoader();<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//如果定位器为null，则抛出异常</span><br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (resourceLoader == <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">null</span>) {<br>        <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">throw</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">new</span> BeanDefinitionStoreException(<br>                <span class="hljs-string" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(238, 220, 112); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">“Cannot import bean definitions from location [“</span> + location + <span class="hljs-string" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(238, 220, 112); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">“]: no ResourceLoader available”</span>);<br>    }<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//是否是ResourcePatternResolver类型的定位器</span><br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (resourceLoader <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">instanceof</span> ResourcePatternResolver) {<br>        <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">// Resource pattern matching available.</span><br>        <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">try</span> {<br>            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);<br>            <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">int</span> loadCount = loadBeanDefinitions(resources);<br>            <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (actualResources != <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">null</span>) {<br>                <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">for</span> (Resource resource : resources) {<br>                    actualResources.add(resource);<br>                }<br>            }<br>            <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (logger.isDebugEnabled()) {<br>                logger.debug(<span class="hljs-string" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(238, 220, 112); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">“Loaded “</span> + loadCount + <span class="hljs-string" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(238, 220, 112); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">“ bean definitions from location pattern [“</span> + location + <span class="hljs-string" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(238, 220, 112); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">“]”</span>);<br>            }<br>            <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">return</span> loadCount;<br>        }<br>        <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">catch</span> (IOException ex) {<br>            <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">throw</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">new</span> BeanDefinitionStoreException(<br>                    <span class="hljs-string" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(238, 220, 112); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">“Could not resolve bean definition resource pattern [“</span> + location + <span class="hljs-string" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(238, 220, 112); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">“]”</span>, ex);<br>        }<br>    }<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//非ResourcePatternResolver类型的</span><br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">else</span> {<br>        <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">// Can only load single resources by absolute URL.</span><br>        Resource resource = resourceLoader.getResource(location);<br>        <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">int</span> loadCount = loadBeanDefinitions(resource);<br>        <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (actualResources != <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">null</span>) {<br>            actualResources.add(resource);<br>        }<br>        <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (logger.isDebugEnabled()) {<br>            logger.debug(<span class="hljs-string" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(238, 220, 112); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">“Loaded “</span> + loadCount + <span class="hljs-string" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(238, 220, 112); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">“ bean definitions from location [“</span> + location + <span class="hljs-string" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(238, 220, 112); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">“]”</span>);<br>        }<br>        <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">return</span> loadCount;<br>    }<br>}<br></code></pre><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;"><code style="font-size: inherit; line-height: inherit; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(233, 105, 0); background: rgb(248, 248, 248);">上面的代码中需要说明下为什么要判断当前resourceLoader是否是ResourcePatternResolver类型的，因为ResourceLoader只是提供了对classpath前缀的支持。而ResourcePatternResolver提供了对classpath<em>前缀的支持。也就是说ResourceLoader提供classpath下单资源文件的载入，而ResourcePatternResolver提供多资源文件的载入。</em></code><br>先看下假如是ResourcePatternResolver类型的（略去了部分log代码）：</p><br><pre style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><code class="java language-java hljs" style="margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; color: rgb(169, 183, 198); background: rgb(40, 43, 46); overflow-x: auto; padding: 0.5em; display: block !important; word-wrap: normal !important; word-break: normal !important; white-space: pre !important; overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">try</span> {<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//先得到我们的resources</span><br>    Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//解析并返回beanDefinition的数量</span><br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">int</span> loadCount = loadBeanDefinitions(resources);<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//加载过程中已经被解析过的实际的Resource的填充集合</span><br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (actualResources != <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">null</span>) {<br>        <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">for</span> (Resource resource : resources) {<br>            actualResources.add(resource);<br>        }<br>    }<br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">return</span> loadCount;<br>}<br><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">catch</span> (IOException ex) {<br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">throw</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">new</span> BeanDefinitionStoreException(<br>        <span class="hljs-string" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(238, 220, 112); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">“Could not resolve bean definition resource pattern [“</span> + location + <span class="hljs-string" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(238, 220, 112); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">“]”</span>, ex);<br>}<br></code></pre><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">非ResourcePatternResolver类型情况：</p><br><pre style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><code class="java language-java hljs" style="margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; color: rgb(169, 183, 198); background: rgb(40, 43, 46); overflow-x: auto; padding: 0.5em; display: block !important; word-wrap: normal !important; word-break: normal !important; white-space: pre !important; overflow: auto !important;"><span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">// Can only load single resources by absolute URL.</span><br><span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//只能通过绝对URL加载单个资源</span><br>Resource resource = resourceLoader.getResource(location);<br><span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//解析并返回beanDefinition的数量</span><br><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">int</span> loadCount = loadBeanDefinitions(resource);<br><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (actualResources != <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">null</span>) {<br>    actualResources.add(resource);<br>}<br><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">return</span> loadCount;<br></code></pre><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">然后继续通过重载方法loadBeanDefinitions(Resource… resources)来解析（AbstractBeanDefinitionReader类中）</p><br><pre style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><code class="java language-java hljs" style="margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; color: rgb(169, 183, 198); background: rgb(40, 43, 46); overflow-x: auto; padding: 0.5em; display: block !important; word-wrap: normal !important; word-break: normal !important; white-space: pre !important; overflow: auto !important;"><span class="hljs-function" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;"><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">public</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">int</span> <span class="hljs-title" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(165, 218, 45); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">loadBeanDefinitions</span><span class="hljs-params" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(255, 152, 35); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">(Resource… resources)</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">throws</span> BeanDefinitionStoreException </span>{<br>    Assert.notNull(resources, <span class="hljs-string" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(238, 220, 112); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">“Resource array must not be null”</span>);<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//初始化beanDefiniton个数</span><br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">int</span> counter = <span class="hljs-number" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(174, 135, 250); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">0</span>;<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//遍历当前资源数组</span><br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">for</span> (Resource resource : resources) {<br>        <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//解析具体resource中的bean</span><br>        counter += loadBeanDefinitions(resource);<br>    }<br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">return</span> counter;<br>}<br></code></pre><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">然后交给子类XmlBeanDefinitionReader中的loadBeanDefinitions(Resource resource)方法：</p><br><pre style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><code class="java language-java hljs" style="margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; color: rgb(169, 183, 198); background: rgb(40, 43, 46); overflow-x: auto; padding: 0.5em; display: block !important; word-wrap: normal !important; word-break: normal !important; white-space: pre !important; overflow: auto !important;"><span class="hljs-function" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;"><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">public</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">int</span> <span class="hljs-title" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(165, 218, 45); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">loadBeanDefinitions</span><span class="hljs-params" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(255, 152, 35); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">(Resource resource)</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">throws</span> BeanDefinitionStoreException </span>{<br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">return</span> loadBeanDefinitions(<span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">new</span> EncodedResource(resource));<br>}<br></code></pre><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">继续通过重载方法loadBeanDefinitions(EncodedResource encodedResource)执行，这个方法我们只关注最核心的代码：</p><br><pre style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><code class="java language-java hljs" style="margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; color: rgb(169, 183, 198); background: rgb(40, 43, 46); overflow-x: auto; padding: 0.5em; display: block !important; word-wrap: normal !important; word-break: normal !important; white-space: pre !important; overflow: auto !important;"><span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//获取输入流</span><br>InputStream inputStream = encodedResource.getResource().getInputStream();<br><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">try</span> {<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//资源读取inputSource</span><br>    InputSource inputSource = <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">new</span> InputSource(inputStream);<br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (encodedResource.getEncoding() != <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">null</span>) {<br>        inputSource.setEncoding(encodedResource.getEncoding());<br>    }<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//委托给doLoadBeanDefinitions来完成</span><br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());<br>}<br><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">finally</span> {<br>    inputStream.close();<br>}<br></code></pre><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">doLoadBeanDefinitions是XmlBeanDefinitionReader中的方法，来看核心代码：</p><br><pre style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><code class="java language-java hljs" style="margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; color: rgb(169, 183, 198); background: rgb(40, 43, 46); overflow-x: auto; padding: 0.5em; display: block !important; word-wrap: normal !important; word-break: normal !important; white-space: pre !important; overflow: auto !important;"><span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//解析成符合w3c标准的Document</span><br>Document doc = doLoadDocument(inputSource, resource);<br><span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//继续交给registerBeanDefinitions来处理</span><br><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">return</span> registerBeanDefinitions(doc, resource);<br></code></pre><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">这个时候已经将loadBeanDefinitions换成registerBeanDefinitions了，也就是载入并注册；registerBeanDefinitions同样也是XmlBeanDefinitionReader中的方法：</p><br><pre style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><code class="java language-java hljs" style="margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; color: rgb(169, 183, 198); background: rgb(40, 43, 46); overflow-x: auto; padding: 0.5em; display: block !important; word-wrap: normal !important; word-break: normal !important; white-space: pre !important; overflow: auto !important;"><span class="hljs-function" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;"><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">public</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">int</span> <span class="hljs-title" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(165, 218, 45); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">registerBeanDefinitions</span><span class="hljs-params" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(255, 152, 35); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">(Document doc, Resource resource)</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">throws</span><br>BeanDefinitionStoreException </span>{<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//得到documentReader用来读取document文档</span><br>    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//注册之前的bean个数</span><br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">int</span> countBefore = getRegistry().getBeanDefinitionCount();<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//解析并注册bean</span><br>    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));<br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">return</span> getRegistry().getBeanDefinitionCount() - countBefore;<br>}<br></code></pre><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">仍然没有处理，继续交给<code style="font-size: inherit; line-height: inherit; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(233, 105, 0); background: rgb(248, 248, 248);">BeanDefinitionDocumentReader</code>的registerBeanDefinitions方法来完成：</p><br><pre style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><code class="java language-java hljs" style="margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; color: rgb(169, 183, 198); background: rgb(40, 43, 46); overflow-x: auto; padding: 0.5em; display: block !important; word-wrap: normal !important; word-break: normal !important; white-space: pre !important; overflow: auto !important;"><span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//这个实现根据“spring-beans”XSD（或DTD）解析bean定义。</span><br><span class="hljs-function" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;"><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">public</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">void</span> <span class="hljs-title" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(165, 218, 45); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">registerBeanDefinitions</span><span class="hljs-params" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(255, 152, 35); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">(Document doc, XmlReaderContext readerContext)</span> </span>{<br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>.readerContext = readerContext;<br>    logger.debug(<span class="hljs-string" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(238, 220, 112); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">“Loading bean definitions”</span>);<br>    Element root = doc.getDocumentElement();<br>    doRegisterBeanDefinitions(root);<br>}<br></code></pre><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">还是没处理，又细化一步，交给<code style="font-size: inherit; line-height: inherit; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(233, 105, 0); background: rgb(248, 248, 248);">DefaultBeanDefinitionDocumentReader</code>的doRegisterBeanDefinitions(Element root)方法：</p><br><pre style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><code class="java language-java hljs" style="margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; color: rgb(169, 183, 198); background: rgb(40, 43, 46); overflow-x: auto; padding: 0.5em; display: block !important; word-wrap: normal !important; word-break: normal !important; white-space: pre !important; overflow: auto !important;"><span class="hljs-function" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;"><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">protected</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">void</span> <span class="hljs-title" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(165, 218, 45); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">doRegisterBeanDefinitions</span><span class="hljs-params" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(255, 152, 35); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">(Element root)</span> </span>{<br>    BeanDefinitionParserDelegate parent = <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>.delegate;<br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>.delegate = createDelegate(getReaderContext(), root, parent);<br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (<span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>.delegate.isDefaultNamespace(root)) {<br>        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);<br>        <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (StringUtils.hasText(profileSpec)) {<br>            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(<br>                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);<br>            <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {<br>                <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (logger.isInfoEnabled()) {<br>                    logger.info(<span class="hljs-string" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(238, 220, 112); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">“Skipped XML bean definition file due to specified profiles [“</span> + profileSpec +<br>                            <span class="hljs-string" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(238, 220, 112); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">“] not matching: “</span> + getReaderContext().getResource());<br>                }<br>                <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">return</span>;<br>            }<br>        }<br>    }<br>    preProcessXml(root);<br>    parseBeanDefinitions(root, <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>.delegate);<br>    postProcessXml(root);<br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">this</span>.delegate = parent;<br>}<br></code></pre><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;"><code style="font-size: inherit; line-height: inherit; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(233, 105, 0); background: rgb(248, 248, 248);">任何嵌套的&lt;beans&gt;元素都将导致此方法的递归。 为了正确传播和保存&lt;beans&gt; default- 属性，请跟踪当前（父）委托，该委托可能为null。 为了回退的目的，创建一个引用父对象的新（子）委托，然后最终重置this.delegate回到它的原始（父）引用。这个行为模仿了一堆委托，而实际上并不需要一个委托。（翻译的有点蹩脚，大概意思就是这）</code></p><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">所以说<code style="font-size: inherit; line-height: inherit; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(233, 105, 0); background: rgb(248, 248, 248);">DefaultBeanDefinitionDocumentReader</code>自己也没干这事，又给了<code style="font-size: inherit; line-height: inherit; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(233, 105, 0); background: rgb(248, 248, 248);">BeanDefinitionParserDelegate</code>，然后就是preProcessXml()、parseBeanDefinitions()、postProcessXml()方法；其中preProcessXml()和postProcessXml()默认是空方法，自己没有实现。具体解析在parseBeanDefinitions(root, this.delegate)中完成。</p><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;"><code style="font-size: inherit; line-height: inherit; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(233, 105, 0); background: rgb(248, 248, 248);">BeanDefinitionParserDelegate</code>用于将<code style="font-size: inherit; line-height: inherit; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(233, 105, 0); background: rgb(248, 248, 248);"> Document</code> 的内容转成 <code style="font-size: inherit; line-height: inherit; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(233, 105, 0); background: rgb(248, 248, 248);">BeanDefinition</code>实例；<code style="font-size: inherit; line-height: inherit; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(233, 105, 0); background: rgb(248, 248, 248);">BeanDefinitionDocumentReader</code> 本身不具备该功能而是交给了该类来完成。</p><br><pre style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><code class="java language-java hljs" style="margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; color: rgb(169, 183, 198); background: rgb(40, 43, 46); overflow-x: auto; padding: 0.5em; display: block !important; word-wrap: normal !important; word-break: normal !important; white-space: pre !important; overflow: auto !important;"><span class="hljs-function" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;"><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">protected</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">void</span> <span class="hljs-title" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(165, 218, 45); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">parseBeanDefinitions</span><span class="hljs-params" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(255, 152, 35); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>{<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//查看定义的命名空间是否为默认的命名空间</span><br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (delegate.isDefaultNamespace(root)) {<br>        NodeList nl = root.getChildNodes();<br>        <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">for</span> (<span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">int</span> i = <span class="hljs-number" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(174, 135, 250); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">0</span>; i &lt; nl.getLength(); i++) {<br>            Node node = nl.item(i);<br>            <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (node <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">instanceof</span> Element) {<br>                Element ele = (Element) node;<br>                <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (delegate.isDefaultNamespace(ele)) {<br>                    parseDefaultElement(ele, delegate);<br>                }<br>                <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">else</span> {<br>                    delegate.parseCustomElement(ele);<br>                }<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">else</span> {<br>        delegate.parseCustomElement(root);<br>    }<br>}<br></code></pre><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">这个方法就是解析文档中根目录下的元素：“import”，“alias”，“bean”。</p><br><pre style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><code class="java language-java hljs" style="margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; color: rgb(169, 183, 198); background: rgb(40, 43, 46); overflow-x: auto; padding: 0.5em; display: block !important; word-wrap: normal !important; word-break: normal !important; white-space: pre !important; overflow: auto !important;"><span class="hljs-function" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;"><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">private</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">void</span> <span class="hljs-title" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(165, 218, 45); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">parseDefaultElement</span><span class="hljs-params" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(255, 152, 35); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>{<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//解析一个“import”元素，并将给定资源的bean定义加载到bean工厂中。</span><br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {<br>        importBeanDefinitionResource(ele);<br>    }<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//处理给定的别名元素，向注册表注册别名。</span><br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">else</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {<br>        processAliasRegistration(ele);<br>    }<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//处理给定的bean元素，解析bean定义并将其注册到注册表中。</span><br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">else</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {<br>        processBeanDefinition(ele, delegate);<br>    }<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//在给定的根&lt;beans /&gt;元素内注册每个bean定义。</span><br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">else</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {<br>        <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">// recurse</span><br>        doRegisterBeanDefinitions(ele);<br>    }<br>}<br></code></pre><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">先来看<code style="font-size: inherit; line-height: inherit; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(233, 105, 0); background: rgb(248, 248, 248);">processBeanDefinition</code>这个方法；</p><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;"><code style="font-size: inherit; line-height: inherit; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(233, 105, 0); background: rgb(248, 248, 248);">BeanDefinitionHolder是一个BeanDefinition的持有者，其定义了一下变量，并对以下变量提供get和set操作。这个在后面的说道BeanDefinition体系的时候再聊。</code></p><br><pre style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><code class="java language-java hljs" style="margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; color: rgb(169, 183, 198); background: rgb(40, 43, 46); overflow-x: auto; padding: 0.5em; display: block !important; word-wrap: normal !important; word-break: normal !important; white-space: pre !important; overflow: auto !important;"><span class="hljs-function" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;"><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">protected</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">void</span> <span class="hljs-title" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(165, 218, 45); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">processBeanDefinition</span><span class="hljs-params" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(255, 152, 35); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>{<br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//获取一个BeanDefinitionHolder</span><br>    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);<br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (bdHolder != <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">null</span>) {<br>        <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//首先根据自定义属性进行装饰。</span><br>        <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">//基于自定义嵌套元素进行装饰。</span><br>        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);<br>        <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">try</span> {<br>            <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">// 注册最终装饰的实例。</span><br>            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder,<br>            getReaderContext().getRegistry());<br>        }<br>        <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">catch</span> (BeanDefinitionStoreException ex) {<br>            getReaderContext().error(<span class="hljs-string" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(238, 220, 112); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">“Failed to register bean definition with name ‘“</span> +<br>                    bdHolder.getBeanName() + <span class="hljs-string" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(238, 220, 112); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">“‘“</span>, ele, ex);<br>        }<br>        <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">// 发送注册事件。</span><br>        getReaderContext().fireComponentRegistered(<span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">new</span> BeanComponentDefinition(bdHolder));<br>    }<br>}<br></code></pre><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">接着看<code style="font-size: inherit; line-height: inherit; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(233, 105, 0); background: rgb(248, 248, 248);">registerBeanDefinition</code>这个方法：通过给定的bean工厂注册给定的bean definition 。</p><br><pre style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><code class="java language-java hljs" style="margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; color: rgb(169, 183, 198); background: rgb(40, 43, 46); overflow-x: auto; padding: 0.5em; display: block !important; word-wrap: normal !important; word-break: normal !important; white-space: pre !important; overflow: auto !important;"><span class="hljs-function" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;"><span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">public</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">static</span> <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">void</span> <span class="hljs-title" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(165, 218, 45); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">registerBeanDefinition</span><span class="hljs-params" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(255, 152, 35); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">(<br>    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span><br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">throws</span> BeanDefinitionStoreException </span>{<br><br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">// 在主名称下注册bean定义。</span><br>    String beanName = definitionHolder.getBeanName();<br>    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());<br><br>    <span class="hljs-comment" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(128, 128, 128); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">// 如果有的话，注册bean名称的别名，</span><br>    String[] aliases = definitionHolder.getAliases();<br>    <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">if</span> (aliases != <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">null</span>) {<br>        <span class="hljs-keyword" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(248, 35, 117); word-wrap: inherit !important; word-break: inherit !important; white-space: inherit !important;">for</span> (String alias : aliases) {<br>            registry.registerAlias(beanName, alias);<br>        }<br>    }<br>}<br></code></pre><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;"><code style="font-size: inherit; line-height: inherit; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(233, 105, 0); background: rgb(248, 248, 248);">registerBeanDefinition</code>里面又通过调用<code style="font-size: inherit; line-height: inherit; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(233, 105, 0); background: rgb(248, 248, 248);">BeanDefinitionRegistry</code>接口的实现<code style="font-size: inherit; line-height: inherit; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(233, 105, 0); background: rgb(248, 248, 248);">DefaultListableBeanFactory</code>来完成具体的注册过程。关于<code style="font-size: inherit; line-height: inherit; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(233, 105, 0); background: rgb(248, 248, 248);">DefaultListableBeanFactory</code>中<code style="font-size: inherit; line-height: inherit; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(233, 105, 0); background: rgb(248, 248, 248);">registerBeanDefinition</code>方法的解析逻辑将在<a href="https://juejin.im/post/5a73c4d3f265da4e7a78266c" style="font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; text-decoration: none; color: rgb(30, 107, 184); word-wrap: break-word;" target="_blank" rel="noopener">Spring源码系列：BeanDefinition载入(下)</a>中来说.</p><br><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;"><img src="https://user-gold-cdn.xitu.io/2018/1/31/1614ae324122a7ac?w=258&amp;h=258&amp;f=jpeg&amp;s=27558" alt="" style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;"><br><code style="font-size: inherit; line-height: inherit; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(233, 105, 0); background: rgb(248, 248, 248);">欢迎关注微信公众号</code></p></div>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring源码系列：BeanFactory的创建</title>
      <link href="/2018/11/10/springbase3/"/>
      <url>/2018/11/10/springbase3/</url>
      
        <content type="html"><![CDATA[<p>Spring的Ioc容器其实就是一个bean的关系网，依赖于core，bean，context三个组件来构建的。在spring中最核心的就是对于bean的管理。而bean又依托于我们的容器。本文将从顶层分析一下spring中beanFactory的具体创建过程，为后续的bean的生命周期提供一个基础。</p><p><strong>BeanFactory的继承体系</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/1/29/16141a440ba09c49?w=1249&amp;h=708&amp;f=png&amp;s=25412" alt=""><br>从上图可以看到，BeanFactory有三个子类：</p><ul><li>ListableBeanFactory</li><li>HierarchicalBeanFactory</li><li>AutowireCapableBeanFactory</li></ul><p><em>（上述三个类的子类体系小伙伴们可以自己对着源码看下，实在太多）</em></p><p>看下上图中最底层的DefaultListableBeanFactory类的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractAutowireCapableBeanFactory</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ConfigurableListableBeanFactory</span>, <span class="title">BeanDefinitionRegistry</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></p><p>这个其实就是BeanFactory的默认实现类，它直接或者间接的实现了所有的接口。其实在看spring源码的时候都会遇到类似的设计模式，对于某一个具体的功能，通常都会定义很多层的接口，层层包装，层层委托。这种做法的好处就是，对于不同的场合都会有特定的接口；这样一来就可以在spring内部对对象的传递和转化操作都会有一些访问限制。</p><p>例如ListableBeanFactory接口表示这些Bean是可列表的，而HierarchicalBeanFactory表示的是这些Bean是有继承关系的，也就是每个Bean有可能有父Bean。AutowireCapableBeanFactory接口定义Bean的自动装配规则。这四个接口共同定义了Bean的集合、Bean之间的关系、以及Bean行为。</p><p><strong>BeanFactory的创建</strong></p><p>在之前的文章中说过了容器的刷新过程。BeanFactory的创建也在wac.refresh()方法中。具体看下到底是通过哪些子类来完成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通知子类刷新内部的bean工厂。</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br></pre></td></tr></table></figure><p><strong><em>1.AbstractApplicationContext中的obtainFreshBeanFactory</em></strong></p><p>下面是obtainFreshBeanFactory的方法逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个是具体创建的方法，由子类实现</span></span><br><span class="line">refreshBeanFactory();</span><br><span class="line"><span class="comment">//获取BeanFactory实例对象（ConfigurableListableBeanFactory类型的）</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>refreshBeanFactory并未有具体的实现逻辑，这个方法主要是通过委托给子类的refreshBeanFactory方法来实现，在AbstractApplicationContext中refreshBeanFactory是一个抽象模板方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;</span><br></pre></td></tr></table></figure><p><strong><em>2.refreshBeanFactory方法(AbstractRefreshableApplicationContext类中)：</em></strong></p><p><code>下面只注释与beanFactory创建相关的代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">//是否已经有BeanFactory了</span></span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        <span class="comment">//销毁原有的Bean</span></span><br><span class="line">    destroyBeans();</span><br><span class="line">    <span class="comment">//关闭工厂</span></span><br><span class="line">    closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个新的beanFactory</span></span><br><span class="line">    DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">    beanFactory.setSerializationId(getId());</span><br><span class="line">    customizeBeanFactory(beanFactory);</span><br><span class="line">    loadBeanDefinitions(beanFactory);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition </span></span><br><span class="line"><span class="string">    source for "</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是实现执行这个上下文的底层bean工厂的实际刷新，如果有的话之前有BeanFactory存在，则关闭以前的bean工厂。并为上下文生命周期的下一个阶段初始化一个新鲜的bean工厂。</p><p><strong><em>3.createBeanFactory(AbstractRefreshableApplicationContext类中)</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DefaultListableBeanFactory <span class="title">createBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DefaultListableBeanFactory(getInternalParentBeanFactory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就是为当前上下文创建一个内部的bean工厂。每次调用refresh()方法是都会创建尝试创建。默认实现是创建一个DefaultListableBeanFactory。并通过getInternalParentBeanFactory（）获取内部bean工厂来作为父级bean工厂。可以在子类中重写，例如自定义DefaultListableBeanFactory的设置。</p><p><strong><em>getInternalParentBeanFactory（AbstractApplicationContext类中）</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanFactory <span class="title">getInternalParentBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (getParent() <span class="keyword">instanceof</span> ConfigurableApplicationContext) ?</span><br><span class="line">((ConfigurableApplicationContext) getParent()).getBeanFactory() : getParent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>4.DefaultListableBeanFactory的构造函数</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过给定的父类创建一个新的DefaultListableBeanFactory容器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentBeanFactory the parent BeanFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultListableBeanFactory</span><span class="params">(BeanFactory parentBeanFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(parentBeanFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>super(parentBeanFactory)调用的是AbstractAutowireCapableBeanFactory的构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过给定的父类构建新的AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentBeanFactory parent bean factory, or &#123;<span class="doctag">@code</span> null&#125; if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractAutowireCapableBeanFactory</span><span class="params">(BeanFactory parentBeanFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>();</span><br><span class="line"><span class="comment">//设置父工厂</span></span><br><span class="line">setParentBeanFactory(parentBeanFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>this(),还是AbstractAutowireCapableBeanFactory的构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建一个新的AbstractAutowireCapableBeanFactory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractAutowireCapableBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">ignoreDependencyInterface(BeanNameAware.class);</span><br><span class="line">ignoreDependencyInterface(BeanFactoryAware.class);</span><br><span class="line">ignoreDependencyInterface(BeanClassLoaderAware.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>super()  ;     AbstractBeanFactory的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建一个新的AbstractBeanFactory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring源码系列：BeanDefinition 源码解析</title>
      <link href="/2018/11/10/springbase2/"/>
      <url>/2018/11/10/springbase2/</url>
      
        <content type="html"><![CDATA[<p>Bean的定义主要由BeanDefinition来描述的。作为Spring中用于包装Bean的数据结构，今天就来看看它的面纱下的真容吧。</p><p>首先就是BeanDefinition的类定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinition</span> <span class="keyword">extends</span> <span class="title">AttributeAccessor</span>, <span class="title">BeanMetadataElement</span></span></span><br></pre></td></tr></table></figure></p><p>对，没错，这货是个接口，而不是类，是不是有点莫名奇妙呢？我们都知道在JAVA中，接口是不能用来new出新的对象的，那么在Spring中，到底将XML解析出来的Bean包装成了什么呢？（这个密等下揭开）</p><p>先来看看BeanDefinition一个继承结构吧（均是与BeanDefinition有直接关联的类或者接口）！</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/20/16112753255accae?w=1064&amp;h=428&amp;f=png&amp;s=237675" alt=""><br>从类图中可以看出，BeanDefinition继承了AttributeAccessor和BeanMetadataElement两个接口；一个一个看。</p><p><strong>AttributeAccessor</strong></p><p>AttributeAccessor接口定义了最基本的对任意对象的元数据的修改或者获取，主要方法有：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将name定义的属性设置为提供的value值。如果value的值为null，则该属性为&#123;@link #removeAttribute removed&#125;。</span></span><br><span class="line"><span class="comment">//通常，用户应该注意通过使用完全限定的名称（可能使用类或包名称作为前缀）来防止与其他元数据属性重叠。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, Object value)</span></span>;</span><br><span class="line"><span class="comment">//获取标识为name的属性的值。</span></span><br><span class="line"><span class="function">Object <span class="title">getAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="comment">//删除标识为name的属性，并返回属性值</span></span><br><span class="line"><span class="function">Object <span class="title">removeAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="comment">//如果名为name的属性是否存在，存在返回true，否则返回false。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="comment">//返回所有属性的名称。</span></span><br><span class="line">String[] attributeNames();</span><br></pre></td></tr></table></figure></p><p><strong>BeanMetadataElement</strong></p><p>BeanMetadataElement接口提供了一个getResource()方法,用来传输一个可配置的源对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回此元数据元素的配置源对象（可能为null）。</span></span><br><span class="line"><span class="function">Object <span class="title">getSource</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="BeanDifinition源码分析"><a href="#BeanDifinition源码分析" class="headerlink" title="BeanDifinition源码分析"></a>BeanDifinition源码分析</h2><p>一个BeanDefinition描述了一个bean的实例，包括属性值，构造方法参数值和继承自它的类的更多信息。BeanDefinition仅仅是一个最简单的接口，主要功能是允许BeanFactoryPostProcessor 例如PropertyPlaceHolderConfigure 能够检索并修改属性值和别的bean的元数据（译注）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标准单例作用域的作用域标识符：“singleton”。</span></span><br><span class="line"><span class="comment">//对于扩展的bean工厂可能支持更多的作用域。</span></span><br><span class="line">String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标准原型作用域的范围标识符：“prototype”。</span></span><br><span class="line"><span class="comment">//对于扩展的bean工厂可能支持更多的作用域。</span></span><br><span class="line">String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示BeanDefinition是应用程序主要部分的角色提示。 通常对应于用户定义的bean。</span></span><br><span class="line"><span class="keyword">int</span> ROLE_APPLICATION = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>ROLE_SUPPORT =1实际上就是说，我这个Bean是用户的，是从配置文件中过来的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示BeanDefinition是某些大型配置的支持部分的角色提示，通常是一个外部ComponentDefinition。</span></span><br><span class="line"><span class="comment">//当查看某个特定的ComponentDefinition时，认为bean非常重要，</span></span><br><span class="line"><span class="comment">//以便在查看应用程序的整体配置时能够意识到这一点。</span></span><br><span class="line"><span class="keyword">int</span> ROLE_SUPPORT = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>ROLE_INFRASTRUCTURE = 2就是我这Bean是Spring自己的，和你用户没有一毛钱关系。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//角色提示表明一个BeanDefinition是提供一个完全背景的角色，并且与最终用户没有关系。</span></span><br><span class="line"><span class="comment">//这个提示用于注册完全是ComponentDefinition内部工作的一部分的bean</span></span><br><span class="line"><span class="keyword">int</span> ROLE_INFRASTRUCTURE = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p>上面是BeanDifinition的一些基本属性信息，一个就是标识下当前Bean的作用域，另外就是标识一下这个Bean是内部的还是外部的。下面来看这个接口为其子类都提供了哪些具体的行为方法：</p><p>1.当前Bean父类名称get&amp;set方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果父类存在，设置这个bean定义的父定义的名称。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setParentName</span><span class="params">(String parentName)</span></span>;</span><br><span class="line"><span class="comment">//如果父类存在，则返回当前Bean的父类的名称</span></span><br><span class="line"><span class="function">String <span class="title">getParentName</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>2.当前Bean的className  get&amp;set方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定此bean定义的bean类名称。</span></span><br><span class="line"><span class="comment">//类名称可以在bean factory后期处理中修改，通常用它的解析变体替换原来的类名称。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(String beanClassName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回此bean定义的当前bean类名称。</span></span><br><span class="line"><span class="comment">//需要注意的是，这不一定是在运行时使用的实际类名，以防子类定义覆盖/继承其父类的类名。</span></span><br><span class="line"><span class="comment">//此外，这可能只是调用工厂方法的类，或者它 在调用方法的工厂bean引用的情况下甚至可能是空的。</span></span><br><span class="line"><span class="comment">//因此，不要认为这是在运行时定义的bean类型，而只是将其用于在单独的bean定义级别进行解析。</span></span><br><span class="line"><span class="function">String <span class="title">getBeanClassName</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>3.Bean的作用域get&amp;set方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//覆盖此bean的目标范围，指定一个新的范围名称。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setScope</span><span class="params">(String scope)</span></span>;</span><br><span class="line"><span class="comment">//返回此bean的当前目标作用域的名称，如果没有确定，返回null</span></span><br><span class="line"><span class="function">String <span class="title">getScope</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>4.懒加载的get&amp;set方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置这个bean是否应该被延迟初始化。如果&#123;false&#125;，那么这个bean将在启动时由bean工厂实例化，</span></span><br><span class="line"><span class="comment">//这些工厂执行单例的立即初始化。</span></span><br><span class="line"><span class="comment">//懒加载 &lt;bean lazy-init="true/false"&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLazyInit</span><span class="params">(<span class="keyword">boolean</span> lazyInit)</span></span>;</span><br><span class="line"><span class="comment">//返回这个bean是否应该被延迟初始化，即不是在启动时立即实例化。只适用于单例bean。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isLazyInit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>5.依赖关系设置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置这个bean依赖被初始化的bean的名字。 bean工厂将保证这些bean首先被初始化。</span></span><br><span class="line"><span class="comment">//&lt;bean depends-on=""&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDependsOn</span><span class="params">(String... dependsOn)</span></span>;</span><br><span class="line"><span class="comment">//返回这个bean依赖的bean名称。</span></span><br><span class="line">String[] getDependsOn();</span><br></pre></td></tr></table></figure></p><p>6.是否是自动转配设置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置这个bean是否是获得自动装配到其他bean的候选人。</span></span><br><span class="line"><span class="comment">//需要注意是，此标志旨在仅影响基于类型的自动装配。</span></span><br><span class="line"><span class="comment">//它不会影响按名称的显式引用，即使指定的bean没有标记为autowire候选，也可以解决这个问题。</span></span><br><span class="line"><span class="comment">//因此，如果名称匹配，通过名称的自动装配将注入一个bean。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAutowireCandidate</span><span class="params">(<span class="keyword">boolean</span> autowireCandidate)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回这个bean是否是自动装配到其他bean的候选者。就是是否在其他类中使用autowired来注入当前Bean的</span></span><br><span class="line"><span class="comment">//是否为被自动装配 &lt;bean autowire-candidate="true/false"&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>7.主候选Bean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否为主候选bean    使用注解：@Primary</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPrimary</span><span class="params">(<span class="keyword">boolean</span> primary)</span></span>;</span><br><span class="line"><span class="comment">//返回这个bean是否是主要的autowire候选者。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrimary</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>8.定义创建该Bean对象的工厂类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定要使用的工厂bean（如果有的话）。 这是调用指定的工厂方法的bean的名称。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFactoryBeanName</span><span class="params">(String factoryBeanName)</span></span>;</span><br><span class="line"><span class="comment">//返回工厂bean的名字，如果有的话。</span></span><br><span class="line"><span class="function">String <span class="title">getFactoryBeanName</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>9.创建该Bean对象的工厂方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果有的话，指定工厂方法。</span></span><br><span class="line"><span class="comment">//这个方法先将通过构造函数参数被调用，或者如果参数，将调用该方法的无参数构造。</span></span><br><span class="line"><span class="comment">//方法将在指定的工厂bean（如果有的话）上被调用，或者作为本地bean类的静态方法被调用。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFactoryMethodName</span><span class="params">(String factoryMethodName)</span></span>;</span><br><span class="line"><span class="comment">//如果存在，返回工厂方法名</span></span><br><span class="line"><span class="function">String <span class="title">getFactoryMethodName</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>10.返回此bean的构造函数参数值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回此bean的构造函数参数值。</span></span><br><span class="line"><span class="function">ConstructorArgumentValues <span class="title">getConstructorArgumentValues</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>11.获取普通属性集合<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取普通属性集合</span></span><br><span class="line"><span class="function">MutablePropertyValues <span class="title">getPropertyValues</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>12.当前Bean的基本特性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否是单例的</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//是否是多例的</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//是否是抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAbstract</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>13.当前Bean的应用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取这个bean的应用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRole</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>13.可读描述<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回对bean定义的可读描述。</span></span><br><span class="line"><span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回该bean定义来自的资源的描述</span></span><br><span class="line"><span class="function">String <span class="title">getResourceDescription</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回原始的BeanDefinition;如果没有，则返回null。允许检索装饰的bean定义（如果有的话）。</span></span><br><span class="line"><span class="comment">//注意，这个方法返回直接的发起者。 迭代原始链，找到用户定义的原始BeanDefinition。</span></span><br><span class="line"><span class="function">BeanDefinition <span class="title">getOriginatingBeanDefinition</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>从上面的属性和方法分析可以看出，BeanDefinition对于一个Bean的描述做了较为完整的一套约束。这为后续的子类提供的最基本的职责和属性。</p><p><code>欢迎关注glmapper工作室公众号</code></p><p><img src="https://user-gold-cdn.xitu.io/2018/1/22/1611e1a1e917238c?w=258&amp;h=258&amp;f=jpeg&amp;s=27558" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC系列源码：DispatcherServlet</title>
      <link href="/2018/11/10/spring-base-webmvc3/"/>
      <url>/2018/11/10/spring-base-webmvc3/</url>
      
        <content type="html"><![CDATA[<p>前面两篇文章直接对SpringMVC里面的组件进行了源码分析，可能很多小伙伴都会觉得有点摸不着头脑。所以今天再岔回来说一说SpringMVC的核心控制器，以此为轴心来学习整个SpringMVC的知识体系。</p><h2 id="SpringMVC在项目中如何使用的？"><a href="#SpringMVC在项目中如何使用的？" class="headerlink" title="SpringMVC在项目中如何使用的？"></a>SpringMVC在项目中如何使用的？</h2><p>前面在《<a href="https://juejin.im/post/59f3ef5c51882534aa0691b2" target="_blank" rel="noopener">项目开发框架-SSM</a>》一篇文章中已经详细的介绍过了SSM项目中关于Spring的一些配置文件，对于一个Spring应用，必不可少的是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;param-value&gt;classpath*:config/applicationContext.xml&lt;/param-value&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置一个监听器将请求转发给 Spring框架 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring监听器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过ContextLoadListener来完成Spring容器的初始化以及Bean的装载《<a href="https://juejin.im/post/59a286866fb9a0249d616fbb" target="_blank" rel="noopener">Spring技术内幕学习：Spring的启动过程</a>》。那么如果在我们需要提供WEB功能，则还需要另外一个，那就是SpringMVC,当然我们同样需要一个用来初始化SpringMVC的配置（初始化9大组件的过程：前面两篇《<a href="https://juejin.im/post/5a55791c6fb9a01c975a2025" target="_blank" rel="noopener">SpringMVC源码系列：HandlerMapping</a>》和《<a href="https://juejin.im/post/5a558b1d6fb9a01cbd587b99" target="_blank" rel="noopener">SpringMVC源码系列：AbstractHandlerMapping</a>》是关于HnadlerMapping的，当然不仅仅这两个，还有其他几个重要的子类，后续会持续更新）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mvc-dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置springMVC需要加载的配置文件 spring-dao.xml,spring-service.xml,spring-web.xml </span></span><br><span class="line"><span class="comment">Mybatis（如果有） - &gt; spring -&gt; springmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mvc-dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 默认匹配所有的请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.htm<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们在web.xml中配置好上述内容（当然还得保证咱们的Spring的配置以及SpringMVC的配置文件没有问题的情况下），启动web容器（如jetty），就可以通过在浏览器输入诸如：<a href="http://localhost:80/myproject/index.do" target="_blank" rel="noopener">http://localhost:80/myproject/index.do</a> 的方式来访问我们的应用了。</p><p>俗话说知其然，之气所以然；那么为什么在配置好相关的配置文件之后，我们就能访问我们的SSM项目了呢？从发送一条那样的请求（<a href="http://localhost:80/myproject/index.do）展示出最后的界面，这个过程在，Spring帮我们做了哪些事情呢？（SpringIOC容器的初始化在《[Spring技术内幕-容器刷新：wac.refresh](https://juejin.im/post/5a3f5b43f265da432e5c37ea)》文中已经大概的说了下大家可以参考一下）" target="_blank" rel="noopener">http://localhost:80/myproject/index.do）展示出最后的界面，这个过程在，Spring帮我们做了哪些事情呢？（SpringIOC容器的初始化在《[Spring技术内幕-容器刷新：wac.refresh](https://juejin.im/post/5a3f5b43f265da432e5c37ea)》文中已经大概的说了下大家可以参考一下）</a></p><h2 id="SpringMVC处理请求的过程"><a href="#SpringMVC处理请求的过程" class="headerlink" title="SpringMVC处理请求的过程"></a>SpringMVC处理请求的过程</h2><p>先通过下面这张图来整个了解下SpringMVC请求处理的过程；图中从1-13，大体上描述了请求从发送到界面展示的这样一个过程。<br><img src="https://user-gold-cdn.xitu.io/2018/1/12/160e9cb552fb7aa0?w=935&amp;h=922&amp;f=png&amp;s=48045" alt=""><br>从上面这张图中，我们可以很明显的看到有一个DispatcherServlet这样一个类，处于各个请求处理过程中的分发站。实际上，在SpringMVC中，整个处理过程的顶层设计都在这里面。通常我们将DispatcherServlet称为SpringMVC的前端控制器，它是SpringMVC中最核心的类。下面我们就来揭开DispatcherServlet的面纱吧！</p><h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p>OK，我们直接来看DispatcherServlet的类定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">FrameworkServlet</span></span></span><br></pre></td></tr></table></figure></p><p>DispatcherServlet继承自FrameworkServlet，就这样？<br><img src="https://user-gold-cdn.xitu.io/2018/1/12/160ea3f0d911990e?w=511&amp;h=300&amp;f=jpeg&amp;s=13176" alt=""><br>下面才是他家的族谱：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/12/160ea4067691d914?w=1056&amp;h=691&amp;f=png&amp;s=21550" alt=""></p><p>首先为什么要有绿色的部门，有的同学可能已经想到了，绿色部分不是Spring的，而是java自己的；Spring通过HttpServletBean这位年轻人成功的拥有了JAVA WEB 血统（本来Spring就是用JAVA写的，哈哈）。关于Servlet这个小伙伴可以看下我之前的文章，有简单的介绍了这个接口。</p><p>话说回来，既然DispatcherServlet归根揭底是一个Servlet，那么就肯定具有Servlet功能行为。</p><p><code>敲黑板！！！Servlet的生命周期是啥（init-&gt;service-&gt;destroy ： 加载-&gt;实例化-&gt;服务-&gt;销毁）。</code></p><p>其实这里我想说的就是service这个方法，当然，在DispatcherServlet中并没有service方法，但是它有一个doService方法！（引的好难…）</p><p>doService是DispatcherServlet的入口，我们来看下这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    String resumed = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult() ? <span class="string">" resumed"</span> : <span class="string">""</span>;</span><br><span class="line">    logger.debug(<span class="string">"DispatcherServlet with name '"</span> + getServletName() + <span class="string">"'"</span> + resumed +</span><br><span class="line">    <span class="string">" processing "</span> + request.getMethod() + <span class="string">" request for ["</span> + getRequestUri(request) + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在include的情况下保留请求属性的快照，以便能够在include之后恢复原始属性。</span></span><br><span class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//确定给定的请求是否是包含请求，即不是从外部进入的顶级HTTP请求。</span></span><br><span class="line">    <span class="comment">//检查是否存在“javax.servlet.include.request_uri”请求属性。 可以检查只包含请求中的任何请求属性。</span></span><br><span class="line">    <span class="comment">//(可以看下面关于isIncludeRequest解释)</span></span><br><span class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">    attributesSnapshot = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">    <span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">    String attrName = (String) attrNames.nextElement();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.cleanupAfterInclude || attrName.startsWith(<span class="string">"org.springframework.web.servlet"</span>)) &#123;</span><br><span class="line">    attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使框架可用于handler和view对象。</span></span><br><span class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</span><br><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</span><br><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line">    <span class="comment">//FlashMap用于保存转发请求的参数的</span></span><br><span class="line">    FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">    <span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">    request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">    &#125;</span><br><span class="line">    request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span><br><span class="line">    request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    doDispatch(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">    <span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line">    <span class="keyword">if</span> (attributesSnapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">    restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PS：“javax.servlet.include.request_uri”是INCLUDE_REQUEST_URI_ATTRIBUTE常量的值。isIncludeRequest(request)方法的作用我们可以借助一条JSP的指令来理解：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:incluede page=<span class="string">"index.jsp"</span>/&gt;</span><br></pre></td></tr></table></figure><p><code>这条指令是指在一个页面中嵌套了另一个页面，那么我们知道JSP在运行期间是会被编译成相应的Servlet类来运行的，所以在Servlet中也会有类似的功能和调用语法，这就是RequestDispatch.include()方法。那么在一个被别的servlet使用RequestDispatcher的include方法调用过的servlet中，如果它想知道那个调用它的servlet的上下文信息该怎么办呢，那就可以通过request中的attribute中的如下属性获取：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javax.servlet.include.request_uri</span><br><span class="line">javax.servlet.include.context_path</span><br><span class="line">javax.servlet.include.servlet_path</span><br><span class="line">javax.servlet.include.path_info</span><br><span class="line">javax.servlet.include.query_string</span><br></pre></td></tr></table></figure><p>在doService中，下面的try块中可以看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    doDispatch(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doService并没有直接进行处理，二是将请求交给了doDispatch进行具体的处理。当然在调用doDispatch之前，doService也是做了一些事情的，比如说判断请求是不是inclde请求，设置一些request属性等。</p><h2 id="FlashMap支撑的Redirect参数传递问题"><a href="#FlashMap支撑的Redirect参数传递问题" class="headerlink" title="FlashMap支撑的Redirect参数传递问题"></a>FlashMap支撑的Redirect参数传递问题</h2><p>在doService中除了webApplicationContext、localeResolver、themeResolve和themeSource四个提供给handler和view使用的四个参数外，后面的三个都是和FlashMap有关的，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FlashMap用于保存转发请求的参数的</span></span><br><span class="line">FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line"><span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">&#125;</span><br><span class="line">request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span><br><span class="line">request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span><br></pre></td></tr></table></figure></p><p>注释中提到，FlashMap主要用于Redirect转发时参数的传递；</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/13/160ed457b177f8c3?w=423&amp;h=149&amp;f=jpeg&amp;s=6126" alt=""><br>就拿表单重复提交这个问题来说,一种方案就是：在处理完post请求之后，然后Redirect到一个get的请求，这样即使用户刷新也不会有重复提交的问题。但是问题在于,前面的post请求时提交订单，提交完后redirect到一个显示订单的页面，显然在显示订单的页面我们需要知道订单的信息，但是redirect本身是没有参数传递功能的，按照普通的模式如果想传递参数，就只能将参数拼接在url中，但是url在get请求下又是有长度限制的；另外，对于一些场景下，我们也不希望自己的参数暴露在url中。</p><p>对于上述问题，我们就可以用FlashMap来进行参数传递了；我们需要在redirect之前将需要的参数写入OUTPUT_FLASH_MAP_ATTRIBUTE，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ServletRequestAttributes SRAttributes = (ServletRequestAttributes)(RequestContextHolder.getRequestAttributes());</span><br><span class="line">HttpServletRequest req = SRAttributes.getRequest();</span><br><span class="line">FlashMap flashMap = (FlashMap)(req.getAttribute(DispatcherServlet.OUTPUT_FLASH_MAP_ATTRIBUTE));</span><br><span class="line">flashMap.put(<span class="string">"myname"</span>,<span class="string">"glmapper_2018"</span>);</span><br></pre></td></tr></table></figure><p>这样在redirect之后的handler中spring就会自动将其设置到model里面。但是如果仅仅是这样，每次redirect时都写上面那样一段代码是不是又显得很鸡肋呢？当然，spring也为我们提供了更加方便的用法，即在我们的handler方法的参数中使用RedirectAttributes类型变量即可（前段时间用到这个，本来是想单独写一篇关于参数传递问题的，借此机会就省略一篇吧，吼吼…），来看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/detail/&#123;productId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">detail</span><span class="params">(HttpServletRequest request,HttpServletResponse </span></span></span><br><span class="line"><span class="function"><span class="params">    response,RedirectAttributes attributes, @PathVariable String productId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotBlank(productId)) &#123;</span><br><span class="line">logger.info(<span class="string">"[产品详情]:detail = &#123;&#125;"</span>,JSONObject.toJSONString(map));</span><br><span class="line">mv.addObject(<span class="string">"detail"</span>,JSONObject.toJSONString(getDetail(productId)));</span><br><span class="line">mv.addObject(<span class="string">"title"</span>, <span class="string">"详情"</span>);</span><br><span class="line">mv.setViewName(<span class="string">"detail.ftl"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果没有获取到productId</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">attributes.addFlashAttribute(<span class="string">"msg"</span>, <span class="string">"产品不存在"</span>);</span><br><span class="line">attributes.addFlashAttribute(<span class="string">"productName"</span>, productName);</span><br><span class="line">attributes.addFlashAttribute(<span class="string">"title"</span>, <span class="string">"有点问题！"</span>);</span><br><span class="line">mv.setViewName(<span class="string">"redirect:"</span>/error/fail.htm<span class="string">");</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">return mv;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>这段代码时我前段时间做全局错误处理模块时对原有业务逻辑错误返回的一个抽象，因为要将错误统一处理，就不可能在具体的handler中直接返回到错误界面，所以就将所有的错误处理都redirect到error/fail.htm这个handler method中处理。redirect的参数问题上面已经描述过了，这里就不在细说，就是简单的例子和背景，知道怎么去使用RedirectAttributes。</p><p>RedirectAttributes这个原理也很简单，就是相当于存在了一个session中，但是这个session在用过一次之后就销毁了，即在fail.htm这个方法中获取之后如果再进行redirect，参数还会丢失，那么就在fail.htm中继续使用RedirectAttributes来存储参数再传递到下一个handler。</p><h2 id="doDispatch方法"><a href="#doDispatch方法" class="headerlink" title="doDispatch方法"></a>doDispatch方法</h2><p>为了偷懒，上面强行插入了对Spring中redirect参数传递问题的解释。回归到咱们的doDispatch方法。</p><p>作用：处理实际的调度到handler。handler将通过按顺序应用servlet的HandlerMappings来获得。<br>HandlerAdapter将通过查询servlet已安装的HandlerAdapter来查找支持处理程序类的第一个HandlerAdapter。所有的HTTP方法都由这个方法处理。这取决于HandlerAdapter或处理程序自己决定哪些方法是可以接受的。</p><p>其实在doDispatch中最核心的代码就4行，我们来看下：</p><ul><li><p>根据request找到我们的handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Determine handler for the current request.</span></span><br><span class="line">   mappedHandler = getHandler(processedRequest);</span><br></pre></td></tr></table></figure></li><li><p>根据handler找到对应的HandlerAdapter</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">   HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br></pre></td></tr></table></figure><ul><li>HandlerAdapter处理handler</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Actually invoke the handler.</span></span><br><span class="line">   mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br></pre></td></tr></table></figure><ul><li>调用processDispatchResult方法处理上述过程中得结果综合，当然也包括找到view并且渲染输出给用户<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br></pre></td></tr></table></figure></li></ul><p>我们以上述为轴心，来看下它的整个源码(具体代码含义在代码中标注)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//当前请求request</span></span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    <span class="comment">//处理器链（handler和拦截器）</span></span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//用户标识multipartRequest（文件上传请求）</span></span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//很熟悉吧，这个就是我们返回给用户的包装视图</span></span><br><span class="line">    ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//处理请求过程中抛出的异常。这个异常是不包括渲染过程中抛出的异常的</span></span><br><span class="line">    Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//检查是不是上传请求</span></span><br><span class="line">    processedRequest = checkMultipart(request);</span><br><span class="line">    multipartRequestParsed = (processedRequest != request);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过当前请求确定相应的handler</span></span><br><span class="line">    mappedHandler = getHandler(processedRequest);</span><br><span class="line">    <span class="comment">//如果没有找到：就会报异常，这个异常我们在搭建SpringMVC应用时会经常遇到：</span></span><br><span class="line">    <span class="comment">//No mapping found for HTTP request with URI XXX in</span></span><br><span class="line">    <span class="comment">//DispatcherServlet with name XXX</span></span><br><span class="line">    <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    noHandlerFound(processedRequest, response);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据handler找到HandlerAdapter</span></span><br><span class="line">    HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理GET和Head请求的Last-Modified</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取请求方法</span></span><br><span class="line">    String method = request.getMethod();</span><br><span class="line">    <span class="comment">//这个方法是不是GET方法</span></span><br><span class="line">    <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">    <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">    <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="comment">//这里就是我们SpringMVC拦截器的preHandle方法的处理</span></span><br><span class="line">    <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 调用具体的Handler，并且返回我们的mv对象.</span></span><br><span class="line">    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">            <span class="comment">//如果需要异步处理的话就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="comment">//这个其实就是处理视图（view）为空的情况，会根据request设置默认的view</span></span><br><span class="line">    applyDefaultViewName(processedRequest, mv);</span><br><span class="line">    <span class="comment">//这里就是我们SpringMVC拦截器的postHandle方法的处理</span></span><br><span class="line">    mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    dispatchException = ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">    <span class="comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span></span><br><span class="line">    <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">    dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理返回结果；（异常处理、页面渲染、拦截器的afterCompletion触发等）</span></span><br><span class="line">    processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">    triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">    <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否执行异步请求</span></span><br><span class="line">    <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">    <span class="comment">// 如果是的话，就替代拦截器的postHandle 和 afterCompletion方法执行</span></span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 删除上传请求的资源</span></span><br><span class="line">    <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">    cleanupMultipart(processedRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体来看，doDispatch做了两件事情：</p><ul><li>处理请求</li><li>页面渲染</li></ul><h3 id="doDispatch处理过程流程图"><a href="#doDispatch处理过程流程图" class="headerlink" title="doDispatch处理过程流程图"></a>doDispatch处理过程流程图</h3><p><img src="https://user-gold-cdn.xitu.io/2018/1/13/160ee44a53228b69?w=682&amp;h=644&amp;f=png&amp;s=36088" alt=""></p><p>那上面就是整个DispatcherServlet的一个大概内容了，关于SpringMVC容器的初始化，我们在先把DispatcherServlet中涉及到的九大组件撸完之后再回头来学习。关于九大组件目前已经有过两篇是关于HandlerMapping的了，由于我们打算对于整个SpringMVC体系结构都进行一次梳理，因此，会将九大组件从接口设计以及子类都会通过源码的方式来呈现。</p><p><code>大家如果有什么意见或者建议可以在下方评论区留言，也可以给我们发邮件（glmapper_2018@163.com）!欢迎小伙伴与我们一起交流，一起成长。</code></p>]]></content>
      
      
      <categories>
          
          <category> spring mvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> web </tag>
            
            <tag> mvc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC源码系列：AbstractHandlerMapping</title>
      <link href="/2018/11/10/spring-base-webmvc2/"/>
      <url>/2018/11/10/spring-base-webmvc2/</url>
      
        <content type="html"><![CDATA[<p>AbstractHandlerMapping是实现HandlerMapping接口的一个抽象基类。支持排序，默认处理程序，处理程序拦截器，包括由路径模式映射的处理程序拦截器。所有的HandlerMapping都继承自AbstractHandlerMapping。另外，此基类不支持PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE的暴露，此属性的支持取决于具体的子类，通常基于请求URL映射。</p><p>前面说到，HandlerMapping的作用就是通过request查找Handler和Interceptors。具体的获取均是通过子类来实现的。</p><h2 id="1-AbstractHandlerMapping-的类定义"><a href="#1-AbstractHandlerMapping-的类定义" class="headerlink" title="1.AbstractHandlerMapping 的类定义"></a>1.AbstractHandlerMapping 的类定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractHandlerMapping extends WebApplicationObjectSupport</span><br><span class="line"> implements HandlerMapping, Ordered &#123;</span><br></pre></td></tr></table></figure><p>AbstractHandlerMapping继承了WebApplicationObjectSupport，初始化时会自动调用模板方法initApplicationContext；AbstractHandlerMapping的创建也就是在这个方法里面完成的。同时实现了HandlerMapping和Ordered接口，这也就是上面提到的支持排序的原因。</p><h2 id="2-AbstractHandlerMapping属性分析"><a href="#2-AbstractHandlerMapping属性分析" class="headerlink" title="2.AbstractHandlerMapping属性分析"></a>2.AbstractHandlerMapping属性分析</h2><ul><li><p>排序值 order</p><p>  默认值为Integer的最大值，后面注释的意思是和没有排序是一样的，因为只有理论上才可能超过Integer.MAX_VALUE。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private int order = Integer.MAX_VALUE;  // default: same as non-Ordered</span><br></pre></td></tr></table></figure></li><li><p>默认处理器 defaultHandler</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Object defaultHandler;</span><br></pre></td></tr></table></figure></li><li><p>Spring工具类 urlPathHelper</p><p>  Helper类用于URL路径匹配。提供对RequestDispatcher中URL路径的支持，包括并支持一致的URL解码。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private UrlPathHelper urlPathHelper = new UrlPathHelper();</span><br></pre></td></tr></table></figure></li><li><p>spring工具类 PathMatcher(AntPathMatcher)</p><p>  用于基于字符串的路径匹配的策略接口。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private PathMatcher pathMatcher = new AntPathMatcher();</span><br></pre></td></tr></table></figure></li><li><p>拦截器列表 interceptors</p><p>  用于配置SpringMVC的拦截器，配置方式由两种：<br></p><ul><li>1.注册HandlerMapping时通过属性设置<br></li><li><p>2.通过子类的extendInterceptors钩子方法进行设置（extendInterceptors方法是在initApplicationContext中调用的）<br></p><p>interceptors并不会直接使用，二是通过initInterceptors方法按照类型分配到mappedInterceptors和adaptedInterceptors中进行使用，<strong><strong>interceptors只用于配置。</strong></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final List&lt;Object&gt; interceptors = new ArrayList&lt;Object&gt;();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>adaptedInterceptors</p><p>  被分配到adaptedInterceptors中的类型的拦截器不需要进行匹配，在getHandler中会全部添加到返回值HandlerExecutionChain里面。他 只能从 interceptors中获取。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final List&lt;HandlerInterceptor&gt; adaptedInterceptors = new ArrayList&lt;HandlerInterceptor&gt;();</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>corsProcessor</p><p>  CorsProcessor作用是接受请求和CorsConfiguration并更新响应的策略。<br>  此组件不关心如何选择CorsConfiguration，而是采取后续操作，例如应用CORS验证检查，并拒绝响应或将CORS头添加到响应中。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private CorsProcessor corsProcessor = new DefaultCorsProcessor();</span><br></pre></td></tr></table></figure></li><li><p>corsConfigSource</p><p>  根据路径模式上映射的CorsConfiguration集合提供每个请求的CorsConfiguration实例。支持精确的路径映射URI（如“/ admin”）以及Ant样式的路径模式（如“/ admin / **”）</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private final UrlBasedCorsConfigurationSource corsConfigSource </span><br><span class="line">= new UrlBasedCorsConfigurationSource();</span><br></pre></td></tr></table></figure></li><li><p>跨域相关问题</p></li></ul><p>CorsConfiguration 具体封装跨域配置信息的pojo<br><br>CorsConfigurationSource request与跨域配置信息映射的容器<br><br>CorsProcessor 具体进行跨域操作的类<br></p><h2 id="3-AbstractHandlerMapping-中的get-amp-set方法"><a href="#3-AbstractHandlerMapping-中的get-amp-set方法" class="headerlink" title="3.AbstractHandlerMapping 中的get&amp;set方法"></a>3.AbstractHandlerMapping 中的get&amp;set方法</h2><h3 id="3-1-setOrder"><a href="#3-1-setOrder" class="headerlink" title="3.1 setOrder"></a>3.1 setOrder</h3><p>指定此HandlerMapping bean的排序值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final void setOrder(int order) &#123;</span><br><span class="line">  this.order = order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-2-setDefaultHandler"><a href="#3-2-setDefaultHandler" class="headerlink" title="3.2 setDefaultHandler"></a>3.2 setDefaultHandler</h3><p>指定此HandlerMapping bean的排序值。<br>设置此处理程序映射的默认处理程序。<br>如果没有找到特定的映射，这个处理程序将被返回。<br>缺省值为null，表示没有默认处理程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void setDefaultHandler(Object defaultHandler) &#123;</span><br><span class="line">this.defaultHandler = defaultHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-3-getDefaultHandler"><a href="#3-3-getDefaultHandler" class="headerlink" title="3.3 getDefaultHandler"></a>3.3 getDefaultHandler</h3><p>返回此处理程序映射的默认处理程序，如果没有，则返回null。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object getDefaultHandler() &#123;</span><br><span class="line">return this.defaultHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-4-setAlwaysUseFullPath"><a href="#3-4-setAlwaysUseFullPath" class="headerlink" title="3.4 setAlwaysUseFullPath"></a>3.4 setAlwaysUseFullPath</h3><p>如果URL查找始终使用当前servlet上下文中的完整路径，请进行设置。 否则，如果适用，则使用当前servlet映射中的路径（即，在web.xml中“… / *”servlet映射的情况下）。<br>默认是“false”。setAlwaysUseFullPath中的实现具体是委托给urlPathHelper和corsConfigSource来完成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setAlwaysUseFullPath(boolean alwaysUseFullPath) &#123;</span><br><span class="line">this.urlPathHelper.setAlwaysUseFullPath(alwaysUseFullPath);</span><br><span class="line">this.corsConfigSource.setAlwaysUseFullPath(alwaysUseFullPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-5-setUrlDecode"><a href="#3-5-setUrlDecode" class="headerlink" title="3.5 setUrlDecode"></a>3.5 setUrlDecode</h3><p>如果上下文路径和请求URI应该被URL解码，则设置。两者都是由Servlet API返回“undecoded”，与servlet路径相反。根据Servlet规范（ISO-8859-1）使用请求编码或默认编码。setUrlDecode中的实现具体是委托给urlPathHelper和corsConfigSource来完成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setUrlDecode(boolean urlDecode) &#123;</span><br><span class="line">this.urlPathHelper.setUrlDecode(urlDecode);</span><br><span class="line">this.corsConfigSource.setUrlDecode(urlDecode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-6-setRemoveSemicolonContent"><a href="#3-6-setRemoveSemicolonContent" class="headerlink" title="3.6 setRemoveSemicolonContent"></a>3.6 setRemoveSemicolonContent</h3><p>如果“;” （分号）内容应该从请求URI中去除,则设置。默认值是true。setRemoveSemicolonContent中的实现具体是委托给urlPathHelper和corsConfigSource来完成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setRemoveSemicolonContent(boolean removeSemicolonContent) &#123;</span><br><span class="line">this.urlPathHelper.setRemoveSemicolonContent(removeSemicolonContent);</span><br><span class="line">this.corsConfigSource.setRemoveSemicolonContent(removeSemicolonContent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-7-setUrlPathHelper"><a href="#3-7-setUrlPathHelper" class="headerlink" title="3.7 setUrlPathHelper"></a>3.7 setUrlPathHelper</h3><p>设置UrlPathHelper以用于解析查找路径。<br>使用它可以用自定义子类覆盖默认的UrlPathHelper，或者跨多个HandlerMappings和MethodNameResolvers共享通用的UrlPathHelper设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void setUrlPathHelper(UrlPathHelper urlPathHelper) &#123;</span><br><span class="line">Assert.notNull(urlPathHelper, &quot;UrlPathHelper must not be null&quot;);</span><br><span class="line">this.urlPathHelper = urlPathHelper;</span><br><span class="line">this.corsConfigSource.setUrlPathHelper(urlPathHelper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-8-getUrlPathHelper"><a href="#3-8-getUrlPathHelper" class="headerlink" title="3.8 getUrlPathHelper"></a>3.8 getUrlPathHelper</h3><p>返回UrlPathHelper实现以用于解析查找路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public UrlPathHelper getUrlPathHelper() &#123;</span><br><span class="line">return urlPathHelper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-9-setPathMatcher"><a href="#3-9-setPathMatcher" class="headerlink" title="3.9 setPathMatcher"></a>3.9 setPathMatcher</h3><p>将PathMatcher实现设置为用于匹配注册的URL模式的URL路径。 默认是AntPathMatcher。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void setPathMatcher(PathMatcher pathMatcher) &#123;</span><br><span class="line">Assert.notNull(pathMatcher, &quot;PathMatcher must not be null&quot;);</span><br><span class="line">this.pathMatcher = pathMatcher;</span><br><span class="line">this.corsConfigSource.setPathMatcher(pathMatcher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-10-setInterceptors"><a href="#3-10-setInterceptors" class="headerlink" title="3.10 setInterceptors"></a>3.10 setInterceptors</h3><p>设置拦截器以应用此处理程序映射映射的所有处理程序。<br>支持的拦截器类型是<strong>HandlerInterceptor，WebRequestInterceptor和MappedInterceptor。</strong><br>映射拦截器仅适用于请求与其路径模式相匹配的URL。映射的拦截器Bean在初始化期间也会按类型检测到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ublic void setInterceptors(Object... interceptors) &#123;</span><br><span class="line">this.interceptors.addAll(Arrays.asList(interceptors));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>其他几个get&amp;set方法就不列出来了，有兴趣的小伙伴可以自行阅读...</code></p><h2 id="4-AbstractHandlerMapping的创建"><a href="#4-AbstractHandlerMapping的创建" class="headerlink" title="4. AbstractHandlerMapping的创建"></a>4. AbstractHandlerMapping的创建</h2><p>因为AbstractHandlerMapping继承了WebApplicationObjectSupport类，因此AbstractHandlerMapping的创建就是依托于模板方法initApplicationContext来完成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void initApplicationContext() throws BeansException &#123;</span><br><span class="line">extendInterceptors(this.interceptors);</span><br><span class="line">detectMappedInterceptors(this.adaptedInterceptors);</span><br><span class="line">initInterceptors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从方法结构可以了解到，initApplicationContext中包括三个子处理方法。</p><ul><li>extendInterceptors：这也是一个模板方法，在AbstractHandlerMapping中并没有具体实现（方法体是空的），主要是用于给子类提供一个添加（修改）Interceptors的入口（现有的SpringMVC实现中均未使用）。</li><li><p>detectMappedInterceptors：用于将SpringMVC容器及父容器中的所有MappedInterceptor类型的Bean添加到MappedInterceptors属性中。</p><p>  <code>检测MappedInterceptor类型的bean，并将它们添加到映射的拦截器列表中。  除了可能通过setInterceptors提供的任何MappedInterceptors之外，还会调用此方法，默认情况下将从当前上下文及其祖先中添加所有MappedInterceptor类型的Bean。子类可以覆盖和优化这个策略。</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void detectMappedInterceptors(List&lt;HandlerInterceptor&gt; mappedInterceptors) &#123;</span><br><span class="line">mappedInterceptors.addAll(</span><br><span class="line">BeanFactoryUtils.beansOfTypeIncludingAncestors(</span><br><span class="line">getApplicationContext(), MappedInterceptor.class, true, false).values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>initInterceptors：初始化指定的拦截器，检查MappedInterceptors并根据需要调整HandlerInterceptors和WebRequestInterceptors。（当前Spring版本时4.3.6） </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void initInterceptors() &#123;</span><br><span class="line">    if (!this.interceptors.isEmpty()) &#123;</span><br><span class="line">    for (int i = 0; i &lt; this.interceptors.size(); i++) &#123;</span><br><span class="line">    Object interceptor = this.interceptors.get(i);</span><br><span class="line">    if (interceptor == null) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;Entry number &quot; + i + &quot; in interceptors array is null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.adaptedInterceptors.add(adaptInterceptor(interceptor));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这个是4.1.5版本的initInterceptors方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected void initInterceptors() &#123;</span><br><span class="line">    if (!this.interceptors.isEmpty()) &#123;</span><br><span class="line">    for (int i = 0; i &lt; this.interceptors.size(); i++) &#123;</span><br><span class="line">    Object interceptor = this.interceptors.get(i);</span><br><span class="line">    if (interceptor == null) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;Entry number &quot; + i + &quot; in interceptors array is null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (interceptor instanceof MappedInterceptor) &#123;</span><br><span class="line">    this.mappedInterceptors.add((MappedInterceptor) interceptor);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">    this.adaptedInterceptors.add(adaptInterceptor(interceptor));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>在4.1.5中版本中，initInterceptors的工作是将interceptors属性里面所包含的对象按照类型添加到adaptedInterceptors或者mappedInterceptors中。在4.1.5版本中mappedInterceptors是AbstractHandlerMapping的属性之一。主要原因是因为，springMVC自4.2开始添加了跨域的支持，也就是上面属性中的后两个。PS：在阅读Spring相关源码时需要关注不同版本的变更及区别，不要只关注某一个版本，另外就是个人觉得阅读源码的关注点应该在编码方式、设计模式使用、设计思想及理念，而不仅仅是知道他是如何实现的】</code></p><p>这里顺便说下mappedInterceptors的作用：mappedInterceptors中的拦截器在使用时需要与请求的url进行匹配，只有匹配成功后才会添加到getHandler的返回值HandlerExecytionChain里。</p><p><strong>adaptInterceptor方法:</strong></p><p>使给定的拦截器对象适配HandlerInterceptor接口。默认情况下，支持的拦截器类型是HandlerInterceptor和WebRequestInterceptor。每个给定的WebRequestInterceptor将被封装在WebRequestHandlerInterceptorAdapter中。可以在子类中重写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected HandlerInterceptor adaptInterceptor(Object interceptor) &#123;</span><br><span class="line">if (interceptor instanceof HandlerInterceptor) &#123;</span><br><span class="line">return (HandlerInterceptor) interceptor;</span><br><span class="line">&#125;</span><br><span class="line">else if (interceptor instanceof WebRequestInterceptor) &#123;</span><br><span class="line">return new WebRequestHandlerInterceptorAdapter((WebRequestInterceptor) interceptor);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">throw new IllegalArgumentException(&quot;Interceptor type not supported: &quot; + interceptor.getClass().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="5-Handler和Interceptor的获取"><a href="#5-Handler和Interceptor的获取" class="headerlink" title="5.Handler和Interceptor的获取"></a>5.Handler和Interceptor的获取</h2><p>HandlerMapping是通过getHandler方法来获取Handler和Interceptor的。因此在抽象基类AbstractHandlerMapping中提供了具体的实现。并且在AbstractHandlerMapping中，getHandler使用final关键字修饰的，也就是说，子类不能再进行对此方法进行覆盖重写了。</p><p>getHandler的作用就是查找给定请求的handler，如果找不到特定请求，则返回到默认handler。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">//通过getHandlerInternal方法来获取handler</span><br><span class="line">Object handler = getHandlerInternal(request);</span><br><span class="line">//如果前一个方法没有获取到，则使用默认的handler</span><br><span class="line">if (handler == null) &#123;</span><br><span class="line">    //默认的Handler就是AbstractHandlerMapping中的handler属性通过set得到的值</span><br><span class="line">handler = getDefaultHandler();</span><br><span class="line">&#125;</span><br><span class="line">//如果还是没有找到Hander，则直接返回Null</span><br><span class="line">if (handler == null) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">// Bean name or resolved handler?</span><br><span class="line">//如果找到的handler是String类型的，</span><br><span class="line">if (handler instanceof String) &#123;</span><br><span class="line">    //则以它为名到spring Mvc的容器中查找相应的Bean</span><br><span class="line">String handlerName = (String) handler;</span><br><span class="line">handler = getApplicationContext().getBean(handlerName);</span><br><span class="line">&#125;</span><br><span class="line">    //先根据handler和request创建一个HandlerExecutionChain对象，</span><br><span class="line">HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</span><br><span class="line">if (CorsUtils.isCorsRequest(request)) &#123;</span><br><span class="line">CorsConfiguration globalConfig = this.corsConfigSource.getCorsConfiguration(request);</span><br><span class="line">CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);</span><br><span class="line">CorsConfiguration config = (globalConfig != null ? globalConfig.combine(handlerConfig) : handlerConfig);</span><br><span class="line">executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">&#125;</span><br><span class="line">return executionChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>getHandlerInternal</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected abstract Object getHandlerInternal(HttpServletRequest request) throws Exception;</span><br></pre></td></tr></table></figure><p>查找给定请求的handler，如果找不到特定请求，则返回null。 这个方法被getHandler调用; 如果设置了null返回值，将导致默认handler。<br>在CORS pre-flight请求上，这个方法应该返回一个不匹配飞行前请求的匹配项，而是根据URL路径，“Access-Control-Request-Method”头中的HTTP方法和头文件 从“Access-Control-Request-Headers”头部获得，从而允许CORS配置通过getCorsConfigurations获得，<br>注意：这个方法也可以返回一个预先构建的HandlerExecutionChain，将一个处理程序对象与动态确定的拦截器组合在一起。状态指定的拦截器将被合并到这个现有的链中。</p><p><strong>getHandlerExecutionChain</strong>：</p><p>getLookupPathForRequest:返回给定请求的映射查找路径，如果适用的话，在当前的servlet映射中，或者在web应用程序中返回。如果在RequestDispatcher中调用include请求，则检测包含请求URL。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) &#123;</span><br><span class="line">    //如果handler是HandlerExecutionChain类型则直接强转为HandlerExecutionChain类型，</span><br><span class="line">        //如果不是则根据handler创建一个新的HandlerExecutionChain实例对象</span><br><span class="line">HandlerExecutionChain chain = (handler instanceof HandlerExecutionChain ?</span><br><span class="line">(HandlerExecutionChain) handler : new HandlerExecutionChain(handler));</span><br><span class="line">    //返回给定请求的映射查找路径</span><br><span class="line">String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);</span><br><span class="line">//遍历当前adaptedInterceptors链表</span><br><span class="line">for (HandlerInterceptor interceptor : this.adaptedInterceptors) &#123;</span><br><span class="line">    //如果是MappedInterceptor类型则</span><br><span class="line">if (interceptor instanceof MappedInterceptor) &#123;</span><br><span class="line">MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;</span><br><span class="line">//拦截器是否应用于给定的请求路径，如果是则返回true</span><br><span class="line">if (mappedInterceptor.matches(lookupPath, this.pathMatcher)) &#123;</span><br><span class="line">chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">chain.addInterceptor(interceptor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为给定的handler构建一个HandlerExecutionChain，包括可用的拦截器。默认实现用给定的handler，handler映射的通用拦截器以及与当前请求URL相匹配的任何MappedInterceptors构建标准的HandlerExecutionChain。拦截器按照他们注册的顺序添加。为了扩展/重新排列拦截器列表，子类可以覆盖它。<br></p><p>需要注意的是，传入的handler对象可能是原始handler或预构建的HandlerExecutionChain。这个方法应该明确地处理这两种情况，建立一个新的HandlerExecutionChain或者扩展现有的链。为了简单地在自定义子类中添加拦截器，可以考虑调用super.getHandlerExecutionChain（handler，request）并在返回的链对象上调用HandlerExecutionChain＃addInterceptor。</p><p><strong>getCorsHandlerExecutionChain</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected HandlerExecutionChain getCorsHandlerExecutionChain(HttpServletRequest request,</span><br><span class="line">HandlerExecutionChain chain, CorsConfiguration config) &#123;</span><br><span class="line">    //通过请求头的http方法是否options判断是否预请求，</span><br><span class="line">if (CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">HandlerInterceptor[] interceptors = chain.getInterceptors();</span><br><span class="line">//如果是使用PreFlightRequest替换处理器</span><br><span class="line">chain = new HandlerExecutionChain(new PreFlightHandler(config), interceptors);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    //如果是普通请求，添加一个拦截器CorsInterceptor。</span><br><span class="line">chain.addInterceptor(new CorsInterceptor(config));</span><br><span class="line">&#125;</span><br><span class="line">return chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新HandlerExecutionChain进行与CORS（HTTP访问控制：跨域资源共享）相关的处理。</p><ul><li>对于pre-flight请求，默认实现用一个简单的HttpRequestHandler来替换选择的handler，该HttpRequestHandler调用已配置的setCorsProcessor。（将处理器替换为内部类PreFlightHandler）</li><li>对于普通的请求，默认实现插入一个HandlerInterceptor，它执行与CORS有关的检查并添加CORS头。（添加CorsInterceptor拦截器）</li></ul><h2 id="AbstractHandlerMapping中的两个内部类"><a href="#AbstractHandlerMapping中的两个内部类" class="headerlink" title="AbstractHandlerMapping中的两个内部类"></a>AbstractHandlerMapping中的两个内部类</h2><p>这两个内部类就是用来校验request是否cors，并封装对应的Adapter的。</p><ul><li>PreFlightRequest是CorsProcessor对于HttpRequestHandler的一个适配器。这样HandlerAdapter直接使用HttpRequestHandlerAdapter处理。</li><li>CorsInterceptor 是CorsProcessor对于HandlerInterceptorAdapter的适配器。</li></ul><p>具体的类信息如下：</p><h3 id="PreFlightHandler"><a href="#PreFlightHandler" class="headerlink" title="PreFlightHandler"></a>PreFlightHandler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private class PreFlightHandler implements HttpRequestHandler, CorsConfigurationSource &#123;</span><br><span class="line"></span><br><span class="line">private final CorsConfiguration config;</span><br><span class="line"></span><br><span class="line">public PreFlightHandler(CorsConfiguration config) &#123;</span><br><span class="line">this.config = config;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;</span><br><span class="line">corsProcessor.processRequest(this.config, request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public CorsConfiguration getCorsConfiguration(HttpServletRequest request) &#123;</span><br><span class="line">return this.config;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CorsInterceptor"><a href="#CorsInterceptor" class="headerlink" title="CorsInterceptor"></a>CorsInterceptor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private class CorsInterceptor extends HandlerInterceptorAdapter implements CorsConfigurationSource &#123;</span><br><span class="line"></span><br><span class="line">private final CorsConfiguration config;</span><br><span class="line"></span><br><span class="line">public CorsInterceptor(CorsConfiguration config) &#123;</span><br><span class="line">this.config = config;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</span><br><span class="line">throws Exception &#123;</span><br><span class="line"></span><br><span class="line">return corsProcessor.processRequest(this.config, request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public CorsConfiguration getCorsConfiguration(HttpServletRequest request) &#123;</span><br><span class="line">return this.config;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此AbstractHandlerMapping中的一些源码就结束了，AbstractHandlerMapping为HandlerMapping的功能提供的一些具体的模板描述，但是具体的细节实现还需要从其子类中来慢慢分析。关于这部分中涉及到的如HandlerExecutionChain，cors跨域等问题，后面会根据实际情况另开篇幅来学习。</p><p><code>大家如果有什么意见或者建议可以在下方评论区留言，也可以给我们发邮件（glmapper_2018@163.com）!欢迎小伙伴与我们一起交流，一起成长。</code></p>]]></content>
      
      
      <categories>
          
          <category> spring mvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> web </tag>
            
            <tag> mvc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC源码系列：HandlerMapping</title>
      <link href="/2018/11/10/spring-base-webmvc1/"/>
      <url>/2018/11/10/spring-base-webmvc1/</url>
      
        <content type="html"><![CDATA[<p>HandlerMapping接口是用来查找Handler的。在SpringMvc中，DispatcherServlet处理分发很多请求，而每个请求都需要一个Handler来处理，具体接受到一个请求后使用哪个Handler来处理呢？这就是Handler要做的事情。因此，HandlerMapping的作用就是根据request找到相应的处理器Handler和Interceptors。</p><p>下面是Spring中对HandlerMapping接口的说明：</p><p><code>This class can be implemented by application developers, although this is not necessary, as BeanNameUrlHandlerMapping and DefaultAnnotationHandlerMapping are included in the framework. The former is the default if no HandlerMapping bean is registered in the application context.</code><br><br>这个类可以由应用程序开发人员实现，尽管这不是必须的，因为BeanNameUrlHandlerMapping和DefaultAnnotationHandlerMapping已经包含在框架中，作为HandlerMapping的默认实现。 如果在应用程序上下文中没有注册HandlerMapping bean，BeanNameUrlHandlerMapping是默认值。</p><p><code>HandlerMapping implementations can support mapped interceptors but do not have to. A handler will always be wrapped in a HandlerExecutionChain instance, optionally accompanied by some HandlerInterceptor instances.The DispatcherServlet will first call each HandlerInterceptor&#39;s preHandle  method in the given order, finally invoking the handler itself if all preHandle methods have returned true</code><br><br>HandlerMapping实现可以支持映射的拦截器，但不必如此；handler将始终被封装在HandlerExecutionChain实例中，并可由一些HandlerInterceptor实例执行。在给定的顺序中，DispatcherServlet将首先调用每个HandlerInterceptor的preHandle方法，如果所有的preHandle方法都返回true，那么最后调用handler本身。</p><p><code>The ability to parameterize this mapping is a powerful and unusual capability of this MVC framework. For example, it is possible to write a custom mapping based on session state, cookie state or many other variables. No other MVC framework seems to be equally flexible.</code><br><br>参数化这个映射的能力是这个MVC框架的一个强大且不同寻常的能力。 例如，可以根据会话状态，cookie状态或许多其他变量编写自定义映射。 没有其他MVC框架似乎同样灵活。</p><p><code>Note: Implementations can implement the Ordered interface to be able to specify a sorting order and thus a priority for getting applied by DispatcherServlet. Non-Ordered instances get treated as lowest priority.</code><br><br>注：实现可以实现Ordered接口，以便能够指定排序顺序，从而指定由DispatcherServlet应用的优先级。 无序实例被视为最低优先级。</p><h2 id="1-接口常量"><a href="#1-接口常量" class="headerlink" title="1.接口常量"></a>1.接口常量</h2><h3 id="1-1、PATH-WITHIN-HANDLER-MAPPING-ATTRIBUTE"><a href="#1-1、PATH-WITHIN-HANDLER-MAPPING-ATTRIBUTE" class="headerlink" title="1.1、PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE"></a>1.1、PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE</h3><p>HttpServletRequest属性的名称，它包含处理程序映射中的路径，比如模式匹配，或者完全相关的URI(通常在DispatcherServlet的映射中)。此属性不需要所有HandlerMapping实现支持。基于url的HandlerMappings通常会支持它，但是处理程序不应该期望这个请求属性在所有场景中都存在。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Name of the &#123;@link HttpServletRequest&#125; attribute that contains the path</span><br><span class="line"> * within the handler mapping, in case of a pattern match, or the full</span><br><span class="line"> * relevant URI (typically within the DispatcherServlet&apos;s mapping) else.</span><br><span class="line"> * &lt;p&gt;Note: This attribute is not required to be supported by all</span><br><span class="line"> * HandlerMapping implementations. URL-based HandlerMappings will</span><br><span class="line"> * typically support it, but handlers should not necessarily expect</span><br><span class="line"> * this request attribute to be present in all scenarios.</span><br><span class="line"> */</span><br><span class="line">String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.pathWithinHandlerMapping&quot;;</span><br></pre></td></tr></table></figure></p><h3 id="1-2、BEST-MATCHING-PATTERN-ATTRIBUTE"><a href="#1-2、BEST-MATCHING-PATTERN-ATTRIBUTE" class="headerlink" title="1.2、BEST_MATCHING_PATTERN_ATTRIBUTE"></a>1.2、BEST_MATCHING_PATTERN_ATTRIBUTE</h3><p>HttpServletRequest属性的名称，包括处理程序映射中的最佳匹配模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Name of the &#123;@link HttpServletRequest&#125; attribute that contains the</span><br><span class="line"> * best matching pattern within the handler mapping.</span><br><span class="line"> * &lt;p&gt;Note: This attribute is not required to be supported by all</span><br><span class="line"> * HandlerMapping implementations. URL-based HandlerMappings will</span><br><span class="line"> * typically support it, but handlers should not necessarily expect</span><br><span class="line"> * this request attribute to be present in all scenarios.</span><br><span class="line"> */</span><br><span class="line">String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.bestMatchingPattern&quot;;</span><br></pre></td></tr></table></figure></p><h3 id="1-3、INTROSPECT-TYPE-LEVEL-MAPPING"><a href="#1-3、INTROSPECT-TYPE-LEVEL-MAPPING" class="headerlink" title="1.3、INTROSPECT_TYPE_LEVEL_MAPPING"></a>1.3、INTROSPECT_TYPE_LEVEL_MAPPING</h3><p>HttpServletRequest属性的名称，指示是否应该检查类型级别的映射。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Name of the boolean &#123;@link HttpServletRequest&#125; attribute that indicates</span><br><span class="line"> * whether type-level mappings should be inspected.</span><br><span class="line"> * &lt;p&gt;Note: This attribute is not required to be supported by all</span><br><span class="line"> * HandlerMapping implementations.</span><br><span class="line"> */</span><br><span class="line">String INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.class.getName() + &quot;.introspectTypeLevelMapping&quot;;</span><br></pre></td></tr></table></figure><h3 id="1-4、URI-TEMPLATE-VARIABLES-ATTRIBUTE"><a href="#1-4、URI-TEMPLATE-VARIABLES-ATTRIBUTE" class="headerlink" title="1.4、URI_TEMPLATE_VARIABLES_ATTRIBUTE"></a>1.4、URI_TEMPLATE_VARIABLES_ATTRIBUTE</h3><p>包含URI模板映射的HttpServletRequest属性的名称，将变量名称映射到值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Name of the &#123;@link HttpServletRequest&#125; attribute that contains the URI</span><br><span class="line"> * templates map, mapping variable names to values.</span><br><span class="line"> * &lt;p&gt;Note: This attribute is not required to be supported by all</span><br><span class="line"> * HandlerMapping implementations. URL-based HandlerMappings will</span><br><span class="line"> * typically support it, but handlers should not necessarily expect</span><br><span class="line"> * this request attribute to be present in all scenarios.</span><br><span class="line"> */</span><br><span class="line">String URI_TEMPLATE_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.uriTemplateVariables&quot;;</span><br></pre></td></tr></table></figure></p><h3 id="1-5、MATRIX-VARIABLES-ATTRIBUTE"><a href="#1-5、MATRIX-VARIABLES-ATTRIBUTE" class="headerlink" title="1.5、MATRIX_VARIABLES_ATTRIBUTE"></a>1.5、MATRIX_VARIABLES_ATTRIBUTE</h3><p>包含带有URI矩阵变量的映射的HttpServletRequest属性的名称。此属性不需要所有HandlerMapping实现支持，也可能不存在，这取决于HandlerMapping是否被配置为在请求URI中保留矩阵变量内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Name of the &#123;@link HttpServletRequest&#125; attribute that contains a map with</span><br><span class="line"> * URI matrix variables.</span><br><span class="line"> * &lt;p&gt;Note: This attribute is not required to be supported by all</span><br><span class="line"> * HandlerMapping implementations and may also not be present depending on</span><br><span class="line"> * whether the HandlerMapping is configured to keep matrix variable content</span><br><span class="line"> * in the request URI.</span><br><span class="line"> */</span><br><span class="line">String MATRIX_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.matrixVariables&quot;;</span><br></pre></td></tr></table></figure><h3 id="1-6、PRODUCIBLE-MEDIA-TYPES-ATTRIBUTE"><a href="#1-6、PRODUCIBLE-MEDIA-TYPES-ATTRIBUTE" class="headerlink" title="1.6、PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE"></a>1.6、PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE</h3><p>HttpServletRequest属性的名称，该属性包含可用于映射处理程序的可生成的MediaTypes集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Name of the &#123;@link HttpServletRequest&#125; attribute that contains the set of</span><br><span class="line"> * producible MediaTypes applicable to the mapped handler.</span><br><span class="line"> * &lt;p&gt;Note: This attribute is not required to be supported by all</span><br><span class="line"> * HandlerMapping implementations. Handlers should not necessarily expect</span><br><span class="line"> * this request attribute to be present in all scenarios.</span><br><span class="line"> */</span><br><span class="line">String PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.producibleMediaTypes&quot;;</span><br></pre></td></tr></table></figure><h2 id="2-核心方法"><a href="#2-核心方法" class="headerlink" title="2.核心方法"></a>2.核心方法</h2><p>HandlerMapping接口中只有一个方法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;</span><br></pre></td></tr></table></figure></p><p>从方法定义可以看出，getHandler方法就是通过request来获取一个HandlerExecutionChain；该方法在不同的子类中都有实现，具体的实现后面说子类的时候在详细分析。</p><h2 id="3-HandlerMapping的子类"><a href="#3-HandlerMapping的子类" class="headerlink" title="3.HandlerMapping的子类"></a>3.HandlerMapping的子类</h2><p><img src="https://user-gold-cdn.xitu.io/2018/1/10/160de1fc214fe76d?w=1298&amp;h=974&amp;f=png&amp;s=35893" alt=""><br><code>图中黄色部分表示已经过时的类，时间开发中不建议再使用。</code></p><p>在HandlerMapping的体系中可以看出，HandlerMapping下属子类可分为两个分支；</p><ul><li>AbstractHandlerMethodMapping</li><li>AbstractUrlHandlerMapping</li></ul><p>上述两个抽象类又均是AbstractHandlerMapping的子类。关于AbstractHandlerMapping我们下篇文章来学习。</p><p><code>大家如果有什么意见或者建议可以在下方评论区留言，也可以给我们发邮件（glmapper_2018@163.com）!欢迎小伙伴与我们一起交流，一起成长。</code></p>]]></content>
      
      
      <categories>
          
          <category> spring mvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> web </tag>
            
            <tag> mvc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>菜鸟成长系列-Builder 建造者模式</title>
      <link href="/2018/11/10/java-design-model-builder/"/>
      <url>/2018/11/10/java-design-model-builder/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.im/post/59feb9296fb9a0451a75c21e" target="_blank" rel="noopener">菜鸟成长系列-面向对象的四大基础特性</a><br><br><a href="https://juejin.im/post/5a0d60ee6fb9a045272525af" target="_blank" rel="noopener">菜鸟成长系列-多态、接口和抽象类</a><br><br><a href="https://juejin.im/post/5a2bad01518825619a029c0e" target="_blank" rel="noopener">菜鸟成长系列-面向对象的6种设计原则</a><br><br><a href="https://juejin.im/post/5a366d756fb9a045076fc04f" target="_blank" rel="noopener">菜鸟成长系列-单例模式</a><br><a href="https://juejin.im/post/5a3f08335188253aea1f8cb9" target="_blank" rel="noopener">菜鸟成长系列-工厂模式</a></p><p><code>建造者模式也是创建型中的一种，用于负责创建对象。建造者模式可以将一个产品的内部表象与产品的生成过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。</code></p><h2 id="什么是产品的内部表象？"><a href="#什么是产品的内部表象？" class="headerlink" title="什么是产品的内部表象？"></a>什么是产品的内部表象？</h2><p>一个产品常有不用的组成成分作为产品的零件，这些零件有可能是对象，也有可能不是对象，他们通常又叫做产品的内部表象。不同的产品可以有不同的内部表象，也就是可以有不同的零件。<strong>使用建造者模式可以使客户端不需要知道所生成的产品对象有哪些零件，每个产品的对应零件彼此有何不同，是怎么建造出来的，以及怎样组成产品。</strong></p><h2 id="工厂模式与建造者模式"><a href="#工厂模式与建造者模式" class="headerlink" title="工厂模式与建造者模式"></a>工厂模式与建造者模式</h2><p>上一篇我们讨论了工厂模式，我们知道工厂模式一般都是创建一个产品，注重的是把这个产品创建出来就行，只要创建出来，不关心这个产品的组成部分。从代码上看，工厂模式就是一个方法，用这个方法就能生产出产品。那么对于建造者模式呢？<br><strong>建造者模式也是创建一个产品，但是不仅要把这个产品创建出来，还要关系这个产品的组成细节，    组成过程。从代码上看（下面给出），建造者模式在建造产品时，这个产品有很多方法，建造者模式会根据这些相同方法但是不同执行顺序建造出不同组成细节的产品。</strong></p><h2 id="建造者模式的结构"><a href="#建造者模式的结构" class="headerlink" title="建造者模式的结构"></a>建造者模式的结构</h2><p><img src="https://user-gold-cdn.xitu.io/2017/12/30/160a55b4d5613629?w=914&amp;h=285&amp;f=png&amp;s=126359" alt=""><br>结构组件角色说明：</p><ul><li>抽象建造者（Builder）:抽象类， 规范产品的组建，一般是由子类实现具体的组件过程</li><li>具体建造者（ConcreteBuilder ）：具体的构建器 </li><li>导演者（Director） : 统一组装过程(可省略)</li><li>产品（Product）:产品的抽象类</li></ul><p>Director角色是与客户端打交道的角色。Director将客户端创建产品的请求划分为对各个零件的建造请求，再将这些请求委派给具体的ConcreteBuilder角色。ConcreteBuilder是做具体建造工作的，但是对客户端是透明的。</p><p>一般来说，每有一个产品类，就有一个相应的具体建造者类。这些产品应当有一样数目的零件，而每有一个零件就相应的在所有的建造者角色里有一个建造方法。</p><h2 id="建造一封邮件"><a href="#建造一封邮件" class="headerlink" title="建造一封邮件"></a>建造一封邮件</h2><p>通过代码来看下各个角色的职责：</p><ul><li>Director</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.model.builder;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * 导演者类</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @time 2017年12月30日上午11:33:26</span><br><span class="line"> * @version glmapper_v1.0</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Director &#123;</span><br><span class="line">private Builder builder;</span><br><span class="line">/**</span><br><span class="line"> * 产品构造方法，负责调用各个零件建造方法</span><br><span class="line"> */</span><br><span class="line">public EmailProduct construct()&#123;</span><br><span class="line">builder = new ConcreteBuilder();</span><br><span class="line">builder.buildFromAddress();</span><br><span class="line">builder.buildToAddress();</span><br><span class="line">builder.buildSubject();</span><br><span class="line">builder.buildContent();</span><br><span class="line">builder.buildSupplement();</span><br><span class="line">return builder.returnEmailProduct();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Builder</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.model.builder;</span><br><span class="line">/**</span><br><span class="line"> * 抽象建造者 提供不同的构建组件方法</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @time 2017年12月30日上午11:31:34</span><br><span class="line"> * @version glmapper_v1.0</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public interface Builder &#123;</span><br><span class="line">/**</span><br><span class="line"> * 构建发件人信息</span><br><span class="line"> */</span><br><span class="line">public void buildFromAddress();</span><br><span class="line">/**</span><br><span class="line"> * 构建收件人信息</span><br><span class="line"> */</span><br><span class="line">public void buildToAddress();</span><br><span class="line">/**</span><br><span class="line"> * 构建邮件内容</span><br><span class="line"> */</span><br><span class="line">public void buildContent();</span><br><span class="line">/**</span><br><span class="line"> * 构建邮件附件</span><br><span class="line"> */</span><br><span class="line">public void buildSupplement();</span><br><span class="line">/**</span><br><span class="line"> * 构建邮件主题</span><br><span class="line"> */</span><br><span class="line">public void buildSubject();</span><br><span class="line">/**</span><br><span class="line"> * 返回构建的产品</span><br><span class="line"> */</span><br><span class="line">public EmailProduct returnEmailProduct();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ConcreteBuilder</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.model.builder;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * 具体产品的建造器</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @time 2017年12月30日上午11:31:11</span><br><span class="line"> * @version glmapper_v1.0</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ConcreteBuilder implements Builder&#123;</span><br><span class="line"></span><br><span class="line">private EmailProduct emailProduct = new EmailProduct();</span><br><span class="line">public void buildFromAddress() &#123;</span><br><span class="line">emailProduct.setFromAddress(&quot;00001111@glmapper.com&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void buildToAddress() &#123;</span><br><span class="line">emailProduct.setToAddress(&quot;00001112@glmapper.com&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void buildContent() &#123;</span><br><span class="line">emailProduct.setContent(&quot;我写了一个建造者模式的例子，希望大佬给点意见&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void buildSupplement() &#123;</span><br><span class="line">emailProduct.setSupplement(&quot;附件：BuilderDemo.rar&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void buildSubject() &#123;</span><br><span class="line">emailProduct.setSubject(&quot;给大佬的一封建造者模式的Demo&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public EmailProduct returnEmailProduct() &#123;</span><br><span class="line">System.out.println(emailProduct.toString());</span><br><span class="line">return emailProduct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Product</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.model.builder;</span><br><span class="line">/**</span><br><span class="line"> * 产品类（产品类中包括不同组件：此处使用字段方式模式组件）</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @time 2017年12月30日上午11:30:13</span><br><span class="line"> * @version glmapper_v1.0</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class EmailProduct &#123;</span><br><span class="line">/**</span><br><span class="line"> * 发件地址</span><br><span class="line"> */</span><br><span class="line">private String fromAddress;</span><br><span class="line">/**</span><br><span class="line"> * 收件地址</span><br><span class="line"> */</span><br><span class="line">private String toAddress;</span><br><span class="line">/**</span><br><span class="line"> * 邮件主题</span><br><span class="line"> */</span><br><span class="line">private String subject;</span><br><span class="line">/**</span><br><span class="line"> * 邮件内容</span><br><span class="line"> */</span><br><span class="line">private String content;</span><br><span class="line">/**</span><br><span class="line"> * 邮件附件</span><br><span class="line"> */</span><br><span class="line">private String supplement;</span><br><span class="line"></span><br><span class="line">public String getFromAddress() &#123;</span><br><span class="line">return fromAddress;</span><br><span class="line">&#125;</span><br><span class="line">public void setFromAddress(String fromAddress) &#123;</span><br><span class="line">this.fromAddress = fromAddress;</span><br><span class="line">&#125;</span><br><span class="line">public String getToAddress() &#123;</span><br><span class="line">return toAddress;</span><br><span class="line">&#125;</span><br><span class="line">public void setToAddress(String toAddress) &#123;</span><br><span class="line">this.toAddress = toAddress;</span><br><span class="line">&#125;</span><br><span class="line">public String getSubject() &#123;</span><br><span class="line">return subject;</span><br><span class="line">&#125;</span><br><span class="line">public void setSubject(String subject) &#123;</span><br><span class="line">this.subject = subject;</span><br><span class="line">&#125;</span><br><span class="line">public String getContent() &#123;</span><br><span class="line">return content;</span><br><span class="line">&#125;</span><br><span class="line">public void setContent(String content) &#123;</span><br><span class="line">this.content = content;</span><br><span class="line">&#125;</span><br><span class="line">public String getSupplement() &#123;</span><br><span class="line">return supplement;</span><br><span class="line">&#125;</span><br><span class="line">public void setSupplement(String supplement) &#123;</span><br><span class="line">this.supplement = supplement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;EmailProduct [fromAddress=&quot; + fromAddress + &quot;, toAddress=&quot; + toAddress + &quot;, subject=&quot; + subject</span><br><span class="line">+ &quot;, content=&quot; + content + &quot;, supplement=&quot; + supplement + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.model.builder;</span><br><span class="line">/**</span><br><span class="line"> * 客户端</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @time 2017年12月30日上午11:45:53</span><br><span class="line"> * @version glmapper_v1.0</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MainTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new Director().construct();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">建造发件人信息组件...</span><br><span class="line">建造收件人信息组件...</span><br><span class="line">建造邮件主题信息组件...</span><br><span class="line">建造邮件内容信息组件...</span><br><span class="line">建造邮件附件信息组件...</span><br><span class="line">（为了方便看，这里把结果的显示做了调整）</span><br><span class="line">EmailProduct ：</span><br><span class="line">[</span><br><span class="line">    fromAddress=00001111@glmapper.com,</span><br><span class="line">    toAddress=00001112@glmapper.com,</span><br><span class="line">    subject=给大佬的一封建造者模式的Demo,</span><br><span class="line">    content=我写了一个建造者模式的例子，希望大佬给点意见,</span><br><span class="line">    supplement=附件：BuilderDemo.rar</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="建造者模式的关注点"><a href="#建造者模式的关注点" class="headerlink" title="建造者模式的关注点"></a>建造者模式的关注点</h2><p>有些情况下，一个对象会有一些重要的性质，在他们没有恰当的值之前，对象不能作为一个完整的产品来使用。就如上面发送一个电子邮件所示，电子邮件有发件人地址、收件人地址、主题、内容、附录等部分，而在收件人地址没有赋值之前，这个电子邮件是不能发送的。在某些情况下，一个对象的一些性质必须按照某个顺序赋值才有意义，在某个性质没有赋值之前，另一个性质则无法赋值。这些情况使得性质本身的建造涉及到复杂的业务逻辑。</p><p>而此时，对象相当于一个有待建造的产品，而对象的这些性质相当于产品的零件，建造产品的过程是建造零件的过程。由于建造零件的过程很复杂，因此，这些零件的健在过程往往会被“外部化”到另一个称作为建造者的对象里，建造者对象返回给客户端的是一个全部零件都建造完毕的产品对象。</p><p>在实际的应用过程中，建造者模式也有不同的变种，比如说省略抽象建造者角色或者省略导演者角色等等，在某些情况下，建造者模式可以通过省略某些角色来达到过度到模板方法模式。</p><p>OK，关于建造者模式的其他变种这里就不讨论了，留一个想象空间！（这段字代表一个微笑的表情(*￣︶￣)）</p><h2 id="java中建造者模式：JavaMail"><a href="#java中建造者模式：JavaMail" class="headerlink" title="java中建造者模式：JavaMail"></a>java中建造者模式：JavaMail</h2><p>JavaMail是一组J2SE的扩展API的一个类库，我们可以使用这个API来开发一个功能完备的电子邮件客户端软件。在JavaMail中就主要使用了建造者模式，当然还有我们上一篇中说道的抽象工厂模式。</p><h3 id="建造者模式在JavaMail中的使用"><a href="#建造者模式在JavaMail中的使用" class="headerlink" title="建造者模式在JavaMail中的使用"></a>建造者模式在JavaMail中的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.model.builder;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import javax.mail.Message;</span><br><span class="line">import javax.mail.Session;</span><br><span class="line">import javax.mail.Transport;</span><br><span class="line">import javax.mail.internet.InternetAddress;</span><br><span class="line">import javax.mail.internet.MimeMessage;</span><br><span class="line">/**</span><br><span class="line"> * 邮件发送-建造者模式</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @time 2017年12月30日下午2:04:46</span><br><span class="line"> * @version glmapper_v1.0</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MailSender &#123;</span><br><span class="line">private static MimeMessage message;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//基本属性</span><br><span class="line">String smptHost = &quot;smpt.xxx.com&quot;;</span><br><span class="line">String fromAddress = &quot;00001111@glmapper.com&quot;;</span><br><span class="line">String toAddress = &quot;00001112@glmapper.com&quot;;</span><br><span class="line">Properties p= new Properties();</span><br><span class="line">p.put(&quot;mail.smtp.host&quot;, smptHost);</span><br><span class="line">Session session = Session.getDefaultInstance(p);</span><br><span class="line">try &#123;</span><br><span class="line">InternetAddress to = new InternetAddress(toAddress);</span><br><span class="line">InternetAddress from = new InternetAddress(fromAddress);</span><br><span class="line">//创建message对象</span><br><span class="line">message = new MimeMessage(session);</span><br><span class="line">//下面就是组装零件的过程</span><br><span class="line">message.setFrom(from);</span><br><span class="line">message.setRecipient(Message.RecipientType.TO, to);</span><br><span class="line">message.setSubject(&quot;hello builder&quot;);</span><br><span class="line">message.setText(&quot;我写了一个建造者模式的例子，希望大佬给点意见&quot;);</span><br><span class="line"></span><br><span class="line">Transport.send(message);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK,建造者模式就到这里了!</p>]]></content>
      
      
      <categories>
          
          <category> 架构之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring源码系列-容器刷新</title>
      <link href="/2018/11/10/spring-base-context-refresh/"/>
      <url>/2018/11/10/spring-base-context-refresh/</url>
      
        <content type="html"><![CDATA[<p><code>Spring对于程序员说来说都不陌生；作为一个强大的开源技术，帮助我们能够更好的进行项目的开发与维护。</code></p><p>上次在Spring的启动过程文章中对Spring的启动过程做了一个较为详细的说明和分析。那么在实际的过程中，Spring的启动实际上就是Spring容器的初始化过程。本文将从源码的角度结合自己断点执行过程中保留的现场来分析一下容器的刷新过程（主要分析前几个方法，后面几个会分开来说）。</p><p>Spring的启动是通过ContextLoaderListener来进行的，在ContextLoaderListener中通过委托父类ContextLoader的initWebApplicationContext来完成具体的初始化过程。具体的启动过程可以看下之前的那篇文章。</p><p>在initWebApplicationContext方法是用来创建容器的，核心代码如下：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/160878791bfd4866?w=776&amp;h=306&amp;f=png&amp;s=21620" alt=""><br>今天主要来看configureAndRefreshWebApplicationContext方法中最后的wac.refresh()到底发生了哪些事;</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/1608789936e4812b?w=656&amp;h=628&amp;f=png&amp;s=37436" alt=""></p><h3 id="1、obtainFreshBeanFactory：BeanFactory的刷新和创建"><a href="#1、obtainFreshBeanFactory：BeanFactory的刷新和创建" class="headerlink" title="1、obtainFreshBeanFactory：BeanFactory的刷新和创建"></a>1、obtainFreshBeanFactory：BeanFactory的刷新和创建</h3><p>refresh()方法主要为IoC容器Bean的生命周期管理提供条件，Spring IoC容器载入Bean定义资源文件从其子类容器的refreshBeanFactory()方法启动，所以整个refresh()中“ConfigurableListableBeanFactory beanFactory =obtainFreshBeanFactory();”这句以后代码的都是注册容器的信息源和生命周期事件，载入过程就是从这句代码启动。<br>AbstractApplicationContext的obtainFreshBeanFactory()方法调用子类容器的refreshBeanFactory()方法，启动容器载入Bean定义资源文件的过程。<br>refresh()方法的作用是：在创建IoC容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IoC容器。refresh的作用类似于对IoC容器的重启，在新建立好的容器中对容器进行初始化，对Bean定义资源进行载入。<br>和refreshBeanFactory方法类似，载入Bean定义的方法loadBeanDefinitions也使用了委派模式，在AbstractRefreshableApplicationContext类中只定义了抽象方法，具体的实现调用子类容器中的方法实现。</p><p><strong>//通知子类去刷新内部bean 工厂</strong></p><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/160878ba771d7cb0?w=627&amp;h=229&amp;f=png&amp;s=12991" alt=""><br>再来看refreshBeanFactory</p><p><code>此实现执行该上下文的底层bean工厂的实际刷新，关闭以前的bean工厂（如果有的话），并为上下文生命周期的下一阶段初始化一个新的bean工厂。</code></p><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/160878cb0149042c?w=881&amp;h=366&amp;f=png&amp;s=21522" alt=""></p><p><strong>customizeBeanFactory(DefaultListableBeanFactory beanFactory)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">        //通过当前上下文来自定义内部bean工厂&lt;br&gt;</span><br><span class="line"> * Customize the internal bean factory used by this context.</span><br><span class="line"> * Called for each &#123;@link #refresh()&#125; attempt.</span><br><span class="line"> * &lt;p&gt;The default implementation applies this context&apos;s</span><br><span class="line"> * &#123;@linkplain #setAllowBeanDefinitionOverriding &quot;allowBeanDefinitionOverriding&quot;&#125;</span><br><span class="line"> * and &#123;@linkplain #setAllowCircularReferences &quot;allowCircularReferences&quot;&#125; settings,</span><br><span class="line"> * if specified. Can be overridden in subclasses to customize any of</span><br><span class="line"> * &#123;@link DefaultListableBeanFactory&#125;&apos;s settings.</span><br><span class="line"> * @param beanFactory the newly created bean factory for this context</span><br><span class="line"> * @see DefaultListableBeanFactory#setAllowBeanDefinitionOverriding</span><br><span class="line"> * @see DefaultListableBeanFactory#setAllowCircularReferences</span><br><span class="line"> * @see DefaultListableBeanFactory#setAllowRawInjectionDespiteWrapping</span><br><span class="line"> * @see DefaultListableBeanFactory#setAllowEagerClassLoading</span><br><span class="line"> */</span><br><span class="line">protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123;</span><br><span class="line">if (this.allowBeanDefinitionOverriding != null) &#123;</span><br><span class="line">beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);</span><br><span class="line">&#125;</span><br><span class="line">if (this.allowCircularReferences != null) &#123;</span><br><span class="line">beanFactory.setAllowCircularReferences(this.allowCircularReferences);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XmlWebApplicationContext类中loadBeanDefinitions（beanFactory）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;</span><br><span class="line">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span><br><span class="line">XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">// Configure the bean definition reader with this context&apos;s</span><br><span class="line">// resource loading environment.</span><br><span class="line">beanDefinitionReader.setEnvironment(getEnvironment());</span><br><span class="line">beanDefinitionReader.setResourceLoader(this);</span><br><span class="line">beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span><br><span class="line"></span><br><span class="line">// Allow a subclass to provide custom initialization of the reader,</span><br><span class="line">// then proceed with actually loading the bean definitions.</span><br><span class="line">initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AbstractApplicationContext调用loadBeanDefinitions(DefaultListableBeanFactory beanFactory) ，此方法根据首先创建XmlBeanDefinitionReader对象，然后配置该对象的上下文和资源加载环境，同时调用子类实现的initBeanDefinitionReader对XmlBeanDefinitionReader进行个性化配置，最近后入到initBeanDefinitionReader(beanDefinitionReader)的调用：</p><ol><li>据给定的BeanFactory创建XmlBeanDefinitionReader 对象  </li><li>配置beanDefinitionReader的上下文和资源加载环境  </li><li>用子类实现的initBeanDefinitionReader对XmlBeanDefinitionReader进行个性化配置initBeanDefinitionReader(beanDefinitionReader);  </li><li>调用载入Bean定义的方法，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器  </li></ol><p><strong>装载bean定义通过XmlBeanDefinitionReader。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Create a new XmlBeanDefinitionReader for the given BeanFactory. 通过给定的bean工厂创建一个新的XmlBeanDefinitionReader</span><br><span class="line">1.XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">2.使用上下文的资源加载环境配置bean定义读取器。</span><br><span class="line">   beanDefinitionReader.setEnvironment(getEnvironment());</span><br><span class="line">   beanDefinitionReader.setResourceLoader(this);</span><br><span class="line">   beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span><br><span class="line">3.允许子类提供reader的自定义初始化，然后继续实际加载bean定义。</span><br><span class="line">    //通过制定的XmlBeanDefinitionReader来载入beandefinitionReader </span><br><span class="line">   initBeanDefinitionReader(beanDefinitionReader)</span><br><span class="line">   // 通过制定的XmlBeanDefinitionReader来载入bean definitions</span><br><span class="line">   loadBeanDefinitions(beanDefinitionReader)</span><br></pre></td></tr></table></figure><p>AbstractApplicationContext调用loadBeanDefinitions(beanDefinitionReader)，这个方法是取得资源或资源路径然后通过传入的reader去加载BeanDefinitions。<br><img src="https://user-gold-cdn.xitu.io/2017/12/24/160879563687ab72?w=997&amp;h=205&amp;f=png&amp;s=22629" alt=""></p><h3 id="2、loadBeanDefinitions"><a href="#2、loadBeanDefinitions" class="headerlink" title="2、loadBeanDefinitions"></a>2、loadBeanDefinitions</h3><p>目前使用Spring的配置都是基于XML的，因此使用XmlBeanDefinitionReader 中的loadBeanDefinitions方法。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/1608797d7481bc37?w=583&amp;h=112&amp;f=png&amp;s=7511" alt=""><br><img src="https://user-gold-cdn.xitu.io/2017/12/24/160879802355b9b2?w=799&amp;h=444&amp;f=png&amp;s=27799" alt=""><br>看doLoadBeanDefinitions,这个就是具体的读取文件配置，然后注册成Bean</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087994cca671ae?w=578&amp;h=141&amp;f=png&amp;s=9005" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/1608799702d1a27a?w=778&amp;h=467&amp;f=png&amp;s=29776" alt=""></p><h3 id="3、prepareBeanFactory"><a href="#3、prepareBeanFactory" class="headerlink" title="3、prepareBeanFactory"></a>3、prepareBeanFactory</h3><p>配置工厂的标准上下文特性，如上下文的类装载器和后处理器。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/160879d74f10ac5c?w=810&amp;h=569&amp;f=png&amp;s=52456" alt=""></p><ul><li>告诉内部bean工厂使用上下文的类装入器等。</li><li>上下文回调配置bean工厂。</li><li>BeanFactory接口未登记为普通工厂的解析式。MessageSource登记（为自动装配创建）作为一个Bean</li><li>如果创建；就去寻找LoadTimeWeaver，然后准备组织</li><li>注册默认环境bean。</li></ul><p>通过断点来看下当前的beanFactory</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/160879dad75a8048?w=612&amp;h=583&amp;f=png&amp;s=53737" alt=""><br><img src="https://user-gold-cdn.xitu.io/2017/12/24/160879ed5cdaef5f?w=604&amp;h=560&amp;f=png&amp;s=49027" alt=""><br>继续执行…</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087a04fe33eb56?w=752&amp;h=168&amp;f=png&amp;s=14279" alt=""><br><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087a06f5fb4c2e?w=808&amp;h=188&amp;f=png&amp;s=22508" alt=""><br>beanDefinitionMap</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087a1b5ada4189?w=1191&amp;h=413&amp;f=png&amp;s=48945" alt=""><br>manualSingletonNames</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087a204892dc0a?w=782&amp;h=306&amp;f=png&amp;s=32662" alt=""></p><h3 id="4、postProcessBeanFactory"><a href="#4、postProcessBeanFactory" class="headerlink" title="4、postProcessBeanFactory"></a>4、postProcessBeanFactory</h3><p>注册web特性的全局域</p><p><strong>1).registerWebApplicationScopes</strong><br><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087a32aa0195bc?w=855&amp;h=201&amp;f=png&amp;s=15426" alt=""><br>注册具有web特性的域；包括：”request”, “session”, “globalSession”, “application”</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087a462ab9a807?w=824&amp;h=408&amp;f=png&amp;s=35130" alt=""><br>看下存储结构：<br><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087a48b52b1efb?w=530&amp;h=46&amp;f=png&amp;s=3519" alt=""><br>registerScope方法<br><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087a4cda81d6b1?w=809&amp;h=140&amp;f=png&amp;s=11295" alt=""><br><strong>2).registerEnvironmentBeans</strong></p><p>注册web特性 环境bean（“contextparameters”、“ContextAttribute”）与给定的WebApplicationContext使用BeanFactory。</p><p>1.servletContext<br><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087a7c6281aca0?w=1220&amp;h=401&amp;f=png&amp;s=52028" alt=""><br>2.servletConfig<br><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087a98a9e47514?w=1224&amp;h=255&amp;f=png&amp;s=38217" alt=""><br>3.registerSingleton</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087ac67b8a29be?w=773&amp;h=308&amp;f=png&amp;s=31414" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087ac95dcd1938?w=1071&amp;h=246&amp;f=png&amp;s=34326" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087acbf2427eda?w=880&amp;h=305&amp;f=png&amp;s=34889" alt=""><br>这里是找到了我们默认的配置文件参数：<br><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087aceb75503c0?w=796&amp;h=334&amp;f=png&amp;s=52552" alt=""><br>beanName=contextParameters</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087af2fc1441a9?w=689&amp;h=172&amp;f=png&amp;s=11770" alt=""><br><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087af4eefec01f?w=1127&amp;h=165&amp;f=png&amp;s=26627" alt=""><br><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087af6a105d944?w=886&amp;h=269&amp;f=png&amp;s=34219" alt=""><br>最后是将contextAttributes放入；contextAttributes中包含的属性值比较多，具体如下面所示：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087b0058a9d783?w=931&amp;h=258&amp;f=png&amp;s=37259" alt=""><br>主要包括：<br>javax.servlet.context.tempdir,<br>org.apache.catalina.resources, org.springframework.web.context.support.ServletContextScope, org.apache.tomcat.util.scan.MergedWebXml,<br>org.apache.tomcat.InstanceManager,<br>org.apache.catalina.jsp_classpath,<br>javax.websocket.server.ServerContainer,<br>org.apache.tomcat.JarScanner</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087b145d6705ce?w=1123&amp;h=223&amp;f=png&amp;s=28111" alt=""><br>这里是把需要的东西全部载入进来了，有很多。就不贴了(mime-mapping)….</p><h3 id="5、invokeBeanFactoryPostProcessors"><a href="#5、invokeBeanFactoryPostProcessors" class="headerlink" title="5、invokeBeanFactoryPostProcessors"></a>5、invokeBeanFactoryPostProcessors</h3><p><strong>BeanDefinitionRegistryPostProcessor实例化</strong>：标准BeanFactoryPostProcessor的扩展，BeanFactoryPostProcessor的作用是用来进一步定义注册的BeanDefinition，IoC容器本质就是Bean管理，所以BeanFactoryPostProcessor本身也是Bean，要对BeanFactoryPostProcessor的BeanDefinition进一步定义就通过BeanDefinitionRegistryPostProcessor进行注册，BeanDefinitionRegistryPostProcessor及其子类是Ioc容器最实例化的一类Bean。它们在ConfigurableApplicationContext（ApplicationContext子接口）实现类调用refresh()方法调用invokeBeanFactoryPostProcessors(beanFactory);方法时就被实例化。</p><p>OK，今天关于这部分的分析就到此结束了，后面的过程会在下一篇Spring系列文章中继续来讲refresh中的过程。</p><p><code>如果您对系列文章有任何意见，可以给我留言，感谢大家。</code></p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>菜鸟成长系列-工厂模式</title>
      <link href="/2018/11/10/java-design-model-factory/"/>
      <url>/2018/11/10/java-design-model-factory/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.im/post/59feb9296fb9a0451a75c21e" target="_blank" rel="noopener">菜鸟成长系列-面向对象的四大基础特性</a><br><br><a href="https://juejin.im/post/5a0d60ee6fb9a045272525af" target="_blank" rel="noopener">菜鸟成长系列-多态、接口和抽象类</a><br><br><a href="https://juejin.im/post/5a2bad01518825619a029c0e" target="_blank" rel="noopener">菜鸟成长系列-面向对象的6种设计原则</a><br><br><a href="https://juejin.im/post/5a366d756fb9a045076fc04f" target="_blank" rel="noopener">菜鸟成长系列-单例模式</a></p><p><code>上一篇我们已经对创建型模式中的单例模式进行了学习，今天来学习另外一个比较重要并且经常使用的模式-工厂模式；工厂模式专门负责将大量有共同接口的类实例化。其可以动态的决定将哪一个类实例化，不必事先知道每次要实例化哪一个类。</code></p><p>工厂模式具有以下三种形态：</p><ul><li>简单工厂模式：又称静态工厂模式</li><li>工厂方法模式：又称多态性工厂模式或者虚拟构造子模式</li><li>抽象工厂模式：又称工具箱模式</li></ul><p>本篇文章将对这三种形态的工厂模式进行一些基本的学习，并通过例子来直观的感受下不同形态的具体实现方式。最后再分析下JAVA以及Spring中是如何使用的。</p><h2 id="1、简单工厂模式"><a href="#1、简单工厂模式" class="headerlink" title="1、简单工厂模式"></a>1、简单工厂模式</h2><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/160864d040dbd467?w=444&amp;h=258&amp;f=png&amp;s=7739" alt=""><br>从上图可以看出，简单工厂模式涉及到工厂角色、抽象产品角色以及具体产品角色等三个角色。各角色职能如下：</p><ul><li>工厂类：担任这个角色的是工厂方法模式的核心，含有与应用紧密相关的具体业务逻辑。工厂类在客户端的直接调用下创建产品对象，它往往由一个具体的java类实现</li><li>抽象产品：担任这个角色的类是工厂方法模式所创建的对象的父类，或它们共同拥有的接口。抽象产品角色可以用一个java接口或者抽象类来实现</li><li>具体产品：工厂方法模式所创建的任何对象都是这个角色的实例，具体产品角色由一个java类实现</li></ul><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/160873bd0f72bce6?w=637&amp;h=247&amp;f=png&amp;s=61193" alt=""><br>来看例子，考虑到今天有小伙伴来我这做客，本demo将以做菜来实现一波。首先工厂就是厨房，抽象类就是笼统的菜，实现类就是具体哪个菜。</p><ul><li><p>抽象产品</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.factory;</span><br><span class="line">/**</span><br><span class="line"> * 抽象类角色：food接口，约束类型</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月24日上午10:38:36</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public interface IFood &#123;</span><br><span class="line">/**</span><br><span class="line"> * 提供一个展示食物细节的方法</span><br><span class="line"> * @param foodName 食物名称</span><br><span class="line"> */</span><br><span class="line">public void showFood();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体产品-鱼</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.factory;</span><br><span class="line">/**</span><br><span class="line"> * 具体产品-食物鱼</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月24日上午10:51:29</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class FishFood implements IFood</span><br><span class="line">&#123;</span><br><span class="line">@Override</span><br><span class="line">public void showFood() &#123;</span><br><span class="line">System.out.println(&quot;一盘鱼&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体产品-土豆丝</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.factory;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * 具体食物：土豆丝</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月24日上午10:47:17</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ShreddedPotatoesFood implements IFood&#123;</span><br><span class="line">@Override</span><br><span class="line">public void showFood() &#123;</span><br><span class="line">System.out.println(&quot;一盘土豆丝&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>工厂角色 - 食物工厂</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.factory;</span><br><span class="line">/**</span><br><span class="line"> * 工厂角色-食物工厂</span><br><span class="line"> * </span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月24日上午10:41:10</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SimpleFoodFactory &#123;</span><br><span class="line">/**</span><br><span class="line"> * 提供一个静态方法，用于获取食物</span><br><span class="line"> * @param foodType 食物类型</span><br><span class="line"> * @return 具体食物</span><br><span class="line"> */</span><br><span class="line">public static IFood getFood(String foodType)&#123;</span><br><span class="line">IFood food = null;</span><br><span class="line">if (foodType.equals(&quot;fish&quot;)) &#123;</span><br><span class="line">food = new FishFood();</span><br><span class="line">&#125;</span><br><span class="line">if (foodType.equals(&quot;potatoes&quot;)) &#123;</span><br><span class="line">food = new ShreddedPotatoesFood();</span><br><span class="line">&#125;</span><br><span class="line">return food;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.factory;</span><br><span class="line">/**</span><br><span class="line"> * 客户端</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月24日上午10:45:17</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MainTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">IFood fishfood = SimpleFoodFactory.getFood(&quot;fish&quot;);</span><br><span class="line">fishfood.showFood();</span><br><span class="line"></span><br><span class="line">IFood potatoesfood = SimpleFoodFactory.getFood(&quot;potatoes&quot;);</span><br><span class="line">potatoesfood.showFood();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一盘鱼</span><br><span class="line">一盘土豆丝</span><br></pre></td></tr></table></figure><p>OK，菜做完了，可以吃了。。。</p><p>我们来讨论下简单工厂模式的优缺点：</p><p><code>优点：模式的核心是工厂类，这个类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例。而客户端则可以免除直接创建产品对象的责任，而仅仅负责消费产品即可。用一句话来说就是：简单工厂模式这个做法实现了对责任的分割。</code><br><br><code>缺点：集中了所有产品的创建逻辑，形成了一个无所不能的全职类，但是之前我们在讨论设计原则的时候说过，我们要尽量避免这种情况的发生，这种就很明显破坏了单一职责这条原则，另外也不满足开闭原则的约束。当我们需要进行品类扩展时，我们需要不断的去修改我们的工厂的业务逻辑，一方面是工厂类会急速的膨胀，另一方面因为囊括了不同的产品对于我们后期的维护造成一定的影响。</code></p><h2 id="2、工厂方法模式"><a href="#2、工厂方法模式" class="headerlink" title="2、工厂方法模式"></a>2、工厂方法模式</h2><p>这个时候一个同事说他是南方人，另外一个同事说他是北方人，吃不惯今天的菜。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/160873c493ae7259?w=400&amp;h=292&amp;f=jpeg&amp;s=16450" alt=""><br>好吧，既然这样，那我就只能点外卖了。。。但是为了防止他们变卦自己的家乡，我需要做一个计划，下面就是计划图：<br><img src="https://user-gold-cdn.xitu.io/2017/12/24/1608709a15936dea?w=626&amp;h=366&amp;f=png&amp;s=16564" alt=""></p><p>从上图中我们可以看出，工厂方法模式的角色包括以下几种：</p><ul><li>抽象工厂：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。</li><li>具体工厂：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建产品对象。</li><li>抽象产品：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口</li><li>具体产品：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应。</li></ul><p>因为我的同事都是来自不同地方的，他们的口味也都不一样，但是呢同事都是第一次来我家吃饭，所以为了招待周全，根据同事不同的口味叫不同口味的鱼。</p><ul><li><p>抽象工厂角色：获取食物</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.factory;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * 角色1：抽象工厂 - 负责获取食物</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月24日下午1:59:28</span><br><span class="line"> */</span><br><span class="line">public interface MethodFoodFactory &#123;</span><br><span class="line">//获取食物的方法</span><br><span class="line">public IFishFood getFood();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体工厂1：获取南方食物-鱼</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.factory;</span><br><span class="line">/**</span><br><span class="line"> * 南方口味外卖 - 鱼</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月24日下午2:03:36</span><br><span class="line"> */</span><br><span class="line">public class SouthFishFactory implements MethodFoodFactory&#123;</span><br><span class="line">@Override</span><br><span class="line">public IFishFood getFood() &#123;</span><br><span class="line">return new SouthFishFood();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体工厂2：获取北方食物-鱼</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.factory;</span><br><span class="line">/**</span><br><span class="line"> * 北方口味外卖 - 鱼</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月24日下午2:03:36</span><br><span class="line"> */</span><br><span class="line">public class NorthFishFactory implements MethodFoodFactory&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public IFishFood getFood() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new NorthFishFood();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体产品1：南方食物- 鱼</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.factory;</span><br><span class="line">/**</span><br><span class="line"> * 南方口味-鱼</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月24日下午2:16:17</span><br><span class="line"> */</span><br><span class="line">public class SouthFishFood implements IFishFood&#123;</span><br><span class="line">@Override</span><br><span class="line">public void showFood() &#123;</span><br><span class="line">System.out.println(&quot;来自南方厨师做的鱼&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体产品2：北方食物-鱼</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.factory;</span><br><span class="line">/**</span><br><span class="line"> * 北方口味  - 鱼</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月24日下午2:12:55</span><br><span class="line"> */</span><br><span class="line">public class NorthFishFood implements IFishFood &#123;</span><br><span class="line">@Override</span><br><span class="line">public void showFood() &#123;</span><br><span class="line">System.out.println(&quot;来自北方厨师做的鱼&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.factory;</span><br><span class="line">/**</span><br><span class="line"> * 客户端</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月24日上午10:45:17</span><br><span class="line"> */</span><br><span class="line">public class MainTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//点一个南方口味外卖</span><br><span class="line">MethodFoodFactory southFoodFactory = new SouthFishFactory();</span><br><span class="line">//点一个北方口味外卖</span><br><span class="line">MethodFoodFactory northFoodFactory = new NorthFishFactory();</span><br><span class="line">//拿到南方口味外卖鱼</span><br><span class="line">southFoodFactory.getFood().showFood();</span><br><span class="line">//拿到北方口味外卖鱼</span><br><span class="line">northFoodFactory.getFood().showFood();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">来自南方厨师做的鱼</span><br><span class="line">来自北方厨师做的鱼</span><br></pre></td></tr></table></figure></li></ul><p>OK，这样我们就满足了不同区域同时关于鱼口味的需求了，以后升值加薪就指望他们了。。。</p><p>关于工厂方法模式的优缺点：</p><p><code>优点：</code><br><br><code>1、  在工厂方法中，用户只需要知道所要产品的具体工厂，无须关系具体的创建过程，甚至不需要具体产品类的类名。</code><br><br><code>2、  在系统增加新的产品时，我们只需要添加一个具体产品类和对应的实现工厂，无需对原工厂进行任何修改，很好地符合了“开闭原则”</code><br><br><code>缺点：</code><br><br><code>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，是的系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</code></p><h2 id="3、抽象工厂模式"><a href="#3、抽象工厂模式" class="headerlink" title="3、抽象工厂模式"></a>3、抽象工厂模式</h2><p>准备吃饭的时候突然又来了几位同事，而且他们有的喜欢吃酸菜鱼，有的喜欢吃红烧鱼，这就很头疼。于是，只能根据他们的需要继续点外卖。（这个就给出一个结构图，并且将每种角色都用具体的场景来说明了，具体的代码可以参考这个图例自己尝试一下。）</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/1608737380bd3c2f?w=781&amp;h=491&amp;f=png&amp;s=29480" alt=""><br>OK，终于可以吃饭了！</p><h2 id="4、三种形态的工厂模式在java中的使用"><a href="#4、三种形态的工厂模式在java中的使用" class="headerlink" title="4、三种形态的工厂模式在java中的使用"></a>4、三种形态的工厂模式在java中的使用</h2><h3 id="4-1、简单工厂模式在java中的使用"><a href="#4-1、简单工厂模式在java中的使用" class="headerlink" title="4.1、简单工厂模式在java中的使用"></a>4.1、简单工厂模式在java中的使用</h3><p>java.text.DateFormat （一个抽象类）这个类相信很多小伙伴都用到过，在java API中，这个类算是一个简单工厂模式的典型应用了（此处还是与上篇一样，不考虑期源码细节，也不介绍基本用法）。来看它的几个方法：</p><ul><li>public final static DateFormat getDateInstance()</li><li>public final static DateFormat getDateInstance(int style)</li><li>public final static DateFormat getDateInstance(int style, Locale aLocale)</li></ul><p>作为一个抽象类，却提供了很多的静态工厂方法，就像上面列举的那三个一样。有小伙伴可能会疑惑，为啥子一个抽象类阔以有自己的实例，并通过几个方法提供自己的实例。我们知道，抽象类是不可以有自己的实例对象的，但是需要注意的是，DateFormat的工厂方法是静态的，并不是普通的方法，也就是说，不需要通过创建实例对象的方式去调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final static DateFormat getDateInstance()</span><br><span class="line">&#123;</span><br><span class="line">    return get(0, DEFAULT, 2, Locale.getDefault(Locale.Category.FORMAT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getDateInstance方法并没有通过调用DateFormat的构造方法来创建对象。</p><h3 id="4-2、工厂方法模式在java中的应用"><a href="#4-2、工厂方法模式在java中的应用" class="headerlink" title="4.2、工厂方法模式在java中的应用"></a>4.2、工厂方法模式在java中的应用</h3><p>java.net.URL类，类图如下，<br><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087550e7bff0c2?w=701&amp;h=346&amp;f=png&amp;s=44805" alt=""><br>URL对象通过一个工厂方法openConnection()返回一个URLConnection类型的对象。URLConnection是一个抽象类，因此所返还的不可能是这个抽象类的实例，而必然是其具体子类的实例。</p><h3 id="4-3、抽象工厂模式在java中的应用"><a href="#4-3、抽象工厂模式在java中的应用" class="headerlink" title="4.3、抽象工厂模式在java中的应用"></a>4.3、抽象工厂模式在java中的应用</h3><p>根据java与模式一书的介绍，在java中使用抽象工厂模式的是 JAVA awt的peer架构，通过抽象工厂模式来构建分属于不同操作系统的peer构件。这个我也没用过，了解即可。</p><p>关于Spring中工厂模式的使用会在后续Spring源码分析系列中给大家详细分析，这里就不重复了。</p><p>今天的学习就到此结束了，祝大家周末愉快。话说今天平安夜，大家都是在家写代码吗？</p><p><code>如果您对系列文章有任何意见，可以给我留言，感谢大家。</code></p>]]></content>
      
      
      <categories>
          
          <category> 架构之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>菜鸟成长系列-单例模式</title>
      <link href="/2018/11/10/java-design-model-singleton/"/>
      <url>/2018/11/10/java-design-model-singleton/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.im/post/59feb9296fb9a0451a75c21e" target="_blank" rel="noopener">菜鸟成长系列-面向对象的四大基础特性</a><br><br><a href="https://juejin.im/post/5a0d60ee6fb9a045272525af" target="_blank" rel="noopener">菜鸟成长系列-多态、接口和抽象类</a><br><br><a href="https://juejin.im/post/5a2bad01518825619a029c0e" target="_blank" rel="noopener">菜鸟成长系列-面向对象的6种设计原则</a><br></p><p><code>前面已经将设计模式中的基本内容撸了一下，今天开始正式开始设计模式系列的内容，因为网上也有很多关于设计模式的技术博客，从不同的角度对设计模式都做了很详细的解读；本系列的模式除了基本的概念和模型之外，还会结合java自身使用的和Spring中使用的一些案例来进行学习分析。</code><br><br><code>水平有限，如果存在不当之处，希望大家多提意见，灰常感谢！</code><br><br>设计模式中总体分为三类:<br><br><strong>一、创建型(5)：</strong></p><ul><li>工厂方法[Factory Method]</li><li>抽象工厂[Abstract Factory]</li><li>原型[Prototype]</li><li>建造者[Builder]</li><li><a href="https://juejin.im/editor/drafts/5a366d756fb9a045076fc04f" target="_blank" rel="noopener">单例[Singleton]</a></li></ul><p>还有一个简单工厂[Simple  Factory]，目前有两种，有的把单例模式作为这5种之一，有的是将简单工厂作为这5种之一。这里不做讨论，原则上两个都是，只是划分规则不同。</p><p><strong>二、结构型(7)</strong></p><ul><li>适配器[Adapter]</li><li>桥接[Bridge]</li><li>组合[Composite]</li><li>装饰[Decorator]</li><li>外观[Facade]</li><li>享元[Flyweight]</li><li>代理[Proxy]</li></ul><p><strong>三、行为型(11)</strong></p><ul><li>策略[Strategy]</li><li>模板方法[Template method]</li><li>职责链[Chain of Responsibility]</li><li>迭代器[Iterator]</li><li>状态[State]</li><li>访问者[Visitor]</li><li>命令[Command]</li><li>备忘录[Memento]</li><li>观察者[Observer]</li><li>中介者[Mediator]</li><li>解释器[Interpreter]</li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><code>首先它是一种创建型模式，与其他模式区别在于：单例模式确保被创建的类只有一个实例对象，而且自行实例化并向整个系统提供这个实例。一般情况下我们称当前这个类为单例类。</code></p><p>从上面这段话中我们可以了解到，单例模式具备以下三个要点：</p><ul><li>某个类只能有一个实例</li><li>必须自行创建这个实例[具体的对象创建由类本身负责，其他类不负责当前类的创建]</li><li>必须向整个系统提供这个实例[也就是说，当前类需要对外提供一个获取当前实例的一个方法，且该方法不能是私有的]</li></ul><p>OK，来看单例模式的几种实现方式。</p><p><strong>方式一：饿汉式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.singleton;</span><br><span class="line">/**</span><br><span class="line"> * 单例模式-饿汉式</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月17日下午10:30:38</span><br><span class="line"> */</span><br><span class="line">public class EagerSingleton &#123;</span><br><span class="line">/**</span><br><span class="line"> * 内部直接提供一个eagerSingletonInstance；</span><br><span class="line"> * 我们知道，一般情况下，如果一个变量被static final修饰了，那么该变量将会被视为常量。</span><br><span class="line"> * 满足要点：自行创建</span><br><span class="line"> */</span><br><span class="line">private static final EagerSingleton eagerSingletonInstance = new EagerSingleton();</span><br><span class="line">/**</span><br><span class="line"> * 提供一个私有的构造函数，这样其他类就无法通过new</span><br><span class="line"> * EagerSingleton()来获取对象了，同样也保证了当前类不可以被继承</span><br><span class="line"> * 满足要点：某个类只能有一个实例</span><br><span class="line"> */</span><br><span class="line">private EagerSingleton()&#123;&#125;</span><br><span class="line">/**</span><br><span class="line"> * 对外提供一个获取实例的方法</span><br><span class="line"> * 满足要点：向整个系统提供这个实例</span><br><span class="line"> */</span><br><span class="line">public static EagerSingleton getInstance()&#123;</span><br><span class="line">return eagerSingletonInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>方式二：懒汉式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.singleton;</span><br><span class="line">/**</span><br><span class="line"> * 单例模式-懒汉式</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月17日下午10:45:54</span><br><span class="line"> */</span><br><span class="line">public class LazySingleton &#123;</span><br><span class="line">//提供一个私有静态变量，注意区别与饿汉式中的static final。</span><br><span class="line">private static LazySingleton lazySingletonInstance = null ;</span><br><span class="line">//同样需要提供一个私有的构造方法，其作用与饿汉式中的作用一样</span><br><span class="line">private LazySingleton()&#123;&#125;</span><br><span class="line">/**</span><br><span class="line"> * 1.使用synchronized来保证线程同步</span><br><span class="line"> * 2.实例的具体创建被延迟到第一次调用getInstance方法时来进行</span><br><span class="line"> * 3.如果当前实例已经存在，不再重复创建</span><br><span class="line"> */</span><br><span class="line">public synchronized static LazySingleton getInstance()&#123;</span><br><span class="line">if (lazySingletonInstance == null) &#123;</span><br><span class="line">lazySingletonInstance = new LazySingleton();</span><br><span class="line">&#125;</span><br><span class="line">return lazySingletonInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式单例类在自己被加载时就自己实例化了，即便加载器是静态的，在饿汉式单例类被加载时仍会将自己实例化。从资源利用角度来说，这个比懒汉式单例类稍微的差一些。如果从速度和响应时间来看，饿汉式就会比懒汉式好一些。懒汉式在单例类进行实例化时，必须处理好在多个线程同时首次引用此类时的访问限制问题。</p><p><strong>方式三：登记式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.singleton;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">/**</span><br><span class="line"> * 单例模式-登记式</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月17日下午10:58:36</span><br><span class="line"> */</span><br><span class="line">public class RegisterSingleton &#123;</span><br><span class="line">//提供一个私有的HashMap类型的registerSingletonInstance存储该RegisterSingleton类型的单例</span><br><span class="line">private static HashMap&lt;String,Object&gt; registerSingletonInstance = new HashMap&lt;&gt;();</span><br><span class="line">//通过static静态代码块来进行初始化RegisterSingleton当前类的实例，并将当前实例存入registerSingletonInstance</span><br><span class="line">static &#123;</span><br><span class="line">RegisterSingleton singleton = new RegisterSingleton();</span><br><span class="line">registerSingletonInstance.put(singleton.getClass().getName(), singleton);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 注意区别，此处提供的是非private类型的，说明当前类可以被继承</span><br><span class="line"> */</span><br><span class="line">protected RegisterSingleton()&#123;&#125;</span><br><span class="line">/**</span><br><span class="line"> * 获取实例的方法</span><br><span class="line"> */</span><br><span class="line">public static RegisterSingleton getInstance(String name)&#123;</span><br><span class="line">//如果name为空，则那么默认为当前类的全限定名</span><br><span class="line">if (name == null) &#123;</span><br><span class="line">name =&quot;com.glmapper.design.singleton.RegisterSingleton&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//如果map中没有查询到指定的单例，则将通过Class.forName(name)来创建一个实例对象，并存入map中</span><br><span class="line">if (registerSingletonInstance.get(name)==null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">registerSingletonInstance.put(name, Class.forName(name).newInstance());</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//返回实例</span><br><span class="line">return (RegisterSingleton) registerSingletonInstance.get(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登记式单例是Gof为了克服饿汉式和懒汉式单例类均不可被继承的缺点而设计的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.singleton;</span><br><span class="line">/**</span><br><span class="line"> * 登记式-单例-子类</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月17日下午11:14:03</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ChildRegisterSingleton extends RegisterSingleton</span><br><span class="line">&#123;</span><br><span class="line">/**</span><br><span class="line"> * 由于子类必须允许父类以构造方法调用产生实例，因此，子类的构造方法必须</span><br><span class="line"> * 是public类型的。但是这样一来，就等于说可以允许以new </span><br><span class="line"> * ChildRegisterSingleton()的方式产生实例，而不必在父类的登记中。</span><br><span class="line"> */</span><br><span class="line">public ChildRegisterSingleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">//客户端测试获取实例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ChildRegisterSingleton crs1 = (ChildRegisterSingleton) getInstance(</span><br><span class="line">&quot;com.glmapper.design.singleton.ChildRegisterSingleton&quot;);</span><br><span class="line">ChildRegisterSingleton crs2 = (ChildRegisterSingleton) getInstance(</span><br><span class="line">&quot;com.glmapper.design.singleton.ChildRegisterSingleton&quot;);</span><br><span class="line">System.out.println(crs1 == crs2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">返回：true   这个同志们可以自行验证，肯定是一样的。但是不能使用new，</span><br><span class="line">因为前提约束是，需在父类中登记的才是单例。</span><br></pre></td></tr></table></figure><p>方式四：双重检测模式，双重检测方式在某些书上或者文献中说对于java语言来说是不成立的，但是目前确实是通过某种技巧完成了在java中使用双重检测机制的单例模式的实现，；这种技巧后面来说；<code>关于为什么java语言对于双重检测成例不成立，大家可以在[BLOCH01]文献中看下具体情况。</code><br><br>先来看一个单线程模式下的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.singleton;</span><br><span class="line">/**</span><br><span class="line"> * 一个错误的单例例子</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月17日下午11:53:04</span><br><span class="line"> */</span><br><span class="line">public class DoubleCheckSingleton &#123;</span><br><span class="line">private static DoubleCheckSingleton instance=null;</span><br><span class="line">public static DoubleCheckSingleton getDoubleCheckSingleton()&#123;</span><br><span class="line">if (instance == null) &#123;</span><br><span class="line">instance = new DoubleCheckSingleton();</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个很明显是一个错误的例子，对于A/B两个线程，因为step 1并没有使用同步策略，因此线程A/B可能会同时进行// step 2，这样的话，就会可能创建两个对象。那么正确的方式如下：使用synchronized关键字来保证同步。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.singleton;</span><br><span class="line">/**</span><br><span class="line"> * 这是一个正确的打开方式哦。。。</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月17日下午11:53:04</span><br><span class="line"> */</span><br><span class="line">public class DoubleCheckSingleton &#123;</span><br><span class="line">private static DoubleCheckSingleton instance=null;</span><br><span class="line">//使用synchronized来保证getDoubleCheckSingleton同一时刻只能被一个线程访问</span><br><span class="line">public synchronized static DoubleCheckSingleton getDoubleCheckSingleton()&#123;</span><br><span class="line">if (instance == null) &#123;</span><br><span class="line">instance = new DoubleCheckSingleton();</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式虽然保证了线程安全性，但是也存在另外一种问题：同步化操作仅仅在instance首次初始化操作之前会起到作用，如果instance已经完成了初始化，对于getDoubleCheckSingleton每一次调用来说都会阻塞其他线程，造成一个不必要的瓶颈。那我们就通过使用更加细粒度化的锁，来适当的减小额外的开销。OK，下面再来一个错误的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.singleton;</span><br><span class="line">/**</span><br><span class="line"> * 一个错误的单例例子</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月17日下午11:53:04</span><br><span class="line"> */</span><br><span class="line">public class DoubleCheckSingleton &#123;</span><br><span class="line">private static DoubleCheckSingleton instance=null;</span><br><span class="line">//使用synchronized来保证getDoubleCheckSingleton同一时刻只能被一个线程访问</span><br><span class="line">public static DoubleCheckSingleton getDoubleCheckSingleton()&#123;</span><br><span class="line">if (instance == null) &#123;  //1</span><br><span class="line">    // B线程检测到uniqueInstance不为空</span><br><span class="line">synchronized (DoubleCheckSingleton.class) &#123; //2</span><br><span class="line">if (instance == null) &#123; //3</span><br><span class="line">instance = new DoubleCheckSingleton();//4</span><br><span class="line">// A线程被指令重排了，刚好先赋值了；但还没执行完构造函数。</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 后面B线程执行时将引发：对象尚未初始化错误。</span><br><span class="line">return instance;//5</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来没什么毛病呀？我们来分析，两个线程A和B，同时到达1,且都通过了1的检测。此时A到了4，B在2。此时B线程检测到instance不为空，A线程被指令重排了，刚好先赋值了；但还没执行完构造函数；再接下来B线程执行时将引发：对象尚未初始化错误（5）。</p><p>对于上面的问题，我们可以通过volatile关键字来修饰instance对象，来保证instance对象的内存可见性和防止指令重排序。这个也就是前面说到的“技巧”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static DoubleCheckSingleton instance=null;</span><br><span class="line">改为：</span><br><span class="line">private static volatile DoubleCheckSingleton instance=null;</span><br></pre></td></tr></table></figure><p>本篇将单例模式的几种情况进行了分析。后面将会对将java中和Spring中所使用的单例场景进行具体的案例分析。</p><h2 id="JAVA中的单例模式使用"><a href="#JAVA中的单例模式使用" class="headerlink" title="JAVA中的单例模式使用"></a>JAVA中的单例模式使用</h2><p>JAVA中对于单例模式的使用最经典的就是RunTime这个类。<br><img src="https://user-gold-cdn.xitu.io/2017/12/23/160822319952bbf9?w=585&amp;h=219&amp;f=png&amp;s=94731" alt=""><br><img src="https://user-gold-cdn.xitu.io/2017/12/23/16082235b1827b2c?w=653&amp;h=316&amp;f=png&amp;s=138718" alt=""><br>注释解读：每个Java应用程序都有一个Runtime类的单个实例，允许应用程序与运行应用程序的环境进行交互。 当前运行时可以从getRuntime方法获得。应用程序不能创建它自己的这个类的实例。</p><p>看过上篇文章的小伙伴可能比较清楚，这里RunTime使用的是懒汉式单例的方式来创建的。Runtime提供了一个静态工厂方法getRuntime方法用于获取Runtime实例。Runtime这个类的具体源码分析和只能此处不做分析。</p><h2 id="Spring中的单例"><a href="#Spring中的单例" class="headerlink" title="Spring中的单例"></a>Spring中的单例</h2><p>Spring依赖注入Bean实例默认是单例的。Spring中bean的依赖注入都是依赖AbstractBeanFactory的getBean方法来完成的。那我们就来看看在getBean中都发生了什么。</p><p><strong>org.springframework.beans.factory.suppor.AbstractBeanFactory</strong><br><img src="https://user-gold-cdn.xitu.io/2017/12/23/1608240b1b8b27b1?w=794&amp;h=500&amp;f=png&amp;s=266167" alt=""><br>从上面这张图中我们啥也看不出，只知道在getBean中又调用了doGetBean方法（Spring中还有java源码中有很多类似的写法，好处在于我们可以通过子类继承，继而编写我们自己的处理逻辑）。OK，再来看看doGetBean方法。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/23/16082466281582ea?w=813&amp;h=270&amp;f=png&amp;s=162783" alt=""><br>来看下这个方法的注释：<strong>返回指定的bean可以共享或独立的实例</strong> （谷歌+有道+百度）</p><ul><li>name:要检索的bean的名称</li><li>requiredType:要检索的bean所需的类型</li><li>args:如果使用静态工厂方法的显式参数创建原型，则使用参数。 在其他情况下使用非空args值是无效的。</li><li>typeCheckOnly:获得实例是否是为了类型检查，而不是实际的使用</li></ul><p>这个方法体内的代码非常的多，那么我们本文不是来学习Spring的，所以我们只看我们关心的部分，<br><img src="https://user-gold-cdn.xitu.io/2017/12/23/160824f12ec92598?w=571&amp;h=39&amp;f=png&amp;s=4554" alt=""><br><strong>为手工注册的singleton检查单例缓存。</strong>,从这个注释可以看出，此处就是我们获取实例的地方，再往下看。</p><p>此处和上面的getBean一样，也是通过模板方法的方式进行调用的。<br><img src="https://user-gold-cdn.xitu.io/2017/12/23/1608251887dbdedd?w=496&amp;h=72&amp;f=png&amp;s=26281" alt=""><br>OK，这里我们看到了获取单例实例的具体实现过程。<br><strong>返回注册在给定名称下的(原始的)singleton对象。检查已经实例化的单例，并且还允许提前引用当前创建的单例（解析循环引用）。</strong><br><img src="https://user-gold-cdn.xitu.io/2017/12/23/1608251b22075527?w=748&amp;h=451&amp;f=png&amp;s=254552" alt=""><br>这里使用的是饿汉式中的双重检测机制来实现的。</p><p>OK，至此单例模式的学习就结束了，下一篇文章将会介绍工厂模式（简单工厂，工厂方法，抽象工厂）。</p>]]></content>
      
      
      <categories>
          
          <category> 架构之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>怎么写一个死锁？</title>
      <link href="/2018/11/10/java-base-thread-deadlock/"/>
      <url>/2018/11/10/java-base-thread-deadlock/</url>
      
        <content type="html"><![CDATA[<p>刚把手头上的项目代码撸完，闲来看看博客，然后就看到了线程这块的东西。之前有简单的记录过线程和进行的零碎知识。<br><br><a href="https://juejin.im/post/59d9a22a6fb9a00a4171b395" target="_blank" rel="noopener">JAVA基础知识系列—进程、线程安全</a></p><p>看着看着就想着怎么能写一个死锁呢，打开eclipse，突然感觉无从下手；之前都是一直在解决阻塞、死锁这些问题，现在反过来去写一个死锁感觉有点莫名奇妙。。。</p><p>ok,写一个死锁就要有一种场景，并且满足死锁的条件。</p><ul><li>互斥条件：一个资源每次只能被一个进程使用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li><li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul><p>首先要有竞争的资源，并且两个线程要同时都在等待对方释放资源。那我们先弄两个资源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object lock=new Object();</span><br><span class="line">Object lock2=new Object();</span><br></pre></td></tr></table></figure><p>然后有两个线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tr1 tr1=new Tr1(lock, lock2);</span><br><span class="line">Tr2 tr2=new Tr2(lock, lock2);</span><br><span class="line"></span><br><span class="line">Thread t1=new Thread(tr1);</span><br><span class="line">Thread t2=new Thread(tr2);</span><br></pre></td></tr></table></figure><p>启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure><p>那么对于lock，lock2怎么再线程内部产生竞争关系呢？来看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.base.synchronize;</span><br><span class="line"></span><br><span class="line">public class Tr1 implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">Object lock;</span><br><span class="line">Object lock2;</span><br><span class="line"></span><br><span class="line">public Tr1(Object lock,Object lock2)&#123;</span><br><span class="line">this.lock= lock;</span><br><span class="line">this.lock2= lock2;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    //获取lock</span><br><span class="line">synchronized (lock) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;获取了lock锁&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(3000);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">//获取lock2</span><br><span class="line">synchronized (lock2) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;获取了lock2锁&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Tr2 implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">Object lock;</span><br><span class="line">Object lock2;</span><br><span class="line"></span><br><span class="line">public Tr2(Object lock,Object lock2)&#123;</span><br><span class="line">this.lock= lock;</span><br><span class="line">this.lock2= lock2;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    //获取lock2</span><br><span class="line">synchronized (lock2) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;获取了lock2锁&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(3000);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">//获取lock</span><br><span class="line">synchronized (lock) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;获取了lock锁&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析一下：当线程1获取lock时，线程2获取了lock2锁；然后线程1继续执行，到这里，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (lock2) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;获取了lock2锁&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时需要获取到lock2这个锁，但是lock2现在被线程2持有；同时，线程2也开始执行到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (lock) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;获取了lock锁&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时线程2也在尝试获取lock这把锁，但是lock又被线程1持有了。两个线程都在等待对方释放资源，造成了死锁。OK，完成了。。。<br><br>当我准备关机时，发现还在等呢？<br><img src="https://user-gold-cdn.xitu.io/2017/12/11/16045832711bea87?w=920&amp;h=142&amp;f=png&amp;s=13705" alt=""><br>？？那为什么呢？？<br>我们开看下发生了什么….</p><ul><li>通过jps来看下我们程序进程<br><img src="https://user-gold-cdn.xitu.io/2017/12/11/16045865f54208b5?w=529&amp;h=128&amp;f=png&amp;s=39317" alt=""></li><li>使用jstack -l 【pid】 来看下信息</li></ul><p><img src="https://user-gold-cdn.xitu.io/2017/12/11/16045874f9e2c635?w=917&amp;h=474&amp;f=png&amp;s=224928" alt=""><br>两个线程都处于BLOCKED状态了…,继续往下看<br><img src="https://user-gold-cdn.xitu.io/2017/12/11/1604587202fa162d?w=793&amp;h=386&amp;f=png&amp;s=161336" alt=""><br>found 1 deadlock.如我们所愿，死锁发生了！</p>]]></content>
      
      
      <categories>
          
          <category> java 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 线程 </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>菜鸟成长系列-面向对象的6种设计原则</title>
      <link href="/2018/11/10/java-bird-three/"/>
      <url>/2018/11/10/java-bird-three/</url>
      
        <content type="html"><![CDATA[<p><code>菜鸟成长系列拖了一周多了，今天继续之前的思路来进行。按照之前的规划，这篇主要来学习设计原则先关知识。通过本文学习，希望大家一方面能是能够认识这些原则是什么，能够在日常的开发中起到怎样的约束，并且用这些原则来提高代码的复用性和可维护性，另一方面是对后续的设计模式的学习能够有一些基础。</code></p><p><a href="https://juejin.im/post/59fe7797518825592451e66c" target="_blank" rel="noopener">菜鸟成长系列-概述</a><br><br><a href="https://juejin.im/post/59feb9296fb9a0451a75c21e" target="_blank" rel="noopener">菜鸟成长系列-面向对象的四大基础特性</a><br><br><a href="https://juejin.im/post/5a0d60ee6fb9a045272525af" target="_blank" rel="noopener">菜鸟成长系列-多态、接口和抽象类</a><br></p><hr><p>设计原则，在java与模式这本书中有提到，用于提高系统可维护性的同时，也提高系统的可复用性。这本书中主要讲了六种设计原则：</p><ul><li>“开-闭”原则</li><li>里氏替换原则</li><li>依赖倒置原则</li><li>接口隔离原则</li><li>单一职责原则</li><li>迪特米法则</li></ul><p>这些设计原则首先都是复用的原则，遵循这些原则可以有效的提高系统的复用性，同时也提高了系统的可维护性。</p><h2 id="“开-闭”原则"><a href="#“开-闭”原则" class="headerlink" title="“开-闭”原则"></a>“开-闭”原则</h2><p>网上看到一个人的解释，他是这样来比喻的：一个本子，已经写完了，你不可能撕几张纸粘上去吧，最好的办法是买个新的。<br><br>道理就是这样，一个已经做好的程序，不支持修改的，因为修改的话，有可能造成程序无法运行或报错，所以，通常程序只支持扩展，不支持修改。</p><ul><li>1.为什么会有这样一个原则来作为程序设计的一种约束呢？<br><br><code>在软件的生命周期内，由于软件功能或者结构的变化、升级和维护等原因需要对软件原有代码进行修改，在修改的过程中可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且还需要进行软件的重新测试，因此我们希望在软件设计之初，能够用一种原则来进行一些基本的约束，使得在软件后期的功能变更、扩展或者维护更加容易</code></li><li>2.开闭原则解决的问题是什么？<br><br><code>当软件需要进行改变时，我们应该尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。通过这样一种原则，可以很好的实现在保证原有功能稳定的前提下扩展新的功能</code></li><li>3.什么是开闭原则呢？<br><br><code>一个软件实体(类、模块或函数)应当对扩展开放，对修改关闭。也就是说在扩展或者修改软件功能时，应尽量在不修改原有代码的情况下进行</code></li></ul><p>举个简单的栗子：现在有这样一个需求，系统需要通过QQ来进行验证登录。OK，我们来撸代码：</p><ul><li><p>用户类User</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * 用户信息类</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午10:54:09</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class User &#123;</span><br><span class="line">private String userName;//用户名</span><br><span class="line">private String passWord;//密码</span><br><span class="line">public String getUserName() &#123;</span><br><span class="line">return userName;</span><br><span class="line">&#125;</span><br><span class="line">public void setUserName(String userName) &#123;</span><br><span class="line">this.userName = userName;</span><br><span class="line">&#125;</span><br><span class="line">public String getPassWord() &#123;</span><br><span class="line">return passWord;</span><br><span class="line">&#125;</span><br><span class="line">public void setPassWord(String passWord) &#123;</span><br><span class="line">this.passWord = passWord;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>QQ核心验证逻辑</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * QQ验证器</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午10:49:24</span><br><span class="line"> */</span><br><span class="line">public class QQAuther &#123;</span><br><span class="line">/**</span><br><span class="line"> * 用于验证QQ登录信息</span><br><span class="line"> */</span><br><span class="line">    public boolean validateQQ(User user)</span><br><span class="line">    &#123;</span><br><span class="line">        //模拟下逻辑</span><br><span class="line">        return user.toString()==null?false:true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>核心验证服务类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * 用于验证的核心服务</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午10:47:04</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class AuthService &#123;</span><br><span class="line">//持有一个QQ验证器对象</span><br><span class="line">private QQAuther qqAuther;</span><br><span class="line">//通过构造器注入qqAuther对象</span><br><span class="line">public AuthService(QQAuther qqAuther) &#123;</span><br><span class="line">this.qqAuther = qqAuther;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line"> * 验证用户合法性</span><br><span class="line"> */</span><br><span class="line">public boolean validateUser(User user)&#123;</span><br><span class="line">return qqAuther.validateQQ(user);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * 客户端调用验证</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午10:50:13</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class AuthClient &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//获取用户信息</span><br><span class="line">User user = UserHolder.getUser();</span><br><span class="line">QQAuther qqAuther = new QQAuther();</span><br><span class="line">AuthService authService = new AuthService(qqAuther);</span><br><span class="line">//获取验证结果</span><br><span class="line">boolean isOK = authService.validateUser(user);</span><br><span class="line">System.out.println(isOK);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK,完事了！但是现在需要接入微博的开放平台接口；修改代码…。<br>增加一个微博验证器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * 微博核心验证器</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午11:01:10</span><br><span class="line"> */</span><br><span class="line">public class WeiBoAuther &#123;</span><br><span class="line">/**</span><br><span class="line"> * 用于验证QQ登录信息</span><br><span class="line"> */</span><br><span class="line">    public boolean validateWeiBo(User user)</span><br><span class="line">    &#123;</span><br><span class="line">        return user.toString()==null?false:true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>核心验证服务修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * 用于验证的核心服务</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午10:47:04</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class AuthService &#123;</span><br><span class="line">//持有一个QQ验证器对象</span><br><span class="line">private Object obj;</span><br><span class="line">//通过构造器注入qqAuther对象</span><br><span class="line">public AuthService(Object obj) &#123;</span><br><span class="line">this.obj = obj;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line"> * 验证用户合法性</span><br><span class="line"> */</span><br><span class="line">public boolean validateUser(User user)&#123;</span><br><span class="line">    //这里仅作为模拟，一般情况下会通过使用定义枚举&amp;工厂模式来完成</span><br><span class="line">if (obj instanceof QQAuther) &#123;</span><br><span class="line">return new QQAuther().validateQQ(user);</span><br><span class="line">&#125;</span><br><span class="line">if(obj instanceof WeiBoAuther)&#123;</span><br><span class="line">return new WeiBoAuther().validateWeiBo(user);</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端改变：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * 客户端调用验证</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午10:50:13</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class AuthClient &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//获取用户信息</span><br><span class="line">User user = UserHolder.getUser();</span><br><span class="line"></span><br><span class="line">//QQ</span><br><span class="line">QQAuther qqAuther = new QQAuther();</span><br><span class="line">boolean isQQOK = new AuthService(qqAuther).validateUser(user);</span><br><span class="line">System.out.println(isQQOK);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//微博</span><br><span class="line">WeiBoAuther weiBoAuther = new WeiBoAuther();</span><br><span class="line">boolean isWeiBoOK = new AuthService(weiBoAuther).validateUser(user);</span><br><span class="line">System.out.println(isWeiBoOK);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，改进完成！但是又有新的需求，接入微信….。假如我们现在把微信开放平台也接入了，然后又来需求要接入支付宝账户、苏宁易购账户等等。。。就需要不断的修改代码。那么这个时候就需要在设计之初用到我们的开闭原则来做一个约束了。继续撸：<br><br>首先我们需要需要定义一个接口用于约束：</p><ul><li><p>验证器接口，用于被QQ/WEIBO/微信/苏宁易购等开发平台验证器实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * 定义一个约束接口 </span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午11:32:32</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public interface ValidateInteface &#123;</span><br><span class="line">/**</span><br><span class="line"> * 提供一个验证入口</span><br><span class="line"> */</span><br><span class="line">boolean validate(User user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>QQ修改之后</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * QQ验证器</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午10:49:24</span><br><span class="line"> */</span><br><span class="line">public class QQAuther implements ValidateInteface&#123;</span><br><span class="line">/**</span><br><span class="line"> * 用于验证QQ登录信息</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public boolean validate(User user) &#123;</span><br><span class="line">return user.toString()==null?false:true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>微博修改之后</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * 微博核心验证器</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午11:01:10</span><br><span class="line"> */</span><br><span class="line">public class WeiBoAuther implements ValidateInteface&#123;</span><br><span class="line">/**</span><br><span class="line"> * 用于验证QQ登录信息</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public boolean validate(User user) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"> return user.toString()==null?false:true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>核心验证服务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * 用于验证的核心服务</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午10:47:04</span><br><span class="line"> */</span><br><span class="line">public class AuthService &#123;</span><br><span class="line">//持有一个QQ验证器对象</span><br><span class="line">private ValidateInteface validate;</span><br><span class="line">//通过构造器注入qqAuther对象</span><br><span class="line">public AuthService(ValidateInteface validate) &#123;</span><br><span class="line">this.validate = validate;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line"> * 验证用户合法性</span><br><span class="line"> */</span><br><span class="line">public boolean validateUser(User user)&#123;</span><br><span class="line">return validate.validate(user);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * 客户端调用验证</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午10:50:13</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class AuthClient &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//获取用户信息</span><br><span class="line">User user = UserHolder.getUser();</span><br><span class="line">//QQ</span><br><span class="line">ValidateInteface qqAuther = new QQAuther();</span><br><span class="line">boolean isQQOK = new AuthService(qqAuther).validateUser(user);</span><br><span class="line">System.out.println(isQQOK);</span><br><span class="line">//微博</span><br><span class="line">ValidateInteface weiBoAuther = new WeiBoAuther();</span><br><span class="line">boolean isWeiBoOK = new AuthService(weiBoAuther).validateUser(user);</span><br><span class="line">System.out.println(isWeiBoOK);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进之后我们可以发现，对于原来的核心验证服务类、各验证器类，无论增加什么方式接入，我们都不需要去修改它的代码了。而此时我们需要做的就是新增一个验证器（例如苏宁易购验证器），然后继承ValidateInterface接口就行了。总体来首，开闭原则的核心是：</p><ul><li>抽象化</li><li>对可变性的封装原则（1.不可变性不应该散落在代码的多处，而应当被封装到一个对象里面；2.一种可变性不应当与另外一种可变性混合在一起）</li></ul><p>（大家如果有更简单暴力的例子，可以留言；这个例子想了很多都感觉不是很恰当，还是从工作中抽象出来的）。</p><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p><code>任何父类可以出现的地方，子类一定可以出现</code><br><br>里氏替换原则算是对“开闭”原则的补充，上面也提到，实现“开闭”原则的关键步骤是抽象化，而父类与子类的继承关系就是抽象化的一种具体体现，所以里氏替换原则是对实现抽象化的具体步骤的规范。</p><p><code>摘自java与模式中的定义:如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。</code></p><p>下图中描述了一种继承关系，从最高层的动物一直衍生出具体的动物。OK，写一段断码来看看：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/10/1603e46c66904d41?w=651&amp;h=352&amp;f=png&amp;s=11022" alt=""></p><ul><li><p>顶层抽象父类-Animal</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framework.model.lsp;</span><br><span class="line">/**</span><br><span class="line"> * 顶层抽象父类动物类</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月10日上午10:51:30</span><br><span class="line"> */</span><br><span class="line">public abstract class Animal &#123;</span><br><span class="line">//提供一个抽象方法，以供不同子类来进行具体的实现</span><br><span class="line">public abstract void eatFood(String foodName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体动物类型-Dog</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> package com.glmapper.framework.model.lsp;</span><br><span class="line">/**</span><br><span class="line"> *子类-小狗</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月10日上午10:54:17</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Dog extends Animal&#123;</span><br><span class="line">@Override</span><br><span class="line">public void eatFood(String foodName) &#123;</span><br><span class="line">System.out.println(&quot;小狗吃&quot;+foodName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体动物-哈士奇</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> package com.glmapper.framework.model.lsp;</span><br><span class="line">/**</span><br><span class="line"> * 具体小狗的种类-子类哈士奇</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月10日上午10:56:59</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class HSQDog extends Dog&#123;</span><br><span class="line">/**</span><br><span class="line"> * 重写父类方法</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void eatFood(String foodName) &#123;</span><br><span class="line">System.out.println(&quot;哈士奇吃&quot;+foodName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framework.model.lsp;</span><br><span class="line">//客户端程序</span><br><span class="line">public class ClientMain &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//子类</span><br><span class="line">HSQDog hsqdog=new HSQDog();</span><br><span class="line">hsqdog.eatFood(&quot;饼干&quot;);</span><br><span class="line">//父类</span><br><span class="line">Dog dog = new HSQDog();</span><br><span class="line">dog.eatFood(&quot;饼干&quot;);</span><br><span class="line">//顶层父类</span><br><span class="line">Animal animal = new HSQDog();</span><br><span class="line">animal.eatFood(&quot;饼干&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">哈士奇吃饼干</span><br><span class="line">哈士奇吃饼干</span><br><span class="line">哈士奇吃饼干</span><br></pre></td></tr></table></figure><p>可以看出我们最开始说的那句话<strong>任何父类可以出现的地方，子类一定可以出现</strong>，反过来是不成立的。我的理解是子类通过集成获取的父类的属性和行为，并且子类自身也具有自己的属性和行为；父类可以出现的地方必然是需要用到父类的属性或者行为，而子类都涵盖了父类的这些信息，因此可以做到替换。反过来不行是因为父类在上述的例子中只是充当了一种类型约束，它可能不具有子类的某些特征，因此就无法做到真正的替换。</p><p><code>里氏替换原则是继承复用的基石，只有当子类可以替换掉基类，软件单位的功能不会受到影响时，基类才能被真正的复用，而子类也才能够在基类的基础上增加新的功能。</code></p><h1 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h1><p><code>实现“开闭”原则的关键是抽象化，并且从抽象化导出具体化实现。如果说开闭原则是面向对象设计的目标的话，依赖倒转原则就是面向对象设计的主要机制（java与模式）。</code><br><br><code>依赖倒转原则：要依赖与抽象，不依赖于具体实现。</code></p><p>怎么理解呢?<br></p><ul><li><p>1）高层模块不应该直接依赖于底层模块的具体实现，而应该依赖于底层的抽象。换言之，模块间的依赖是通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。</p></li><li><p>2）接口和抽象类不应该依赖于实现类，而实现类依赖接口或抽象类。这一点其实不用多说，很好理解，“面向接口编程”思想正是这点的最好体现</p></li></ul><p>首先是第一点，从复用的角度来说，高层次的模块是设计者应当复用的。但是在传统的过程性的设计中，复用却侧重于具体层次模块的复用。比如算法的复用，数据结构的复用，函数库的复用等，都不可避免是具体层次模块里面的复用。较高层次的结构依赖于较低层次的结构，然后较低层次的结构又依赖于更低层次的结构，直到依赖到每一行代码为止。然后对低层次修改也会逐层修改，一直到最高层的设计模块中。</p><p><code>对于一个系统来说，一般抽象层次越高，它的稳定性就越好，因此也是作为复用的重点</code>。</p><p>“倒转”，实际上就是指复用应当将复用的重点放在抽象层上，如果抽象层次的模块相对独立于具体层次模块的话，那么抽象层次的模块的复用便是相对较为容易的了。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/10/1603e7d16270426f?w=423&amp;h=398&amp;f=jpeg&amp;s=44474" alt=""><br>在很多情况下，一个java程序需要引用一个对象，如果这个对象有一个抽象类型的话，应当使用这个抽象类型作为变量的静态类型。<br>在上面我们画了动物和小狗的类图关系，在客户端调用的时候有三种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//子类(方式1)</span><br><span class="line">HSQDog hsqdog=new HSQDog();</span><br><span class="line">hsqdog.eatFood(&quot;饼干&quot;);</span><br><span class="line">//父类（方式2）</span><br><span class="line">Dog dog = new HSQDog();</span><br><span class="line">dog.eatFood(&quot;饼干&quot;);</span><br><span class="line">//顶层父类（方式3）</span><br><span class="line">Animal animal = new HSQDog();</span><br><span class="line">animal.eatFood(&quot;饼干&quot;);</span><br></pre></td></tr></table></figure><p>如果我们需要一个哈士奇（HSQDog）的话，我们不应当使用方式1，而是应当使用方式2或者方式3。</p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p><code>接口隔离原则：使用多个专门的接口比使用单一的总接口要好。换句话说，从一个客户类的角度来讲：一个类对另外一个类的依赖性应当是建立在最小的接口上的。</code><br>这个其实在我们实际的开发中是经常遇到的。比如我们需要编写一个完成一个产品的一些操作接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framework.model.isp;</span><br><span class="line">/**</span><br><span class="line"> * 一个产品服务接口</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月10日下午12:01:31</span><br><span class="line"> */</span><br><span class="line">public interface ProductService &#123;</span><br><span class="line">//增加产品</span><br><span class="line">public int addProduct(Product p);</span><br><span class="line">//删除产产品</span><br><span class="line">public int deleteProduct(int pId);</span><br><span class="line">//修改产品</span><br><span class="line">public int updateProduct(Product p);</span><br><span class="line">//查询一个产品</span><br><span class="line">public Product queryProduct(int pId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>OK，我们在ProductService中提供了对产品的增删改查；但是随着需求升级，我们需要可以增加对产品新的批量导入和导出。OK，这时在接口中继续新增两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//从excel中批量导入</span><br><span class="line">public void batchImportFromExcel();</span><br><span class="line">//从excel中批量导导出</span><br><span class="line">public void batchExportFromExcel();</span><br></pre></td></tr></table></figure></p><p>然后需求又需要扩展，需要增加增加购买产品、产品订单生产、查询订单、订单详情….；这样一来，我们的ProductService就会慢慢的急速膨胀。与此对应的具体的实现逻辑ProductServiceImpl类也会变得非常的庞大，可能单类会超过数千行代码。</p><p>那么我们就需要进行接口隔离，将产品的基本操作如增删改查放在一个接口，将产品订单处理放在一个接口，将产品申购放在一个接口，将批量操作放在一个接口等等…对于每一个接口我们只关心某一类特定的职责，这个其实就是和单一职责原则有点挂钩了。<br><code>通过这种设计，降低了单个接口的复杂度，使得接口的“内聚性”更高，“耦合性”更低。由此可以看出接口隔离原则的必要性。</code></p><h2 id="迪特米法则"><a href="#迪特米法则" class="headerlink" title="迪特米法则"></a>迪特米法则</h2><p><code>迪特米法则：又称为最少知识原则，就是说一个对象应当对其他对象尽可能少的了解；看下迪特米法则的几种表述：</code><br><br><code>1.只与你直接的朋友们通信</code><br><br><code>2.不跟陌生人说话</code><br><br><code>3.每一个软件单位对其他的单位都只有最少知识，而且局限于那些与本单位密切相关的软件单位</code><br></p><p>也就是说，如果两个雷不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要电泳另一个类的某一个方法的话，可以通过第三者进行消息的转发。代码看下：</p><ul><li><p>某个人</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framework.model.isp;</span><br><span class="line">/**</span><br><span class="line"> * 某个人</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月10日下午12:39:45</span><br><span class="line"> */</span><br><span class="line">public class SomeOne &#123;</span><br><span class="line">//具体oprateion行为</span><br><span class="line">public void oprateion(Friend friend)&#123;</span><br><span class="line">Stranger stranger =friend.provide();</span><br><span class="line">stranger.oprateion3();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">SomeOne具有一个oprateion方法，该方法接受Friend为参数，根据上面的定义可以知道Friend是SomeOne的“朋友”（直接通信了）</span><br></pre></td></tr></table></figure></li><li><p>朋友</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framework.model.isp;</span><br><span class="line">/**</span><br><span class="line"> * 朋友</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月10日下午12:40:09</span><br><span class="line"> */</span><br><span class="line">public class Friend &#123;</span><br><span class="line">private Stranger stranger = new Stranger();</span><br><span class="line">public Stranger provide()&#123;</span><br><span class="line">return stranger;</span><br><span class="line">&#125;</span><br><span class="line">public void opration2()&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">很明显SomeOne的opration方法不满足迪特米法则，因为这个方法中涉及到了陌生人Stranger,Stranger不是SomeOne的朋友</span><br></pre></td></tr></table></figure></li></ul><p>OK，我们来通过迪特米法则进行改造。</p><ul><li>改造之后的SomeOne</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framework.model.isp;</span><br><span class="line">/**</span><br><span class="line"> * 某个人</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月10日下午12:39:45</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SomeOne &#123;</span><br><span class="line">//具体oprateion行为</span><br><span class="line">public void oprateion(Friend friend)&#123;</span><br><span class="line">friend.forward();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>改造之后的朋友</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framework.model.isp;</span><br><span class="line">/**</span><br><span class="line"> * 朋友</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月10日下午12:40:09</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Friend &#123;</span><br><span class="line">private Stranger stranger = new Stranger();</span><br><span class="line">public void opration2()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//进行转发</span><br><span class="line">public void forward() &#123;</span><br><span class="line">stranger.oprateion3();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于调用了转发，因此SomeOne中就不会和陌生人Stranger直接的关系就被忽略了。满足了直接和朋友通信、不与陌生人说话的条件。<br><br>但是迪特米法则带来的问题也是很明显的：即会在系统中造出大量的小方法散落在系统的各个角落，这些方法仅仅是传递消息的调用，与系统的业务逻辑没有任何关系。</p><h2 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h2><p>上面在接口隔离中有提到过，单一职责其实很好理解，解释尽量的使得我们的每一个类或者接口只完成本职工作以内的事情，不参与其他任何逻辑。比如说苹果榨汁机我就只用来榨苹果汁，如果你需要榨黄瓜汁的话，你就得买一个黄瓜榨汁机。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OK ，至此，设计原则部分就复习完了。总结一下：</p><ul><li><ol><li>单一职责原则要求实现类要职责单一；</li></ol></li><li><ol start="2"><li>里氏替换原则要求不要去破坏继承系统；</li></ol></li><li><ol start="3"><li>依赖倒置原则要求面向接口编程；</li></ol></li><li><ol start="4"><li>接口隔离原则要求在设计接口的时候要精简单一；</li></ol></li><li><ol start="5"><li>迪米特法则要求要降低耦合；</li></ol></li><li><ol start="6"><li>开闭原则是总纲，要求对扩展开发，对修改关闭。</li></ol></li></ul><p>大家周末愉快！（如果有不当之处，希望大家及时指出，多谢！）</p>]]></content>
      
      
      <categories>
          
          <category> 架构之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从源码来聊一聊hashmap</title>
      <link href="/2018/11/10/java-base-hashmap/"/>
      <url>/2018/11/10/java-base-hashmap/</url>
      
        <content type="html"><![CDATA[<p><code>HashMap为什么会是面试中的常客呢？我觉得有以下几点原因：</code><br><br><code>* 考察你阅读源码的能力</code><br><br><code>* 是否了解内部数据结构</code><br><br><code>* 是否了解其存储和查询逻辑</code><br><br><code>* 对非线程安全情况下的使用考虑</code><br><br>前段时间一同事面试蚂蚁金服，就被问到了这个问题；其实很多情况下都是从hashMap,hashTable,ConcurrentHahMap三者之间的关系衍生而出，当然也有直接就针对hashMap原理直接进行考察的。实际上本质都一样，就是为了考察你是否对集合中这些常用集合的原理、实现和使用场景是否清楚。一方面是我们开发中用的多，当然用的人也就多，但是用的好的人却不多（我也用的多，用的也不好）。所以就借此机会（强行蹭一波）再来捋一捋这个HashMap。<br>本文基于jdk1.7.0_80；jdk 1.8之后略有改动，这个后面细说。</p><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt;</span><br><span class="line">    extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure><p>hashMap实现了Map、Cloneable、Serializable三个接口，并且继承了AbstractMap这个抽象类。hashTable继承的是Dictionary这个类，同时也实现了Map、Cloneable、Serializable三个接口。</p><h2 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h2><ul><li>DEFAULT_INITIAL_CAPACITY 默认初始容量 16 （hashtable 是11） 常量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * The default initial capacity - MUST be a power of two.</span><br><span class="line">    * 默认初始容量-必须是2的幂。</span><br><span class="line">    */</span><br><span class="line">   static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br></pre></td></tr></table></figure><ul><li>MAXIMUM_CAPACITY 默认最大容量 常量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * The maximum capacity, used if a higher value is implicitly specified</span><br><span class="line">     * by either of the constructors with arguments.</span><br><span class="line">     * MUST be a power of two &lt;= 1&lt;&lt;30.</span><br><span class="line">     *如果有一个更大的值被用于构造HashMap,则使用最大值</span><br><span class="line">     */</span><br><span class="line">    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br></pre></td></tr></table></figure><ul><li>DEFAULT_LOAD_FACTOR 负载因子(默认0.75) 常量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * The load factor used when none specified in constructor.</span><br><span class="line">     * 加载因子，如果构造函数中没有指定，则使用默认的</span><br><span class="line">     */</span><br><span class="line">    static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br></pre></td></tr></table></figure><ul><li>EMPTY_TABLE 默认的空表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * An empty table instance to share when the table is not inflated.</span><br><span class="line">     * 当表不膨胀时共享的空表实例。</span><br><span class="line">     */</span><br><span class="line">    static final Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>table 表，必要时调整大小。长度必须是两个幂。<br>这个也是hashmap中的核心的存储结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * The table, resized as necessary. Length MUST Always be a power of two.</span><br><span class="line">     */</span><br><span class="line">    transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure></li><li><p>size 表示HashMap中存放KV的数量（为链表/树中的KV的总和）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * The number of key-value mappings contained in this map.</span><br><span class="line">     */</span><br><span class="line">    transient int size;</span><br></pre></td></tr></table></figure><ul><li>threshold 扩容变量，表示当HashMap的size大于threshold时会执行resize操作。<br>threshold=capacity*loadFactor</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * The next size value at which to resize (capacity * load factor).</span><br><span class="line">     * @serial</span><br><span class="line">     */</span><br><span class="line">    // If table == EMPTY_TABLE then this is the initial capacity at which the</span><br><span class="line">    // table will be created when inflated.</span><br><span class="line">    int threshold;</span><br></pre></td></tr></table></figure><ul><li>loadFactor 负载因子 负载因子用来衡量HashMap满的程度。loadFactor的默认值为0.75f。计算HashMap的实时装载因子的方法为：size/capacity，而不是占用桶的数量去除以capacity。（桶的概念后续介绍）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The load factor for the hash table.</span><br><span class="line"> *</span><br><span class="line"> * @serial</span><br><span class="line"> */</span><br><span class="line">final float loadFactor;</span><br></pre></td></tr></table></figure><ul><li><p>modCount<br>这个HashMap的结构修改的次数是那些改变HashMap中的映射数量或修改其内部结构(例如rehash)的那些。这个字段用于使迭代器对HashMap失败快速的集合视图。(见ConcurrentModificationException)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * The number of times this HashMap has been structurally modified</span><br><span class="line">     * Structural modifications are those that change the number of mappings in</span><br><span class="line">     * the HashMap or otherwise modify its internal structure (e.g.,</span><br><span class="line">     * rehash).  This field is used to make iterators on Collection-views of</span><br><span class="line">     * the HashMap fail-fast.  (See ConcurrentModificationException).</span><br><span class="line">     */</span><br><span class="line">    transient int modCount;</span><br></pre></td></tr></table></figure></li><li><p>hashSeed 与此实例相关联的随机值，用于哈希键的散列代码，使散列冲突更难找到。如果0，那么替代哈希是禁用的。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * A randomizing value associated with this instance that is applied to</span><br><span class="line">     * hash code of keys to make hash collisions harder to find. If 0 then</span><br><span class="line">     * alternative hashing is disabled.</span><br><span class="line">     */</span><br><span class="line">    transient int hashSeed = 0;</span><br></pre></td></tr></table></figure><h2 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;</span><br></pre></td></tr></table></figure><p>hashmap中是通过使用一个继承自Map中内部类Entry的Entry静态内部类来存储每一个K-V值的。看下具体代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final K key; //键对象</span><br><span class="line">        V value;     //值对象</span><br><span class="line">        Entry&lt;K,V&gt; next; //指向链表中下一个Entry对象，可为null，表示当前Entry对象在链表尾部</span><br><span class="line">        int hash;    //键对象的hash值</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 构造对象</span><br><span class="line">         */</span><br><span class="line">        Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">        * 获取key</span><br><span class="line">        */</span><br><span class="line">        public final K getKey() &#123;</span><br><span class="line">            return key;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">        * 获取value</span><br><span class="line">        */</span><br><span class="line">        public final V getValue() &#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">        * 设置value，这里返回的是oldValue(这个不太明白，哪位大佬清楚的可以留言解释下，非常感谢)</span><br><span class="line">        */</span><br><span class="line">        public final V setValue(V newValue) &#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">        * 重写equals方法</span><br><span class="line">        */</span><br><span class="line">        public final boolean equals(Object o) &#123;</span><br><span class="line">            if (!(o instanceof Map.Entry))</span><br><span class="line">                return false;</span><br><span class="line">            Map.Entry e = (Map.Entry)o;</span><br><span class="line">            Object k1 = getKey();</span><br><span class="line">            Object k2 = e.getKey();</span><br><span class="line">            if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">                Object v1 = getValue();</span><br><span class="line">                Object v2 = e.getValue();</span><br><span class="line">                if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">        * 重写hashCode方法</span><br><span class="line">        */</span><br><span class="line">        public final int hashCode() &#123;</span><br><span class="line">            return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final String toString() &#123;</span><br><span class="line">            return getKey() + &quot;=&quot; + getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * This method is invoked whenever the value in an entry is</span><br><span class="line">         * overwritten by an invocation of put(k,v) for a key k that&apos;s already</span><br><span class="line">         * in the HashMap.</span><br><span class="line">         */</span><br><span class="line">        void recordAccess(HashMap&lt;K,V&gt; m) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * This method is invoked whenever the entry is</span><br><span class="line">         * removed from the table.</span><br><span class="line">         */</span><br><span class="line">        void recordRemoval(HashMap&lt;K,V&gt; m) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>HashMap是一个用于存储Key-Value键值对的集合，每一个键值对也叫做Entry。这些个键值对（Entry）分散存储在一个数组当中，这个数组就是HashMap的主干（也就是上面的table–桶）。<br>看一张图：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/3/1601ad77555ecaac?w=557&amp;h=426&amp;f=jpeg&amp;s=31339" alt=""><br>hashmap初始化时各个空间的默认值为null，当插入元素时（具体插入下面分析），根据key值来计算出具体的索引位置，如果重复，则使用尾插入法进行插入后面链表中。</p><ul><li>尾插法<br><br>之前我是通过插入17条数据来试验的（具体数据数目随意，越大重复的几率越高）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">HashMap&lt;String, Object&gt; map=new HashMap&lt;&gt;();</span><br><span class="line">for (int i = 0; i &lt; 170; i++) &#123;</span><br><span class="line">map.put(&quot;key&quot;+i, i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://user-gold-cdn.xitu.io/2017/12/3/1601ada6b59da9f2?w=607&amp;h=358&amp;f=jpeg&amp;s=25069" alt=""><br>通过断点查看next，可以得出我们上面的结论：<br><br>1.索引冲突时会使用链表来存储；<br>2.插入链表的方式是从尾部开始插入的（官方的解释是一般情况下，后来插入的数据被使用的频次较高），这样的话有利于查找。</p><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><p>我们平时在开发是最常用的hashMap中的方法无非就是先创建一个HashMap对象，然后存，接着取；对应的方法就是：</p><ul><li>构造函数</li><li>put函数</li><li>get函数</li></ul><p><strong>构造函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span><br><span class="line">    * capacity and load factor.</span><br><span class="line">    *</span><br><span class="line">    * @param  initialCapacity the initial capacity 指定的初始化容量大小</span><br><span class="line">    * @param  loadFactor      the load factor 指定的负载因子</span><br><span class="line">    * @throws IllegalArgumentException if the initial capacity is negative</span><br><span class="line">    *         or the load factor is nonpositive</span><br><span class="line">    */</span><br><span class="line">   public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">       //如果初始化容量小于0，则抛出异常</span><br><span class="line">       if (initialCapacity &lt; 0)</span><br><span class="line">           throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       //如果初始化容量大于最大容量，则使用默认最大容量</span><br><span class="line">       if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">      //如果负载因子小于0或者非数值类型，则抛出异常</span><br><span class="line">       if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">           throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                              loadFactor);</span><br><span class="line">       //初始化负载因子</span><br><span class="line">       this.loadFactor = loadFactor;</span><br><span class="line">       //初始化threshold</span><br><span class="line">       threshold = initialCapacity;</span><br><span class="line">       //这个初始化方法是个空方法，应该是意在HashMap的子类中由使用者自行重写该方法的具体实现</span><br><span class="line">       init();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>另外两个构造方法实际上都是对上面这个构造方法的调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//只制定默认容量</span><br><span class="line"> public HashMap(int initialCapacity) &#123;</span><br><span class="line">        this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"> //使用HashMap默认的容量大小和负载因子</span><br><span class="line"> public HashMap() &#123;</span><br><span class="line">        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>还有一个是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,</span><br><span class="line">                      DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line"></span><br><span class="line">        putAllForCreate(m);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>构造一个映射关系与指定 Map 相同的新 HashMap。所创建的 HashMap 具有默认加载因子 (0.75) 和足以容纳指定 Map 中映射关系的初始容量。</p><p><strong>put方法</strong><br><br><br>首先，我们都知道hashmap中的key是允许为null的，这一点也是面试中最常问到的点。那我先看下为什么可以存null作为key值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        //如果table是空的</span><br><span class="line">        if (table == EMPTY_TABLE) &#123;</span><br><span class="line">            //inflate：扩容/膨胀的意思</span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果key为null 此处敲下桌子，为什么可以存null？</span><br><span class="line">        if (key == null)</span><br><span class="line">            //执行putForNullKey方法，这个方法的作用是如果key为null，就将当前的k-v存放到table[0],即第一个桶。</span><br><span class="line">            return putForNullKey(value);</span><br><span class="line">        //对key进行一次hash运算，获取hash值</span><br><span class="line">        int hash = hash(key);</span><br><span class="line">        //根据key值得hash值和表的长度来计算索引位置</span><br><span class="line">        int i = indexFor(hash, table.length);</span><br><span class="line">        //移动数据，插入数据</span><br><span class="line">        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                //上面Entry中的setValue中也有提到，返回的都是旧的数据</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>hash方法：<br>检索对象哈希代码，并将附加哈希函数应用于结果哈希，该哈希函数防止质量差的哈希函数。 这是至关重要的，因为HashMap使用两个长度的哈希表，否则会碰到hashCode的冲突，这些hashCodes在低位上没有区别。 注意：空键总是映射到散列0，因此索引为0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    final int hash(Object k) &#123;</span><br><span class="line">        int h = hashSeed;</span><br><span class="line">        if (0 != h &amp;&amp; k instanceof String) &#123;</span><br><span class="line">            return sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">        //这个函数确保在每个比特位置上仅以恒定倍数不同</span><br><span class="line">        //的散列码具有有限数量的冲突（在默认加载因子下大约为8）。</span><br><span class="line">        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>冲突具体过程描述：</p><ul><li>一个空的hashmap表<br><img src="https://user-gold-cdn.xitu.io/2017/12/3/1601b0c8971b8e73?w=459&amp;h=49&amp;f=jpeg&amp;s=4597" alt=""></li><li>插入元素，通过hash计算得出索引为3，因为当前3的位置没有元素，因此直接插入进去即可<br><img src="https://user-gold-cdn.xitu.io/2017/12/3/1601b0cb48ff45e3?w=456&amp;h=50&amp;f=jpeg&amp;s=4759" alt=""></li><li>再次插入元素，通过hash计算得出索引还是3，发生冲突，则将当前新插入的元素放在原来的已有的元素位置，并将其next指向原来已经存在的元素。<br><img src="https://user-gold-cdn.xitu.io/2017/12/3/1601b0cd89818439?w=467&amp;h=137&amp;f=jpeg&amp;s=10000" alt=""><br><strong>get方法</strong><br><br><br>返回指定键映射到的值;如果此映射不包含键映射，则返回null。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">       //和存null key一样，取的时候也是从table[0]取</span><br><span class="line">       if (key == null)</span><br><span class="line">           return getForNullKey();</span><br><span class="line">       //获取entry</span><br><span class="line">       Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">       return null == entry ? null : entry.getValue();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><p>getEntry方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">       //size等于0，说明当前hashMap中没有元素，直接返回null（每个entry默认值为null）</span><br><span class="line">       if (size == 0) &#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">       //根据key值计算hash值</span><br><span class="line">       int hash = (key == null) ? 0 : hash(key);</span><br><span class="line">       //通过hash值获取到索引位置，找到对应的桶链进行遍历查找</span><br><span class="line">       for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">            e != null;</span><br><span class="line">            e = e.next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           //如果找到则返回，如果没有链表指针移动到下一个节点继续查找。</span><br><span class="line">           if (e.hash == hash &amp;&amp;</span><br><span class="line">               ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">               return e;</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><p>在前面提到过threshold，扩容变量，表示当HashMap的size大于threshold时会执行resize操作。其计算方式是：threshold=capacity*loadFactor。<br>从上面的式子中我们可以得知hashmap的扩容时机是<strong>当前当前size的值超过容量乘以负载因子时就会触发扩容</strong>。来看下源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">        //如果当前size超过threshold 并且满足桶索引位置不为null的情况下，扩容</span><br><span class="line">        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</span><br><span class="line">           //扩容之后为原来的两倍</span><br><span class="line">            resize(2 * table.length);</span><br><span class="line">            //重新计算hash值</span><br><span class="line">            hash = (null != key) ? hash(key) : 0;</span><br><span class="line">            //重写计算索引</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line">        //执行具体的插入操作</span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">        //先取到当前桶的entry</span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        //将新的数据插入到table[bucketIndex]，再将之前的entry通过链表简介到table[bucketIndex]的next指向；前面的图已经进行了描述。</span><br><span class="line">        table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，扩容并不是在hashmap满了之后才进行的，看下面断点：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/3/1601b56fe116d600?w=845&amp;h=319&amp;f=jpeg&amp;s=35941" alt=""><br>通过默认构造函数new了一个map对象出来，通过for循环插入12条数据，断点到执行结束，我们看到当前table的容量是16，扩容变量threshold为12（16x0.75），现在我们将12改为13.<br><img src="https://user-gold-cdn.xitu.io/2017/12/3/1601b598042d70f2?w=750&amp;h=279&amp;f=jpeg&amp;s=26666" alt=""><br>此时13还是小于16的，但是还是触发了hashmap 的扩容。当前table容量为32（扩容为了之前的两倍），threshold为24（32x0.75），通过这两种图我们得知：</p><ul><li>每次扩容之后的容量为原有容量的两倍（2n）</li><li>触发扩容并不是因为当前hashmap对象已经满了，而是通过threhold扩容变量来控制触发时机的。</li><li><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2>本文就单纯的扒了一波源码，并对源码中的注释并结合自己的理解进行了翻译，通过断点调试简单的介绍了尾插法在hashmap的应用。最后通过几张图描述了下hashmap发生索引冲突时的解决方案。hashmap在面试时真的是可深可浅，但是源码的阅读还是很有必要的，下面推荐两篇博客给大家。</li><li>1.关于hashmap与hashtable的具体对比可以参考这个博客：<br><br><a href="http://mp.weixin.qq.com/s/wnvpPOQvCgE5vgdnoMpGYw" target="_blank" rel="noopener">HashMap和HashTable到底哪不同？</a><br></li><li>2.关于为什么hashmap中的容量必须是2的幂，这篇博客大家可以看下：<br><br><a href="https://juejin.im/post/5a215783f265da431d3c7bba" target="_blank" rel="noopener">什么是hashmap？</a></li><li>3.关于hashmap非线程安全的解释<br><br><a href="https://www.cnblogs.com/alexlo/p/4955391.html" target="_blank" rel="noopener">并发安全问题之HashMap</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> hash </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一个朋友圈泛型问题引发的“案子”</title>
      <link href="/2018/11/10/java-base-one/"/>
      <url>/2018/11/10/java-base-one/</url>
      
        <content type="html"><![CDATA[<p>昨天朋友圈问了一个问题：<br>对于下面的list，何如在list添加一个Integer型整数？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure></p><p>有这样几种回答：</p><ul><li>1.不知道（非专业回答）</li><li>2.硬塞（非专业回答）</li><li>3.把String 改成Integer再添加（违背了问题初衷）</li><li>4.把String改成Object，可以加任意类型（违背了问题初衷）</li><li>5.String换成通配符</li><li>6.反射</li></ul><p>对于1、2就不说了，属于搞事情的！3、4、5三种方式违背了问题的初衷，如果可以改，那我们直接new三个ArrayList就可以了。6反射，这个是无限接近的，那么这个和反射有什么关系呢？下来看下下面几个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">ArrayList list=new ArrayList();</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; str_list=new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Integer&gt; int_list=new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Object&gt; obj_list=new ArrayList&lt;Object&gt;();</span><br><span class="line">//对象比较</span><br><span class="line">System.out.println(list == str_list);</span><br><span class="line">System.out.println(list == int_list);</span><br><span class="line">System.out.println(list == obj_list);</span><br><span class="line"></span><br><span class="line">//对象的运行时class比较</span><br><span class="line">System.out.println(list.getClass() == str_list.getClass());</span><br><span class="line">System.out.println(list.getClass() == int_list.getClass());</span><br><span class="line">System.out.println(list.getClass() == obj_list.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure></p><p>其实上面三个很容易理解，不同对象在内存中的地址肯定是不同的，因此均为false;下面三个均为true?是的，确实为true,这就引出了朋友圈的那个问题。为什么不同的三个对象，他们的getClass是一样的，不应该是有三个不同的hashCode吗？这个其实就是<strong>泛型编译时和运行时的问题</strong>。<br>对于泛型来说，<strong>泛型只在编译阶段有效，编译之后，集合的泛型是去泛型化的；原因：由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的</strong>。<br>因此：java集合中的泛型，是来约束用户的错误输入的，只在编译时有效；<br>在回到问题最初，我们怎么才能将一个Integer对像放入上面定义的list中呢？既然集合中的泛型是编译时有效的，那我我们就可以通过绕过编译的方式进行插入。那么如何绕过编译时的校验呢？答案就是用反射；我们知道JAVA反射机制是指：<br><strong>“在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</strong><br>OK，再来看程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      ArrayList&lt;String&gt; str_list=new ArrayList&lt;String&gt;();</span><br><span class="line">//获取类信息</span><br><span class="line">Class c=str_list.getClass();</span><br><span class="line">//获取add方法</span><br><span class="line">Method m=c.getMethod(&quot;add&quot;, Object.class);</span><br><span class="line">//运行时调用add方法</span><br><span class="line">m.invoke(str_list, 20);</span><br><span class="line">//输出当前str_list</span><br><span class="line">System.out.println(str_list);</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[20]</span><br></pre></td></tr></table></figure></p><p>从结果可以看出，我们完成了在list中添加Integer的任务。<br>【泛型、反射、编译时、运行时】</p>]]></content>
      
      
      <categories>
          
          <category> java 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法-排序算法思想及实现</title>
      <link href="/2018/11/10/alg-one/"/>
      <url>/2018/11/10/alg-one/</url>
      
        <content type="html"><![CDATA[<p><code>排序算法主要有：插入排序，选择排序，冒泡排序，希尔排序，归并排序，快速排序，堆排序。这里的排序指的是内部排序，也就是基于内存的排序，基于内存的排序是基于大O模型的，可以使用大O模型来衡量算法的性能</code><br>摘自我自己的博客园：<a href="http://www.cnblogs.com/myadmin/p/5821158.html" target="_blank" rel="noopener">http://www.cnblogs.com/myadmin/p/5821158.html</a> 中的部分排序算法。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>基本思想：每一步都将一个待排数据按其大小插入到已经排序的数据中的适当位置，直到全部插入完毕。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始：4 3 1 2</span><br><span class="line">1)3 4 1 2</span><br><span class="line">2)1 3 4 2</span><br><span class="line">3)1 2 3 4</span><br></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 插入排序</span><br><span class="line">     */</span><br><span class="line">    public static int[] insertSort(int[] arr) &#123;</span><br><span class="line">        for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            int index = i;// index当前扫描到的元素下标</span><br><span class="line">            int temp = arr[i];</span><br><span class="line">            // 寻找插入的位置</span><br><span class="line">            while (index &gt; 0 &amp;&amp; temp &lt; arr[index - 1]) &#123;</span><br><span class="line">                arr[index] = arr[index - 1];</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[index] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>基本思想：从所有序列中先找到最小的，然后放到第一个位置。之后再看剩余元素中最小的，放到第二个位置……以此类推，就可以完成整个的排序工作了。可以很清楚的发现，选择排序是固定位置，找元素。相比于插入排序的固定元素找位置，是两种思维方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3 2 1 4 6 5</span><br><span class="line"></span><br><span class="line">初始化索引位置为0 </span><br><span class="line">寻找最小值所在位置交换：1 2 3 4 6 5</span><br><span class="line"></span><br><span class="line">初始化索引位置为1</span><br><span class="line">寻找最小值所在位置交换：1 2 3 4 6 5</span><br><span class="line"></span><br><span class="line">依次类推！</span><br></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 选择排序</span><br><span class="line">     */</span><br><span class="line">    public static int[] selectSort(int[] arr) &#123;</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            int minVal = arr[i];</span><br><span class="line">            int index = i;</span><br><span class="line">            for (int j = i + 1; j &lt; arr.length; j++) &#123;// 找到最小元素</span><br><span class="line">                if (arr[j] &lt; minVal) &#123;</span><br><span class="line">                    minVal = arr[j];</span><br><span class="line">                    index = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[index] = arr[i];</span><br><span class="line">            arr[i] = minVal;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>基本思想：原理是临近的数字两两进行比较,按照从小到大或者从大到小的顺序进行交换。<br>核心代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 冒泡排序</span><br><span class="line">     * </span><br><span class="line">     * @param arr</span><br><span class="line">     *            输入的待排数组</span><br><span class="line">     * @return 返回排序号的数组</span><br><span class="line">     */</span><br><span class="line">    public static int[] bubbleSort(int[] arr) &#123;</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">                if (arr[j - 1] &gt; arr[j]) &#123;</span><br><span class="line">                    int temp = arr[j - 1];</span><br><span class="line">                    arr[j - 1] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>基本思想：先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量 =1( &lt; …&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。（下图来自百度图片）</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/28/160006ad381ba442?w=430&amp;h=403&amp;f=png&amp;s=199830" alt=""></p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 希尔排序</span><br><span class="line"> * </span><br><span class="line"> * @author sgl</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">public class ShellSort &#123;</span><br><span class="line"></span><br><span class="line">    public static int[] shellSort(int[] arr) &#123;</span><br><span class="line">        int step = arr.length / 2;// 初始步长</span><br><span class="line"></span><br><span class="line">        while (1 &lt;= step) &#123;</span><br><span class="line">            for (int i = step; i &lt; arr.length; i++) &#123;</span><br><span class="line">                if (arr[i] &lt; arr[i - step]) &#123;</span><br><span class="line">                    int temp = arr[i];</span><br><span class="line">                    arr[i] = arr[i - step];</span><br><span class="line">                    arr[i - step] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step = step / 2;</span><br><span class="line">            for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">                System.out.print(arr[i]+&quot;,&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>基本思想：将待排序序列R[0…n-1]看成是n个长度为1的有序序列，将相邻的有序表成对归并，得到n/2个长度为2的有序表；将这些有序序列再次归并，得到n/4个长度为4的有序序列；如此反复进行下去，最后得到一个长度为n的有序序列。<br>归并排序其实要做两件事：<br>（1）“分解”——将序列每次折半划分。<br>（2）“合并”——将划分后的序列段两两合并后排序。</p><p>核心代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public static int[] sort(int[] nums, int low, int high) &#123;</span><br><span class="line">        int mid = (low + high) / 2;</span><br><span class="line">        if (low &lt; high) &#123;</span><br><span class="line">            sort(nums, low, mid);// 左边</span><br><span class="line">            sort(nums, mid + 1, high);// 右边</span><br><span class="line">            merge(nums, low, mid, high);// 左右归并</span><br><span class="line">        &#125;</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void merge(int[] nums, int low, int mid, int high)           &#123;</span><br><span class="line">        int[] temp = new int[high - low + 1];</span><br><span class="line">        int i = low;// 左指针</span><br><span class="line">        int j = mid + 1;// 右指针</span><br><span class="line">        int k = 0;</span><br><span class="line">        // 把较小的数先移到新数组中</span><br><span class="line">        while (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">            if (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">                temp[k++] = nums[i++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                temp[k++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 把左边剩余的数移入数组</span><br><span class="line">        while (i &lt;= mid) &#123;</span><br><span class="line">            temp[k++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        // 把右边边剩余的数移入数组</span><br><span class="line">        while (j &lt;= high) &#123;</span><br><span class="line">            temp[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        // 把新数组中的数覆盖nums数组</span><br><span class="line">        for (int k2 = 0; k2 &lt; temp.length; k2++) &#123;</span><br><span class="line">            nums[k2 + low] = temp[k2];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>基本思想：快速排序采用的思想是分治思想。<br>快速排序是找出一个元素（理论上可以随便找一个）作为基准,然后对数组进行分区操作,使基准左边元素的值都不大于基准值,基准右边的元素值 都不小于基准值，如此作为基准的元素调整到排序后的正确位置。递归快速排序，将其他n-1个元素也调整到排序后的正确位置。最后每个元素都是在排序后的正 确位置，排序完成。所以快速排序算法的核心算法是分区操作，即如何调整基准的位置以及调整返回基准的最终位置以便分治递归。</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 快速排序</span><br><span class="line"> * </span><br><span class="line"> * @author sgl</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">public class QuickSort &#123;</span><br><span class="line">    static void quicksort(int n[], int left, int right) &#123;</span><br><span class="line">        int dp;</span><br><span class="line">        if (left &lt; right) &#123;</span><br><span class="line">            dp = partition(n, left, right);</span><br><span class="line">            quicksort(n, left, dp - 1);</span><br><span class="line">            quicksort(n, dp + 1, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int partition(int n[], int left, int right) &#123;</span><br><span class="line">        int pivot = n[left];</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            while (left &lt; right &amp;&amp; n[right] &gt;= pivot)</span><br><span class="line">                right--;</span><br><span class="line">            if (left &lt; right)</span><br><span class="line">                n[left++] = n[right];</span><br><span class="line">            while (left &lt; right &amp;&amp; n[left] &lt;= pivot)</span><br><span class="line">                left++;</span><br><span class="line">            if (left &lt; right)</span><br><span class="line">                n[right--] = n[left];</span><br><span class="line">        &#125;</span><br><span class="line">        n[left] = pivot;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于maven构建多模块化的SSM框架</title>
      <link href="/2018/11/10/project-frame-maven-ssm/"/>
      <url>/2018/11/10/project-frame-maven-ssm/</url>
      
        <content type="html"><![CDATA[<p>之前写过一篇SSM的框架整合；<a href="https://juejin.im/post/59f3ef5c51882534aa0691b2" target="_blank" rel="noopener">项目开发框架-SSM</a>；对SSM中的一些点进行了学习记录,那篇文章也是基于maven来创建的，那么为什么又要搞一篇呢？以我当前公司项目A来说，A项目包括前台、后台子项目【前台用于对外，后台用于管理】，如果按照前一篇文章的那种方式来进行，我们就需要建立两个单独的框架来进行开发，一样的拥有一套从dmo实体类包，util包，dao包，service包以及controller包，这种结构非常的紧凑和独立，但是问题在于，我们前后台使用的是同一个库，dmo、util、dao以及service中都会存在大量重复的代码，很多基础方法无法公用；另外一个原因是，我们还需要包装一些接口向外提供服务【不局限于我们自己的这两个系统】，这样一来，我们又需要再去抽离一次service，非常不方便。因此就使用maven来构建多模块项目，对于util、dao、rpc服务接口以及service进行模块化分离，这样一来，这些模块就可以对我们自己的前后台以及外部提供一些公关的服务，避免了大量的代码重复，也方便管理。</p><p><code>Maven多模块项目，通过合理的模块拆分，实现代码的复用，便于维护和管理。尤其是一些开源框架，也是采用多模块的方式，提供插件集成，用户可以根据需要配置指定的模块。</code></p><h1 id="构建多模块化项目"><a href="#构建多模块化项目" class="headerlink" title="构建多模块化项目"></a>构建多模块化项目</h1><p><code>基于maven构建多模块化项目主要依赖于maven可以实现父子项目的关系，子项目可以父项目的依赖Jar包，这样也方便我们去共同管理jar依赖，但是由于一个项目中毕竟会有很多人进行协同开发，在此过程中如果没有很好的约束，对于这种多模块化来说，解决jar包的冲突也很繁琐。</code></p><h2 id="新建一个父工程"><a href="#新建一个父工程" class="headerlink" title="新建一个父工程"></a>新建一个父工程</h2><p>1.创建maven项目</p><ul><li>step1:(新建maven项目)<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd33922055090e?w=522&amp;h=495&amp;f=jpeg&amp;s=27781" alt=""></li><li>step2:(勾选创建一个简单工程)<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd339da27c69e2?w=647&amp;h=349&amp;f=jpeg&amp;s=25698" alt=""></li><li>step3:(填写工程配置：主要是打包方式要选择pom方式)<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd33a64043c613?w=646&amp;h=609&amp;f=jpeg&amp;s=41840" alt=""><br>点击finish，父项目就创建成功了！<br>2.创建子项目</li><li>step1:(右击父项目-&gt;maven-&gt;New Maven Model Project)<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd345841f4595f?w=779&amp;h=549&amp;f=jpeg&amp;s=71841" alt=""></li><li>step2:<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd3469ac355dd4?w=641&amp;h=580&amp;f=jpeg&amp;s=37396" alt=""></li><li>step3:(一般情况下，我们项目中的util、dao、service都是可以直接分出来的，这里我们选择quickstart来构建,用于生产后面的jar包提供服务。我们的web子项目选择webapp来构建，用于配置文件、jsp文件/ftl/html/js/css等界面资源文件维护)<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd346f632a56de?w=648&amp;h=580&amp;f=jpeg&amp;s=57047" alt=""><br>点击finish，完成子模块的构建！构建之后的项目结构为：<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd34b0b69a6b8f?w=283&amp;h=242&amp;f=jpeg&amp;s=10977" alt=""><br>此时，我们的父模块中已经有了子模块的项目标识，新建的dao模块中不包括webapp此类的文件夹。那么这时就可以将我们的数据访问相关的类和接口都放在这个子模块中，如果其他项目需要使用，我们直接引入就行，引入方式如下（下面截图是从service模块引入dao模块的，这里的groupId，artifactId，version我们可以在dao的pom文件中直接复制使用）：<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd34f0c9671a6d?w=562&amp;h=82&amp;f=jpeg&amp;s=7070" alt=""><br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd34fdf62d1288?w=735&amp;h=289&amp;f=jpeg&amp;s=33325" alt=""><br>（上面新建的过程只作为演示而用，下面的引入和上面的新建项目并非一个项目）<br>其他的模块构建和dao的构建过程是一样的，这里就不一一构建了。源码地址在下面，解压之后，以maven项目方式导入，修改下数据库配置文件应该就可以直接运行了（当前项目基于jdk1.7写的，有的小伙伴如果用1.8的话，应该会出现jsp无法编译的一个错误）；源码附件中还有一个setting文件,阿里的，个人觉得用起来很不错，也推荐给大家!</li></ul><p>源码地址：<a href="http://download.csdn.net/download/sinat_25518349/10124726" target="_blank" rel="noopener">http://download.csdn.net/download/sinat_25518349/10124726</a><br>【这个是csdn的地址，现在资源上传还必需要选择C币，小伙伴如果没有csdn账户或者C币不足，可以在文章留言区留言，留下邮箱，我发给你们】</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
            <tag> ssm </tag>
            
            <tag> spring </tag>
            
            <tag> web </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>多态、接口和抽象类</title>
      <link href="/2018/11/10/glmapper-bird-two/"/>
      <url>/2018/11/10/glmapper-bird-two/</url>
      
        <content type="html"><![CDATA[<p><code>面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。</code></p><p><strong>多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）</strong></p><h2 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h2><ul><li><p>静态绑定和动态绑定<br><strong>这里所谓的绑定，即一个方法的调用与方法所在的类（方法主体）关联起来。</strong></p><p><strong>静态绑定（前期绑定）</strong>：即在程序执行前，即编译的时候已经实现了该方法与所在类的绑定，像C就是静态绑定。<br>  java中只有static，final，private和构造方法是静态绑定，其他的都属于动态绑定，而private的方法其实也是final方法（隐式），而构造               方法其实是一个static方法（隐式），所以可以看出把方法声明为final，第一可以让他不被重写，第二也可以关闭它的动态绑定。</p><p><strong>动态绑定（后期绑定）</strong>：运行时根据对象的类型进行绑定，java中的大多数方法都是属于动态绑定，也就是实现多态的基础。<br>  java实现了后期绑定，则必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。 也就是说，编译的时候该方法不与所在类绑定，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。java里实现动态绑定的是JVM.</p></li></ul><p><strong>动态绑定是实现多态的技术，是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</strong></p><h2 id="多态的作用"><a href="#多态的作用" class="headerlink" title="多态的作用"></a>多态的作用</h2><p>消除类型之间的耦合关系。即：把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。</p><h2 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h2><p>一、要有继承；<br>二、要有重写；<br>三、父类引用指向子类对象。</p><h2 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h2><p>1.可替换性（substitutability）。多态对已存在代码具有可替换性。<br>2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。<br>3.接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。<br>4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。<br>5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。</p><h2 id="多态的实现方式"><a href="#多态的实现方式" class="headerlink" title="多态的实现方式"></a>多态的实现方式</h2><p>Java中多态的实现方式：</p><ul><li>接口实现</li><li>继承父类进行方法重写</li><li>同一个类中进行方法重载。<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2>无论工作还是学习中，笔都是我们经常用到的工具。但是笔的种类又非常的繁多，铅笔、签字笔、水笔、毛笔、钢笔…。现在我们要对“笔”进行抽象，抽象成一个抽象父类“Pen”</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.demo.base;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 抽象父类：笔</span><br><span class="line"> * @author glmapper</span><br><span class="line"> */</span><br><span class="line">public abstract class Pen &#123;</span><br><span class="line">//笔的长度</span><br><span class="line">private int length;</span><br><span class="line">//颜色</span><br><span class="line">private String color;</span><br><span class="line">//类型</span><br><span class="line">private String type;</span><br><span class="line">//价格</span><br><span class="line">private double price;</span><br><span class="line"></span><br><span class="line">//写字</span><br><span class="line">public abstract void write(String cnt);</span><br><span class="line"></span><br><span class="line">public int getLength() &#123;</span><br><span class="line">return length;</span><br><span class="line">&#125;</span><br><span class="line">public void setLength(int length) &#123;</span><br><span class="line">this.length = length;</span><br><span class="line">&#125;</span><br><span class="line">public String getColor() &#123;</span><br><span class="line">return color;</span><br><span class="line">&#125;</span><br><span class="line">public void setColor(String color) &#123;</span><br><span class="line">this.color = color;</span><br><span class="line">&#125;</span><br><span class="line">public String getType() &#123;</span><br><span class="line">return type;</span><br><span class="line">&#125;</span><br><span class="line">public void setType(String type) &#123;</span><br><span class="line">this.type = type;</span><br><span class="line">&#125;</span><br><span class="line">public double getPrice() &#123;</span><br><span class="line">return price;</span><br><span class="line">&#125;</span><br><span class="line">public void setPrice(double price) &#123;</span><br><span class="line">this.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有两个子类，分别是：铅笔和钢笔。</p><p>铅笔类，继承父类Pen，并重写write方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.demo.base;</span><br><span class="line">/**</span><br><span class="line"> * 铅笔类 继承父类 笔（满足必要条件一：有继承【其实如果是接口的话，implement实现也是可以的】）</span><br><span class="line"> * @author glmapper</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Pencil extends Pen&#123;</span><br><span class="line">/**</span><br><span class="line"> * 父类的抽象方法委托子类具体实现：覆盖</span><br><span class="line"> */</span><br><span class="line"> //满足必要条件二：要有重写【当然，如果是对于write有重载也是可以的，不同的概念而已】</span><br><span class="line">@Override</span><br><span class="line">public void write(String cnt) &#123;</span><br><span class="line">System.out.println(&quot;这是一只铅笔写的内容，内容是：&quot;+cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>钢笔类，继承父类Pen，并重写write方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.demo.base;</span><br><span class="line">/**</span><br><span class="line"> * 钢笔类 继承父类 笔</span><br><span class="line"> * @author 17070738</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Fountainpen extends Pen&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void write(String cnt) &#123;</span><br><span class="line">System.out.println(&quot;这是一支钢笔写的内容，内容是：&quot;+cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.demo.base;</span><br><span class="line"></span><br><span class="line">public class MainTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">/*Pen pen= new Pencil();*/</span><br><span class="line">    //必要条件三：父类引用指向子类对象。</span><br><span class="line">Pen pen= new Fountainpen();</span><br><span class="line">pen.write(&quot;我是一支笔&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：这是一支钢笔写的内容，内容是：我是一支笔</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>可替换性：多态对笔Pen类工作，对其他任何子类，如铅笔、钢笔，也同样工作。<br>可扩充性：在实现了铅笔、钢笔的多态基础上，很容易增添“笔”类的多态性。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>一个Java接口，就是一些方法特征的集合。【本文角度并非是java基础角度来说，主要是以设计模式中的应用为背景，因此对于相关定义及用法请自行学习。<a href="http://www.runoob.com/java/java-interfaces.html】" target="_blank" rel="noopener">http://www.runoob.com/java/java-interfaces.html】</a><br>我们在平时的工作中，提到接口，一般会含有两种不同的含义，</p><ul><li>指的是java接口，这是一种java语言中存在的结构，有特定的语法和结构</li><li>指一个类所具有的方法特征的集合，是一种逻辑上的抽象。</li></ul><p>前者叫做“java接口”，后者叫着“接口”。例如：java.lang.Runnable就是一个java接口。</p><h2 id="为什么使用接口"><a href="#为什么使用接口" class="headerlink" title="为什么使用接口"></a>为什么使用接口</h2><p>我们考虑一下，假如没有接口会怎么样呢？一个类总归是可以通过继承来进行扩展的，这难道不足以我们的实际应用吗？<br>一个对象需要知道其他的一些对象，并且与其他的对象发生相互的作用，这是因为这些对象需要借住于其他对象的行为以便于完成一项工作。这些关于其他对象的知识，以及对其他对象行为的调用，都是使用硬代码写在类里面的，可插入性几乎为0。如：钢笔中需要钢笔水，钢笔水有不同的颜色：<br>钢笔水类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.demo.base;</span><br><span class="line">/**</span><br><span class="line"> * 钢笔墨水</span><br><span class="line"> * @author glmapper</span><br><span class="line"> */</span><br><span class="line">public class PenInk &#123;</span><br><span class="line">//墨水颜色</span><br><span class="line">private String inkColor;</span><br><span class="line"></span><br><span class="line">public String getInkColor() &#123;</span><br><span class="line">return inkColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setInkColor(String inkColor) &#123;</span><br><span class="line">this.inkColor = inkColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public PenInk(String inkColor) &#123;</span><br><span class="line">super();</span><br><span class="line">this.inkColor = inkColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>钢笔中持有一个墨水类的对象引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.demo.base;</span><br><span class="line">/**</span><br><span class="line"> * 钢笔类 继承父类 笔</span><br><span class="line"> * @author 17070738</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Fountainpen extends Pen&#123;</span><br><span class="line">    //引用持有</span><br><span class="line">PenInk ink =new PenInk(&quot;black&quot;);</span><br><span class="line">@Override</span><br><span class="line">public void write(String cnt) &#123;</span><br><span class="line">System.out.println(&quot;钢笔墨水颜色是：&quot;+ink.getInkColor());</span><br><span class="line">System.out.println(&quot;这是一支钢笔写的内容，内容是：&quot;+cnt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种时候，我们需要换一种颜色怎么办呢？就必须要对Fountainpen中的代码进行修改，将创建PenInk对象时的inkColor属性进行更改；现在假如我们有一个具体的类，提供某种使用硬代码写在类中的行为；<br>现在，要提供一些类似的行为，并且可以实现动态的可插入，也就是说，要能够动态的决定使用哪一种实现。一种方案就是为这个类提供一个抽象父类，且声明出子类要提供的行为，然后让这个具体类继承自这个抽象父类。同时，为这个抽象父类提供另外一个具体的子类，这个子类以不同的方法实现了父类所声明的行为。客户端可以动态的决定使用哪一个具体的子类，这是否可以提供可插入性呢？<br>改进之后的代码：<br>子类1：黑色墨水<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.demo.base;</span><br><span class="line">/**</span><br><span class="line"> * 黑色墨水</span><br><span class="line"> * @author glmapper</span><br><span class="line"> */</span><br><span class="line">public class BlackInk extends PenInk&#123;</span><br><span class="line"></span><br><span class="line">public BlackInk() &#123;</span><br><span class="line">super(&quot;black&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>子类2：蓝色墨水</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.demo.base;</span><br><span class="line">/**</span><br><span class="line"> * 蓝色墨水</span><br><span class="line"> * @author glmapper</span><br><span class="line"> */</span><br><span class="line">public class BlueInk extends PenInk&#123;</span><br><span class="line"></span><br><span class="line">public BlueInk() &#123;</span><br><span class="line">super(&quot;blue&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>钢笔类引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.demo.base;</span><br><span class="line">/**</span><br><span class="line"> * 钢笔类 继承父类 笔</span><br><span class="line"> * @author 17070738</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Fountainpen extends Pen&#123;</span><br><span class="line">PenInk ink ;</span><br><span class="line">//通过构造函数初始化PenInk ，PenInk由具体子类来实现</span><br><span class="line">public Fountainpen(PenInk ink) &#123;</span><br><span class="line">this.ink = ink;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void write(String cnt) &#123;</span><br><span class="line">System.out.println(&quot;钢笔墨水颜色是：&quot;+ink.getInkColor());</span><br><span class="line">System.out.println(&quot;这是一支钢笔写的内容，内容是：&quot;+cnt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">/**</span><br><span class="line"> * 使用黑色墨水子类</span><br><span class="line"> */</span><br><span class="line">Pen pen= new Fountainpen(new BlackInk());</span><br><span class="line">pen.write(&quot;我是一支笔&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，确实可以在简单的情况下提供了动态可插入性。</p><p>但是由于java语言是一个单继承的语言，换言之，一个类只能有一个超类，因此，在很多情况下，这个具体类可能已经有了一个超类，这个时候，要给他加上一个新的超类是不可能的。如果硬要做的话，就只好把这个新的超类加到已有的超类上面，形成超超类的情况，如果这个超超类的位置也已经被占用了，就只好继续向上移动，直到移动到类等级结构的最顶端。这样一来，对一个具体类的可插入性设计，就变成了对整个等级结构中所有类的修改。这种还是假设这些超类是我们可以控制的，如果某些超类是由一些软件商提供的，我们无法修改，怎么办呢？因此，假设没有接口，可插入性就没有了保证。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>java接口（以及java抽象类）用来声明一个新的类型。<br>java设计师应当主要使用java接口和抽象类而不是具体类进行变量的类型声明、参数的类型声明、方法的返还类型声明，以及数据类型的转换等。当然，一个更好的做法是仅仅使用java接口，而不要使用抽象java类来做到上面这些。在理想的情况下，一个具体java类应当只实现java接口和抽象类中声明过的方法，而不应该给出多余的方法。</p><ul><li>类型等级结构<br>java接口（以及抽象类）一般用来作为一个类型的等级结构的起点<br>java的类型是以类型等级结构的方式组织起来的，在一个类型等级结构里面，一个类型可以有一系列的超类型，这时这个类型叫做其超类型的子类型。子类型的关系是传递性：类型甲是类型乙的子类型，类型乙是类型丙的子类型，那么类型甲就是类型丙的子类型。</li><li>混合类型<br>如果一个类已经有一个主要的超类型，那么通过实现一个接口，这个类可以拥有另一个次要的超类型。这种次要的超类型就叫做混合类型。例如：在java中，<br><img src="https://user-gold-cdn.xitu.io/2017/11/17/15fc7f7b4eacb5bd?w=569&amp;h=60&amp;f=png&amp;s=4293" alt=""></li></ul><p>TreeMap类有多个类型，它的主要类型是AbstractMap,这是一种java的聚集；而Cloneable接口则给出了一个次要类型，这个类型说明当前类的对象是可以被克隆；同时Serializable也是一个次要类型，它表明当前类的对象是可以被序列化的。而NavigableMap继承了SortedMap,因为之前说到过，子类型是可以传递的，因此对于TreeMap来说，SortedMap（或者说NavigableMap）表明这个聚集类是可以排序的。</p><h2 id="接口的一些用法"><a href="#接口的一些用法" class="headerlink" title="接口的一些用法"></a>接口的一些用法</h2><ul><li><p>单接口方法：接口中只有一个方法；java语言中有很多但方法接口的使用，Runnalble接口中的run（）方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface Runnable &#123;</span><br><span class="line">    /**</span><br><span class="line">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span><br><span class="line">     * to create a thread, starting the thread causes the object&apos;s</span><br><span class="line">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span><br><span class="line">     * thread.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span><br><span class="line">     * take any action whatsoever.</span><br><span class="line">     *</span><br><span class="line">     * @see     java.lang.Thread#run()</span><br><span class="line">     */</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>标识接口：没有任何方法和属性的接口；标识接口不对实现它的类有任何语义上的要求，仅仅是表明实现该接口的类属于一个特定的类型。上面说到的Serializable接口就是一种标识接口。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>常量接口：用java接口来声明一些常量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.demo.base;</span><br><span class="line"></span><br><span class="line">public interface MyConstants &#123;</span><br><span class="line">public static final String USER_NAME=&quot;admin&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样一来，凡是实现这个接口的类都会自动继承这些常量，并且都可以像使用自己的常量一样，不需要再用MyConstants.USER_NAME来使用。</p><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>在java语言里面，类有两种，一种是具体类，一种是抽象类。在上面给出的代码中，使用absract修饰的类为抽象类。没有被abstract修饰的类是具体类。抽象类通常代表一个抽象概念，它提供一个继承的出发点。而具体类则不同，具体类可以被实例化，应当给出一个有逻辑实现的对象模板。由于抽象类不可以被实例化，因此一个程序员设计一个新的抽象类，一定是用来被继承的。（不建议使用具体类来进行相关的继承）。</p><h2 id="关于代码重构"><a href="#关于代码重构" class="headerlink" title="关于代码重构"></a>关于代码重构</h2><p>假设有两个具体类，类A和类B，类B是类A的子类，那么一个比较简单的方案应该是建立一个抽象类（或者java接口），暂定为C，然后让类A和类B成为抽象类C的子类【没有使用UML的方式来绘制，请见谅哈】。</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/17/15fc8d2c928e38c6?w=627&amp;h=207&amp;f=png&amp;s=61903" alt=""><br>上面其实就是里氏替换原则，后面会具体介绍到的。这种重构之后，我们需要做的就是如何处理类A和类B的共同代码和共同数据。下面给出相关准则。</p><ul><li>抽象类应当拥有尽可能多的共同代码</li></ul><p><img src="https://user-gold-cdn.xitu.io/2017/11/17/15fc8dfab440eee6?w=793&amp;h=538&amp;f=png&amp;s=188139" alt=""><br>在一个继承等级结构中，共同的代码应当尽量向结构的顶层移动，将重复的代码从子类中抽离，放在抽象父类中，提高代码的复用率。这样做的另外一个好处是，在代码发生改变时，我们只需要修改一个地方【因为共同代码均在父类中】。</p><ul><li>抽象类应当拥有尽可能少的数据<br>数据的移动方向是从抽象类到具体类，也就是从继承等级的顶层到底层的移动。我们知道，一个对象的数据不论是否使用都会占用资源，因此数据应当尽量放到具体类或者继承等级结构的低端。</li></ul><h2 id="Has-A-与Is-A"><a href="#Has-A-与Is-A" class="headerlink" title="Has - A 与Is -A"></a>Has - A 与Is -A</h2><p>当一个类是另外一个类的角色时【我  有一个 玩具】，这种关系就不应当使用继承来描述了，这个将会在后面说到的“合成/聚合复用原则”来描述。<br>Has - A: 我有一只笔（聚合）<br>Is - A:钢笔是一种笔（继承）</p><h2 id="关于子类扩展父类的责任"><a href="#关于子类扩展父类的责任" class="headerlink" title="关于子类扩展父类的责任"></a>关于子类扩展父类的责任</h2><p>子类应当扩展父类的职责，而不是置换掉或者覆盖掉超类的职责。如果一个子类需要将继承自父类的责任取消或者置换后才能使用的话，就很有可能说明这个子类根本不属于当前父类的子类，存在设计上的缺陷。</p><p>最后，说明下，我们在平时的工作中会经常使用的工具类，再次特地申明一下，我们也尽可能少的去从工具类进行继承扩展。</p><p>参考：</p><ul><li>《Java与模式》电子工业出版社出版，作者：阎宏。</li><li><a href="http://www.runoob.com/java/java-interfaces.html" target="_blank" rel="noopener">http://www.runoob.com/java/java-interfaces.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面向对象的四大基础特性</title>
      <link href="/2018/11/10/glmapper-bird-one/"/>
      <url>/2018/11/10/glmapper-bird-one/</url>
      
        <content type="html"><![CDATA[<p>按照之前的学习规划，开始进行第一部分的学习。那么今天就重新认识一下JAVA中的四大特性：抽象、封装、继承、多态</p><h1 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h1><p>学习面向对象，抽象还是很重要的。面向对象最接近我们人类的思维，你的抽象能力就是你对万物万事总结和归纳的能力。关于抽象，就是从具体事物抽出、概括出它们共同的方面、本质属性与关系等，而将个别的、非本质的方面、属性与关系舍弃，这种思维过程，称为抽象。在JAVA中表现就是使用abstract来修饰类，被abstract修饰的类成为抽象类，一般是为了为子类提供一些共有的属性和行为，不同的子类根据自身的特性再进行具体的行为实现。</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>封装是面向对象的重要原则，就是把对象的属性和行为（方法）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节；在java中，对于对象的内部属性一般用private来实现隐藏，并通过set和get方法对外提供访问接口。封装实际上是一种信息隐藏技术的实现方式。</p><ul><li>对象的数据封装特性彻底消除了传统结构方法中数据与操作分离所带来的种种问题，提高了程序的可复用性和可维护性，降低了程序员保持数据与操作内容的负担。</li><li>对象的数据封装特性还可以把对象的私有数据和公共数据分离开，保护了私有数据，减少了可能的模块间干扰，达到降低程序复杂性、提高可控性的目的。</li></ul><p>例如：对于客观存在的人这个对象进行属性和行为抽象【此处仅仅是部分抽象】；使用private关键字来修饰人的属性，并通过对应的set和get方法对外界提供访问入口；在行为方面，通过public关键字来修饰，对外提供具体的行为描述。外界对象并不知道“人”这个对象在内部发生了什么，仅仅是通过提供的方法来获得具体的描述信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 人</span><br><span class="line"> * @author glmapper</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Person &#123;</span><br><span class="line">//姓名</span><br><span class="line">private String name;</span><br><span class="line">//年龄</span><br><span class="line">private int age;</span><br><span class="line">//性别</span><br><span class="line">private String sex;</span><br><span class="line">//身高</span><br><span class="line">private float high;</span><br><span class="line">//体重</span><br><span class="line">private float weight;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">public int getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">public String getSex() &#123;</span><br><span class="line">return sex;</span><br><span class="line">&#125;</span><br><span class="line">public void setSex(String sex) &#123;</span><br><span class="line">this.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line">public float getHigh() &#123;</span><br><span class="line">return high;</span><br><span class="line">&#125;</span><br><span class="line">public void setHigh(float high) &#123;</span><br><span class="line">this.high = high;</span><br><span class="line">&#125;</span><br><span class="line">public float getWeight() &#123;</span><br><span class="line">return weight;</span><br><span class="line">&#125;</span><br><span class="line">public void setWeight(float weight) &#123;</span><br><span class="line">this.weight = weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void eat()&#123;</span><br><span class="line">System.out.println(&quot;吃东西&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void walk()&#123;</span><br><span class="line">System.out.println(&quot;走路&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void study()&#123;</span><br><span class="line">System.out.println(&quot;学习&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承是面向对象最显著的一个特性，是从已有的类中派生出新的类，我们把它称之为子类，子类继承父类的属性和行为，并能根据自己的需求扩展出新的属性和行为，提高了代码的可复用性。 </p><ul><li>提高了代码的复用性。</li><li>让类与类之间产生了关系，给第三个特征多态提供了前提。</li></ul><p>Java的继承通过extends关键字来实现，实现继承的类被称为子类，被继承的类称为父类(有的也称其为基类、超类)，父类和子类的关系，是一种一般和特殊的关系；子类扩展父类，将可以获得父类的全部属性和方法。</p><p>男人是人的一种，男人的特征是有胡子，因此也有剪胡子的行为【有胡子和剪胡子并非依赖关系；一个是属性，一个是行为】；但是男人继承了人这个父类，因此，男人也具有例如姓名、性别、身高、体重等属性，同时也具有父类人具有的吃饭、走路和学习的行为。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 男人</span><br><span class="line"> * @author glmapper</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Man extends Person&#123;</span><br><span class="line">//胡子</span><br><span class="line">private String  goatee;</span><br><span class="line"></span><br><span class="line">public String getGoatee() &#123;</span><br><span class="line">return goatee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setGoatee(String goatee) &#123;</span><br><span class="line">this.goatee = goatee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void shaved()&#123;</span><br><span class="line">System.out.println(&quot;剪胡子&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重写父类的方法：<br>大部分的时候，子类总是以父类为基础，额外添加新的属性和方法。但有一种情况例外：子类需要重写父类的方法。例如男人吃东西比较快，女人吃东西比较慢，因此对于eat方法来说，Man可以覆盖父类的eat方法，来描述Man本身的特点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void eat()&#123;</span><br><span class="line">System.out.println(&quot;快速的吃东西&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当子父类中出现相同方法时，会先运行子类中的方法。<br>重写的特点：方法名一样，访问修饰符权限不小于父类，返回类型一致，参数列表一致。</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）<br>实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。从语言特点上来说，Java引用变量有两个类型：一个是编译时类型，一个是运行时类型。编译时的类型由声明该变量时使用的类型决定，运行时的类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，就会出现所谓的多态（Polymorphism）。<br>封装和继承都是为Java语言的多态提供了支撑；多态存在的三个必要条件：</p><ul><li>要有继承；</li><li>要有重写；</li><li>父类引用指向子类对象。</li></ul><p>具体的实现方式就是：接口实现，继承父类进行方法重写，同一个类中进行方法重载。</p><p>下一篇在说类和接口的时候再用具体的例子来描述覆盖、重载。</p>]]></content>
      
      
      <categories>
          
          <category> java 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>菜鸟成长系列-概述</title>
      <link href="/2018/11/10/glmapper-bird-overall/"/>
      <url>/2018/11/10/glmapper-bird-overall/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为渣硕一枚，毕业时一线互联网公司招聘基本没有参与过，等回过神准备参加，春招都快结束了【17年毕业】；跌跌撞撞面了几家公司，虽然被虐，但是基本上都给了Offer，几番比较之后到了苏宁，选择做一枚金融码农。虽然网上关于在苏宁做IT有着不同的看法，有好有坏，褒贬不一，但就我而言，作为新人，苏宁还是给我提供了不错的工作和学习环境【入职快4个月了】。<br>言归正传，作为一个初入职场的新人，面对很多复杂的业务场景，不同的开源技术的使用，一开始确实有点“慌”，但是随着慢慢的渗入，从能够将一个项目成功跑起来，到对着详设给代码加注释，到自己去画某一条业务线的流程图，到第一次独立完成一个需求，再到不断的去发现现有框架或者业务逻辑中的问题并去尝试优化；这个过程还是很“吃鸡”的。技术始终是来支撑业务的，熟悉产品很重要，只有深入了解了某一个业务，然后拓展出与其他业务的关系，这样才可以发现问题，找到切入点去做具体的代码优化和业务优化。所以人人都是产品经理这句话很中肯，特别是程序员，要学会和产品经理“讨价还价”。</p><h1 id="为什么要写"><a href="#为什么要写" class="headerlink" title="为什么要写"></a>为什么要写</h1><p>为什么要写，最开始的想法就是把自己工作中的问题和坑记录下来，以便于自己不会再调到坑里面去。但是后来发现跑偏了，在没有具体深入了解的情况下开始“借鉴”+“总结”。后来再去看，该不会的还是不会，这就很无奈。<br>网上有很多什么“JAVA学习路线一览”、“数据库学习路线一览”，“Spring学习路线一览”。。。，实话实说，尝试过，但是都失败了，走不下去。比如说我想学习java集合，然后就去看，去总结，然后就会发现，线程安全和不安全在集合里面的比较很多，然后就去看线程安全相关，然后再走，就会发现从这个坑跳到了另外一个坑，一方面是没有足够的时间去研究，另一方面没有把自己的思维放进去，结果就是学到的还是很碎的东西。因此放弃别人的成功之路，回来走自己的独木桥。结合自己之前的一些技术积累和实际工作的需求，来整合。<br>看了很多，却发现深入的不多。一开始想的是从java的Object开始写，但是当我去尝试一次之后就放弃了【其实从java基础类库学还是很不错的】；我觉得不适合我这种不按套路出牌的人，因此就给自己定了一个框，在框里学。这个框是什么呢？就是设计模式。<br>无论是java基础类库的设计还是Spring体系的设计基本都离不开设计模式的使用，为什么说不从Object开始，不从Spring的启动开始就是因为当我顺着一条线开始走的时候，就会牵扯出无数条线，直到不知道去往哪一条开始。只有当前站在顶层去看整体的时候，才会对全局有一个把握，才能直到不同分支的关系，才能更好的学抓细节。</p><h1 id="写什么"><a href="#写什么" class="headerlink" title="写什么"></a>写什么</h1><p>我的想法是以设计模式为主线来贯穿，开始重新学习。【从java语言的角度】<br>设计模式中基本上都是围绕六种设计原则来约束的，再利用JAVA中提供抽象、继承、多态提供的机制来进行具体的实现。顺着这个思路简单罗列下我自己的学习路线：<br>因为需要使用JAVA，那么就必须先要对抽象、继承和多态有一个比较清楚的理解，因此第一部分将会从java语言本身的特色来学习，主要包括：</p><ul><li>1.抽象，继承，多态的理解</li><li>2.类和接口</li><li>3.面向接口编程的理解<br>OK，到此就收，第一部分就把后面设计模式中我们需要用的方式的基础定了个基调。<br>第二部分就直接进入设计模式范畴之内：</li><li>1.设计原则</li><li>2.创建型</li><li>3.结构型</li><li>4.行为型<br>在学习某个具体的设计模式的时候会结合java语言中某些类库来讨论，穿插学习；<br>第二部分之后，对于设计模式、设计模式在java中的应用、Spring的顶层设计以及java中的一些类库会有一个大体的掌握。这个部分会需要很长时间，会涉及到的知识点会很多，有点慌。<br>第三部分开始数据结构，为什么是数据结构而不是并发或者数据库呢。一方面在java中很多关于并发的问题都会涉及到集合的使用，集合内部就依赖于不同的数据结构；数据库方面，如果都不清楚数据库是怎么存数据的，就不可能知道怎么去优化；如果都不知道数据库中的数据的存储结构是什么，又怎么能知道数据是怎么存的呢？<br>上面三个部分结束之后，关于java差不多也就结束了。那么作为一个程序员，对于网络理解和开源技术的使用才是真正快速解决实际问题和吃饭问题的根本。<br>spring、mybatis、redis，struts2,hibernate,以及相关rpc框架。<br>关于java虚拟机这个东西不会单独的写了，感觉写不出来，等有了实际的经验积累之后再去谈吧。。。<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1>其实我们每个人每天都会有想法，好坏不说，要去试试，这篇文章写完之后我也不知道自己能走到哪个部分，但是还是回去尝试走一走。我也不知道这种学习的“野路子”适合不适合，但是就现在【2017.11.5 11:59】看，我觉得对我是可以的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 架构之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>项目开发框架-SSM</title>
      <link href="/2018/11/10/project-frame-ssm/"/>
      <url>/2018/11/10/project-frame-ssm/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Spring"><a href="#1-Spring" class="headerlink" title="1.Spring"></a>1.Spring</h1><p>无需多言，作为开源届数一数二的典例，项目开发中无处不在；<br>核心IOC容器，用来装载bean（java中的类）-用Spring的IOC容器来管理Bean的生命周期，有了这样一种机制，我们就可以不用在代码中去重复的做new操作。<br>aop，面向切面编程，spring中最主要的是用于事务方面的使用。</p><h1 id="2-Spring-MVC"><a href="#2-Spring-MVC" class="headerlink" title="2.Spring MVC"></a>2.Spring MVC</h1><p>作用于web层，相当于controller，与struts中的action一样，都是用来处理用户请求的。同时，相比于struts2来说，更加细粒度，它是基于方法层面的，而struts是基于类层面的。<br><img src="https://user-gold-cdn.xitu.io/2017/10/28/ab2648fd768293a6fa61959ba1dbbc40" alt=""></p><h1 id="3-MyBatis"><a href="#3-MyBatis" class="headerlink" title="3.MyBatis"></a>3.MyBatis</h1><p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。[来自：<a href="http://www.mybatis.org/mybatis-3/zh/index.html]" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/zh/index.html]</a></p><p><strong>他人总结</strong></p><ul><li>Hibernate功能强大，数据库无关性好，O/R映射能力强，如果你对Hibernate相当精通，而且对Hibernate进行了适当的封装，那么你的项目整个持久层代码会相当简单，需要写的代码很少，开发速度很快，非常爽。 </li><li>Hibernate的缺点就是学习门槛不低，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡取得平衡，以及怎样用好Hibernate方面需要你的经验和能力都很强才行。 </li><li>MYBATIS入门简单，即学即用，提供了数据库查询的自动对象绑定功能，而且延续了很好的SQL使用经验，对于没有那么高的对象模型要求的项目来说，相当完美。 </li><li>MYBATIS的缺点就是框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。<h1 id="4-SSM框架整合"><a href="#4-SSM框架整合" class="headerlink" title="4.SSM框架整合"></a>4.SSM框架整合</h1>本项目将以购物为背景，主要包括商品信息及库存【因为想顺便学习一下事务的处理】、订单信息。下面将从数据库创建、项目结构说明、配置文件、业务代码等方面进行一步步说明。<h2 id="4-1-数据库创建"><a href="#4-1-数据库创建" class="headerlink" title="4.1 数据库创建"></a>4.1 数据库创建</h2>1.商品表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `goods` (</span><br><span class="line">  `goods_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;商品ID&apos;,</span><br><span class="line">  `goodsname` varchar(100) NOT NULL COMMENT &apos;商品名称&apos;,</span><br><span class="line">  `number` int(11) NOT NULL COMMENT &apos;商品库存&apos;,</span><br><span class="line">   PRIMARY KEY (`goods_id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8 COMMENT=&apos;商品表&apos;</span><br></pre></td></tr></table></figure></li></ul><p>初始化表数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `goods` (`goods_id`, `goodsname`, `number`)</span><br><span class="line">VALUES (1001, &apos;SN卫衣&apos;, 15)</span><br></pre></td></tr></table></figure></p><p>2.订单表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `orderinfo` (</span><br><span class="line">  `order_id` varchar(20) NOT NULL COMMENT &apos;订单编号&apos;,</span><br><span class="line">  `goods_id` bigint(18) NOT NULL COMMENT &apos;商品ID&apos;,</span><br><span class="line">  `user_id` bigint(10) NOT NULL COMMENT &apos;用户ID&apos;,</span><br><span class="line">  `order_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &apos;下单时间&apos; ,</span><br><span class="line">   PRIMARY KEY (`order_id`),</span><br><span class="line">   INDEX `idx_order_id` (`order_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;订单表&apos;</span><br></pre></td></tr></table></figure></p><p>OK，至此表结构及初始化数据构建完成，下面说下基于Mavan的项目结构。</p><h2 id="项目结构说明"><a href="#项目结构说明" class="headerlink" title="项目结构说明"></a>项目结构说明</h2><p>因为项目是使用maven来管理jar包的，先来贴一下，pom.xml的配置</p><ul><li>pom.xml<br>为了避免学习小伙伴崇尚拿来主义【也就是去除了xmlns之类的东西】，这里只放项目依赖的jar包的dependencies；本案例将本着“需则用”的原则，避免在网上看到的各种乱七八糟的依赖都丢进来的情况，造成资源浪费和干扰阅读。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;!-- 单元测试 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 1.日志 slf4j--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.1.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 2.数据库连接驱动 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;5.1.37&lt;/version&gt;</span><br><span class="line">&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 2.数据库连接池 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;c3p0&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;c3p0&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.9.1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 3.MyBatis 以及 spring-mybatis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 4.Servlet 相关依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;taglibs&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;standard&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;jstl&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jstl&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.5.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 5.Spring --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 5.1 Spring核心 ：core bean context --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 5.2 Spring jdbc依赖，事务依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-tx&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 5.3 Spring web依赖&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 5.4 Spring test --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 6.redis客户端:Jedis【不使用的话可以直接去除】 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;protostuff-core&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;protostuff-runtime&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 7.工具类 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li></ul><p>*项目结构图</p><p><img src="https://user-gold-cdn.xitu.io/2017/10/28/2c7ad9c13a987f35dec09b1aa58d8eb8" alt=""><br><em>src/test/java：用于junit的测试类</em>src/main/java:<br>   dao:数据库处理<br>   service:业务处理<br>   enums:项目枚举<br>   mapper:dao中方法对应mybatis映射文件，Sql就在这里面<br>   web：控制器，controller<br>   entity:项目中的实体类，如：商品类和订单类</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul><li>jdbc.properties<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://serverName:port/dbname?useUnicode=true&amp;characterEncoding=utf8</span><br><span class="line">jdbc.username=[填写自己的数据库用户名]</span><br><span class="line">jdbc.password=[填写自己的数据库登录密码]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>logback.xml<br>这里直接用的是控制台输出，如果是生产环境，可以根据具体的需求进行配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;configuration debug=&quot;true&quot;&gt;</span><br><span class="line">&lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line"> ch.qos.logback.classic.encoder.PatternLayoutEncoder --&gt;</span><br><span class="line">&lt;encoder&gt;</span><br><span class="line">&lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;</span><br><span class="line">&lt;/encoder&gt;</span><br><span class="line">&lt;/appender&gt;</span><br><span class="line">&lt;root level=&quot;debug&quot;&gt;</span><br><span class="line">&lt;appender-ref ref=&quot;STDOUT&quot; /&gt;</span><br><span class="line">&lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p>mybatis-config<br>这里主要是MyBaties全局配置文件的配置，可以将一些类的别名、主键自增配置、驼峰命名规则配置等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!-- 配置全局属性 --&gt;</span><br><span class="line">&lt;settings&gt;</span><br><span class="line">&lt;!-- 使用jdbc的getGeneratedKeys获取数据库自增主键值 --&gt;</span><br><span class="line">&lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用列别名替换列名 默认:true --&gt;</span><br><span class="line">&lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启驼峰命名转换:Table&#123;create_time&#125; -&gt; Entity&#123;createTime&#125; --&gt;</span><br><span class="line">&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/settings&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p>spring 相关配置文件<br>为了更加清晰的了解spring各个组件的作用，这里将数据源的配置、事务配置和视图解析器的配置分开来。<br><strong>spring-dao.xml</strong><br>这里面主要就是spring配置整合mybatis的具体过程，具体包括：<br>1.引入数据库配置文件<br>2.配置数据源【数据库连接池】<br>3.配置SqlSessionFactory对象<br>4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 1.配置数据库相关参数properties的属性：$&#123;url&#125; --&gt;</span><br><span class="line">&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 2.数据库连接池 --&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">&lt;!-- 配置连接池属性 --&gt;</span><br><span class="line">&lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- c3p0连接池的私有属性 --&gt;</span><br><span class="line">&lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot; /&gt;</span><br><span class="line">&lt;!-- 关闭连接后不自动commit --&gt;</span><br><span class="line">&lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">&lt;!-- 获取连接超时时间 --&gt;</span><br><span class="line">&lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot; /&gt;</span><br><span class="line">&lt;!-- 当获取连接失败重试次数 --&gt;</span><br><span class="line">&lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 3.配置SqlSessionFactory对象 --&gt;</span><br><span class="line">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">&lt;!-- 注入数据库连接池 --&gt;</span><br><span class="line">&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">&lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;</span><br><span class="line">&lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot; /&gt;</span><br><span class="line">&lt;!-- 扫描entity包 使用别名 --&gt;</span><br><span class="line">&lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.glmapper.framerwork.entity&quot; /&gt;</span><br><span class="line">&lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt;</span><br><span class="line">&lt;property name=&quot;mapperLocations&quot; value=&quot;com.glmapper.framerwork.mapper/*.xml&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt;</span><br><span class="line">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">&lt;!-- 注入sqlSessionFactory --&gt;</span><br><span class="line">&lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt;</span><br><span class="line">&lt;!-- 给出需要扫描Dao接口包 --&gt;</span><br><span class="line">&lt;property name=&quot;basePackage&quot; value=&quot;com.glmapper.framerwork.dao&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>spring-service<br>实际的开发过程中事务一般都是在service层进行操作。因此用一个单独的spring-service.xml来进行事务的相关的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   &lt;!-- 扫描service包下所有使用注解的类型 --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.glmapper.framerwork.service&quot; /&gt;</span><br><span class="line">&lt;!-- 配置事务管理器 --&gt;</span><br><span class="line">&lt;bean id=&quot;transactionManager&quot;</span><br><span class="line">class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">&lt;!-- 注入数据库连接池 --&gt;</span><br><span class="line">&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 配置基于注解的声明式事务 --&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>spring-web.xml<br>配置SpringMVC；需要说明一下，一般我们在实际的开发过程中，会配置json2map解析。这里没有用到就不贴出来，读者可以自行网上搜索一波。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 1.开启SpringMVC注解模式 --&gt;</span><br><span class="line">&lt;mvc:annotation-driven /&gt;</span><br><span class="line">&lt;!-- 2.静态资源默认servlet配置</span><br><span class="line">(1)加入对静态资源的处理：js,css,图片等</span><br><span class="line">(2)允许使用&quot;/&quot;做整体映射</span><br><span class="line"> --&gt;</span><br><span class="line"> &lt;mvc:default-servlet-handler/&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;!-- 3.配置视图解析器ViewResolver --&gt;</span><br><span class="line"> &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line"> &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;</span><br><span class="line"> &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;</span><br><span class="line"> &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;</span><br><span class="line"> &lt;/bean&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;!-- 4.扫描web相关的bean --&gt;</span><br><span class="line"> &lt;context:component-scan base-package=&quot;com.glmapper.framerwork.web&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>web.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 编码过滤器 --&gt;  </span><br><span class="line">    &lt;filter&gt;  </span><br><span class="line">        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;  </span><br><span class="line">        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;  </span><br><span class="line">        &lt;async-supported&gt;true&lt;/async-supported&gt;  </span><br><span class="line">        &lt;init-param&gt;  </span><br><span class="line">            &lt;param-name&gt;encoding&lt;/param-name&gt;  </span><br><span class="line">            &lt;param-value&gt;UTF-8&lt;/param-value&gt;  </span><br><span class="line">        &lt;/init-param&gt;  </span><br><span class="line">    &lt;/filter&gt;  </span><br><span class="line">    &lt;filter-mapping&gt;  </span><br><span class="line">        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;  </span><br><span class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  </span><br><span class="line">    &lt;/filter-mapping&gt;  </span><br><span class="line">     &lt;!-- Spring监听器 --&gt;  </span><br><span class="line">    &lt;listener&gt;  </span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  </span><br><span class="line">    &lt;/listener&gt;  </span><br><span class="line">    &lt;!-- 防止Spring内存溢出监听器 --&gt;  </span><br><span class="line">    &lt;listener&gt;  </span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt;  </span><br><span class="line">    &lt;/listener&gt; </span><br><span class="line">&lt;!-- 配置DispatcherServlet --&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;</span><br><span class="line">&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;!-- 配置springMVC需要加载的配置文件</span><br><span class="line">spring-dao.xml,spring-service.xml,spring-web.xml</span><br><span class="line">Mybatis - &gt; spring -&gt; springmvc</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;init-param&gt;</span><br><span class="line">&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">&lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;</span><br><span class="line">&lt;!-- 默认匹配所有的请求 --&gt;</span><br><span class="line">&lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></li></ul><p>至此，所有的配置文件结束，下面将进行具体的代码环节</p><h2 id="业务代码"><a href="#业务代码" class="headerlink" title="业务代码"></a>业务代码</h2><p>这里mapper中的xml文件就不贴了，自行脑补。。。。</p><ul><li>实体类：包括商品和订单</li></ul><p><strong>商品类</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 商品信息类</span><br><span class="line"> * @author glmapper</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Goods &#123;</span><br><span class="line">private long goodsId;// 商品ID</span><br><span class="line">private String goodsName;// 商品名称</span><br><span class="line">private int number;// 商品库存</span><br><span class="line"></span><br><span class="line">public long getGoodsId() &#123;</span><br><span class="line">return goodsId;</span><br><span class="line">&#125;</span><br><span class="line">public void setGoodsId(long goodsId) &#123;</span><br><span class="line">this.goodsId = goodsId;</span><br><span class="line">&#125;</span><br><span class="line">public String getGoodsName() &#123;</span><br><span class="line">return goodsName;</span><br><span class="line">&#125;</span><br><span class="line">public void setGoodsName(String goodsName) &#123;</span><br><span class="line">this.goodsName = goodsName;</span><br><span class="line">&#125;</span><br><span class="line">public int getNumber() &#123;</span><br><span class="line">return number;</span><br><span class="line">&#125;</span><br><span class="line">public void setNumber(int number) &#123;</span><br><span class="line">this.number = number;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>订单类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 订单信息类</span><br><span class="line"> * @author glmapper</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class OrderInfo &#123;</span><br><span class="line">private String orderId;//订单ID</span><br><span class="line">private long goodsId;//商品ID</span><br><span class="line">private long userId;//用户ID</span><br><span class="line">private Date orderTime;//下单时间</span><br><span class="line">public String getOrderId() &#123;</span><br><span class="line">return orderId;</span><br><span class="line">&#125;</span><br><span class="line">public void setOrderId(String orderId) &#123;</span><br><span class="line">this.orderId = orderId;</span><br><span class="line">&#125;</span><br><span class="line">public long getGoodsId() &#123;</span><br><span class="line">return goodsId;</span><br><span class="line">&#125;</span><br><span class="line">public void setGoodsId(long goodsId) &#123;</span><br><span class="line">this.goodsId = goodsId;</span><br><span class="line">&#125;</span><br><span class="line">public long getUserId() &#123;</span><br><span class="line">return userId;</span><br><span class="line">&#125;</span><br><span class="line">public void setUserId(long userId) &#123;</span><br><span class="line">this.userId = userId;</span><br><span class="line">&#125;</span><br><span class="line">public Date getOrderTime() &#123;</span><br><span class="line">return orderTime;</span><br><span class="line">&#125;</span><br><span class="line">public void setOrderTime(Date orderTime) &#123;</span><br><span class="line">this.orderTime = orderTime;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>商品dao</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public interface GoodsDao &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 通过ID查询单件商品信息</span><br><span class="line"> * </span><br><span class="line"> * @param id</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">Goods queryById(long id);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 查询所有商品信息</span><br><span class="line"> * </span><br><span class="line"> * @param offset 查询起始位置</span><br><span class="line"> * @param limit 查询条数</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">List&lt;Goods&gt; queryAll(@Param(&quot;offset&quot;) int offset, @Param(&quot;limit&quot;) int limit);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 减少商品库存</span><br><span class="line"> * </span><br><span class="line"> * @param bookId</span><br><span class="line"> * @return 如果影响行数等于&gt;1，表示更新的记录行数</span><br><span class="line"> */</span><br><span class="line">int reduceNumber(long goodsId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>订单dao</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface OrderInfoDao &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 插入订单记录</span><br><span class="line"> * </span><br><span class="line"> * @param OrderInfo orderInfo</span><br><span class="line"> * @return 插入的行数</span><br><span class="line"> */</span><br><span class="line">int insertOrderInfo(OrderInfo orderInfo);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 通过主键查询订单记录，返回订单实体 </span><br><span class="line"> * @param orderId</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">OrderInfo queryByOrderId(String orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>下单服务接口orderService</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">@Service(&quot;orderService&quot;)</span><br><span class="line">public class OrderServiceImpl implements OrderService &#123;</span><br><span class="line">//log生成器</span><br><span class="line">private Logger logger = LoggerFactory.getLogger(OrderServiceImpl.class);</span><br><span class="line"></span><br><span class="line">// 注入dao依赖【商品dao，订单dao】</span><br><span class="line">@Autowired</span><br><span class="line">private GoodsDao goodsDao;</span><br><span class="line">@Autowired</span><br><span class="line">private OrderInfoDao orderInfoDao;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Goods getById(long goodsId) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return goodsDao.queryById(goodsId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public List&lt;Goods&gt; getList(int offset,int limit) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return goodsDao.queryAll(offset, limit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">@Transactional</span><br><span class="line">public OrderInfo buyGoods(long goodsId, long userId) &#123;</span><br><span class="line">//扣减库存，插入订单 =一个事务  如果失败则执行回滚</span><br><span class="line">try &#123;</span><br><span class="line">// 减库存</span><br><span class="line">int update = goodsDao.reduceNumber(goodsId);</span><br><span class="line">if (update &lt;= 0) &#123;// 库存不足</span><br><span class="line">throw new NoNumberException(&quot;no number&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 执行预约操作</span><br><span class="line">OrderInfo orderInfo=new OrderInfo();</span><br><span class="line">orderInfo.setGoodsId(goodsId);</span><br><span class="line">orderInfo.setUserId(userId);</span><br><span class="line">orderInfo.setOrderTime(new Date());</span><br><span class="line">String orderId=getRandomOrderId(goodsId);</span><br><span class="line">orderInfo.setOrderId(orderId);</span><br><span class="line">int insert = orderInfoDao.insertOrderInfo(orderInfo);</span><br><span class="line">if (insert &lt;= 0) &#123;// 重复预约</span><br><span class="line">throw new RepeatAppointException(&quot;repeat appoint&quot;);</span><br><span class="line">&#125; else &#123;// 预约成功</span><br><span class="line">return orderInfo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">//这里可以丰富下具体的返回信息</span><br><span class="line">logger.error(&quot;下单失败&quot;);</span><br><span class="line">&#125; </span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private String getRandomOrderId(long goodsId) &#123;</span><br><span class="line">SimpleDateFormat dateFormater = new SimpleDateFormat(&quot;yyyyMMddhhmmss&quot;);</span><br><span class="line">String prefix=dateFormater.format(new Date());</span><br><span class="line">String goodsIdStr=goodsId+&quot;&quot;;</span><br><span class="line">String temp=&quot;&quot;;</span><br><span class="line">for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">Random random=new Random(goodsIdStr.length()-1);</span><br><span class="line">temp+=goodsIdStr.charAt(random.nextInt());</span><br><span class="line">&#125;</span><br><span class="line">return prefix+temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>OK，至此所有核心代码及配置文件罗列完毕；【mapper中的xml和具体的controller就不贴了，相信大家对这个也不陌生。本文主要意图在于梳理下自己学习中的一些点，SSM框架在实际的应用开发中还会有很多其他的开源技术结合进来，如：quartz,redis等。当前本文的列子就是一个空壳子，以备参考吧】</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
            <tag> ssm </tag>
            
            <tag> spring </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JAVA基础知识系列---进程、线程安全</title>
      <link href="/2018/11/10/java-thread-base/"/>
      <url>/2018/11/10/java-thread-base/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-临界区"><a href="#1-1-临界区" class="headerlink" title="1.1 临界区"></a>1.1 临界区</h2><p>保证在某一时刻只有一个线程能访问数据的简便方法，在任意时刻只允许一个线程对资源进行访问。如果有多个线程试图同时访问临界区，那么在有一个线程进入后，其他所有试图访问临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操作共享资源的目的</p><h2 id="1-2-互斥量"><a href="#1-2-互斥量" class="headerlink" title="1.2 互斥量"></a>1.2 互斥量</h2><p>互斥量和临界区很相似，只能拥有互斥对象的线程才能具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下次共享资源都不会同时被多个线程所访问。当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后可以访问资源。互斥量比临界区复杂，因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。</p><h2 id="1-3-管程-信号量"><a href="#1-3-管程-信号量" class="headerlink" title="1.3 管程/信号量"></a>1.3 管程/信号量</h2><p>管程和信号量是同一个概念。指一个互斥独占锁定的对象或称为互斥体。在给定的时间，仅有一个线程可以获得管程。当一个线程需要锁定，他必须进入管程。所有其他的试图进入已经锁定的管程的线程必须挂起直到第一个线程退出管程。这些其他的线程被称为等待线程。一个拥有管程的线程如果愿意的话可以再次进入相同的管程（可重入性）</p><h2 id="1-4-CAS操作"><a href="#1-4-CAS操作" class="headerlink" title="1.4 CAS操作"></a>1.4 CAS操作</h2><p>CAS操作（compare  and swap）CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则返回V。这是一种乐观锁的思路，它相信在它修改之前，没有其它线程去修改它；而Synchronized是一种悲观锁，它认为在它修改之前，一定会有其它线程去修改它，悲观锁效率很低。下面来看一下AtomicInteger是如何利用CAS实现原子性操作的。</p><h2 id="1-5-重排序"><a href="#1-5-重排序" class="headerlink" title="1.5 重排序"></a>1.5 重排序</h2><p>编译器和处理器为了提高性能，而在程序执行时会对程序进行重排序。他的出现是为了提高程序的并发度。从而提高性能；但是对于多线程程序，重排序可能会导致程序执行的结果不是我们需要的结果，重排序分为编译器和处理器俩个方面。而处理器重排序包括指令级重排序和内存重排序。</p><h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>在java中，所有的变量（实例字段，静态字段，构成数组的元素，不包括局部变量和方法参数）都存储在主内存中，内个线程都有自己的工作内存，线程的工作内存保存被线程使用到的变量的主内存副本拷贝。线程对变量的所有操作都必须在工作内存中进行，为不能直接读写主内存的变量。不同线程之间也不恩能够直接访问对方工作内存中的变量，线程间比变量值的传递通过主内存来完成。</p><h2 id="JAVA中线程安全相关关键字及类"><a href="#JAVA中线程安全相关关键字及类" class="headerlink" title="JAVA中线程安全相关关键字及类"></a>JAVA中线程安全相关关键字及类</h2><p>主要包括：synchronized，Volitile，ThreadLocal，Lock，Condition</p><h2 id="2-1-Volitile"><a href="#2-1-Volitile" class="headerlink" title="2.1 Volitile"></a>2.1 Volitile</h2><p>作用：</p><p>1）保证了心智能立即存储到主内存才，每次使用前立即从主内存中刷新</p><p>2）禁止指令重排序优化</p><p>Volitile关键字不能保证在多线程环境下对共享数据的操作的正确性，可以使用在自己状态改变之后需要立即通知所有线程的情况下，只保证可见性，不保证原子性。即通过刷新变量值确保可见性。</p><p>Java中synchronized和final也能保证可见性</p><p>synchronized：同步快通过变量锁定前必须清空工作内存中的变量值，重新从主内存中读取变量值，解锁前必须把变量值同步回主内存来确保可见性。</p><p>final:被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把this引用传递进去，那么在其他线程中就能看见final字段的值，无需同步就可以被其他线程正确访问。</p><h2 id="2-2-synchronized"><a href="#2-2-synchronized" class="headerlink" title="2.2 synchronized"></a>2.2 synchronized</h2><p>把代码块声明为synchronized，有俩个作用，通常是指改代码具有原子性和可见性。如果没有同步机制提供的这种可见性，线程看到的共享比那里可能是修改前的值或不一致的值，这将引发许多严重问题。</p><p>原理：当对象获取锁是，他首先是自己的高速缓存无效，这样就可以保证直接从主内存中装入变量，同样在对象释放锁之前，他会刷新其高速缓存，强制使已做的任何更改都出现在主内存中，这样会保证在同一个锁上同步的俩个线程看到在synchronized块内修改的变量的相同值。</p><p>synchronized释放由JVM自己管理。</p><p>存在的问题：</p><p>1）无法中断一个正在等待获得锁的线程</p><p>2）无法通过投票得到锁，如果不想等待下去，也就没法得到锁</p><p>3）同步还需要锁的释放只能在与获得锁所在的堆栈帧相同的堆栈中进行，多数情况下，这没问题（而且与一场处理交互的很好），但是，确实存在一些非块结构的锁定更适合情况。</p><h2 id="2-3-Lock"><a href="#2-3-Lock" class="headerlink" title="2.3 Lock"></a>2.3 Lock</h2><p>Lock是有JAVA编写而成的，在java这个层面是无关JVM实现的。包括：ReentrantLock，ReadWriteLock。其本质都依赖于AbstractQueueSynchronized类。Lock提供了很多锁的方式，尝试锁，中断锁等。释放锁的过程由JAVA开发人员自己管理。</p><p>就性能而言，对于资源冲突不多的情况下synchronized更加合理，但如果资源访问冲突多的情况下，synchronized的性能会快速下降，而Lock可以保持平衡。</p><h2 id="2-4-condition"><a href="#2-4-condition" class="headerlink" title="2.4 condition"></a>2.4 condition</h2><p>Condition将Object监视器方法（wait，notify,notifyall）分解成截然不同的对象，以便通过这些对象与任意Lock实现组合使用，为每个对象提供多个等待set(wait-set),，其中Lock替代了synchronized方法和语句的使用，condition替代了Object监视器方法的使用。Condition实例实质上被你绑定到一个锁上。要为特定Lock实例获得Condition实例，请使用其newCondition（）方法。</p><h2 id="2-5-ThreadLock"><a href="#2-5-ThreadLock" class="headerlink" title="2.5 ThreadLock"></a>2.5 ThreadLock</h2><p>线程局部变量。</p><p>变量是同一个，但是每个线程都使用同一个初始值，也就是使用同一个变量的一个新的副本，这种情况下TreadLocal就非常有用。</p><p>应用场景：当很多线程需要多次使用同一个对象，并且需要该对象具有相同初始值的时候，最适合使用TreadLocal。</p><p>事实上，从本质上讲，就是每个线程都维持一个MAP，而这个map的key就是TreadLocal,而值就是我们set的那个值，每次线程在get的时候，都从自己的变量中取值，既然从自己的变量中取值，那就肯定不存在线程安全的问题。总体来讲，TreadLocal这个变量的状态根本没有发生变化。它仅仅是充当了一个key的角色，另外提供给每一个线程一个初始值。如果允许的话，我们自己就能实现一个这样的功能，只不过恰好JDK就已经帮助我们做了这个事情。</p><p>使用TreadLocal维护变量时，TreadLocal为每个使用该变量的线程提供独立地变量副本，所以每一个线程都可以独立地改变自己的副本，而不会英语其他线程所对应的副本。从线程的角度看，目标变量对象是线程的本地变量，这也是类名中Local所需要表达的意思。</p><p>TreadLocal的四个方法：</p><p>void set(Object val),设置当前线程的线程局部变量的值</p><p>Object get（）返回当前线程所对用的线程局部变量。</p><p>void remove() 将当前线程局部变量的值删除，目的是为了减少内存的占用，线程结束后，局部变量自动被GC</p><p>Object  initValue() 返回该线程局部变量的初始值，使用protected修饰，显然是为了让子类覆盖而设计的。</p><h2 id="线程安全的实现方式"><a href="#线程安全的实现方式" class="headerlink" title="线程安全的实现方式"></a>线程安全的实现方式</h2><h2 id="3-1-互斥同步"><a href="#3-1-互斥同步" class="headerlink" title="3.1 互斥同步"></a>3.1 互斥同步</h2><p>在多线程访问的时候，保证同一时间只有一条线程使用。</p><p>临界区，互斥量，管程都是同步的一种手段。</p><p>java中最基本的互斥同步手段是synchronized，编译之后会形成monitorenter和monitorexit这俩个字节码指令，这俩个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象，还有一个锁的计数器，来记录加锁的次数，加锁几次就要同样解锁几次才能恢复到无锁状态。</p><p>java的线程是映射到操作系统的原生线程之上的，不管阻塞还是唤醒都需要操作系统的帮助完成，都需要从用户态转换到核心态，这是很耗费时间的，是java语言中的一个重量级的操作，虽然虚拟机本身会做一点优化的操作，比如通知操作系统阻塞之前会加一段自旋等待的过程，避免频繁切换到核心态。</p><h2 id="3-2-非阻塞同步"><a href="#3-2-非阻塞同步" class="headerlink" title="3.2 非阻塞同步"></a>3.2 非阻塞同步</h2><p>互斥和同步最主要的问题就是阻塞和唤醒所带来的性能的问题，所以这通常叫阻塞同步（悲观的并发策略）.随着硬件指令集的发展，我们有另外的选择：基于冲突检测的乐观并发策略，通俗讲就是先操作，如果没有其他线程争用共享的数据，操作就成功，如果有，则进行其他的补偿（最常见的就是不断的重试）。这种乐观的并发策略许多实现都不需要把线程先挂起，这种同步操作被称为非阻塞同步。</p><h2 id="3-3-无同步"><a href="#3-3-无同步" class="headerlink" title="3.3 无同步"></a>3.3 无同步</h2><p>部分代码天生就是线程安全的，不需要同步。</p><p>1）可重入代码：纯代码，具有不依赖存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入，不调用非可重入的方法等特征，它的返回结果是可以预测的。</p><p>2）线程本地存储：把共享数据的可见性范围限制在同一个线程之内，这样就无需同步也能保证线程之间不出现数据争用问题。可以通过java.lang.TreadLocal类来实现线程本地存储的功能。</p>]]></content>
      
      
      <categories>
          
          <category> java 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 线程 </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Web核心-Servlet</title>
      <link href="/2018/11/10/servletbase1/"/>
      <url>/2018/11/10/servletbase1/</url>
      
        <content type="html"><![CDATA[<p>Servlet实际上是ServerApplet–小服务程序或服务连接器，用Java编写的服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容。与常用的协议，如DNS，TCP/IP，HTTP类似，Servlet是作为一整套规范存在的；同时作为J2EE标准的一部分，定义了javaweb开发的标准。Servlet制定了java处理WEB请求的一系列标准，我们只需要按照标准规定的去做就可以了。<br>实际上，无论是Struts2的FilterDispatcher还是SpringMvc的DispatcherServlet,其底层都是通过实现Sevlet或者Servlet类型的扩展【如：GenericServlet】来实现的。</p><h1 id="1-Servlet接口"><a href="#1-Servlet接口" class="headerlink" title="1.Servlet接口"></a>1.Servlet接口</h1><p>下图为Servlet3.1中的结构图：<br><img src="https://user-gold-cdn.xitu.io/2017/9/17/f082e8b42bd73aacc90e1a79ba99596f" alt=""><br>因为Servlet是以规范的方式存在的，实际上就是定义一系列规范接口。在Servlet接口中，主要包括以下几个接口：<br><img src="https://user-gold-cdn.xitu.io/2017/9/17/6c96aac1646cea4a19aaf7a2a8da0fcc" alt=""></p><ul><li>1)init方法是在容器启动时被容器调用，且只会被调用一次；</li><li>2)getServletConfig方法用于获取ServletConfig；</li><li>3)service方法用于处理一个具体的请求</li><li>4)getServletInfo方法用于获取Servlet相关的信息：版权等。</li><li>5)destroy方法用来销毁一个Servlet，和init一样，只会被调用一次，一般在服务器关闭时用于释放一些资源。</li></ul><p>init方法调用时会接受一个ServletConfig类型的参数，用于初始化Servlet，由容器传入。ServletConfig，顾名思义，其包含了Serlvet的配置信息。通常情况下，我们在web.xml文件中定义Serlvet时，会通过init-param标签来进行参数配置。在Springmvc的配置中，通常通过以下方式来配置参数：<br><img src="https://user-gold-cdn.xitu.io/2017/9/17/1379ebb6b6e2849e1243f5b4a2445816" alt=""></p><h1 id="2-ServletConfig接口"><a href="#2-ServletConfig接口" class="headerlink" title="2.ServletConfig接口"></a>2.ServletConfig接口</h1><p><img src="https://user-gold-cdn.xitu.io/2017/9/17/651a24ed98cc74708ff03856a2bd5faf" alt=""><br>1)getServletName用于获取Servlet的名字，也就是我们在web.xml中定义的servlet-name<br>2)getServletContext返回ServletContext，代表我们当前应用本身<br>3)getInitParameter用于获取init-param配置的参数<br>4)getInitParameterNames用于获取所有init-param配置名字的集合<br>ServletContext和ServletConfig最常见的使用就是传递初始化参数。来看下spring中的contextConfigServlet的参数配置<br><img src="https://user-gold-cdn.xitu.io/2017/9/17/303a290e03736b0aa1a0a4ce3b935de8" alt=""><br>通过context-param配置的contextConfigLocation配置到了ServletContext中，再通过Servlet下的init-param配置的contextConfigLocation配置到ServletConfig中,在Servlet中可以通过getInitParameter方法获取具体的信息。</p><h1 id="3-GenericServlet"><a href="#3-GenericServlet" class="headerlink" title="3.GenericServlet"></a>3.GenericServlet</h1><p>GenericServlet是Servlet的默认实现，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package javax.servlet;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.Enumeration;</span><br><span class="line">import java.util.ResourceBundle;</span><br><span class="line">public abstract class GenericServlet</span><br><span class="line">  implements Servlet, ServletConfig, Serializable</span><br><span class="line">&#123;</span><br><span class="line">  private static final String LSTRING_FILE = &quot;javax.servlet.LocalStrings&quot;;</span><br><span class="line">  private static ResourceBundle lStrings = ResourceBundle.getBundle(&quot;javax.servlet.LocalStrings&quot;);</span><br><span class="line">  private transient ServletConfig config;</span><br><span class="line">  public void destroy()</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  public String getInitParameter(String name)</span><br><span class="line">  &#123;</span><br><span class="line">    ServletConfig sc = getServletConfig();</span><br><span class="line">    if (sc == null) &#123;</span><br><span class="line">      throw new IllegalStateException(lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    return sc.getInitParameter(name);</span><br><span class="line">  &#125;</span><br><span class="line">  public Enumeration getInitParameterNames()</span><br><span class="line">  &#123;</span><br><span class="line">    ServletConfig sc = getServletConfig();</span><br><span class="line">    if (sc == null) &#123;</span><br><span class="line">      throw new IllegalStateException(lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    return sc.getInitParameterNames();</span><br><span class="line">  &#125;</span><br><span class="line">  public ServletConfig getServletConfig()</span><br><span class="line">  &#123;</span><br><span class="line">    return this.config;</span><br><span class="line">  &#125;</span><br><span class="line">  public ServletContext getServletContext()</span><br><span class="line">  &#123;</span><br><span class="line">    ServletConfig sc = getServletConfig();</span><br><span class="line">    if (sc == null) &#123;</span><br><span class="line">      throw new IllegalStateException(lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    return sc.getServletContext();</span><br><span class="line">  &#125;</span><br><span class="line">  public String getServletInfo()</span><br><span class="line">  &#123;</span><br><span class="line">    return &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  public void init(ServletConfig config)</span><br><span class="line">    throws ServletException</span><br><span class="line">  &#123;</span><br><span class="line">    this.config = config;</span><br><span class="line">    init();</span><br><span class="line">  &#125;</span><br><span class="line">  public void init()</span><br><span class="line">    throws ServletException</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  public void log(String msg)</span><br><span class="line">  &#123;</span><br><span class="line">    getServletContext().log(getServletName() + &quot;: &quot; + msg);</span><br><span class="line">  &#125;</span><br><span class="line">  public void log(String message, Throwable t)</span><br><span class="line">  &#123;</span><br><span class="line">    getServletContext().log(getServletName() + &quot;: &quot; + message, t);</span><br><span class="line">  &#125;</span><br><span class="line">  public abstract void service(ServletRequest paramServletRequest, ServletResponse paramServletResponse)</span><br><span class="line">    throws ServletException, IOException;</span><br><span class="line">  public String getServletName()</span><br><span class="line">  &#123;</span><br><span class="line">    ServletConfig sc = getServletConfig();</span><br><span class="line">    if (sc == null) &#123;</span><br><span class="line">      throw new IllegalStateException(lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    return sc.getServletName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从其继承和实现关系来看，GenericServlet主要做了3件事：<br>1.实现了ServletConfig接口，这样我们就可以直接调用ServletConfig里面的方法；<br>  GenericServlet实现了ServletConfig，可以在需要的时候直接调用ServletConfig中的方法，不需要再先获取ServletConfig对象；比如，获取ServletContext的时候可以直接调用getServletContext,而无需调用getServletConfig().getServletContext(),但是实际上，其底层的内部实现还是在内部还是进行了getServletConfig().getServletContext()的调用。<br><img src="https://user-gold-cdn.xitu.io/2017/9/17/dd8a5129f647e5294c4b2f19a1e7de8f" alt=""><br>2.提供了无参的init方法<br>     GenericServlet实现了Servlet的init（ServletConfig config）方法，在里面将config设置给了其内部变量config，然后调用了无参的init方法；此方法可以在子类中通过覆盖它来完成初始化工作。<br><img src="https://user-gold-cdn.xitu.io/2017/9/17/272a1795528bfa56e7f579f2d3fe97fd" alt=""><br>这种方式具有的有点包括以下几点：<br>    a.config设置为内部属性，这样可以在ServletConfig的接口方法中直接调用Config的相应方法来执行；<br>    b.我们在写Serlvet的时候可以不用再关心Config，只需要执行自己的初始化逻辑即可<br>    c.在重写init方法时，不需要再调用super.init(config)。<br>3.提供了Log方法<br>    GenericServlet提供了2个log方法，一个用于记录日志，一个用于记录异常。其具体的实现是通过传给ServletConfig的日志实现的。<br> GenericServlet是与具体协议无关的。</p><h1 id="4-HttpServlet"><a href="#4-HttpServlet" class="headerlink" title="4.HttpServlet"></a>4.HttpServlet</h1><p>HttpServlet是基于Http协议实现的Servlet的基类，写Servlet时直接继承HttpServlet即可,不需要再重头实现Servlet接口，SpringMvc中的dispatcherServlet就是HttpServlet的子类。 HttpServlet是与Http协议相关的，HttpServlet处理请求主要是通过重写父类的service方法来完成具体的请求处理的。在service方法中首先是将ServletRequest和ServletResponse转换成HttpServletRequest和HttpServletResponse，然后根据请求的不同路由到不同的处理过程中去【处理方法就是我们常见的doXXX的方法。最常见的就是doGet和doPost】<br><img src="https://user-gold-cdn.xitu.io/2017/9/17/8e5566839bf5ace1b9bd42bd06110460" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring源码系列：Spring的启动过程</title>
      <link href="/2018/11/10/springbase1/"/>
      <url>/2018/11/10/springbase1/</url>
      
        <content type="html"><![CDATA[<p>Spring对于程序员说来说都不陌生；作为一个强大的开源技术，帮助我们能够更好的进行项目的开发与维护。<br>直接进入主题吧。Spring的启动过程实际上就是Ioc容器初始化以及载入Bean的过程；本文主要是学习记录下前半部分（Ioc容器的初始化），新手上路，如有错误，请指正！<br>1.从配置文件说起</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener</span><br><span class="line">     <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在一般的WEB项目中，项目的启动一般是从web.xml文件的载入开始的。如果我们的项目中使用了Spring，那么你肯定会在你的web.xml文件中看到上面的配置。Spring正是通过ContextLoaderListener监听器来进行容器初始化的。下面通过代码进行分析。</p><p>2.Spring容器加载的三步走</p><ul><li>step1:创建一个WebApplicationContext</li><li>step2:配置并且刷新Bean</li><li>step3：将容器初始化到servlet上下文中</li></ul><p>3.WebApplicationContext的创建过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span></span></span><br></pre></td></tr></table></figure></p><p>从ContextLoaderListener的定义可以看出，该监听器继承了ContextLoader，并且重写了ServletContextListener中的contextInitialized和contextDestroyed方法。</p><p>在contextInitialized中，通过调用父类（ContextLoader）的initWebApplicationContext方法进行容器创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">    initWebApplicationContext(event.getServletContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面来看initWebApplicationContext的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1：判断当前容器是否存在，如果存在则报容器已经存在的异常信息</span></span><br><span class="line">    <span class="keyword">if</span> (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">          <span class="string">"Cannot initialize context because there is already a root application context present - "</span> +</span><br><span class="line">          <span class="string">"check whether you have multiple ContextLoader* definitions in your web.xml!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Log logger = LogFactory.getLog(ContextLoader.class);</span><br><span class="line">    <span class="comment">//下面这个日志就是我们经常在启动Spring项目时看到的日志信息: </span></span><br><span class="line">    <span class="comment">//Initializing Spring root WebApplicationContext</span></span><br><span class="line">    <span class="comment">//Root WebApplicationContext: initialization started</span></span><br><span class="line">    servletContext.log(<span class="string">"Initializing Spring root WebApplicationContext"</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">"Root WebApplicationContext: initialization started"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Store context in local instance variable, to guarantee that</span></span><br><span class="line">      <span class="comment">// it is available on ServletContext shutdown.</span></span><br><span class="line">      <span class="comment">//如果当前容器为null,则创建一个容器，并将servletContext上下文作为参数传递进去，</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.context = createWebApplicationContext(servletContext);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//判断当前容器是否为可配置的，只有是Configurable的容器，才能进行后续的配置</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">        ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class="keyword">this</span>.context;</span><br><span class="line">        <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">          <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">          <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">          <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// The context instance was injected without an explicit parent -&gt;</span></span><br><span class="line">            <span class="comment">// determine parent for root web application context, if any.</span></span><br><span class="line">            ApplicationContext parent = loadParentContext(servletContext);</span><br><span class="line">            cwac.setParent(parent);</span><br><span class="line">          &#125;</span><br><span class="line">           <span class="comment">//三步走中的第二步：配置并且刷新当前容器</span></span><br><span class="line">          configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//将配置并且刷新过的容器存入servlet上下文中，并以WebApplicationContext的类名作为key值</span></span><br><span class="line"></span><br><span class="line">      servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.context);</span><br><span class="line"></span><br><span class="line">      ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">      <span class="keyword">if</span> (ccl == ContextLoader.class.getClassLoader()) &#123;</span><br><span class="line">        currentContext = <span class="keyword">this</span>.context;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ccl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        currentContextPerThread.put(ccl, <span class="keyword">this</span>.context);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Published root WebApplicationContext as ServletContext attribute with name ["</span> +</span><br><span class="line">            WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        <span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">        logger.info(<span class="string">"Root WebApplicationContext: initialization completed in "</span> + elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//返回创建好的容器</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">      logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">      servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">      logger.error(<span class="string">"Context initialization failed"</span>, err);</span><br><span class="line">      servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>下面我们在看下是如何创建WebApplicationContext的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(ServletContext sc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先来确定context是由什么类定义的，并且判断当前容器是否为可配置的</span></span><br><span class="line">    Class&lt;?&gt; contextClass = determineContextClass(sc);</span><br><span class="line">    <span class="keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Custom context class ["</span> + contextClass.getName() +</span><br><span class="line">          <span class="string">"] is not of type ["</span> + ConfigurableWebApplicationContext.class.getName() + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建可配置的上下文容器</span></span><br><span class="line">    <span class="keyword">return</span> (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后来看下determineContextClass这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; determineContextClass(ServletContext servletContext) &#123;</span><br><span class="line">    <span class="comment">//首先从web.xml中查看用户是否自己定义了context</span></span><br><span class="line">    String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);</span><br><span class="line">    <span class="comment">//如果有，则通过反射创建实例</span></span><br><span class="line">    <span class="keyword">if</span> (contextClassName != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">            <span class="string">"Failed to load custom context class ["</span> + contextClassName + <span class="string">"]"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*如果没有，则去defaultStrategies里面取【defaultStrategies是Propertites类的/对象，在ContextLoader中的静态代码块中初始化的；具体可看下下面的图像】；默认容器是XmlWebApplicationContext*/</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   contextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">            <span class="string">"Failed to load default context class ["</span> + contextClassName + <span class="string">"]"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>总的来说就是：Spring的web工程首先回去检查用户是否自己定义了context，如果有就采用；如果没有就使用Spring默认的。<br>defaultStrategies初始化：<br><img src="https://user-gold-cdn.xitu.io/2017/8/27/62ee7d396cdab1a3636d6d4237b4ca76" alt=""></p><p>至此，容器创建完成。下面是整个过程的一个流程图（有疏漏，回头补一个时序图）：</p><p><img src="https://user-gold-cdn.xitu.io/2017/8/27/f4fe5698c40759d2a1eadb1a0d390f91" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JAVA中的关键字</title>
      <link href="/2018/11/10/java-key-word/"/>
      <url>/2018/11/10/java-key-word/</url>
      
        <content type="html"><![CDATA[<p>Java中关键字有51个，另外还有俩个保留字；因此总共有53个。本文只将java中的关键字进行罗列和简单介绍，对于部分关键字的理解如sychronized将在其他文章中单独分析。</p><h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><p>保留字是指预留的关键字；</p><ul><li>const<br>用于修饰字段或局部变量的声明；被const修饰的字段或局部变量的值是常数，不能被修改</li><li>goto<br>指定跳转到标签，找到标签后，程序将处理从下一行开始的命令。</li></ul><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><ul><li>数据类型</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/2/24/161c56a5513a0b4c" alt=""></p><ul><li>访问修饰符</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/2/24/161c56d16e420180?w=554&amp;h=87&amp;f=png&amp;s=20781" alt=""></p><ul><li>类、接口定义相关</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/2/24/161c56e46c6eb13a?w=554&amp;h=236&amp;f=png&amp;s=75005" alt=""></p><ul><li>流程控制与判断相关</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/2/24/161c56e789b5734f?w=554&amp;h=440&amp;f=png&amp;s=99208" alt=""></p><ul><li>包</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/2/24/161c56e9ffbb75d0?w=555&amp;h=109&amp;f=png&amp;s=29835" alt=""></p><ul><li>变量\类\接口\方法修饰符</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/2/24/161c56ec204867be?w=555&amp;h=254&amp;f=png&amp;s=86733" alt=""></p><ul><li>异常处理</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/2/24/161c56ef12657a13?w=554&amp;h=130&amp;f=png&amp;s=34675" alt=""></p><ul><li>枚举和断言</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/2/24/161c56f13a85caea?w=555&amp;h=67&amp;f=png&amp;s=10210" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> java 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>每天一道算法题：无重复字符的最长子串</title>
      <link href="/2018/11/10/leetcode5/"/>
      <url>/2018/11/10/leetcode5/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>给定一个字符串，找出不含有重复字符的 最长子串 的长度。</strong></p><p>示例：</p><ul><li><p>给定 “abcabcbb” ，没有重复字符的最长子串是 “abc” ，那么长度就是3。</p></li><li><p>给定 “bbbbb” ，最长的子串就是 “b” ，长度是1。</p></li><li><p>给定 “pwwkew” ，最长子串是 “wke” ，长度是3。请注意答案必须是一个子串，”pwke” 是 子序列 而不是子串。</p></li></ul><h2 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h2><p>思路：</p><ul><li><p>字符对应的数字作为下标</p></li><li><p>初始化一个255的boolean作为所有可能出现的字符对应的存在可能性，不存在重复的均为false，存在重复的，则对应的下标置为true。</p></li><li><p>两个指针进行移动，前指针先不动，后指针移动并根据当前字符对应整数下标是否为false或者true进行判断。如果是false，则表示没有重复，则指针向后移动一位；如果为true，表示存在重复，则后指针停止移动，并计算当前字串长度，且将boolean数组重置，第一个指针向前移动一位，后指针指向当前前指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">         int len = 0 ;</span><br><span class="line"></span><br><span class="line">        if (s==null || s.length()== 0 )</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s.length() == 1)&#123;</span><br><span class="line"></span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int firstPoint = 0;</span><br><span class="line">        int nextPoint = 0;</span><br><span class="line"></span><br><span class="line">        boolean[] exist=new boolean[255];</span><br><span class="line"></span><br><span class="line">        while (nextPoint &lt; s.length()&amp;&amp;firstPoint &lt;s.length())&#123;</span><br><span class="line"></span><br><span class="line">            int currMax = 0;</span><br><span class="line">            int index = s.charAt(nextPoint)-0;</span><br><span class="line">            while (exist[index] == false&amp;&amp;nextPoint&lt;s.length())&#123;</span><br><span class="line">                exist[s.charAt(nextPoint)-0] = true;</span><br><span class="line">                nextPoint++;</span><br><span class="line">                if (nextPoint &lt; s.length())&#123;</span><br><span class="line">                    index = s.charAt(nextPoint)-0;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currMax = Math.max(currMax,nextPoint-firstPoint);</span><br><span class="line">            firstPoint++;</span><br><span class="line">            nextPoint=firstPoint;</span><br><span class="line">            len = Math.max(len,currMax);</span><br><span class="line">            for (int i = 0 ; i &lt; 255 ; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                exist[i] = false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h2><p>思路：</p><p>以一个hashmap作为辅助，map的key存储的是字符，value存储的是该字符当前的位置，首先设置一个头指针，指向字符串开头，那么从开始遍历字符串，如果map当中不包含这个字符，那么用这个字符当前所在的位置减去头指针的位置，然后与最大长度做比较，选打的成为最大长度，然后把当前字符的以及位置放入map，以abba为例，头指针指向a，当前为a，那么长度为1，map。put（‘a’,0）,当前为b，那么长度为2，map.put(‘b’,1)，如果说map中存在当前字符，那么把头指针指向，头指针当前的位置与map中存储该字符位置的下一个位置当中的较大者，成为新的头指针位置，比如当走到第二个b的时候，那么头指针原来是0，当前map中存放b的位置是1，那么头指针指向2，所以长度为1，比最大长度小不进行替换，最后将当前的字符及位置放入map，现在是map.put(‘b’,2)，然后走到了a，那么当前map中a的位置是0，那么它的下一个位置是1，与当前头指针位置2相比，小于当前头指针的位置，那么头指针不跟新，所以长度为2，与最大长度相等，所以不替换，最后求出最大长度为2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static int lengthOfLongestSubstring(String s) &#123;  </span><br><span class="line">        Map&lt;Character,Integer&gt; map=new HashMap&lt;Character,Integer&gt;();  </span><br><span class="line">        int maxLength=0;  </span><br><span class="line">        int now=0;  </span><br><span class="line">        for(int i=0;i&lt;s.length();i++)&#123;  </span><br><span class="line">            if(map.containsKey(s.charAt(i)))&#123;  </span><br><span class="line">                now=Math.max(map.get(s.charAt(i))+1,now);  </span><br><span class="line">                if((i-now+1)&gt;maxLength)&#123;  </span><br><span class="line">                    maxLength=i-now+1;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;else&#123;  </span><br><span class="line">                if((i-now+1)&gt;maxLength)&#123;  </span><br><span class="line">                    maxLength=i-now+1;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            map.put(s.charAt(i), i);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return maxLength;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>每天一道算法题：求两个排序数组的中位数</title>
      <link href="/2018/11/10/leetcode4/"/>
      <url>/2018/11/10/leetcode4/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有两个大小为 m 和 n 的排序数组 nums1 和 nums2 。</p><p>请找出两个排序数组的中位数并且总的运行时间复杂度为 O(log (m+n)) 。</p><p><strong>示例1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">中位数是 2.0</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure><hr><p>归并&amp;topK问题</p><h2 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h2><p>这个思路就是对于两个有序数组进行合并，合并到一个大的有序的数组中去，然后求合并后数组的中位数。下面代码中使用的是归并排序的方式，对于两个有序数组进行归并排序的。从复杂度的角度来说可以满足题目的要求，但是还是存在一些问题，主要是怎么能够使得时间复杂度变成O{MIN(nums1.length,nums2.leng)}。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">0.0</span>d;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length+nums2.length];</span><br><span class="line">        <span class="keyword">int</span> num1index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums1.length == <span class="number">0</span> &amp;&amp; nums2.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums1.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> getResult(nums2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums2.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> getResult(nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(num1index &lt; nums1.length &amp;&amp; num2index &lt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[num1index] &lt; nums2[num2index])&#123;</span><br><span class="line">                nums[index]= nums1[num1index];</span><br><span class="line">                num1index++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[index]= nums2[num2index];</span><br><span class="line">                num2index++;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (num1index &lt; nums1.length)&#123;</span><br><span class="line">            nums[index] = nums1[num1index++];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (num2index &lt; nums2.length)&#123;</span><br><span class="line">            nums[index] = nums2[num2index++];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.length%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result = (nums[nums.length/<span class="number">2</span>]+nums[nums.length/<span class="number">2</span>-<span class="number">1</span>])/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            result = nums[nums.length/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">0.0</span>D;</span><br><span class="line">        <span class="keyword">if</span> (nums.length%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result = (nums[nums.length/<span class="number">2</span>]+nums[nums.length/<span class="number">2</span>-<span class="number">1</span>])/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            result = nums[nums.length/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h2><p><a href="https://www.cnblogs.com/leavescy/p/5877627.html" target="_blank" rel="noopener">求两个排序数组的中位数</a></p><ol><li>假设nums1.length = m, nums2.length = n; m &lt; n;</li><li>若(m + n) % 2 == 0, 表示两数组之和为偶数，应该是有两个中位数，因此最终结果为第9行的代码所示。否则，结果为第7行的代码所示。</li><li>为了使得方法的统一，在最初时，对数组进行处理，统一使得传进方法的短数组为nums1，即第14行代码所示。</li><li>如果len1-start1 == 0,则表示nums1已经全部加入前k个了，则第k个为nums2[k -1]; 在方法findKth（）中的k是一直变化的，初始时，k为两个数组中排序之后的第k个数的位置；k在方法中的真正含义为“还需要找到多少个数才能达到k个”；因此假设nums1.length ==0;,此时len1-start1 == 0, 则中位数就是nums2[k - 1],即在nums1中找到了0个数，还需要找k个数，第k个数就是nums[k - 1];</li><li>如果k == 1,则表示前k-1小的数已经找过了，则第k个数肯定是nums1[start1]和nums2[start2]中较小的那个数。</li><li>下面接着就是常规的情况：即nums1中包含一部分k,nums2中也包含一部分的k,因此就从每个数组的k/2那里开始比较（也相当于每次都会有一半的数被加入前k个，因此时间复杂度为O（log(m + n)））：<br>采用p1和p2分别记录当前nums1和nums2需要比较的那个位，由于nums1比较短，因此有可能2/k的位置已经超出了nums1的长度，因此nums1还需要做特殊处理，即第19行代码所示；由于p1做了特殊处理，那p2也就要做特殊处理。总之，start1~p1和start2~p2的和一定为k。<br>1）若nums1[p1 - 1] &lt; nums[p2 - 1],则表明【start1, p1)之间的值在前k个数中；<br>2）若nums[p1 - 1] &gt; nums2[p2- 1],则表明【start2, p2)之间的值在前k个数中；<br>3）若两值相等，则表明【start1, p1)+【start2， p2）的个数为k,则结果直接返回其中一个即可。<br>为什么比较的p1和p2的前一个位的数，而不是p1和p2位置的数呢？ 举例说明：假设start1== start2 == 0, 则p1 = Math.min(len1, k / 2); p2 = k - p1,即p1 + p2 == k;；假设p1 = 5, p2 = 7;, 则k = 12; 在数组中nums[5]其实是第6个数，nums[7]其实是第8个数，所以我们比较的是nums1[p1 - 1]与nums2[p2 - 1]的值；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> len2 = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> size = len1 + len2;</span><br><span class="line">        <span class="keyword">if</span>(size % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, <span class="number">0</span>, len1, nums2, <span class="number">0</span>, len2, size / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (findKth(nums1, <span class="number">0</span>, len1, nums2, <span class="number">0</span>, len2, size / <span class="number">2</span>) + findKth(nums1, <span class="number">0</span>, len1, nums2, <span class="number">0</span>, len2, size / <span class="number">2</span> + <span class="number">1</span>)) /<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> start1, <span class="keyword">int</span> len1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> start2, <span class="keyword">int</span> len2, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len1 - start1 &gt; len2 -start2)  <span class="comment">// 传进来的时候统一让短的数组为nums1</span></span><br><span class="line">            <span class="keyword">return</span> findKth(nums2, start2, len2, nums1, start1, len1, k);</span><br><span class="line">        <span class="keyword">if</span>(len1 - start1 == <span class="number">0</span>)  <span class="comment">// 表示nums1已经全部加入前K个了，第k个为nums2[k - 1];</span></span><br><span class="line">            <span class="keyword">return</span> nums2[k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> Math.min(nums1[start1], nums2[start2]); <span class="comment">// k==1表示已经找到第k-1小的数，下一个数为两个数组start开始的最小值</span></span><br><span class="line">        <span class="keyword">int</span> p1 = start1 + Math.min(len1 - start1, k / <span class="number">2</span>); <span class="comment">// p1和p2记录当前需要比较的那个位</span></span><br><span class="line">        <span class="keyword">int</span> p2 = start2 + k - p1 + start1;</span><br><span class="line">        <span class="keyword">if</span>(nums1[p1 - <span class="number">1</span>] &lt; nums2[p2 - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1,  p1, len1, nums2, start2, len2, k - p1 + start1);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums1[p1 - <span class="number">1</span>] &gt; nums2[p2 -<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, start1, len1, nums2, p2, len2, k - p2 + start2);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> nums1[p1 - <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>每天一道算法题：最长回文子串</title>
      <link href="/2018/11/10/leetcode3/"/>
      <url>/2018/11/10/leetcode3/</url>
      
        <content type="html"><![CDATA[<p>##题目<br>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 长度最长为1000。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line"></span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line"></span><br><span class="line">注意: &quot;aba&quot;也是有效答案</span><br></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line"></span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一开始是想用最笨的方法来解的，也就是找出所有的字串，然后再对所有的子串进行回文检测，并记录长度。这种方式时间复杂度可想而知，O(n)<em>O(n)</em>O(n)=O(n^3)。所以这种肯定是不能满足我们要求的。</p><p>ok，那我们来分析一下这个问题，先把这个问题特殊化；</p><ul><li><p>假如输入的字符串长度就是1</p><p>  那么这个字符串的最长回文串就是它自己，长度就是1</p></li><li><p>假如字符串长度为2，它要是回文串的化，就需要两个字符是相等的。</p><p>  即：s[i] == s[j]  且i-j=1(此处假定i是较大索引位置)</p></li><li><p>那么对于i－j&gt;1的情况下呢？是不是只要满足下面的条件就可以了：</p><p>  即:s[i] == s[j]&amp;&amp;s[i-1] == s[j+1] </p></li></ul><p>其实这种思路就是动态规划。关于动态规划的理论性文字就不码了，有兴趣的小伙伴阔以自行学习。下面就针对这个问题码一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  长度为1，返回当前串</span></span><br><span class="line">    <span class="keyword">if</span> (s.length()==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//长度为2并且两个字符相等则返回</span></span><br><span class="line">    <span class="keyword">if</span> (s.length()==<span class="number">2</span>&amp;&amp;s.charAt(<span class="number">0</span>)==s.charAt(<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用于标记isLongestPalindrome[j][i]即从j到i是否是回文串；</span></span><br><span class="line">    <span class="comment">//如isLongestPalindrome[1][5]＝＝true则表示字符串索引位置从1到5的子串是回文串。</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] isLongestPalindrome = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">    <span class="comment">//最长回文串初始最大为0</span></span><br><span class="line">    <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//对应的maxlen的开始索引位置</span></span><br><span class="line">    <span class="keyword">int</span> beginIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//对应的maxlen的结束索引位置</span></span><br><span class="line">    <span class="keyword">int</span> lastIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j=i;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//满足上述的第三个条件，即当前s.charAt(i)==s.charAt(j)并</span></span><br><span class="line">            <span class="comment">//且s[j＋1到i－1]也是回文串</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i)==s.charAt(j)&amp;&amp;(i-j&lt;<span class="number">2</span>||isLongestPalindrome[j+<span class="number">1</span>][i-<span class="number">1</span>]))&#123;</span><br><span class="line">                isLongestPalindrome[j][i]=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (maxlen &lt; i-j+<span class="number">1</span>) &#123;</span><br><span class="line">                    beginIndex = j;</span><br><span class="line">                    lastIndex = i+<span class="number">1</span>;</span><br><span class="line">                    maxlen = i-j+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.substring(beginIndex,lastIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>每天一道算法题：Z字形转换</title>
      <link href="/2018/11/10/leetcodetwo/"/>
      <url>/2018/11/10/leetcodetwo/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将字符串 “PAYPALISHIRING” 以Z字形排列成给定的行数：（下面这样的形状）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure><p>之后按逐行顺序依次排列：”PAHNAPLSIIGYIR”</p><p>实现一个将字符串进行指定行数的转换的函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string convert(string text, int nRows);</span><br></pre></td></tr></table></figure><p>convert(“PAYPALISHIRING”, 3) 应当返回 “PAHNAPLSIIGYIR” 。</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算字符串长度</span></span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="comment">//两个周期之间的列数，</span></span><br><span class="line">    <span class="keyword">int</span> slash = numRows - <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//计算行的长度</span></span><br><span class="line">    <span class="keyword">int</span> rowLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//竖列</span></span><br><span class="line">        len = len - numRows;</span><br><span class="line">        rowLength++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//斜着的一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slash &amp;&amp; len &gt; <span class="number">0</span>; i++)&#123;</span><br><span class="line">            len--;</span><br><span class="line">            rowLength++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立一个多一列的数组用于保存我们的字符串,并且全部初始化为空格了</span></span><br><span class="line">    <span class="keyword">char</span> result[] = <span class="keyword">new</span> <span class="keyword">char</span>[numRows* rowLength];</span><br><span class="line">    <span class="comment">// 初始化为空格</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.length; i++) &#123; </span><br><span class="line">        result[i] = <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前处理的行数</span></span><br><span class="line">    <span class="keyword">int</span> curColumn = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面将字符串写入所谓的矩阵中</span></span><br><span class="line">    <span class="keyword">while</span>(index &lt; s.length())&#123;</span><br><span class="line">        <span class="comment">//写入列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows &amp;&amp; index &lt; s.length(); i++)&#123;</span><br><span class="line">            result[rowLength * i + curColumn] = s.charAt(index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curColumn++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入斜线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = numRows - <span class="number">2</span>; i &gt; <span class="number">0</span> &amp;&amp; index &lt; s.length(); i--)&#123;</span><br><span class="line">            result[rowLength * i + curColumn] = s.charAt(index);</span><br><span class="line">            curColumn++;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去空格，定义两个指针循环进行操作</span></span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 找第一个是空格的字符位置</span></span><br><span class="line">    <span class="keyword">while</span> (index &lt; s.length() &amp;&amp; result[index] != <span class="string">' '</span>) &#123; </span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> next = index + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">// 找不是空格的元素</span></span><br><span class="line">        <span class="keyword">while</span> (next &lt; result.length &amp;&amp; result[next] == <span class="string">' '</span>) &#123; </span><br><span class="line">            next++;</span><br><span class="line">        &#125;</span><br><span class="line">        result[index] = result[next];</span><br><span class="line">        index++;</span><br><span class="line">        next++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(result, <span class="number">0</span>, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题目想了两天，之前的思路是建立一个二维数组，然后填充，最后遍历数组拿到结果，但是对于很多边界问题不太好考虑，放弃。这两种方案的首要核心都是计算列数和对斜列的处理，没有数学功底和抽象思维的程序员真的伤不起。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>每天一道算法题：颠倒整数</title>
      <link href="/2018/11/10/leetcodeone/"/>
      <url>/2018/11/10/leetcodeone/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个范围为 32 位 int 的整数，将其颠倒。</p><p><strong>例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出:  321</span><br></pre></td></tr></table></figure><p><strong>例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure><p><strong>例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure><p>注意:<br>假设我们的环境只能处理 32 位 int范围内的整数。根据这个假设，<br>如果颠倒后的结果超过这个范围，则返回 0。</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>这个题目其实挺简单的；思路如下：</p><ul><li>判断输入的数字是否大于最大整数，其实这里没有必要判断，因为如果参数输入大于最大整数的话会直接报错。</li><li>将整数转换成字符串</li><li>判断是否是负数，这个依据就是判断字符串中是否存在‘－’</li><li>从后向前开始遍历，注意的是必须后向遍历且初始为0的情况下保持继续向前迭代。</li><li>如果转换之后的值大于最大整数，则会导致string转int失败，抛出异常，那么我们直接在这把异常捕获，并且返回0（偷懒一波，丷）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;Integer.MAX_VALUE)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    String s =String.valueOf(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (s!=<span class="keyword">null</span>&amp;&amp;s.length()!=<span class="number">0</span>&amp;&amp;s.charAt(<span class="number">0</span>)==<span class="string">'-'</span>)&#123;</span><br><span class="line">        len = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.length() == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lastp = s.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">boolean</span> isStart = <span class="keyword">true</span>;</span><br><span class="line">    String ints = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span>( lastp &gt;= len)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isStart &amp;&amp; s.charAt(lastp)==<span class="string">'0'</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (s.charAt(lastp)==<span class="string">'0'</span>)&#123;</span><br><span class="line">                lastp--;</span><br><span class="line">            &#125;</span><br><span class="line">            isStart = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isStart)&#123;</span><br><span class="line">            isStart = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ints = ints+s.charAt(lastp);</span><br><span class="line">        lastp--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        result = Integer.parseInt(ints);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (NumberFormatException e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len==<span class="number">0</span>?result:result*(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于rpc的整理和理解</title>
      <link href="/2018/11/10/rpcone/"/>
      <url>/2018/11/10/rpcone/</url>
      
        <content type="html"><![CDATA[<h1 id="架构演变"><a href="#架构演变" class="headerlink" title="架构演变"></a>架构演变</h1><ul><li><p>所有的界面和服务均在同一个进程下<br><img src="https://user-gold-cdn.xitu.io/2018/3/11/1621576f8c29c490?w=730&amp;h=625&amp;f=png&amp;s=55992" alt=""></p></li><li><p>基于mvc的视图与服务分离，但是实际上还是在一个应用系统中，只不过在功能层次上划分的更加细致<br><img src="https://user-gold-cdn.xitu.io/2018/3/11/16215773671e27af?w=725&amp;h=607&amp;f=png&amp;s=55638" alt=""></p></li><li><p>粒度更细，对于不同的功能服务进行切分，并进行单独的部署<br><img src="https://user-gold-cdn.xitu.io/2018/3/11/1621577911209db2?w=752&amp;h=605&amp;f=png&amp;s=67938" alt=""></p></li><li><p>面向服务的架构，将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来<br><img src="https://user-gold-cdn.xitu.io/2018/3/11/1621577ae54199ff?w=784&amp;h=622&amp;f=png&amp;s=66194" alt=""></p></li><li><p>微服务</p><p>  此处不支持图片展示，自行脑补！！！</p></li></ul><p>随着业务量和用户量的增加，架构也是从单一系统走向分布式系统，我能想到的是，这种架构的演变主要解决的问题在于：</p><ul><li>通过业务模块的拆分，使得每个模块的职责更加清晰，但是模块的职责边界的划分往往也是很疼头的事情。</li><li>细致的划分使得项目在管理上面会更加方面，从代码的角度来说，开发和维护的成本也会降低，不会因为一个bug去跑整个项目了。</li><li>提高了系统的容错率，单一系统如果宕机那就真的gg了，另外就是，单个环节出现问题也会导致项目无法正常运行（比如数据库出问题了）。对于分布式系统来说，一般都会使用冗余的方式来提高可用性，个人理解就是可以提供多个一样的服务，它们之间可以进行切换。</li><li>分布式系统带来的问题一个是成本，硬件成本，运维成本都会增加。</li></ul><h1 id="rpc简介及常用的rpc框架"><a href="#rpc简介及常用的rpc框架" class="headerlink" title="rpc简介及常用的rpc框架"></a>rpc简介及常用的rpc框架</h1><p>随着集中式架构向分布式架构的转变，应用系统之间的服务调用与通讯问题成为了首要解决的需求。</p><p><strong>而RPC 的主要目标就是为了让构建分布式计算（应用）变得更加简单，在提供强大的远程调用能力时不损失本地调用的语义简洁性。 为实现该目标，RPC 框架需提供一种透明调用机制让使用者不必显式的区分本地调用和远程调用。</strong></p><p>如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   @Autowired</span><br><span class="line">private GlRpcAgent glRpcAgent; //rpc代理</span><br><span class="line">/**</span><br><span class="line"> * @param param 此处约定参数以Map键值对的形式传递</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public List&lt;OrderInfo&gt; queryOrdersByUserId(Map&lt;String, Object&gt; param) &#123;</span><br><span class="line">//创建远程调用代理（远程服务的类的全限定名）</span><br><span class="line">OrderConsumeAgent orderConsumer=glRpcAgent.getAgent(&quot;com.glmapper.rpc.interface.OrderConsumeInterface&quot;);</span><br><span class="line">//通过代理获取返回结果  此处getOrders为远程服务器上的com.glmapper.rpc.interface.OrderConsumeInterface接口中的方法，param为参数</span><br><span class="line">Map&lt;String,Object&gt; resultMap=(Map)orderConsumer.call(&quot;getOrders&quot;,param);</span><br><span class="line">//解析返回结果（远程方法同样以Map集合的方式放回）</span><br><span class="line">List&lt;OrderInfo&gt; orders = parseResultMap(resultMap);</span><br><span class="line">return orders;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要以全限定名来获取呢，这个我们将会在后面来说。</p><h2 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h2><p>In distributed computing a remote procedure call (RPC) is when a computer program causes a procedure (subroutine) to execute in another address space(commonly on another computer on a shared network), which is coded as if it were a normal (local) procedure call, without the programmer explicitly coding the details for the remote interaction.<br>RPC 的全称是 Remote Procedure Call 是一种<strong>进程间通信</strong>方式。 它允许程序调用另一个进程上（通常是共享网络的另一台机器上）的过程或函数，而<strong>不用程序员显式编码这个远程调用的细节</strong>。即程序员<strong>无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同</strong>。</p><p>从定义中可以得知，RPC主要来解决三件事情：</p><ul><li>进程间通讯</li><li>提供和本地方法调用一样的调用机制</li><li>屏蔽程序员对远程调用的细节实现</li></ul><p>首先是进程间的通信问题，对于分布式环境，rpc能够帮助我们解决不同服务器之间的通信及数据传输问题，即<strong>做好方法调用到数据的转换，然后借助网络进行数据传递；</strong>rpc客户端向rpc服务端发起远程服务调用，通过请求的封装，参数的封装，序列化、编码、约定协议传输、解析请求、处理请求、封装返回消息数据、在进行返回数据的序列化、编码、在通过网络返回给客户端。再者是提供和本地方法调用一样的调用机制，为什么这么说，对于业务系统来说，我们更多的关注点在于如何解决实际的业务需求问题，而不想花更多的时间和心思在诸如上述过程中关于网络传输及编解码过程，因此对于rpc来说，需要将这些编解码、协议约定、网络传输等进行一个整体的封装，然后只向业务系统提供最简单的调用方式。最后一个屏蔽程序员对远程调用的细节实现，其实也就是第二点中提到的那些功能的封装，我们不用去关系rpc到底是如何实现的，也不用关心它是如何运作的，对于业务开发人员来说，通过约定的方式进行类似于本地方法调用的形式来调用远程服务接口就可以了。<br><strong>那么如何实现透明化的远程调用呢？</strong><br><strong>什么样的内部封装才能让我们觉得像以本地调用方式调用远程服务呢？</strong><br>对于java来说就是使用代理。java代理有两种方式：1） jdk 动态代理（接口代理）；2）cglib代理（子类代理）。尽管字节码生成方式实现的代理更为强大和高效，但代码不易维护，大部分公司实现RPC框架时还是选择动态代理方式。这部分也将会在后续的章节中展开来说。</p><h2 id="RPC基本原理"><a href="#RPC基本原理" class="headerlink" title="RPC基本原理"></a>RPC基本原理</h2><p>上面说到，rpc需要对一些远程调用的内部实现进行封装。我们说到有以下几个点：</p><ul><li>序列化</li><li>编解码</li><li>协议</li><li>网络</li></ul><p>从发起远程调用到接收到数据返回结果，大致过程是：</p><p>1）服务消费方（client）调用以本地调用方式调用服务；<br>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；<br>3）client stub找到服务地址，并将消息发送到服务端；<br>4）server stub收到消息后进行解码；<br>5）server stub根据解码结果调用本地的服务；<br>6）本地服务执行并将结果返回给server stub；<br>7）server stub将返回结果打包成消息并发送至消费方；<br>8）client stub接收到消息，并进行解码；<br>9）服务消费方得到最终结果。</p><p>那么rpc就相当于将step2-step8的步骤进行了封装。下面借用一张网上的图片来帮助我们理解这个过程。</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/23/15fe93fb307ec7e9?w=554&amp;h=323&amp;f=png&amp;s=171659" alt=""></p><h2 id="RPC模型"><a href="#RPC模型" class="headerlink" title="RPC模型"></a>RPC模型</h2><p>对于上图，我们进行进一步的拆解得到（来自网络）：</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/23/15fe94c7fd4edb39?w=841&amp;h=404&amp;f=png&amp;s=205212" alt=""><br>RPC 服务端通过 RpcServer 去暴露服务接口，而客户端通过 RpcClient 去获取服务接口。客户端像调用本地方法一样去调用远程接口方法，RPC 框架提供接口的代理实现，实际的调用将委托给代理 RpcProxy。代理封装调用信息并将调用转交给 RpcInvoker 去实际执行。在客户端的 RpcInvoker 通过连接器 RpcConnector 去维持与服务端的通道 RpcChannel，并使用 RpcProtocol 执行协议编码（encode）并将编码后的请求消息通过通道发送给服务端。RPC 服务端接收器 RpcAcceptor接收客户端的调用请求，同样使用 RpcProtocol 执行协议解码（decode）。<br>解码后的调用信息传递给 RpcProcessor 去控制处理调用过程，最后再委托调用给 RpcInvoker 去实际执行并返回调用结果。</p><p>通过上述分析可知，这里面包括以下核心组件：</p><ul><li>用于暴露服务接口的RpcServer </li><li>用于发现服务接口的RpcClient </li><li>远程接口的代理实现RpcProxy </li><li>负责协议编解码的RpcProtocol（实际的rpc框架中一般会提供多种不同的实现）</li><li>网络连接器<br>（之前看过一篇文章说9个组件，对于咱们这个来说，部分模块可以集成在client和server中）</li></ul><h2 id="常见的RPC框架"><a href="#常见的RPC框架" class="headerlink" title="常见的RPC框架"></a>常见的RPC框架</h2><p>目前常见的分布式RPC框架有以下几个：</p><ul><li>dubbo<br>阿里巴巴公司开源的一个Java高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成</li><li>motan<br>新浪微博开源的一个Java 框架。它诞生的比较晚，起于2013年，2016年5月开源。Motan 在微博平台中已经广泛应用，每天为数百个服务完成近千亿次的调用。</li><li>rpcx<br>Go语言生态圈的Dubbo， 比Dubbo更轻量，实现了Dubbo的许多特性，借助于Go语言优秀的并发特性和简洁语法，可以使用较少的代码实现分布式的RPC服务。</li><li>gRPC<br>Google开发的高性能、通用的开源RPC框架，主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf(Protocol Buffers)序列化协议开发，且支持众多开发语言。本身它不是分布式的，所以要实现上面的框架的功能需要进一步的开发。</li><li>thrift<br>Apache的一个跨语言的高性能的服务框架</li></ul><h2 id="RPC与MQ"><a href="#RPC与MQ" class="headerlink" title="RPC与MQ"></a>RPC与MQ</h2><p>MQ(message queue)消息队列，从某种程度上来说，同样可以实现RPC的功能。从功能特点上来说，MQ可以把消息存储，而RPC不行。关于MQ和RPC做了以下简单的对比，如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/23/15fe963722bccc10?w=572&amp;h=318&amp;f=png&amp;s=100343" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对RPC的基本原理、特点以及基本组件进行了简单的说明，让我们可以对RPC有一个基本的了解。关于常见的RPC框架也做了基本认识，对于这些优秀的框架，我们在实现我们自己RPC时可以借鉴一下这些架构里的一些模式以及技术。最后说明了下为什么我们会在分布式架构中要使用RPC而不是MQ，对于MQ来说，在处理同步调用无法满足实际的生产需求，而RPC才更加适合分布式应用的实际需要。</p>]]></content>
      
      
      <categories>
          
          <category> rpc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rpc </tag>
            
            <tag> dubbo </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于Mybatis中SQL语句的整理</title>
      <link href="/2018/11/10/mybatisone/"/>
      <url>/2018/11/10/mybatisone/</url>
      
        <content type="html"><![CDATA[<blockquote><p>随着业务的发展，越来越多的应用系统都从一个大的系统分拆成多个小的系统，各个系统之间通过一定的通信协议进行数据交换。这样就会导致一些小的应用系统自己不用去进行数据库的操作，只需要进行一些rpc调用或者缓存就可以拿到数据进行展示。我之前参与的一个项目就是这样的情况，而我也是将近7个多月的时间没有写过一行SQL。</p></blockquote><p>近期参与的一个项目的数据大多都市基于数据库来进行数据交互的，所以免不了的要写大量的SQL，所以本篇就总结一下一些SQL的基本写法，以备后用。</p><h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`user_test`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'自增长id'</span>,</span><br><span class="line">  <span class="string">`user_name`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名'</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span>=<span class="string">'用户表'</span>;</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><ul><li>简单的查询</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryUserByName"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.String"</span>&gt;</span></span><br><span class="line">SELECT * FROM user_test WHERE user_name = #&#123;userName&#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是如果这里不指定parameterType，则默认会识别处理；如果指定了类型，则传入的值就需要和当前指定的类型保持一致，不然就会出现数据类型转换异常。</p><ul><li>简单分页查询</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryUsersList"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">    SELECT * FROM user_test WHERE 1=1 </span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"keyword != null and keyword != ''"</span> &gt;</span></span><br><span class="line">            AND user_name LIKE concat('%',#&#123;keyword&#125;,'%')</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    LIMIT #&#123;currentPage&#125;,#&#123;pageSize&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>left join</li></ul><p>app_info表和app_verion表分别存储的是应用信息和应用版本信息。现在要根据appId和versionId查出一个应用的具体信息【包括信息信息和版本信息】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;getAppDetail&quot; resultMap=&quot;appDeatilMap&quot;&gt;</span><br><span class="line">    select  m.id id,</span><br><span class="line">m.app_name appName,</span><br><span class="line">n.version version,</span><br><span class="line">from app_info m</span><br><span class="line">LEFT JOIN app_version n ON m.id = n.app_id </span><br><span class="line">where m.id = #&#123;appId&#125; and n.id = #&#123;versionId&#125;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure><ul><li>查询条件是list</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;queryAppByAppNames&quot; resultMap=&quot;AppMap&quot; parameterType=&quot;java.util.List&quot;&gt;</span><br><span class="line">select </span><br><span class="line">a.app_name appName,</span><br><span class="line">b.version version</span><br><span class="line">from starter_info a,starter_version b </span><br><span class="line">where </span><br><span class="line">a.id = b.app_id </span><br><span class="line">and a.id in </span><br><span class="line">(</span><br><span class="line">        select id from app_info where app_name in </span><br><span class="line">        &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; index=&quot;index&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">)</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ul><li>简单的更新</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateApp"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.List"</span>&gt;</span></span><br><span class="line">    UPDATE app_info</span><br><span class="line">        SET </span><br><span class="line">            app_name = #&#123;appName&#125;</span><br><span class="line">        WHERE </span><br><span class="line">            app_id = #&#123;appId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>批量更新</li></ul><p>有这样一个需求，把 app_info表中id 为1，2，3的app的app_name改为appName1，appName2，appName3;</p><p>使用 case ..when ..then 这样的语法结构来完成：</p><p>case 是当前的条件，when表示条件值，then后面是当前目前更新字段的值；</p><blockquote><p>下面的说明：当前id=#{item.appId}时,app_name=#{item.appName}</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateApps"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.List"</span>&gt;</span></span><br><span class="line">UPDATE app_info set app_name =</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"applList"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">separator</span>=<span class="string">" "</span> <span class="attr">open</span>=<span class="string">"case ID"</span> <span class="attr">close</span>=<span class="string">"end"</span>&gt;</span></span><br><span class="line">when #&#123;item.appId,jdbcType=INTEGER&#125; then #&#123;item.appName,jdbcType=INTEGER&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"></span><br><span class="line">where id in</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"appList"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">close</span>=<span class="string">")"</span>&gt;</span></span><br><span class="line">#&#123;item.appId,jdbcType=INTEGER&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>OK，现在于这样的需要：</p><p>根据应用类型的不同，更新不同的运行环境配置；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;appType&quot;:&quot;applet&quot;,</span><br><span class="line">            &quot;cpu&quot;:5,</span><br><span class="line">            &quot;memory&quot;:4,</span><br><span class="line">            &quot;card&quot;:3,</span><br><span class="line">            &quot;nums&quot;:2,</span><br><span class="line">            &quot;network&quot;:1,</span><br><span class="line">            &quot;isInUse&quot;:1</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;appType&quot;:&quot;bs&quot;,</span><br><span class="line">            &quot;cpu&quot;:5,</span><br><span class="line">            &quot;memory&quot;:4,</span><br><span class="line">            &quot;card&quot;:3,</span><br><span class="line">            &quot;nums&quot;:2,</span><br><span class="line">            &quot;network&quot;:1,</span><br><span class="line">            &quot;isInUse&quot;:1</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;appType&quot;:&quot;cs&quot;,</span><br><span class="line">            &quot;cpu&quot;:5,</span><br><span class="line">            &quot;memory&quot;:4,</span><br><span class="line">            &quot;card&quot;:3,</span><br><span class="line">            &quot;nums&quot;:2,</span><br><span class="line">            &quot;network&quot;:1,</span><br><span class="line">            &quot;isInUse&quot;:1</span><br><span class="line">        &#125;,</span><br><span class="line">        //有几个放几个</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>trim属性说明 </p><ul><li>1.prefix,suffix 表示在trim标签包裹的部分的前面或者后面添加内容 </li><li>2.如果同时有prefixOverrides,suffixOverrides 表示会用prefix,suffix覆盖Overrides中的内容。 </li><li>3.如果只有prefixOverrides,suffixOverrides 表示删除开头的或结尾的xxxOverides指定的内容。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=&quot;updateBatchApp&quot; parameterType=&quot;java.util.List&quot;&gt;</span><br><span class="line">UPDATE app_info</span><br><span class="line">&lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot;&gt;</span><br><span class="line">&lt;trim prefix=&quot;cpu = case&quot; suffix=&quot;end,&quot;&gt;</span><br><span class="line">&lt;foreach collection=&quot;modelList&quot; item=&quot;item&quot; index=&quot;index&quot;&gt;</span><br><span class="line">&lt;if test=&quot;item != null&quot;&gt;</span><br><span class="line">when app_type =#&#123;item.appType&#125; then #&#123;item.cpu&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line">&lt;/trim&gt;</span><br><span class="line">&lt;trim prefix=&quot;memory = case&quot; suffix=&quot;end,&quot;&gt;</span><br><span class="line">&lt;foreach collection=&quot;modelList&quot; item=&quot;item&quot; index=&quot;index&quot;&gt;</span><br><span class="line">&lt;if test=&quot;item != null&quot;&gt;</span><br><span class="line">when app_type =#&#123;item.appType&#125; then #&#123;item.memory&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line">&lt;/trim&gt;</span><br><span class="line">&lt;trim prefix=&quot;card = case&quot; suffix=&quot;end,&quot;&gt;</span><br><span class="line">&lt;foreach collection=&quot;modelList&quot; item=&quot;item&quot; index=&quot;index&quot;&gt;</span><br><span class="line">when app_type =#&#123;item.appType&#125; then #&#123;item.card&#125;</span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line">&lt;/trim&gt;</span><br><span class="line">&lt;trim prefix=&quot;nums = case&quot; suffix=&quot;end,&quot;&gt;</span><br><span class="line">&lt;foreach collection=&quot;modelList&quot; item=&quot;item&quot; index=&quot;index&quot;&gt;</span><br><span class="line">when app_type =#&#123;item.appType&#125; then #&#123;item.nums&#125;</span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line">&lt;/trim&gt;</span><br><span class="line">&lt;trim prefix=&quot;network = case&quot; suffix=&quot;end,&quot;&gt;</span><br><span class="line">&lt;foreach collection=&quot;modelList&quot; item=&quot;item&quot; index=&quot;index&quot;&gt;</span><br><span class="line">when app_type =#&#123;item.appType&#125; then #&#123;item.network&#125;</span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line">&lt;/trim&gt;</span><br><span class="line">&lt;trim prefix=&quot;is_in_use = case&quot; suffix=&quot;end,&quot;&gt;</span><br><span class="line">&lt;foreach collection=&quot;modelList&quot; item=&quot;item&quot; index=&quot;index&quot;&gt;</span><br><span class="line">when app_type =#&#123;item.appType&#125; then #&#123;item.isInUse&#125;</span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line">&lt;/trim&gt;</span><br><span class="line">&lt;/trim&gt;</span><br><span class="line">where app_id = #&#123;appId&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure><blockquote><p>关于性能问题没做研究，之前看过关于不同更新语句写法的一篇性能的分析，大家有兴趣可以看下：<a href="https://blog.csdn.net/xu1916659422/article/details/77971696" target="_blank" rel="noopener">批量更新数据两种方法效率对比</a></p></blockquote><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul><li>简单删除</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM app_info where id = #&#123;id&#125;</span><br></pre></td></tr></table></figure><ul><li>批量删除</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;delete id=&quot;deleteApps&quot; parameterType=&quot;java.util.List&quot;&gt;</span><br><span class="line">DELETE FROM app_info where  app_id in </span><br><span class="line">    &lt;foreach item=&quot;item&quot; collection=&quot;appIds&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">            #&#123;item&#125;</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure><h2 id="时间字符串-order-by"><a href="#时间字符串-order-by" class="headerlink" title="时间字符串 order by"></a>时间字符串 order by</h2><p>不知道各位是否遇到过，之前的前辈们在项目中将时间用字符串的方式存在DB中，而不是使用DATE,然后有一天你的前辈走了，你的主管说查出来按时间来排序….；呵呵，好！！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;querySysParamList&quot; resultMap=&quot;sysParamDO&quot;&gt;</span><br><span class="line">    SELECT * FROM app_info WHERE 1=1</span><br><span class="line">        &lt;if test=&quot;keyword != null and keyword != &apos;&apos;&quot; &gt;</span><br><span class="line">            AND app_name LIKE concat(&apos;%&apos;,#&#123;keyword&#125;,&apos;%&apos;)</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    ORDER BY DATE_FORMAT(update_time,&apos;%H %k %I %r %T %S %w&apos;) DESC</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><blockquote><p>字符串转为日期格式<br>SELECT DATE_FORMAT(‘2011-09-20 08:30:45’,   ‘%Y-%m-%d %H:%i:%S’);</p></blockquote><blockquote><p>把日期转为字符串格式<br>SELECT DATE_FORMAT(NOW(),   ‘%Y-%m-%d %H:%i:%S’);</p></blockquote><p>附：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">%M 月名字(January……December) </span><br><span class="line">%W 星期名字(Sunday……Saturday) </span><br><span class="line">%D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。） </span><br><span class="line">%Y 年, 数字, 4 位 </span><br><span class="line">%y 年, 数字, 2 位 </span><br><span class="line">%a 缩写的星期名字(Sun……Sat) </span><br><span class="line">%d 月份中的天数, 数字(00……31) </span><br><span class="line">%e 月份中的天数, 数字(0……31) </span><br><span class="line">%m 月, 数字(01……12) </span><br><span class="line">%c 月, 数字(1……12) </span><br><span class="line">%b 缩写的月份名字(Jan……Dec) </span><br><span class="line">%j 一年中的天数(001……366) </span><br><span class="line">%H 小时(00……23) </span><br><span class="line">%k 小时(0……23) </span><br><span class="line">%h 小时(01……12) </span><br><span class="line">%I 小时(01……12) </span><br><span class="line">%l 小时(1……12) </span><br><span class="line">%i 分钟, 数字(00……59)                                        </span><br><span class="line">%r 时间,12 小时(hh:mm:ss [AP]M) </span><br><span class="line">%T 时间,24 小时(hh:mm:ss) </span><br><span class="line">%S 秒(00……59) </span><br><span class="line">%s 秒(00……59) </span><br><span class="line">%p AM或PM </span><br><span class="line">%w 一个星期中的天数(0=Sunday ……6=Saturday ） </span><br><span class="line">%U 星期(0……52), 这里星期天是星期的第一天 </span><br><span class="line">%u 星期(0……52), 这里星期一是星期的第一天 </span><br><span class="line">%% 一个文字“%”。</span><br></pre></td></tr></table></figure><p>先记录这些，有坑再补！</p><p>参考：<a href="http://www.runoob.com/sql/sql-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/sql/sql-tutorial.html</a></p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
            <tag> sql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>nginx反向代理和负载均衡策略实战案例</title>
      <link href="/2018/11/10/nginxone/"/>
      <url>/2018/11/10/nginxone/</url>
      
        <content type="html"><![CDATA[<p>欢迎关注：<a href="https://juejin.im/user/5a505bf5518825732a6d50ff" target="_blank" rel="noopener">glmapper_2018</a></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>先来看下nginx在web服务器排名上的趋势：<br><img src="https://user-gold-cdn.xitu.io/2018/4/22/162ec151c277a385?w=651&amp;h=544&amp;f=png&amp;s=44941" alt=""></p><p>存在即合理，那为什么要使用nginx呢？这得看看nginx能帮我们做些什么。</p><p>首先，nginx能做反向代理【关于反向代理和正向代理此处不做说明了，感兴趣的小伙伴自行谷歌】；比方说，我想在本地使用 <a href="http://www.glmapper1.com" target="_blank" rel="noopener">www.glmapper1.com</a> 的域名去访问<a href="http://www.taobao.com。那么这个时候我们就可以通过nginx去实现。" target="_blank" rel="noopener">www.taobao.com。那么这个时候我们就可以通过nginx去实现。</a></p><p>再者，nginx能实现负载均衡，什么是负载均衡呢？就是说应用部署在不同的服务器上，但是通过统一的域名进入，nginx则对请求进行分发，将请求分发到不同的服务器上去处理，这样就可以有效的减轻了单台服务器的压力。</p><p>在上面这两种情况下，nginx服务器的作用都只是作为分发服务器，真正的内容，我们可以放在其他的服务器上，这样来，还能起到一层安全隔壁的作用，nginx作为隔离层。</p><p><strong>解决跨域问题</strong></p><blockquote><p>同源：URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。</p></blockquote><blockquote><p>浏览器的同源策略：浏览器的同源策略，限制了来自不同源的”document”或脚本，对当前”document”读取或设置某些属性。从一个域上加载的脚本不允许访问另外一个域的文档属性。</p></blockquote><p>因为nginx和tomcat不能共用同一端口,url一样，端口不同，这样就会有跨域问题。</p><p><code>PS：点到为止，这里本次测试没有涉及，就不妄自菲薄了！！!</code></p><h2 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h2><p>配置文件主要由四部分组成：</p><ul><li>main(全区设置)</li><li>server(主机配置)</li><li>http(控制着nginx http处理的所有核心特性)<ul><li>location(URL匹配特定位置设置)。</li></ul></li><li>upstream(负载均衡服务器设置)</li></ul><p>下面以默认的配置文件来说明下具体的配置文件属性含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">#Nginx的worker进程运行用户以及用户组</span><br><span class="line">#user  nobody;</span><br><span class="line"></span><br><span class="line">#Nginx开启的进程数</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">#定义全局错误日志定义类型，[debug|info|notice|warn|crit]</span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">#指定进程ID存储文件位置</span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#事件配置</span><br><span class="line">events &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    #use [ kqueue | rtsig | epoll | /dev/poll | select | poll ];</span><br><span class="line">    #epoll模型是Linux内核中的高性能网络I/O模型，如果在mac上面，就用kqueue模型。</span><br><span class="line">    use kqueue;</span><br><span class="line">    </span><br><span class="line">    #每个进程可以处理的最大连接数，理论上每台nginx服务器的最大连接数为worker_processes*worker_connections。理论值：worker_rlimit_nofile/worker_processes</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#http参数</span><br><span class="line">http &#123;</span><br><span class="line">    #文件扩展名与文件类型映射表</span><br><span class="line">    include       mime.types;</span><br><span class="line">    #默认文件类型</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    </span><br><span class="line">    #日志相关定义</span><br><span class="line">    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">    </span><br><span class="line">    #连接日志的路径，指定的日志格式放在最后。</span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    #开启高效传输模式</span><br><span class="line">    sendfile        on;</span><br><span class="line">    </span><br><span class="line">    #防止网络阻塞</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #客户端连接超时时间，单位是秒</span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #开启gzip压缩输出</span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    #虚拟主机基本设置</span><br><span class="line">    server &#123;</span><br><span class="line">        #监听的端口号</span><br><span class="line">        listen       80;</span><br><span class="line">        #访问域名</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        </span><br><span class="line">        #编码格式，如果网页格式与当前配置的不同的话将会被自动转码</span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #虚拟主机访问日志定义</span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line">        </span><br><span class="line">        #对URL进行匹配</span><br><span class="line">        location / &#123;</span><br><span class="line">            #访问路径，可相对也可绝对路径</span><br><span class="line">            root   html;</span><br><span class="line">            #首页文件，匹配顺序按照配置顺序匹配</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        #错误信息返回页面</span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line">        </span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        #访问URL以.php结尾则自动转交给127.0.0.1</span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http://127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line">        </span><br><span class="line">        #php脚本请求全部转发给FastCGI处理</span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        #禁止访问.ht页面</span><br><span class="line">        # deny access to .htaccess files, if Apache&apos;s document root</span><br><span class="line">        # concurs with nginx&apos;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ /\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #第二个虚拟主机配置</span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    #HTTPS虚拟主机定义</span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line">    include servers/*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反向代理实例"><a href="#反向代理实例" class="headerlink" title="反向代理实例"></a>反向代理实例</h2><p>假设我现在需要本地访问<a href="http://www.baidu.com;配置如下：" target="_blank" rel="noopener">www.baidu.com;配置如下：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    #监听80端口</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">     # individual nginx logs for this web vhost</span><br><span class="line">    access_log /tmp/access.log;</span><br><span class="line">    error_log  /tmp/error.log ;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://www.baidu.com;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>验证结果：</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/22/162ec5d6cc09a498?w=2584&amp;h=1486&amp;f=png&amp;s=249055" alt=""></p><p>可以看到，我在浏览器中使用localhost打开了百度的首页…</p><h2 id="负载均衡实例"><a href="#负载均衡实例" class="headerlink" title="负载均衡实例"></a>负载均衡实例</h2><p>下面主要验证最常用的三种负载策略。虚拟主机配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    #监听80端口</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    </span><br><span class="line">    # individual nginx logs for this web vhost</span><br><span class="line">    access_log /tmp/access.log;</span><br><span class="line">    error_log  /tmp/error.log ;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        #负载均衡</span><br><span class="line">        #轮询 </span><br><span class="line">        #proxy_pass http://polling_strategy;</span><br><span class="line">        #weight权重</span><br><span class="line">        #proxy_pass http://weight_strategy;</span><br><span class="line">        #ip_hash</span><br><span class="line">        # proxy_pass http://ip_hash_strategy;</span><br><span class="line">        #fair</span><br><span class="line">        # proxy_pass http://fair_strategy;</span><br><span class="line">        #url_hash</span><br><span class="line">        # proxy_pass http://url_hash_strategy;</span><br><span class="line">        #重定向</span><br><span class="line">        #rewrite ^ http://localhost:8080;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="轮询策略"><a href="#轮询策略" class="headerlink" title="轮询策略"></a>轮询策略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 1、轮询（默认）</span><br><span class="line"># 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 </span><br><span class="line">upstream polling_strategy &#123; </span><br><span class="line">    server glmapper.net:8080; # 应用服务器1</span><br><span class="line">    server glmapper.net:8081; # 应用服务器2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果（通过端口号来区分当前访问）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8081：hello</span><br><span class="line">8080：hello</span><br><span class="line">8081：hello</span><br><span class="line">8080：hello</span><br></pre></td></tr></table></figure><h3 id="权重策略"><a href="#权重策略" class="headerlink" title="权重策略"></a>权重策略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#2、指定权重</span><br><span class="line">#指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 </span><br><span class="line">upstream  weight_strategy &#123; </span><br><span class="line">    server glmapper.net:8080 weight=1; # 应用服务器1</span><br><span class="line">    server glmapper.net:8081 weight=9; # 应用服务器2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：总访问次数15次，根据上面的权重配置，两台机器的访问比重：2：13；满足预期！</p><h3 id="ip-hash策略"><a href="#ip-hash策略" class="headerlink" title="ip hash策略"></a>ip hash策略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#3、IP绑定 ip_hash</span><br><span class="line">#每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，</span><br><span class="line">#可以解决session的问题;在不考虑引入分布式session的情况下，</span><br><span class="line">#原生HttpSession只对当前servlet容器的上下文环境有效</span><br><span class="line">upstream ip_hash_strategy &#123; </span><br><span class="line">    ip_hash; </span><br><span class="line">    server glmapper.net:8080; # 应用服务器1</span><br><span class="line">    server glmapper.net:8081; # 应用服务器2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>iphash 算法:ip是基本的点分十进制，将ip的前三个端作为参数加入hash函数。这样做的目的是保证ip地址前三位相同的用户经过hash计算将分配到相同的后端server。作者的这个考虑是极为可取的，因此ip地址前三位相同通常意味着来着同一个局域网或者相邻区域，使用相同的后端服务让nginx在一定程度上更具有一致性。</p></blockquote><p>为什么说要解释下iphash,因为采坑了；和猪弟在进行这个策略测试时使用了5台机器来测试的，5台机器均在同一个局域网内【192.168.3.X】;测试时发现5台机器每次都路由到了同一个服务器上，一开始以为是配置问题，但是排查之后也排除了这个可能性。最后考虑到可能是对于同网段的ip做了特殊处理，验证之后确认了猜测。</p><h3 id="其他负载均衡策略"><a href="#其他负载均衡策略" class="headerlink" title="其他负载均衡策略"></a>其他负载均衡策略</h3><p>这里因为需要安装三方插件，时间有限就不验证了，知悉即可！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#4、fair（第三方）</span><br><span class="line">#按后端服务器的响应时间来分配请求，响应时间短的优先分配。 </span><br><span class="line">upstream fair_strategy &#123; </span><br><span class="line">    server glmapper.net:8080; # 应用服务器1</span><br><span class="line">    server glmapper.net:8081; # 应用服务器2</span><br><span class="line">    fair; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">#5、url_hash（第三方）</span><br><span class="line">#按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，</span><br><span class="line">#后端服务器为缓存时比较有效。 </span><br><span class="line">upstream url_hash_strategy &#123; </span><br><span class="line">    server glmapper.net:8080; # 应用服务器1</span><br><span class="line">    server glmapper.net:8081; # 应用服务器2 </span><br><span class="line">    hash $request_uri; </span><br><span class="line">    hash_method crc32; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="重定向rewrite"><a href="#重定向rewrite" class="headerlink" title="重定向rewrite"></a>重定向rewrite</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    #重定向</span><br><span class="line">    #rewrite ^ http://localhost:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证思路：本地使用localhost:80端口进行访问，根据nginx的配置，如果重定向没有生效，则最后会停留在当前localhost:80这个路径，浏览器中的地址栏地址不会发生改变；如果生效了则地址栏地址变为localhost:8080；</p><p>通过验证，满足预期！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文先对nginx的作用和基本的配置做了简单说明；然后通过负载均衡的实例测试了不同负载均衡算法的具体应用反馈结果。帮助自己更加深刻的理解nginx服务器中的一些配置细节。感谢刘秘提供的helloworld程序【基于springboot的脚手架，有需要的可以联系他获取；还有就是刘秘是个男的…😜】</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://nginx.org/" target="_blank" rel="noopener">http://nginx.org/</a></li><li><a href="https://www.nginx.com/" target="_blank" rel="noopener">https://www.nginx.com/</a></li><li><a href="http://www.sohu.com/a/161411719_324809" target="_blank" rel="noopener">http://www.sohu.com/a/161411719_324809</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> 代理模式 </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>聊一聊session和cookie</title>
      <link href="/2018/11/10/sessionone/"/>
      <url>/2018/11/10/sessionone/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本来是想写aop设计机制的，但是最近被session这个东西搞得有点头大，所以就抽点时间来整理下关于session的一些东西。</p></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="">从http协议的无状态性说起</a><ul><li><a href="">无连接和无状态</a></li><li><a href="">持久连接</a></li><li><a href="">http无状态</a></li><li><a href="">如何保持状态信息</a></li></ul></li><li>Cookie<ul><li><a href="">Cookie机制原理</a></li><li><a href="">Cookie在servlet-api中的定义</a></li><li><a href="">Cookie属性</a></li><li><a href="">创建Cookie</a></li><li><a href="">Cookie更新</a></li><li><a href="">Cookie删除</a></li><li><a href="">从请求中获取Cookie</a></li><li><a href="">Cookie同源与跨域</a></li><li><a href="">Cookie数量&amp;大小限制及处理策略</a></li></ul></li><li>Session<ul><li><a href="">session机制原理</a></li><li><a href="">HttpSession</a></li><li><a href="">创建session</a></li><li><a href="">生命周期</a></li><li><a href="">session的有效期</a></li><li><a href="">分布式session</a><h2 id="从http协议的无状态性说起"><a href="#从http协议的无状态性说起" class="headerlink" title="从http协议的无状态性说起"></a>从http协议的无状态性说起</h2></li></ul></li></ul><p>HTTP是一种无状态协议。关于这个无状态之前我也不太理解，因为HTTP底层是TCP，既然是TCP，就是长连接，这个过程是保持连接状态的，又为什么说http是无状态的呢？先来搞清楚这两个概念：</p><h3 id="无连接和无状态"><a href="#无连接和无状态" class="headerlink" title="无连接和无状态"></a>无连接和无状态</h3><ul><li><p>无连接</p><p>  每次连接只处理一个请求，服务端处理完客户端一次请求，等到客户端作出回应之后便断开连接；</p></li><li><p>无状态</p><p>  是指服务端对于客户端每次发送的请求都认为它是一个新的请求，上一次会话和下一次会话没有联系；</p></li></ul><p>无连接的维度是连接，无状态的维度是请求；http是基于tcp的，而从http1.1开始默认使用持久连接；在这个连接过程中，客户端可以向服务端发送多次请求，但是各个请求之间的并没有什么联系；这样来考虑，就很好理解无状态这个概念了。</p><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p><code>持久连接，本质上是客户端与服务器通信的时候，建立一个持久化的TCP连接，这个连接不会随着请求结束而关闭，通常会保持连接一段时间。</code></p><p>现有的持久连接类型有两种：HTTP/1.0+的keep-alive和HTTP/1.1的persistent。</p><ul><li>HTTP/1.0+的keep-alive</li></ul><p>先来开一张图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/13/163551ad5795255d?w=1444&amp;h=170&amp;f=png&amp;s=58043" alt=""><br>这张图是请求<a href="http://www.baidu.com时的请求头信息。这里面我们需要注意的是：" target="_blank" rel="noopener">www.baidu.com时的请求头信息。这里面我们需要注意的是：</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection: keep-alive</span><br></pre></td></tr></table></figure><p>我们每次发送一个HTTP请求，会附带一个connection:keep-alive，这个参数就是声明一个持久连接。</p><ul><li>HTTP/1.1的persistent</li></ul><p>HTTP/1.1的持久连接默认是开启的，只有首部中包含connection：close，才会事务结束之后关闭连接。当然服务器和客户端仍可以随时关闭持久连接。</p><p>当发送了connection：close首部之后客户端就没有办法在那条连接上发送更多的请求了。当然根据持久连接的特性，一定要传输正确的content-length。</p><p>还有根据HTTP/1.1的特性，是不应该和HTTP/1.0客户端建立持久连接的。最后，一定要做好重发的准备。</p><h3 id="http无状态"><a href="#http无状态" class="headerlink" title="http无状态"></a>http无状态</h3><p>OK，首先来明确下，这个状态的主体指的是什么？应该是信息，这些信息是由服务端所维护的与客户端交互的信息（也称为状态信息）；<br>因为HTTP本身是不保存任何用户的状态信息的，所以HTTP是无状态的协议。</p><h3 id="如何保持状态信息"><a href="#如何保持状态信息" class="headerlink" title="如何保持状态信息"></a>如何保持状态信息</h3><p>在聊这个这个问题之前，我们来考虑下为什么http自己不来做这个事情：也就是让http变成有状态的。</p><ul><li><p>http本身来实现状态维护</p><p>  从上面关于无状态的理解，如果现在需要让http自己变成有状态的，就意味着http协议需要保存交互的状态信息；暂且不说这种方式是否合适，但从维护状态信息这一点来说，代价就很高，因为既然保存了状态信息，那后续的一些行为必定也会受到状态信息的影响。</p><p>  从历史角度来说，最初的http协议只是用来浏览静态文件的，无状态协议已经足够，这样实现的负担也很轻。但是随着web技术的不断发展，越来越多的场景需要状态信息能够得以保存；一方面是http本身不会去改变它的这种无状态的特性（至少目前是这样的），另一方面业务场景又迫切的需要保持状态；那么这个时候就需要来“装饰”一下http，引入一些其他机制来实现有状态。</p></li><li><p>cookie和session体系</p><p>  通过引入cookie和session体系机制来维护状态信息。即用户第一次访问服务器的时候，服务器响应报头通常会出现一个Set-Cookie响应头，这里其实就是在本地设置一个cookie，当用户再次访问服务器的时候，http会附带这个cookie过去，cookie中存有sessionId这样的信息来到服务器这边确认是否属于同一次会话。</p></li></ul><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p> cookie是由服务器发送给客户端（浏览器）的小量信息，以{key：value}的形式存在。</p><h3 id="Cookie机制原理"><a href="#Cookie机制原理" class="headerlink" title="Cookie机制原理"></a>Cookie机制原理</h3><p> 客户端请求服务器时，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。而客户端浏览器会把Cookie保存起来。当浏览器再请求 服务器时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器通过检查该Cookie来获取用户状态。</p><p> 我们通过看下servlet-api中Cookie类的定义及属性，来更加具体的了解Cookie。</p><h3 id="Cookie在servlet-api中的定义"><a href="#Cookie在servlet-api中的定义" class="headerlink" title="Cookie在servlet-api中的定义"></a>Cookie在servlet-api中的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cookie</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6454587001725327448L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TSPECIALS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LSTRING_FILE =</span><br><span class="line">    <span class="string">"javax.servlet.http.LocalStrings"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ResourceBundle lStrings =</span><br><span class="line">    ResourceBundle.getBundle(<span class="string">"javax.servlet.http.LocalStrings"</span>);</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="keyword">private</span> String comment;</span><br><span class="line">    <span class="keyword">private</span> String domain;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxAge = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> secure;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> version = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isHttpOnly = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//....省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Cookie属性"><a href="#Cookie属性" class="headerlink" title="Cookie属性"></a>Cookie属性</h3><ul><li><p>name</p><p>  cookie的名字，Cookie一旦创建，名称便不可更改</p></li><li><p>value</p><p>  cookie值</p></li><li><p>comment</p><p>  该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明</p></li><li><p>domain</p><p>  可以访问该Cookie的域名。如果设置为“.baidu.com”，则所有以“baidu.com”结尾的域名都可以访问该Cookie；第一个字符必须为“.”</p></li><li><p>maxAge</p><p>  Cookie失效的时间，单位秒。</p><ul><li>正数，则超过maxAge秒之后失效。</li><li>负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。</li><li>为0，表示删除该Cookie。</li></ul></li><li><p>path</p><p>  该Cookie的使用路径。例如：</p><ul><li>path=/，说明本域名下contextPath都可以访问该Cookie。</li><li><p>path=/app/，则只有contextPath为“/app”的程序可以访问该Cookie</p><p>path设置时，其以“/”结尾.</p></li></ul></li><li><p>secure</p><p>  该Cookie是否仅被使用安全协议传输。这里的安全协议包括HTTPS，SSL等。默认为false。</p></li><li><p>version</p><p>  该Cookie使用的版本号。</p><ul><li>0 表示遵循Netscape的Cookie规范，目前大多数用的都是这种规范；</li><li><p>1 表示遵循W3C的RFC2109规范；规范过于严格，实施起来很难。</p><p>在servlet规范中默认是0；</p></li></ul></li><li><p>isHttpOnly</p><p>  HttpOnly属性是用来限制非HTTP协议程序接口对客户端Cookie进行访问；也就是说如果想要在客户端取到httponly的Cookie的唯一方法就是使用AJAX，将取Cookie的操作放到服务端，接收客户端发送的ajax请求后将取值结果通过HTTP返回客户端。这样能有效的防止XSS攻击。</p></li></ul><p>上述的这些属性，除了name与value属性会被提交外，其他的属性对于客户端来说都是不可读的，也是不可被提交的。</p><h3 id="创建Cookie"><a href="#创建Cookie" class="headerlink" title="创建Cookie"></a>创建Cookie</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"cookieSessionId"</span>,<span class="string">"qwertyuiop"</span>);</span><br><span class="line">cookie.setDomain(<span class="string">".baidu.com"</span>);             <span class="comment">// 设置域名</span></span><br><span class="line">cookie.setPath(<span class="string">"/"</span>);                        <span class="comment">// 设置路径</span></span><br><span class="line">cookie.setMaxAge(Integer.MAX_VALUE);        <span class="comment">// 设置有效期为永久</span></span><br><span class="line">response.addCookie(cookie);                 <span class="comment">// 回写到客户端</span></span><br></pre></td></tr></table></figure><p>创建Cookie只能通过上述方式来创建，因为在Cookie类中只提供了这样一个构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Cookie的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cookie</span><span class="params">(String name, String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; name.length() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//判断下是不是token</span></span><br><span class="line">        <span class="comment">//判断是不是和Cookie的属性字段重复</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isToken(name) &amp;&amp; !name.equalsIgnoreCase(<span class="string">"Comment"</span>) &amp;&amp;</span><br><span class="line">        !name.equalsIgnoreCase(<span class="string">"Discard"</span>) &amp;&amp;</span><br><span class="line">        !name.equalsIgnoreCase(<span class="string">"Domain"</span>) &amp;&amp;</span><br><span class="line">        !name.equalsIgnoreCase(<span class="string">"Expires"</span>) &amp;&amp;</span><br><span class="line">        !name.equalsIgnoreCase(<span class="string">"Max-Age"</span>) &amp;&amp;</span><br><span class="line">        !name.equalsIgnoreCase(<span class="string">"Path"</span>) &amp;&amp;</span><br><span class="line">        !name.equalsIgnoreCase(<span class="string">"Secure"</span>) &amp;&amp;</span><br><span class="line">        !name.equalsIgnoreCase(<span class="string">"Version"</span>) &amp;&amp; !name.startsWith(<span class="string">"$"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String errMsg =</span><br><span class="line">            lStrings.getString(<span class="string">"err.cookie_name_is_token"</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> Object[]&#123;name&#125;;</span><br><span class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(errMsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(lStrings.getString</span><br><span class="line">        (<span class="string">"err.cookie_name_blank"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Cookie更新"><a href="#Cookie更新" class="headerlink" title="Cookie更新"></a>Cookie更新</h3><p>在源码中可以知道，Cookie本身并没有提供修改的方法；在实际应用中，一般通过使用相同name的Cookie来覆盖原来的Cookie,以达到更新的目的。</p><p>但是这个修改的前提是需要具有相同domain，path的 Set-Cookie 消息头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"cookieSessionId"</span>,<span class="string">"new-qwertyuiop"</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure><h3 id="Cookie删除"><a href="#Cookie删除" class="headerlink" title="Cookie删除"></a>Cookie删除</h3><p>与Cookie更新一样，Cookie本身也没有提供删除的方法；但是从前面分析Cookie属性时了解到，删除Cookie可以通过将maxAge设置为0即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"cookieSessionId"</span>,<span class="string">"new-qwertyuiop"</span>);</span><br><span class="line">cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure><p>上面的删除是我们自己可控的；但是也存在一些我们不可控或者说无意识情况下的删除操作：</p><ul><li>如果maxAge是负值，则cookie在浏览器关闭时被删除</li><li>持久化cookie在到达失效日期时会被删除</li><li>浏览器中的 cookie 数量达到上限，那么 cookie 会被删除以为新建的 cookie 创建空间。</li></ul><p>其实很多情况下，我们关注的都是后者。关于数量上限后面会说到。</p><h3 id="从请求中获取Cookie"><a href="#从请求中获取Cookie" class="headerlink" title="从请求中获取Cookie"></a>从请求中获取Cookie</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br></pre></td></tr></table></figure><h3 id="Cookie同源与跨域"><a href="#Cookie同源与跨域" class="headerlink" title="Cookie同源与跨域"></a>Cookie同源与跨域</h3><p>我们知道浏览器的同源策略：</p><blockquote><p>URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。浏览器的同源策略，限制了来自不同源的”document”或脚本，对当前”document”读取或设置某些属性。 </p></blockquote><p>对于Cookie来说，Cookie的同源只关注域名，是忽略协议和端口的。所以一般情况下，<a href="https://localhost:80/和http://localhost:8080/的Cookie是共享的。" target="_blank" rel="noopener">https://localhost:80/和http://localhost:8080/的Cookie是共享的。</a></p><p>Cookie是不可跨域的；在没有经过任何处理的情况下，二级域名不同也是不行的。(wenku.baidu.com和baike.baidu.com)。</p><h3 id="Cookie数量-amp-大小限制及处理策略"><a href="#Cookie数量-amp-大小限制及处理策略" class="headerlink" title="Cookie数量&amp;大小限制及处理策略"></a>Cookie数量&amp;大小限制及处理策略</h3><table><thead><tr><th></th><th>IE6.0</th><th>IE7.0/8.0</th><th>Opera</th><th>FF</th><th>Safari</th><th>Chrome</th></tr></thead><tbody><tr><td>个数/个</td><td>20/域</td><td>50/域</td><td>30/域</td><td>50/域</td><td>无限制</td><td>53/域</td></tr><tr><td>大小/Byte</td><td>4095</td><td>4095</td><td>4096</td><td>4097</td><td>4097</td><td>4097</td></tr></tbody></table><p><code>注：数据来自网络，仅供参考</code></p><p>因为浏览器对于Cookie在数量上是有限制的，如果超过了自然会有一些剔除策略。在这篇文章中<a href="https://www.nczonline.net/blog/2008/05/17/browser-cookie-restrictions/" target="_blank" rel="noopener">Browser cookie restrictions</a>提到的剔除策略如下：</p><blockquote><p>The least recently used (LRU) approach automatically kicks out the oldest cookie when the cookie limit has been reached in order to allow the newest cookie some space. Internet Explorer and Opera use this approach.</p></blockquote><p>最近最少使用（LRU）方法：在达到cookie限制时自动地剔除最老的cookie，以便腾出空间给许最新的cookie。Internet Explorer和Opera使用这种方法。</p><blockquote><p>Firefox does something strange: it seems to randomly decide which cookies to keep although the last cookie set is always kept. There doesn’t seem to be any scheme it’s following at all. The takeaway? Don’t go above the cookie limit in Firefox.</p></blockquote><p>Firefox决定随机删除Cookie集中的一个Cookie，并没有什么章法。所以最好不要超过Firefox中的Cookie限制。</p><p>超过大小长度的话就是直接被截取丢弃；</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Cookie机制弥补了HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。</p><p>与Cookie不同的是，session是以服务端保存状态的。</p><h3 id="session机制原理"><a href="#session机制原理" class="headerlink" title="session机制原理"></a>session机制原理</h3><p>当客户端请求创建一个session的时候，服务器会先检查这个客户端的请求里是否已包含了一个session标识 - sessionId，</p><ul><li>如果已包含这个sessionId，则说明以前已经为此客户端创建过session，服务器就按照sessionId把这个session检索出来使用（如果检索不到，可能会新建一个）</li><li>如果客户端请求不包含sessionId，则为此客户端创建一个session并且生成一个与此session相关联的sessionId</li></ul><p>sessionId的值一般是一个既不会重复，又不容易被仿造的字符串，这个sessionId将被在本次响应中返回给客户端保存。保存sessionId的方式大多情况下用的是cookie。</p><h3 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h3><p>HttpSession和Cookie一样，都是javax.servlet.http下面的；Cookie是一个类，它描述了Cookie的很多内部细节。而HttpSession是一个接口，它为session的实现提供了一些行为约束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpSession</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回session的创建时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCreationTime</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个sessionId,唯一标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回客户端最后一次发送与该 session 会话相关的请求的时间</span></span><br><span class="line"><span class="comment">     *自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastAccessedTime</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前session所在的ServletContext</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxInactiveInterval</span><span class="params">(<span class="keyword">int</span> interval)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 Servlet 容器在客户端访问时保持 session</span></span><br><span class="line"><span class="comment">     * 会话打开的最大时间间隔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxInactiveInterval</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpSessionContext <span class="title">getSessionContext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回在该 session会话中具有指定名称的对象，</span></span><br><span class="line"><span class="comment">     * 如果没有指定名称的对象，则返回 null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 String 对象的枚举，String 对象包含所有绑定到该 session</span></span><br><span class="line"><span class="comment">     * 会话的对象的名称。</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getAttributeNames</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String[] getValueNames();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putValue</span><span class="params">(String name, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeValue</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指示该 session 会话无效，并解除绑定到它上面的任何对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果客户端不知道该 session 会话，或者如果客户选择不参入该</span></span><br><span class="line"><span class="comment">     * session 会话，则该方法返回 true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNew</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建session"><a href="#创建session" class="headerlink" title="创建session"></a>创建session</h3><p>创建session的方式是通过request来创建；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建Session对象</span></span><br><span class="line">HttpSession session = request.getSession(); </span><br><span class="line"><span class="comment">// 2、创建Session对象</span></span><br><span class="line">HttpSession session = request.getSession(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p><p>这两种是一样的；如果session不存在，就新建一个；如果是false的话，标识如果不存在就返回null；</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>session的生命周期指的是从Servlet容器创建session对象到销毁的过程。Servlet容器会依据session对象设置的存活时间，在达到session时间后将session对象销毁。session生成后，只要用户继续访问，服务器就会更新session的最后访问时间，并维护该session。</p><p>之前在单进程应用中，session我一般是存在内存中的，不会做持久化操作或者说使用三方的服务来存session信息，如redis。但是在分布式场景下，这种存在本机内存中的方式显然是不适用的，因为session无法共享。这个后面说。</p><h3 id="session的有效期"><a href="#session的有效期" class="headerlink" title="session的有效期"></a>session的有效期</h3><p>session一般在内存中存放，内存空间本身大小就有一定的局限性，因此session需要采用一种过期删除的机制来确保session信息不会一直累积，来防止内存溢出的发生。</p><p>session的超时时间可以通过maxInactiveInterval属性来设置。</p><p>如果我们想让session失效的话，也可以当通过调用session的invalidate()来完成。</p><h3 id="分布式session"><a href="#分布式session" class="headerlink" title="分布式session"></a>分布式session</h3><p>首先是为什么会有这样的概念出现？</p><p>先考虑这样一个问题，现在我的应用需要部署在3台机器上。是不是出现这样一种情况，我第一次登陆，请求去了机器1，然后再机器1上创建了一个session；但是我第二次访问时，请求被路由到机器2了，但是机器2上并没有我的session信息，所以得重新登录。当然这种可以通过nginx的IP HASH负载策略来解决。对于同一个IP请求都会去同一个机器。</p><p>但是业务发展的越来越大，拆分的越来越多，机器数不断增加；很显然那种方案就不行了。那么这个时候就需要考虑是不是应该将session信息放在一个独立的机器上，所以分布式session要解决的问题其实就是分布式环境下的session共享的问题。</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/13/163562469179fe66?w=1160&amp;h=798&amp;f=png&amp;s=44700" alt=""></p><p>上图中的关于session独立部署的方式有很多种，可以是一个独立的数据库服务，也可以是一个缓存服务(redis，目前比较常用的一种方式，即使用Redis来作为session缓存服务器)。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/icelin/p/3974935.html" target="_blank" rel="noopener">https://www.cnblogs.com/icelin/p/3974935.html</a></li><li><a href="https://www.nczonline.net/blog/2008/05/17/browser-cookie-restrictions/" target="_blank" rel="noopener">https://www.nczonline.net/blog/2008/05/17/browser-cookie-restrictions/</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> session </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 聊一聊 </tag>
            
            <tag> session </tag>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>聊一聊 AOP：Advice 源码解析</title>
      <link href="/2018/11/10/springaoptwo/"/>
      <url>/2018/11/10/springaoptwo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在第一篇中的例子和概念介绍中我们对 Advice 有了一个初步的认知。在Spring AOP中，Advice的作用就是用来描述 Spring AOP 围绕方法调用而注入的切面行为。</p></blockquote><p>本篇文章将从源码的角度来看一看 <code>Advice</code> 到底是什么样的？又是怎么完成通知的？</p><h2 id="Advice-接口"><a href="#Advice-接口" class="headerlink" title="Advice 接口"></a>Advice 接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.aopalliance.aop;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tag interface for Advice. Implementations can be any type</span></span><br><span class="line"><span class="comment"> * of advice, such as Interceptors.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> $Id: Advice.java,v 1.1 2004/03/19 17:02:16 johnsonr Exp $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Advice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Advice</code> 接口的定义是在 <code>org.aopalliance.aop</code> 包下面的；从上面的代码中我们可以知道，<code>Advice</code> 接口并没有提供任何的方法；类似的接口定义还有<code>java</code> 中的如<code>Serializable</code>接口，这类接口一般称之为标识接口；标识接口对实现它的类没有任何的语义要求,仅仅是充当一个标示的作用,用来表明实现它的类属于一个特定的类型（从这种标识性角度来说，和注解其实挺像的）；</p><p><code>Spring AOP</code>中通过定义和使用这样一个统一的接口，为的就是能够为切面增强的织入功能做更多的细化和扩展。下面就对常见的三个<code>Advice</code>进行分析。</p><h2 id="BeforeAdvice"><a href="#BeforeAdvice" class="headerlink" title="BeforeAdvice"></a>BeforeAdvice</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeforeAdvice</span> <span class="keyword">extends</span> <span class="title">Advice</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口也是一个标识接口。看下 <code>BeforeAdvice</code> 的继承关系：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/22/1642834fc63bae1d?w=1644&amp;h=250&amp;f=png&amp;s=77901" alt=""></p><p><code>MethodBeforeAdvice</code> 是 <code>BeforeAdvice</code> 为待增强的目标方法设置的前置增强接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodBeforeAdvice</span> <span class="keyword">extends</span> <span class="title">BeforeAdvice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">    Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MethodBeforeAdvice</code> 中提供了一个回调函数 <code>before(…)</code> ；</p><p>作为回调函数，<code>before</code> 方法的实现在 <code>Advice</code> 中被配置到目标方法后，会在调用目标方法时被回调。来看下<code>before</code>方法的几个参数：</p><ul><li>Method method ：（ method being invoked）这个参数是目标方法的反射对象；</li><li>Object[] args ：（arguments to the method）目标方法的输入参数；</li><li>Object target ：（target of the method invocation）方法调用的目标</li></ul><h2 id="AspectJMethodBeforeAdvice"><a href="#AspectJMethodBeforeAdvice" class="headerlink" title="AspectJMethodBeforeAdvice"></a>AspectJMethodBeforeAdvice</h2><p><code>AspectJMethodBeforeAdvice</code> 继承了 <code>AbstractAspectJAdvice</code> 抽象类，并实现了 <code>MethodBeforeAdvice</code> 接口。从 <code>AspectJMethodBeforeAdvice</code> 类中代码可以得知，<code>AspectJMethodBeforeAdvice</code> 重写 <code>before</code> 方法的实现是 通过调用父类的 <code>invokeAdviceMethod</code> 方法完成的。也就是说<code>Spring AOP</code> 的<code>Advice</code>包装了<code>AspectJ</code>的<code>before</code>方法。</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642a5ea16c25b2d?w=1578&amp;h=618&amp;f=png&amp;s=128780" alt=""></p><p>Spring AOP的实现后面再说，我们先自己来实现一个简单的通知。</p><h2 id="自定义-Advice实现-MethodBeforeAdvice"><a href="#自定义-Advice实现-MethodBeforeAdvice" class="headerlink" title="自定义 Advice实现 MethodBeforeAdvice"></a>自定义 Advice实现 MethodBeforeAdvice</h2><p>定义我们自己的 <code>GlmapperBeforeMethodAdvice</code> ；这里实现 <code>MethodBeforeAdvice</code> 接口，然后重写 <code>before</code> 这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 自定义的 GlmapperBeforeMethodAdvice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: glmapper@leishu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/6/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperBeforeMethodAdvice</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class"><span class="title">MethodBeforeAdvice</span>,<span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER =</span><br><span class="line">    LoggerFactory.getLogger(GlmapperBeforeMethodAdvice.class.getSimpleName());</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"invoke BeforeAdvice successfully..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result=invocation.proceed();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，有了这个 <code>GlmapperBeforeMethodAdvice</code> ，再来看看怎么用它；同样本篇文章所使用的案例均使用前一篇博客中的那个脚手架来完成。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--我们的目标类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"goodsService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.service.impl.GoodsServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--我们自定义的Advice--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"glmapperBeforeMethodAdvice"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.Advice.GlmapperBeforeMethodAdvice"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 声明切入点adviser --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"adviser"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.RegexpMethodPointcutAdvisor"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里使用我们自定义的advice--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advice"</span> <span class="attr">ref</span>=<span class="string">"glmapperBeforeMethodAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- pattern指定queryAll方法作为切入点； \. 这个是转义使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pattern"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">value</span>=<span class="string">"com\.glmapper\.framerwork\.service\.impl\.GoodsServiceImpl\.queryAll"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义代理对象 返回实例是目标对象 target属性指定的goodsService对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"proxyService"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"goodsService"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--源码内固定的属性private String[] interceptorNames;  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>adviser<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>客户端部分，通过SpringContextUtil来拿代理对象；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/initPage"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">initPage</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response, ModelAndView view)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取代理bean</span></span><br><span class="line">    GoodsService proxyService= (GoodsService) SpringContextUtil.getBean(<span class="string">"proxyService"</span>);</span><br><span class="line">    <span class="comment">//调用</span></span><br><span class="line">    List&lt;Goods&gt; goods = proxyService.queryAll(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    view.addObject(<span class="string">"goodsList"</span>, goods);</span><br><span class="line">    view.setViewName(<span class="string">"goodslist"</span>);</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志输出满足我们的期望（如下）：<br><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642abd5c1097135?w=1516&amp;h=62&amp;f=png&amp;s=26032" alt=""></p><p>同样的，在<code>GlmapperBeforeMethodAdvice</code>基础上再实现 <code>AfterReturningAdvice </code>接口，重写<code>afterReturning</code>方法，就能实现后置通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[]</span></span></span><br><span class="line"><span class="function"><span class="params">args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"invoke AfterAdvice successfully..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方式在<a href="https://juejin.im/post/5b1ca657f265da6e5a205c45" target="_blank" rel="noopener">聊一聊 AOP ：表现形式与基础概念</a>中有说道。</p><h2 id="Advice-在-Aop-中的实现原理"><a href="#Advice-在-Aop-中的实现原理" class="headerlink" title="Advice 在 Aop 中的实现原理"></a>Advice 在 Aop 中的实现原理</h2><p>这里感觉没什么好说的，上面的案例其实就是Spring提供给我们使用的接口。因为MethodBeforeAdvice等都是继承自 AbstractAspectJAdvice 这个抽象类；我们就来看下这个抽象类里面的一些核心逻辑吧。我们按照AspectJMethodBeforeAdvice这里这个类里面before提供的线索来一步步分析。</p><p>首先在AspectJMethodBeforeAdvice里before方法中调用的是这个逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoke the advice method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> jpMatch the JoinPointMatch that matched this execution join point</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnValue the return value from the method execution (may be null)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ex the exception thrown by the method execution (may be null)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the invocation result</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable in case of invocation failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeAdviceMethod</span><span class="params">(JoinPointMatch jpMatch, Object</span></span></span><br><span class="line"><span class="function"><span class="params">returnValue, Throwable ex)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">return</span> invokeAdviceMethodWithGivenArgs(argBinding(getJoinPoint(),</span><br><span class="line">jpMatch, returnValue, ex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 argBinding 方法的作用是获取方法执行连接点上的参数，并将一组参数输出给Advice方法。</p><p>继续来看invokeAdviceMethodWithGivenArgs这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeAdviceMethodWithGivenArgs</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">Throwable </span>&#123;</span><br><span class="line">    <span class="comment">//保存一份参数副本</span></span><br><span class="line">    Object[] actualArgs = args;</span><br><span class="line">    <span class="comment">//验证下参数是否不存在</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdviceMethod.getParameterTypes().length == <span class="number">0</span>) &#123;</span><br><span class="line">    actualArgs = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//设置下方法的访问权限</span></span><br><span class="line">    ReflectionUtils.makeAccessible(<span class="keyword">this</span>.aspectJAdviceMethod);</span><br><span class="line">    <span class="comment">// invoke执行；这里先通过aspectInstanceFactory对像拿到我们的目标对象实例，然后再进行invoke调用执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.aspectJAdviceMethod.invoke(<span class="keyword">this</span>.aspectInstanceFactory.getAspectInstance(), actualArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">"Mismatch on arguments to advice method ["</span> +</span><br><span class="line">    <span class="keyword">this</span>.aspectJAdviceMethod + <span class="string">"]; pointcut expression ["</span> +</span><br><span class="line">    <span class="keyword">this</span>.pointcut.getPointcutExpression() + <span class="string">"]"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码其实就是通过反射的方式执行了我们的目标方法。我们再回过头来看下我们的目标方法到底在哪里去进行增强的；这里我们通过配置文件来看：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 代理对象 返回实例是目标对象 target属性指定的AOPservice对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"proxyService"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"goodsService"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--源码内固定的属性private String[] interceptorNames;  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>adviser<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代理对象proxyService实现上是ProxyFactoryBean产生的；这里就不在阐述BeanFactory和FactoryBean的区别了。</p><p>从上面的配置文件我们可以简单的了解到，代理对象实际上是我们目标对象+adviser共同组成；而在adviser里面又包括了我们的通知。</p><p>ProxyFactoryBean继承了FactoryBean，我们知道FactoryBean也是用来生成bean的，但是它生成的bean是通过其getObject方法来获取的。OK，那我们来看下ProxyFactoryBean的getObject方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a proxy. Invoked when clients obtain beans from this factory bean.</span></span><br><span class="line"><span class="comment"> * Create an instance of the AOP proxy to be returned by this factory.</span></span><br><span class="line"><span class="comment"> * The instance will be cached for a singleton, and create on each call to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> getObject()&#125; for a proxy.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a fresh AOP proxy reflecting the current state of this factory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">//初始化Advisor链</span></span><br><span class="line">    initializeAdvisorChain();</span><br><span class="line">    <span class="comment">//如果是单例，则获取单例对象</span></span><br><span class="line">    <span class="keyword">if</span> (isSingleton()) &#123;</span><br><span class="line">    <span class="keyword">return</span> getSingletonInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.targetName == <span class="keyword">null</span>) &#123;</span><br><span class="line">    logger.warn(<span class="string">"Using non-singleton proxies with singleton targets is often undesirable. "</span> +</span><br><span class="line">    <span class="string">"Enable prototype proxies by setting the 'targetName' property."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newPrototypeInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>返回一个代理。当客户端从这个工厂bean获取bean时调用。创建该工厂返回的AOP代理的一个实例。该实例将被缓存为一个单例，并在每次调用时创建。</p></blockquote><p>initializeAdvisorChain：创建 advisor（拦截器）链。每次添加新的 prototype 实例时，源自 BeanFactory 的 Advisor 都将被刷新。通过工厂 API 以编程方式添加的拦截器不受此类更改的影响。（译注）；其实就是根据我们配置的interceptorNames来初始化我们的advisor（拦截器）链，用来增强我们的目标调用方法。</p><p>下面是getSingletonInstance这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the singleton instance of this class's proxy object,</span></span><br><span class="line"><span class="comment"> * lazily creating it if it hasn't been created already.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the shared singleton proxy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Object <span class="title">getSingletonInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.singletonInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//创建目标对象的代理</span></span><br><span class="line">    <span class="keyword">this</span>.targetSource = freshTargetSource();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.autodetectInterfaces &amp;&amp; getProxiedInterfaces().length == <span class="number">0</span> &amp;&amp; !isProxyTargetClass()) &#123;</span><br><span class="line">        <span class="comment">// Rely on AOP infrastructure to tell us what interfaces to proxy.</span></span><br><span class="line">        <span class="comment">//获取目标类</span></span><br><span class="line">        Class&lt;?&gt; targetClass = getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FactoryBeanNotInitializedException(<span class="string">"Cannot determine target class for proxy"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, <span class="keyword">this</span>.proxyClassLoader));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Initialize the shared singleton instance.</span></span><br><span class="line">    <span class="keyword">super</span>.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">    <span class="keyword">this</span>.singletonInstance = getProxy(createAopProxy());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.singletonInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码最核心的是getProxy这个方法，这里方式有两个方式，一个是cglib，另外一种是jdk动态代理：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642c20eec4d6c09?w=1536&amp;h=506&amp;f=png&amp;s=201462" alt=""></p><p>这里我们以默认的动态代理的方式来说：(<code>org.springframework.aop.framework.JdkDynamicAopProxy类中</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">"Creating JDK dynamic proxy: target source is "</span> +</span><br><span class="line">    <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt;[] proxiedInterfaces =</span><br><span class="line">    AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised);</span><br><span class="line">    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法返回的就是指定接口的代理类实例，该接口将方法调用分派给指定的调用处理程序。</p><p>到此整个AOP代理生成逻辑就完了。</p><p>总结一下就是我们的代理类中其实包括了我们AOP增强的那部分逻辑的，这个其实从上面的配置文件中就很清楚的可以看出来；所以从Adivce介个角度来说，它其实会被抱在advisor中，然后在被传递到代理对象中，代理对象除了拥有我们目标对象的能力之外，还包括了Adivce的能力；通过这种方式就实现了增强。</p><p>关于Advice就到这里了，下一章会来单独说一下 PointCut 。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 聊一聊 </tag>
            
            <tag> aop </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>聊一聊 AOP ：表现形式与基础概念</title>
      <link href="/2018/11/10/springaopone/"/>
      <url>/2018/11/10/springaopone/</url>
      
        <content type="html"><![CDATA[<blockquote><p>aop 终于提上日程来写一写了。</p></blockquote><h2 id="系列目录"><a href="#系列目录" class="headerlink" title="系列目录"></a>系列目录</h2><p>本系列分为 上、中、下三篇。上篇主要是介绍如果使用 AOP ，提供了demo和配置方式说明；中篇来对实现 AOP 的技术原理进行分析；下篇主要针对Spring中对于AOP的实现进行源码分析。</p><ul><li><a href="">从一个例子说起</a><ul><li><a href="">基于代理的方式</a> </li><li><a href="">纯POJO切面 配置方式</a></li><li><a href="">AspectJ 注解方式</a></li><li><a href="">AspectJ XML 配置方式</a></li><li><a href="">表达式说明</a>  </li></ul></li><li><a href="">基础概念</a><ul><li><a href="">AOP概念</a></li><li><a href="">Target Object</a></li><li><a href="">织入（Weave</a></li><li><a href="">Proxy</a></li><li><a href="">Introduction</a></li><li><a href="">Aspect</a></li><li><a href="">Joinpoint</a></li><li><a href="">Pointcut</a></li><li><a href="">Advice</a><ul><li><a href="">概念</a></li><li><a href="">分类</a></li></ul></li><li><a href="">关系</a></li></ul></li><li><a href="">一些坑</a></li></ul><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p>项目地址：<a href="https://github.com/glmapper/glmapper-ssm-parent" target="_blank" rel="noopener">glmapper-ssm-parent</a></p><p>这个项目里面包含了下面几种 AOP 实现方式的所有代码，有兴趣的同学可以fork跑一下。这个demo中列举了4中方式的实现：</p><ul><li>基于代码的方式</li><li>基于纯POJO类的方式</li><li>基于Aspect注解的方式</li><li>基于注入式Aspect的方式</li></ul><p>目前我们经常用到的是<strong>基于Aspect注解的方式</strong>的方式。下面来一个个了解下不同方式的表现形式。</p><h2 id="基于代理的方式"><a href="#基于代理的方式" class="headerlink" title="基于代理的方式"></a>基于代理的方式</h2><p>这种方式看起来很好理解，但是配置起来相当麻烦；小伙伴们可以参考项目来看，这里只贴出比较关键的流程代码。</p><h3 id="1、首先定义一个接口：GoodsService"><a href="#1、首先定义一个接口：GoodsService" class="headerlink" title="1、首先定义一个接口：GoodsService"></a>1、首先定义一个接口：GoodsService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GoodsService</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询所有商品信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset 查询起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> limit 查询条数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;Goods&gt; <span class="title">queryAll</span><span class="params">(<span class="keyword">int</span> offset,<span class="keyword">int</span> limit)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、GoodsService-实现类"><a href="#2、GoodsService-实现类" class="headerlink" title="2、GoodsService 实现类"></a>2、GoodsService 实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"goodsService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsServiceImpl</span> <span class="keyword">implements</span> <span class="title">GoodsService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line"><span class="keyword">private</span> GoodsDao goodsDao;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Goods&gt; <span class="title">queryAll</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"执行了queryAll方法"</span>);</span><br><span class="line">List&lt;Goods&gt; list = <span class="keyword">new</span> ArrayList&lt;Goods&gt;();</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、定义一个通知类-LoggerHelper，该类继承-MethodBeforeAdvice和-AfterReturningAdvice。"><a href="#3、定义一个通知类-LoggerHelper，该类继承-MethodBeforeAdvice和-AfterReturningAdvice。" class="headerlink" title="3、定义一个通知类 LoggerHelper，该类继承 MethodBeforeAdvice和 AfterReturningAdvice。"></a>3、定义一个通知类 LoggerHelper，该类继承 MethodBeforeAdvice和 AfterReturningAdvice。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通知类 LoggerHelper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerHelper</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span>,</span></span><br><span class="line"><span class="class"><span class="title">AfterReturningAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(LoggerHelper.class);</span><br><span class="line">    <span class="comment">//MethodBeforeAdvice的before方法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"before current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//AfterReturningAdvice的afterReturning方法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object o, Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">    Object[] objects, Object o1)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"afterReturning current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、重点，这个配置需要关注下。这个项目里面我是配置在applicationContext-xml文件中的。"><a href="#4、重点，这个配置需要关注下。这个项目里面我是配置在applicationContext-xml文件中的。" class="headerlink" title="4、重点，这个配置需要关注下。这个项目里面我是配置在applicationContext.xml文件中的。"></a>4、重点，这个配置需要关注下。这个项目里面我是配置在applicationContext.xml文件中的。</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义被代理者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"goodsServiceImpl"</span> <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.service.impl.GoodsServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义通知内容，也就是切入点执行前后需要做的事情 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loggerHelper"</span> <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.aspect.LoggerHelper"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义切入点位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loggerPointcut"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.JdkRegexpMethodPointcut"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">".*query.*"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使切入点与通知相关联，完成切面配置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 从这里可以帮助我们理解Advisor，advice和pointcut之间的关系--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--adivce和pointcut是Advisor的两个属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loggerHelperAdvisor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.DefaultPointcutAdvisor"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advice"</span> <span class="attr">ref</span>=<span class="string">"loggerHelper"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pointcut"</span> <span class="attr">ref</span>=<span class="string">"loggerPointcut"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 设置代理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"proxy"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 代理的对象 ，也就是目标类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span> <span class="attr">ref</span>=<span class="string">"goodsServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span> <span class="attr">value</span>=<span class="string">"loggerHelperAdvisor"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 代理接口，商品接口 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span> <span class="attr">value</span>=<span class="string">"com.glmapper.framerwork.service.GoodsService"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5、使用：注解注入方式"><a href="#5、使用：注解注入方式" class="headerlink" title="5、使用：注解注入方式"></a>5、使用：注解注入方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/buy"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line">    <span class="comment">//因为我们已经在配置文件中配置了proxy，</span></span><br><span class="line">    <span class="comment">//所以这里可以直接注入拿到我们的代理类</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GoodsService proxy;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/initPage"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">initPage</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">    HttpServletResponse response, ModelAndView view)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里使用proxy执行了*query*,</span></span><br><span class="line">    List&lt;Goods&gt; goods = proxy.queryAll(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    view.addObject(<span class="string">"goodsList"</span>, goods);</span><br><span class="line">    view.setViewName(<span class="string">"goodslist"</span>);</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、使用：工具类方式手动获取bean"><a href="#6、使用：工具类方式手动获取bean" class="headerlink" title="6、使用：工具类方式手动获取bean"></a>6、使用：工具类方式手动获取bean</h3><p>这个方式是通过一个SpringContextUtil工具类来获取代理对象的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/initPage&quot;)</span><br><span class="line">public ModelAndView initPage(HttpServletRequest request,</span><br><span class="line">HttpServletResponse response, ModelAndView view) &#123;</span><br><span class="line">    //这里通过工具类来拿，效果一样的。</span><br><span class="line">    GoodsService proxy= (GoodsService) SpringContextUtil.getBean(&quot;proxy&quot;);</span><br><span class="line">    List&lt;Goods&gt; goods = proxy.queryAll(10,10);</span><br><span class="line">    view.addObject(&quot;goodsList&quot;, goods);</span><br><span class="line">    view.setViewName(&quot;goodslist&quot;);</span><br><span class="line">    return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="7、SpringContextUtil-类的定义"><a href="#7、SpringContextUtil-类的定义" class="headerlink" title="7、SpringContextUtil 类的定义"></a>7、SpringContextUtil 类的定义</h3><p>这个还是有点坑的，首先SpringContextUtil是继承ApplicationContextAware这个接口，我们希望能够SpringContextUtil可以被Spring容器直接管理，所以，需要使用 @Component 标注。标注了之后最关键的是它得能够被我们配置的注入扫描扫到（亲自踩的坑，我把它放在一个扫不到的包下面，一直debug都是null；差点砸电脑…）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringContextUtil</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring应用上下文环境</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现ApplicationContextAware接口的回调方法，设置上下文环境</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationContext</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        SpringContextUtil.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ApplicationContext</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取对象</span></span><br><span class="line"><span class="comment">     * 这里重写了bean方法，起主要作用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Object 一个以所给名字注册的bean的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8、运行结果"><a href="#8、运行结果" class="headerlink" title="8、运行结果"></a>8、运行结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">21:04:47.940 [http-nio-8080-exec-7] INFO </span><br><span class="line">c.g.framerwork.aspect.LoggerHelper - before current</span><br><span class="line">time:1529413487940</span><br><span class="line"></span><br><span class="line">执行了queryAll方法</span><br><span class="line"></span><br><span class="line">21:04:47.940 [http-nio-8080-exec-7] INFO </span><br><span class="line">c.g.framerwork.aspect.LoggerHelper - afterReturning current</span><br><span class="line">time:1529413487940</span><br></pre></td></tr></table></figure><p>上面就是最最经典的方式，就是通过代理的方式来实现AOP的过程。</p><h2 id="纯POJO切面-aop-config"><a href="#纯POJO切面-aop-config" class="headerlink" title="纯POJO切面 aop:config"></a>纯POJO切面 <a href="aop:config" target="_blank" rel="noopener">aop:config</a></h2><p>注意这里和LoggerHelper的区别，这里的LoggerAspect并没有继承任何接口或者抽象类。</p><h3 id="1、POJO-类定义"><a href="#1、POJO-类定义" class="headerlink" title="1、POJO 类定义"></a>1、POJO 类定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: [描述文本]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="guolei.sgl@antfin.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/6/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER =</span><br><span class="line">    LoggerFactory.getLogger(LoggerHelper.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"before current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"afterReturning current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义通知内容，也就是切入点执行前后需要做的事情 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loggerAspect"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.aspect.LoggerAspect"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"loggerAspect"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"loggerPointCut"</span>  <span class="attr">expression</span>=</span></span><br><span class="line"><span class="tag">    "<span class="attr">execution</span>(* <span class="attr">com.glmapper.framerwork.service.impl.</span>*<span class="attr">.</span>*(<span class="attr">..</span>)) " /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义 Advice --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 前置通知 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"loggerPointCut"</span> <span class="attr">method</span>=<span class="string">"before"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 后置通知 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut-ref</span>=<span class="string">"loggerPointCut"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">method</span>=<span class="string">"afterReturning"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意这里LoggerAspect中的before和afterReturning如果有参数，这里需要处理下，否则会报 <strong>0 formal unbound in pointcut</strong> 异常。</p><h2 id="AspectJ-注解驱动方式"><a href="#AspectJ-注解驱动方式" class="headerlink" title="@AspectJ 注解驱动方式"></a>@AspectJ 注解驱动方式</h2><p>这种方式是最简单的一种实现，直接使用 @Aspect 注解标注我们的切面类即可。</p><h3 id="1、定义切面类，并使用-Aspect-进行标注"><a href="#1、定义切面类，并使用-Aspect-进行标注" class="headerlink" title="1、定义切面类，并使用 @Aspect 进行标注"></a>1、定义切面类，并使用 @Aspect 进行标注</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 使用Aspect注解驱动的方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="guolei.sgl@antfin.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/6/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerAspectInject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(LoggerAspectInject.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.glmapper.framerwork.service.impl.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"before current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AfterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"afterReturning current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、使用方式1：配置文件方式声明-bean"><a href="#2、使用方式1：配置文件方式声明-bean" class="headerlink" title="2、使用方式1：配置文件方式声明 bean"></a>2、使用方式1：配置文件方式声明 bean</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义通知内容，也就是切入点执行前后需要做的事情 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loggerAspectInject"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.aspect.LoggerAspectInject"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义被代理者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"goodsServiceImpl"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.service.impl.GoodsServiceImpl"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3、客户端使用："><a href="#3、客户端使用：" class="headerlink" title="3、客户端使用："></a>3、客户端使用：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/buy"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/initPage"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">initPage</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">    HttpServletResponse response, ModelAndView view)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过SpringContextUtil手动获取 代理bean</span></span><br><span class="line">    GoodsService goodsService=(GoodsService)</span><br><span class="line">    SpringContextUtil.getBean(<span class="string">"goodsServiceImpl"</span>);</span><br><span class="line">    </span><br><span class="line">    List&lt;Goods&gt; goods = goodsService.queryAll(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    view.addObject(<span class="string">"goodsList"</span>, goods);</span><br><span class="line">    view.setViewName(<span class="string">"goodslist"</span>);</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、使用方式2：使用-component注解托管给IOC"><a href="#4、使用方式2：使用-component注解托管给IOC" class="headerlink" title="4、使用方式2：使用@component注解托管给IOC"></a>4、使用方式2：使用@component注解托管给IOC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">//这里加上了Component注解，就不需要在xml中配置了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerAspectInject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER =</span><br><span class="line">    LoggerFactory.getLogger(LoggerAspectInject.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.glmapper.framerwork.service.impl.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"before current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AfterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"afterReturning current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、客户端代码："><a href="#5、客户端代码：" class="headerlink" title="5、客户端代码："></a>5、客户端代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/buy"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line">    <span class="comment">//直接注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GoodsService goodsService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/initPage"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">initPage</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">    HttpServletResponse response, ModelAndView view)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;Goods&gt; goods = goodsService.queryAll(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    view.addObject(<span class="string">"goodsList"</span>, goods);</span><br><span class="line">    view.setViewName(<span class="string">"goodslist"</span>);</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、比较完整的一个LoggerAspectInject，在实际工程中可以直接参考"><a href="#6、比较完整的一个LoggerAspectInject，在实际工程中可以直接参考" class="headerlink" title="6、比较完整的一个LoggerAspectInject，在实际工程中可以直接参考"></a>6、比较完整的一个LoggerAspectInject，在实际工程中可以直接参考</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: aop</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="henugl@1992.163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: glmapper@磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/6/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerAspectInject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER= LoggerFactory.getLogger(LoggerAspectInject.class);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.glmapper.book.web.controller.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"cutIn()"</span>)   <span class="comment">// 定义Pointcut，名称即下面的标识"aroundAdvice</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint poin)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"环绕通知"</span>);</span><br><span class="line">        Object object = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            object = poin.proceed();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 advise</span></span><br><span class="line">    <span class="comment">//这个方法只是一个标识，相当于在配置文件中定义了pointcut的id,此方法没有返回值和参数</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterAdvice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置返回 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关于命名切入点</strong>：上面的例子中cutIn方法可以被称之为命名切入点，命名切入点可以被其他切入点引用，而匿名切入点是不可以的。只有@AspectJ支持命名切入点，而Schema风格不支持命名切入点。<br>如下所示，@AspectJ使用如下方式引用命名切入点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.glmapper.book.web.controller.*.*(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//引入命名切入点</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"前置通知"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注入式-AspectJ-切面"><a href="#注入式-AspectJ-切面" class="headerlink" title="注入式 AspectJ 切面"></a>注入式 AspectJ 切面</h2><p>这种方式我感觉是第二种和第三种的结合的一种方式。</p><h3 id="1、定义切面类"><a href="#1、定义切面类" class="headerlink" title="1、定义切面类"></a>1、定义切面类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@description</span>: 注入式 也是一种通过XML方式配置的方式</span></span><br><span class="line"><span class="comment">* <span class="doctag">@email</span>: &lt;a href="guolei.sgl@antfin.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span>: 18/6/20</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerAspectHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(LoggerAspectHelper.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调动方法前执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> point</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"before current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在调用方法前后执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> point</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"around current time:"</span>+System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">if</span>(point.getArgs().length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> point.proceed(point.getArgs());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> point.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在调用方法之后执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> point</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint point)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"after current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> point</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doThrowing</span><span class="params">(JoinPoint point, Throwable ex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"throwing current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、XML-配置"><a href="#2、XML-配置" class="headerlink" title="2、XML 配置"></a>2、XML 配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loggerAspectHelper"</span>    </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.aspect.LoggerAspectHelper"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"configAspect"</span> <span class="attr">ref</span>=<span class="string">"loggerAspectHelper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置com.glmapper.framerwork.service.imp</span></span><br><span class="line"><span class="comment">    包下所有类或接口的所有方法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"cutIn"</span> <span class="attr">expression</span>=</span></span><br><span class="line"><span class="tag">    "<span class="attr">execution</span>(* <span class="attr">com.glmapper.framerwork.service.impl.</span>*<span class="attr">.</span>*(<span class="attr">..</span>))" /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span>   <span class="attr">pointcut-ref</span>=<span class="string">"cutIn"</span> <span class="attr">method</span>=<span class="string">"doBefore"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after</span>    <span class="attr">pointcut-ref</span>=<span class="string">"cutIn"</span> <span class="attr">method</span>=<span class="string">"doAfter"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span>   <span class="attr">pointcut-ref</span>=<span class="string">"cutIn"</span> <span class="attr">method</span>=<span class="string">"doAround"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut-ref</span>=<span class="string">"cutIn"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">method</span>=<span class="string">"doThrowing"</span> <span class="attr">throwing</span>=<span class="string">"ex"</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3、结果"><a href="#3、结果" class="headerlink" title="3、结果"></a>3、结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">23:39:48.756 [http-nio-8080-exec-4] INFO  c.g.f.aspect.LoggerAspectHelper</span><br><span class="line">- before current time:1529509188756</span><br><span class="line">23:39:48.757 [http-nio-8080-exec-4] INFO  c.g.f.aspect.LoggerAspectHelper</span><br><span class="line">- around current time:1529509188757</span><br><span class="line">excute queryAll method...</span><br><span class="line">23:39:48.757 [http-nio-8080-exec-4] INFO  c.g.f.aspect.LoggerAspectHelper</span><br><span class="line">- after current time:1529509188757</span><br></pre></td></tr></table></figure><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><hr><p>从上面的例子中我们都是使用一些正则表达式来指定我们的切入点的。在实际的使用中，不仅仅是execution，还有其他很多种类型的表达式。下面就列举一些：</p><h3 id="1、execution"><a href="#1、execution" class="headerlink" title="1、execution"></a>1、execution</h3><p>用于匹配方法执行的连接点;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.glmapper.book.web.controller.*.*(..))</span><br></pre></td></tr></table></figure><ul><li>execution（）表达式的主体；</li><li>第一个 “*” 符号表示返回值的类型任意；</li><li>com.glmapper.book.web.controller       AOP所切的服务的包名，即，我们的业务部分</li><li>包名后面的”.”    表示当前包及子包</li><li>第二个”*”    表示类名，即所有类</li><li>.*(..) 表示任何方法名，括号表示参数，两个点表示任何参数类型</li></ul><h2 id="2、within"><a href="#2、within" class="headerlink" title="2、within"></a>2、within</h2><p>用于匹配指定类型内的方法执行;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果在com.glmapper.book.web.controller包或其下的任何子包中</span></span><br><span class="line"><span class="comment">//定义了该类型，则在Web层中有一个连接点。</span></span><br><span class="line">within(com.glmapper.book.web.controller..*)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.glmapper.book.web.controller..*)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>@within：用于匹配所以持有指定注解类型内的方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 注解定义</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="henugl@1992.163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: glmapper@磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/6/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD,ElementType.FIELD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AuthAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何目标对象对应的类型持有AuthAnnotation注解的类方法；必须是在目标对象上声明这个注解，在接口上声明的对它不起作用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@within</span>(com.glmapper.book.common.annotaion.AuthAnnotation)</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有被@AdviceAnnotation标注的类都将匹配</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@within(com.glmapper.book.common.annotaion.AuthAnnotation)"</span>) </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3、this"><a href="#3、this" class="headerlink" title="3、this"></a>3、this</h3><p>用于匹配当前AOP代理对象类型的执行方法；注意是AOP代理对象的类型匹配，这样就可能包括引入接口也类型匹配；this中使用的表达式必须是类型全限定名，不支持通配符；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前目标对象（非AOP对象）实现了 UserService 接口的任何方法</span></span><br><span class="line"><span class="keyword">this</span>(com.glmapper.book.web.service.UserService)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于向通知方法中传入代理对象的引用。</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"cutIn() &amp;&amp; this(proxy)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">(ProceedingJoinPoint poin,Object proxy)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"前置通知"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、target"><a href="#4、target" class="headerlink" title="4、target"></a>4、target</h3><p>用于匹配当前目标对象类型的执行方法；注意是目标对象的类型匹配，这样就不包括引入接口也类型匹配；target中使用的表达式必须是类型全限定名，不支持通配符；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前目标对象（非AOP对象）实现了 UserService 接口的任何方法</span></span><br><span class="line">target(com.glmapper.book.web.service.UserService)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于向通知方法中传入代理对象的引用。</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"cutIn() &amp;&amp; target(proxy)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">(ProceedingJoinPoint poin,Object proxy)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"前置通知"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@target：用于匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解；任何目标对象持有Secure注解的类方法；这个和@within一样必须是在目标对象上声明这个注解，在接口上声明的对它同样不起作用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@target</span>(com.glmapper.book.common.annotaion.AuthAnnotation)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@target(com.glmapper.book.common.annotaion.AuthAnnotation)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5、args"><a href="#5、args" class="headerlink" title="5、args"></a>5、args</h3><p>用于匹配当前执行的方法传入的参数为指定类型的执行方法；参数类型列表中的参数必须是类型全限定名，通配符不支持；args属于动态切入点，这种切入点开销非常大，非特殊情况最好不要使用；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任何一个以接受“传入参数类型为java.io.Serializable”开头，</span></span><br><span class="line"><span class="comment">//且其后可跟任意个任意类型的参数的方法执行，</span></span><br><span class="line"><span class="comment">//args指定的参数类型是在运行时动态匹配的</span></span><br><span class="line">args (java.io.Serializable,..)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于将参数传入到通知方法中。</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"cutIn() &amp;&amp; args(age,username)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvide</span><span class="params">(JoinPoint point, <span class="keyword">int</span> age, String username)</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@args：用于匹配当前执行的方法传入的参数持有指定注解的执行；任何一个只接受一个参数的方法，且方法运行时传入的参数持有注解AuthAnnotation；动态切入点，类似于arg指示符；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@args</span> (com.glmapper.book.common.annotaion.AuthAnnotation)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"@args(com.glmapper.book.common.annotaion.AuthAnnotation)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvide</span><span class="params">(JoinPoint point)</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、-annotation"><a href="#6、-annotation" class="headerlink" title="6、@annotation"></a>6、@annotation</h3><p>使用“@annotation(注解类型)”匹配当前执行方法持有指定注解的方法；注解类型也必须是全限定类型名；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前执行方法上持有注解 AuthAnnotation将被匹配</span></span><br><span class="line"><span class="meta">@annotation</span>(com.glmapper.book.common.annotaion.AuthAnnotation)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配连接点被它参数指定的AuthAnnotation注解的方法。</span></span><br><span class="line"><span class="comment">//也就是说，所有被指定注解标注的方法都将匹配。</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.glmapper.book.common.annotaion.AuthAnnotation)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>还有一种是bean的方式，没用过。有兴趣可以看看。</p></blockquote><p>例子在下面说到的基础概念部分对应给出。</p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>基础概念部分主要将 AOP 中的一些概念点捋一捋，这部分主要参考了官网上的一些解释。</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p><code>AOP(Aspect-Oriented Programming)</code>， 即 <strong>面向切面编程</strong>, 它与 <code>OOP</code>( <code>Object-Oriented Programming</code>, 面向对象编程) 相辅相成, 提供了与 <code>OOP</code> 不同的抽象软件结构的视角。在 <code>OOP</code> 中,我们以类(class)作为我们的基本单元, 而 <code>AOP</code> 中的基本单元是 <strong>Aspect(切面)</strong>。</p><p><strong>横切关注点</strong>(<code>Cross Cutting Concern</code>)：独立服务，如系统日志。如果不是独立服务（就是与业务耦合比较强的服务）就不能横切了。通常这种独立服务需要遍布系统各个角落，遍布在业务流程之中。</p><h2 id="Target-Object"><a href="#Target-Object" class="headerlink" title="Target Object"></a>Target Object</h2><p>目标对象。织入 advice 的目标对象。 目标对象也被称为 <code>advised object</code>。<br>因为 Spring AOP 使用运行时代理的方式来实现 aspect, 因此 adviced object 总是一个代理对象(proxied object)；注意， adviced object 指的不是原来的类, 而是织入 advice 后所产生的代理类。</p><h2 id="织入（Weave）"><a href="#织入（Weave）" class="headerlink" title="织入（Weave）"></a>织入（Weave）</h2><p>即<code>Advice</code>应用在<code>JoinPoint</code>的过程，这个过程叫织入。从另外一个角度老说就是将 <code>aspect</code> 和其他对象连接起来, 并创建 <code>adviced object</code> 的过程。</p><p>根据不同的实现技术， <code>AOP</code>织入有三种方式:</p><ul><li>编译器织入，这要求有特殊的<code>Java</code>编译器</li><li>类装载期织入， 这需要有特殊的类装载器</li><li>动态代理织入, 在运行期为目标类添加增强( <code>Advice</code> )生成子类的方式。</li></ul><p>Spring 采用动态代理织入, 而AspectJ采用编译器织入和类装载期</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>Spring AOP默认使用代理的是标准的JDK动态代理。这使得任何接口（或一组接口）都可以代理。</p><p>Spring AOP也可以使用CGLIB代理。如果业务对象不实现接口，则默认使用CGLIB。对接口编程而不是对类编程是一种很好的做法；业务类通常会实现一个或多个业务接口。在一些特殊的情况下，即需要通知的接口上没有声明的方法，或者需要将代理对象传递给具体类型的方法，有可能强制使用CGLIB。</p><h2 id="Introductions"><a href="#Introductions" class="headerlink" title="Introductions"></a>Introductions</h2><p>我们知道Java语言本身并非是动态的，就是我们的类一旦编译完成，就很难再为他添加新的功能。但是在一开始给出的例子中，虽然我们没有向对象中添加新的方法，但是已经向其中添加了新的功能。这种属于向现有的方法添加新的功能，那能不能为一个对象添加新的方法呢？答案肯定是可以的，使用introduction就能够实现。</p><p>introduction：动态为某个类增加或减少方法。为一个类型添加额外的方法或字段。Spring AOP 允许我们为 <code>目标对象</code> 引入新的接口(和对应的实现)。</p><h2 id="Aspect"><a href="#Aspect" class="headerlink" title="Aspect"></a>Aspect</h2><p>切面：通知和切入点的结合。</p><p>切面实现了cross-cutting（横切）功能。最常见的是logging模块、方法执行耗时模块，这样，程序按功能被分为好几层，如果按传统的继承的话，商业模型继承日志模块的话需要插入修改的地方太多，而通过创建一个切面就可以使用AOP来实现相同的功能了，我们可以针对不同的需求做出不同的切面。</p><p>而将散落于各个业务对象之中的Cross-cutting concerns 收集起来，设计各个独立可重用的对象，这些对象称之为Aspect；在上面的例子中我们根据不同的配置方式，定义了四种不同形式的切面。</p><h2 id="Joinpoint"><a href="#Joinpoint" class="headerlink" title="Joinpoint"></a>Joinpoint</h2><p>Aspect 在应用程序执行时加入业务流程的点或时机称之为 Joinpoint ，具体来说，就是 Advice 在应用程序中被呼叫执行的时机，这个时机可能是某个方法被呼叫之前或之后（或两者都有），或是某个异常发生的时候。</p><h3 id="Joinpoint-amp-ProceedingJoinPoint"><a href="#Joinpoint-amp-ProceedingJoinPoint" class="headerlink" title="Joinpoint &amp; ProceedingJoinPoint"></a>Joinpoint &amp; ProceedingJoinPoint</h3><p>环绕通知 = 前置+目标方法执行+后置通知，proceed方法就是用于启动目标方法执行的。</p><p>环绕通知 ProceedingJoinPoint 执行 proceed 方法 的作用是让目标方法执行 ，这 也是环绕通知和前置、后置通知方法的一个最大区别。</p><p>Proceedingjoinpoint 继承了 JoinPoint 。是在JoinPoint的基础上暴露出 proceed 这个方法。proceed很重要，这个是aop代理链执行的方法；暴露出这个方法，就能支持<a href="aop:around" target="_blank" rel="noopener">aop:around</a> 这种切面（其他的几种切面只需要用到JoinPoint，这跟切面类型有关）， 能决定是否走代理链还是走自己拦截的其他逻辑。</p><p>在环绕通知的方法中是需要返回一个Object类型对象的，如果把环绕通知的方法返回类型是void，将会导致一些无法预估的情况，比如：404。</p><h2 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h2><p>匹配 <code>join points</code>的谓词。<code>Advice</code>与切入点表达式相关联, 并在切入点匹配的任何连接点上运行。（例如，具有特定名称的方法的执行）。由切入点表达式匹配的连接点的概念是<code>AOP</code>的核心，<code>Spring</code>默认使用<code>AspectJ</code>切入点表达式语言。</p><p>在 <code>Spring</code> 中, 所有的方法都可以认为是<code>Joinpoint</code>, 但是我们并不希望在所有的方法上都添加 <code>Advice</code>, 而 <code>Pointcut</code> 的作用就是提供一组规则(使用 <code>AspectJ pointcut expression language</code> 来描述) 来匹配<code>Joinpoint</code>, 给满足规则的<code>Joinpoint</code> 添加 <code>Advice</code>。</p><h3 id="Pointcut-和-Joinpoint"><a href="#Pointcut-和-Joinpoint" class="headerlink" title="Pointcut 和 Joinpoint"></a>Pointcut 和 Joinpoint</h3><p>在<code>Spring AOP</code> 中, 所有的方法执行都是 <code>join point</code>。 而 <code>point cut</code> 是一个描述信息，它修饰的是 <code>join point</code>， 通过 <code>point cut</code>，我们就可以确定哪些 <code>join point</code> 可以被织入<code>Advice</code>。 因此<code>join point</code> 和 <code>point cut</code>本质上就是两个不同维度上的东西。</p><p><code>advice</code> 是在 <code>join point</code> 上执行的, 而 <code>point cut</code> 规定了哪些 <code>join point</code> 可以执行哪些 <code>advice</code>。</p><h2 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Advice 是我们切面功能的实现，它是切点的真正执行的地方。比如像前面例子中打印时间的几个方法（被@Before等注解标注的方法都是一个通知）；Advice 在 Jointpoint 处插入代码到应用程序中。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>BeforeAdvice，AfterAdvice，区别在于Advice在目标方法之前调用还是之后调用，Throw Advice 表示当目标发生异常时调用Advice。</p><ul><li>before advice： 在 join point 前被执行的 advice. 虽然 before advice 是在 join point 前被执行, 但是它并不能够阻止 join     point 的执行, 除非发生了异常(即我们在 before advice 代码中, 不能人为地决定是否继续执行 join point 中的代码)</li><li>after return advice： 在一个 join point 正常返回后执行的 advice</li><li>after throwing advice： 当一个 join point 抛出异常后执行的 advice</li><li>after(final) advice： 无论一个 join point 是正常退出还是发生了异常, 都会被执行的 advice.</li><li>around advice：在 join point 前和 joint point 退出后都执行的 advice. 这个是最常用的 advice.</li></ul><h2 id="Advice、JoinPoint、PointCut-关系"><a href="#Advice、JoinPoint、PointCut-关系" class="headerlink" title="Advice、JoinPoint、PointCut 关系"></a>Advice、JoinPoint、PointCut 关系</h2><p><img src="https://user-gold-cdn.xitu.io/2018/6/21/1641e065ec1ad2e7?w=712&amp;h=148&amp;f=jpeg&amp;s=22970" alt=""></p><p>下面这张图是在网上一位大佬的博客里发现的，可以帮助我们更好的理解这些概念之间的关系。</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/21/1641e0a1e65715e4?w=581&amp;h=405&amp;f=jpeg&amp;s=32663" alt="图片源自网络"></p><p>上面是对于AOP中涉及到的一些基本概念及它们之间的关系做了简单的梳理。</p><h2 id="一些坑"><a href="#一些坑" class="headerlink" title="一些坑"></a>一些坑</h2><p>在调试程序过程中出现的一些问题记录</p><h3 id="1、使用AOP拦截controller层的服务成功，但是页面报错404"><a href="#1、使用AOP拦截controller层的服务成功，但是页面报错404" class="headerlink" title="1、使用AOP拦截controller层的服务成功，但是页面报错404"></a>1、使用AOP拦截controller层的服务成功，但是页面报错404</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint poin)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"环绕通知"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是再使用环绕通知时，需要给方法一个返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint poin)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"环绕通知"</span>);</span><br><span class="line">    <span class="keyword">return</span> poin.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、0-formal-unbound-in-pointcut"><a href="#2、0-formal-unbound-in-pointcut" class="headerlink" title="2、0 formal unbound in pointcut"></a>2、0 formal unbound in pointcut</h3><p>在spring 4.x中 提供了aop注解方式 带参数的方式。看下面例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(value = <span class="string">"execution(* com.glmapper.framerwork.service.impl.*(int,int)) &amp;&amp; args(i,j)"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Before</span>(value=<span class="string">"cutIn(i, j)"</span>,argNames = <span class="string">"i,j"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">( <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"---------begins with "</span> + i + <span class="string">"-"</span> +j);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如说这里，Before中有两个int类型的参数，如果此时我们在使用时没有给其指定参数，那么就会抛出：<strong>Caused by: java.lang.IllegalArgumentException: error at ::0 formal unbound in pointcut</strong> 异常信息。</p><p><code>本来是想放在一篇里面的，但是实在太长了，就分开吧；周末更新下</code></p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 聊一聊 </tag>
            
            <tag> aop </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Google Guava 在实际场景中的应用封装</title>
      <link href="/2018/11/10/guavacacheone/"/>
      <url>/2018/11/10/guavacacheone/</url>
      
        <content type="html"><![CDATA[<blockquote><p>毕竟西湖六月中，风光不与四时同。</p><p>接天莲叶无穷碧，映日荷花别样红。</p><p>晓出净慈寺送林子方-杨万里</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/6/24/16432555f503d718?w=3968&amp;h=2976&amp;f=jpeg&amp;s=2734726" alt=""></p><p>周末与小伙伴约了一波西湖，这个时间荷花开的正好…，在开始文章之前先放一张“佛系”美图来镇楼！！！</p><p>最近这段时间用了下谷歌的guava，自己封了一个缓存模板方案，特此记录，以备后续所需。</p><h2 id="一个缓存定时清除任务带来的GC问题"><a href="#一个缓存定时清除任务带来的GC问题" class="headerlink" title="一个缓存定时清除任务带来的GC问题"></a>一个缓存定时清除任务带来的GC问题</h2><p>为什么要从这个来说起，因为不说这个就没guava什么事了！</p><p>最近项目中需要使用缓存来对一查查询频繁的数据做缓存处理；首先我们也不希望引入三方的如redis或者memcache这样的服务进来，其次是我们对于数据一致性的要求并不是很高，不需要集群内的查询接口共享到一份缓存数据；所以这样一来我们只要实现一个基于内存的缓存即可。</p><p>最开始我并没有考虑使用guava来做这个事情，而是自己写了一套基于CurrentHashMap的缓存方案；这里需要明确一点，因为缓存在这个场景里面希望提供超时清除的能力，而基于所以在自己缓存框架中增加了定时清除过期数据的能力。</p><p>这里我就直接把定时清楚的这段代码放上来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类来进行超时处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ClearCacheThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">                Object[] keys = map.keySet().toArray();</span><br><span class="line">                <span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line">                    CacheEntry entry = map.get(key);</span><br><span class="line">                    <span class="keyword">if</span> (now - entry.time &gt;= cacheTimeout) &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span> (map) &#123;</span><br><span class="line">                            map.remove(key);</span><br><span class="line">                            <span class="keyword">if</span> (LOGGER.isDebugEnabled())&#123;</span><br><span class="line">                                LOGGER.debug(<span class="string">"language cache timeout clear"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                LOGGER.error(<span class="string">"clear out time cache value error;"</span>,e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个线程是用来单独处理过期数据的。缓存初始化时就会触发这个线程的start方法开始执行。</p><p>正式由于这段代码的不合理导致我在发布dev环境之后，机器GC触发的频次高的离谱。在尝试了不同的修复方案之后，最后选择放弃了；改用guava了！</p><p>小伙伴们可以在下面留言来讨论下这里为什么会存在频繁GC的问题；我会把结论放在评论回复里面。</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/24/16432756a9b3e7e8?w=1140&amp;h=534&amp;f=png&amp;s=220453" alt=""></p><h2 id="guava"><a href="#guava" class="headerlink" title="guava"></a>guava</h2><p>为什么选用guava呢，很显然，是大佬推荐的！！！</p><blockquote><p>guava是谷歌提供的一个基于内存的缓存工具包，Guava Cache 提供了一种把数据（key-value对）缓存到本地（JVM）内存中的机制，适用于很少会改动的数据。Guava Cache 与 ConcurrentMap 很相似，但也不完全一样。最基本的区别是 ConcurrentMap 会一直保存所有添加的元素，直到显式地移除。相对地，Guava Cache 为了限制内存占用，通常都设定为自动回收元素。</p></blockquote><p>对于我们的场景，guava 提供的能力满足了我们的需要：</p><ul><li>数据改动小</li><li>基于内存</li><li>可以自动回收</li></ul><p>既然选择它了，我们还是有必要来先对它有个大致的了解；先来看看它提供的一些类和接口：</p><table><thead><tr><th>接口/类</th><th>详细解释</th></tr></thead><tbody><tr><td>Cache</td><td>【I】;定义get、put、invalidate等操作，这里只有缓存增删改的操作，没有数据加载的操作。</td></tr><tr><td>AbstractCache</td><td>【C】;实现Cache接口。其中批量操作都是循环执行单次行为，而单次行为都没有具体定义。</td></tr><tr><td>LoadingCache</td><td>【I】;继承自Cache。定义get、getUnchecked、getAll等操作，这些操作都会从数据源load数据。</td></tr><tr><td>AbstractLoadingCache</td><td>【C】;继承自AbstractCache，实现LoadingCache接口。</td></tr><tr><td>LocalCache</td><td>【C】;整个guava cache的核心类，包含了guava cache的数据结构以及基本的缓存的操作方法。</td></tr><tr><td>LocalManualCache</td><td>【C】;LocalCache内部静态类，实现Cache接口。其内部的增删改缓存操作全部调用成员变量localCache（LocalCache类型）的相应方法。</td></tr><tr><td>LocalLoadingCache</td><td>【C】;LocalCache内部静态类，继承自LocalManualCache类，实现LoadingCache接口。其所有操作也是调用成员变量localCache（LocalCache类型）的相应方法</td></tr><tr><td>CacheBuilder</td><td>【C】;缓存构建器。构建缓存的入口，指定缓存配置参数并初始化本地缓存。CacheBuilder在build方法中，会把前面设置的参数，全部传递给LocalCache，它自己实际不参与任何计算</td></tr><tr><td>CacheLoader</td><td>【C】;用于从数据源加载数据，定义load、reload、loadAll等操作。</td></tr></tbody></table><p>整个来看的话，guava里面最核心的应该算是 LocalCache 这个类了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span>(emulated = <span class="keyword">true</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span></span></span><br><span class="line"><span class="class"><span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于这个类的源码这里就不细说了，直接来看下在实际应用中我的封装思路【封装满足我当前的需求，如果有小伙伴需要借鉴，可以自己在做扩展】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>            MAX_SIZE     = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>            EXPIRE_TIME  = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>            DEFAULT_SIZE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>                         maxSize      = MAX_SIZE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>                         expireTime   = EXPIRE_TIME;</span><br><span class="line"><span class="comment">/** 时间单位（分钟） */</span></span><br><span class="line"><span class="keyword">private</span> TimeUnit                    timeUnit     = TimeUnit.MINUTES;</span><br><span class="line"><span class="comment">/** Cache初始化或被重置的时间  */</span></span><br><span class="line"><span class="keyword">private</span> Date                        resetTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 分别记录历史最多缓存个数及时间点*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>                        highestSize  = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> Date                        highestTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> LoadingCache&lt;K, V&gt; cache;</span><br></pre></td></tr></table></figure><p>这里先是定义了一些常量和基本的属性信息，当然这些属性会提供set&amp;get方法，供实际使用时去自行设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LoadingCache&lt;K, V&gt; <span class="title">getCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用双重校验锁保证只有一个cache实例</span></span><br><span class="line">    <span class="keyword">if</span>(cache == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cache == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//CacheBuilder的构造函数是私有的，只能通过其静态方法newBuilder()来获得CacheBuilder的实例</span></span><br><span class="line">                cache = CacheBuilder.newBuilder()</span><br><span class="line">                        <span class="comment">//设置缓存容器的初始容量为100</span></span><br><span class="line">                        .initialCapacity(DEFAULT_SIZE)</span><br><span class="line">                        <span class="comment">//缓存数据的最大条目</span></span><br><span class="line">                        .maximumSize(maxSize)</span><br><span class="line">                        <span class="comment">//定时回收:缓存项在给定时间内没有被写访问（创建或覆盖），则回收。</span></span><br><span class="line">                        .expireAfterWrite(expireTime, timeUnit)</span><br><span class="line">                        <span class="comment">//启用统计-&gt;统计缓存的命中率等</span></span><br><span class="line">                        .recordStats()</span><br><span class="line">                        <span class="comment">//设置缓存的移除通知</span></span><br><span class="line">                        .removalListener((notification)-&gt; &#123;</span><br><span class="line">                            <span class="keyword">if</span> (LOGGER.isDebugEnabled())&#123;</span><br><span class="line">                                LOGGER.debug(<span class="string">"&#123;&#125; was removed, cause is &#123;&#125;"</span> ,notification.getKey(), notification.getCause());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">                        .build(<span class="keyword">new</span> CacheLoader&lt;K, V&gt;() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> V <span class="title">load</span><span class="params">(K key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                <span class="keyword">return</span> fetchData(key);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                <span class="keyword">this</span>.resetTime = <span class="keyword">new</span> Date();</span><br><span class="line">                <span class="keyword">this</span>.highestTime = <span class="keyword">new</span> Date();</span><br><span class="line">                <span class="keyword">if</span> (LOGGER.isInfoEnabled())&#123;</span><br><span class="line">                    LOGGER.info(<span class="string">"本地缓存&#123;&#125;初始化成功."</span>, <span class="keyword">this</span>.getClass().getSimpleName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码是整个缓存的核心，通过这段代码来生成我们的缓存对象【使用了单例模式】。具体的属性参数看注释。</p><p>因为上面的那些都是封装在一个抽象类AbstractGuavaCache里面的，所以我又封装了一个CacheManger用来管理缓存，并对外提供具体的功能接口；在CacheManger中，我使用了一个静态内部类来创建当前默认的缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用静态内部类实现一个默认的缓存，委托给manager来管理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DefaultGuavaCache 使用一个简单的单例模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;String&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;Object&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultGuavaCache</span>&lt;<span class="title">String</span>, <span class="title">Object</span>&gt; <span class="keyword">extends</span></span></span><br><span class="line"><span class="class"><span class="title">AbstractGuavaCache</span>&lt;<span class="title">String</span>, <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AbstractGuavaCache cache = <span class="keyword">new</span> DefaultGuavaCache();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理自动载入缓存，按实际情况载入</span></span><br><span class="line"><span class="comment">     * 这里</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">fetchData</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractGuavaCache <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DefaultGuavaCache.cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概思路就是这样，如果需要扩展，我们只需要按照实际的需求去扩展AbstractGuavaCache这个抽象类就可以了。具体的代码贴在下面了。</p><h2 id="完整的两个类"><a href="#完整的两个类" class="headerlink" title="完整的两个类"></a>完整的两个类</h2><h3 id="AbstractGuavaCache"><a href="#AbstractGuavaCache" class="headerlink" title="AbstractGuavaCache"></a>AbstractGuavaCache</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractGuavaCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Logger              LOGGER       = LoggerFactory.getLogger(AbstractGuavaCache.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>            MAX_SIZE     = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>            EXPIRE_TIME  = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/** 用于初始化cache的参数及其缺省值 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>            DEFAULT_SIZE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                         maxSize      = MAX_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                         expireTime   = EXPIRE_TIME;</span><br><span class="line">    <span class="comment">/** 时间单位（分钟） */</span></span><br><span class="line">    <span class="keyword">private</span> TimeUnit                    timeUnit     = TimeUnit.MINUTES;</span><br><span class="line">    <span class="comment">/** Cache初始化或被重置的时间  */</span></span><br><span class="line">    <span class="keyword">private</span> Date                        resetTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 分别记录历史最多缓存个数及时间点*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>                        highestSize  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Date                        highestTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> LoadingCache&lt;K, V&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoadingCache&lt;K, V&gt; <span class="title">getCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用双重校验锁保证只有一个cache实例</span></span><br><span class="line">        <span class="keyword">if</span>(cache == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cache == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//CacheBuilder的构造函数是私有的，只能通过其静态方法ne</span></span><br><span class="line">                    <span class="comment">//wBuilder()来获得CacheBuilder的实例</span></span><br><span class="line">                    cache = CacheBuilder.newBuilder()</span><br><span class="line">                            <span class="comment">//设置缓存容器的初始容量为100</span></span><br><span class="line">                            .initialCapacity(DEFAULT_SIZE)</span><br><span class="line">                            <span class="comment">//缓存数据的最大条目</span></span><br><span class="line">                            .maximumSize(maxSize)</span><br><span class="line">                            <span class="comment">//定时回收:缓存项在给定时间内没有被写访问</span></span><br><span class="line">                            <span class="comment">//（创建或覆盖），则回收。</span></span><br><span class="line">                            .expireAfterWrite(expireTime, timeUnit)</span><br><span class="line">                            <span class="comment">//启用统计-&gt;统计缓存的命中率等</span></span><br><span class="line">                            .recordStats()</span><br><span class="line">                            <span class="comment">//设置缓存的移除通知</span></span><br><span class="line">                            .removalListener((notification)-&gt; &#123;</span><br><span class="line">                                <span class="keyword">if</span> (LOGGER.isDebugEnabled())&#123;</span><br><span class="line">                                   <span class="comment">//...</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">                            .build(<span class="keyword">new</span> CacheLoader&lt;K, V&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> V <span class="title">load</span><span class="params">(K key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    <span class="keyword">return</span> fetchData(key);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                    <span class="keyword">this</span>.resetTime = <span class="keyword">new</span> Date();</span><br><span class="line">                    <span class="keyword">this</span>.highestTime = <span class="keyword">new</span> Date();</span><br><span class="line">                    <span class="keyword">if</span> (LOGGER.isInfoEnabled())&#123;</span><br><span class="line">                         <span class="comment">//...</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key从数据库或其他数据源中获取一个value，并被自动保存到缓存中。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 改方法是模板方法，子类需要实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> value,连同key一起被加载到缓存中的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> V <span class="title">fetchData</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从缓存中获取数据（第一次自动调用fetchData从外部获取数据），并处理异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> V <span class="title">getValue</span><span class="params">(K key)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">        V result = getCache().get(key);</span><br><span class="line">        <span class="keyword">if</span> (getCache().size() &gt; highestSize) &#123;</span><br><span class="line">            highestSize = getCache().size();</span><br><span class="line">            highestTime = <span class="keyword">new</span> Date();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxSize</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getExpireTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> expireTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExpireTime</span><span class="params">(<span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.expireTime = expireTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TimeUnit <span class="title">getTimeUnit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeUnit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeUnit</span><span class="params">(TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timeUnit = timeUnit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getResetTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resetTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResetTime</span><span class="params">(Date resetTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resetTime = resetTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getHighestSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> highestSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHighestSize</span><span class="params">(<span class="keyword">long</span> highestSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.highestSize = highestSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getHighestTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> highestTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHighestTime</span><span class="params">(Date highestTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.highestTime = highestTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DefaultGuavaCacheManager"><a href="#DefaultGuavaCacheManager" class="headerlink" title="DefaultGuavaCacheManager"></a>DefaultGuavaCacheManager</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultGuavaCacheManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger  LOGGER =</span><br><span class="line">    LoggerFactory.getLogger(DefaultGuavaCacheManager.class);</span><br><span class="line">   <span class="comment">//缓存包装类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AbstractGuavaCache&lt;String, Object&gt; cacheWrapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化缓存容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">initGuavaCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cacheWrapper = DefaultGuavaCache.getInstance();</span><br><span class="line">            <span class="keyword">if</span> (cacheWrapper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Failed to init Guava cache;"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        cacheWrapper.getCache().put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定缓存时效</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        cacheWrapper.getCache().invalidate(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量清除</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invalidateAll</span><span class="params">(Iterable&lt;?&gt; keys)</span> </span>&#123;</span><br><span class="line">        cacheWrapper.getCache().invalidateAll(keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除所有缓存项 ： 慎用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invalidateAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cacheWrapper.getCache().invalidateAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cacheWrapper.getCache().get(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Failed to get value from guava cache;"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用静态内部类实现一个默认的缓存，委托给manager来管理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * DefaultGuavaCache 使用一个简单的单例模式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;String&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;Object&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultGuavaCache</span>&lt;<span class="title">String</span>, <span class="title">Object</span>&gt; <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">    <span class="title">AbstractGuavaCache</span>&lt;<span class="title">String</span>, <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> AbstractGuavaCache cache = <span class="keyword">new</span> DefaultGuavaCache();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 处理自动载入缓存，按实际情况载入</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">fetchData</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractGuavaCache <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DefaultGuavaCache.cache;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://willnewii.gitbooks.io/google-guava/content/" target="_blank" rel="noopener">Google Guava官方教程（中文版）</a></p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cache </tag>
            
            <tag> guava </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分布式链路跟踪组件 SOFATracer 和 Zipkin 模型转换原理</title>
      <link href="/2018/11/10/sofatracertwo/"/>
      <url>/2018/11/10/sofatracertwo/</url>
      
        <content type="html"><![CDATA[<p>SOFATracer 是一个用于分布式系统调用跟踪的组件，通过统一的 traceId 将调用链路中的各种网络调用情况以日志的方式记录下来或者上报到 zipkin，以达到透视化网络调用的目的。这种以日志的方式记录下来或者上报到zipkin通常称为 Report，即数据上报 SOFATracer 的数据上报是在遵循 OpenTracing 规范基础上扩展出来的能力，OpenTracing 规范本身只是约定了数据模型和行为。本文主要目的在于分析 SOFATracer 的数据上报功能部分，主要内容如下：</p><ul><li>基于 OpenTracing 规范的分布式链路跟踪解决方案</li><li>SOFATracer Report 数据上报模型</li><li>SOFATracer 和  Zipkin 模型转换原理</li></ul><h2 id="基于-OpenTracing-规范的分布式链路跟踪解决方案"><a href="#基于-OpenTracing-规范的分布式链路跟踪解决方案" class="headerlink" title="基于 OpenTracing 规范的分布式链路跟踪解决方案"></a>基于 OpenTracing 规范的分布式链路跟踪解决方案</h2><p> OpenTracing 是一个轻量级的标准化层，它位于应用程序/类库和追踪或日志分析程序之间。为了解决不同的分布式追踪系统 API 不兼容的问题，OpenTracing 提供了一套平台无关、厂商无关的 API，同时也提供了统一的概念和数据标准。关于对 OpenTracing 标准的版本化描述可以参考 specification.md（<a href="https://github.com/opentracing/specification/blob/master/specification.md）。一些具体的概念下面将结合SOFATracer" target="_blank" rel="noopener">https://github.com/opentracing/specification/blob/master/specification.md）。一些具体的概念下面将结合SOFATracer</a> 的实现来一一说明。</p><p> 目前基于 OpenTracing 规范实现的链路跟踪组件有 Jaeger，Appdash，Apache SkyWalking ，Datadog 等。像谷歌的 StackDriver Tracer 实际上并不是遵循 OpenTracing 规范的，但是都源自于 Dapper 这篇论文。</p><p> 规范其实就是模型和行为的约束，在 OpenTracing 规范中有三种关键和相互关联的模型：Tracer、Span 和SpanContext；并且在规范中对于每个模型的行为也做了约定。</p><h3 id="Tracer"><a href="#Tracer" class="headerlink" title="Tracer"></a>Tracer</h3><p> Tracer 可以被认为是一个由多个 Span 组成的有向无环图。一个 Tracer 可以用来描述一个请求从发出到收到响应整个链路过程。前提是需要在适当的地方进行埋点。下图就是一条完整的链路的展示：</p><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1536236659627-31fa22c0-6cb0-4f8b-825c-5892aa266aac.png" alt="img"></p><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1536236727855-6c02f1a7-3e6c-4236-b2d4-37dc4c69d57f.png" alt="img"></p><p> 在 SOFATracer 中 ，SofaTracer 实现了 Tracer 接口，实现了构建 span，数据载入（Inject）和 数据提取（Extract ) 的能力。</p><ul><li>Start a new Span ：创建一个新的 Span 。通过指定的 operationName 来创建一个新的 Span。operationName 表示由 Span 完成的具体的工作 ( 例如，RPC 方法名称、函数名称或一个较大的计算任务中的阶段的名称)。</li><li>Inject a SpanContext：将 SpanContext 注入到给定类型的 “carrier” 中，用于进行跨进程的传输。</li><li>Extract a SpanContext ：从载体中提取中 spanContext 实例对象。这个过程是注入的逆过程。spanContext 中包括了贯穿整个链路的 traceId ，变化的 spanId ，父 spanId 以及透传数据等。</li></ul><h3 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h3><p> 一个 span 代表系统中具有开始时间和执行时长的逻辑运行单元。span 之间通过嵌套或者顺序排列建立逻辑因果关系，然后再通过这种关系来构建整个调用链路（Tracer）。</p><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1536238542375-0bd31368-4f84-4504-99ee-d02fdc00b99e.png" alt="img"> </p><p>OpenTracing 规范 API 约定 Span 的模型如下（实际上就是 Span 接口中对应的方法，需要由遵循该规范的实现者必须提供的最小能力的集合）：</p><ul><li>Get the Span’s SpanContext： 通过 Span 获取 SpanContext （即使 span 已经结束，或者即将结束）</li><li>Finish：结束一个 Span 。Finish 必须是 span 实例的最后一个被调用的方法。但是在主线程处理失败或者其他程序错误发生时，Finish 方法可能不会被调用。在这种情况下，实现者应该明确的记录 Span，保证数据的持久化（这一点 SOFATracer 其实是没有做的）。</li><li>Set a K:V tag on the Span：为 Span 设置 tag 。tag 的 key 必须是 string 类型；value 必须是 string、boolean 或数字类型。通常会使用 Tag 来记录跟踪系统感兴趣的一些指标数据。</li><li>Add a new log event：为 Span 增加一个 log 事件，用于记录 Span 生命周期中发生的事件。</li><li>Set a Baggage item： 设置一个 string:string 类型的键值对，一般是业务数据在全链路数据透明传输，存储在 SpanContext 中。</li><li>Get a Baggage item： 通过 key 获取 Baggage 中的元素。</li></ul><h3 id="SpanContext"><a href="#SpanContext" class="headerlink" title="SpanContext"></a>SpanContext</h3><p> Span 上下文，几乎包含了需要在链路中传递的全部信息。另外，Span 间 References 就是通过 SpanContext 来建立关系的。根据 OpenTracing 规范要求，SpanContext 是不可变的，目的是防止由于 Span 的结束和相互关系，造成的复杂生命周期问题。</p><p> SpanContext 表示必须传播到后代 Spans 和跨进程边界的 Span 状态。SpanContext 在逻辑上分为两部分：</p><ul><li>跨 Span 边界传播的用户级 “Baggage”</li><li>识别或以其他方式关联 Span 实例所需的任何 Tracer 实现特定字段（例如，trace_id，span_id，sampling，元组） </li></ul><p>Opentracing 中 SpanContext 接口中只有一个 baggageItems 方法，通过这个方法来遍历所有的 baggage 元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpanContext</span> </span>&#123;</span><br><span class="line">    Iterable&lt;Map.Entry&lt;String, String&gt;&gt; baggageItems();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SOFATracer-扩展的-Tracer-的能力"><a href="#SOFATracer-扩展的-Tracer-的能力" class="headerlink" title="SOFATracer 扩展的 Tracer 的能力"></a>SOFATracer 扩展的 Tracer 的能力</h3><p>上面简单介绍了 OpenTracing 规范  API  对于 Tracer、Span、SpanContext 三个核心模型的规范定义。下面来看下 SOFATracer 是如何遵循规范并做扩展的。</p><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1536241818520-0b112c9e-f785-4538-b507-e12a96854631.png" alt="img"></p><p>在 <a href="http://opentracing.io/documentation/pages/spec.html" target="_blank" rel="noopener">OpenTracing</a> 规范 基础上，SOFATracer 提供了实现，并在规范基础上提供了扩展功能。本文主要介绍上图中标绿色的部分，即数据上报功能。</p><p>SOFATracer 中提供了 Report 接口，然后基于此接口扩展了两个实现：</p><ul><li>第一种 Report 扩展是基于 Disruptor（<a href="https://github.com/LMAX-Exchange/disruptor）" target="_blank" rel="noopener">https://github.com/LMAX-Exchange/disruptor）</a> 高性能无锁循环队列的异步落地磁盘的日志打印。</li><li>第二种 Report 扩展是提供远程上报，能够将 SOFATracer 的链路数据模型汇报到 Zipkin 中做调用链路的展示。 </li></ul><p>当然，SOFATracer 也允许用户自定义上报功能，只需要在自己的工程代码中实现 Report 接口即可，下面是 Report 接口的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Reporter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 上报到远程服务器的持久化类型</span></span><br><span class="line">    String REMOTE_REPORTER    = <span class="string">"REMOTE_REPORTER"</span>;</span><br><span class="line">    <span class="comment">// 组合类型</span></span><br><span class="line">    String COMPOSITE_REPORTER = <span class="string">"COMPOSITE_REPORTER"</span>;</span><br><span class="line">    <span class="comment">// 获取 Reporter 实例类型</span></span><br><span class="line">    <span class="function">String <span class="title">getReporterType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 上报 span</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">(SofaTracerSpan span)</span></span>;</span><br><span class="line">    <span class="comment">// 关闭上报 span 的能力</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SOFATracer-Report-数据上报模型"><a href="#SOFATracer-Report-数据上报模型" class="headerlink" title="SOFATracer Report 数据上报模型"></a>SOFATracer Report 数据上报模型</h2><p> 上面提到 SOFATracer 的 Report 有两种机制，一种是落到磁盘，另外一种是上报到 zipkin。SOFATracer 中这两种方案并不是二选一的，而是可以同时使用多个实现。例如，我们希望上报数据到 zipkin，先引入 tracer-sofa-boot-starter 这个依赖，并进行相关 zipkin 的配置之后就可以将链路数据上报到 zipkin，如果没有引入依赖则不会上报。本节来分析下 SOFATracer 上报数据过程的具体逻辑。</p><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1536201415524-19bc4895-dac4-4582-b17c-48e2b39126e2.png" alt="img"></p><p> 上面这张图描述了数据上报的几种方式：</p><ul><li>绿色部分，上报 zipkin：这里其实就是实现上报 zipkin 的一个回调，当进行 reportSpan 操作时，会执行一个invokeReportListeners ，这个方法就是通知所有实现了 SpanReportListener 接口的类执行回调方法，然后在这个回调方法中将 span 数据上报到 zipkin。</li><li><p>红色部分，输出到磁盘：SOFATracer 为了提供更好的扩展能力，将输出日志的 Report 细分为 client 和 server 两种；并在 Tracer 基类中提供 generateClientStatReporter 和 generateServerStatReporter 两个抽象方法，供不同的组件自己来实现一些特殊化的定制。</p><p>关于何时进行上报，其实这个在 Opentracing API 的规范中已经给出了明确的时机。在上面的介绍中提到，“Finish必须是 span 实例的最后一个被调用的方法”，当 finish 方法被调用时也就意味着一个 span 生命周期的结束，为了保证 span 数据的完整性和正确性，SOFATracer reportSpan 的逻辑就是在 finish 方法被调用时触发执行。</p></li></ul><h3 id="数据落地磁盘"><a href="#数据落地磁盘" class="headerlink" title="数据落地磁盘"></a>数据落地磁盘</h3><p> SOFATracer 日志落盘是基于<a href="https://github.com/LMAX-Exchange/disruptor" target="_blank" rel="noopener">Disruptor</a>高性能无锁循环队列实现的，提供了异步打印日志到本地磁盘的能力。</p><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1536205560373-b3b5b362-8041-4077-8b4f-38b76bde25d7.png" alt="img"> </p><p><strong>append</strong> : 追溯 Report，无论是 clientReport 还是 serverReport ，底层均依赖 DiskReporterImpl 的实现。DiskReporterImpl 是 SOFATracer 统筹处理日志落盘的类。clientReport 和 serverReport 的最终调用都会走到DiskReporterImpl 中的 digestReport 这个方法。digestReport 中会将当前 span append 到环形缓冲队列中，append 操作就是发布一个事件的过程。</p><p><strong>consume</strong>：consume 是 Disruptor 中的对应的消费模型；SOFATracer 中这个消费者就是将 SofaTracerSpan 中的数据写到日志文件中的。</p><p>事件发布过程：</p><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1536206792096-48737dab-09e4-4825-8829-5b9af6668a1f.png" alt="img"></p><h3 id="数据上报-zipkin"><a href="#数据上报-zipkin" class="headerlink" title="数据上报 zipkin"></a>数据上报 zipkin</h3><p> 前面提到，上报 zipkin 的是通过 onSpanReport 这个回调函数完成的。tracer-sofa-boot-starter 这个依赖中提供了 SpanReportListener 接口实现 ZipkinSofaTracerSpanRemoteReporter 。而在 onSpanReport 这个回调函数中，又将具体上报委托给了 AsyncReporter 来处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSpanReport</span><span class="params">(SofaTracerSpan span)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (span == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//convert</span></span><br><span class="line">    Span zipkinSpan = convertToZipkinSpan(span);</span><br><span class="line">    <span class="keyword">this</span>.delegate.report(zipkinSpan);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建 AsyncReporter 对象需要两个参数：</p><ul><li>sender： 数据发送器，SOFATracer 中，sender 的是通过 RestTemplate 以 http 方式 来与 zipkin 进行通信传输的。</li><li>url：Zipkin 默认的 Collector 使用 http 协议里收集 Trace 信息，客户端调用 /api/v1/spans 或 /api/v2/spans 来上报 tracer 信息。这里我们使用的是 Zipkin V2 的 API。</li></ul><p>AsyncReporter 中实际构建的是 BoundedAsyncReporter 对象 ， 并且在构建一个异步报告器是，会根据messageTimeoutNanos 是否大于 0 来决定是否起一个守护线程 flushThread；flushThread 作用是一直循环调用 BoundedAsyncReporter 的 flush 方法，将内存中的 Span 信息上报给 Zipkin。具体细节这里不展开分析。</p><h2 id="SOFATracer-和-Zipkin-模型转换原理"><a href="#SOFATracer-和-Zipkin-模型转换原理" class="headerlink" title="SOFATracer 和  Zipkin 模型转换原理"></a>SOFATracer 和  Zipkin 模型转换原理</h2><p> 在上小节中贴出的小段代码中，除了构建 delegate 对象用于执行上报外；另一个关键就是 SOFATracer 的 Span 模型转换成 Zipkin Span 模型。SOFATracer 从 2.2.0 版本之后支持 Zipkin v2 的模型 ，对于 Zipkin v1 的模型不在提供支持。</p><h4 id="Zipkin-v2的模型"><a href="#Zipkin-v2的模型" class="headerlink" title="Zipkin v2的模型"></a>Zipkin v2的模型</h4><p> 下面是 zipkin GitHub 上提供的 Zipkin v2 的模型的结构化数据 Demo。<a href="https://github.com/openzipkin/zipkin/issues/1499" target="_blank" rel="noopener">关于 Zipkin 的 Span 模型支持可以查看 Simplified span2 format #1499</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"kind"</span>: <span class="string">"CLIENT"</span>,</span><br><span class="line">  <span class="string">"traceId"</span>: <span class="string">"5af7183fb1d4cf5f"</span>,</span><br><span class="line">  <span class="string">"parentId"</span>: <span class="string">"6b221d5bc9e6496c"</span>,</span><br><span class="line">  <span class="string">"id"</span>: <span class="string">"352bff9a74ca9ad2"</span>,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"query"</span>,</span><br><span class="line">  <span class="string">"timestamp"</span>: <span class="number">1461750040359000</span>,</span><br><span class="line">  <span class="string">"duration"</span>: <span class="number">5000</span>,</span><br><span class="line">  <span class="string">"localEndpoint"</span>: &#123;</span><br><span class="line">    <span class="string">"serviceName"</span>: <span class="string">"zipkin-server"</span>,</span><br><span class="line">    <span class="string">"ipv4"</span>: <span class="string">"172.19.0.3"</span>,</span><br><span class="line">    <span class="string">"port"</span>: <span class="number">9411</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"remoteEndpoint"</span>: &#123;</span><br><span class="line">    <span class="string">"serviceName"</span>: <span class="string">"mysql"</span>,</span><br><span class="line">    <span class="string">"ipv4"</span>: <span class="string">"172.19.0.2"</span>,</span><br><span class="line">    <span class="string">"port"</span>: <span class="number">3306</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"tags"</span>: &#123;</span><br><span class="line">    <span class="string">"jdbc.query"</span>: <span class="string">"//....discard"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Zipkin v2 的模型结构较为简洁，整体看起来并没有什么繁重，这种对于使用者来说是很友好的，方便理解。其实在Zipkin v1 模型时，其整个模型也是比较复杂的，zipkin 社区对于 Zipkin 数据模型的变更也有讨论，见 <a href="https://github.com/openzipkin/zipkin/issues/939" target="_blank" rel="noopener">Zipkin v2 span model #939</a> ；像现在 v2 模型中的 tags，替换了原本 v1 中的 binaryAnnotations，binaryAnnotations 的存在是 v1 模型复杂的重要原因。详见 <a href="https://github.com/openzipkin/zipkin/releases/tag/2.10.1" target="_blank" rel="noopener">去除原因</a>。</p><h4 id="SofaTracerSpan-模型"><a href="#SofaTracerSpan-模型" class="headerlink" title="SofaTracerSpan 模型"></a>SofaTracerSpan 模型</h4><p>SofaTracerSpan 是基于 Opentracing 标准来的。但是 Opentracing 标准并没有规定一个 Span 模型必须有哪些属性。所以各个基于该标准的产品在于 Span 的模型上是不统一的，大多会基于其本身产生的场景带有一些特殊的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"client"</span>:<span class="keyword">true</span>,</span><br><span class="line">    <span class="string">"server"</span>:<span class="keyword">false</span>,</span><br><span class="line">    <span class="string">"durationMicroseconds"</span>:<span class="number">775</span>,</span><br><span class="line">    <span class="string">"endTime"</span>:<span class="number">1536288243446</span>,</span><br><span class="line">    <span class="string">"logType"</span>:<span class="string">"httpclient-digest.log"</span>,</span><br><span class="line">    <span class="string">"operationName"</span>:<span class="string">"GET"</span>,</span><br><span class="line">    <span class="string">"logs"</span>:[</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">    ], </span><br><span class="line">    <span class="string">"sofaTracer"</span>:&#123;</span><br><span class="line">        <span class="string">"clientReporter"</span>:&#123;&#125;,</span><br><span class="line">        <span class="string">"tracerTags"</span>:&#123;&#125;,</span><br><span class="line">        <span class="string">"tracerType"</span>:<span class="string">"httpclient"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"sofaTracerSpanContext"</span>:&#123;</span><br><span class="line">        <span class="comment">// sofaTracerSpanContext info</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"spanReferences"</span>:[],</span><br><span class="line">    <span class="string">"startTime"</span>:<span class="number">1536288242671</span>,</span><br><span class="line">    <span class="string">"tagsWithBool"</span>:&#123;&#125;,</span><br><span class="line">    <span class="string">"tagsWithNumber"</span>:&#123;&#125;,</span><br><span class="line">    <span class="string">"tagsWithStr"</span>:&#123;&#125;,</span><br><span class="line">    <span class="string">"thisAsParentWhenExceedLayer"</span>:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SOFATracer 的 Span 模型相较于 Opentracing 规范模型和 Zipkin v2 的模型来说，记录的数据信息更加丰富，且在 Opentracing 规范的基础上扩展了一套自己的 API，可以让使用者能够更加方便的在自己的代码中来获取链路中的信息；在日志中展示更多的 span 信息，能够帮助我们去了解一些调用细节，在发生问题时，也提供了更多排查问题的依据信息。</p><h4 id="模型转换对照"><a href="#模型转换对照" class="headerlink" title="模型转换对照"></a>模型转换对照</h4><p>为了使得 SOFATracer 的数据能够被 zipkin 解析，需要将 SOFATracer 的 Span 模型转换成 zipkin v2 的数据模型。</p><table><thead><tr><th><strong>Zipkin v2 Span Model</strong></th><th><strong>SOFATracer Span Model</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>traceId</td><td>traceId</td><td>traceId</td></tr><tr><td>id</td><td>spanId</td><td>spanId</td></tr><tr><td>parentId</td><td>parentId</td><td>父spanId</td></tr><tr><td>name</td><td>operationName</td><td>span 名，用来描述当前span 的行为</td></tr><tr><td>duration</td><td>-</td><td>当前span的时间跨度;这里通过span的（结束时间-开始时间）获取</td></tr><tr><td>timestamp</td><td>timestamp</td><td>当前span的开始时间</td></tr><tr><td>localEndPoint</td><td>operationName&amp;host&amp;logData</td><td>标明这个span的来源</td></tr><tr><td>remoteEndPoint</td><td>-</td><td>被调用方的服务名和地址</td></tr><tr><td>tags</td><td>bizBaggage &amp; tags</td><td>额外的用于描述span的信息</td></tr></tbody></table><p>整体来看，Span 模型相似度是很高，但是实际上并不能直接将某些相同的字段直接进行值复制；这里有一个 案例：<a href="https://github.com/alipay/sofa-tracer/issues/57" target="_blank" rel="noopener">ISSUE#57</a> 。 </p><h4 id="traceId-和-spanId-处理"><a href="#traceId-和-spanId-处理" class="headerlink" title="traceId 和 spanId 处理"></a>traceId 和 spanId 处理</h4><p>zipkin 在自己的模型里做了很多特殊的处理。比如 traceId 需满足16 或者 32 位，长度不够的会高位补 0；所以在使用 SOFATracer 时，日志中的 traceId 和上报到 zipkin 的 traceId 长度不一致是合理的。</p><p>关于 spanId，我们期望在 zipkin 中展示是以（0.1,0.1.1,…）这种形式来描述，能够直观的看到 span 之间的依赖关系。但是目前使用的 zipkin 模型并不能满足我们的需求，主要原因在于虽然 zipkin 在 v2 模型中虽然支持 string 类型的 id ，但是其长度限制是16位，对于 SOFATracer 来说，如果存在较长的链路调用，会导致层次丢失。另外，如果上报 zipkin 的 span 的 parentId 为 0，那么 zipkin 将会不进行设置；而 SOFATracer 的第一个 span 的 id 就是从 0 开始的，所以会导致链路构建失败，如果我们尝试通过改变起始 id 来改变，会对整个模型产生影响。经过验证测试，我们最终采用的方案是使用冲突较小的 FNV64 Hash 算法将 String 类型转换成 long 型来描述我们的 spanId。</p><h4 id="SOFARPC-上报的数据处理"><a href="#SOFARPC-上报的数据处理" class="headerlink" title="SOFARPC 上报的数据处理"></a>SOFARPC 上报的数据处理</h4><p>在整个模型转换中，比较核心的就是如何兼容 SOFARPC 上报的数据。Zipkin 在构建链路数时，其基本的模型是 <code>client-server-client-server-..</code> 这种模式；不会出现 a server calling a server 这种情况，也就是带有kind = server 的 span 的 父span 应该是 kind = client。</p><p>SOFARPC 对于一个 rpc span 上报了两个 span 信息，这两个 span 除了 kind 类型不同之外，其他的信息是一样的。当数据上报给 zipkin 之后，zipkin 通过自己的算法来构建依赖树时，会对上报的 SOFARPC 数据处理有问题。下图是没有适配 SOFARPC 生成的链路: </p><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1536291774102-2ab76b17-f550-45b0-9d21-c3193f195e67.png" alt="img"></p><p>这里可以看出，从 mvc 到 rpc 之间的关系被‘切断’了。 </p><p>造成上述问题的原因在于，SOFATracer 上报数据到 zipkin 时，在 v2 模型中，zipkin 会通过广度优先遍历来构建依赖树，实际上在展示 services 或者 dependencies 时，zipkin ui 中的展示会依赖 endpiont 中的 serviceName ；两个条件：</p><ul><li>SOFARPC 的 span 有两个（client&amp;server），但是这两个 span 具有相同的 spanId 和 parentId，span.kind 不同。</li><li>zipkin 在构建依赖树时，依赖于 endpiont 中的 serviceName。该 servieName 依赖于 idToNode（Node.TreeBuilder 中的属性，Map 结构，映射关系为 spanId -&gt; span）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;V&gt; previous = idToNode.put(id, node);</span><br><span class="line"><span class="keyword">if</span> (previous != <span class="keyword">null</span>) </span><br><span class="line">node.setValue(mergeFunction.merge(previous.value, node.value));</span><br></pre></td></tr></table></figure><p>这里当前 node 为 rpc server 类型时，previous 返回结果不为 null，会执行 merge 操作，该 merge 操作的核心就是设置当前 rpc node 的 remoteEndpoint，值为 rpc client 的 localEndpoint。</p><p> 这样会有一个问题，就是 RPC 的 client 和 server Span 在 Zipkin 模型中的会被合并成一个 span；这样就会导致 server -&gt; server 的情况，与 zipkin 的 client -&gt; server 链路模型有冲突。如下图（绿色为SOFATracer span，黄色为 zipkin span）： </p><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1537974797330-7db6f317-7b42-4758-819d-ae106cb22b84.png" alt="img"></p><p> 通过分析 zipkin 的构建过程，适配 SOFARPC 上报数据时，SOFARPC server span 的 remoteEndpoint 不能依赖 SOFARPC client span 的 localEndpoint，而应该依赖 SOFARPC client parentSpan 的 localEndpoint。下图为 SOFARPC 适配之后的依赖关系图：</p><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1536298481412-5b52aedc-86f1-4dec-bae1-164dbd72e1d5.png" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 本文从 OpenTracing 规范说起，对 OpenTracing 规范中的模型和行为进行了简单的描述。结合 OpenTracing 规范，介绍了蚂蚁金服 SOFATracer 分布式链路跟踪的模型实现。在此基础上，对 SOFATracer 的数据上报功能进行了详细的分析，包括基于 disruptor 实现的异步日志落盘和上报数据到zipkin；最后对 SOFATracer 和  Zipkin 模型转换原理进行了说明，并对 SOFARPC 模型数据的上报处理进行了解析。</p><h2 id="相关文档链接"><a href="#相关文档链接" class="headerlink" title="相关文档链接"></a>相关文档链接</h2><ul><li><a href="https://github.com/alipay/sofa-tracer" target="_blank" rel="noopener">SOFATracer GitHub</a></li><li><a href="https://zipkin.io/" target="_blank" rel="noopener">Zipkin 官网</a></li><li><a href="https://github.com/openzipkin/zipkin" target="_blank" rel="noopener">Zipkin GitHub</a></li><li><a href="http://opentracing.io/documentation/pages/spec.html" target="_blank" rel="noopener">opentracing 规范</a></li><li><a href="http://opentracing.io/" target="_blank" rel="noopener">opentracing 官网</a></li><li><a href="https://github.com/LMAX-Exchange/disruptor" target="_blank" rel="noopener">disruptor</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> SOFA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链路跟踪 </tag>
            
            <tag> OpenTracing </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>看完这个不会配置 logback ，请你吃瓜！</title>
      <link href="/2018/11/10/logone/"/>
      <url>/2018/11/10/logone/</url>
      
        <content type="html"><![CDATA[<p>之前在 <a href="https://juejin.im/post/5ad1ccc86fb9a028c14ae528" target="_blank" rel="noopener">日志？聊一聊slf4j吧</a> 这篇文章中聊了下<code>slf4j</code>。本文也从实际的例子出发，针对<code>logback</code>的日志配置进行学习。</p><h1 id="logack-简介"><a href="#logack-简介" class="headerlink" title="logack 简介"></a>logack 简介</h1><blockquote><p>logback 官网：<a href="https://logback.qos.ch/" target="_blank" rel="noopener">https://logback.qos.ch/</a></p></blockquote><p>目前还没有看过日志类框架的源码，仅限于如何使用。所以就不说那些“空话”了。最直观的认知是：</p><ul><li><code>logback</code>和<code>log4j</code>是一个人写的</li><li><code>springboot</code>默认使用的日志框架是<code>logback</code>。</li><li>三个模块组成<ul><li>logback-core</li><li>logback-classic</li><li>logback-access</li></ul></li><li>其他的关于性能，关于内存占用，关于测试，关于文档详见源码及官网说明</li></ul><p><code>logback-core</code> 是其它模块的基础设施，其它模块基于它构建，显然，<code>logback-core</code> 提供了一些关键的通用机制。<code>logback-classic</code> 的地位和作用等同于 <code>Log4J</code>，它也被认为是 <code>Log4J</code> 的一个改进版，并且它实现了简单日志门面 <code>SLF4J</code>；而 <code>logback-access</code> 主要作为一个与 <code>Servlet</code> 容器交互的模块，比如说<code>tomcat</code>或者 <code>jetty</code>，提供一些与 <code>HTTP</code> 访问相关的功能。</p><h1 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h1><p>这部分主要来学习下logback配置文件的一些配置项。</p><h2 id="configuration"><a href="#configuration" class="headerlink" title="configuration"></a>configuration</h2><p>先来看这张图，这个结构就是整个logback.xml配置文件的结构。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/20/164b84acd40e3590?w=297&amp;h=143&amp;f=png&amp;s=2950" alt=""><br>对应来看下配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">"true"</span> <span class="attr">scanPeriod</span>=<span class="string">"60 seconds"</span> <span class="attr">debug</span>=<span class="string">"false"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"glmapper-name"</span> <span class="attr">value</span>=<span class="string">"glmapper-demo"</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>$&#123;glmapper-name&#125;<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span>&gt;</span></span><br><span class="line">        //xxxx</span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span>&gt;</span></span><br><span class="line">        //xxxx</span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span>             </span><br><span class="line">       //xxxx</span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>ps：想使用spring扩展profile支持，要以logback-spring.xml命名，其他如property需要改为springProperty</p></blockquote><ul><li>scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。</li><li>scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。</li><li>debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。</li></ul><h3 id="contextName"><a href="#contextName" class="headerlink" title="contextName"></a>contextName</h3><p>每个<code>logger</code>都关联到<code>logger</code>上下文，默认上下文名称为<code>“default”</code>。但可以使用<code>contextName</code>标签设置成其他名字，用于区分不同应用程序的记录</p><h3 id="property"><a href="#property" class="headerlink" title="property"></a>property</h3><p>用来定义变量值的标签，<code>property</code>标签有两个属性，<code>name</code>和<code>value</code>；其中<code>name</code>的值是变量的名称，<code>value</code>的值时变量定义的值。通过<code>property</code>定义的值会被插入到<code>logger</code>上下文中。定义变量后，可以使“${name}”来使用变量。如上面的<code>xml</code>所示。</p><h3 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h3><p>用来设置某一个包或者具体的某一个类的日志打印级别以及指定<code>appender</code>。</p><h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><p>根logger，也是一种logger，且只有一个level属性</p><h3 id="appender"><a href="#appender" class="headerlink" title="appender"></a>appender</h3><p>负责写日志的组件，下面会细说</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter其实是appender里面的子元素。它作为过滤器存在，执行一个过滤器会有返回DENY，NEUTRAL，ACCEPT三个枚举值中的一个。</p><ul><li>DENY：日志将立即被抛弃不再经过其他过滤器</li><li>NEUTRAL：有序列表里的下个过滤器过接着处理日志</li><li>ACCEPT：日志会被立即处理，不再经过剩余过滤器</li></ul><h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><p>首先来配置一个非常简单的文件。这里申请下，我使用的是 <code>logback-spring.xml</code>。和 <code>logback.xml</code> 在<code>properties</code>上有略微差别。其他都一样。</p><blockquote><p>工程：springboot+web</p></blockquote><p>先来看下项目目录</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/21/164b8ba7a44783aa?w=872&amp;h=954&amp;f=png&amp;s=117022" alt=""></p><p>properties中就是指定了日志的打印级别和日志的输出位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#设置应用的日志级别</span><br><span class="line">logging.level.com.glmapper.spring.boot=INFO</span><br><span class="line">#路径</span><br><span class="line">logging.path=./logs</span><br></pre></td></tr></table></figure><h2 id="通过控制台输出的log"><a href="#通过控制台输出的log" class="headerlink" title="通过控制台输出的log"></a>通过控制台输出的log</h2><h3 id="logback-spring-xml的配置如下："><a href="#logback-spring-xml的配置如下：" class="headerlink" title="logback-spring.xml的配置如下："></a>logback-spring.xml的配置如下：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 默认的控制台日志输出，一般生产环境都是后台启动，这个没太大作用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; %-5level %logger&#123;80&#125; - %msg%n<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="打印日志的controller"><a href="#打印日志的controller" class="headerlink" title="打印日志的controller"></a>打印日志的controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER =</span><br><span class="line">LoggerFactory.getLogger(HelloController.class);</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TestLogService testLogService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"GLMAPPER-SERVICE:info"</span>);</span><br><span class="line">    LOGGER.error(<span class="string">"GLMAPPER-SERVICE:error"</span>);</span><br><span class="line">    testLogService.printLogToSpecialPackage();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello spring boot"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证结果："><a href="#验证结果：" class="headerlink" title="验证结果："></a>验证结果：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">01:50:39.633 INFO  com.glmapper.spring.boot.controller.HelloController</span><br><span class="line">- GLMAPPER-SERVICE:info</span><br><span class="line">01:50:39.633 ERROR com.glmapper.spring.boot.controller.HelloController</span><br><span class="line">- GLMAPPER-SERVICE:error</span><br></pre></td></tr></table></figure><p>上面的就是通过控制台打印出来的，这个时候因为我们没有指定日志文件的输出，因为不会在工程目录下生产<code>logs</code>文件夹。</p><h2 id="控制台不打印，直接输出到日志文件"><a href="#控制台不打印，直接输出到日志文件" class="headerlink" title="控制台不打印，直接输出到日志文件"></a>控制台不打印，直接输出到日志文件</h2><p>先来看下配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 属性文件:在properties文件中找到对应的配置项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">"context"</span> <span class="attr">name</span>=<span class="string">"logging.path"</span>  <span class="attr">source</span>=<span class="string">"logging.path"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">"context"</span> <span class="attr">name</span>=<span class="string">"logging.level"</span> <span class="attr">source</span>=<span class="string">"logging.level.com.glmapper.spring.boot"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 默认的控制台日志输出，一般生产环境都是后台启动，这个没太大作用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; %-5level %logger&#123;80&#125; - %msg%n<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"GLMAPPER-LOGGERONE"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>$&#123;logging.level&#125;<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">            $&#123;logging.path&#125;/glmapper-spring-boot/glmapper-loggerone.log</span><br><span class="line">        <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;logging.path&#125;/glmapper-spring-boot/glmapper-loggerone.log.%d&#123;yyyy-MM-dd&#125;<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"GLMAPPER-LOGGERONE"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里我们<code>appender-ref</code>指定的<code>appender</code>是<code>GLMAPPER-LOGGERONE</code>，因为之前没有名字为<code>GLMAPPER-LOGGERONE</code>的<code>appender</code>，所以要增加一个<code>name</code>为<code>GLMAPPER-LOGGERONE</code>的<code>appender</code>。</p><p>注意上面这个配置，我们是直接接将<code>root</code>的<code>appender-ref</code>直接指定到我们的<code>GLMAPPER-LOGGERONE</code>这个appender的。所以控制台中将只会打印出bannar之后就啥也不打印了，所有的启动信息都会被打印在日志文件<code>glmapper-loggerone.log</code>中。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/21/164b8d8b5f22d274?w=1720&amp;h=532&amp;f=png&amp;s=78996" alt=""></p><p>但是实际上我们不希望我的业务日志中会包括这些启动信息。所以这个时候我们就需要通过<code>logger</code>标签来搞事情了。将上面的配置文件进行简单修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.glmapper.spring.boot.controller"</span> <span class="attr">level</span>=<span class="string">"$&#123;logging.level&#125;"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"GLMAPPER-LOGGERONE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"$&#123;logging.level&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><p>让<code>root</code>指向控制台输出；<code>logger</code>负责打印包<code>com.glmapper.spring.boot.controller</code>下的日志。</p><h3 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h3><p>还是通过我们的测试controller来打印日志为例，但是这里不会在控制台出现日志信息了。期望的日志文件在<code>./logs/glmapper-spring-boot/glmapper-loggerone.log</code>。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/21/164b8df30b286089?w=2492&amp;h=318&amp;f=png&amp;s=98075" alt=""></p><h2 id="logger和appender的关系"><a href="#logger和appender的关系" class="headerlink" title="logger和appender的关系"></a>logger和appender的关系</h2><p>上面两种是一个基本的配置方式，通过上面两个案例，我们先来了解下<code>logger/appender/root</code>之间的关系，然后再详细的说下<code>logger</code>和<code>appender</code>的配置细节。</p><p>在最前面介绍中提到，<code>root</code>是根<code>logger</code>,所以他两是一回事；只不过<code>root</code>中不能有<code>name</code>和<code>additivity</code>属性，是有一个<code>level</code>。</p><p><code>appender</code>是一个日志打印的组件，这里组件里面定义了打印过滤的条件、打印输出方式、滚动策略、编码方式、打印格式等等。但是它仅仅是一个打印组件，如果我们不使用一个<code>logger</code>或者<code>root</code>的<code>appender-ref</code>指定某个具体的<code>appender</code>时，它就没有什么意义。</p><p>因此<code>appender</code>让我们的应用知道怎么打、打印到哪里、打印成什么样；而<code>logger</code>则是告诉应用哪些可以这么打。例如某个类下的日志可以使用这个<code>appender</code>打印或者某个包下的日志可以这么打印。</p><h2 id="appender-配置详解"><a href="#appender-配置详解" class="headerlink" title="appender 配置详解"></a>appender 配置详解</h2><p>这里以上面案例中的名为<code>GLMAPPER-LOGGERONE</code>的<code>appender</code>说明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"GLMAPPER-LOGGERONE"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span>&gt;</span>$&#123;logging.level&#125;<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">        $&#123;logging.path&#125;/glmapper-spring-boot/glmapper-loggerone.log</span><br><span class="line">    <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;logging.path&#125;/glmapper-spring-boot/glmapper-loggerone.log.%d&#123;yyyy-MM-dd&#125;<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>appender</code> 有两个属性 <code>name</code>和<code>class</code>;<code>name</code>指定<code>appender</code>名称，<code>class</code>指定<code>appender</code>的全限定名。上面声明的是名为<code>GLMAPPER-LOGGERONE</code>，<code>class</code>为<code>ch.qos.logback.core.rolling.RollingFileAppender</code>的一个<code>appender</code>。</p><h3 id="appender-的种类"><a href="#appender-的种类" class="headerlink" title="appender 的种类"></a>appender 的种类</h3><ul><li>ConsoleAppender：把日志添加到控制台</li><li>FileAppender：把日志添加到文件</li><li>RollingFileAppender：滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件。它是FileAppender的子类</li></ul><h3 id="append-子标签"><a href="#append-子标签" class="headerlink" title="append 子标签"></a>append 子标签</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果是 <code>true</code>，日志被追加到文件结尾，如果是<code>false</code>，清空现存文件，默认是<code>true</code>。</p><h3 id="filter-子标签"><a href="#filter-子标签" class="headerlink" title="filter 子标签"></a>filter 子标签</h3><p>在简介中提到了<code>filter</code>；作用就是上面说的。可以为<code>appender</code> 添加一个或多个过滤器，可以用任意条件对日志进行过滤。<code>appender</code> 有多个过滤器时，按照配置顺序执行。</p><h4 id="ThresholdFilter"><a href="#ThresholdFilter" class="headerlink" title="ThresholdFilter"></a>ThresholdFilter</h4><p>临界值过滤器，过滤掉低于指定临界值的日志。当日志级别等于或高于临界值时，过滤器返回<code>NEUTRAL</code>；当日志级别低于临界值时，日志会被拒绝。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="LevelFilter"><a href="#LevelFilter" class="headerlink" title="LevelFilter"></a>LevelFilter</h4><p>级别过滤器，根据日志级别进行过滤。如果日志级别等于配置级别，过滤器会根据<code>onMath</code>(用于配置符合过滤条件的操作) 和 <code>onMismatch</code>(用于配置不符合过滤条件的操作)接收或拒绝日志。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于<code>NEUTRAL</code>、<code>ACCEPT</code>、<code>DENY</code> 见上文简介中关于<code>filter</code>的介绍。</p><h3 id="file-子标签"><a href="#file-子标签" class="headerlink" title="file 子标签"></a>file 子标签</h3><p><code>file</code> 标签用于指定被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">    $&#123;logging.path&#125;/glmapper-spring-boot/glmapper-loggerone.log</span><br><span class="line"><span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个表示当前appender将会将日志写入到<code>${logging.path}/glmapper-spring-boot/glmapper-loggerone.log</code>这个目录下。</p><h3 id="rollingPolicy-子标签"><a href="#rollingPolicy-子标签" class="headerlink" title="rollingPolicy 子标签"></a>rollingPolicy 子标签</h3><p>这个子标签用来描述滚动策略的。这个只有<code>appender</code>的<code>class</code>是<code>RollingFileAppender</code>时才需要配置。这个也会涉及文件的移动和重命名（a.log-&gt;a.log.2018.07.22）。</p><h4 id="TimeBasedRollingPolicy"><a href="#TimeBasedRollingPolicy" class="headerlink" title="TimeBasedRollingPolicy"></a>TimeBasedRollingPolicy</h4><p>最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。这个下面又包括了两个属性：</p><ul><li>FileNamePattern</li><li>maxHistory</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rollingPolicy</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志文件输出的文件名:按天回滚 daily --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">        $&#123;logging.path&#125;/glmapper-spring-boot/glmapper-loggerone.log.%d&#123;yyyy-MM-dd&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志文件保留天数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的这段配置表明<strong>每天生成一个日志文件，保存30天的日志文件</strong></p><h4 id="FixedWindowRollingPolicy"><a href="#FixedWindowRollingPolicy" class="headerlink" title="FixedWindowRollingPolicy"></a>FixedWindowRollingPolicy</h4><p>根据固定窗口算法重命名文件的滚动策略。</p><h3 id="encoder-子标签"><a href="#encoder-子标签" class="headerlink" title="encoder 子标签"></a>encoder 子标签</h3><p>对记录事件进行格式化。它干了两件事：</p><ul><li>把日志信息转换成字节数组</li><li>把字节数组写入到输出流</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;</span><br><span class="line">    &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125;</span><br><span class="line">    - %msg%n&lt;/pattern&gt;</span><br><span class="line">    &lt;charset&gt;UTF-8&lt;/charset&gt;</span><br><span class="line">&lt;/encoder&gt;</span><br></pre></td></tr></table></figure><p>目前<code>encoder</code>只有<code>PatternLayoutEncoder</code>一种类型。</p><h3 id="定义一个只打印error级别日志的appcener"><a href="#定义一个只打印error级别日志的appcener" class="headerlink" title="定义一个只打印error级别日志的appcener"></a>定义一个只打印error级别日志的appcener</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 错误日志 appender ： 按照每天生成日志文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"ERROR-APPENDER"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 过滤器，只记录 error 级别的日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span>&gt;</span>error<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;logging.path&#125;/glmapper-spring-boot/glmapper-error.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 每天生成一个日志文件，保存30天的日志文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件输出的文件名:按天回滚 daily --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;logging.path&#125;/glmapper-spring-boot/glmapper-error.log.%d&#123;yyyy-MM-dd&#125;<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件保留天数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 编码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="定义一个输出到控制台的appender"><a href="#定义一个输出到控制台的appender" class="headerlink" title="定义一个输出到控制台的appender"></a>定义一个输出到控制台的appender</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 默认的控制台日志输出，一般生产环境都是后台启动，这个没太大作用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; %-5level %logger&#123;80&#125; - %msg%n<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="logger-配置详解"><a href="#logger-配置详解" class="headerlink" title="logger 配置详解"></a>logger 配置详解</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.glmapper.spring.boot.controller"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">level</span>=<span class="string">"$&#123;logging.level&#125;"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"GLMAPPER-LOGGERONE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的这个配置文件描述的是：<code>com.glmapper.spring.boot.controller</code>这个包下的<code>${logging.level}</code>级别的日志将会使用<code>GLMAPPER-LOGGERONE</code>来打印。<code>logger</code>有三个属性和一个子标签：</p><ul><li>name:用来指定受此<code>logger</code>约束的某一个包或者具体的某一个类。</li><li>level:用来设置打印级别（<code>TRACE</code>, <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code>, <code>ERROR</code>, <code>ALL</code> 和 <code>OFF</code>），还有一个值<code>INHERITED</code>或者同义词<code>NULL</code>，代表强制执行上级的级别。如果没有设置此属性，那么当前<code>logger</code>将会继承上级的级别。</li><li>addtivity:用来描述是否向上级<code>logger</code>传递打印信息。默认是<code>true</code>。</li></ul><p><code>appender-ref</code>则是用来指定具体<code>appender</code>的。</p><h2 id="不同日志隔离打印案例"><a href="#不同日志隔离打印案例" class="headerlink" title="不同日志隔离打印案例"></a>不同日志隔离打印案例</h2><p>在前面的例子中我们有三种appender,一个是指定包约束的，一个是控制error级别的，一个是控制台的。然后这小节我们就来实现下不同日志打印到不同的log文件中。</p><h3 id="根据包进行日志文件隔离"><a href="#根据包进行日志文件隔离" class="headerlink" title="根据包进行日志文件隔离"></a>根据包进行日志文件隔离</h3><p>这个例子里我们将<code>com.glmapper.spring.boot.controller</code>中的日志输出到<code>glmapper-controller.log</code>；将<code>com.glmapper.spring.boot.service</code>中的日志输出到<code>glmapper-service.log</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--打印日志到glmapper-service.log的appender--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"GLMAPPER-SERVICE"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span>&gt;</span>$&#123;logging.level&#125;<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">        $&#123;logging.path&#125;/glmapper-spring-boot/glmapper-service.log</span><br><span class="line">    <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;logging.path&#125;/glmapper-spring-boot/glmapper-service.log.%d&#123;yyyy-MM-dd&#125;<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--打印日志到glmapper-controller.log的appender--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"GLMAPPER-CONTROLLER"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span>&gt;</span>$&#123;logging.level&#125;<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">        $&#123;logging.path&#125;/glmapper-spring-boot/glmapper-controller.log</span><br><span class="line">    <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;logging.path&#125;/glmapper-spring-boot/glmapper-controller.log.%d&#123;yyyy-MM-dd&#125;<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--此logger约束将.controller包下的日志输出到GLMAPPER-CONTROLLER，错误日志输出到GERROR-APPENDE；GERROR-APPENDE见上面--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.glmapper.spring.boot.controller"</span> <span class="attr">level</span>=<span class="string">"$&#123;logging.level&#125;"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"GLMAPPER-CONTROLLER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"GERROR-APPENDER"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--此logger约束将.service包下的日志输出到GLMAPPER-SERVICE，错误日志输出到GERROR-APPENDE；GERROR-APPENDE见上面--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.glmapper.spring.boot.service"</span> <span class="attr">level</span>=<span class="string">"$&#123;logging.level&#125;"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"GLMAPPER-SERVICE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"GERROR-APPENDER"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure><p>来看运行结果</p><p>1、glmaper-controller</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/21/164bac0d699c0ca9?w=2498&amp;h=316&amp;f=png&amp;s=104302" alt=""></p><p>2、glmapper-service</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/21/164bac127270addf?w=2722&amp;h=318&amp;f=png&amp;s=105643" alt=""></p><p>3、glmapper-error</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/21/164bac1698f84f29?w=2746&amp;h=314&amp;f=png&amp;s=106457" alt=""></p><p>满足我们的预期，但是这里有个小问题。在<code>info</code>日志里出现了<code>error</code>,当然这是正常的。假如我们不想在<code>info</code>里面出现<code>error</code>怎么办呢？很简单，我们以<code>APPENDER-SERVICE</code>为例，将<code>filter</code>过滤器进行修改：</p><p>将下面的：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">level</span>&gt;</span>$&#123;logging.level&#125;<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>修改为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果命中就禁止这条日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 如果没有命中就使用这条规则 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里同时要注意的是，在<code>logger</code>中<code>level</code>需要设置为<code>info</code>级别。</p><h3 id="根据类进行日志文件隔离"><a href="#根据类进行日志文件隔离" class="headerlink" title="根据类进行日志文件隔离"></a>根据类进行日志文件隔离</h3><p>这个其实也是和上面那个差不过，只不过粒度更细一点，一般情况下比如说我们有个定时任务类需要单独来记录其日志信息，这样我们就可以考虑使用基于类维度来约束打印。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--特殊功能单独appender 例如调度类的日志--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"SCHEDULERTASKLOCK-APPENDER"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span>&gt;</span>$&#123;logging.level&#125;<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;logging.path&#125;/glmapper-spring-boot/scheduler-task-lock.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 每天生成一个日志文件，保存30天的日志文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件输出的文件名:按天回滚 daily --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;logging.path&#125;/glmapper-spring-boot/scheduler-task-lock.log.%d&#123;yyyy-MM-dd&#125;<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件保留天数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 编码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--这里指定到了具体的某一个类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.glmapper.spring.boot.task.TestLogTask"</span> <span class="attr">level</span>=<span class="string">"$&#123;logging.level&#125;"</span> <span class="attr">additivity</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"SCHEDULERTASKLOCK-APPENDER"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"ERROR-APPENDER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终<code>TestLogTask</code>中的日志将会被打印到这个自己独立的log文件中。如下所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/21/164bad7d9e4dd631?w=2494&amp;h=770&amp;f=png&amp;s=504199" alt=""></p><h3 id="根据自定义-logger-的-name-进行日志文件隔离"><a href="#根据自定义-logger-的-name-进行日志文件隔离" class="headerlink" title="根据自定义 logger 的 name 进行日志文件隔离"></a>根据自定义 logger 的 name 进行日志文件隔离</h3><p><code>logger</code>的<code>name</code>除了类、包等约束之外，当然还可以这样来玩。。。</p><p>在进行案例之前，这里先把前面案例中<code>logger</code>声明的代码贴一下，以作对比,以<code>TestLogTask</code>类中的日志为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER =</span><br><span class="line">LoggerFactory.getLogger(TestLogTask.class);</span><br></pre></td></tr></table></figure><p>在<code>getLogger</code>中我们是将当前对象的<code>class</code>作为参数的，这个是为了打印时获取其全限定名的（见下面3-）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1-2018-07-21 11:15:42.003 [pool-1-thread-1] </span><br><span class="line">2-INFO  </span><br><span class="line">3-com.glmapper.spring.boot.task.TestLogTask -</span><br><span class="line">4-com.glmapper.spring.boot.task:info</span><br></pre></td></tr></table></figure><h4 id="业务类定义"><a href="#业务类定义" class="headerlink" title="业务类定义"></a>业务类定义</h4><p>我们同样是<code>service</code>包下定义一个类<code>TestLogNameServiceImpl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.spring.boot.service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"testLogNameService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLogNameServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestLogNameService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER =</span><br><span class="line">    LoggerFactory.getLogger(<span class="string">"GLMAPPER-TEST-LOG"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"GLMAPPER-TEST-LOG:this is special logger-----info"</span>);</span><br><span class="line">        LOGGER.error(<span class="string">"GLMAPPER-TEST-LOG:this is special logger-------error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="appender和logger配置"><a href="#appender和logger配置" class="headerlink" title="appender和logger配置"></a>appender和logger配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"ROOT-APPENDER"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span>&gt;</span>$&#123;logging.level&#125;<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;logging.path&#125;/glmapper-spring-boot/glmapper-test.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 每天生成一个日志文件，保存30天的日志文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件输出的文件名:按天回滚 daily --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;logging.path&#125;/glmapper-spring-boot/glmapper-test.log.%d&#123;yyyy-MM-dd&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件保留天数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 编码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--这里的name和业务类中的getLogger中的字符串是一样的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"GLMAPPER-TEST-LOG"</span> <span class="attr">level</span>=<span class="string">"$&#123;logging.level&#125;"</span> <span class="attr">additivity</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"ROOT-APPENDER"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"ERROR-APPENDER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们这个预期的是<code>TestLogNameServiceImpl</code>中的日志不打印到<code>glmapper-service.log</code>中，而是打印到<code>glmapper-test.log</code>中。</p><p>1、glmapper-test.log</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/21/164bae82de2d1d6c?w=2456&amp;h=386&amp;f=png&amp;s=112207" alt=""></p><p>2、glmapper-service.log</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/21/164bae86cb0f9c04?w=2692&amp;h=398&amp;f=png&amp;s=101896" alt=""></p><p>满足我们的预期。</p><h2 id="如何使用logback打印mybatis的sql语句"><a href="#如何使用logback打印mybatis的sql语句" class="headerlink" title="如何使用logback打印mybatis的sql语句"></a>如何使用logback打印mybatis的sql语句</h2><p>这个还是比较坑的。为什么。看下这个：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"slf4j"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>mybatis-configration.xml</code>中，我们通过这样一个配置项来关联到具体的日志组件。但是<code>logImpl</code>的实现中是没有<code>logback</code>的。那么怎么办呢？这里只能通过<code>slf4j</code>的方式桥接到<code>logback</code>。</p><p>然后在我们的logback-spring.xml中进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 将sql语句输出到具体的日志文件中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.alipay.sofa.cloudplatform.common.dao"</span> <span class="attr">level</span>=<span class="string">"$&#123;logging.sql.level&#125;"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"SQL-APPENDER"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里有几个点需要注意的。首先是<code>${logging.sql.level}</code>这个必须是debug，这个是由mybatis本身实现决定的。而这里的<code>name</code>设定的<code>com.alipay.sofa.cloudplatform.common.dao</code>值就是我们dao接口的包路径。</p><p>网上看了一个比较典型的案例，这种方式只能输出到控制台，并不能将文件输出到日志文件；它是根据内部的一个实现机制偷了个懒。<a href="https://blog.csdn.net/xiaoyu411502/article/details/51064885" target="_blank" rel="noopener">mybatis用logback日志不显示sql的解决办法</a>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇博客主要是整理最近工作中的一些日志配置积累，将每个细节进行总结一下，以作备忘。如果有时间的话会考虑看一个日志框架的源码。其实我觉得还是很有必要的，日志组件毕竟是需要进行日志文件落盘的，这个会涉及到许多的性能问题、缓冲区问题、队列问题、当然还有一些锁的问题、同步打印或者异步打印等问题。有兴趣的小伙伴可以看看，然后分享给我们。</p><p>后面准备写一写蚂蚁金服SOFABoot和SpringBoot的一些文章，如果有兴趣可以先看一波。</p><p><a href="https://github.com/alipay/sofa-boot" target="_blank" rel="noopener">SOFABoot GitHub 传送门</a></p>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logback </tag>
            
            <tag> slf4j </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SOFATracer 中 Disruptor 实践</title>
      <link href="/2018/11/10/sofatracerone/"/>
      <url>/2018/11/10/sofatracerone/</url>
      
        <content type="html"><![CDATA[<h2 id="OpenTraceing-规范"><a href="#OpenTraceing-规范" class="headerlink" title="OpenTraceing 规范"></a>OpenTraceing 规范</h2><ul><li><a href="https://github.com/opentracing-contrib/opentracing-specification-zh/blob/master/specification.md" target="_blank" rel="noopener">OpenTracing语义标准</a></li><li><a href="https://github.com/opentracing-contrib/opentracing-specification-zh/blob/master/semantic_conventions.md" target="_blank" rel="noopener">语义惯例</a></li><li><a href="http://opentracing.io/documentation/pages/spec" target="_blank" rel="noopener">官方文档</a></li></ul><h2 id="SOFATracer-对-OpenTraceing-的实现"><a href="#SOFATracer-对-OpenTraceing-的实现" class="headerlink" title="SOFATracer 对 OpenTraceing 的实现"></a>SOFATracer 对 OpenTraceing 的实现</h2><blockquote><p>SOFATracer  就是根据 OpenTracing 规范 衍生出来的分布式 链路跟 踪的解决方案。</p></blockquote><ul><li><a href="https://github.com/alipay/sofa-tracer" target="_blank" rel="noopener">GitHub SOFATrcer</a></li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>OpenTracing</code> 标准中有三个重要的相互关联的类型，分别是<code>Tracer</code>, <code>Span</code>和 <code>SpanContext</code>。</p><blockquote><p>【下面的概念说明过程中，如不做说明，所使用的案例代码均以SOFATracer中的实现为例。】</p></blockquote><h3 id="Tracer"><a href="#Tracer" class="headerlink" title="Tracer"></a>Tracer</h3><p>一个 <code>trace</code> 代表一个潜在的，分布式的，存在并行数据或并行执行轨迹（潜在的分布式、并行）的系统。一个<code>trace</code>可以认为是多个<code>span</code>的有向无环图（<code>DAG</code>）。</p><p>Tracer接口用来创建Span，以及处理如何处理Inject(serialize) 和 Extract (deserialize)，用于跨进程边界传递。</p><p><code>SOFATracer</code> 中 <code>SofaTracer</code>这个类实现了 <code>opentracing</code> 的 <code>Tracer</code> 接口，并在此规范接口上做了一些扩展。看下<code>Tracer</code> 中声明的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tracer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//启动一个新的span</span></span><br><span class="line">    <span class="function">SpanBuilder <span class="title">buildSpan</span><span class="params">(String operationName)</span></span>;</span><br><span class="line">    <span class="comment">//将SpanContext上下文Inject（注入）到carrier</span></span><br><span class="line">    &lt;C&gt; <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(SpanContext spanContext, Format&lt;C&gt; format, C carrier)</span></span>;</span><br><span class="line">    <span class="comment">//将SpanContext上下文从carrier中Extract（提取）</span></span><br><span class="line">    &lt;C&gt; <span class="function">SpanContext <span class="title">extract</span><span class="params">(Format&lt;C&gt; format, C carrier)</span></span>;   </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">SpanBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以从接口定义来看，要实现一个Tracer，必须要实现其以下的几个能力：</p><h4 id="启动一个新的span"><a href="#启动一个新的span" class="headerlink" title="启动一个新的span"></a>启动一个新的span</h4><p><code>SOFATracer</code> 实现了 <code>Tracer</code> 中 <code>buildSpan</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpanBuilder <span class="title">buildSpan</span><span class="params">(String operationName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SofaTracerSpanBuilder(operationName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>operationName</code> :操作名称，字符串类型，表示由Span完成的工作 (例如，RPC方法名称、函数名称或一个较大的计算任务中的阶段的名称)。操作名称应该用泛化的字符串形式标识出一个Span实例。</p><p>何为泛化的字符串形式，比如现在有一个操作：获取用户 ；下面有几种标识方式：</p><ul><li>1、/get</li><li>2、/get/user</li><li>3、/get/user/123</li></ul><p>方式1过于抽象，方式3过于具体。方式2是正确的操作名。</p><h4 id="将SpanContext上下文Inject（注入）到carrier"><a href="#将SpanContext上下文Inject（注入）到carrier" class="headerlink" title="将SpanContext上下文Inject（注入）到carrier"></a>将SpanContext上下文Inject（注入）到carrier</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;C&gt; <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(SpanContext spanContext, Format&lt;C&gt; format, C carrier)</span> </span>&#123;</span><br><span class="line">    RegistryExtractorInjector&lt;C&gt; registryInjector = TracerFormatRegistry.getRegistry(format);</span><br><span class="line">    <span class="keyword">if</span> (registryInjector == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported injector format: "</span> + format);</span><br><span class="line">    &#125;</span><br><span class="line">    registryInjector.inject((SofaTracerSpanContext) spanContext, carrier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>SpanContext</code> :实例</li><li><code>format</code>（格式化）描述，一般会是一个字符串常量，但不做强制要求。通过此描述，通知Tracer实现，如何对SpanContext进行编码放入到carrier中。<br>carrier，根据format确定。Tracer实现根据format声明的格式，将SpanContext序列化到carrier对象中。</li></ul><blockquote><p>RegistryExtractorInjector 见后面</p></blockquote><h4 id="将SpanContext上下文从carrier中Extract（提取）"><a href="#将SpanContext上下文从carrier中Extract（提取）" class="headerlink" title="将SpanContext上下文从carrier中Extract（提取）"></a>将SpanContext上下文从carrier中Extract（提取）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;C&gt; <span class="function">SpanContext <span class="title">extract</span><span class="params">(Format&lt;C&gt; format, C carrier)</span> </span>&#123;</span><br><span class="line">    RegistryExtractorInjector&lt;C&gt; registryExtractor = TracerFormatRegistry.getRegistry(format);</span><br><span class="line">    <span class="keyword">if</span> (registryExtractor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported extractor format: "</span> + format);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> registryExtractor.extract(carrier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>格式描述符(<code>format descriptor</code>)(通常但不一定是字符串常量)，告诉<code>Tracer</code>的实现如何在载体对象中对<code>SpanContext</code>进行编码</li><li>载体(<code>carrier</code>)，其类型由格式描述符指定<code>。Tracer</code>的实现将根据格式描述对此载体对象中的<code>SpanContext</code>进行编码</li></ul><p>返回一个<code>SpanContext</code>实例，可以使用这个<code>SpanContext</code>实例，通过<code>Tracer</code>创建新的<code>Span</code>。</p><h4 id="Format"><a href="#Format" class="headerlink" title="Format"></a>Format</h4><p>从<code>Tracer</code>的注入和提取来看，<code>format</code>都是必须的。</p><p><code>Inject</code>（注入）和<code>Extract</code>（提取）依赖于可扩展的<code>format</code>参数。<code>forma</code>t参数规定了另一个参数<code>&quot;carrier&quot;</code>的类型，同时约束了<code>&quot;carrier&quot;</code>中<code>SpanContext</code>是如何编码的。所有的<code>Tracer</code>实现，都必须支持下面的<code>format</code>。</p><ul><li><code>Text Map</code>: 基于字符串：字符串的<code>map</code>,对于<code>key</code>和<code>value</code>不约束字符集。</li><li><code>HTTP Headers</code>: 适合作为<code>HTTP</code>头信息的，基于字符串：字符串的<code>map</code>。（<code>RFC 7230.</code>在工程实践中，如何处理<code>HTTP</code>头具有多样性，强烈建议<code>tracer</code>的使用者谨慎使用<code>HTTP</code>头的键值空间和转义符）</li><li><code>Binary</code>: 一个简单的二进制大对象，记录<code>SpanContext</code>的信息。</li></ul><p>在上面的注入和提取代码中，有如下代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注入</span></span><br><span class="line">RegistryExtractorInjector&lt;C&gt; registryInjector  = </span><br><span class="line">    TracerFormatRegistry.getRegistry(format);</span><br><span class="line"><span class="comment">//提取</span></span><br><span class="line">RegistryExtractorInjector&lt;C&gt; registryExtractor = </span><br><span class="line">    TracerFormatRegistry.getRegistry(format);</span><br></pre></td></tr></table></figure><p>来通过<code>TracerFormatRegistry</code>这个类来来看下 <code>SOFATracer</code> 中的 <code>Format</code> 的具体实现。</p><h4 id="X-B3"><a href="#X-B3" class="headerlink" title="X-B3"></a>X-B3</h4><p>在看<code>Format</code>之前，先了解下<code>X-B3</code>。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Expose-Headers</span>: </span><br><span class="line"><span class="attribute">X-B3-TraceId,X-B3-ParentSpanId,X-B3-SpanId</span></span><br></pre></td></tr></table></figure><p><code>HTTP</code>请求时其<code>span</code>参数通过<code>http headers</code>来传递追踪信息；<code>header</code>中对应的<code>key</code>分别是:</p><ul><li>X-B3-TraceId: 64 encoded bits（id被encode为hex Strings）</li><li>X-B3-SpanId : 64 encoded bits</li><li>X-B3-ParentSpanId: 64 encoded bits</li><li>X-B3-Sampled:(是否采样) Boolean (either “1” or “0”)（下面的调用是否进行采样）</li><li>X-B3-Flags:a Long</li></ul><h4 id="SOFATracer-中的-Format"><a href="#SOFATracer-中的-Format" class="headerlink" title="SOFATracer 中的 Format"></a>SOFATracer 中的 Format</h4><p>具体代码在 <code>tracer-core -&gt; com.alipay.common.tracer.core.registy</code> 包下:</p><ul><li>TextMapFormatter</li><li>TextMapB3Formatter</li><li>HttpHeadersFormatter</li><li>HttpHeadersB3Formatter</li><li>BinaryFormater</li></ul><p><strong>BinaryFormater</strong>：这个的注入和提取实现没有编解码一说；本身就是基于二进制流的操作。</p><p><strong>TextMapB3Formatter/TextMapFormatter</strong> 和 <strong>HttpHeadersB3Formatter/HttpHeadersFormatter</strong> 区别就在于编解码不同。<code>HttpHeadersB3Formatter</code>使用的是 <code>URLDecoder.decode</code> &amp;&amp; <code>URLDecoder.encode</code> ; <code>TextMapB3Formatter</code> 返回的是值本身（如果为空或者<code>null</code>则返回空字符串）。</p><p><strong>TextMapFormatter</strong>和<strong>TextMapB3Formatter</strong>区别在于注入或者提取是使用的<code>key</code>不用。<code>TextMapB3Formatter</code>中使用的是 <code>x-b3-{}</code> 的字符串作为<code>key</code>。</p><h3 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h3><p>一个<code>span</code>代表系统中具有开始时间和执行时长的逻辑运行单元。<code>span</code>之间通过嵌套或者顺序排列建立逻辑因果关系。当<code>Span</code>结束后(<code>span.finish()</code>)，除了通过<code>Span</code>获取<code>SpanContext</code>外，下列其他所有方法都不允许被调用。</p><p>同样先来看下<code>opentracing</code>规范<code>api</code> 定义的 <code>span</code> 的定义及方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Span</span> <span class="keyword">extends</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="function">SpanContext <span class="title">context</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(<span class="keyword">long</span> finishMicros)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">setTag</span><span class="params">(String key, String value)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">setTag</span><span class="params">(String key, <span class="keyword">boolean</span> value)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">setTag</span><span class="params">(String key, Number value)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">log</span><span class="params">(Map&lt;String, ?&gt; fields)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">log</span><span class="params">(<span class="keyword">long</span> timestampMicroseconds, Map&lt;String, ?&gt; fields)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">log</span><span class="params">(String event)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">log</span><span class="params">(<span class="keyword">long</span> timestampMicroseconds, String event)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">setBaggageItem</span><span class="params">(String key, String value)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getBaggageItem</span><span class="params">(String key)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">setOperationName</span><span class="params">(String operationName)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">log</span><span class="params">(String eventName, <span class="comment">/* @Nullable */</span> Object payload)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">log</span><span class="params">(<span class="keyword">long</span> timestampMicroseconds, String eventName, <span class="comment">/* @Nullable */</span> Object payload)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过Span获取SpanContext"><a href="#通过Span获取SpanContext" class="headerlink" title="通过Span获取SpanContext"></a>通过Span获取SpanContext</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SOFATracerSpan</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpanContext <span class="title">context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sofaTracerSpanContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值，<code>Span</code>构建时传入的<code>SpanContext</code>。这个返回值在<code>Span</code>结束后(<code>span.finish()</code>)，依然可以使用。</p><h4 id="复写操作名"><a href="#复写操作名" class="headerlink" title="复写操作名"></a>复写操作名</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Span <span class="title">setOperationName</span><span class="params">(String operationName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.operationName = operationName;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>operationName</strong>:新的操作名，覆盖构建<code>Span</code>时，传入的操作名。</p><h4 id="结束Span"><a href="#结束Span" class="headerlink" title="结束Span"></a>结束Span</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.finish(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(<span class="keyword">long</span> endTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setEndTime(endTime);</span><br><span class="line">    <span class="comment">//关键记录:report span</span></span><br><span class="line">    <span class="keyword">this</span>.sofaTracer.reportSpan(<span class="keyword">this</span>);</span><br><span class="line">    SpanExtensionFactory.logStoppedSpan(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个可选参数，如果指定完成时间则使用当前指定的时间；如果省略此参数，使用当前时间作为完成时间。<code>finish</code>方法中会将当前<code>span</code>进行<code>report</code>操作。</p><h4 id="为Span设置tag"><a href="#为Span设置tag" class="headerlink" title="为Span设置tag"></a>为Span设置tag</h4><p><code>Tag</code>是一个<code>key:value</code>格式的数据。<code>key</code>必须是<code>String</code>类型，<code>value</code>可以是<strong>字符串、布尔或者数字</strong>。</p><ul><li>字符串类型的value 设置tag</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Span <span class="title">setTag</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(key) || StringUtils.isBlank(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.tagsWithStr.put(key, value);</span><br><span class="line">    <span class="comment">//注意:server 还是 client 在 OpenTracing 标准中是用 tags 标识的,所以在这里进行判断</span></span><br><span class="line">    <span class="keyword">if</span> (isServer()) &#123;</span><br><span class="line">        Reporter serverReporter = <span class="keyword">this</span>.sofaTracer.getServerReporter();</span><br><span class="line">        <span class="keyword">if</span> (serverReporter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.setLogType(serverReporter.getReporterType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isClient()) &#123;</span><br><span class="line">        Reporter clientReporter = <span class="keyword">this</span>.sofaTracer.getClientReporter();</span><br><span class="line">        <span class="keyword">if</span> (clientReporter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.setLogType(clientReporter.getReporterType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>布尔类型的value 设置tag</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Span <span class="title">setTag</span><span class="params">(String key, <span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.tagsWithBool.put(key, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数字类型的value 设置tag</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Span <span class="title">setTag</span><span class="params">(String key, Number number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.tagsWithNumber.put(key, number);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Log结构化数据"><a href="#Log结构化数据" class="headerlink" title="Log结构化数据"></a>Log结构化数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Span <span class="title">log</span><span class="params">(<span class="keyword">long</span> currentTime, Map&lt;String, ?&gt; map)</span> </span>&#123;</span><br><span class="line">    AssertUtils.isTrue(currentTime &gt;= startTime, <span class="string">"current time must greater than start time"</span>);</span><br><span class="line">    <span class="keyword">this</span>.logs.add(<span class="keyword">new</span> LogData(currentTime, map));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Span <span class="title">log</span><span class="params">(Map&lt;String, ?&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.log(System.currentTimeMillis(), map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Map&lt;String, ?&gt; map</strong> : 键必须是字符串类型，值可以是任意类型</li><li><strong>currentTime</strong> : 时间戳。如果指定时间戳，那么它必须在<code>span</code>的开始和结束时间之内。</li></ul><h4 id="设置一个baggage（随行数据）元素"><a href="#设置一个baggage（随行数据）元素" class="headerlink" title="设置一个baggage（随行数据）元素"></a>设置一个baggage（随行数据）元素</h4><p><code>Baggage</code>元素是一个键值对集合，将这些值设置给给定的<code>Span</code>，<code>Span</code>的<code>SpanContext</code>，以及所有和此<code>Span</code>有直接或者间接关系的本地<code>Span</code>。 也就是说，<code>baggage</code>元素随<code>trace</code>一起保持在带内传递。（译者注：带内传递，在这里指，随应用程序调用过程一起传递）</p><p><code>Baggage</code>元素为<code>OpenTracing</code>的实现全栈集成，提供了强大的功能 （例如：任意的应用程序数据，可以在移动端创建它，显然的，它会一直传递了系统最底层的存储系统。由于它如此强大的功能，他也会产生巨大的开销，请小心使用此特性。</p><p>再次强调，请谨慎使用此特性。每一个键值都会被拷贝到每一个本地和远程的下级相关的<code>span</code>中，因此，总体上，他会有明显的网络和<code>CPU</code>开销。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Span <span class="title">setBaggageItem</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sofaTracerSpanContext.setBizBaggageItem(key, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SofaTracerSpan-中的属性"><a href="#SofaTracerSpan-中的属性" class="headerlink" title="SofaTracerSpan 中的属性"></a>SofaTracerSpan 中的属性</h4><ul><li>sofaTracer  : 当前 tracer</li><li>spanReferences : 当前span的关系，ChildOf(引用) or FollowsFrom（跟随）</li><li>tagsWithStr : String 类型的tag 集合</li><li>tagsWithBool : 布尔类型的tag集合</li><li>tagsWithNumber : 数值类型的tag集合</li><li>logs : log结构化数据列表，通过span.log（map）操作的map,均存储在logs中。</li><li>operationName：当前span的操作名</li><li>sofaTracerSpanContext：当前 spanContext</li><li>startTime : 当前span 开始时间</li><li>endTime  : 当前span 结束时间，在finish方法中传入。</li><li>logType : report时才有意义:摘要日志类型,日志能够正确打印的关键信息；当前 span 的日志类型,如:客户端为 rpc-client-digest.log,服务端为 rpc-server-digest.log</li><li>parentSofaTracerSpan：父亲 span,当作为客户端结束并弹出线程上下文时,需要将父亲 span 再放入</li></ul><h4 id="SpanContext"><a href="#SpanContext" class="headerlink" title="SpanContext"></a>SpanContext</h4><p><code>opentracing</code> 中 <code>SpanContext</code> 接口中只有一个<code>baggageItems</code>方法，通过这个方法来遍历所有的<code>baggage</code>元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpanContext</span> </span>&#123;</span><br><span class="line">    Iterable&lt;Map.Entry&lt;String, String&gt;&gt; baggageItems();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相对于<code>OpenTracing</code>中其他的功能，<code>SpanContext</code>更多的是一个“概念”。也就是说，<code>OpenTracing</code>实现中，需要重点考虑，并提供一套自己的<code>API</code>。</p><p><code>OpenTracing</code>的使用者仅仅需要，在创建<code>span</code>、向传输协议<code>Inject</code>（注入）和从传输协议中<code>Extract</code>（提取）时，使用<code>SpanContext</code>和<code>references</code>，</p><p><code>OpenTracing</code>要求，<code>SpanContext</code>是不可变的，目的是防止由于<code>Span</code>的结束和相互关系，造成的复杂生命周期问题。</p><h2 id="Disruptor-简介"><a href="#Disruptor-简介" class="headerlink" title="Disruptor 简介"></a>Disruptor 简介</h2><blockquote><p>A High Performance Inter-Thread Messaging Library 高性能的线程间消息传递库</p></blockquote><p>关于 Disruptor 的 一些原理分析可以参考：<a href="https://ifeve.com/disruptor/" target="_blank" rel="noopener">disruptor</a></p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>先通过 <code>Disruptor</code> 的一个小例子来有个直观的认识；先看下它的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Disruptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> EventFactory&lt;T&gt; eventFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">int</span> ringBufferSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ProducerType producerType,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> WaitStrategy waitStrategy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(</span><br><span class="line">        RingBuffer.create(producerType, eventFactory, ringBufferSize, waitStrategy),</span><br><span class="line">        <span class="keyword">new</span> BasicExecutor(threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>eventFactory : 在环形缓冲区中创建事件的 <code>factory</code></li><li>ringBufferSize:环形缓冲区的大小，必须是2的幂。</li><li>threadFactory：用于为处理器创建线程。</li><li>producerType：生成器类型以支持使用正确的<code>sequencer</code>和<code>publisher</code>创建<code>RingBuffer</code>；枚举类型，<code>SINGLE</code>、<code>MULTI</code>两个项。对应于 <code>SingleProducerSequencer</code>和<code>MultiProducerSequencer</code>两种<code>Sequencer</code>。</li><li>waitStrategy : 等待策略；</li></ul><p>如果我们想构造一个<code>disruptor</code>,那么我们就需要上面的这些组件。从<code>eventFactory</code>来看，还需要一个具体的<code>Event</code>来作为消息事件的载体。【下面按照官方给的案例进行简单的修改作为示例】</p><h3 id="消息事件-LongEvent-，能够被消费的数据载体"><a href="#消息事件-LongEvent-，能够被消费的数据载体" class="headerlink" title="消息事件 LongEvent ，能够被消费的数据载体"></a>消息事件 LongEvent ，能够被消费的数据载体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建消息事件的factory"><a href="#创建消息事件的factory" class="headerlink" title="创建消息事件的factory"></a>创建消息事件的factory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventFactory</span> <span class="keyword">implements</span> <span class="title">EventFactory</span>&lt;<span class="title">LongEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LongEvent <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LongEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConsumerThreadFactory"><a href="#ConsumerThreadFactory" class="headerlink" title="ConsumerThreadFactory"></a>ConsumerThreadFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger index = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"disruptor-thread-"</span> + index.getAndIncrement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK ，上面的这些可以满足创建一个<code>disruptor</code>了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ringBufferCapacity = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//消息事件生产Factory</span></span><br><span class="line">LongEventFactory longEventFactory = <span class="keyword">new</span> LongEventFactory();</span><br><span class="line"><span class="comment">//执行事件处理器线程Factory</span></span><br><span class="line">ConsumerThreadFactory consumerThreadFactory = <span class="keyword">new</span> ConsumerThreadFactory();</span><br><span class="line"><span class="comment">//用于环形缓冲区的等待策略。</span></span><br><span class="line">WaitStrategy waitStrategy = <span class="keyword">new</span> BlockingWaitStrategy();</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建disruptor</span></span><br><span class="line">Disruptor&lt;LongEvent&gt; disruptor = <span class="keyword">new</span> Disruptor&lt;&gt;(</span><br><span class="line">    longEventFactory,</span><br><span class="line">    ringBufferCapacity,</span><br><span class="line">    longEventThreadFactory,</span><br><span class="line">    ProducerType.SINGLE,</span><br><span class="line">    waitStrategy);</span><br></pre></td></tr></table></figure><p>现在是已经有了 <code>disruptor</code> 了，然后通过：<code>start</code> 来启动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动 disruptor</span></span><br><span class="line"> disruptor.start();</span><br></pre></td></tr></table></figure><p>到这里，已经构建了一个<code>disruptor</code>；但是目前怎么使用它来发布消息和消费消息呢？</p><h3 id="发布消息"><a href="#发布消息" class="headerlink" title="发布消息"></a>发布消息</h3><p>下面在 <code>for</code> 循环中 发布 5 条数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> l = <span class="number">0</span>; l &lt; <span class="number">5</span>; l++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> sequence = ringBuffer.next();</span><br><span class="line">    LongEvent event = ringBuffer.get(sequence);</span><br><span class="line">    event.set(<span class="number">100</span>+l);</span><br><span class="line">    System.out.println(<span class="string">"publish event :"</span> + l);</span><br><span class="line">    ringBuffer.publish(sequence);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息已经发布，下面需要设定当前<code>disruptor</code>的消费处理器。前面已经有个<code>LongEvent</code> 和 <code>EventFactory</code> ; 在<code>disruptor</code>中是通过 <code>EventHandler</code> 来进行消息消费的。</p><h3 id="编写消费者代码"><a href="#编写消费者代码" class="headerlink" title="编写消费者代码"></a>编写消费者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventHandler</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">LongEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(LongEvent event, <span class="keyword">long</span> sequence, <span class="keyword">boolean</span> endOfBatch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Event: "</span> + event.getValue()+<span class="string">" -&gt; "</span> + Thread.currentThread().getName());</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <code>eventHandler</code> 设置到 <code>disruptor</code> 的处理链上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将处理事件的事件处理程序 -&gt; 消费事件的处理程序</span></span><br><span class="line">LongEventHandler longEventHandler = <span class="keyword">new</span> LongEventHandler();</span><br><span class="line">disruptor.handleEventsWith(longEventHandler);</span><br></pre></td></tr></table></figure><h3 id="运行结果（这里）："><a href="#运行结果（这里）：" class="headerlink" title="运行结果（这里）："></a>运行结果（这里）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">publish event :0</span><br><span class="line">Event: 0 -&gt; disruptor-thread-1</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :1</span><br><span class="line">Event: 1 -&gt; disruptor-thread-1</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :2</span><br><span class="line">Event: 2 -&gt; disruptor-thread-1</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :3</span><br><span class="line">Event: 3 -&gt; disruptor-thread-1</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :4</span><br><span class="line">Event: 4 -&gt; disruptor-thread-1</span><br><span class="line">--------------------------------&gt;</span><br></pre></td></tr></table></figure><h2 id="基本概念和原理"><a href="#基本概念和原理" class="headerlink" title="基本概念和原理"></a>基本概念和原理</h2><h3 id="Disruptor"><a href="#Disruptor" class="headerlink" title="Disruptor"></a>Disruptor</h3><p>整个基于<code>ringBuffer</code>实现的生产者消费者模式的容器。主要属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RingBuffer&lt;T&gt; ringBuffer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConsumerRepository&lt;T&gt; consumerRepository = <span class="keyword">new</span> ConsumerRepository&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean started = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">private</span> ExceptionHandler&lt;? <span class="keyword">super</span> T&gt; exceptionHandler = <span class="keyword">new</span> ExceptionHandlerWrapper&lt;&gt;();</span><br></pre></td></tr></table></figure><ul><li><code>ringBuffer</code>：内部持有一个 <code>RingBuffer</code> 对象，<code>Disruptor</code> 内部的事件发布都是依赖这个<code>RingBuffer</code>对象完成的。</li><li><code>executor</code>：消费事件的线程池</li><li><code>consumerRepository</code>：提供存储库机制，用于将<code>EventHandler</code>与<code>EventProcessor</code>关联起来</li><li><code>started</code> : 用于标志当前<code>Disruptor</code>是否已经启动</li><li><code>exceptionHandler</code> : 异常处理器，用于处理<code>BatchEventProcessor</code>事件周期中 <code>uncaught exceptions</code> 。</li></ul><h3 id="RingBuffer"><a href="#RingBuffer" class="headerlink" title="RingBuffer"></a>RingBuffer</h3><p>环形队列[实现上是一个数组]，可以类比为<code>BlockingQueue</code>之类的队列，<code>ringBuffer</code>的使用，使得内存被循环使用，减少了某些场景的内存分配回收扩容等耗时操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RingBuffer</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">RingBufferFields</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Cursored</span>, <span class="title">EventSequencer</span>&lt;<span class="title">E</span>&gt;, <span class="title">EventSink</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>E：在事件的交换或并行协调期间存储用于共享的数据的实现 -&gt; 消息事件</li></ul><h3 id="Sequencer"><a href="#Sequencer" class="headerlink" title="Sequencer"></a>Sequencer</h3><p> <code>RingBuffer</code> 中 生产者的顶级父接口，其直接实现有<code>SingleProducerSequencer</code>和<code>MultiProducerSequencer</code>；对应 <code>SINGLE</code>、<code>MULTI</code> 两个枚举值。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16504080427c32c5?w=1046&amp;h=768&amp;f=png&amp;s=52527" alt=""></p><h3 id="EventHandler"><a href="#EventHandler" class="headerlink" title="EventHandler"></a>EventHandler</h3><p>事件处置器，改接口用于对外扩展来实现具体的消费逻辑。如上面 <code>demo</code> 中的 <code>LongEventHandler</code> ;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回调接口，用于处理&#123;@link RingBuffer&#125;中可用的事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(T event, <span class="keyword">long</span> sequence, <span class="keyword">boolean</span> endOfBatch)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>event</code> : <code>RingBuffer</code> 已经发布的事件</li><li><code>sequence</code> : 正在处理的事件 的序列号</li><li><code>endOfBatch</code> : 用来标识否是来自 <code>RingBuffer</code> 的批次中的最后一个事件</li></ul><h3 id="SequenceBarrier"><a href="#SequenceBarrier" class="headerlink" title="SequenceBarrier"></a>SequenceBarrier</h3><p>消费者路障。规定了消费者如何向下走。事实上，该路障算是变向的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessingSequenceBarrier</span> <span class="keyword">implements</span> <span class="title">SequenceBarrier</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当等待（探测）的需要不可用时，等待的策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WaitStrategy waitStrategy;</span><br><span class="line">    <span class="comment">//依赖的其它Consumer的序号，这个用于依赖的消费的情况，</span></span><br><span class="line">    <span class="comment">//比如A、B两个消费者，只有A消费完，B才能消费。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sequence     dependentSequence;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span>   alerted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//Ringbuffer的写入指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sequence     cursorSequence;</span><br><span class="line">    <span class="comment">//RingBuffer对应的Sequencer</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sequencer    sequencer;</span><br><span class="line">    <span class="comment">//exclude method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>waitStrategy</code> 决定了消费者采用何种等待策略。</p><h3 id="WaitStrategy"><a href="#WaitStrategy" class="headerlink" title="WaitStrategy"></a>WaitStrategy</h3><blockquote><p>Strategy employed for making {@link EventProcessor}s wait on a cursor {@link Sequence}.</p></blockquote><p><code>EventProcessor</code> 的等待策略；具体实现在 <code>disruptor</code> 中有8种，</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/165040897c8cd0fd?w=429&amp;h=184&amp;f=png&amp;s=70264" alt=""></p><p>这些等待策略不同的核心体现是在如何实现 <code>waitFor</code> 这个方法上。</p><h3 id="EventProcessor"><a href="#EventProcessor" class="headerlink" title="EventProcessor"></a>EventProcessor</h3><p>事件处理器，实际上可以理解为消费者模型的框架，实现了线程<code>Runnable</code>的<code>run</code>方法，将循环判断等操作封在了里面。该接口有三个实现类:</p><p><strong>1、BatchEventProcessor</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchEventProcessor</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">EventProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean           running          = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">private</span> ExceptionHandler&lt;? <span class="keyword">super</span> T&gt;   exceptionHandler = <span class="keyword">new</span> FatalExceptionHandler();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataProvider&lt;T&gt;         dataProvider;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SequenceBarrier         sequenceBarrier;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventHandler&lt;? <span class="keyword">super</span> T&gt; eventHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sequence                sequence         = <span class="keyword">new</span> Sequence(                                      Sequencer.INITIAL_CURSOR_VALUE);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimeoutHandler          timeoutHandler;</span><br><span class="line">    <span class="comment">//exclude method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ExceptionHandler：异常处理器</li><li>DataProvider：数据来源，对应 <code>RingBuffer</code></li><li>EventHandler：处理 <code>Event</code> 的回调对象</li><li>SequenceBarrier：对应的序号屏障</li><li>TimeoutHandler：超时处理器，默认情况为空，如果要设置，只需要要将关联的<code>EventHandler</code>实现<code>TimeOutHandler</code>即可。</li></ul><p>如果我们选择使用 <code>EventHandler</code> 的时候，默认使用的就是 <code>BatchEventProcessor</code>，它与<code>EventHandler</code>是一一对应，并且是单线程执行。</p><p>如果某个<code>RingBuffer</code>有多个<code>BatchEventProcessor</code>，那么就会每个<code>BatchEventProcessor</code>对应一个线程。</p><p><strong>2、WorkProcessor</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkProcessor</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">EventProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean running = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sequence sequence = <span class="keyword">new</span> Sequence(Sequencer.INITIAL_CURSOR_VALUE);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RingBuffer&lt;T&gt; ringBuffer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SequenceBarrier  sequenceBarrier;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WorkHandler&lt;? <span class="keyword">super</span> T&gt; workHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExceptionHandler&lt;? <span class="keyword">super</span> T&gt; exceptionHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sequence workSequence;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventReleaser eventReleaser = <span class="keyword">new</span> EventReleaser() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                sequence.set(Long.MAX_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimeoutHandler timeoutHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本和 <code>BatchEventProcessor</code> 类似，不同在于，用于处理<code>Event</code>的回调对象是<code>WorkHandler</code>。</p><h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/165040ee8a2eae73?w=1240&amp;h=750&amp;f=png&amp;s=312558" alt=""></p><h2 id="无消费者情况下，生产者保持生产，但是-remainingCapacity-保持不变"><a href="#无消费者情况下，生产者保持生产，但是-remainingCapacity-保持不变" class="headerlink" title="无消费者情况下，生产者保持生产，但是 remainingCapacity 保持不变"></a>无消费者情况下，生产者保持生产，但是 <code>remainingCapacity</code> 保持不变</h2><p>在写<code>demo</code>的过程中，本来想通过不设定 消费者 来观察 <code>RingBuffer</code> 可用容量变化的。但是验证过程中，一直得不到预期的结果，(注：没有设置消费者，只有生产者)，先看结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">publish event :0</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:0</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :1</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:1</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :2</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:2</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :3</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:3</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :4</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:4</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :5</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:5</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :6</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:6</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :7</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:7</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :8</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:8</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :9</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:9</span><br><span class="line">--------------------------------&gt;</span><br></pre></td></tr></table></figure><p>从结果来看，<code>remainingCapacity</code> 的值应该随着 发布的数量 递减的；但是实际上它并没有发生任何变化。</p><p>来看下<code>ringBuffer.remainingCapacity()</code> 这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the remaining capacity for this ringBuffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The number of slots remaining.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">remainingCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sequencer.remainingCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面又使用 <code>sequencer.remainingCapacity()</code>这个方法来计算的。上面的例子中使用的是<code>ProducerType.SINGLE</code>，那来看<code>SingleProducerSequencer</code> 这个里面<code>remainingCapacity</code>的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">remainingCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//上次申请完毕的序列值</span></span><br><span class="line">    <span class="keyword">long</span> nextValue = <span class="keyword">this</span>.nextValue;</span><br><span class="line">    <span class="comment">//计算当前已经消费到的序列值</span></span><br><span class="line">    <span class="keyword">long</span> consumed = Util.getMinimumSequence(gatingSequences, nextValue);</span><br><span class="line">    <span class="comment">//当前生产到的序列值</span></span><br><span class="line">    <span class="keyword">long</span> produced = nextValue;</span><br><span class="line">    <span class="keyword">return</span> getBufferSize() - (produced - consumed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来解释下这段代码的含义：</p><p>假设当前 <code>ringBuffer</code> 的 <code>bufferSize</code> 是 8 ；上次申请到的序列号是 5，其实也就是说已经生产过占用的序列号是5；假设当前已经消费到的序列号是 3，那么剩余的容量为： 8-（5-2） = 5；</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/1650414723061ce7?w=992&amp;h=744&amp;f=png&amp;s=310780" alt=""></p><p>因为这里我们可以确定 <code>bufferSize</code> 和 <code>produced</code> 的值了，那么 <code>remainingCapacity</code> 的结果就取决于<code>getMinimumSequence</code>的计算结果了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getMinimumSequence</span><span class="params">(<span class="keyword">final</span> Sequence[] sequences, <span class="keyword">long</span> minimum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = sequences.length; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> value = sequences[i].get();</span><br><span class="line">        minimum = Math.min(minimum, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是从 <code>Sequence</code> 数组中获取最小序列 。如果<code>sequences</code> 为空，则返回 <code>minimum</code>。回到上一步，看下<code>sequences</code>这个数组是从哪里过来的，它的值在哪里设置的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> consumed = Util.getMinimumSequence(gatingSequences, nextValue);</span><br></pre></td></tr></table></figure><p><code>gatingSequences</code>是 <code>SingleProducerSequencer</code>父类  <code>AbstractSequencer</code> 中的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> Sequence[] gatingSequences = <span class="keyword">new</span> Sequence[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p><code>gatingSequences</code> 是在下面这个方法里面来管理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Sequencer#addGatingSequences(Sequence...)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addGatingSequences</span><span class="params">(Sequence... gatingSequences)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SequenceGroups.addSequences(<span class="keyword">this</span>, SEQUENCE_UPDATER, <span class="keyword">this</span>, gatingSequences);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的调用栈向前追溯有这几个地方调用了：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/1650415d0682db8f?w=1934&amp;h=560&amp;f=png&amp;s=203628" alt=""></p><p><code>WorkerPool</code>来管理多个消费者；<code>hangdlerEventsWith</code> 这个方法也是用来设置消费者的。但是在上面的测试案例中我们是想通过不设定消费者 只设定生成者 来观察 环形队列的占用情况，所以<code>gatingSequences</code> 会一直是空的，因此在计算时会把 <code>produced</code> 的值作为 <code>minimum</code> 返回。这样每次计算就相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> getBufferSize() - (produced - produced) === getBufferSize();</span><br></pre></td></tr></table></figure><p>也就验证了为何在不设定消费者的情况下，<code>remainingCapacity</code> 的值会一直保持不变。</p><h2 id="SOFATracer-中-Disruptor-实践"><a href="#SOFATracer-中-Disruptor-实践" class="headerlink" title="SOFATracer 中 Disruptor 实践"></a>SOFATracer 中 Disruptor 实践</h2><p><code>SOFATracer</code>中，<code>AsyncCommonDigestAppenderManager</code> 对 <code>disruptor</code> 进行了封装，用于处理外部组件的<code>Tracer</code>摘要日志。该部分借助 <code>AsyncCommonDigestAppenderManager</code> 的源码来分析下<code>SOFATracer</code>如何使用<code>disruptor</code>的。</p><p><code>SOFATracer</code>中使用了两种不同的事件模型，一种是<code>SOFATracer</code>内部使用的 <code>StringEvent</code> , 一种是 外部扩展使用的 <code>SofaTacerSpanEvent</code>。这里以 <code>SofaTacerSpanEvent</code> 这种事件模型来分析。<code>StringEvent</code> 消息事件模型对应的是 <code>AsyncCommonAppenderManager</code> 类封装的<code>disruptor</code>。</p><h3 id="SofaTracerSpanEvent-gt-LongEvent"><a href="#SofaTracerSpanEvent-gt-LongEvent" class="headerlink" title="SofaTracerSpanEvent ( -&gt; LongEvent)"></a>SofaTracerSpanEvent ( -&gt; LongEvent)</h3><p>定义消息事件模型，<code>SofaTacerSpanEvent</code> 和 前面 <code>demo</code> 中的 <code>LongEvent</code> 基本结构是一样的，主要是内部持有的消息数据不同，<code>LongEvent</code> 中是一个<code>long</code>类型的数据，<code>SofaTacerSpanEvent</code>中持有的是 <code>SofaTracerSpan</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaTracerSpanEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> SofaTracerSpan sofaTracerSpan;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SofaTracerSpan <span class="title">getSofaTracerSpan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sofaTracerSpan;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSofaTracerSpan</span><span class="params">(SofaTracerSpan sofaTracerSpan)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sofaTracerSpan = sofaTracerSpan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Consumer-gt-LongEventHandler"><a href="#Consumer-gt-LongEventHandler" class="headerlink" title="Consumer ( -&gt; LongEventHandler)"></a>Consumer ( -&gt; LongEventHandler)</h3><p><code>Consumer</code> 是 <code>AsyncCommonDigestAppenderManager</code> 的内部类;实现了 <code>EventHandler</code> 接口，这个<code>consumer</code>就是作为消费者存在的。</p><p>在<code>AsyncCommonAppenderManager</code>中也有一个，这个地方个人觉得可以抽出去，这样可以使得<code>AsyncCommonDigestAppenderManager/AsyncCommonAppenderManager</code>的代码看起来更干净；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">SofaTracerSpanEvent</span>&gt; </span>&#123;</span><br><span class="line">       <span class="comment">//日志类型集合，非该集合内的日志类型将不会被处理</span></span><br><span class="line">        <span class="keyword">protected</span> Set&lt;String&gt; logTypes = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;String&gt;());</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(SofaTracerSpanEvent event, <span class="keyword">long</span> sequence, <span class="keyword">boolean</span> endOfBatch)</span></span></span><br><span class="line"><span class="function">                                <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 拿到具体的消息数据 sofaTracerSpan</span></span><br><span class="line">            SofaTracerSpan sofaTracerSpan = event.getSofaTracerSpan();</span><br><span class="line">            <span class="comment">// 如果没有数据，则不做任何处理</span></span><br><span class="line">            <span class="keyword">if</span> (sofaTracerSpan != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String logType = sofaTracerSpan.getLogType();</span><br><span class="line">                    <span class="comment">// 验证当前日志类型是否可以被当前consumer消费</span></span><br><span class="line">                    <span class="keyword">if</span> (logTypes.contains(logType)) &#123;</span><br><span class="line">                        <span class="comment">// 获取编码类型</span></span><br><span class="line">                        SpanEncoder encoder = contextEncoders.get(logType);</span><br><span class="line">                        <span class="comment">//获取 appender</span></span><br><span class="line">                        TraceAppender appender = appenders.get(logType);</span><br><span class="line">                        <span class="comment">// 对数据进行编码处理</span></span><br><span class="line">                        String encodedStr = encoder.encode(sofaTracerSpan);</span><br><span class="line">                        <span class="keyword">if</span> (appender <span class="keyword">instanceof</span> LoadTestAwareAppender) &#123;</span><br><span class="line">                            ((LoadTestAwareAppender) appender).append(encodedStr,</span><br><span class="line">                                TracerUtils.isLoadTest(sofaTracerSpan));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            appender.append(encodedStr);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 刷新缓冲区，日志输出</span></span><br><span class="line">                        appender.flush();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   <span class="comment">// 异常省略</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLogType</span><span class="params">(String logType)</span> </span>&#123;</span><br><span class="line">            logTypes.add(logType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="SofaTracerSpanEventFactory-（-gt-LongEventFactory）"><a href="#SofaTracerSpanEventFactory-（-gt-LongEventFactory）" class="headerlink" title="SofaTracerSpanEventFactory （-&gt; LongEventFactory）"></a>SofaTracerSpanEventFactory （-&gt; LongEventFactory）</h3><p>用于产生消息事件的 <code>Factory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaTracerSpanEventFactory</span> <span class="keyword">implements</span> <span class="title">EventFactory</span>&lt;<span class="title">SofaTracerSpanEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SofaTracerSpanEvent <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SofaTracerSpanEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConsumerThreadFactory-gt-LongEventThreadFactory"><a href="#ConsumerThreadFactory-gt-LongEventThreadFactory" class="headerlink" title="ConsumerThreadFactory (-&gt; LongEventThreadFactory )"></a>ConsumerThreadFactory (-&gt; LongEventThreadFactory )</h3><p>用来产生消费线程的 <code>Factory</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String workName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWorkName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> workName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWorkName</span><span class="params">(String workName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workName = workName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        Thread worker = <span class="keyword">new</span> Thread(runnable, <span class="string">"Tracer-AsyncConsumer-Thread-"</span> + workName);</span><br><span class="line">        worker.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> worker;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建disruptor"><a href="#构建disruptor" class="headerlink" title="构建disruptor"></a>构建disruptor</h3><p><code>disruptor</code> 的构建是在 <code>AsyncCommonDigestAppenderManager</code> 的构造函数中完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncCommonDigestAppenderManager</span><span class="params">(<span class="keyword">int</span> queueSize, <span class="keyword">int</span> consumerNumber)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用这个计算来保证realQueueSize是2的次幂（返回当前 大于等于queueSize的最小的2的次幂数 ）</span></span><br><span class="line">    <span class="keyword">int</span> realQueueSize = <span class="number">1</span> &lt;&lt; (<span class="number">32</span> - Integer.numberOfLeadingZeros(queueSize - <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//构建disruptor，使用的是 ProducerType.MULTI</span></span><br><span class="line">    <span class="comment">//等待策略是 BlockingWaitStrategy</span></span><br><span class="line">    disruptor = <span class="keyword">new</span> Disruptor&lt;SofaTracerSpanEvent&gt;(<span class="keyword">new</span> SofaTracerSpanEventFactory(),</span><br><span class="line">        realQueueSize, threadFactory, ProducerType.MULTI, <span class="keyword">new</span> BlockingWaitStrategy());</span><br><span class="line">    <span class="comment">//消费者列表</span></span><br><span class="line">    <span class="keyword">this</span>.consumers = <span class="keyword">new</span> ArrayList&lt;Consumer&gt;(consumerNumber);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; consumerNumber; i++) &#123;</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer();</span><br><span class="line">        consumers.add(consumer);</span><br><span class="line">        <span class="comment">//设置异常处理程序</span></span><br><span class="line">        disruptor.setDefaultExceptionHandler(<span class="keyword">new</span> ConsumerExceptionHandler());</span><br><span class="line">        <span class="comment">//绑定消费者</span></span><br><span class="line">        disruptor.handleEventsWith(consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否允许丢弃，从配置文件获取</span></span><br><span class="line">    <span class="keyword">this</span>.allowDiscard = Boolean.parseBoolean(SofaTracerConfiguration.getProperty(</span><br><span class="line">        SofaTracerConfiguration.TRACER_ASYNC_APPENDER_ALLOW_DISCARD, DEFAULT_ALLOW_DISCARD));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (allowDiscard) &#123;</span><br><span class="line">        <span class="comment">//是否记录丢失日志的数量</span></span><br><span class="line">        <span class="keyword">this</span>.isOutDiscardNumber = Boolean.parseBoolean(SofaTracerConfiguration.getProperty(</span><br><span class="line">            SofaTracerConfiguration.TRACER_ASYNC_APPENDER_IS_OUT_DISCARD_NUMBER,</span><br><span class="line">            DEFAULT_IS_OUT_DISCARD_NUMBER));</span><br><span class="line">        <span class="comment">//是否记录丢失日志的TraceId和RpcId</span></span><br><span class="line">        <span class="keyword">this</span>.isOutDiscardId = Boolean.parseBoolean(SofaTracerConfiguration.getProperty(</span><br><span class="line">            SofaTracerConfiguration.TRACER_ASYNC_APPENDER_IS_OUT_DISCARD_ID,</span><br><span class="line">            DEFAULT_IS_OUT_DISCARD_ID));</span><br><span class="line">        <span class="comment">//丢失日志的数量达到该阈值进行一次日志输出</span></span><br><span class="line">        <span class="keyword">this</span>.discardOutThreshold = Long.parseLong(SofaTracerConfiguration.getProperty(</span><br><span class="line">            SofaTracerConfiguration.TRACER_ASYNC_APPENDER_DISCARD_OUT_THRESHOLD,</span><br><span class="line">            DEFAULT_DISCARD_OUT_THRESHOLD));</span><br><span class="line">        <span class="keyword">if</span> (isOutDiscardNumber) &#123;</span><br><span class="line">            <span class="keyword">this</span>.discardCount = <span class="keyword">new</span> PaddedAtomicLong(<span class="number">0L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动-disruptor"><a href="#启动-disruptor" class="headerlink" title="启动 disruptor"></a>启动 disruptor</h3><p><code>disruptor</code>的启动委托给了<code>AsyncCommonDigestAppenderManager</code> 的<code>start</code>方法来执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">final</span> String workerName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.threadFactory.setWorkName(workerName);</span><br><span class="line">    <span class="keyword">this</span>.ringBuffer = <span class="keyword">this</span>.disruptor.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看下，<code>SOFATracer</code> 中 具体是在哪里调用这个<code>start</code> 的：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/165041aeac0dc066?w=576&amp;h=158&amp;f=png&amp;s=40516" alt=""></p><ul><li><code>CommonTracerManager</code> : 这个里面持有了<code>AsyncCommonDigestAppenderManager</code> 类的一个单例对象，并且是<code>static</code> 静态代码块中调用了<code>start</code>方法；这个用来输出普通日志。</li><li><code>SofaTracerDigestReporterAsyncManager</code>：这里类里面也是持有了<code>AsyncCommonDigestAppenderManager</code> 类的一个单例对像，并且提供了<code>getSofaTracerDigestReporterAsyncManager</code>方法来获取该单例，在这个方法中调用了<code>start</code>方法；该对象用来输出摘要日志。</li></ul><h3 id="发布事件"><a href="#发布事件" class="headerlink" title="发布事件"></a>发布事件</h3><p>前面的<code>demo</code>中是通过一个<code>for</code>循环来发布事件的，在 <code>SOFATracer</code> 中 的事件发布无非就是当有<code>Tracer</code>日志需要输出时会触发发布，那么对应的就是日志的 <code>append</code> 操作，将日志 <code>append</code> 到环形缓冲区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">append</span><span class="params">(SofaTracerSpan sofaTracerSpan)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">//是否允许丢弃</span></span><br><span class="line">    <span class="keyword">if</span> (allowDiscard) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//允许丢弃就使用tryNext尝试申请序列，申请不到抛出异常</span></span><br><span class="line">            sequence = ringBuffer.tryNext();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InsufficientCapacityException e) &#123;</span><br><span class="line">            <span class="comment">//是否输出丢失日志的TraceId和RpcId</span></span><br><span class="line">            <span class="keyword">if</span> (isOutDiscardId) &#123;</span><br><span class="line">                SofaTracerSpanContext sofaTracerSpanContext = sofaTracerSpan</span><br><span class="line">                    .getSofaTracerSpanContext();</span><br><span class="line">                <span class="keyword">if</span> (sofaTracerSpanContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    SynchronizingSelfLog.warn(<span class="string">"discarded tracer: traceId["</span></span><br><span class="line">                                              + sofaTracerSpanContext.getTraceId()</span><br><span class="line">                                              + <span class="string">"];spanId["</span> + sofaTracerSpanContext.getSpanId()</span><br><span class="line">                                              + <span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">//是否输出丢失日志的数量</span></span><br><span class="line">            <span class="keyword">if</span> ((isOutDiscardNumber) &amp;&amp; discardCount.incrementAndGet() == discardOutThreshold) &#123;</span><br><span class="line">                discardCount.set(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (isOutDiscardNumber) &#123;</span><br><span class="line">                    SynchronizingSelfLog.warn(<span class="string">"discarded "</span> + discardOutThreshold + <span class="string">" logs"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不允许丢弃则使用next方法</span></span><br><span class="line">        sequence = ringBuffer.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SofaTracerSpanEvent event = ringBuffer.get(sequence);</span><br><span class="line">        event.setSofaTracerSpan(sofaTracerSpan);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        SynchronizingSelfLog.error(<span class="string">"fail to add event"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发布</span></span><br><span class="line">    ringBuffer.publish(sequence);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SOFATracer 事件发布的调用逻辑：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/165041c4514a3102?w=1060&amp;h=1012&amp;f=png&amp;s=80785" alt=""></p><p>追溯调用的流程，可以知道当前 <code>span</code> 调用 <code>finish</code>时或者 <code>SOFATracer</code>中调用<code>reportSpan</code>时 就相当于发布了一个消息事件。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文对 <code>SOFATracer</code> 中使用 <code>Disruptor</code> 来进行日志输出的代码进行了简单的分析，更多内部细节原理可以自行看下<code>SOFATracer</code>的代码。<code>SOFATracer</code> 作为一种比较底层的中间件组件，在实际的业务开发中基本是无法感知的。但是作为技术来学习，还是有很多点可以挖一挖。</p><p><a href="https://github.com/alipay/sofa-tracer" target="_blank" rel="noopener">SOFATracer GitHub 传送门</a>。</p><blockquote><p>如果有小伙伴对中间件感兴趣，欢迎加入我们团队，欢迎来撩；对 SOFA 技术体系有兴趣的可以关注我们 <a href="https://github.com/alipay" target="_blank" rel="noopener">ALIPAY SOFA 社区</a>；附团队镇楼图。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/1650426cfb443c99?w=1088&amp;h=708&amp;f=png&amp;s=1217313" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> SOFA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenTracing </tag>
            
            <tag> SOFATracer </tag>
            
            <tag> Disruptor </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>聊一聊 RestTemplate</title>
      <link href="/2018/11/10/resttemplate1/"/>
      <url>/2018/11/10/resttemplate1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近这段时间用了下 RestTemplate 这个类，抽点时间总结下一些东西，希望对大家有所帮助。</p></blockquote><p>从 3.0 版本开始，Spring 提供了 RestTemplate 作为用于访问 Rest 服务的客户端，RestTemplate 提供了多种便捷访问远程 Http 服务的方法，能够大大提高客户端的编写效率。</p><p>本篇文章将从 RestTemplate 提供的 API 入手，先来了解下 RestTemplate 的具体使用，然后再对其中涉及到的几个核心类进行分析，最后再来分析下 RestTemplate 执行的整个流程，篇幅比较长，建议先码为快！</p><h2 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h2><p>在平时的使用中，我们通常都是使用包装好的getForObject/getForEntity，postForObject/postForEntity/postForLocation，put以及delete。</p><h3 id="get-请求处理"><a href="#get-请求处理" class="headerlink" title="get 请求处理"></a>get 请求处理</h3><p>getForEntity方法的返回值是一个ResponseEntity<t>，ResponseEntity<t>是Spring对HTTP请求响应的封装，包括了几个重要的元素，如响应码、contentType、contentLength、响应消息体等。</t></t></p><ul><li>url：调用的服务的地址</li><li>responseType：返回的body类型</li><li>uriVariables：有两种形式:<ul><li>可以用一个数字做占位符，最后是一个可变长度的参数，来一一替换前面的占位符<br><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682a71d3436f37?w=2110&amp;h=188&amp;f=png&amp;s=69713" alt=""></li><li>也可以前面使用name={name}这种形式，最后一个参数是一个map，map的key即为前边占位符的名字，map的value为参数值<br><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682a77dd355749?w=2084&amp;h=196&amp;f=png&amp;s=69867" alt=""></li></ul></li></ul><h4 id="responseType-测试案例"><a href="#responseType-测试案例" class="headerlink" title="responseType 测试案例"></a>responseType 测试案例</h4><p>定义的一个controller资源：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682a97f48fb171?w=1262&amp;h=282&amp;f=png&amp;s=54017" alt=""><br>这里分别使用不同的 responseType 进行测试：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682a93da364cf1?w=1536&amp;h=498&amp;f=png&amp;s=134357" alt=""></p><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getForEntity(responseType=Map.class):&#123;glmapper=hello glmapper&#125;</span><br><span class="line">getForEntity(responseType=String.class):&#123;&quot;glmapper&quot;:&quot;hello glmapper&quot;&#125;</span><br></pre></td></tr></table></figure></p><h4 id="uriVariables-测试案例"><a href="#uriVariables-测试案例" class="headerlink" title="uriVariables 测试案例"></a>uriVariables 测试案例</h4><p>先来看下非map方式的，两个controller，两种不同方式的参数获取（本质上是一样的）<br><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682ab556c128fc?w=1412&amp;h=272&amp;f=png&amp;s=70152" alt=""></p><ul><li>使用占位符的方式：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682abcc1d8c3ca?w=1504&amp;h=240&amp;f=png&amp;s=69526" alt=""></p><ul><li>使用 map 的方式：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682ac3e84dbb0a?w=1504&amp;h=276&amp;f=png&amp;s=66893" alt=""></p><h3 id="getForObject"><a href="#getForObject" class="headerlink" title="getForObject"></a>getForObject</h3><p>getForObject 函数实际上是对 getForEntity 函数的进一步封装，如果只关注返回的消息体的内容，对其他信息都不关注，那么就可以使用 getForObject。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682ad954b5df90?w=1148&amp;h=278&amp;f=png&amp;s=46924" alt=""></p><p>这里调用就比getForEntity要简单一点了，可以直接拿到对象：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682ae0804d0692?w=1504&amp;h=146&amp;f=png&amp;s=37689" alt=""></p><p>getForObject 的几个重载方法和 getForEntity 基本是一样的。</p><h3 id="post-请求处理"><a href="#post-请求处理" class="headerlink" title="post 请求处理"></a>post 请求处理</h3><p>在RestTemplate中，POST请求可以通过如下三个方法来发起：postForEntity，postForObject，postForLocation。</p><h4 id="postForEntity-案例"><a href="#postForEntity-案例" class="headerlink" title="postForEntity 案例"></a>postForEntity 案例</h4><p><img src="https://user-gold-cdn.xitu.io/2018/10/18/1668778ea595c23b?w=1212&amp;h=232&amp;f=png&amp;s=49938" alt=""><br>调用获取：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/18/16687792c19ca889?w=1588&amp;h=286&amp;f=png&amp;s=74538" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postForEntity(URI url, <span class="meta">@Nullable</span> Object request, Class&lt;T&gt; responseType)</span><br></pre></td></tr></table></figure><ul><li>方法的第一参数表示要调用的服务的地址</li><li>方法的第二个参数表示上传的参数</li><li>方法的第三个参数表示返回的消息体的数据类型</li></ul><h4 id="postForObject-案例"><a href="#postForObject-案例" class="headerlink" title="postForObject 案例"></a>postForObject 案例</h4><p>和 getForObject 相对应，只关注返回的消息体。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877ade7c3795c?w=1556&amp;h=228&amp;f=png&amp;s=67804" alt=""></p><h4 id="postForLocation-案例"><a href="#postForLocation-案例" class="headerlink" title="postForLocation 案例"></a>postForLocation 案例</h4><p>postForLocation也是提交新资源，提交成功之后，返回新资源的URI，postForLocation的参数和前面两种的参数基本一致，只不过该方法的返回值为Uri，这个只需要服务提供者返回一个Uri即可，该Uri表示新资源的位置。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877b5de7b3e06?w=1522&amp;h=324&amp;f=png&amp;s=88249" alt=""></p><p>这里有点坑，我们需要把这个uri添加到response的header中，不然后面拿到的是null。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877b96ded6304?w=1414&amp;h=194&amp;f=png&amp;s=39251" alt=""></p><h3 id="exchange"><a href="#exchange" class="headerlink" title="exchange"></a>exchange</h3><p>exchange 方法和上述这些方法差别在于需要多一个请求类型的参数：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877c1ee29bf31?w=1556&amp;h=194&amp;f=png&amp;s=50603" alt=""></p><h2 id="AsyncRestTemplate-异步客户端"><a href="#AsyncRestTemplate-异步客户端" class="headerlink" title="AsyncRestTemplate 异步客户端"></a>AsyncRestTemplate 异步客户端</h2><p>RestTemplate的异步实现方式。所涉及到的API和RestTemplate基本一致。区别在于RestTemplate直接返回结果，而AsyncRestTemplate返回的是ListenableFuture。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877cd10d2bb0e?w=1372&amp;h=716&amp;f=png&amp;s=139753" alt=""></p><h2 id="RestTemplate-拦截器"><a href="#RestTemplate-拦截器" class="headerlink" title="RestTemplate 拦截器"></a>RestTemplate 拦截器</h2><p>Spring提供了ClientHttpRequestInterceptor和AsyncClientHttpRequestInterceptor两个接口，分别可以对RestTemplate和AsyncRestTemplate发起的请求进行拦截，并在其被发送至服务端之前修改请求或是增强相应的信息。</p><ul><li><p>ClientHttpRequestInterceptor 拦截 RestTemplate<br><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877d579c56a0c?w=1380&amp;h=368&amp;f=png&amp;s=83172" alt=""></p></li><li><p>AsyncClientHttpRequestInterceptor 拦截AsyncRestTemplate<br><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877e0ff73a952?w=1548&amp;h=366&amp;f=png&amp;s=93632" alt=""></p></li></ul><p>设置拦截器就是通过提供的 setInterceptors 设置即可：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877ef7ccd132e?w=1368&amp;h=492&amp;f=png&amp;s=112979" alt=""></p><h2 id="自定义-ResponseErrorHandler"><a href="#自定义-ResponseErrorHandler" class="headerlink" title="自定义 ResponseErrorHandler"></a>自定义 ResponseErrorHandler</h2><p>ResponseErrorHandler 接口定义了当response发生错误时需要进行的操作。这里我们自定义一个CustomResponseErrorHandler，当返回的code不是200时，就表示执行出错了。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668fe76528a5659?w=1560&amp;h=630&amp;f=png&amp;s=146140" alt=""></p><p>设置 ResponseErrorHandler：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668fe8f603b0760?w=1574&amp;h=338&amp;f=png&amp;s=117473" alt=""></p><p>执行结果：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668fe97d6c85821?w=2672&amp;h=348&amp;f=png&amp;s=173962" alt=""></p><h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><p>下面来梳理下 RestTemplate 中请求处理的流程。下图中 XXXX 表示我们调用的 API 方法。大体流程就是：api 内部做一些请求相关的处理封装，然后交给 execute 方法执行，最后真正处理则是在 doExecute 方法中完成。<br><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668f78ce0e92b1e?w=294&amp;h=248&amp;f=png&amp;s=5157" alt=""></p><p>下面以 getForEntity 方法的执行过程来分析：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668f7c60711d002?w=1452&amp;h=248&amp;f=png&amp;s=68902" alt=""></p><p>getForEntity 方法：</p><ul><li>基于给定响应类型，返回一个请求回调实现，准备请求。</li><li>基于给定响应类型，返回 ResponseEntity 的响应提取器。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668f7e5d410b82e?w=1570&amp;h=246&amp;f=png&amp;s=66950" alt=""><br>execute 方法：</p><ul><li>这个方法里面是对url进行urlencode编码处理的，统一转为URL。这里我们也可以手动把参数进行网络编码。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668f8294bc82e81?w=1516&amp;h=886&amp;f=png&amp;s=207580" alt=""><br>doExecute是请求真正处理的方法，这里来重点看下这个方法的执行过程：</p><ul><li>createRequest</li><li>doWithRequest</li><li>execute</li><li>handleResponse</li></ul><h4 id="1、createRequest"><a href="#1、createRequest" class="headerlink" title="1、createRequest"></a>1、createRequest</h4><p>这个方法的作用就是创建一个 ClientHttpRequest 对象。RestTemplate集成了 HttpAccessor这个抽象类，创建ClientHttpRequest的过程就是在其父类HttpAccessor中通过默认的 ClientHttpRequestFactory 实现类 SimpleClientHttpRequestFactory 完成具体的请求创建。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668f8a70f4e1664?w=1462&amp;h=370&amp;f=png&amp;s=91033" alt=""></p><ul><li><p>1、创建 java.net.HttpURLConnection 对象</p></li><li><p>2、设置 connection，包括 connectTimeout、setDoInput 等。</p></li><li><p>3、bufferRequestBody 用于标志是否使用缓存流的形式，默认是 true。缺点是当发送大量数据时，比如 put/post，存在内存消耗严重。该值可以通过 SimpleClientHttpRequestFactory#setBufferRequestBody来修改。</p></li></ul><blockquote><p>不同版本的变更还是比较大的，大家在阅读源码时，还是从最新的代码来看。</p></blockquote><h4 id="2、doWithRequest"><a href="#2、doWithRequest" class="headerlink" title="2、doWithRequest"></a>2、doWithRequest</h4><p>RequestCallback 封装了请求体和请求头对象。这里会遍历所有的 HttpMessageConverter，解析成所有支持的MediaType，放在allSupportedMediaTypes中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getHeaders().setAccept(allSupportedMediaTypes);</span><br></pre></td></tr></table></figure><p>RestTemplate中对应了两个内部类的实现：</p><ul><li><p>AcceptHeaderRequestCallback.doWithRequest的处理。<br>发送请求时，Http头部需要设置Accept字段，该字段表明了发送请求的这方接受的媒体类型（消息格式），也是响应端要返回的信息的媒体类型（消息格式）。<br>根据postForEntity方法的第三个参数responseType，程序将选择适合的解析器XXXConverter，并依据该解析器找出所有支持的媒体类型。</p><ul><li>HttpEntityRequestCallback.doWithRequest的处理。<br>如果是POST请求并且消息体存在时，除了设置Accept字段，还可能需要设置Content-Type字段，该字段表明了所发送请求的媒体类型（消息格式），也是响应端接受的媒体类型（消息格式）。<br>根据postForEntity方法的第二个参数request，程序将选择适合的解析器XXXConverter，将请求消息写入输出流。</li></ul></li></ul><h4 id="3、execute"><a href="#3、execute" class="headerlink" title="3、execute"></a>3、execute</h4><p>这里会把请求头/体封装到connect，然后发送请求。跟踪 execute 方法执行，定位到SimpleBufferingClientHttpRequest#executeInternal方法：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668fdccb7601b1f?w=1570&amp;h=612&amp;f=png&amp;s=177702" alt=""><br>这里是使用实例 SimpleBufferingClientHttpRequest 封装请求体和请求头。从代码中可以看到：</p><ul><li>delete 时通过前面设置的 DoOutput参数和是否可以设置输出流来判断是否需要发送请求体如果是 delete 请求，那么很明显 DoOutput = false，不会有封装请求体的过程，即不执行FileCopyUtils.copy(bufferedOutput, this.connection.getOutputStream())。</li></ul><h4 id="4、handleResponse"><a href="#4、handleResponse" class="headerlink" title="4、handleResponse"></a>4、handleResponse</h4><p>最后就是 response 的解析了，从代码来看，主要还是 Error 的解析。这里的ErrorHandler我们前面也提到，可以通过实现 ResponseErrorHandler 来自定义 异常处理。<br><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668fe3ae92b7ead?w=1532&amp;h=502&amp;f=png&amp;s=109859" alt=""></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇先介绍了RestTemplate的API使用，挑了几个介绍了下，更多使用细节还是要针对不同的场景来决定。接着对拦截器，异步RestTemplate以及错误处理器做了简单的介绍并给出了案例。最后分析了下RestTemplate的执行流程，篇幅原因执行流程部分只是大概捋了捋，其中还是很多细节有时间再补充，这部分主要就是看底层是如何通信的，已经请求参数的传递等。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> web </tag>
            
            <tag> restful </tag>
            
            <tag> 聊一聊 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>聊一聊 Spring 中的扩展机制(二) - NamespaceHandler</title>
      <link href="/2018/11/10/springextentiontwo/"/>
      <url>/2018/11/10/springextentiontwo/</url>
      
        <content type="html"><![CDATA[<p>前一篇 <a href="https://juejin.im/post/5b7964d6f265da43412866c7" target="_blank" rel="noopener">聊一聊 Spring 中的扩展机制（一）</a> 中聊到了<code>ApplicationListener</code>、<code>ApplicationContextAware</code>、<code>BeanFactoryAware</code>三种机制。本篇将介绍 <code>NamespaceHandler</code> 的扩展使用。</p><p>相信很多小伙伴对于这几个类都不陌生，基本基于<code>java</code>实现的<code>RPC</code>框架都会使用，比如 <a href="https://github.com/apache/incubator-dubbo" target="_blank" rel="noopener">Dubbo</a> , <a href="https://github.com/alipay/sofa-rpc" target="_blank" rel="noopener">SOFARpc</a> 等。本文先从几个小<code>demo</code>入手，了解下基本的概念和编程流程，然后分析下 <code>SOFARpc</code> 中是如何使用的。</p><h2 id="NamespaceHandler"><a href="#NamespaceHandler" class="headerlink" title="NamespaceHandler"></a>NamespaceHandler</h2><p><code>NamespaceHandler</code> 是 <code>Spring</code> 提供的 命名空间处理器。下面这张图中，除了乱入的本篇 <code>demo</code> 中涉及到的 <code>BridgeNameSpaceHandler</code> 之外，其他均为 <code>Spring</code> 自身提供的。<br><img src="https://user-gold-cdn.xitu.io/2018/8/26/1657680c24505dbe?w=2376&amp;h=488&amp;f=png&amp;s=307869" alt=""><br>因为这里我只引入了 <code>bean</code> 和 <code>context</code> 依赖，所以这也仅仅是一部分。图中我们常用的应该算是 <code>AopNamespaceHandler</code>。</p><p>我们使用基于<code>xml</code>的<code>spring</code>配置时，可能需要配置如<code>&lt;aop:config /&gt;</code>这样的标签，在配置这个标签之前，通常我们需要引入这个<code>aop</code>所在的命名空间：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string"> http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>关于AOP 可以了解下 <a href="https://juejin.im/post/5b1ca657f265da6e5a205c45" target="_blank" rel="noopener">聊一聊 AOP ：表现形式与基础概念</a>，这里不过多解释，下面就按照 <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#xml-custom" target="_blank" rel="noopener">官方文档的流程</a> 来写一个自定义<code>xml</code>，最终效果如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bridge:application</span> <span class="attr">id</span>=<span class="string">"bridgeTestApplication"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">name</span>=<span class="string">"bridgeTestApplication"</span>  </span></span><br><span class="line"><span class="tag">                    <span class="attr">version</span>=<span class="string">"1.0"</span> </span></span><br><span class="line"><span class="tag">                    <span class="attr">organization</span>=<span class="string">"bridge.glmapper.com"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">owner</span>=<span class="string">"leishu@glmapper"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1、定义-xsd-文件"><a href="#1、定义-xsd-文件" class="headerlink" title="1、定义 xsd 文件"></a>1、定义 xsd 文件</h3><p>关于 <code>xsd</code> 文件的语法规则不在本篇范围之内，有兴趣的同学可以自行<code>google</code>。<br>下面这个文件很简单，定义的<code>element</code> name 为<code>application</code>，对应于 <code>bridge:application</code>中的<code>application</code>。<code>attribute</code>就是上面效果展示中对应的几个属性名。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:schema</span> <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:beans</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:tool</span>=<span class="string">"http://www.springframework.org/schema/tool"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns</span>=<span class="string">"http://bridge.glmapper.com/schema/bridge"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetNamespace</span>=<span class="string">"http://bridge.glmapper.com/schema/bridge"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:import</span> <span class="attr">namespace</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:complexType</span> <span class="attr">name</span>=<span class="string">"applicationType"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"xsd:ID"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"xsd:string"</span> <span class="attr">use</span>=<span class="string">"required"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">"version"</span> <span class="attr">type</span>=<span class="string">"xsd:string"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">"owner"</span> <span class="attr">type</span>=<span class="string">"xsd:string"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">"organization"</span> <span class="attr">type</span>=<span class="string">"xsd:string"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">"application"</span> <span class="attr">type</span>=<span class="string">"applicationType"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、编写-NamespaceHandler"><a href="#2、编写-NamespaceHandler" class="headerlink" title="2、编写 NamespaceHandler"></a>2、编写 NamespaceHandler</h3><blockquote><p>In addition to the schema, we need a NamespaceHandler that will parse all elements of this specific namespace Spring encounters while parsing configuration files.</p></blockquote><p>用编写的这个 <code>NamespaceHandler</code> 来解析配置文件。</p><p>具体说来<code>NamespaceHandler</code>会根据<code>schema</code>和节点名找到某个<code>BeanDefinitionParser</code>，然后由<code>BeanDefinitionParser</code>完成具体的解析工作。</p><p><code>Spring</code>提供了默认实现类<code>NamespaceHandlerSupport</code>和<code>AbstractSingleBeanDefinitionParser</code>，最简单的方式就是去继承这两个类。</p><p>这里通过继承 <code>NamespaceHandlerSupport</code> 这个抽象类来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"application"</span>, </span><br><span class="line">        <span class="keyword">new</span> ApplicationBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里实际上只是注册了一个解析器，具体的 <code>BeanDefinitionParser</code> 才是将 <code>XML</code>元素映射到特定<code>bean</code>的。</p><h3 id="3、编写-BeanDefinitionParser"><a href="#3、编写-BeanDefinitionParser" class="headerlink" title="3、编写 BeanDefinitionParser"></a>3、编写 BeanDefinitionParser</h3><p>这里直接通过实现<code>BeanDefinitionParser</code>接口的方式定义我们的<code>BeanDefinitionParser</code>实现类。关于<code>AbstractSingleBeanDefinitionParser</code> 的使用在 <code>SPFARpc</code> 中会涉及到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//beanDefinition</span></span><br><span class="line">        RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">        beanDefinition.setBeanClass(ApplicationConfig.class);</span><br><span class="line">        beanDefinition.setLazyInit(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//解析id</span></span><br><span class="line">        String id = element.getAttribute(<span class="string">"id"</span>);</span><br><span class="line">        beanDefinition.getPropertyValues().add(<span class="string">"id"</span>, id);</span><br><span class="line">        <span class="comment">//解析name</span></span><br><span class="line">        beanDefinition.getPropertyValues().add(<span class="string">"name"</span>,</span><br><span class="line">        element.getAttribute(<span class="string">"name"</span>));</span><br><span class="line">        <span class="comment">//解析version</span></span><br><span class="line">        beanDefinition.getPropertyValues().add(<span class="string">"version"</span>,</span><br><span class="line">        element.getAttribute(<span class="string">"version"</span>));</span><br><span class="line">        <span class="comment">//owner</span></span><br><span class="line">        beanDefinition.getPropertyValues().add(<span class="string">"owner"</span>,</span><br><span class="line">        element.getAttribute(<span class="string">"owner"</span>));</span><br><span class="line">        <span class="comment">//organization</span></span><br><span class="line">        beanDefinition.getPropertyValues().add(<span class="string">"organization"</span>,</span><br><span class="line">        element.getAttribute(<span class="string">"organization"</span>));</span><br><span class="line">    </span><br><span class="line">        parserContext.getRegistry().registerBeanDefinition(id, beanDefinition);</span><br><span class="line">        <span class="keyword">return</span> beanDefinition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们需要了解的是开始解析自定义标签的时候，是通过<code>BeanDefinitionParserDelegate-&gt;parseCustomElement</code>方法来处理的，如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/26/16576a988554f2e9?w=2046&amp;h=568&amp;f=png&amp;s=172310" alt=""></p><p>通过<code>ele</code>元素拿到当前<code>namespaceUri</code>，也就是在<code>xsd</code>中定义的命名空间，接着委托给 <code>DefaultNamespaceResolver</code> 得到具体的<code>handler</code>（<code>BridgenamspaceHandler</code>） ,<br>然后执行<code>parse</code> 解析。</p><h3 id="4、配置-spring-handlers-和-spring-schmas"><a href="#4、配置-spring-handlers-和-spring-schmas" class="headerlink" title="4、配置 spring.handlers 和 spring.schmas"></a>4、配置 spring.handlers 和 spring.schmas</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http\://bridge.glmapper.com/schema/bridge=</span><br><span class="line">com.glmapper.extention.namespacehandler.BridgeNamespaceHandler</span><br><span class="line"></span><br><span class="line">http\://bridge.glmapper.com/schema/bridge.xsd=META-INF/bridge.xsd</span><br></pre></td></tr></table></figure><p>配置这个其实是为了让<code>Spring</code>在解析<code>xml</code>的时候能够感知到我们的自定义元素，我们需要把<code>NamespaceHandler</code>和<code>xsd</code>文件放到位于META-INF目录下的<code>spring.handlers</code> 和 <code>spring.schmas</code>文件中。这样就可以在<code>spring</code>配置文件中使用我们自定义的标签了。如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:bridge</span>=<span class="string">"http://bridge.glmapper.com/schema/bridge"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://bridge.glmapper.com/schema/bridge</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://bridge.glmapper.com/schema/bridge.xsd"</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">    <span class="tag">&lt;<span class="name">bridge:application</span> <span class="attr">id</span>=<span class="string">"bridgeTestApplication"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">name</span>=<span class="string">"bridgeTestApplication"</span>  </span></span><br><span class="line"><span class="tag">                    <span class="attr">version</span>=<span class="string">"1.0"</span> </span></span><br><span class="line"><span class="tag">                    <span class="attr">organization</span>=<span class="string">"bridge.glmapper.com"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">owner</span>=<span class="string">"leishu@glmapper"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>验证下从容器中获取我们的<code>bean</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span></span><br><span class="line">    ClassPathXmlApplicationContext(<span class="string">"classpath:bean.xml"</span>);</span><br><span class="line">    </span><br><span class="line">    ApplicationConfig applicationConfig = (ApplicationConfig)</span><br><span class="line">    applicationContext.getBean(<span class="string">"bridgeTestApplication"</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"applicationConfig = "</span>+applicationConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">applicationConfig = ApplicationConfig &#123;</span><br><span class="line">    id=bridgeTestApplication, </span><br><span class="line">    name=&apos;bridgeTestApplication&apos;, </span><br><span class="line">    version=&apos;1.0&apos;, </span><br><span class="line">    owner=&apos;leishu@glmapper&apos;, </span><br><span class="line">    organization=&apos;bridge.glmapper.com&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整体来看，如果我们要实现自己的 <code>xml</code> 标签，仅需完成以下几步即可：</p><ul><li>1、定义 xsd 文件</li><li>2、编写 NamespaceHandler </li><li>3、编写 BeanDefinitionParser</li><li>4、配置 spring.handlers 和 spring.schmas</li></ul><h2 id="SOFARpc-中使用分析"><a href="#SOFARpc-中使用分析" class="headerlink" title="SOFARpc 中使用分析"></a>SOFARpc 中使用分析</h2><p><code>SOFARpc</code> 中的 <code>rpc.xsd</code> 文件是集成在 <code>sofaboot.xsd</code> 文件中的，详细可见：<a href="https://github.com/alipay/sofa-boot" target="_blank" rel="noopener">sofa-boot</a></p><p><img src="https://user-gold-cdn.xitu.io/2018/8/26/16576c06a6b70603?w=1172&amp;h=420&amp;f=png&amp;s=60454" alt=""></p><blockquote><p><code>xsd</code> 文件这里不贴了，有点长 </p></blockquote><h3 id="spring-handlers-和-spring-schmas"><a href="#spring-handlers-和-spring-schmas" class="headerlink" title="spring.handlers 和 spring.schmas"></a>spring.handlers 和 spring.schmas</h3><p>先看下 <code>spring.handlers</code> 和 <code>spring.schmas</code> 配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http\:<span class="comment">//sofastack.io/schema/sofaboot=</span></span><br><span class="line">com.alipay.sofa.infra.config.spring.namespace.handler.SofaBootNamespaceHandler</span><br><span class="line"></span><br><span class="line">http\:<span class="comment">//sofastack.io/schema/sofaboot.xsd=</span></span><br><span class="line">META-INF/com/alipay/sofa/infra/config/spring/namespace/schema/sofaboot.xsd</span><br><span class="line"></span><br><span class="line">http\:<span class="comment">//sofastack.io/schema/rpc.xsd=</span></span><br><span class="line">META-INF/com/alipay/sofa/infra/config/spring/namespace/schema/rpc.xsd</span><br></pre></td></tr></table></figure><p>从 <code>spring.handlers</code>找到 <code>NamespaceHandler</code> : <code>SofaBootNamespaceHandler</code>。</p><h3 id="SofaBootNamespaceHandler"><a href="#SofaBootNamespaceHandler" class="headerlink" title="SofaBootNamespaceHandler"></a>SofaBootNamespaceHandler</h3><p>源码如下，这里看出来，并不是像上面我们自己写的那种方式那样，会有一个 <code>BeanDefinitionParser</code>。这里其实设计的很巧妙，通过<code>spi</code>的方式来载入具体的<code>BeanDefinitionParser</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaBootNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServiceLoader&lt;SofaBootTagNameSupport&gt; serviceLoaderSofaBoot =</span><br><span class="line">        ServiceLoader.load(SofaBootTagNameSupport.class);</span><br><span class="line">        <span class="comment">//SOFABoot</span></span><br><span class="line">        <span class="keyword">for</span> (SofaBootTagNameSupport tagNameSupport : serviceLoaderSofaBoot) &#123;</span><br><span class="line">            <span class="keyword">this</span>.registerTagParser(tagNameSupport);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerTagParser</span><span class="params">(SofaBootTagNameSupport tagNameSupport)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(tagNameSupport <span class="keyword">instanceof</span> BeanDefinitionParser)) &#123;</span><br><span class="line">            <span class="comment">// log</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String tagName = tagNameSupport.supportTagName();</span><br><span class="line">        registerBeanDefinitionParser(tagName, (BeanDefinitionParser)</span><br><span class="line">        tagNameSupport);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看出有 <code>ReferenceDefinitionParser</code> 和 <code>ServiceDefinitionParser</code> 两个解析类，分别对应服务引用和服务暴露。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/26/16576cfad71411d6?w=2626&amp;h=702&amp;f=png&amp;s=279969" alt=""></p><p>下面以<code>ReferenceDefinitionParser</code>为例，先看下它的类图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/26/16576da5390f9128?w=1514&amp;h=904&amp;f=png&amp;s=90864" alt=""></p><p>解析工作都是在 <code>AbstractContractDefinitionParser</code> 类中完成， <code>ReferenceDefinitionParser</code> 自己只是做了一些特殊处理【jvm-first，jvm服务】。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇通过 <code>NamespaceHandler</code> 了解了如何去编写我们自定义的xml标签，从<code>NamespaceHandler</code>的角度可以很好的理解一些 <code>RPC</code> 框架中最基础的基于<code>xml</code> 方式的服务引用和暴露的实现思路。另外通过分析 <code>SOFARpc</code> ，也了解了在实际的工程组件中对于<code>NamespaceHandler</code>的扩展使用。</p><p>本文代码：<a href="https://github.com/glmapper/glmapper-spring-extention" target="_blank" rel="noopener">glmapper-spring-extention</a></p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 聊一聊 </tag>
            
            <tag> spring 扩展机制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>聊一聊 Spring 中的扩展机制（一）</title>
      <link href="/2018/11/10/springextentionone/"/>
      <url>/2018/11/10/springextentionone/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前 Spring 源码系列文章中大多是底层源码的分析，通过源码可以让我们能够清晰的了解 Spring 到底是什么，而不是停留于表面的认知。比如当我们要使用 @Autowired 注解时，可以拿到我们想要的 bean ,但是为什么可以是值得思考的。– 关于阅读源码</p></blockquote><p>Spring源码的阅读结合日常的使用，可以帮助我们更好的掌握这个庞大的技术体系，实际的开发工作中有很多地方可以借鉴它的一些思想来帮助我们更好的实现自己的业务逻辑。本篇将以扩展点为切入点，来了解下在Spring生命周期中扩展Spring中的Bean功能。</p><h2 id="ApplicationListener-扩展"><a href="#ApplicationListener-扩展" class="headerlink" title="ApplicationListener 扩展"></a>ApplicationListener 扩展</h2><p><code>ApplicationListener</code> 其实是 <code>spring</code> 事件通知机制中核心概念；在java的事件机制中，一般会有三个概念：</p><ul><li>event object : 事件对象</li><li>event source ：事件源，产生事件的地方</li><li>event listener ：监听事件并处理</li></ul><p><code>ApplicationListener</code> 继承自 <code>java.util.EventListener</code> ，提供了对于<code>Spring</code>中事件机制的扩展。</p><p><code>ApplicationListener</code> 在实际的业务场景中使用的非常多，比如我一般喜欢在容器初始化完成之后来做一些资源载入或者一些组件的初始化。这里的容器指的就是<code>Ioc</code>容器，对应的事件是<code>ContextRefreshedEvent</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartApplicationListener</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class"><span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent</span></span></span><br><span class="line"><span class="function"><span class="params">    contextRefreshedEvent)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//初始化资源文件</span></span><br><span class="line">       <span class="comment">//初始化组件 如：cache</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码会在容器刷新完成之后来做一些事情。下面通过自定义事件来看看怎么使用，在看具体的<code>demo</code>之前，先来了解下一些关注点。</p><p>日常工作了，如果要使用 <code>Spring</code> 事件传播机制，我们需要关注的点有以下几点：</p><ul><li>事件类，这个用来描述事件本身一些属性，一般继承<code>ApplicationEvent</code></li><li>监听类，用来监听具体的事件并作出响应。需要实现 <code>ApplicationListener</code> 接口</li><li>事件发布类，需要通过这个类将时间发布出去，这样才能被监听者监听到，需要实现<code>ApplicationContextAware</code>接口。</li><li>将事件类和监听类交给<code>Spring</code>容器。</li></ul><p>那么下面就按照这个思路来看下<code>demo</code>的具体实现。</p><h3 id="事件类：UserRegisterEvent"><a href="#事件类：UserRegisterEvent" class="headerlink" title="事件类：UserRegisterEvent"></a>事件类：UserRegisterEvent</h3><p><code>UserRegisterEvent</code> ，用户注册事件；这里作为事件对象，继承自 <code>ApplicationEvent</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 用户注册事件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/7/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRegisterEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserRegisterEvent</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserRegisterEvent</span><span class="params">(Object o, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(o);</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件发布类：UserService"><a href="#事件发布类：UserService" class="headerlink" title="事件发布类：UserService"></a>事件发布类：UserService</h3><p>用户注册服务，这里需要在用户注册时将注册事件发布出去，所以通过实现<code>ApplicationEventPublisherAware</code>接口，使<code>UserService</code>具有事件发布能力。</p><blockquote><p>ApplicationEventPublisherAware:发布事件，也就是把某个事件告诉的所有与这个事件相关的监听器。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 用户注册服务，实现ApplicationEventPublisherAware接口</span></span><br><span class="line"><span class="comment"> ，表明本身具有事件发布能力</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/7/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher</span></span></span><br><span class="line"><span class="function"><span class="params">    applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用户："</span> + name + <span class="string">" 已注册！"</span>);</span><br><span class="line">        applicationEventPublisher.publishEvent(<span class="keyword">new</span> UserRegisterEvent(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>UserService</code>实际上是作为事件源存在的，通过<code>register</code>将用户注册事件传播出去。那么下面就是需要定义如何来监听这个事件，并且将事件进行消费处理掉，这里就是通过<code>ApplicationListener</code>来完成。</p><h3 id="监听类：BonusServerListener"><a href="#监听类：BonusServerListener" class="headerlink" title="监听类：BonusServerListener"></a>监听类：BonusServerListener</h3><p>当用户触发注册操作时，向积分服务发送消息，为用户初始化积分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: BonusServerListener</span></span><br><span class="line"><span class="comment"> 积分处理，当用户注册时，给当前用户增加初始化积分</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/7/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BonusServerListener</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class"><span class="title">ApplicationListener</span>&lt;<span class="title">UserRegisterEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(UserRegisterEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"积分服务接到通知，给 "</span> + event.getSource() +</span><br><span class="line">        <span class="string">" 增加积分..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册到容器中"><a href="#注册到容器中" class="headerlink" title="注册到容器中"></a>注册到容器中</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.glmapper.extention.UserService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bonusServerListener"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.glmapper.extention.BonusServerListener"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="客户端类"><a href="#客户端类" class="headerlink" title="客户端类"></a>客户端类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 客户端类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/7/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context =<span class="keyword">new</span> </span><br><span class="line">        ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        UserService userService = (UserService)</span><br><span class="line">        context.getBean(<span class="string">"userService"</span>);</span><br><span class="line">        <span class="comment">//注册事件触发</span></span><br><span class="line">        userService.register(<span class="string">"glmapper"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端类中，注册一个<code>name</code>为<code>glmapper</code>的用户，执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户：glmapper 已注册！</span><br><span class="line">积分服务接到通知，给 glmapper 增加积分...</span><br></pre></td></tr></table></figure><p>现在来考虑另外一个问题，增加一个功能，用户注册之后给用户发一个邮件。这个其实就是增加一个监听类就可以，前提是这个监听者是监听当前事件的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 邮件服务监听器，当监听到用户的注册行为时，</span></span><br><span class="line"><span class="comment">    给用户发送邮件通知</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/7/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailServerListener</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class"><span class="title">ApplicationListener</span>&lt;<span class="title">UserRegisterEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(UserRegisterEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"邮件服务接到通知，给 "</span> + event.getSource() +</span><br><span class="line">        <span class="string">" 发送邮件..."</span>);</span><br></pre></td></tr></table></figure><p>这里如果将<code>UserRegisterEvent</code>换成<code>UserLoginEvent</code>，那么邮件服务将不会有任何行为。</p><p>增加发送邮件监听类之后的执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用户：glmapper 已注册！</span><br><span class="line">邮件服务接到通知，给 glmapper 发送邮件...</span><br><span class="line">积分服务接到通知，给 glmapper 增加积分...</span><br></pre></td></tr></table></figure></p><p><code>Spring</code> 的事件传播机制是基于观察者模式（<code>Observer</code>）实现的，它可以将 <code>Spring Bean</code>的改变定义为事件 <code>ApplicationEvent</code>，通过 <code>ApplicationListener</code> 监听 <code>ApplicationEvent</code> 事件，一旦<code>Spring Bean</code> 使用 <code>ApplicationContext.publishEvent( ApplicationEvent event )</code>发布事件后，<code>Spring</code> 容器会通知注册在 容器中所有 <code>ApplicationListener</code> 接口的实现类，最后 <code>ApplicationListener</code> 接口实现类判断是否处理刚发布出来的 <code>ApplicationEvent</code> 事件。</p><h2 id="ApplicationContextAware-扩展"><a href="#ApplicationContextAware-扩展" class="headerlink" title="ApplicationContextAware 扩展"></a>ApplicationContextAware 扩展</h2><p><code>ApplicationContextAware</code>中只有一个<code>setApplicationContext</code>方法。实现了<code>ApplicationContextAware</code>接口的类，可以在该<code>Bean</code>被加载的过程中获取<code>Spring</code>的应用上下文<code>ApplicationContext</code>，通过<code>ApplicationContext</code>可以获取<br><code>Spring</code>容器内的很多信息。</p><p>这种一般在需要手动获取<code>Bean</code>的注入实例对象时会使用到。下面通过一个简单的<code>demo</code>来了解下。</p><p><code>GlmapperApplicationContext</code> 持有<code>ApplicationContext</code>对象，通过实现 <code>ApplicationContextAware</code>接口来给<code>ApplicationContext</code>做赋值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: GlmapperApplicationContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/7/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperApplicationContext</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class"><span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  ApplicationContext applicationContext;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext</span></span></span><br><span class="line"><span class="function"><span class="params">    applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.applicationContext=applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationContext <span class="title">getApplicationContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要手动获取的<code>bean</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: HelloService</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/7/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Glmapper"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在配置文件中进行配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloService"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"com.glmapper.extention.applicationcontextaware.HelloService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"glmapperApplicationContext"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"com.glmapper.extention.applicationcontextaware.GlmapperApplicationContext"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>客户端类调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span></span><br><span class="line">        ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        </span><br><span class="line">        HelloService helloService = (HelloService)</span><br><span class="line">        context.getBean(<span class="string">"helloService"</span>);</span><br><span class="line">        helloService.sayHello();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里通过实现ApplicationContextAware接口的类来完成bean的获取</span></span><br><span class="line">        GlmapperApplicationContext glmapperApplicationContext =</span><br><span class="line">        (GlmapperApplicationContext) context.getBean(<span class="string">"glmapperApplicationContext"</span>);</span><br><span class="line">        </span><br><span class="line">        ApplicationContext applicationContext =</span><br><span class="line">        glmapperApplicationContext.getApplicationContext();</span><br><span class="line">        </span><br><span class="line">        HelloService glmapperHelloService = (HelloService)</span><br><span class="line">        applicationContext.getBean(<span class="string">"helloService"</span>);</span><br><span class="line">        </span><br><span class="line">        glmapperHelloService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BeanFactoryAware-扩展"><a href="#BeanFactoryAware-扩展" class="headerlink" title="BeanFactoryAware 扩展"></a>BeanFactoryAware 扩展</h2><p>我们知道<code>BeanFactory</code>是整个<code>Ioc</code>容器最顶层的接口，它规定了容器的基本行为。实现<code>BeanFactoryAware</code>接口就表明当前类具体<code>BeanFactory</code>的能力。</p><p><code>BeanFactoryAware</code>接口中只有一个<code>setBeanFactory</code>方法。实现了<code>BeanFactoryAware</code>接口的类，可以在该<code>Bean</code>被加载的过程中获取加载该<code>Bean</code>的<code>BeanFactory</code>，同时也可以获取这个<code>BeanFactory</code>中加载的其它<code>Bean</code>。</p><p>来想一个问题，我们为什么需要通过<code>BeanFactory</code>的<code>getBean</code>来获取<code>Bean</code>呢？Spring已经提供了很多便捷的注入方式，那么通过<code>BeanFactory</code>的<code>getBean</code>来获取<code>Bean</code>有什么好处呢？来看一个场景。</p><p>现在有一个<code>HelloService</code>，这个<code>HelloService</code>就是打招呼，我们需要通过不同的语言来实现打招呼，比如用中文，用英文。一般的做法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//英文打招呼实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperHelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Glmapper"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中文打招呼实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeishuHelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"你好，磊叔"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端类来调用务必会出现下面的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (condition==&quot;英文&quot;)&#123;</span><br><span class="line">    glmapperHelloService.sayHello();</span><br><span class="line">&#125;</span><br><span class="line">if (condition==&quot;中文&quot;)&#123;</span><br><span class="line">    leishuHelloService.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有一天，老板说我们要做国际化，要实现全球所有的语言来问候。你是说好的，还是控制不住要动手呢？</p><p>那么有没有什么方式可以动态的去决定我的客户端类到底去调用哪一种语言实现，而不是用过if-else方式来罗列呢？是的，对于这些需要动态的去获取对象的场景，<code>BeanFactoryAware</code>就可以很好的搞定。OK，来看代码改造：</p><p>引入<code>BeanFactoryAware</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 实现BeanFactoryAware ，让当前bean本身具有 BeanFactory 的能力</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实现 BeanFactoηAware 接口的 bean 可以直接访问 Spring 容器，被容器创建以后，</span></span><br><span class="line"><span class="comment"> * 它会拥有一个指向 Spring</span></span><br><span class="line"><span class="comment"> 容器的引用，可以利用该bean根据传入参数动态获取被spring工厂加载的bean</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/7/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperBeanFactory</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">    BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory=beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供一个execute 方法来实现不同业务实现类的调度器方案。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String beanName)</span></span>&#123;</span><br><span class="line">        HelloService helloService=(HelloService)</span><br><span class="line">        beanFactory.getBean(beanName);</span><br><span class="line">        helloService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里为了逻辑方便理解，再加入一个<code>HelloFacade</code> 类,这个类的作用就是持有一个<code>BeanFactoryAware</code>的实例对象，然后通过<code>HelloFacade</code>实例对象的方法来屏蔽底层<code>BeanFactoryAware</code>实例的实现细节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloFacade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GlmapperBeanFactory glmapperBeanFactory;</span><br><span class="line">    <span class="comment">//调用glmapperBeanFactory的execute方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String beanName)</span></span>&#123;</span><br><span class="line">        glmapperBeanFactory.execute(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGlmapperBeanFactory</span><span class="params">(GlmapperBeanFactory beanFactory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.glmapperBeanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span></span><br><span class="line">        ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        </span><br><span class="line">        HelloFacade helloFacade = (HelloFacade)</span><br><span class="line">        context.getBean(<span class="string">"helloFacade"</span>);</span><br><span class="line"></span><br><span class="line">        GlmapperBeanFactory glmapperBeanFactory = (GlmapperBeanFactory)</span><br><span class="line">        context.getBean(<span class="string">"glmapperBeanFactory"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里其实可以不通过set方法注入到helloFacade中，</span></span><br><span class="line">        <span class="comment">//可以在helloFacade中通过autowired</span></span><br><span class="line">        <span class="comment">//注入；这里在使用main方法来执行验证，所以就手动set进入了</span></span><br><span class="line">        helloFacade.setGlmapperBeanFactory(glmapperBeanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个只需要传入不同HelloService的实现类的beanName，</span></span><br><span class="line">        <span class="comment">//就可以执行不同的业务逻辑</span></span><br><span class="line">        helloFacade.sayHello(<span class="string">"glmapperHelloService"</span>);</span><br><span class="line">        helloFacade.sayHello(<span class="string">"leishuHelloService"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在调用者（客户端）类中，只需要通过一个<code>beanName</code>就可以实现不同实现类的切换，而不是通过一堆if-else来判断。另外有的小伙伴可能会说，程序怎么知道用哪个<code>beanName</code>呢？其实这个也很简单，这个参数我们可以通过一些途径来拼接得到，比如使用一个<code>prefix</code>用来指定语言，<code>prefix</code>+<code>HelloService</code>就可以确定唯一的<code>beanName</code>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本来想着在一篇文章里面把扩展点都写一下的，但是实在太长了。后面差不多还有两篇。本系列中所有的<code>demo</code>可以在<code>github</code>获取，也欢迎小伙伴把能够想到的扩展点pr过来。</p><ul><li><a href="https://github.com/glmapper/glmapper-spring-extention" target="_blank" rel="noopener">glmapper-spring-extention</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 聊一聊 </tag>
            
            <tag> spring 事件机制 </tag>
            
            <tag> spring 扩展机制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>：SpringSession系列-集成SpringBoot</title>
      <link href="/2018/11/10/springsessionone/"/>
      <url>/2018/11/10/springsessionone/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>springSession</code>是 <code>spring</code> 旗下的一个项目，把 <code>servlet</code> 容器实现的 <code>httpSession</code>替换为<code>springSession</code>，专注于解决<code>session</code>管理问题。可简单快速且无缝的集成到我们的应用中。本文通过一个案例，使用<code>SpringBoot</code>来集成 <code>SpringSession</code>，并且使用<code>Redis</code>作为存储来实践下<code>SpringSession</code> 的使用。</p></blockquote><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>因为需要使用<code>Redis</code>作为底层<code>Session</code>的存储介质，实现分布式<code>session</code>，因此需要安装<code>Redis</code>。</p><h3 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h3><p>1、从<a href="https://redis.io/" target="_blank" rel="noopener">官网</a>下载最新版的<code>Redis</code></p><p><img src="https://user-gold-cdn.xitu.io/2018/11/3/166d858f1ef7e45c?w=1924&amp;h=1086&amp;f=png&amp;s=334618" alt=""></p><p>2、解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf redis-5.0.0.tar.gz</span><br></pre></td></tr></table></figure><p>3、编译测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make test</span><br></pre></td></tr></table></figure><p>4、编译安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>5、安装问题</p><p>如果您之前安装过，重复安装且没有卸载干净的话，会报下面的错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make[1]: *** [test] Error 1 </span><br><span class="line">make: *** [test] Error 2</span><br></pre></td></tr></table></figure><p>解决这个错误，执行下面的语句即可： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make distclean </span><br><span class="line">make </span><br><span class="line">make test</span><br></pre></td></tr></table></figure><p>正确安装姿势如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/3/166d85fca26e9d51?w=818&amp;h=160&amp;f=png&amp;s=29947" alt=""></p><p>6、启动<code>Redis</code><br>在您的<code>Redis</code>安装目录下，有 <code>redis-server</code> ，执行该脚本命令：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/3/166d861951a63478?w=1710&amp;h=930&amp;f=png&amp;s=1463553" alt=""></p><p>OK，到这里，<code>Redis</code>的安装工作完毕。</p><h3 id="SpringBoot-工程准备"><a href="#SpringBoot-工程准备" class="headerlink" title="SpringBoot 工程准备"></a>SpringBoot 工程准备</h3><p>这里我们直接通过<code>Idea</code>来构建我们的<code>SpringBoot</code>工程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File-&gt;New-&gt;Project : Spring Initializr</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/11/3/166d866832463dfc?w=2880&amp;h=918&amp;f=png&amp;s=255047" alt=""></p><p>OK，<code>SpringBoot</code> 工程准备完毕，这里选择创建的是一个<code>Web</code>工程。</p><h2 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h2><p>集成主要是依赖引入，这里需要<code>redis</code>和<code>session</code>的依赖</p><h3 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--redis 依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--sessions 依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置application-properties"><a href="#配置application-properties" class="headerlink" title="配置application.properties"></a>配置application.properties</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#服务端口</span><br><span class="line">server.port=8080</span><br><span class="line">#redi主机地址</span><br><span class="line">spring.redis.host=localhost</span><br><span class="line">#redis服务端口</span><br><span class="line">spring.redis.port=6379</span><br><span class="line"></span><br><span class="line"># spring session使用存储类型，spirngboot默认就是使用redis方式，如果不想用可以填none。</span><br><span class="line">spring.session.store-type=redis</span><br></pre></td></tr></table></figure><h3 id="在启动类中加入-EnableRedisHttpSession-注解"><a href="#在启动类中加入-EnableRedisHttpSession-注解" class="headerlink" title="在启动类中加入@EnableRedisHttpSession  注解"></a>在启动类中加入@EnableRedisHttpSession  注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootSessionApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootSessionApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>先来编写一个<code>Controller</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SessionController</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: glmapper@leishu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 18/11/3 下午3:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/session"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getSession</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        request.getSession().setAttribute(<span class="string">"userName"</span>, <span class="string">"glmapper"</span>);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"sessionId"</span>, request.getSession().getId());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/get"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String userName = (String) request.getSession().getAttribute(<span class="string">"userName"</span>);</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>启动<code>SpringBoot</code> 工程；然后浏览器中输入地址 <a href="http://localhost:8080/session；" target="_blank" rel="noopener">http://localhost:8080/session；</a></p><p><img src="https://user-gold-cdn.xitu.io/2018/11/3/166d8710aa02ae65?w=1462&amp;h=336&amp;f=png&amp;s=78128" alt=""><br>这里对应执行的是我们上面<code>Controller</code>中的第一个方法<code>getSession</code>，这个方法向<code>session</code>中设置了一个值。</p><p>下面我们执行：<a href="http://localhost:8080/get" target="_blank" rel="noopener">http://localhost:8080/get</a>  这里是从<code>session</code>中取值:</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/3/166d8745a083485e?w=1306&amp;h=238&amp;f=png&amp;s=43662" alt=""></p><p>到此，<code>SpringBoot</code> 整合 <code>SpringSession</code> 的过程就完成了。这里我们只是引入了依赖，然后做了简单的配置，那么我们的请求是如何被 <code>SpringSession</code> 处理的呢？从我们一贯的认知来看，对于基于<code>Servlet</code>规范的容器（<code>SpringBoot</code> 使用的是嵌入式<code>Tomcat</code>）的应用，请求最先被处理的是<code>Filter</code>。我们在基于<code>Spring+SpringMvc</code>这套技术栈开发时,如果我们需要做权限管理，通过会基于<code>Filter</code>或者拦截器。但是这里貌似我们什么也没做，但是请求确实被<code>SpringSession</code>处理了。OK，我们来扒一扒。</p><h2 id="SpringSession-是如何处理请求的？"><a href="#SpringSession-是如何处理请求的？" class="headerlink" title="SpringSession 是如何处理请求的？"></a>SpringSession 是如何处理请求的？</h2><p><img src="https://user-gold-cdn.xitu.io/2018/11/3/166d87c15503e1c0?w=1932&amp;h=628&amp;f=png&amp;s=321163" alt=""><br>上面这张截图想必大家都不陌生，是<code>SpringBoot</code>的启动日志；上图红色框内的是当前应用注册是<code>Filter</code>信息，从这里可以看到有个和 <code>session</code> 有关的<code>Filter：sessionRepositoryFilter</code>；这个<code>bean</code>对应的类是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.session.SessionRepositoryFilterConfiguration.ConditionalOnBean=</span><br><span class="line">org.springframework.session.web.http.SessionRepositoryFilter</span><br></pre></td></tr></table></figure><p>在这里找到了<br><img src="https://user-gold-cdn.xitu.io/2018/11/3/166d8809d67b53a2?w=2812&amp;h=424&amp;f=png&amp;s=291544" alt=""></p><p>这里涉及到<code>SpringBoot</code>的自动配置，从<code>spring-boot-autoconfig</code>包下加载<code>spring-autoconfigure-metadata.properties</code> 配置文件，然后获取所有支持自动配置的信息；<code>SpringSession</code> 也在其中。关于如何加载并且注册不在本文的范畴之内，我们继续来分析<code>SpringSession</code>的处理过程。</p><h2 id="SpringSession-的处理过程"><a href="#SpringSession-的处理过程" class="headerlink" title="SpringSession 的处理过程"></a>SpringSession 的处理过程</h2><p>从上面<code>SpringBoot</code>的启动过程我们找到了处理<code>session</code>的<code>Filter</code>，然后知道了它是通过自动配置的方式被注册到当前的容器并且来处理请求。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order</span>(SessionRepositoryFilter.DEFAULT_ORDER)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionRepositoryFilter</span>&lt;<span class="title">S</span> <span class="keyword">extends</span> <span class="title">Session</span>&gt; </span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br></pre></td></tr></table></figure></p><p>从<code>SessionRepositoryFilter</code>的定义来看：</p><ul><li>1、使用了<code>Order</code>，并且配置了一个很小的值（<code>Integer.MIN_VALUE + 50</code>），以此来确保<code>session</code>的<code>Filter</code>在<code>Filter</code>链中被优先执行。</li><li>2、集成了<code>OncePerRequestFilter</code>，确保在一次请求只通过一次<code>filter</code>，而不需要重复执行</li></ul><p>为什么 <code>session</code> 的 <code>Filter</code> 要被优先执行呢？因为我们的请求被包装了，如果<code>SessionRepositoryFilter</code>不优先处理请求，可能会导致后续的请求行为不一致，这里涉及到 <code>springSession</code>无缝替换应用服务器的<code>request</code>的原理：</p><ul><li>1.自定义个<code>Filter</code>，实现<code>doFilter</code>方法 </li><li>2.继承 <code>HttpServletRequestWrapper</code> 、<code>HttpServletResponseWrapper</code> 类，重写<code>getSession</code>等相关方法(在这些方法里调用相关的 <code>session</code>存储容器操作类)。 </li><li>3.自定义<code>request</code>和<code>response</code>类；并把它们分别传递到过滤器链 </li><li>4.把该<code>filter</code>配置到过滤器链的第一个位置上</li></ul><p>OK，了解了这些背景，我们来跟踪下整个处理流程。</p><h4 id="1、断点到-doFilterInternal"><a href="#1、断点到-doFilterInternal" class="headerlink" title="1、断点到 doFilterInternal"></a>1、断点到 doFilterInternal</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/3/166d892f7ef1f8ea?w=1938&amp;h=536&amp;f=png&amp;s=195954" alt=""></p><p>从这里可以看到<code>request</code>和<code>response</code>类被包装了。</p><h4 id="2、断点到-getSession"><a href="#2、断点到-getSession" class="headerlink" title="2、断点到 getSession"></a>2、断点到 getSession</h4><p>这里是从<code>Redis</code>中拿我们<code>session</code>数据的地方</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/3/166d8a3135566112?w=1620&amp;h=1286&amp;f=png&amp;s=319222" alt=""></p><ul><li>先从我们当前<code>servlet</code>容器中去拿，如果拿到则直接返回</li><li><p>去<code>Redis</code>中取</p><p>  <img src="https://user-gold-cdn.xitu.io/2018/11/3/166d8a7556f931c5?w=1606&amp;h=624&amp;f=png&amp;s=169149" alt=""><br>  这里会有一个缓存处理，并非是每次都到<code>Reids</code>中去查一次，避免一次与<code>Reids</code>的交互。</p><ul><li>如果缓存当前应用容器缓存中有，则直接返回当前被缓存的<code>session</code></li><li>如果没有，则从请求中获取<code>sessionId</code>，并且根据当前<code>sessionId</code>去<code>Reids</code>中查找<code>session</code>数据</li><li>更新缓存<code>session，sessionId,requestedSessionCached</code>等数据状态</li></ul></li><li>如果<code>Redis</code>中有，则更新<code>session</code>相关信息并返回</li><li>如果<code>Reids</code>中没有找到，则根据 <code>create</code> 来判断是否创建新的<code>session</code>。</li></ul><h3 id="断点到-readCookieValues"><a href="#断点到-readCookieValues" class="headerlink" title="断点到 readCookieValues"></a>断点到 readCookieValues</h3><p><code>SpringSession</code>提供了两种保存和传递<code>SessionId</code>的方式，一种是基于<code>Cookie</code>的，一种是基于<code>Header</code>的。<code>SpringSession</code>中默认使用的是基于<code>Cookie</code>的方式。<code>readCookieValues</code> 就是实现如何从<code>Cookie</code>中获取<code>sessionId</code>的。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/3/166d8b17ef251a93?w=1454&amp;h=712&amp;f=png&amp;s=168306" alt=""></p><p>这个过程其实很简单，先是从<code>request</code>中获取当前请求携带的所以的<code>Cookie</code>信息，然后将匹配到的 <code>cookieName</code> 为 <code>“SESSION”</code> 的<code>Cookie</code>进行解析。</p><h3 id="断点到-RedisOperationsSessionRepository-gt-getSession"><a href="#断点到-RedisOperationsSessionRepository-gt-getSession" class="headerlink" title="断点到 RedisOperationsSessionRepository -&gt; getSession"></a>断点到 RedisOperationsSessionRepository -&gt; getSession</h3><p>这里是从<code>Redis</code>中取<code>session</code>数据的地方<br><img src="https://user-gold-cdn.xitu.io/2018/11/3/166d8b5088d73386?w=1480&amp;h=472&amp;f=png&amp;s=105479" alt=""></p><ul><li>根据<code>sessionId</code>从 <code>Redis</code>中取到 <code>entries</code> 数据</li><li>构建 <code>RedisSession</code> 并返回</li></ul><h3 id="断点到-commitSession"><a href="#断点到-commitSession" class="headerlink" title="断点到 commitSession"></a>断点到 commitSession</h3><p><code>commitSession</code>作用是通过<code>HttpSessionIdResolver</code> 将<code>sessionId</code>写到<code>response</code>，并且进行持久化。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/3/166d895cfab06ffd?w=1458&amp;h=726&amp;f=png&amp;s=167558" alt=""></p><p>这里的 <code>session</code> 其实是已经更新过状态的，比如重新设置了 <code>session</code> 的过期时间等。<code>session</code> 提交实际上就意味着当前请求已经处理完毕了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文先介绍了如何使用 <code>SpringBoot</code> 集成 <code>SpringSession</code>，并且以 <code>Redis</code> 作为存储。然后简单分析了 <code>SpringSession</code> 的处理过程，本文对 <code>SpringSession</code> 的原理部分没有进行深入分析，下一篇分析下<code>SpringSession</code>的原理。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> session </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> session </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
