<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>glmapper</title>
  
  <subtitle>大家都喊我磊叔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.glmapper.com/"/>
  <updated>2020-06-25T07:52:56.220Z</updated>
  <id>http://www.glmapper.com/</id>
  
  <author>
    <name>GuoLei Song</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聊一聊 BeanPostProcessor 不生效</title>
    <link href="http://www.glmapper.com/2020/06/21/spring-series-factory-bean-and-post-processor/"/>
    <id>http://www.glmapper.com/2020/06/21/spring-series-factory-bean-and-post-processor/</id>
    <published>2020-06-21T13:12:14.000Z</published>
    <updated>2020-06-25T07:52:56.220Z</updated>
    
    <content type="html"><![CDATA[<p>关于 BeanPostProcessor 各位一定不陌生，在 <a href="http://www.glmapper.com/2019/12/14/springboot-series-bean-life/">SpringBoot 源码系列-Bean 的生命周期与扩展</a> 这篇文章中，我有介绍过 bean 的创建流程及相关扩展，就有提到 BeanPostProcessor，包括它的作用时机及如何使用，这篇文章提到的这种属于比较常规的流程，因此在绝大多数场景下，都是符合我们认知的。但是最近在排查一个问题时，发现在某些场景下，BeanPostProcessor 不生效了…</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>代码详见：<a href="https://github.com/glmapper/glmapper-spring-extention/tree/master/extention-FactoryBean" target="_blank" rel="noopener">extention-FactoryBean</a>; clone 之后可以直接运行 DemoApplication 即可，可以观察到 控制台不输出 GlmapperBeanPostProcessor 里面 print out 的字符串。</p></blockquote><p>运行代码，即可观察到具体的执行现场；代码里除了 BeanPostProcessor 之外，另外一个是 FactoryBean，也就是本篇所要聊的重点：<strong>FactoryBean getObjectType 为 null 时导致 bean 提前初始化，从而使得作用与目标 bean 的 BeanPostProcessors 都失效了。</strong></p><p>下面将基于这个问题，展开进行分析。</p><h2 id="bean-生命周期"><a href="#bean-生命周期" class="headerlink" title="bean 生命周期"></a>bean 生命周期</h2><p>先来看下 ApplicationContext 和 bean 生命周期(仅列出部分关键流程)：</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/beanlife/bean%20init.png" alt=""></p><p>从流程中可以看到：BeanPostProcessor 的注册是在 ApplicationContext 生命周期中完成的，故而当 bean 创建时，如果相应拦截器 BeanPostProcessor 还没有注册，那么其就不会起作用，这个可能有以下两种原因：</p><ul><li>1、bean 本身是一个 BeanPostProcessor ，且实现了 PriorityOrdered 或者 Ordered 接口</li><li>2、bean 由于某种原因，被提前初始化了，初始化的时候相应拦截器 BeanPostProcessor 还没有注册</li></ul><p>关于第一个其实很好理解，不再赘述，本篇主要基于第二个原因进行说明。</p><h2 id="bean-由于某种原因，被提前初始化了，初始化的时候相应拦截器-BeanPostProcessor-还没有注册"><a href="#bean-由于某种原因，被提前初始化了，初始化的时候相应拦截器-BeanPostProcessor-还没有注册" class="headerlink" title="bean 由于某种原因，被提前初始化了，初始化的时候相应拦截器 BeanPostProcessor 还没有注册"></a>bean 由于某种原因，被提前初始化了，初始化的时候相应拦截器 BeanPostProcessor 还没有注册</h2><p>bean 被提前初始化的情况就比较多了，归纳下来都能符合同一个规律：在 创建所有 non-lazy-init bean 这一步之前，也即在创建 BeanFactoryPostProcessor 或者 BeanPostProcessor 的过程中，引发了 bean 的创建，导致其被提前初始化，大体可以分为两种情形：</p><ul><li>用户自定义的 BeanFactoryPostProcessor 或者 BeanPostProcessor 中会通过构造函数、属性注入等方式引用到目标 bean 导致其被提前创建</li><li>在上述过程中由于 Spring 自身对 FactoryBean 的 typeCheck(类型检测) 机制导致目标 bean 被提前创建</li></ul><p>对于第一种情形，比较简单，这个通常是用户的配置导致的，比如我的 TestBeanFactoryPostProcessor 中通过属性注入了目标 bean 导致了其被提前创建，最终拦截器失效(如果去掉相应 TestBeanFactoryPostProcessor 配置，可以看到拦截器是能够成功的 )。</p><blockquote><p>简单代码如下，作用在 TestFacade 上的 BeanFactoryPostProcessor 可能会由于 TestFacade 的提前被创建而失效</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @<span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestFacade testFacade;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>如何找到 bean 被提前初始化的时机呢？可以在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[]) 打一个条件断点，通过 beanName 进行匹配，然后顺着 debug 堆栈往回找，就能够看到是在哪里导致了 bean 被提前创建。</p></blockquote><p>对于第二种情形，其实也是通过上述方法先找到被提前创建的源头，只不过这种情形更加隐晦，也更加复杂，这里我们单独在下面的部分中来分析。</p><h2 id="关于-isTypeMatch"><a href="#关于-isTypeMatch" class="headerlink" title="关于 isTypeMatch"></a>关于 isTypeMatch</h2><p>从 Spring 2.x 版本开始，BeanFactory 中就已经有 isTypeMatch 这个方法了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Check whether the bean with the given name matches the specified type.</span></span><br><span class="line"><span class="comment">* More specifically, check whether a &#123;<span class="doctag">@link</span> #getBean&#125; call for the given name</span></span><br><span class="line"><span class="comment">* would return an object that is assignable to the specified target type.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">* Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> typeToMatch the type to match against (as a &#123;<span class="doctag">@code</span> Class&#125;)</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the bean type matches,</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> false&#125; if it doesn't match or cannot be determined yet</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 2.0.1</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> #getType</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, @Nullable Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br></pre></td></tr></table></figure><p>从方法注释可以简单了解到，isTypeMatch 的作用就是：判断 JavaBean 是否匹配指定的类型。他包括两个参数：</p><ul><li>name：容器中定义的 JavaBean 的名称。</li><li>typeToMatch：要匹配的目标类型。</li></ul><p>回到案例，我们需要关注的是 isTypeMatch 和我们前面提到的<strong>FactoryBean getObjectType 为 null 时导致 bean 提前初始化，从而使得作用与目标 bean 的 BeanPostProcessors 都失效了。</strong>有什么关系呢？这里有两个比较关键的信息：</p><ul><li>1、FactoryBean getObjectType 为 null</li><li>2、目标 bean 的 BeanPostProcessors 都失效了</li></ul><p>其实大概能够猜到的是，<strong>actoryBean getObjectType 为 null 时，导致了 当前 bean 被提前初始化，而此时 bean 的 BeanPostProcessors 还没有被注册到当前 bean ，从而导致了目标 bean 的 BeanPostProcessors 都失效。</strong> 这个也是本篇的结论，但是还是需要来看看具体原因的细节是什么样的。</p><p><strong>我们知道，在 Spring 中，当进行 byType (除了用户主动配置 byType 注入以外，使用 @autowired 以及 @Bean 中的方法参数时等都使用的是 byType  注入) 注入时，会通过 org.springframework.beans.factory.ListableBeanFactory#getBeanNamesForType(java.lang.Class&lt;?&gt;, boolean, boolean) 来寻找相应类型的 bean 。</strong></p><p><strong>针对 FactoryBean 而言，当判断其类型时，会先创建一个简单的(非完整的，仅仅是调用构造函数) bean ，调用其 getObjectType() ，如果发现返回为 null，那么就会再创造完整的 bean ，然后再通过 getObjectType() 获取类型进行匹配。</strong></p><h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><p>基于上面提到的点，结合本案例，来 debug 看下 <strong>FactoryBean typeCheck(类型检测) 机制导致的 BeanPostProcessor 不生效</strong>的原因。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/beanlife/exe-stack.jpg" alt="执行堆栈"></p><p>这里主要还是看下 isTypeMatch 方法执行是如何触发 bean 提前初始化的。</p><h3 id="isTypeMatch-方法"><a href="#isTypeMatch-方法" class="headerlink" title="isTypeMatch 方法"></a>isTypeMatch 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">    String beanName = transformedBeanName(name);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Check manually registered singletons.</span></span><br><span class="line">    Object beanInstance = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 常规情况下，这里 beanInstance 是不为 null 的，但是对于提前加载的 beanInstance == null</span></span><br><span class="line">    <span class="keyword">if</span> (beanInstance != <span class="keyword">null</span> &amp;&amp; beanInstance.getClass() != NullBean.class) &#123;</span><br><span class="line">        <span class="comment">// 判断类型是不是 FactoryBean</span></span><br><span class="line">        <span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">            <span class="comment">// 返回给定名称是否为工厂解除引用(以工厂解除引用前缀开始)。 &amp;xxxx </span></span><br><span class="line">            <span class="keyword">if</span> (!BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">                <span class="comment">// 这里拿 FactoryBean#getObjectType</span></span><br><span class="line">                Class&lt;?&gt; type = getTypeForFactoryBean((FactoryBean&lt;?&gt;) beanInstance);</span><br><span class="line">                <span class="keyword">return</span> (type != <span class="keyword">null</span> &amp;&amp; typeToMatch.isAssignableFrom(type));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 实例类型是否匹配</span></span><br><span class="line">                <span class="keyword">return</span> typeToMatch.isInstance(beanInstance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理泛型和代理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (typeToMatch.isInstance(beanInstance)) &#123;</span><br><span class="line">                <span class="comment">// 直接匹配暴露实例?</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (typeToMatch.hasGenerics() &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">                <span class="comment">// 泛型可能只匹配目标类，而不匹配代理…</span></span><br><span class="line">                RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">                Class&lt;?&gt; targetType = mbd.getTargetType();</span><br><span class="line">                <span class="keyword">if</span> (targetType != <span class="keyword">null</span> &amp;&amp; targetType != ClassUtils.getUserClass(beanInstance) &amp;&amp;</span><br><span class="line">                        typeToMatch.isAssignableFrom(targetType)) &#123;</span><br><span class="line">                    <span class="comment">// 还要检查原始类匹配，确保它在代理上暴露。</span></span><br><span class="line">                    Class&lt;?&gt; classToMatch = typeToMatch.resolve();</span><br><span class="line">                    <span class="keyword">return</span> (classToMatch == <span class="keyword">null</span> || classToMatch.isInstance(beanInstance));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 beanName 的 bean 没有被注册过</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (containsSingleton(beanName) &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">        <span class="comment">// null instance registered</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有找到单例实例-&gt;检查bean定义。</span></span><br><span class="line">    BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">        <span class="comment">// 在这个 factory 中没有找到 bean definition -&gt; 委托 parent。</span></span><br><span class="line">        <span class="keyword">return</span> parentBeanFactory.isTypeMatch(originalBeanName(name), typeToMatch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检索相应的 bean 定义。</span></span><br><span class="line">    RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; classToMatch = typeToMatch.resolve();</span><br><span class="line">    <span class="keyword">if</span> (classToMatch == <span class="keyword">null</span>) &#123;</span><br><span class="line">        classToMatch = FactoryBean.class;</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt;[] typesToMatch = (FactoryBean.class == classToMatch ?</span><br><span class="line">            <span class="keyword">new</span> Class&lt;?&gt;[] &#123;classToMatch&#125; : <span class="keyword">new</span> Class&lt;?&gt;[] &#123;FactoryBean.class, classToMatch&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check decorated bean definition, if any: We assume it'll be easier</span></span><br><span class="line">    <span class="comment">// to determine the decorated bean's type than the proxy's type.</span></span><br><span class="line">    <span class="comment">// 检查修饰 bean definition(如果有的话):我们假设确定修饰 bean 的类型比确定代理的类型更容易。</span></span><br><span class="line">    BeanDefinitionHolder dbd = mbd.getDecoratedDefinition();</span><br><span class="line">    <span class="keyword">if</span> (dbd != <span class="keyword">null</span> &amp;&amp; !BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">        RootBeanDefinition tbd = getMergedBeanDefinition(dbd.getBeanName(), dbd.getBeanDefinition(), mbd);</span><br><span class="line">        <span class="comment">// 预测指定bean的最终bean类型(已处理bean实例的)。由&#123;@link #getType&#125;和&#123;@link #isTypeMatch&#125;调用。不需要专门处理factorybean，因为它只应该操作原始bean类型。</span></span><br><span class="line">        <span class="comment">// 这个实现过于简单，因为它不能处理工厂方法和实例化 awarebeanpostprocessors。对于标准bean，它只能正确地预测bean类型。要在子类中重写，应用更复杂的类型检测。</span></span><br><span class="line">        Class&lt;?&gt; targetClass = predictBeanType(dbd.getBeanName(), tbd, typesToMatch);</span><br><span class="line">        <span class="keyword">if</span> (targetClass != <span class="keyword">null</span> &amp;&amp; !FactoryBean.class.isAssignableFrom(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> typeToMatch.isAssignableFrom(targetClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 推断出 beanType</span></span><br><span class="line">    Class&lt;?&gt; beanType = predictBeanType(beanName, mbd, typesToMatch);</span><br><span class="line">    <span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查 bean class 是否是 FactoryBean 类型。本案例就是在这被处理到 返回 false 的</span></span><br><span class="line">    <span class="keyword">if</span> (FactoryBean.class.isAssignableFrom(beanType)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; beanInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果它是FactoryBean，我们希望看到它创建了什么（getObject），而不是工厂类。</span></span><br><span class="line">            beanType = getTypeForFactoryBean(beanName, mbd);</span><br><span class="line">            <span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 ........</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getTypeForFactoryBean-方法"><a href="#getTypeForFactoryBean-方法" class="headerlink" title="getTypeForFactoryBean 方法"></a>getTypeForFactoryBean 方法</h3><p>这个步骤会向尝试从 FactoryBean 的 getObjectType 方法去获取类型，如果拿不到，则调用父类的进行初始化 bean 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略 其他...</span></span><br><span class="line"><span class="keyword">if</span> (fb != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 尝试从实例的这个早期阶段获取 FactoryBean 的对象类型。这里调用的就是 FactoryBean#getObjectType 方法</span></span><br><span class="line">    Class&lt;?&gt; result = getTypeForFactoryBean(fb);</span><br><span class="line">    <span class="comment">// 本案例中这里返回的是 null, 所以会走到 else</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的意思就是没有通过 FactoryBean#getObjectType 快速获取到类型</span></span><br><span class="line">        <span class="comment">// 将执行实例当前实例，然后再获取</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getTypeForFactoryBean(beanName, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略 其他...</span></span><br></pre></td></tr></table></figure><h3 id="AbstractBeanFactory-getTypeForFactoryBean"><a href="#AbstractBeanFactory-getTypeForFactoryBean" class="headerlink" title="AbstractBeanFactory#getTypeForFactoryBean"></a>AbstractBeanFactory#getTypeForFactoryBean</h3><p>调用父类的 getTypeForFactoryBean 方法，执行 bean 的初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getTypeForFactoryBean(String beanName, RootBeanDefinition mbd) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSingleton()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里开始执行 doGetBean，之前的文章里面有提到，bean 实例化的入口就是 getBean 的时候</span></span><br><span class="line">        FactoryBean&lt;?&gt; factoryBean = doGetBean(FACTORY_BEAN_PREFIX + beanName, FactoryBean.class, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> getTypeForFactoryBean(factoryBean);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">        <span class="comment">// 省略日志打印部分</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 doGetBean 中执行链路中，会在 initializeBean 时给当前 bean 注册 BeanPostProcessor，（applyBeanPostProcessorsBeforeInitialization 方法中) ，这里可以比较清晰的看到 BeanPostProcessor 没有作用于 目标 bean 的。</p><blockquote><p>doGetBean -&gt; createBean -&gt; initializeBean -&gt; applyBeanPostProcessorsBeforeInitialization</p></blockquote><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/beanlife/no-processors.jpg" alt=""></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在本篇的案例中，其实比较明显的可以看到测试工程中 GlmapperFactoryBean 的 getObjectType 返回是为 null 的，也正是因为这个原因导致了 BeanPostProcessor 失效。那么如何在实际的开发过程中来规避呢？</p><ul><li>1、FactoryBean 的 getObjectType() 不要返回 null </li><li>2、定义 BeanPostProcessor 时，需要特别注意 order</li><li>3、在 创建所有 non-lazy-init bean 之前的  getBeanNamesForType 调用，尽量将 eagerInit 传为 false。</li></ul><p>关于第三点，前面提到过 getBeanNamesForType 的调用会触发类型检查，但其实这个方法还有些参数，参考如下：</p><p>String[] getBeanNamesForType(Class&lt;?&gt; type, boolean includeNonSingletons, boolean allowEagerInit);<br>这里有个很重要的参数 allowEagerInit ，可以看到 spring 的注释中对其有非常详细的解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@param allowEagerInit whether to initialize lazy-init singletons and</span><br><span class="line"></span><br><span class="line">* objects created by FactoryBeans (or by factory methods with a</span><br><span class="line">* &quot;factory-bean&quot; reference) for the type check. Note that FactoryBeans need to be</span><br><span class="line">* eagerly initialized to determine their type: So be aware that passing in &quot;true&quot;</span><br><span class="line">* for this flag will initialize FactoryBeans and &quot;factory-bean&quot; references.</span><br></pre></td></tr></table></figure><p>简单来说这个参数能够控制是否允许 FactoryBean 的提前创建，如果是 false，那么也不会引发上述的 类型检测 。可以看到在 Spring 中在获取 BeanFactoryPostProcessor 以及 BeanPostProcessor 时，也都是传入 false 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tring[] postProcessorNames =</span><br><span class="line">        beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">String[] postProcessorNames = </span><br><span class="line">    beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>当然在一些 @Bean 的方法参数注入、@Autowire 注入等场景下，这个默认都是 true 的，无法改变；但针对平时编码过程中，如果是在比较早期的调用中，可根据情况，尽量传入 false。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于 BeanPostProcessor 各位一定不陌生，在 &lt;a href=&quot;http://www.glmapper.com/2019/12/14/springboot-series-bean-life/&quot;&gt;SpringBoot 源码系列-Bean 的生命周期与扩展&lt;/a
      
    
    </summary>
    
      <category term="spring" scheme="http://www.glmapper.com/categories/spring/"/>
    
    
      <category term="spring" scheme="http://www.glmapper.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>什么是中台？</title>
    <link href="http://www.glmapper.com/2020/05/19/solution-series-zhongtai/"/>
    <id>http://www.glmapper.com/2020/05/19/solution-series-zhongtai/</id>
    <published>2020-05-19T03:07:17.000Z</published>
    <updated>2020-05-19T03:08:31.395Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文来自 PoemByte 公众号，作者 kayzhao</p></blockquote><h2 id="没有XX台的时代-烟囱式的架构"><a href="#没有XX台的时代-烟囱式的架构" class="headerlink" title="没有XX台的时代 - 烟囱式的架构"></a>没有XX台的时代 - 烟囱式的架构</h2><p>​        在传统IT企业，项目的架构是什么样的呢？无论项目内部的如何复杂，都可简化分为<strong>“前台”</strong>和<strong>“后台”</strong>两部分，也就是<strong>垂直的烟囱式架构</strong>（业内人士把见招拆招、垂直化发展、未做足够抽象通用的架构称之为烟囱型架构）。什么是<strong>前台</strong>？所谓前台即包括各种和消费者用户直接交互的界面业务功能，比如web页面（PC端），手机app（无线端或移动端）。什么是<strong>后台</strong>？后台是面向运营人员的配置管理系统，比如商品管理、物流管理、结算管理。后台为前台提供业务管理等。前台、后台、用户之间的关系，可以用下图简单表示：</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/middleground/1.png" alt="image-20200510183353012" style="zoom: 50%;"></p><p>​        起初，项目的发展相对稳定，并不需要快速的去迭代，所以垂直的烟囱式结构并没有什么问题。但在互联网快速发展的今天，企业之间的竞争越来越激烈，只有以用户为中心，快速响应用户的需求，不断迭代和试错，才能让企业在竞争当中立于不败。在传统的前台-后台架构中，各个项目相对独立，许多项目都在重复发明同样的轮子（比如用户中心，支付业务等），即让项目本身越来越臃肿，也让开发效率越来越低。这种时候，为提高开发效率，我们有必要整合出一个中间组织，为所有的项目提供一些公共资源。而这个中间组织，就是人们所说的平台。</p><h2 id="垂直烟囱的进化-平台化的架构"><a href="#垂直烟囱的进化-平台化的架构" class="headerlink" title="垂直烟囱的进化 - 平台化的架构"></a>垂直烟囱的进化 - 平台化的架构</h2><p>​        为什么会出现平台化架构，还得从烟囱型架构说起（参考上一节）。但烟囱型架构并非一无是处，在早期业务死活未知的情况下，不过度设计架构，能直接有效的支持到业务。不过，当业务发展起来之后，烟囱越树越多，成长的烦恼就如期而至了。</p><p>​        <strong>第一个问题是人不够，业务响应慢了下来。</strong>我们以一个5人研发团队为例来说明一下这个问题。起初团队一个产品都没有，5个人1个月干出一个简单版本的红包系统；几年之后团队增加到10人，但手头要维护10个系统。那么平均人手一个系统，这时候，又来了2个新业务，团队派出3个人去干，大约要干4个月，严重不符合前端业务的响应预期。</p><p>​        <strong>第二个问题是重复建设</strong>，同类烟囱系统中80%的功能是类似的，从数据库模型到主要业务逻辑，都是copy-paste加补丁，一步留神又踩到一个坑。</p><p>​        <strong>第三个问题是维护成本高</strong>。日常升级包、咨询支持服务，团队疲惫不堪。基于此，80%甚至90%的共性问题，能不能抽象出来呢？核心领域模型是否可以是稳定的呢？从下图可以看出，这是可以做到的。</p><p>​        在既要支持不断出现的各种业务，又要支持建设新平台。企业便启动了平台化建设，对前后台业务提供统一的能力露出，由能力组装编排内部服务。研发规则运营、统一后台管理服务等。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/middleground/2.png" alt="image-20200510183513991" style="zoom: 50%;"></p><p>​        总结下来，平台化架构有以下好处：一是快速支撑、响应业务；二是抽象共性，边界清晰。快速支撑，响应业务是以终为始的出发点。架构如果不服务业务，再高大上都是扯淡。技术不是炫技，要服务商业。再谈谈抽象共性的问题，业务平台化要解决业务共性问题，比如天猫、淘宝都有各类营销活动。那么就抽象出一个营销平台来管理营销活动、营销工具的整个的生命周期管理。</p><h2 id="中台的架构思想-大中台小前台"><a href="#中台的架构思想-大中台小前台" class="headerlink" title="中台的架构思想 - 大中台小前台"></a>中台的架构思想 - 大中台小前台</h2><h3 id="中台的起源"><a href="#中台的起源" class="headerlink" title="中台的起源"></a>中台的起源</h3><ul><li><strong>SuperCell</strong></li></ul><p>​        SuperCell是一家芬兰的手机游戏公司，这个名字或许有些陌生，但是说起下面几款游戏，大家一定会很熟悉：部落冲突、海岛奇兵、皇室战争等。SuperCell公司就像是一个高产的游戏孵化器，在几年内开发出了10款以上的游戏，但是大部分用于试错的游戏都在研发过程中被腰斩了，最终呈献给用户的几款游戏都是经典中的经典。是什么让SuperCell公司能够如此高效地试错和迭代呢？他们依靠的是强大的平台资源，支撑起各个游戏开发的小团队。他们开发出的游戏看上去风格迥异，却存在许多共同之处。在业务上，共通的东西包括支付系统、用户系统等等，在技术上，共同的东西包括游戏引擎，内部开发工具等等。而这些共通的资源，都可以由一个强大的“中台”来提供。Supercell的中台，指的是公司将游戏开发过程中公共和通用的游戏素材和算法整合起来，并积累了非常科学的研发工具和框架体系，构建了一个功能非常强大的中台。这样强大的中台可以支持若干个小团队在短时间内开发出一款新的游戏。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/middleground/3.png" alt="image-20200511111247892" style="zoom: 67%;"></p><ul><li><strong>阿里巴巴</strong></li></ul><p>​        马云在2015年的一次欧洲之旅（访问SuperCell公司），将中台的思想结合阿里的现状，提出了<strong>大中台、小前台</strong>的战略架构，从而将中台架构思想引入国内，开启了中台化热潮。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/middleground/4.png" alt="img" style="zoom:67%;"></p><h3 id="中台的定义"><a href="#中台的定义" class="headerlink" title="中台的定义"></a>中台的定义</h3><p>​        中台是什么？简言之，中台是<strong>给业务团队提效为目标的，可复用的技术能力及业务能力的集合</strong>。有业务能力说明理解业务，能复用说明能提效。从这个定义可以看出，中台更接近是一个解决方案。</p><h3 id="中台的分类"><a href="#中台的分类" class="headerlink" title="中台的分类"></a>中台的分类</h3><p>​        <strong>中台 是 可复用的技术能力和业务能力的集合；</strong>与此相对应的，<strong>中间件、技术框架、技术平台 是 可复用的技术能力的集合；</strong>中台和中间件的共同点就是他们都需要被复用才能发挥价值，并不能出去单打独斗。</p><p>​        以此类推：业务中台就是可复用的业务技术能力和组织业务能力的集合；数据中台就是可复用的数据技术能力和数据业务能力的集合；算法中台就是可复用的算法技术能力和算法业务能力的集合；</p><p>​        但是，<strong>技术中台</strong>这种说法有点迷，会让人误解里面都是技术复用，而没有任何业务。如果其实是纯粹的技术复用平台，建议大家在平常交流时还是尽量别用技术中台，直接用<strong>中间件、技术平台、技术框架</strong>的原有概念来沟通即可，没必要赶时髦。</p><h3 id="中台的用户"><a href="#中台的用户" class="headerlink" title="中台的用户"></a>中台的用户</h3><p>​        电商交易系统，前台的用户是消费者，后台的用户是电商运营，中台的用户是谁？</p><p>​        企业管理系统，前台的用户是员工，后台的用户是企业管理员，中台的用户是谁？</p><p>​        数字政务系统，前台的用户是公务员，后台的用户是政府管理员，中台的用户是谁？</p><p>​        大中台，小前台。 这种说法的误导性在于，让人以为中台是为前台服务的。但其实中台可以服务任何业务形态。从Supercell这个故事可以看出，中台不会直面消费者或最终用户。<strong>中台的作用就是为业务团队服务，</strong>让业务团队更好更快的服务最终用户。</p><h2 id="中台是必须？"><a href="#中台是必须？" class="headerlink" title="中台是必须？"></a>中台是必须？</h2><h3 id="从0到1的阶段"><a href="#从0到1的阶段" class="headerlink" title="从0到1的阶段"></a>从0到1的阶段</h3><p>​        <strong>没有必要搭建中台。</strong>从0到1的创业型公司，首要目的是生存下去，以最快的速度打造出产品，证明自身的市场价值。这个时候，让项目野蛮生长才是最好的选择。如果不慌不忙地先去搭建中台，恐怕中台还没搭建好，公司早就饿死了。</p><h3 id="从1到N的阶段"><a href="#从1到N的阶段" class="headerlink" title="从1到N的阶段"></a>从1到N的阶段</h3><p>​        <strong>适合搭建中台。</strong>当企业有了一定规模，产品得到了市场的认可，这时候公司的首要目的不再是活下去，而是活的更好。这个时候，趁着项目复杂度还不是特别高，可以考虑把各项目的通用部分下沉，组建中台，以方便后续新项目的尝试和旧项目的迭代。</p><h3 id="从N到N-1的阶段"><a href="#从N到N-1的阶段" class="headerlink" title="从N到N+1的阶段"></a>从N到N+1的阶段</h3><p>​        <strong>搭建中台势在必行。</strong>当企业已经有了很大的规模，各种产品、服务、部门错综复杂，这时候做架构调整会比较痛苦。但是长痛不如短痛，为了项目的长期发展，还是需要尽早调整架构，实现平台化，以免日后越来越难以维护。</p><h2 id="中台的FAQ"><a href="#中台的FAQ" class="headerlink" title="中台的FAQ"></a>中台的FAQ</h2><h3 id="中心化-平台化-中台化异同？"><a href="#中心化-平台化-中台化异同？" class="headerlink" title="中心化/平台化/中台化异同？"></a>中心化/平台化/中台化异同？</h3><p>​        中心化-&gt;平台化-&gt;中台化，更像是随着组织规模增大，分布式系统下一种架构思想的演进。在业务最早期，业务既量小又简单，一个业务系统、单机或几台机器就支持了。随着业务快速发展，团队增多，带来诸多的效率和稳定性问题，系统架构升级，开始系统拆分，正式进入分布式系统阶段，并由此开启了一段新的架构演进，如下图所示：</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/middleground/5.png" alt="image-20200511140325736" style="zoom: 50%;"></p><p>​        <strong>中心化重在领域建模</strong>，通过对自身领域的抽象建模，对外提供统一标准的数据和服务；</p><p>​        <strong>平台化重在业务抽象和架构开放</strong>，“业务抽象解决共性的80%问题，系统架构开放性解决20%的个性化问题”，既能对外提供标准的数据和服务，还能通过平台配置，或实现指定服务接口，或平台内部实现业务逻辑控制等方式支持不同业务的运行；</p><p>​        <strong>中台化重在建立标准和机制</strong>，通过建立业务身份、能力、扩展点等业务领域概念标准，能力管控、流程编排等系统运行时标准，使大家能互联互通、共享共建，以统一的标准进行需求分析、技术开发和复用。</p><p>​        总的来说：<strong>中心主要负责自身单一领域的建设，而平台要负责对多个业务域的支持，而中台则是要覆盖到所有业务域，建立整个业务域的协同标准和机制。所以中台的技术连通性更强，技术生态性更突出。</strong>淘系业务系统的发展正是这个过程，业务上从淘宝时期到三淘（淘宝、天猫、一淘）时期到现在的淘系生态，系统上从商品中心、店铺中心等到商品平台、店铺平台到今天的电商业务中台。 </p><h3 id="小前台到底多小才算小呢？"><a href="#小前台到底多小才算小呢？" class="headerlink" title="小前台到底多小才算小呢？"></a>小前台到底多小才算小呢？</h3><p>​        小前台只是个代称，并不一定非得是前台团队， 用一个<strong>“快速反应团队”</strong>代之较为合适。<strong>也就是5人、7人、最多十几个人组成的团队</strong>，不宜过大（其实是相对“小”，不用刻意追求数量的少）。过大了惯性也会比较大，掉头就比较不容易，不利于快速反应、创新、试错。</p><h3 id="如何下手建设中台化架构？"><a href="#如何下手建设中台化架构？" class="headerlink" title="如何下手建设中台化架构？"></a>如何下手建设中台化架构？</h3><p>​        从哪里开始？哪种路径更适合打造一个中台？</p><p>​        ① 直接下手开始做中台，逐步扩展到其他业务 </p><p>​        <strong>②</strong> <strong>从最擅长的业务（核心业务）入手，做中台的探索</strong></p><p>​        第一种路径的好处是一开始可以做好中台的规划，技术栈保持一致性。坏处是失败的概率和成本比较高。第二种路径更保险，也是目前来看比较可能结出果实的路径。比如：阿里先有电商业务和互联网金融业务，然后才做了共享业务、星环等中台方案。头条最擅长算法业务，然后才有了算法中台。腾讯在IM领域沉淀了多年，基于IM做中台符合逻辑。</p><h3 id="中台架构到底在学习什么？"><a href="#中台架构到底在学习什么？" class="headerlink" title="中台架构到底在学习什么？"></a>中台架构到底在学习什么？</h3><p>​        <strong>值得我们学习的不是中台本身，而是 Supercell模式。</strong>Supercell模式如何实现，马老师已经给了一种路径：大中台，小前台。 但也许这不是唯一路径，但至少是种思路。18年到19年，有种功利化、蹭热度化、浮躁化的氛围，弥漫在中台的圈子里。大家一哄而上，咋咋呼呼的大跃进式的建设大中台，逢人必谈中台，周报写中台，开会说中台，晋升提中台，甚至借中台之名，行平台之实。 </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://mp.weixin.qq.com/s/fQ98fe3XH6imxzNhwiNaNA" target="_blank" rel="noopener">我看中台</a>：<a href="https://mp.weixin.qq.com/s/fQ98fe3XH6imxzNhwiNaNA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/fQ98fe3XH6imxzNhwiNaNA</a></p><p><a href="https://mp.weixin.qq.com/s/rF7_xJBq4NJP6CmkW3HPpQ" target="_blank" rel="noopener">漫画：什么是中台</a>：<a href="https://mp.weixin.qq.com/s/rF7_xJBq4NJP6CmkW3HPpQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/rF7_xJBq4NJP6CmkW3HPpQ</a></p><p><a href="https://juejin.im/search?query=数据中台" target="_blank" rel="noopener">掘金： 数据中台</a>：<a href="https://juejin.im/search?query=数据中台" target="_blank" rel="noopener">https://juejin.im/search?query=数据中台</a></p><p><a href="https://juejin.im/post/5d79fedff265da03cd0aac81" target="_blank" rel="noopener">读透《阿里巴巴数据中台实践》，其到底有什么高明之处？</a>：<a href="https://juejin.im/post/5d79fedff265da03cd0aac81" target="_blank" rel="noopener">https://juejin.im/post/5d79fedff265da03cd0aac81</a></p><p><a href="https://www.zhihu.com/search?type=content&amp;q=中台如何做到快速响应" target="_blank" rel="noopener">知乎：中台如何做到快速响应</a>：<a href="https://www.zhihu.com/search?type=content&amp;q=中台如何做到快速响应" target="_blank" rel="noopener">https://www.zhihu.com/search?type=content&amp;q=中台如何做到快速响应</a></p><p><a href="https://zhuanlan.zhihu.com/p/59867439" target="_blank" rel="noopener">业务中台探索和实践：软件的根本问题</a>：<a href="https://zhuanlan.zhihu.com/p/59867439" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/59867439</a></p><p><a href="https://zhuanlan.zhihu.com/p/77097815" target="_blank" rel="noopener">什么是中台？什么不是中台？所有的中台都是业务中台</a>：<a href="https://zhuanlan.zhihu.com/p/77097815" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/77097815</a></p><p><a href="https://zhuanlan.zhihu.com/p/77362869" target="_blank" rel="noopener">如何建设中台？中台建设的组织、支撑技术和方法论</a>：<a href="https://zhuanlan.zhihu.com/p/77362869" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/77362869</a></p><p><a href="https://www.zhihu.com/question/332569121/answer/733808658" target="_blank" rel="noopener">什么是人力资源中台模式？</a>：<a href="https://www.zhihu.com/question/332569121/answer/733808658" target="_blank" rel="noopener">https://www.zhihu.com/question/332569121/answer/733808658</a></p><p><a href="https://juejin.im/post/5d8093c251882579f24fb9ed" target="_blank" rel="noopener">中台是什么，到底要解决什么问题？</a>：<a href="https://juejin.im/post/5d8093c251882579f24fb9ed" target="_blank" rel="noopener">https://juejin.im/post/5d8093c251882579f24fb9ed</a></p><p><a href="https://mp.weixin.qq.com/s/dpkteHsQJ4Rwl6YNl2PVeg?" target="_blank" rel="noopener">从平台到中台【上】</a>：<a href="https://mp.weixin.qq.com/s/dpkteHsQJ4Rwl6YNl2PVeg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dpkteHsQJ4Rwl6YNl2PVeg</a>?</p><p><a href="https://mp.weixin.qq.com/s/TirTQfWo0gX9PUw_okdGjQ?" target="_blank" rel="noopener">从平台到中台【下】</a>：<a href="https://mp.weixin.qq.com/s/TirTQfWo0gX9PUw_okdGjQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/TirTQfWo0gX9PUw_okdGjQ</a>?</p><p><a href="https://book.douban.com/subject/27039508/" target="_blank" rel="noopener">陈华编著《企业IT架构转型之道：阿里巴巴中台战略思想与架构实战》</a>：<a href="https://book.douban.com/subject/27039508/" target="_blank" rel="noopener">https://book.douban.com/subject/27039508/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文来自 PoemByte 公众号，作者 kayzhao&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;没有XX台的时代-烟囱式的架构&quot;&gt;&lt;a href=&quot;#没有XX台的时代-烟囱式的架构&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="解决方案" scheme="http://www.glmapper.com/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="解决方案" scheme="http://www.glmapper.com/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
      <category term="中台" scheme="http://www.glmapper.com/tags/%E4%B8%AD%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>ClassLoader 类加载-type checking 对类加载的影响</title>
    <link href="http://www.glmapper.com/2020/05/01/java-base-classloader-typecheck/"/>
    <id>http://www.glmapper.com/2020/05/01/java-base-classloader-typecheck/</id>
    <published>2020-05-01T01:33:57.000Z</published>
    <updated>2020-05-01T03:59:55.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Type-Checking"><a href="#Type-Checking" class="headerlink" title="Type Checking"></a>Type Checking</h2><p>Type Checking (类型检测) 的作用是分析程序在编译或者运行期间，其类型表达是否一致的一个过程。举个例子：如果一个变量被声明为 int 类型，那么他就不能被赋值为实际的值（或者字符串类型、或者其他任何类型）。java 语言的类型检测分为两种：</p><ul><li>静态类型检测（static checking）: 问题在程序运行之前被自动找到，也就是在编译阶段完成的检查。静态类型检测更多的是关注在”类型“上。</li><li>动态类型检测（dynamic checking）: 问题在运行期间被检测，动态运行检测关注的是在”值“上。</li></ul><p>本文主要介绍静态类型检测。java 语言在编译时会做大量的类型检测，只要你声明了一个变量的类型，编译器将会确保只有相应类型的值可以被赋值给这个变量（或者这个值的类型是变量类型的子类型）。比如，如果你声明了如下变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br></pre></td></tr></table></figure></p><p>这里可以确保它只保存 int 值。但是，如果将变量声明为 List，则该变量可能包含列表的子类型，包括 ArrayList、LinkedList 等。</p><h2 id="Type-Checking-对类加载的影响"><a href="#Type-Checking-对类加载的影响" class="headerlink" title="Type Checking 对类加载的影响"></a>Type Checking 对类加载的影响</h2><p>前面提到静态类型检测主要是对类型的检测，而 java 语言中，类型一致表示的是 <code>类全限定名+ClassLoader</code> 一致，所以在做类型检测时就必定会涉及到某些类的 class load 操作。下面我们就从几个方面来分析下类型检测对于类加载的影响。</p><blockquote><p>在 jvm 参数中配置 -verbose:class 可以观察类加载过程</p></blockquote><h3 id="方法的返回类型"><a href="#方法的返回类型" class="headerlink" title="方法的返回类型"></a>方法的返回类型</h3><p>在下面的例子中， Main 执行过程，check 方法没有被调用，但是该方法返回了一个非 ClassA 的类型，也就是类型 ClassB。那么类型检测就要求就提前加载 ClassA 和 ClassB 类型，加以验证，因此加载顺序如下（ClassA –&gt; ClassB –&gt; ClassC –&gt; ClassD）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> <span class="keyword">extends</span> <span class="title">ClassA</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassC</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassD</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ClassC c;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        c = <span class="keyword">new</span> ClassC();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ClassD();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ClassA <span class="title">check</span><span class="params">(ClassA a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClassB();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行查看类加载顺序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Loaded com.glmapper.bridge.boot.methodreturn.Main from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class="line">[Loaded sun.launcher.LauncherHelper$FXHelper from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded java.lang.Class$MethodArray from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded com.glmapper.bridge.boot.methodreturn.ClassA from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class="line">[Loaded com.glmapper.bridge.boot.methodreturn.ClassB from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class="line">[Loaded java.lang.Void from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded com.glmapper.bridge.boot.methodreturn.ClassC from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class="line">[Loaded com.glmapper.bridge.boot.methodreturn.ClassD from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br></pre></td></tr></table></figure><p>从这里可以看到，静态域不一定会比非静态域先加载，这里就是因为静态检测提前出发了类的加载导致。</p><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><p>先来看下下面这段代码，大家可以想一下类加载顺序是什么样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> <span class="keyword">extends</span> <span class="title">ClassA</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassC</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ClassC c;</span><br><span class="line">    <span class="keyword">static</span>  &#123;</span><br><span class="line">        c = <span class="keyword">new</span> ClassC();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main main = <span class="keyword">new</span> Main();</span><br><span class="line">        main.m(<span class="keyword">new</span> ClassB());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">(ClassA a)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照我们惯性理解，Main 加载之后，会加载 ClassC，然后再加载 ClassA 和 ClassB。但是事实是这样吗？通过 <code>-verbose:class</code> 参数执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Loaded com.glmapper.bridge.boot.paramscheck.Main from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class="line">[Loaded sun.launcher.LauncherHelper$FXHelper from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded java.lang.Class$MethodArray from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded com.glmapper.bridge.boot.paramscheck.ClassA from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class="line">[Loaded com.glmapper.bridge.boot.paramscheck.ClassB from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class="line">[Loaded java.lang.Void from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded com.glmapper.bridge.boot.paramscheck.ClassC from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br></pre></td></tr></table></figure></p><p>但是从这里看到，Main 执行时， ClassA ，ClassB 先于 ClassC 加载了。原因是类型检测过程中，会一行行先行的看你的代码，在这个场景中，它发现有 m(ClassA a) 方法，但是代码中传入了 ClassB 这个类型，那么在真正运行 main 方法之前，在运行 Main 的 static 块之前，先行加载了 ClassA 和 ClassB 两个类型，然后验证它们之间的关系。所以看到的类加载顺序是 ClassA -&gt; ClassB -&gt; ClassC ，而非我们概念中的 ClassC -&gt; ClassA -&gt; ClassB。</p><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>最后一种场景是变量赋值，来看下面的代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> <span class="keyword">extends</span> <span class="title">ClassA</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassC</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassD</span> </span>&#123;</span><br><span class="line">    ClassA a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ClassC c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        c = <span class="keyword">new</span> ClassC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassD d = <span class="keyword">new</span> ClassD();</span><br><span class="line">        d.a = <span class="keyword">new</span> ClassB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 main 方法时，在 jvm 参数中配置 -verbose:class 来观察类型加载顺序；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Loaded com.glmapper.bridge.boot.variableassign.Main from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class="line">[Loaded sun.launcher.LauncherHelper$FXHelper from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded java.lang.Class$MethodArray from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded com.glmapper.bridge.boot.variableassign.ClassA from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class="line">[Loaded com.glmapper.bridge.boot.variableassign.ClassB from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class="line">[Loaded java.lang.Void from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded com.glmapper.bridge.boot.variableassign.ClassC from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class="line">[Loaded com.glmapper.bridge.boot.variableassign.ClassD from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br></pre></td></tr></table></figure><p>是不是又有点出乎意料呢？类型检测发现 Main 中包含了 d.a = new ClassB() 的语句，其中 d.a 的类型不是 ClassB，因此会先于 main 方法执行以及先于 Main 中的 static 块执行进行加载。 类型检测，将类型 ClassA 和 ClassB 的加载“提前”了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要介绍了静态类型检测对于 Class Loader 加载类顺序的影响，了解此逻辑对于在考虑多 class loader 场景处理问题非常有用，对于常规的类似 ClassCastExcetion, LinkageError 等异常排查有一定的意义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Type-Checking&quot;&gt;&lt;a href=&quot;#Type-Checking&quot; class=&quot;headerlink&quot; title=&quot;Type Checking&quot;&gt;&lt;/a&gt;Type Checking&lt;/h2&gt;&lt;p&gt;Type Checking (类型检测) 的作用是分
      
    
    </summary>
    
      <category term="java 基础" scheme="http://www.glmapper.com/categories/java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="classloader" scheme="http://www.glmapper.com/tags/classloader/"/>
    
  </entry>
  
  <entry>
    <title>【译】微服务（microservices）</title>
    <link href="http://www.glmapper.com/2020/04/12/solution-series-microservices/"/>
    <id>http://www.glmapper.com/2020/04/12/solution-series-microservices/</id>
    <published>2020-04-12T10:47:34.000Z</published>
    <updated>2020-04-12T11:21:03.652Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">https://martinfowler.com/articles/microservices.html</a></p></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>微服务体系结构的特征</li><li>通过服务拆分实现组件化</li><li>围绕业务功能进行组织</li><li>产品不是项目</li><li>智能端点和轻量级通信</li><li>分散治理</li><li>分散的数据管理</li><li>基础设施自动化</li><li>容错设计</li><li>演进式设计</li><li>微服务是未来的趋势吗?</li></ul><h2 id="Sidebars-扩展"><a href="#Sidebars-扩展" class="headerlink" title="Sidebars-扩展"></a>Sidebars-扩展</h2><ul><li>微服务有多大?</li><li>Microservices和SOA</li><li>多种语言，多种选择</li><li>经过实战检验的标准和强制执行的标准</li><li>让做正确的事情变得容易</li><li>断路器和可随时上线的代码</li><li>同步调用的弊端</li></ul><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><table><thead><tr><th>术语原词</th><th>释义</th></tr></thead><tbody><tr><td>Microservice Architecture</td><td>微服务架构</td></tr><tr><td>automated deployment</td><td>自动部署</td></tr><tr><td>centralized management</td><td>集中管理</td></tr><tr><td>communicating</td><td>通信、交互</td></tr><tr><td>lightweight mechanisms</td><td>轻量级机制</td></tr><tr><td>monolithic application</td><td>单体应用/集中式应用</td></tr><tr><td>load-balancer</td><td>负载均衡器</td></tr><tr><td>modular structure</td><td>模块化结构</td></tr><tr><td>Componentization/components</td><td>组件化/组件</td></tr><tr><td>physical world</td><td>客观世界</td></tr><tr><td>OO programs</td><td>面向对象编程</td></tr><tr><td>encapsulation</td><td>封装</td></tr><tr><td>processes</td><td>进程</td></tr><tr><td>cross-team</td><td>跨团队</td></tr><tr><td>boundaries</td><td>边界</td></tr><tr><td>business capability</td><td>业务能力</td></tr><tr><td>business area</td><td>业务领域</td></tr><tr><td>cross-functional</td><td>跨职能的</td></tr><tr><td>message bus.</td><td>消息总线</td></tr><tr><td>Smart endpoints</td><td>智能端点</td></tr><tr><td>dumb pipes</td><td>轻量级通信</td></tr><tr><td>Decentralized Governance</td><td>去中心化治理</td></tr><tr><td>Infrastructure Automation</td><td>基础设施自动化</td></tr><tr><td>Design for failure</td><td>容错机制设计</td></tr><tr><td>Evolutionary Design</td><td>演进/迭代 设计</td></tr><tr><td>coarser-grained</td><td>粗粒度的</td></tr></tbody></table><h2 id="一个新架构术语的定义"><a href="#一个新架构术语的定义" class="headerlink" title="一个新架构术语的定义"></a>一个新架构术语的定义</h2><blockquote><p>The term “Microservice Architecture” has sprung up over(涌现出了) the last few years to describe a particular(特定的) way of designing software applications as suites of independently deployable services.</p></blockquote><p>过去几年中出现了“微服务架构”一词，用以描述将软件应用程序设计为可独立部署的服务套件的特定方法。</p><blockquote><p>While there is no precise(精确) definition of this architectural style，there are certain(某些) common characteristics around organization around business capability(业务功能), automated deployment(自动部署), intelligence in the endpoints, and decentralized(分散的，去中心化的) control of languages and data.</p></blockquote><p>虽然没有对这种架构风格的精确定义，但围绕业务功能的组织，自动部署，端点智能以及在编程语言和数据方面进行去中心化的控制方面存在某些共同特征。</p><blockquote><p>“Microservices” - yet another new term on the crowded streets of software architecture. Although our natural inclination is to pass such things by with a contemptuous glance, this bit of terminology describes a style of software systems that we are finding more and more appealing.</p></blockquote><p>“微服务” - 在繁多的软件架构术语中又多了一个新的名词。 虽然我们对于这种新的概念打心底里自然是不削一顾的，但这个术语描述了一种对于我们来说越来越有吸引力的软件系统风格。</p><blockquote><p>We’ve seen many projects use this style in the last few years, and results so far have been positive, so much so that for many of our colleagues this is becoming the default style for building enterprise applications.</p></blockquote><p>我们已经看到许多项目在过去几年中使用了这种架构风格，并且都取得了很不错的结果；以至于对于我们的许多同事来说，这已成为构建企业应用程序的默认架构风格了。</p><blockquote><p>Sadly, however, there’s not much information that outlines what the microservice style is and how to do it.</p></blockquote><p>然而，遗憾的是，现在还没有太多信息可以概述微服务是什么，以及我们该如何实现微服务架构。</p><blockquote><p>In short, the microservice architectural style [1] is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API.</p></blockquote><p>简单来说，微服务架构风格[1]就是以开发一组小型服务的方式来开发一个独立的应用系统的，每个单体服务都在自己独立的进程中运行，并以HTTP资源API这种轻量级机制进行通信。</p><blockquote><p>These services are built around business capabilities and independently deployable by fully automated deployment machinery.</p></blockquote><p>这些服务围绕业务功能构建，可通过自动化部署机制进行独立部署。</p><blockquote><p>There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.</p></blockquote><p>这些服务具有最低限度的集中管理，可以用不同的编程语言编写，也可以使用不同的数据存储技术。</p><blockquote><p>To start explaining the microservice style it’s useful to compare it to the monolithic style: a monolithic application built as a single unit.</p></blockquote><p>在开始介绍微服务风格之前，将它与单体应用进行比较是很有用的。</p><blockquote><p>Enterprise Applications are often built in three main parts: a client-side user interface (consisting of HTML pages and javascript running in a browser on the user’s machine) a database (consisting of many tables inserted into a common, and usually relational, database management system), and a server-side application.</p></blockquote><p>企业级应用通常由三个主要部分构成：</p><ul><li>客户端用户界面(由在用户机器上的浏览器中运行的HTML页面和javascript组成)</li><li>数据库(由插入到公共(通常是关系)数据库管理系统中的许多表组成)</li><li>服务器端应用程序。</li></ul><blockquote><p>The server-side application will handle HTTP requests, execute domain logic, retrieve and update data from the database, and select and populate HTML views to be sent to the browser.</p></blockquote><p>服务器端应用负责处理HTTP请求、执行域逻辑、从数据库检索和更新数据，并选择和填充要发送到浏览器的HTML视图。</p><blockquote><p>This server-side application is a monolith - a single logical executable[2]. Any changes to the system involve building and deploying a new version of the server-side application.</p></blockquote><p>这个服务器端应用是一个整体 - 一个可执行的逻辑程序[2]。 对系统的任何更改都涉及构建和部署新版本的服务器端应用程序。</p><blockquote><p>Such a monolithic server is a natural way to approach building such a system.All your logic for handling a request runs in a single process, allowing you to use the basic features of your language to divide up the application into classes, functions, and namespaces.With some care, you can run and test the application on a developer’s laptop, and use a deployment pipeline to ensure that changes are properly tested and deployed into production.</p></blockquote><p>这种单体服务器是构建上述系统的常规方式。所有请求的逻辑处理都运行在单个进程中，允许使用语言的基本特性将应用程序划分为类、函数和命名空间。通过这样一些设计，你可以在开发人员的笔记本电脑上运行和测试应用程序，并使用部署流程平台来确保变更可以被正确地测试然后再将其部署到生产环境中。</p><blockquote><p>You can horizontally scale the monolith by running many instances behind a load-balancer.</p></blockquote><p>最后，通过负载均衡器运行许多实例，已达到将这个单体应用进行横向扩展的目的。</p><blockquote><p>Monolithic applications can be successful, but increasingly people are feeling frustrations with them - especially as more applications are being deployed to the cloud .Change cycles are tied together - a change made to a small part of the application, requires the entire monolith to be rebuilt and deployed. </p></blockquote><p>单体应用架构可以很成功的实现，但是随着越来越多的应用程序被部署到云上时，人们对它们将会越来越感到失望。<br>因为对于单体架构的应用来说，每当对一个小小的功能进行修改时，都会涉及到整个应用的重新构建和部署，实际上这个局部功能的改动是不应该对整个应用造成影响的。</p><blockquote><p>Over time it’s often hard to keep a good modular structure, making it harder to keep changes that ought to only affect one module within that module. Scaling requires scaling of the entire application rather than parts of it that require greater resource.</p></blockquote><p>随着时间的推移，单体应用也很难保持一个良好的模块化结构，因为把一个模块的变更影响控制在该模块内将会变得非常困难。当对系统进行扩展时，不得不扩展整个应用系统，而不是对需要更多资源的部分应用程序进行扩展。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/micro/one-more.png" alt=""></p><p>图1：单应用架构和微服务架构</p><blockquote><p>These frustrations have led to the microservice architectural style: building applications as suites of services.</p></blockquote><p>这一系列的问题导致了微服务架构风格产生：以构建一组服务的方式来构建应用系统。</p><blockquote><p>As well as the fact that services are independently deployable and scalable, each service also provides a firm module boundary, even allowing for different services to be written in different programming languages. They can also be managed by different teams .</p></blockquote><p>除了服务是可独立部署和可伸缩的这一事实之外，每个服务还提供了一个可靠的模块边界，甚至允许用不同的编程语言编写不同的服务。它们也可以由不同的团队管理。</p><blockquote><p>We do not claim that the microservice style is novel or innovative, its roots go back at least to the design principles of Unix. But we do think that not enough people consider a microservice architecture and that many software developments would be better off if they used it.</p></blockquote><p>我们并不认为微服务架构风格是新颖或创新的，它的根源至少可以追溯到Unix的设计原则。但是我们认为目前还没有足够多的人考虑微服务体系架构，如果他们都参与使用这个架构风格的话，许多软件的开发将会变得更好。</p><h2 id="Characteristics-of-a-Microservice-Architecture-微服务架构的特征"><a href="#Characteristics-of-a-Microservice-Architecture-微服务架构的特征" class="headerlink" title="Characteristics of a Microservice Architecture-微服务架构的特征"></a>Characteristics of a Microservice Architecture-微服务架构的特征</h2><blockquote><p>We cannot say there is a formal definition of the microservices architectural style, but we can attempt to describe what we see as common characteristics for architectures that fit the label.</p></blockquote><p>我们不能说微服务体系架构风格有一个正式的定义，但是我们可以尝试去描述我们所看到的符合这个标签的体系结构的一些共同特征。</p><blockquote><p>As with any definition that outlines common characteristics, not all microservice architectures have all the characteristics, but we do expect that most microservice architectures exhibit most characteristics.</p></blockquote><p>与任何概述共同特征的定义一样，并非所有的微服务体系架构都具有所有特征，但我们期望常见的微服务都应该有这些特性。</p><blockquote><p>While we authors have been active members of this rather loose community, our intention is to attempt a description of what we see in our own work and in similar efforts by teams we know of. In particular we are not laying down some definition to conform to.</p></blockquote><p>虽然我们作者是这个相当松散的社区的活跃成员，但我们的意图是尝试描述我们在自己的工作中看到的内容，以及我们所知道的团队在类似的工作中所做的工作。特别是，我们不依赖于那些已经明确过的定义。</p><h2 id="Componentization-via-Services-通过服务拆分实现组件化"><a href="#Componentization-via-Services-通过服务拆分实现组件化" class="headerlink" title="Componentization via Services-通过服务拆分实现组件化"></a>Componentization via Services-通过服务拆分实现组件化</h2><blockquote><p>For as long as we’ve been involved in the software industry, there’s been a desire to build systems by plugging together components, much in the way we see things are made in the physical world.</p></blockquote><p>只要我们参与到软件行业，就一直希望通过将组件集成在一起来构建系统，就像我们在物理世界中看到事物的方式一样。</p><blockquote><p>During the last couple of decades we’ve seen considerable progress with large compendiums of common libraries that are part of most language platforms.</p></blockquote><p>在过去的几十年中，我们已经看到了作为大多数语言平台一部分的公共库，已经在大量组合方面取得了相当大的进展。</p><blockquote><p>When talking about components we run into the difficult definition of what makes a component. Our definition is that a component is a unit of software that is independently replaceable and upgradeable.</p></blockquote><p>在讨论组件时，我们遇到了一个困惑是组件到底是什么。我们的定义是，组件一个可独立替换和升级的软件单元。</p><blockquote><p>Microservice architectures will use libraries, but their primary way of componentizing their own software is by breaking down into services.</p></blockquote><p>微服务架构会使用库，但他们将自己的软件组件化的主要方式是把它拆分成服务</p><blockquote><p>We define libraries as components that are linked into a program and called using in-memory function calls, while services are out-of-process components who communicate with a mechanism such as a web service request, or remote procedure call. (This is a different concept to that of a service object in many OO programs [3].)</p></blockquote><p>我们将库定义为链接到程序并使用内存内函数调用的组件，而服务是进程外组件，它们通过诸如web服务请求或远程过程调用之类的机制进行通信。（这与许多面向对象程序中的服务对象的概念不同[3]。）</p><blockquote><p>One main reason for using services as components (rather than libraries) is that services are independently deployable.</p></blockquote><p>将服务用作组件（而不是库）的一个主要原因是服务可以独立部署。</p><blockquote><p>If you have an application <a href="https://martinfowler.com/articles/microservices.html#footnote-application" target="_blank" rel="noopener">[4]</a> that consists of a multiple libraries in a single process, a change to any single component results in having to redeploy the entire application.</p></blockquote><p>如果您在单个进程中有一个由多个库组成的应用程序[4]，则对任何单个组件的更改都会导致必须重新部署整个应用程序。</p><blockquote><p>But if that application is decomposed into multiple services, you can expect many single service changes to only require that service to be redeployed.</p></blockquote><p>但是，如果将该应用程序分解为多个服务，那你只需要重新部署那个改变的服务就可以。</p><blockquote><p>That’s not an absolute, some changes will change service interfaces resulting in some coordination, but the aim of a good microservice architecture is to minimize these through cohesive service boundaries and evolution mechanisms in the service contracts.</p></blockquote><p>但是这也不是绝对的，比如一些更改将会更改服务接口，从而导致一些协调问题，但是一个好的微服务体系结构的目标是通过服务契约中的内聚服务边界和演进机制将这些更改最小化。</p><blockquote><p>Another consequence of using services as components is a more explicit component interface.Most languages do not have a good mechanism for defining an explicit <a href="https://martinfowler.com/bliki/PublishedInterface.html" target="_blank" rel="noopener">Published Interface</a>.Often it’s only documentation and discipline that prevents clients breaking a component’s encapsulation, leading to overly-tight coupling between components.Services make it easier to avoid this by using explicit remote call mechanisms.</p></blockquote><p>将服务用作组件的另一个结果是将拥有更清晰的组件接口。大多数语言都没有定义显式发布接口的良好机制。通常只有文档和规则的说明来防止客户端破坏组件的封装，避免组件之间的耦合过于紧密。但是通过使用显式远程调用机制，则更容易避免这种情况。</p><blockquote><p>Using services like this does have downsides. Remote calls are more expensive than in-process calls, and thus remote APIs need to be coarser-grained, which is often more awkward to use.</p></blockquote><p>但是这种方式也有不足的地方。主要是远程调用比进程内调用更昂贵，因此远程api需要是粗粒度的，但这会比较难用。</p><blockquote><p>If you need to change the allocation of responsibilities between components, such movements of behavior are harder to do when you’re crossing process boundaries.</p></blockquote><p>如果您需要更改组件之间的职责分配，那么当你需要跨进程时，这种行为的迁移将更加困难。</p><blockquote><p>At a first approximation, we can observe that services map to runtime processes, but that is only a first approximation.</p></blockquote><p>一种可能是，我们可以观察到服务映射到运行时进程上，但这只是一种可能。</p><blockquote><p>A service may consist of multiple processes that will always be developed and deployed together, such as an application process and a database that’s only used by that service.</p></blockquote><p>服务可以由多个进程组成，这些进程可以同时开发和部署，例如一个应用程序进程和一个只能由这个服务使用的数据库。</p><h3 id="Organized-around-Business-Capabilities-围绕业务功能组织"><a href="#Organized-around-Business-Capabilities-围绕业务功能组织" class="headerlink" title="Organized around Business Capabilities-围绕业务功能组织"></a>Organized around Business Capabilities-围绕业务功能组织</h3><blockquote><p>When looking to split a large application into parts, often management focuses on the technology layer, leading to UI teams, server-side logic teams, and database teams. </p></blockquote><p>当希望将大型应用程序分解为多个模块时，管理通常关注于技术层，重要的包括UI团队、服务器端逻辑团队和数据库团队。</p><blockquote><p>When teams are separated along these lines, even simple changes can lead to a cross-team project taking time and budgetary approval.</p></blockquote><p>当团队按照这些原则分开时，即使是简单的更改也可能涉及到跨团队沟通，那么这样项目就会需要增加时间和预算审批等成本。</p><blockquote><p>A smart team will optimise around this and plump for the lesser of two evils - just force the logic into whichever application they have access to. Logic everywhere in other words. This is an example of Conway’s Law<a href="https://martinfowler.com/articles/microservices.html#footnote-conwayslaw" target="_blank" rel="noopener">[5]</a> in action.</p></blockquote><p>一个优秀的团队将围绕这一点进行改善，并选择两害相权取其轻——只需将逻辑强制应用到他们能够访问的任何应用程序中。换句话说，逻辑无处不在。这是康威定律[5]的一个例子。</p><blockquote><p>Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization’s communication structure.<br>任何设计系统(广义定义)的组织都会产生一个结构是组织通信结构副本的设计。<br>– Melvyn Conway, 1967</p></blockquote><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/micro/kangwei.png" alt=""><br>图2:康韦定律的作用</p><blockquote><p>The microservice approach to division is different, splitting up into services organized around <strong>business capability</strong>. </p></blockquote><p>划分微服务方法是不同的，但更倾向于围绕业务功能的组织来进行服务划分。</p><blockquote><p>Such services take a broad-stack implementation of software for that business area, including user-interface, persistant storage, and any external collaborations.</p></blockquote><p>这些服务在商业领域软件上有广泛实施，包括用户界面、持久性存储和任何外部协作。</p><blockquote><p>Consequently the teams are cross-functional, including the full range of skills required for the development: user-experience, database, and project management.</p></blockquote><p>因此，团队是跨职能的，包括开发所需的全方位技能:用户体验、数据库和项目管理。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/micro/service-boundle.png" alt=""><br>图3:由团队边界加强的服务边界</p><blockquote><p>One company organised in this way is <a href="http://www.comparethemarket.com/" target="_blank" rel="noopener">www.comparethemarket.com</a>. Cross functional teams are responsible for building and operating each product and each product is split out into a number of individual services communicating via a message bus.</p></blockquote><p><a href="http://www.comparethemarket.com" target="_blank" rel="noopener">www.comparethemarket.com</a> 就是采样这样组织形式的一家公司。跨职能团队负责同时构建和运维每个产品，每个产品都被划分为许多单个服务，服务间再通过消息总线进行通信。</p><blockquote><p>Large monolithic applications can always be modularized around business capabilities too, although that’s not the common case.Certainly we would urge a large team building a monolithic application to divide itself along business lines. </p></blockquote><p>大型集中式应用程序也可以围绕业务功能进行模块划分，尽管这种情况并不常见。当然，我们会敦促构建完整应用程序的大型团队沿着业务线进行自我划分。</p><blockquote><p>The main issue we have seen here, is that they tend to be organised around <em>too many</em> contexts.</p></blockquote><p>我们在这里看到的主要问题是，它们往往围绕太多的上下文背景进行组织（依赖太多，包袱太重）。</p><blockquote><p>If the monolith spans many of these modular boundaries it can be difficult for individual members of a team to fit them into their short-term memory.Additionally we see that the modular lines require a great deal of discipline to enforce. The necessarily more explicit separation required by service components makes it easier to keep the team boundaries clear.</p></blockquote><p>如果整个应用会跨越许多这样的模块边界时，这对于团队中的一些成员来说也很难短期内可以掌握。此外，我们看到模块化开发需要大量的规范来遵守执行。但是对于服务组件这种需要进行明确的业务划分的要求的情况下，可以使得保持团队职能边界清晰变得更加容易。</p><h3 id="Products-not-Projects-产品不是项目"><a href="#Products-not-Projects-产品不是项目" class="headerlink" title="Products not Projects-产品不是项目"></a>Products not Projects-产品不是项目</h3><blockquote><p>Most application development efforts that we see use a project model: where the aim is to deliver some piece of software which is then considered to be completed. On completion the software is handed over to a maintenance organization and the project team that built it is disbanded.</p></blockquote><p>我们看到的大多数应用程序开发工作都使用这样的项目模式：目标是交付一个他们认为完成的软件。接着，软件被移交给运维团队，项目开发团队被解散。</p><blockquote><p>Microservice proponents tend to avoid this model, preferring instead the notion that a team should own a product over its full lifetime. </p></blockquote><p>微服务的支持者倾向于避免这种模式，他们更希望团队应该负责产品的整个生命周期。</p><blockquote><p>A common inspiration for this is Amazon’s notion of <a href="https://queue.acm.org/detail.cfm?id=1142065" target="_blank" rel="noopener">“you build, you run it”</a> where a development team takes full responsibility for the software in production.This brings developers into day-to-day contact with how their software behaves in production and increases contact with their users, as they have to take on at least some of the support burden. </p></blockquote><p>一个常见的灵感是Amazon的“你构建，你运行它”的概念，在这个概念中，开发团队需要对产品承担全部责任。这使得开发人员能够在日常中关注到软件运行情况，并增加与用户的联系，同时必须承担一些支持工作。</p><blockquote><p>The product mentality, ties in with the linkage to business capabilities. Rather than looking at the software as a set of functionality to be completed, there is an on-going relationship where the question is how can software assist its users to enhance the business capability.</p></blockquote><p>产品的理念，与业务能力联系在一起。与其将软件看作一组要完成的功能，还不如将软件看作是一种持续的关系，在这种关系中，软件是如何帮助用户增强业务能力。</p><blockquote><p>There’s no reason why this same approach can’t be taken with monolithic applications, but the smaller granularity of services can make it easier to create the personal relationships between service developers and their users.</p></blockquote><p>没有理由不能在单体应用程序中采用相同的方法，但是服务粒度越小，就越容易在服务开发人员和用户之间创建个人关系。</p><h3 id="Smart-endpoints-and-dumb-pipes-智能端点和轻量级通信"><a href="#Smart-endpoints-and-dumb-pipes-智能端点和轻量级通信" class="headerlink" title="Smart endpoints and dumb pipes-智能端点和轻量级通信"></a>Smart endpoints and dumb pipes-智能端点和轻量级通信</h3><blockquote><p>When building communication structures between different processes, we’ve seen many products and approaches that stress putting significant smarts into the communication mechanism itself.</p></blockquote><p>在构建不同进程之间的通信结构时，我们看到许多产品和方法都强调在通信机制本身中投入大量的方案。</p><blockquote><p>A good example of this is the Enterprise Service Bus (ESB), where ESB products often include sophisticated facilities for message routing, choreography, transformation, and applying business rules.</p></blockquote><p>这方面的一个很好的例子是企业服务总线(ESB)，ESB产品通常包含用于消息路由、编排、转换和应用业务规则的复杂工具。</p><blockquote><p>The microservice community favours an alternative approach: <em>smart endpoints and dumb pipes</em>. </p></blockquote><p>在微服务社区则支持另一种方法:智能端点和轻量级通信。</p><blockquote><p>Applications built from microservices aim to be as decoupled and as cohesive as possible - they own their own domain logic and act more as filters in the classical Unix sense - receiving a request, applying logic as appropriate and producing a response.</p></blockquote><p>使用微服务构建的应用程序旨在尽可能地解耦和内聚 - 采用独立的业务逻辑，表现的更像经典Unix意义上的过滤器一样，接受请求、处理业务逻辑，然后返回响应。</p><blockquote><p>These are choreographed using simple RESTish protocols rather than complex protocols such as WS-Choreography or BPEL or orchestration by a central tool.</p></blockquote><p>它们更喜欢简单的REST风格，而不是使用复杂的协议，如WS-Choreography、BPEL或集中式框架。</p><blockquote><p>The two protocols used most commonly are HTTP request-response with resource API’s and lightweight messaging<a href="https://martinfowler.com/articles/microservices.html?spm=a2c4e.11153940.blogcont2764.12.fd5b2766lUOPyQ#footnote-protobufs" target="_blank" rel="noopener">[8]</a>.</p></blockquote><p>最常用的两种协议是带有资源API的HTTP请求-响应协议和轻量级消息传递[8]协议。 第一个是最好的描述是:善于利用网络，而不是限制。</p><blockquote><p>Be of the web, not behind the web<br><a href="https://www.amazon.com/gp/product/0596805829?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0596805829" target="_blank" rel="noopener">– Ian Robinson</a></p></blockquote><blockquote><p>Microservice teams use the principles and protocols that the world wide web (and to a large extent, Unix) is built on. Often used resources can be cached with very little effort on the part of developers or operations folk.</p></blockquote><p>微服务团队使用构建在互联网(很大程度上是Unix)上的原则和协议。开发人员或操作人员只需很少的精力就可以缓存经常使用的资源。</p><blockquote><p>The second approach in common use is messaging over a lightweight message bus. The infrastructure chosen is typically dumb (dumb as in acts as a message router only) - simple implementations such as RabbitMQ or ZeroMQ don’t do much more than provide a reliable asynchronous fabric - the smarts still live in the end points that are producing and consuming messages; in the services.</p></blockquote><p>第二种常用的方式是通过轻量级消息总线进行消息传递。所选择的基础设施通常是单一的(只负责消息路由)——像RabbitMQ或者ZeroMQ这样的简单的实现，连可靠的异步机制都没有提供——导致仍然需要依赖产生或者消费消息的终端或者服务来处理这类问题。</p><blockquote><p>In a monolith, the components are executing in-process and communication between them is via either method invocation or function call. The biggest issue in changing a monolith into microservices lies in changing the communication pattern. A naive conversion from in-memory method calls to RPC leads to chatty communications which don’t perform well. Instead you need to replace the fine-grained communication with a coarser -grained approach.</p></blockquote><p>在单体应用中，组件在进程内执行，它们之间的通信要么通过方法调用要么通过回调函数。将单体架构变为微服务架构的最大问题在于改变通信模式。 从内存中的方法调用到RPC调用的简单转换会导致通信性能的下降。因此，你需要用更粗粒度的方法替换细粒度的通信。</p><h3 id="Decentralized-Governance-分散治理"><a href="#Decentralized-Governance-分散治理" class="headerlink" title="Decentralized Governance-分散治理"></a>Decentralized Governance-分散治理</h3><blockquote><p>One of the consequences of centralised governance is the tendency to standardise on single technology platforms. Experience shows that this approach is constricting - not every problem is a nail and not every solution a hammer. We prefer using the right tool for the job and while monolithic applications can take advantage of different languages to a certain extent, it isn’t that common.</p></blockquote><p>集中治理的优势在于可以在单一技术平台上实现标准化。经验表明，这种方法是有局限性的——不是每个问题都是很棘手，也不是每个解决方案都是万能的。我们更喜欢使用适合这项工作的工具，虽然单体应用程序可以在一定程度上利用不同的语言，但这种情况并不常见。</p><blockquote><p>Splitting the monolith’s components out into services we have a choice when building each of them. You want to use Node.js to standup a simple reports page? Go for it. C++ for a particularly gnarly near-real-time component? Fine. You want to swap in a different flavour of database that better suits the read behaviour of one component? We have the technology to rebuild him.</p></blockquote><p>把整体式框架中的组件，拆分成不同的服务，这样构建它们时就会有更多的选择性。 您想使用Node.js站立一个简单的报告页面吗？ 去吧。 C ++是否适用于特别近乎实时的组件？做吧。 您想要交换不同风格的数据库，以更好地适应一个组件的读取行为？ 我们同样有重构它的技术。</p><blockquote><p>Of course, just because you <em>can</em> do something, doesn’t mean you <em>should</em> - but partitioning your system in this way means you have the option.</p></blockquote><p>当然，仅仅因为你可以做一些事情，并不意味着你就应该这么做——但是以这种方式对系统进行划分意味着你可以选择。</p><blockquote><p>Teams building microservices prefer a different approach to standards too. Rather than use a set of defined standards written down somewhere on paper they prefer the idea of producing useful tools that other developers can use to solve similar problems to the ones they are facing.These tools are usually harvested from implementations and shared with a wider group, sometimes, but not exclusively using an internal open source model. Now that git and github have become the de facto version control system of choice, open source practices are becoming more and more common in-house .</p></blockquote><p>与其选用一组写在纸上已经定义好的标准，他们更喜欢编写一些有用的工具，来让其他开发者能够使用，以便解决那些和他们所面临的问题相似的问题。这些工具通常源自他们的微服务实施过程，并且被分享到更大规模的组织中，这种分享有时会使用内部开源的模式来进行。现在，git和github已经成为事实上的首选版本控制系统。在企业内部，开源的做法也正在变得越来越普遍。</p><blockquote><p>Netflix is a good example of an organisation that follows this philosophy. Sharing useful and, above all, battle-tested code as libraries encourages other developers to solve similar problems in similar ways yet leaves the door open to picking a different approach if required. Shared libraries tend to be focused on common problems of data storage, inter-process communication and as we discuss further below, infrastructure automation.</p></blockquote><p>Netflix公司是遵循上述理念的好例子。将实用且经过实战检验的代码以软件库的形式共享出来，能鼓励其他开发人员以相似的方式来解决相似的问题，当然也为在需要的时候选用不同的方案留了一扇门。共享软件库往往集中在解决这样的常见问题，即数据存储、进程间的通信和下面要进一步讨论的基础设施的自动化。</p><blockquote><p>For the microservice community, overheads are particularly unattractive. That isn’t to say that the community doesn’t value service contracts. Quite the opposite, since there tend to be many more of them. It’s just that they are looking at different ways of managing those contracts. Patterns like <a href="https://martinfowler.com/bliki/TolerantReader.html" target="_blank" rel="noopener">Tolerant Reader</a> and <a href="https://martinfowler.com/articles/consumerDrivenContracts.html" target="_blank" rel="noopener">Consumer-Driven Contracts</a> are often applied to microservices. These aid service contracts in evolving independently. Executing consumer driven contracts as part of your build increases confidence and provides fast feedback on whether your services are functioning. Indeed we know of a team in Australia who drive the build of new services with consumer driven contracts. They use simple tools that allow them to define the contract for a service. This becomes part of the automated build before code for the new service is even written. The service is then built out only to the point where it satisfies the contract - an elegant approach to avoid the ‘YAGNI’<a href="https://martinfowler.com/articles/microservices.html#footnote-YAGNI" target="_blank" rel="noopener">[9]</a>dilemma when building new software. These techniques and the tooling growing up around them, limit the need for central contract management by decreasing the temporal coupling between services.</p></blockquote><p>对于微服务社区来说，管理费用特别缺乏吸引力。 这并不是说社区不重视服务合同。 恰恰相反，因为往往会有更多。只是他们正在寻找管理这些合同的不同方式。像“容错读取”和“消费者驱动的契约”这样的模式，经常被运用到微服务中。这些都有助于服务契约进行独立演进。将执行“ 消费者驱动的契约 ”做为软件构建的一部分，能增强开发团队的信心，并提供所依赖的服务是否正常工作的快速反馈。实际上，我们了解到一个在澳大利亚的团队就是使用“ 消费者驱动的契约 ”来驱动构建多个新服务的。他们使用了一些简单的工具，来针对每一个服务定义契约。甚至在新服务的代码编写之前，这件事就已经成为自动化构建的一部分了。接下来服务仅被构建到刚好能满足契约的程度——这是一个在构建新软件时避免YAGNI <strong>[9]</strong> 困境的优雅方法。这些技术和工具在契约周边生长出来，由于减少了服务之间在时域(temporal)上的耦合，从而抑制了对中心契约管理的需求。</p><blockquote><p>Perhaps the apogee of decentralised governance is the build it / run it ethos popularised by Amazon. Teams are responsible for all aspects of the software they build including operating the software 24/7. Devolution of this level of responsibility is definitely not the norm but we do see more and more companies pushing responsibility to the development teams. Netflix is another organisation that has adopted this ethos<a href="https://martinfowler.com/articles/microservices.html#footnote-netflix-flowcon" target="_blank" rel="noopener">[11]</a>. Being woken up at 3am every night by your pager is certainly a powerful incentive to focus on quality when writing your code. These ideas are about as far away from the traditional centralized governance model as it is possible to be.</p></blockquote><p>也许分散治理治理技术的极盛时期，就是亚马逊的“你构建，你运行”的理念开始普及的时候。 每个团队负责他们构建的软件的全生命周期，包括持续的软件的运维。 把运维的这种能力放到团队的做法目前还不是主流的，但我们确实看到越来越多的公司将运维的职责推向开发团队。 Netflix是另一个采用这种模式的组织[11]。 如果你不想每天凌晨3点被喊起来去改bug，那么你就该在编写代码时投入更多的精力和时间。 但是这些想法与传统的集中治理模式相差甚远。</p><h3 id="Decentralized-Data-Management-分散的数据管理"><a href="#Decentralized-Data-Management-分散的数据管理" class="headerlink" title="Decentralized Data Management-分散的数据管理"></a>Decentralized Data Management-分散的数据管理</h3><blockquote><p>Decentralization of data management presents in a number of different ways. At the most abstract level, it means that the conceptual model of the world will differ between systems. This is a common issue when integrating across a large enterprise, the sales view of a customer will differ from the support view. Some things that are called customers in the sales view may not appear at all in the support view. Those that do may have different attributes and (worse) common attributes with subtly different semantics.</p></blockquote><p>分散化的数据管理以多种不同的方式呈现。 在最抽象的层面上来看的话，就意味着各个系统对客观世界所构建的概念模型是彼此各不相同的。 这是在大型企业中集成时的常见问题，比如对于客户来说，销售视角和支持视角肯定是不同的。 销售视角中客户的某些内容可能根本不会出现在支持视角中。即使在两个视角中都能看到的事物，那么各自关注的核心信息也是不同的。极端情况下，甚至两个视角中具有相同属性的事物，或许在语义上也会有细的差距。</p><blockquote><p>This issue is common between applications, but can also occur _within_applications, particular when that application is divided into separate components. A useful way of thinking about this is the Domain-Driven Design notion of <a href="https://martinfowler.com/bliki/BoundedContext.html" target="_blank" rel="noopener">Bounded Context</a>. DDD divides a complex domain up into multiple bounded contexts and maps out the relationships between them. This process is useful for both monolithic and microservice architectures, but there is a natural correlation between service and context boundaries that helps clarify, and as we describe in the section on business capabilities, reinforce the separations.</p></blockquote><p>上述问题在不同的应用程序之间经常出现，当然应用程序内部也会出现，尤其是当一个应用程序被分成不同组件的情况下。思考这类问题的一个可靠的方法，就是使用领域驱动设计（Domain-Driven Design, DDD）中的“限界上下文”的概念。DDD将一个复杂的领域划分为多个限界上下文，并且将其相互之间的关系用图画出来。这一划分过程对于单体架构和微服务架构两者都是有用的，而且就像前面有关“业务功能”一节中所讨论的那样，在服务和各个限界上下文之间所存在的自然的联动关系，能有助于澄清和强化这种划分。</p><blockquote><p>As well as decentralizing decisions about conceptual models, microservices also decentralize data storage decisions. While monolithic applications prefer a single logical database for persistant data, enterprises often prefer a single database across a range of applications - many of these decisions driven through vendor’s commercial models around licensing. Microservices prefer letting each service manage its own database, either different instances of the same database technology, or entirely different database systems - an approach called <a href="https://martinfowler.com/bliki/PolyglotPersistence.html" target="_blank" rel="noopener">Polyglot Persistence</a>. You can use polyglot persistence in a monolith, but it appears more frequently with microservices.</p></blockquote><p>除了关于概念模型的分散决策之外，微服务还分散了数据存储决策。 虽然单体应用程序通常都是使用单个逻辑数据库来存储持久性数据，但企业往往喜欢一系列单体应用共用一个单独的数据库 - 其中许多决策是通过供应商围绕许可的商业模型来实现的（供应商的版权商业模式所驱动）。 微服务体系中更偏向让每个服务实例管理自己的数据库，可以是相同数据库技术的不同实例，也可以是完全不同的数据库系统 – 这种方法称为 Polyglot Persistence（多语言持久化）。在一个单体系统中也能使用多语种持久化，但它在微服务中更常出现。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/micro/persistence.png" alt=""></p><blockquote><p>Decentralizing responsibility for data across microservices has implications for managing updates. The common approach to dealing with updates has been to use transactions to guarantee consistency when updating multiple resources. This approach is often used within monoliths.</p></blockquote><p>跨微服务分散数据责任对管理更新具有影响。处理软件更新的常用方法，是当更新多个资源的时候，需要使用事务来保证一致性。这种方法经常在单块系统中被采用。</p><blockquote><p>Using transactions like this helps with consistency, but imposes significant temporal coupling, which is problematic across multiple services. Distributed transactions are notoriously difficult to implement and as a consequence microservice architectures <a href="http://www.eaipatterns.com/ramblings/18_starbucks.html" target="_blank" rel="noopener">emphasize transactionless coordination between services</a>, with explicit recognition that consistency may only be eventual consistency and problems are dealt with by compensating operations.</p></blockquote><p>通过使用事务，有助于保持数据一致性。但对时间的消耗是严重的，而当在多个服务之间处理事务时也会出现一致性问题。众所周知，分布式事务很难实现，因此微服务架构强调服务间事务协调，明确认识到一致性可能只是最终的一致性及通过补偿操作来处理问题。</p><blockquote><p>Choosing to manage inconsistencies in this way is a new challenge for many development teams, but it is one that often matches business practice. Often businesses handle a degree of inconsistency in order to respond quickly to demand, while having some kind of reversal process to deal with mistakes. The trade-off is worth it as long as the cost of fixing mistakes is less than the cost of lost business under greater consistency.</p></blockquote><p>对于许多开发团队来说，选择以这种方式管理数据的“不一致性”问题是一个新的挑战，但是这又是一种非常常见的业务实践场景。为了对需求做出快速反应，企业通常会允许一定程度上的数据“不一致性”，但同时也会采用一些恢复的进程来处理这种错误 。只要业务上处理强一致性成本比处理错误的成本少时，那么这种“ 不一致性”地管理数据的权衡就是值得的。</p><h3 id="Infrastructure-Automation-基础设施高度自动化"><a href="#Infrastructure-Automation-基础设施高度自动化" class="headerlink" title="Infrastructure Automation-基础设施高度自动化"></a>Infrastructure Automation-基础设施高度自动化</h3><blockquote><p>Infrastructure automation techniques have evolved enormously over the last few years - the evolution of the cloud and AWS in particular has reduced the operational complexity of building, deploying and operating microservices.</p></blockquote><p>在过去几年里，基础设施自动化技术有了很大的发展——云计算和AWS的发展降低了构建、部署和运维微服务的复杂性。</p><blockquote><p>Many of the products or systems being build with microservices are being built by teams with extensive experience of <a href="https://martinfowler.com/bliki/ContinuousDelivery.html" target="_blank" rel="noopener">Continuous Delivery</a> and it’s precursor, <a href="https://martinfowler.com/articles/continuousIntegration.html" target="_blank" rel="noopener">Continuous Integration</a>. Teams building software this way make extensive use of infrastructure automation techniques. This is illustrated in the build pipeline shown below.</p></blockquote><p>许多使用微服务构建的产品或系统都是由具有大量 持续交付与其前身持续集成 经验的团队构建的。以这种方式构建软件的团队广泛使用了基础设施自动化技术。如下图的构建流水线所示：</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/micro/pipeline.png" alt=""></p><p>图5:基本构建流程</p><blockquote><p>Since this isn’t an article on Continuous Delivery we will call attention to just a couple of key features here. We want as much confidence as possible that our software is working, so we run lots of <strong>automated tests</strong>. Promotion of working software ‘up’ the pipeline means we <strong>automate deployment</strong> to each new environment.</p></blockquote><p>由于这不是一篇关于持续交付的文章，我们将在这里只关注几个关键特性。我们希望我们的软件能够正常工作，所以我们运行了大量的自动化测试。让可工作的软件达到“晋级”(Promotion)状态从而“推上”流水线，就意味着可以在 每一个新的环境中，对软件进行 <strong>自动化部署</strong> 。</p><blockquote><p>A monolithic application will be built, tested and pushed through these environments quite happlily. It turns out that once you have invested in automating the path to production for a monolith, then deploying _more_applications doesn’t seem so scary any more. Remember, one of the aims of CD is to make deployment boring, so whether its one or three applications, as long as its still boring it doesn’t matter<a href="https://martinfowler.com/articles/microservices.html#footnote-trickycd" target="_blank" rel="noopener">[12]</a>.</p></blockquote><p>对于单体应用来说，可以轻松的在上述的各个环境中进行构建、测试和发布。其结果是，一旦投入到自动化平台， 那么部署更多的应用系统似乎就不再可怕。记住，持续交付的目的之一，是让“部署”工作变得“无聊”。所以不管是一个还是三个应用系统，只要是部署工作，就依旧很“无聊”，那么就没什么可担心的了 <strong>[12]</strong> 。</p><blockquote><p>Another area where we see teams using extensive infrastructure automation is when managing microservices in production. In contrast to our assertion above that as long as deployment is boring there isn’t that much difference between monoliths and microservices, the operational landscape for each can be strikingly different.</p></blockquote><p>另一个方面，我们发现使用微服务的团队更加依赖于基础设施的自动化。与前面我们对比单体系统和微服务所说的正相反，只要部署工作很无聊，那么在这一点上单块系统和微服务就没什么区别。然而，两者在运维领域的情况却截然不同。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/micro/multi-module.png" alt=""><br>图6:模块部署通常是不同的</p><h3 id="Design-for-failure-“容错”设计"><a href="#Design-for-failure-“容错”设计" class="headerlink" title="Design for failure-“容错”设计"></a>Design for failure-“容错”设计</h3><blockquote><p>A consequence of using services as components, is that applications need to be designed so that they can tolerate the failure of services. Any service call could fail due to unavailability of the supplier, the client has to respond to this as gracefully as possible. This is a disadvantage compared to a monolithic design as it introduces additional complexity to handle it. The consequence is that microservice teams constantly reflect on how service failures affect the user experience. Netflix’s <a href="https://github.com/Netflix/SimianArmy" target="_blank" rel="noopener">Simian Army</a> induces failures of services and even datacenters during the working day to test both the application’s resilience and monitoring.</p></blockquote><p>使用各个微服务来替代组件，其结果是各个应用程序需要设计成能够容忍这些服务所出现的故障。如果服务提供方不可用，那么任何对该服务的调用都会出现故障。客户端要尽可能优雅地应对这种情况。与单体应用设计相比，这是一个劣势。因为这会引人额外的复杂性来处理这种情况。这需要微服务团队要时刻考虑到服务故障情况下的用户体验。Netflix公司所研发的开源测试工具Simian Army，可以为每个应用的服务及数据中心提供日常故障检测和恢复。</p><blockquote><p>This kind of automated testing in production would be enough to give most operation groups the kind of shivers usually preceding a week off work. This isn’t to say that monolithic architectural styles aren’t capable of sophisticated monitoring setups - it’s just less common in our experience.</p></blockquote><p>这种在生产环境中所进行的自动化测试，能足以让大多数运维组织兴奋得浑身颤栗，就像在一周的长假即将到来前那样。这并不是说单体架构风格不能构建先进的监控系统——只是根据我们的经验，这在单体系统中并不常见罢了。</p><blockquote><p>Since services can fail at any time, it’s important to be able to detect the failures quickly and, if possible, automatically restore service. Microservice applications put a lot of emphasis on real-time monitoring of the application, checking both architectural elements (how many requests per second is the database getting) and business relevant metrics (such as how many orders per minute are received). Semantic monitoring can provide an early warning system of something going wrong that triggers development teams to follow up and investigate.</p></blockquote><p>因为每个服务都可能在任何时候发生故障，所以下面两件事就变得很重要，即 快速故障检测 和 自动恢复。各个微服务的应用都将大量的精力放到了应用程序的实时监控上，来检查“架构元素指标”（例如数据库每秒收到多少请求）和“业务相关指标”（例如系统每分钟收到多少订单）。当系统某个地方出现问题，监控系统能提供一个预警，来触发开发团队进行后续的跟进和调查工作。</p><blockquote><p>This is particularly important to a microservices architecture because the microservice preference towards choreography and <a href="https://martinfowler.com/eaaDev/EventCollaboration.html" target="_blank" rel="noopener">event collaboration</a> leads to emergent behavior. While many pundits praise the value of serendipitous emergence, the truth is that emergent behavior can sometimes be a bad thing. Monitoring is vital to spot bad emergent behavior quickly so it can be fixed.</p></blockquote><p>这对于一个微服务架构是非常重要的，因为微服务之间交互通信随时都可能出现一些紧急的意外情况。尽管许多权威人士对于突发情况的价值持积极态度，但事实上，突发情况有时可能会酿成大的灾难。在能够快速发现有坏处的突发情况并进行修复的方面，监控是至关重要的。</p><blockquote><p>Monoliths can be built to be as transparent as a microservice - in fact, they should be. The difference is that you absolutely need to know when services running in different processes are disconnected. With libraries within the same process this kind of transparency is less likely to be useful.</p></blockquote><p>单体系统也能构建像微服务那样来实现透明的一套监控系统——实际上，它们也应该如此。差别是，绝对需要知道那些运行在不同进程中的服务，在何时断掉了。而如果在同一个进程内使用软件库的话，这种透明的监控系统就用处不大了。</p><blockquote><p>Microservice teams would expect to see sophisticated monitoring and logging setups for each individual service such as dashboards showing up/down status and a variety of operational and business relevant metrics. Details on circuit breaker status, current throughput and latency are other examples we often encounter in the wild.</p></blockquote><p>微服务团队希望在每一个单独的服务中，都能看到良好的监控和日志记录装置。例如显示“运行/宕机”状态的仪表盘，和各种运维和业务相关的指标。另外我们经常在工作中会碰到这样一些细节，即断路器的状态、当前的吞吐率和延迟，以及其他一些例子。</p><h3 id="Evolutionary-Design-“演进式”设计"><a href="#Evolutionary-Design-“演进式”设计" class="headerlink" title="Evolutionary Design-“演进式”设计"></a>Evolutionary Design-“演进式”设计</h3><blockquote><p>Microservice practitioners, usually have come from an evolutionary design background and see service decomposition as a further tool to enable application developers to control changes in their application without slowing down change. Change control doesn’t necessarily mean change reduction - with the right attitudes and tools you can make frequent, fast, and well-controlled changes to software.</p></blockquote><p>微服务的从业者们，通常具有演进式设计的背景，他们把服务分解成进一步的工具，以达到可以让应用开发者在不改变速度情况下，控制他们应用的需求变更。变更控制并不一定意味着要减少变化——在正确的方式和工具的帮助下，能在软件中让变更发生得频繁、快速且有良好的控制。</p><blockquote><p>Whenever you try to break a software system into components, you’re faced with the decision of how to divide up the pieces - what are the principles on which we decide to slice up our application? The key property of a component is the notion of independent replacement and upgradeability<a href="https://martinfowler.com/articles/microservices.html#footnote-RCA" target="_blank" rel="noopener">[13]</a> - which implies we look for points where we can imagine rewriting a component without affecting its collaborators. Indeed many microservice groups take this further by explicitly expecting many services to be scrapped rather than evolved in the longer term.</p></blockquote><p>每当试图要将软件系统分解为各个组件时，就会面临这样的问题，即如何进行切分——我们决定切分应用系统时应该遵循的原则是什么？首要的因素，组件可以被独立替换和更新的 <strong>[13]</strong> ——这意味着，需要寻找这些点，即想象着能否在其中一个点上重写该组件，而无须影响该组件的其他合作组件。事实上，许多微服务团队考虑的更多的是，如何明确地预期许多服务将来会报废，而不是守着这些服务做长期迭代。</p><blockquote><p>The Guardian website is a good example of an application that was designed and built as a monolith, but has been evolving in a microservice direction. The monolith still is the core of the website, but they prefer to add new features by building microservices that use the monolith’s API. This approach is particularly handy for features that are inherently temporary, such as specialized pages to handle a sporting event. Such a part of the website can quickly be put together using rapid development languages, and removed once the event is over. We’ve seen similar approaches at a financial institution where new services are added for a market opportunity and discarded after a few months or even weeks.</p></blockquote><p>Guardian网站就是这方面的一个优秀的例子。它初期被设计和构建成一个单体架构应用，然而它已经开始向微服务方向进行迭代演进了。原先的单体系统依旧是该网站的核心，但是在添加新特性时，他们愿意以构建微服务的方式来进行添加，而这些微服务会去调用原先那个单体系统的API。当在开发那些本身就带有临时性特点的新特性时， 这种方法就特别方便，例如开发那些报道一个体育赛事的专门页面。当使用一些快速的开发语言时，像这样的网站页面就能被快速地整合起来。而一旦赛事结束，这样页面就可以被删除。在一个金融机构中，我们已经看到了一些相似的做法，即针对一个市场机会，一些新的服务可以被添加进来。然后在几个月甚至几周之后，这些新服务就作废了。</p><blockquote><p>This emphasis on replaceability is a special case of a more general principle of modular design, which is to drive modularity through the pattern of change <a href="https://martinfowler.com/articles/microservices.html#footnote-beck-rate-of-change" target="_blank" rel="noopener">[14]</a>. You want to keep things that change at the same time in the same module. Parts of a system that change rarely should be in different services to those that are currently undergoing lots of churn. If you find yourself repeatedly changing two services together, that’s a sign that they should be merged.</p></blockquote><p>这种强调可更换性的特点，是模块化设计一般性原则的一个特例，需求变更通过进行模块化的方式实现。大家都愿意将那些能在同时发生变化的东西，放到同一个模块中。系统中那些很少发生变化的部分，应该被放到不同的服务中，以区别于那些当前正在经历大量变动(churn)的部分。如果发现需要同时反复变更两个服务时，这就是它们两个需要被合并的一个信号。</p><blockquote><p>Putting components into services adds an opportunity for more granular release planning. With a monolith any changes require a full build and deployment of the entire application. With microservices, however, you only need to redeploy the service(s) you modified. This can simplify and speed up the release process. The downside is that you have to worry about changes to one service breaking its consumers. The traditional integration approach is to try to deal with this problem using versioning, but the preference in the microservice world is to <a href="https://martinfowler.com/articles/enterpriseREST.html#versioning" target="_blank" rel="noopener">only use versioning as a last resort</a>. We can avoid a lot of versioning by designing services to be as tolerant as possible to changes in their suppliers.</p></blockquote><p>把组件改成服务，增加了作出更加精细的软件发布计划的机会。对于一个单体系统，任何变化都需要做一次整个应用系统的全量构建和部署。然而，对于微服务来说，只需要重新部署修改过的那些服务就够了。这能简化并加快发布过程。但缺点是：必须要考虑当一个服务发生变化时，依赖它并对其进行消费的其他服务可能将无法工作。传统的集成方法是试图使用版本化来解决这个问题。但在微服务世界中，大家更喜欢将版本化作为最后万不得已的手段来使用 。我们需要在设计服务时尽可能的容忍供应商的变更，以避免提供多个版本。</p><h2 id="Are-Microservices-the-Future-未来的方向是“微服务”吗？"><a href="#Are-Microservices-the-Future-未来的方向是“微服务”吗？" class="headerlink" title="Are Microservices the Future?-未来的方向是“微服务”吗？"></a>Are Microservices the Future?-未来的方向是“微服务”吗？</h2><blockquote><p>Our main aim in writing this article is to explain the major ideas and principles of microservices. By taking the time to do this we clearly think that the microservices architectural style is an important idea - one worth serious consideration for enterprise applications. We have recently built several systems using the style and know of others who have used and favor this approach.</p></blockquote><p>我们写这篇文章的主要目的是来解释有关微服务的主要思路和原则。在花了一点时间做了这件事后，我们清楚地认识到，微服务架构风格是一个重要的架构方案——在研发企业应用系统时，值得对它进行认真考虑。我们最近已经使用这种风格构建了一些系统，并且了解到其他一些团队也在使用并支持这种方法。</p><blockquote><p>Those we know about who are in some way pioneering the architectural style include Amazon, Netflix, <a href="http://www.theguardian.com/" target="_blank" rel="noopener">The Guardian</a>, the <a href="https://gds.blog.gov.uk/" target="_blank" rel="noopener">UK Government Digital Service</a>, <a href="https://martinfowler.com/articles/realestate.com.au" target="_blank" rel="noopener">realestate.com.au</a>, Forward and <a href="http://www.comparethemarket.com/" target="_blank" rel="noopener">comparethemarket.com</a>. The conference circuit in 2013 was full of examples of companies that are moving to something that would class as microservices - including Travis CI. In addition there are plenty of organizations that have long been doing what we would class as microservices, but without ever using the name. (Often this is labelled as SOA - although, as we’ve said, SOA comes in many contradictory forms. <a href="https://martinfowler.com/articles/microservices.html#footnote-already" target="_blank" rel="noopener">[15]</a>)</p></blockquote><p>我们所了解到的实践先驱包括：亚马逊、Netflix、The Guardian、The UK Government Digital Service、realestate.com.au、Forward和comparethemarket.com。在2013年的技术大会圈子里充满了各种各样的正在转向微服务的公司案例——包括Travis CI。另外还有大量的组织，它们长期以来一直在做着我们可以归类为微服务的产品，却从未使用过这个名字（这通常被标记为SOA—— 尽管正如我们所说，SOA会表现出各种自相矛盾的形式 <strong>[15]</strong> ）。</p><blockquote><p>Despite these positive experiences, however, we aren’t arguing that we are certain that microservices are the future direction for software architectures. While our experiences so far are positive compared to monolithic applications, we’re conscious of the fact that not enough time has passed for us to make a full judgement.</p></blockquote><p>尽管有这些正面的经验，然而并不是说我们确信微服务是软件架构的未来的方向。尽管到目前为止，与单体应用系统相比，我们对于所经历过的微服务架构的评价都是积极的，但是我们也意识到这样的事实，即能供我们做出完整判断的时间还不够长。</p><blockquote><p>Often the true consequences of your architectural decisions are only evident several years after you made them. We have seen projects where a good team, with a strong desire for modularity, has built a monolithic architecture that has decayed over the years. Many people believe that such decay is less likely with microservices, since the service boundaries are explicit and hard to patch around. Yet until we see enough systems with enough age, we can’t truly assess how microservice architectures mature.</p></blockquote><p>通常，架构决策的真正效果只有在做出这些决策几年之后才会表现出来。我们已经看到由带着强烈的模块化愿望的优秀团队所做的一些项目，最终却构建出一个单体架构，并在几年之内不断腐化。许多人认为，这种腐化不太可能与微服务有关，因为服务的边界是明确的，很难往里面塞新的东西。但是，当我们还没看到足够多的系统运行足够长时间时，我们不能肯定微服务构架是成熟的。</p><blockquote><p>There are certainly reasons why one might expect microservices to mature poorly. In any effort at componentization, success depends on how well the software fits into components. It’s hard to figure out exactly where the component boundaries should lie. Evolutionary design recognizes the difficulties of getting boundaries right and thus the importance of it being easy to refactor them. But when your components are services with remote communications, then refactoring is much harder than with in-process libraries. Moving code is difficult across service boundaries, any interface changes need to be coordinated between participants, layers of backwards compatibility need to be added, and testing is made more complicated.</p></blockquote><p>有人觉得微服务或许很难成熟起来，这当然是有原因的。在组件化上所做的任何工作的是否有效，取决于软件与组件的匹配程度。要想准确地搞清楚某个组件的边界的位置是一件困难的事情。 演进式设计承认难以对边界进行正确定位，所以它将工作的重点放到了易于重构上。但是当各个组件成为各个进行远程通信的服务后，比起在单一进程内进行各个软件库之间的调用，重构就变得更加困难。跨服务边界的代码迁移也会变得困难起来。接口的任何变更，都需要在其各个参与者之间进行协调，向后兼容的层次也需要被添加进来，测试也会变得更加复杂。</p><blockquote><p>Another issue is If the components do not compose cleanly, then all you are doing is shifting complexity from inside a component to the connections between components. Not just does this just move complexity around, it moves it to a place that’s less explicit and harder to control. It’s easy to think things are better when you are looking at the inside of a small, simple component, while missing messy connections between services.</p></blockquote><p>另一个问题在于，如果组件并没有清晰的划分，那么这项工作的复杂性将会从组件内部转向组件间。后果是，不仅仅是将复杂性搬了家，它还将复杂性变得不可控。在一个小的、简单的组件内部考虑事情是很容易的，但也不能忽视了服务之间复杂的连接。</p><blockquote><p>Finally, there is the factor of team skill. New techniques tend to be adopted by more skillful teams. But a technique that is more effective for a more skillful team isn’t necessarily going to work for less skillful teams. We’ve seen plenty of cases of less skillful teams building messy monolithic architectures, but it takes time to see what happens when this kind of mess occurs with microservices. A poor team will always create a poor system - it’s very hard to tell if microservices reduce the mess in this case or make it worse.</p></blockquote><p>最后，对于团队技能也是一个因素。新的技术倾向于被掌握更多的技能的团队使用。适用于技术背景好的团队的技术，不一定适用于一个技术薄弱的团队。我们已经看到大量这样的案例，那些技术薄弱的团队构建出了杂乱的单体架构。当这种杂乱发生到微服务身上时，会出现什么情况？这需要花时间来观察 。一个糟糕的团队，总会构建一个糟糕的系统——在这种情况下，很难讲微服务究竟是减少了杂乱，还是让事情变得更糟。</p><blockquote><p>One reasonable argument we’ve heard is that you shouldn’t start with a microservices architecture. Instead <a href="https://martinfowler.com/bliki/MonolithFirst.html" target="_blank" rel="noopener">begin with a monolith</a>, keep it modular, and split it into microservices once the monolith becomes a problem. (Although <a href="https://martinfowler.com/articles/dont-start-monolith.html" target="_blank" rel="noopener">this advice isn’t ideal</a>, since a good in-process interface is usually not a good service interface.)</p></blockquote><p>我们听到一个合理的说法，是说不要一上来就以微服务架构做为起点。相反，要用一个单体系统做为起点，并保持其模块化。当这个单体系统出现了问题后，再将其分解为微服务。（尽管这个建议并不理想，因为一个良好的单一进程内的接口，通常不是一个良好的服务接口）</p><blockquote><p>So we write this with cautious optimism. So far, we’ve seen enough about the microservice style to feel that it can be <a href="https://martinfowler.com/microservices/" target="_blank" rel="noopener">a worthwhile road to tread</a>. We can’t say for sure where we’ll end up, but one of the challenges of software development is that you can only make decisions based on the imperfect information that you currently have to hand.</p></blockquote><p>因此，我们持谨慎乐观的态度来撰写此文。到目前为止，我们已经看到足够多的有关微服务风格的项目，并且觉得这是一条值得去探索的道路。我们不能肯定地说，道路的尽头在哪里。但是，软件开发的挑战之一，就是只能基于 “目前手上拥有但还不够完善” 的信息来做出决策。</p><h2 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h2><h3 id="Tips1-How-big-is-a-microservice-一个微服务应该有多大？"><a href="#Tips1-How-big-is-a-microservice-一个微服务应该有多大？" class="headerlink" title="Tips1 : How big is a microservice?-一个微服务应该有多大？"></a>Tips1 : How big is a microservice?-一个微服务应该有多大？</h3><blockquote><p>Although “microservice” has become a popular name for this architectural style, its name does lead to an unfortunate focus on the size of service, and arguments about what constitutes “micro”. In our conversations with microservice practitioners, we see a range of sizes of services. The largest sizes reported follow Amazon’s notion of the Two Pizza Team (i.e. the whole team can be fed by two pizzas), meaning no more than a dozen people. On the smaller size scale we’ve seen setups where a team of half-a-dozen would support half-a-dozen services.</p></blockquote><p>尽管“微服务”已经成为一个流行的名字，但是这个名字确实会不幸地导致大家对服务规模的关注，并且产生了有关什么是“微”的争论。在与微服务从业者的交谈中，我们看到了有关服务的一系列规模。所听到的最大的一个服务的规模，是遵循了亚马逊的“两个比萨团队”（即一个团队可以被两个比萨所喂饱）的理念，这意味着这个团队不会多于12人。对于规模较小的服务，我们已经看到一个6人的团队在支持6个服务。</p><blockquote><p>This leads to the question of whether there are sufficiently large differences within this size range that the service-per-dozen-people and service-per-person sizes shouldn’t be lumped under one microservices label. At the moment we think it’s better to group them together, but it’s certainly possible that we’ll change our mind as we explore this style further.</p></blockquote><p>这引出了一个问题，即“每12人做一个服务”和“每人做一个服务”这样有关服务规模的差距，是否已经大到不能将两者都纳入微服务之下？此时，我们认为最好还是把它们归为一类，但是随着进一步探索这种架构风格，绝对有可能我们会在将来改变主意。</p><h3 id="Tips2-Microservices-and-SOA-微服务与SOA"><a href="#Tips2-Microservices-and-SOA-微服务与SOA" class="headerlink" title="Tips2 : Microservices and SOA-微服务与SOA"></a>Tips2 : Microservices and SOA-微服务与SOA</h3><blockquote><p>When we’ve talked about microservices a common question is whether this is just Service Oriented Architecture (SOA) that we saw a decade ago. There is merit to this point, because the microservice style is very similar to what some advocates of SOA have been in favor of. The problem, however, is that SOA means <a href="https://martinfowler.com/bliki/ServiceOrientedAmbiguity.html" target="_blank" rel="noopener">too many different things</a>, and that most of the time that we come across something called “SOA” it’s significantly different to the style we’re describing here, usually due to a focus on ESBs used to integrate monolithic applications.</p></blockquote><p>当我们谈起微服务时，一个常见的问题就会出现：是否微服务仅仅是十多年前所看到的“面向服务的架构”(Service Oriented Architecture, SOA)？这样问是有道理的，因为微服务风格非常类似于一些支持SOA的人所赞成的观点。然而，问题在于SOA这个词儿意味着太多不同的东西。而且大多数时候，我们所遇到的某些被称作”SOA”的事物，明显不同于本文所描述的风格。这通常由于它们专注于ESB，来集成各个单体应用。</p><blockquote><p>In particular we have seen so many botched implementations of service orientation - from the tendency to hide complexity away in ESB’s <a href="https://martinfowler.com/articles/microservices.html#footnote-esb" target="_blank" rel="noopener">[6]</a>, to failed multi-year initiatives that cost millions and deliver no value, to centralised governance models that actively inhibit change, that it is sometimes difficult to see past these problems.</p></blockquote><p>特别地，我们已经看到如此之多的面向服务的拙劣实现——从将系统复杂性隐藏于ESB中的趋势 <strong>[7]</strong> ，到花费数百万进行多年却没有交付任何价值的失败项目，到顽固抑制变化发生的中心化技术治理模型——以至于有时觉得其所造成的种种问题真的不堪回首。</p><blockquote><p>Certainly, many of the techniques in use in the microservice community have grown from the experiences of developers integrating services in large organisations. The <a href="https://martinfowler.com/bliki/TolerantReader.html" target="_blank" rel="noopener">Tolerant Reader</a> pattern is an example of this. Efforts to use the web have contributed, using simple protocols is another approach derived from these experiences - a reaction away from central standards that have reached a complexity that is, <a href="http://wiki.apache.org/ws/WebServiceSpecifications" target="_blank" rel="noopener">frankly, breathtaking</a>. (Any time you need an ontology to manage your ontologies you know you are in deep trouble.)</p></blockquote><p>当然，在微服务社区投入使用的许多技术，源自各个开发人员将各种服务集成到各个大型组织的经验。“容错读取”(Tolerant Reader)模式就是这样一个例子。对于Web的广泛使用，使得人们不再使用一些中心化的标准，而使用一些简单的协议。坦率地说，这些中心化的标准，其复杂性已经达到令人吃惊的程度。（任何时候，如果需要一个本体（ontology）来管理其他各个本体，那么麻烦就大了）</p><blockquote><p>This common manifestation of SOA has led some microservice advocates to reject the SOA label entirely, although others consider microservices to be one form of SOA <a href="https://martinfowler.com/articles/microservices.html#footnote-fine-grained" target="_blank" rel="noopener">[7]</a>, perhaps <em>service orientation done right</em>. Either way, the fact that SOA means such different things means it’s valuable to have a term that more crisply defines this architectural style.</p></blockquote><p>这种常见的SOA的表现，已使得一些微服务的倡导者完全拒绝将自己贴上SOA的标签。尽管其他人会将微服务看作是SOA的 一种形式 <strong>[8]</strong> ，也许微服务就是以正确的形式来实现面向服务的SOA 。不管是哪种情况，SOA意味着很多的不同事物，这表明用一个更加干净利落的术语来命名这种架构风格是很有价值的。</p><h3 id="Tips3-Many-languages-many-options-多种编程语言，多种选择可能"><a href="#Tips3-Many-languages-many-options-多种编程语言，多种选择可能" class="headerlink" title="Tips3 : Many languages, many options-多种编程语言，多种选择可能"></a>Tips3 : Many languages, many options-多种编程语言，多种选择可能</h3><blockquote><p>The growth of JVM as a platform is just the latest example of mixing languages within a common platform. It’s been common practice to shell-out to a higher level language to take advantage of higher level abstractions for decades. As is dropping down to the metal and writing performance sensitive code in a lower level one. However, many monoliths don’t need this level of performance optimisation nor are DSL’s and higher level abstractions that common (to our dismay). Instead monoliths are usually single language and the tendency is to limit the number of technologies in use [10].</p></blockquote><p>做为一个平台，JVM的发展仅仅是一个将各种编程语言混合到一个通用平台的最新例证。近十年以来，在平台外层实现更高层次的编程语言，来利用更高层次的抽象，已经成为一个普遍做法。同样，在平台底层以更低层次的编程语言编写性能敏感的代码也很普遍。然而，许多单体系统并不需要这种级别的性能优化，另外DSL和更高层次的抽象也不常用（这令我们感到失望）。相反，许多单体应用通常就使用单一编程语言，并且有对所使用的技术数量进行 限制 的趋势 <strong>[10]</strong> 。</p><h3 id="Tips4-Battle-tested-standards-and-enforced-standards-”实战检验”的标准与“强制执行”的标准"><a href="#Tips4-Battle-tested-standards-and-enforced-standards-”实战检验”的标准与“强制执行”的标准" class="headerlink" title="Tips4 : Battle-tested standards and enforced standards-”实战检验”的标准与“强制执行”的标准"></a>Tips4 : Battle-tested standards and enforced standards-”实战检验”的标准与“强制执行”的标准</h3><blockquote><p>It’s a bit of a dichotomy that microservice teams tend to eschew the kind of rigid enforced standards laid down by enterprise architecture groups but will happily use and even evangelise the use of open standards such as HTTP, ATOM and other microformats.</p></blockquote><p>微服务的某些做法有点泾渭分明的味道，即他们趋向于避开被那些企业架构组织所制定的硬性实施的标准，而愉快地使用甚至传播一些开放标准，比如 HTTP、ATOM和其他微格式的协议。</p><blockquote><p>The key difference is how the standards are developed and how they are enforced. Standards managed by groups such as the IETF only <em>become</em> standards when there are several live implementations of them in the wider world and which often grow from successful open-source projects.</p></blockquote><p>这里的关键区别是，这些标准是如何被制定以及如何被实施的。像诸如IETF这样的组织所管理的各种标准，只有达到某些条件才能称为标准，即该标准在全球更广阔的地区有一些正在运行的实现案例，而且这些标准经常源自一些成功的开源项目。</p><blockquote><p>These standards are a world apart from many in a corporate world, which are often developed by groups that have little recent programming experience or overly influenced by vendors.</p></blockquote><p>这些标准组成了一个世界，它区别于来自企业世界的许多标准。企业世界中的标准，经常由这样特点的组织来开发，即缺乏用较新技术进行编程的经验，或受到供应商的过度影响。</p><h3 id="Tips5-Make-it-easy-to-do-the-right-thing-让做正确的事情变得容易"><a href="#Tips5-Make-it-easy-to-do-the-right-thing-让做正确的事情变得容易" class="headerlink" title="Tips5 : Make it easy to do the right thing-让做正确的事情变得容易"></a>Tips5 : Make it easy to do the right thing-让做正确的事情变得容易</h3><blockquote><p>One side effect we have found of increased automation as a consequence of continuous delivery and deployment is the creation of useful tools to help developers and operations folk. Tooling for creating artefacts, managing codebases, standing up simple services or for adding standard monitoring and logging are pretty common now. The best example on the web is probably <a href="http://netflix.github.io/" target="_blank" rel="noopener">Netflix’s set of open source tools</a>, but there are others including <a href="http://dropwizard.codahale.com/" target="_blank" rel="noopener">Dropwizard</a> which we have used extensively.</p></blockquote><p>那些因实现持续交付和持续集成所增加的自动化工作的副产品，是创建一些对开发和运维人员有用的工具。现在，能完成下面工作的工具已经相当常见了：即创建工件(artefacts)、管理代码库、启动一些简单的服务、或增加标准的监控和日志功能。Web上最好的例子可能是Netflix提供的一套开源工具集，但也有其他一些好工具，包括我们已经广泛使用的Dropwizard。</p><h3 id="Tips6-The-circuit-breaker-and-production-ready-code-“断路器”与“可随时上线的代码”"><a href="#Tips6-The-circuit-breaker-and-production-ready-code-“断路器”与“可随时上线的代码”" class="headerlink" title="Tips6 : The circuit breaker and production ready code-“断路器”与“可随时上线的代码”"></a>Tips6 : The circuit breaker and production ready code-“断路器”与“可随时上线的代码”</h3><blockquote><p><a href="https://martinfowler.com/bliki/CircuitBreaker.html" target="_blank" rel="noopener">Circuit Breaker</a> appears in <a href="https://www.amazon.com/gp/product/B00A32NXZO?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B00A32NXZO" target="_blank" rel="noopener">Release It!</a><br>alongside other patterns such as Bulkhead and Timeout. Implemented together, these patterns are crucially important when building communicating applications. This <a href="http://techblog.netflix.com/2012/02/fault-tolerance-in-high-volume.html" target="_blank" rel="noopener">Netflix blog entry</a> does a great job of explaining their application of them.</p></blockquote><p>“断路器”(Circuit Breaker )一词与其他一些模式一起出现在《发布！》(Release It! )一书中，例如隔板(Bulkhead)和超时(Timeout)。当构建彼此通信的应用系统时，将这些模式加以综合运用就变得至关重要。Netflix公司的这篇很精彩的博客解释了这些模式是如何应用的。</p><h3 id="Tips7-Synchronous-calls-considered-harmful-同步调用的弊端"><a href="#Tips7-Synchronous-calls-considered-harmful-同步调用的弊端" class="headerlink" title="Tips7 : Synchronous calls considered harmful-同步调用的弊端"></a>Tips7 : Synchronous calls considered harmful-同步调用的弊端</h3><blockquote><p>Any time you have a number of synchronous calls between services you will encounter the multiplicative effect of downtime. Simply, this is when the downtime of your system becomes the product of the downtimes of the individual components. You face a choice, making your calls asynchronous or managing the downtime. At <a href="http://www.guardian.co.uk" target="_blank" rel="noopener">www.guardian.co.uk</a> they have implemented a simple rule on the new platform - one synchronous call per user request while at Netflix, their platform API redesign has built asynchronicity into the API fabric.</p></blockquote><p>一旦在一些服务之间进行多个同步调用，就会遇到宕机的乘法效应。简而言之，这意味着整个系统的宕机时间，是每一个单独模块各自宕机时间的乘积。此时面临着一个选择：是让模块之间的调用异步，还是去管理宕机时间？在<a href="http://www.guardian.co.uk网站，他们在新平台上实现了一个简单的规则——每一个用户请求都对应一个同步调用。然而在Netflix公司，他们重新设计的平台API将异步性构建到API的机制(fabric)中。" target="_blank" rel="noopener">www.guardian.co.uk网站，他们在新平台上实现了一个简单的规则——每一个用户请求都对应一个同步调用。然而在Netflix公司，他们重新设计的平台API将异步性构建到API的机制(fabric)中。</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.aliyun.com/jiaocheng/292444.html" target="_blank" rel="noopener">https://www.aliyun.com/jiaocheng/292444.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://martinfowler.com/articles/microservices.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://martinfowler.com/
      
    
    </summary>
    
    
      <category term="微服务" scheme="http://www.glmapper.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实践系列-集成 RocketMQ</title>
    <link href="http://www.glmapper.com/2020/04/05/springboot-series-rocketmq/"/>
    <id>http://www.glmapper.com/2020/04/05/springboot-series-rocketmq/</id>
    <published>2020-04-05T11:39:17.000Z</published>
    <updated>2020-04-06T02:57:12.123Z</updated>
    
    <content type="html"><![CDATA[<p>RocketMQ 简介：Apache RocketMQ是一个分布式消息传递和流媒体平台，具有低延迟、高性能和可靠性、万亿级容量和灵活的可伸缩性。它提供了多种功能，具体参考: <a href="https://github.com/apache/rocketmq" target="_blank" rel="noopener">https://github.com/apache/rocketmq</a> 。</p><h2 id="RocketMQ-快速开始"><a href="#RocketMQ-快速开始" class="headerlink" title="RocketMQ 快速开始"></a>RocketMQ 快速开始</h2><p>官方指导手册快速开始中提到，RocketMQ 安装需要具体以下条件：</p><ul><li>64bit OS, 推荐使用 Linux/Unix/Mac </li><li>64bit JDK 1.8+</li><li>Maven 3.2.x</li><li>4g+ free disk for Broker server （这个需要特别关注下）</li></ul><h3 id="下载安装和编译"><a href="#下载安装和编译" class="headerlink" title="下载安装和编译"></a>下载安装和编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://archive.apache.org/dist/rocketmq/4.7.0/rocketmq-all-4.7.0-source-release.zip</span><br><span class="line">unzip rocketmq-all-4.7.0-source-release.zip</span><br><span class="line"><span class="built_in">cd</span> rocketmq-all-4.7.0/</span><br><span class="line">mvn -Prelease-all -DskipTests clean install -U</span><br><span class="line"><span class="built_in">cd</span> distribution/target/rocketmq-4.7.0/rocketmq-4.7.0</span><br></pre></td></tr></table></figure><p>1、启动 Name Server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; nohup sh bin/mqnamesrv &amp;</span><br><span class="line">&gt; tail -f ~/logs/rocketmqlogs/namesrv.log</span><br><span class="line">The Name Server boot success...</span><br></pre></td></tr></table></figure><p>2、启动 Broker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; nohup sh bin/mqbroker -n localhost:9876 &amp;</span><br><span class="line"><span class="comment"># nohup sh bin/mqbroker -n localhost:9876 autoCreateTopicEnable=true &amp;</span></span><br><span class="line">&gt; tail -f ~/logs/rocketmqlogs/broker.log </span><br><span class="line">The broker[%s, 172.30.30.233:10911] boot success...</span><br></pre></td></tr></table></figure><blockquote><p>autoCreateTopicEnable：使用 RocketMQ 进行发消息时，必须要指定 topic，对于 topic 的设置有一个开关 autoCreateTopicEnable，一般在开发测试环境中会使用默认设置 autoCreateTopicEnable = true，但是这样就会导致 topic 的设置不容易规范管理，没有统一的审核等等，所以在正式环境中会在 Broker 启动时设置参数 autoCreateTopicEnable = false。这样当需要增加 topic 时就需要在 web 管理界面上或者通过 admin tools 添加即可</p></blockquote><h2 id="SpringBoot-集成"><a href="#SpringBoot-集成" class="headerlink" title="SpringBoot 集成"></a>SpringBoot 集成</h2><p>RocketMQ 目前没有提供集成 SpringBoot 的 starter，因此现在接入都是通过引入客户端进行编程。下面来看下 SpringBoot 集成 RocketMQ 的过程。</p><h3 id="引入-RocketMQ-客户端依赖"><a href="#引入-RocketMQ-客户端依赖" class="headerlink" title="引入 RocketMQ 客户端依赖"></a>引入 RocketMQ 客户端依赖</h3><p>github 上目前更新的最新版本是 4.7.0 版本，这里就使用最新版本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="提供生产者的自动配置类"><a href="#提供生产者的自动配置类" class="headerlink" title="提供生产者的自动配置类"></a>提供生产者的自动配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl (glmapper_2018@163.com) 2020/4/5 5:17 PM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQProducerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MQProducerConfiguration.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.producer.groupName&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String             groupName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.producer.namesrvAddr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String             namesrvAddr;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.producer.maxMessageSize&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer            maxMessageSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.producer.sendMsgTimeout&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer            sendMsgTimeout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.producer.retryTimesWhenSendFailed&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer            retryTimesWhenSendFailed;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultMQProducer <span class="title">defaultMQProducer</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="keyword">this</span>.groupName);</span><br><span class="line">        producer.setNamesrvAddr(<span class="keyword">this</span>.namesrvAddr);</span><br><span class="line">        producer.setCreateTopicKey(<span class="string">"AUTO_CREATE_TOPIC_KEY"</span>);</span><br><span class="line">        <span class="comment">//如果需要同一个 jvm 中不同的 producer 往不同的 mq 集群发送消息，需要设置不同的 instanceName</span></span><br><span class="line">        <span class="comment">//producer.setInstanceName(instanceName);</span></span><br><span class="line">        <span class="comment">//如果发送消息的最大限制</span></span><br><span class="line">        producer.setMaxMessageSize(<span class="keyword">this</span>.maxMessageSize);</span><br><span class="line">        <span class="comment">//如果发送消息超时时间</span></span><br><span class="line">        producer.setSendMsgTimeout(<span class="keyword">this</span>.sendMsgTimeout);</span><br><span class="line">        <span class="comment">//如果发送消息失败，设置重试次数，默认为 2 次</span></span><br><span class="line">        producer.setRetryTimesWhenSendFailed(<span class="keyword">this</span>.retryTimesWhenSendFailed);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            producer.start();</span><br><span class="line">            LOGGER.info(<span class="string">"producer is started. groupName:&#123;&#125;, namesrvAddr: &#123;&#125;"</span>, groupName, namesrvAddr);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"failed to start producer."</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> producer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>groupName: 发送同一类消息的设置为同一个 group，保证唯一， 默认不需要设置，rocketmq 会使用 ip@pid(pid代表jvm名字) 作为唯一标示。</li><li>namesrvAddr：Name Server 地址</li><li>maxMessageSize：消息最大限制，默认 4M</li><li>sendMsgTimeout：消息发送超时时间，默认 3 秒</li><li>retryTimesWhenSendFailed：消息发送失败重试次数，默认 2 次</li></ul><h3 id="提供消费者的自动配置类"><a href="#提供消费者的自动配置类" class="headerlink" title="提供消费者的自动配置类"></a>提供消费者的自动配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQConsumerConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger  LOGGER = LoggerFactory.getLogger(MQConsumerConfiguration.class);</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.consumer.namesrvAddr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String                        namesrvAddr;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.consumer.groupName&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String                        groupName;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.consumer.consumeThreadMin&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                           consumeThreadMin;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.consumer.consumeThreadMax&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                           consumeThreadMax;</span><br><span class="line">    <span class="comment">// 订阅指定的 topic </span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.consumer.topics&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String                        topics;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.consumer.consumeMessageBatchMaxSize&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                           consumeMessageBatchMaxSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MQConsumeMsgListenerProcessor mqMessageListenerProcessor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultMQPushConsumer <span class="title">defaultMQPushConsumer</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line"></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(groupName);</span><br><span class="line">        consumer.setNamesrvAddr(namesrvAddr);</span><br><span class="line">        consumer.setConsumeThreadMin(consumeThreadMin);</span><br><span class="line">        consumer.setConsumeThreadMax(consumeThreadMax);</span><br><span class="line">        consumer.registerMessageListener(mqMessageListenerProcessor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 consumer 第一次启动是从队列头部开始消费还是队列尾部开始消费</span></span><br><span class="line">        <span class="comment">// 如果非第一次启动，那么按照上次消费的位置继续消费</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        <span class="comment">// 设置消费模型，集群还是广播，默认为集群</span></span><br><span class="line">        consumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line">        <span class="comment">// 设置一次消费消息的条数，默认为 1 条</span></span><br><span class="line">        consumer.setConsumeMessageBatchMaxSize(consumeMessageBatchMaxSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置该消费者订阅的主题和tag，如果是订阅该主题下的所有tag，使用*；</span></span><br><span class="line">            consumer.subscribe(topics, <span class="string">"*"</span>);</span><br><span class="line">            <span class="comment">// 启动消费</span></span><br><span class="line">            consumer.start();</span><br><span class="line">            LOGGER.info(<span class="string">"consumer is started. groupName:&#123;&#125;, topics:&#123;&#125;, namesrvAddr:&#123;&#125;"</span>,groupName,topics,namesrvAddr);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"failed to start consumer . groupName:&#123;&#125;, topics:&#123;&#125;, namesrvAddr:&#123;&#125;"</span>,groupName,topics,namesrvAddr,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> consumer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数参考上述生产者部分。这里配置只是启动的消费端的监听，具体的消费需要再实现一个 MessageListenerConcurrently 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl (glmapper_2018@163.com) 2020/4/5 5:21 PM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListenerHandler</span> <span class="keyword">implements</span> <span class="title">MessageListenerConcurrently</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MessageListenerHandler.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String TOPIC = <span class="string">"DemoTopic"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(msgs)) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">"receive blank msgs..."</span>);</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">        MessageExt messageExt = msgs.get(<span class="number">0</span>);</span><br><span class="line">        String msg = <span class="keyword">new</span> String(messageExt.getBody());</span><br><span class="line">        <span class="keyword">if</span> (messageExt.getTopic().equals(TOPIC)) &#123;</span><br><span class="line">            <span class="comment">// mock 消费逻辑</span></span><br><span class="line">            mockConsume(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mockConsume</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"receive msg: &#123;&#125;."</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用客户端发送消息"><a href="#使用客户端发送消息" class="headerlink" title="使用客户端发送消息"></a>使用客户端发送消息</h3><p>使用客户端发送消息的逻辑比较简单，就是拿到 DefaultMQProducer 对象，调用 send 方法，支持同步、异步、oneway 等多种调用方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(TestController.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String TOPIC = <span class="string">"DemoTopic"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String TAGS = <span class="string">"glmapperTags"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DefaultMQProducer defaultMQProducer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"send"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Message msg = <span class="keyword">new</span> Message(TOPIC, TAGS, (<span class="string">"Say Hello RocketMQ to Glmapper"</span>).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">        <span class="comment">// 调用客户端发送消息</span></span><br><span class="line">        SendResult sendResult = defaultMQProducer.send(msg);</span><br><span class="line">        LOGGER.info(<span class="string">"sendResult: &#123;&#125;."</span>,sendResult);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"SUCCESS"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>这里的测试应用是将生产端和消费端放在一起的，所以配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=test-rocket</span><br><span class="line">server.port=8008</span><br><span class="line">#producer</span><br><span class="line">rocketmq.producer.isOnOff=on #该应用是否启用生产者</span><br><span class="line">rocketmq.producer.groupName=$&#123;spring.application.name&#125;</span><br><span class="line">rocketmq.producer.namesrvAddr=sofa.cloud.alipay.net:9876</span><br><span class="line">rocketmq.producer.maxMessageSize=4096</span><br><span class="line">rocketmq.producer.sendMsgTimeout=3000</span><br><span class="line">rocketmq.producer.retryTimesWhenSendFailed=2</span><br><span class="line"></span><br><span class="line">#consumer</span><br><span class="line">rocketmq.consumer.isOnOff=on #该应用是否启用消费者</span><br><span class="line">rocketmq.consumer.groupName=$&#123;spring.application.name&#125;</span><br><span class="line">rocketmq.consumer.namesrvAddr=sofa.cloud.alipay.net:9876</span><br><span class="line">rocketmq.consumer.topics=DemoTopic</span><br><span class="line">rocketmq.consumer.consumeThreadMin=20</span><br><span class="line">rocketmq.consumer.consumeThreadMax=64</span><br><span class="line">rocketmq.consumer.consumeMessageBatchMaxSize=1</span><br></pre></td></tr></table></figure><p>启动程序，查看日志输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-04-05 22:53:15.141  INFO 46817 --- [           main] c.g.b.b.c.MQProducerConfiguration        : producer is started. groupName:test-rocket, namesrvAddr: sofa.cloud.alipay.net:9876</span><br><span class="line">2020-04-05 22:53:15.577  INFO 46817 --- [           main] c.g.b.b.c.MQConsumerConfiguration        : consumer is started. groupName:test-rocket, topics:DemoTopic, namesrvAddr:sofa.cloud.alipay.net:9876</span><br></pre></td></tr></table></figure><p>这里看到，生产者和消费者自动配置已经生效并启动完成。通过 curl localhost:8008/send 来触发消息发送:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-04-05 22:54:21.654  INFO 46817 --- [nio-8008-exec-1] c.g.b.boot.controller.TestController     : sendResult: SendResult [sendStatus=SEND_OK, msgId=1E0FC3A2B6E118B4AAC21983B3C50000, offsetMsgId=64583D7C00002A9F0000000000011788, messageQueue=MessageQueue [topic=DemoTopic, brokerName=sofa.cloud.alipay.net, queueId=6], queueOffset=50].</span><br><span class="line">2020-04-05 22:54:21.658  INFO 46817 --- [MessageThread_1] c.g.b.b.p.MessageListenerHandler         : receive msg: Say Hello RocketMQ to Glmapper.</span><br></pre></td></tr></table></figure><p>看到发送消息的日志和接受消息的日志。</p><h2 id="使用-hook-拦截消息"><a href="#使用-hook-拦截消息" class="headerlink" title="使用 hook 拦截消息"></a>使用 hook 拦截消息</h2><p>RocKetMQ 中提供了两个 hook 接口：SendMessageHook 和 ConsumeMessageHook 接口，可以用于在消息发送之前、之后，消息消费之前、之后对消息进行拦截，官方文档中并没有关于这部分的描述，那么这里我们就来看下如何使用这两个 hook 接口来搞点事情。</p><h3 id="SendMessageHook"><a href="#SendMessageHook" class="headerlink" title="SendMessageHook"></a>SendMessageHook</h3><p>自定义一个 ProducerTestHook ，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerTestHook</span> <span class="keyword">implements</span> <span class="title">SendMessageHook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ProducerTestHook.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hookName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ProducerTestHook.class.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessageBefore</span><span class="params">(SendMessageContext sendMessageContext)</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"execute sendMessageBefore. sendMessageContext:&#123;&#125;"</span>, sendMessageContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessageAfter</span><span class="params">(SendMessageContext sendMessageContext)</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"execute sendMessageAfter. sendMessageContext:&#123;&#125;"</span>, sendMessageContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面生产者的自动配置类中，将 ProducerTestHook 注册给 producer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册 SendMessageHook</span></span><br><span class="line">producer.getDefaultMQProducerImpl().registerSendMessageHook(<span class="keyword">new</span> ProducerTestHook());</span><br></pre></td></tr></table></figure><h3 id="ConsumeMessageHook"><a href="#ConsumeMessageHook" class="headerlink" title="ConsumeMessageHook"></a>ConsumeMessageHook</h3><p>自定义一个 ConsumerTestHook ，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTestHook</span> <span class="keyword">implements</span> <span class="title">ConsumeMessageHook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ConsumerTestHook.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hookName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ConsumerTestHook.class.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumeMessageBefore</span><span class="params">(ConsumeMessageContext consumeMessageContext)</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"execute consumeMessageBefore. consumeMessageContext: &#123;&#125;"</span>,consumeMessageContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumeMessageAfter</span><span class="params">(ConsumeMessageContext consumeMessageContext)</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"execute consumeMessageAfter. consumeMessageContext: &#123;&#125;"</span>,consumeMessageContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面消费者的自动配置类中，将 ConsumerTestHook 注册给 consumer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册 ConsumeMessageHook</span></span><br><span class="line">consumer.getDefaultMQPushConsumerImpl().registerConsumeMessageHook(<span class="keyword">new</span> ConsumerTestHook());</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">execute sendMessageBefore. sendMessageContext:org.apache.rocketmq.client.hook.SendMessageContext@a50ea34</span><br><span class="line">execute sendMessageAfter. sendMessageContext:org.apache.rocketmq.client.hook.SendMessageContext@a50ea34</span><br><span class="line">sendResult: SendResult [sendStatus=SEND_OK, msgId=0A0FE8F8C02F18B4AAC21C1275FB0000, offsetMsgId=64583D7C00002A9F0000000000011850, messageQueue=MessageQueue [topic=DemoTopic, brokerName=sofa.cloud.alipay.net, queueId=5], queueOffset=50].</span><br><span class="line">execute consumeMessageBefore. consumeMessageContext: org.apache.rocketmq.client.hook.ConsumeMessageContext@6482209a</span><br><span class="line">receive msg: Say Hello RocketMQ to Glmapper.</span><br><span class="line">execute consumeMessageAfter. consumeMessageContext: org.apache.rocketmq.client.hook.ConsumeMessageContext@6482209a</span><br></pre></td></tr></table></figure><h2 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h2><p>集成过程中遇到几个问题记录如下：</p><p><strong>1、Broker 启动失败。</strong></p><p>我在测试时遇到的情况是，在 Name Server 启动之后，再启动 Boker 时，ssh 连接会直接提示 connect conversation fail. 通过 <code>dmesg | egrep -i -B100 &#39;killed process&#39;</code> 查看进程被 kill 的记录，得到如下日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[2257026.030741] Memory cgroup out of memory: Kill process 110719 (systemd) score 0 or sacrifice child</span><br><span class="line">[2257026.031888] Killed process 100735 (sh) total-vm:15708kB, anon-rss:176kB, file-rss:1800kB, shmem-rss:0kB</span><br><span class="line">[2257026.133506] Memory cgroup out of memory: Kill process 110719 (systemd) score 0 or sacrifice child</span><br><span class="line">[2257026.133539] Killed process 100745 (vsar) total-vm:172560kB, anon-rss:22936kB, file-rss:1360kB, shmem-rss:0kB</span><br><span class="line">[2257026.206872] Memory cgroup out of memory: Kill process 104617 (java) score 3 or sacrifice child</span><br><span class="line">[2257026.207742] Killed process 104617 (java) total-vm:9092924kB, anon-rss:4188528kB, file-rss:496kB, shmem-rss:0kB</span><br></pre></td></tr></table></figure><p>那这里看到的结论是发生了 OOM，这里是启动时没哟分配到足够的空间导致的(默认配置文件初始内存设置的太大了)。解决办法是：进入到编译之后的 distribution/target/apache-rocketmq/bin 目录，找到 runbroker.sh 和 runserver.sh 两个脚本文件，这两个脚本理解启动时默认指定的参数是非常大的（4g/8g/2g），我线下测试机器总共才 1c2g，所以适当的调整了下参数:</p><ul><li>runserver.sh</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms128m -Xmx256m -Xmn256m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</span></span><br></pre></td></tr></table></figure><ul><li>runbroker.sh</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms256m -Xmx256m -Xmn128m"</span></span><br></pre></td></tr></table></figure><p>修改后重新启动 namesrv 和 broker ，正常了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jps</span><br><span class="line">98633 Jps</span><br><span class="line">55689 BrokerStartup</span><br><span class="line">54906 NamesrvStartup</span><br></pre></td></tr></table></figure><p><strong>2、No Topic Route Info，xxx</strong></p><p>这个在官方的 FAQ 里面有提到，说明遇到的频次一定是很高的。官方给出的方案可以详解<a href="http://rocketmq.apache.org/docs/faq/" target="_blank" rel="noopener">这里</a> <a href="http://rocketmq.apache.org/docs/faq/" target="_blank" rel="noopener">http://rocketmq.apache.org/docs/faq/</a> 第4条。我是通过 <strong>If you can’t find this topic, create it on a broker via admin tools command updateTopic or web console.</strong>  这个解决的:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sh mqadmin updateTopic -b localhost:10911 -n localhost:9876 -t DemoTopic <span class="comment"># 执行此指令，创建 DemoTopic</span></span><br><span class="line">RocketMQLog:WARN No appenders could be found <span class="keyword">for</span> logger (io.netty.util.internal.PlatformDependent0).</span><br><span class="line">RocketMQLog:WARN Please initialize the logger system properly.</span><br><span class="line">create topic to localhost:10911 success.</span><br><span class="line">TopicConfig [topicName=DemoTopic, readQueueNums=8, writeQueueNums=8, perm=RW-, topicFilterType=SINGLE_TAG, topicSysFlag=0, order=<span class="literal">false</span>]</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前在做 SOFATracer 集成消息组件时有看过 RocketMQ 的部分代码，但是在实际操作时还是饶了不少弯路。总体来看，SpringBoot 集成 RocketMQ 还是比较简单的，在此记录一下。如果文中有描述有误的地方，还请各位大佬留言指正。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="http://rocketmq.apache.org/docs/quick-start/" target="_blank" rel="noopener">http://rocketmq.apache.org/docs/quick-start/</a></li><li><a href="https://blog.csdn.net/ph3636/article/details/79528638" target="_blank" rel="noopener">https://blog.csdn.net/ph3636/article/details/79528638</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RocketMQ 简介：Apache RocketMQ是一个分布式消息传递和流媒体平台，具有低延迟、高性能和可靠性、万亿级容量和灵活的可伸缩性。它提供了多种功能，具体参考: &lt;a href=&quot;https://github.com/apache/rocketmq&quot; targe
      
    
    </summary>
    
      <category term="springboot" scheme="http://www.glmapper.com/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://www.glmapper.com/tags/springboot/"/>
    
      <category term="rocketmq" scheme="http://www.glmapper.com/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>解决方案系列-基于 SOFAArk 实现应用的动态装载和卸载</title>
    <link href="http://www.glmapper.com/2020/04/03/solution-series-dynamic-module/"/>
    <id>http://www.glmapper.com/2020/04/03/solution-series-dynamic-module/</id>
    <published>2020-04-02T16:03:05.000Z</published>
    <updated>2020-04-03T02:23:22.998Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要来看下蚂蚁金服开源的 <a href="https://www.sofastack.tech/projects/sofa-boot/sofa-ark-readme/" target="_blank" rel="noopener">SOFAArk</a> 这个产品。SOFAArk 是一款基于 Java 实现的轻量级类隔离容器，主要提供类隔离和应用(模块)合并部署能力；本文主要基于 telnet 指令的方式进行应用 Biz 的装载和卸载操作。去年在上海 KubeCon 大会上有分享过 《SOFABoot 动态模块实践》，主要是通过 SOFADashboard 来下发指令的，基于 SOFABoot 3.1.4 和 SOFAArk 0.6.0 版本；目前 SOFABoot 已经发布到 3.3.x+ ，SOFAARK 1.1.1 版本，其中 ，SOFAARK 提供了很多新的特性，包括全生命周期的事件机制、卸载优化等。</p><p>由于 SOFABoot 3.3.0 版本中部分代码的重构，导致无法兼容 runtime plugin，所以本文是基于修复版的 <a href="https://github.com/glmapper/sofa-boot.git" target="_blank" rel="noopener">SOFABoot 3.3.0-poc-ark-SNAPSHOT</a> 来完成，案例工程<a href="https://github.com/sofastack-guides/kc-sofastack-dynamic-demo.git" target="_blank" rel="noopener">kc-sofastack-dynamic-demo 分支 support-3.3.0</a> 。</p><h2 id="案例描述"><a href="#案例描述" class="headerlink" title="案例描述"></a>案例描述</h2><p>先看下官方文档里面对于动态部署的描述，是通过变更/监听 zk 节点数据来实现运维命令的下发和接收：</p><p><img src="https://www.sofastack.tech/projects/sofa-boot/sofa-ark-readme/architecture.png" alt=""></p><p>本篇精简一下，使用 telnet 指令直接进行运维操作；案例描述如下：对于一个运行期的一个应用 A，将另外一个应用 B 动态的装载到 A 上（实际是 A 所在的 Ark 容器上），大体描述如下图所示：</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/dynamic/dynamic-processor.jpg" alt=""></p><p>下面两张图是具体的运行结果图：</p><ul><li><p>默认 master 运行、无动态 biz 运行时的运行结果<br><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/dynamic/dynamic-default.jpg" alt=""></p></li><li><p>动态安装 biz 之后运行结果<br><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/dynamic/dynamic-biz.jpg" alt=""></p></li></ul><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>1、构建 SOFABoot 3.3.0-poc-ark-SNAPSHOT 版本，安装到本地仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/glmapper/sofa-boot.git</span><br><span class="line">git checkout 3.3.0-poc-ark-SNAPSHOT</span><br><span class="line">mvn clean install -DskipTest</span><br></pre></td></tr></table></figure><p>2、下载 kc-sofastack-dynamic-demo 案例工程，打包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/sofastack-guides/kc-sofastack-dynamic-demo.git</span><br><span class="line">git checkout support-3.3.0</span><br><span class="line">mvn clean package -DskipTest</span><br></pre></td></tr></table></figure><p>3、完成打包之后，案例工程根目录 target 目录下有两个包，<code>dynamic-stock-mng-1.0.0-ark-biz.jar</code> 和 <code>dynamic-provider-1.0.0-ark-biz.jar</code>。<code>dynamic-stock-mng-1.0.0-ark-biz.jar</code> 是 master biz + ark 容器，<code>dynamic-provider-1.0.0-ark-biz.jar</code> 是动态 biz</p><p>4、执行 <code>java -jar dynamic-stock-mng-1.0.0-ark-biz.jar</code>，浏览器输入 <a href="http://localhost:8080/，运行结果" target="_blank" rel="noopener">http://localhost:8080/，运行结果</a></p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/dynamic/dynamic-default.jpg" alt=""><br>这里看到的 <code>SUPPORT BY: DEFAULT BIZ</code> 是默认的 BIZ ，也就是 master BIZ</p><p>5、通过 telnet 指令安装 动态 biz</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">telnet localhost 1234</span><br><span class="line">sofa-ark&gt; biz -i file://xxxxx/dynamic-provider-1.0.0-ark-biz.jar <span class="comment">#这里的文件路径根据你自己本地实际的包路径修改</span></span><br></pre></td></tr></table></figure><p>通过 biz -a 查看安装结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sofa-ark&gt;biz -a</span><br><span class="line">provide:1.0.0:activated</span><br><span class="line">stock-mng:1.0.0:activated</span><br><span class="line">biz count = 2</span><br></pre></td></tr></table></figure><p>在次通过浏览器输入 <a href="http://localhost:8080/，运行结果" target="_blank" rel="noopener">http://localhost:8080/，运行结果</a></p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/dynamic/dynamic-biz.jpg" alt=""></p><p>这里 SUPPORT BY 是刚刚安装的 动态 BIZ 所提供的。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote><p>来自官网</p></blockquote><p>SOFAArk 包含三个概念，Ark Container, Ark Plugin 和 Ark Biz; 运行时逻辑结构图如下:</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/dynamic/dynamic-yuanli.png" alt=""></p><p>概念解释： </p><ul><li><p>Ark Container: SOFAArk 容器，负责 Ark 包启动运行时的管理；Ark Plugin 和 Ark Biz 运行在 SOFAArk 容器之上；容器具备管理插件和应用的功能；容器启动成功后，会自动解析 classpath 包含的 Ark Plugin 和 Ark Biz 依赖，完成隔离加载并按优先级依次启动之；</p></li><li><p>Ark Plugin: Ark 插件，满足特定目录格式要求的 Fat Jar，使用官方提供的 Maven 插件 sofa-ark-plugin-maven-plugin 可以将一个或多个普通的 Java jar 打包成一个标准格式的 Ark Plugin；Ark Plugin 会包含一份配置文件，通常包括插件类导入导出配置、资源导入导出配置、插件启动优先级等；运行时，SOFAArk 容器会使用独立的 PluginClassLoader加载插件，并根据插件配置构建类加载索引表、资源加载索引表，使插件和插件之间、插件和应用之间相互隔离；</p></li><li><p>Ark Biz: Ark 应用模块，满足特定目录格式要求的 Fat Jar，使用官方提供的 Maven 插件 sofa-ark-maven-plugin 可以将工程应用打包成一个标准格式的 Ark Biz；Ark Biz 是工程应用以及其依赖包的组织单元，包含应用启动所需的所有依赖和配置；一个 Ark 包中可以包含多个 Ark Biz 包，按优先级依次启动，Biz 之间通过 JVM 服务交互；</p></li></ul><p>运行 Ark 包，Ark Container 优先启动，容器自动解析 Ark 包中含有的 Ark Plugin 和 Ark Biz，并读取他们的配置信息，构建类和资源的加载索引表；然后使用独立的 ClassLoader 加载并按优先级配置依次启动。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇主要来看下蚂蚁金服开源的 &lt;a href=&quot;https://www.sofastack.tech/projects/sofa-boot/sofa-ark-readme/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SOFAArk&lt;/a&gt; 这个产品。S
      
    
    </summary>
    
      <category term="解决方案" scheme="http://www.glmapper.com/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="解决方案" scheme="http://www.glmapper.com/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
      <category term="SOFA" scheme="http://www.glmapper.com/tags/SOFA/"/>
    
      <category term="SOFAArk" scheme="http://www.glmapper.com/tags/SOFAArk/"/>
    
  </entry>
  
  <entry>
    <title>解决方案系列-集群选主(基于DB)</title>
    <link href="http://www.glmapper.com/2020/03/29/solution-series-cluster-selector/"/>
    <id>http://www.glmapper.com/2020/03/29/solution-series-cluster-selector/</id>
    <published>2020-03-29T10:12:42.000Z</published>
    <updated>2020-04-04T15:23:17.957Z</updated>
    
    <content type="html"><![CDATA[<p>一个业务量很小的系统，所有的代码都放在一个项目中，部署在一台服务器上。所有的服务都由这台服务器提供，这就是常说的单机模式；我们知道单机模式的缺点是：1、处理能力有限，2、存在单点问题。单机模式大致如下图所示：</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/clusters/cluster-single.jpg" alt=""></p><p>为了解决这些问题，出现了集群模式。</p><h2 id="常见的集群模式方案"><a href="#常见的集群模式方案" class="headerlink" title="常见的集群模式方案"></a>常见的集群模式方案</h2><p>集群主要的使用场景就是为了分担请求的压力，也就是在几个服务器上部署相同的应用程序，来分担客户端请求。集群主要是通过加机器来解决问题，对于问题本身是不会做任何分解的。（PS：分解了就是分布式）。那么常见的集群模式有哪几种呢？</p><h3 id="主备，冷备模式，主写主读"><a href="#主备，冷备模式，主写主读" class="headerlink" title="主备，冷备模式，主写主读"></a>主备，冷备模式，主写主读</h3><p>所有的写请求都由 master 负责处理，如果请求打在 slave 上，则 slave 会将请求转发给 master 处理，架构图如下图所示：</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/clusters/cluster-m-s-cold.jpg" alt=""></p><p>冷备模式主要是在请求量不大，且对于数据状态有要求的情况（比如所有的数据其实都是 master 内存存储），提供一个从机用于备用，在 master 出现问题的时候能够及时顶上去。</p><h3 id="主备，主写从读"><a href="#主备，主写从读" class="headerlink" title="主备，主写从读"></a>主备，主写从读</h3><p>基于冷备模式，衍生出主写从读，也就是 master 会将数据同步给各个 slave，然后就可以分担掉读请求的处理压力，架构图如下图所示：</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/clusters/cluster-mw-sr.jpg" alt=""></p><p>这种模式算是比较常见的，像数据库的主从模式。</p><h3 id="对等，广播"><a href="#对等，广播" class="headerlink" title="对等，广播"></a>对等，广播</h3><p>这种场景是客户端的请求可能需要指定的集群中的某个 server 来处理，常见的比如配置中心，配置中心客户端会选择与集群中的某个 server 建立连接，当通过管控端推送配置指令下来时，因为没法指定到具体的 server 去推送，所以当请求推到集群的某台机器时，该机器会向集群中的其他机器广播此次请求，谁持有这个客户端的连接，谁去处理。架构图如下图所示：</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/clusters/cluster-m-s-broadcast.jpg" alt=""></p><h3 id="纯对等（无状态）"><a href="#纯对等（无状态）" class="headerlink" title="纯对等（无状态）"></a>纯对等（无状态）</h3><p>最后一种就是纯对等的，集群中的机器谁处理都行；这种就是广义说的集群模式，通过扩机器解决高并发。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/clusters/cluster-equality.jpg" alt=""></p><h2 id="集群选主"><a href="#集群选主" class="headerlink" title="集群选主"></a>集群选主</h2><p>集群选主指是上述提到的主备模式下进行的，也就是有状态的情况，无状态场景不需要进行选主操作。集群选主很容易，困难的是选主之后的操作（比如如何协调和感知集群中的机器状态），还有集群内机器发生变更之后的操作（如如何分配客户端连接，这里就会涉及到一个非常常见的问题：一致性 hash）。本篇主要介绍集群选主，所以对于这两个问题不做过多的探讨。</p><p>集群选主的方式有很多种，本篇只介绍通过 ”争抢锁“ 的选主方式，即在集群中机器启动时会通过争抢某个”非共享“资源，谁抢到谁来当 master。那么基于此，我们可以罗列以下几种常见的”非共享“资源：</p><ul><li>DB 的唯一键插入</li><li>zk 的节点创建</li><li>redis 的原子写</li><li>…</li></ul><h2 id="基于-DB-的唯一键插入实现选主"><a href="#基于-DB-的唯一键插入实现选主" class="headerlink" title="基于 DB 的唯一键插入实现选主"></a>基于 DB 的唯一键插入实现选主</h2><p>下面以 DB 的唯一键插入 为例来简单介绍下选主的逻辑。</p><blockquote><p>数据库唯一键：unique key，用来保证对应的字段中的数据唯一。</p></blockquote><h3 id="机器表设计-amp-唯一键设置"><a href="#机器表设计-amp-唯一键设置" class="headerlink" title="机器表设计&amp;唯一键设置"></a>机器表设计&amp;唯一键设置</h3><p>所有集群中的机器启动时都需要将自己的机器信息写到 DB 中。这里创建一个唯一键：<code>uk_master</code>，包括两个字段，分别是 机器状态和一个 master_lock（master 锁）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for cluster_servers</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`cluster_servers`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`cluster_servers`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`host_name`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'主机名'</span>,</span><br><span class="line">  <span class="string">`ip`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'ip 地址'</span>,</span><br><span class="line">  <span class="string">`is_master`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'是否是 master'</span>,</span><br><span class="line">  <span class="string">`status`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'机器状态'</span>,</span><br><span class="line">  <span class="string">`master_lock`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'master 锁'</span>,</span><br><span class="line">  <span class="string">`heartbeat`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'心跳时间'</span>,</span><br><span class="line">  <span class="string">`gmt_sql_server_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'sql 执行时间'</span>,</span><br><span class="line">  <span class="string">`gmt_modify`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'修改时间'</span>,</span><br><span class="line">  <span class="string">`gmt_create`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uk_master`</span> (<span class="string">`status`</span>,<span class="string">`master_lock`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><h3 id="争抢唯一键"><a href="#争抢唯一键" class="headerlink" title="争抢唯一键"></a>争抢唯一键</h3><p>这里就是谁更新数据状态成功，谁就是 master，没有争抢成功则是 slave。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"setMaster"</span> &gt;</span></span><br><span class="line">    update cluster_servers set is_master = #&#123;isMaster&#125;, master_lock = #&#123;masterLock&#125;, status = #&#123;status&#125;, heartbeat = CURRENT_TIMESTAMP, gmt_modify = CURRENT_TIMESTAMP where host_name = #&#123;hostName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="集群选主的过程"><a href="#集群选主的过程" class="headerlink" title="集群选主的过程"></a>集群选主的过程</h3><p>基于此，集群选主的大致过程可以通过下图描述：</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/clusters/cluster-select.jpg" alt=""></p><p>这里的像 slave 的后置任务，比如开启监听 master 状态，这样在 master 出现问题时就会触发新的选举。master 的后置任务一个是开始监听各个 slave 的状态，如果 slave 出现问题，则可以及时的将此 slave 踢出集群，其他则需要根据具体的业务情况来看。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇主要介绍了集群的几种基本形态，然后基于需要选主的场景进行了简单分析；最后提供了基于 DB 进行集群选主的一种可行性方案，并介绍了大体的选主流程。需要补充一点，基于 DB 选主和维持心跳本身是比较重的，强依赖 DB 的状态，如果 DB 有问题则集群状态可能会出现一些非预期的情况或者导致集群直接不可用，所以大家在选择具体的方式时，还是要结合业务的具体场景来选择。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个业务量很小的系统，所有的代码都放在一个项目中，部署在一台服务器上。所有的服务都由这台服务器提供，这就是常说的单机模式；我们知道单机模式的缺点是：1、处理能力有限，2、存在单点问题。单机模式大致如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://glmappe
      
    
    </summary>
    
      <category term="解决方案" scheme="http://www.glmapper.com/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="解决方案" scheme="http://www.glmapper.com/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
      <category term="集群选主" scheme="http://www.glmapper.com/tags/%E9%9B%86%E7%BE%A4%E9%80%89%E4%B8%BB/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊 CopyOnWriteArraySet 的迭代删除</title>
    <link href="http://www.glmapper.com/2020/03/16/java-base-iterator-of-set/"/>
    <id>http://www.glmapper.com/2020/03/16/java-base-iterator-of-set/</id>
    <published>2020-03-16T01:26:12.000Z</published>
    <updated>2020-03-16T02:06:42.986Z</updated>
    
    <content type="html"><![CDATA[<p>上周在工程中涉及到一个清理 Set 集合的操作，将满足设定条件的项从 Set 中删除掉。简化版本代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; sets = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">    sets.add(<span class="string">"1"</span>);</span><br><span class="line">    sets.add(<span class="string">"3"</span>);</span><br><span class="line">    sets.add(<span class="string">"3"</span>);</span><br><span class="line">    sets.add(<span class="string">"4"</span>);</span><br><span class="line">    Iterator&lt;String&gt; iterator = sets.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sets);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个看起来是个很常规的问题，没有验证就直接发了线下环境，然后就收到了业务方反馈的服务无法正常使用的问题了。</p><h3 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h3><p>先来看下上述代码所抛出的异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.UnsupportedOperationException</span><br><span class="line">at java.util.concurrent.CopyOnWriteArrayList$COWIterator.remove(CopyOnWriteArrayList.java:<span class="number">1178</span>)</span><br><span class="line">at com.glmapper.bridge.boot.TestMain.main(TestMain.java:<span class="number">21</span>)</span><br></pre></td></tr></table></figure><p>关于 UnsupportedOperationException 这个异常没有什么好说的，在集合操作中经常出现，网上也有很多关于这个异常的说明，这里不再赘述。这里我比较关注的是，我使用的是 CopyOnWriteArraySet，迭代器也是 sets 的，但是异常中居然出现了 CopyOnWriteArrayList，查看了 CopyOnWriteArraySet 的类继承关系，和 CopyOnWriteArrayList 也没啥关系。</p><h3 id="排查-amp-结果"><a href="#排查-amp-结果" class="headerlink" title="排查&amp;结果"></a>排查&amp;结果</h3><p>通过查看了 CopyOnWriteArraySet 的代码，发现 CopyOnWriteArraySet 内部其实是持有了一个 CopyOnWriteArrayList 的对象实例，其内部的所有操作都是基于 CopyOnWriteArrayList 这个对象来进行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArraySet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Creates an empty set.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于-CopyOnWriteArrayList-的操作"><a href="#关于-CopyOnWriteArrayList-的操作" class="headerlink" title="关于 CopyOnWriteArrayList 的操作"></a>关于 CopyOnWriteArrayList 的操作</h3><p><strong>写操作</strong></p><p>在 CopyOnWriteArrayList 里处理写操作（包括 add、remove、set 等）是先将原始的数据通过 JDK1.6 的 Arrays.copyof() 来生成一份新的数组。add 的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 这里是生产新的数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续的操作都是在新的数据对象上进行写，写完后再将原来的引用指向到当前这个数据对象，这样保证了每次写都是在新的对象上（因为要保证写的一致性，这里要对各种写操作要加一把锁，JDK1.6 在这里用了重入锁），</p><p><strong>读操作</strong></p><p>读的时候就是在引用的当前对象上进行读（包括 get，iterator 等），不存在加锁和阻塞，针对 iterator 使用了一个叫 COWIterator 的简化版迭代器，因为不支持写操作，当获取 CopyOnWriteArrayList 的迭代器时，是将迭代器里的数据引用指向当前引用指向的数据对象，无论未来发生什么写操作，都不会再更改迭代器里的数据对象引用，所以迭代器也很安全。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>因为 CopyOnWriteArraySet 的内部操作都是基于 CopyOnWriteArrayList 的，从异常来看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.CopyOnWriteArrayList$COWIterator.remove(CopyOnWriteArrayList.java:1178)</span><br></pre></td></tr></table></figure></p><p>COWIterator 是 CopyOnWriteArrayList 内部提供的一个简化版的迭代器。所以异常里面出现这个就理所应当了。在来看下 COWIterator 这里简化版的迭代器的 remove 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Not supported. Always throws UnsupportedOperationException.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> UnsupportedOperationException always; &#123;<span class="doctag">@code</span> remove&#125;</span></span><br><span class="line"><span class="comment">*         is not supported by this iterator.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里实际上是直接就会抛出异常的，另外这里在多补充一个关于 HashSet 的迭代器移除，HashSet 其实内部是持有的 HashMap 实例，因此它的迭代器是 HashMap 内部提供的 HashIterator：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; p = current;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    current = <span class="keyword">null</span>;</span><br><span class="line">    K key = p.key;</span><br><span class="line">    removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里其实也可以看到，在对非安全的集合做 remove 操作时会经常遇到的 ConcurrentModificationException 这个异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上周在工程中涉及到一个清理 Set 集合的操作，将满足设定条件的项从 Set 中删除掉。简化版本代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="java 基础" scheme="http://www.glmapper.com/categories/java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://www.glmapper.com/tags/java/"/>
    
      <category term="set" scheme="http://www.glmapper.com/tags/set/"/>
    
      <category term="CopyOnWriteArraySet" scheme="http://www.glmapper.com/tags/CopyOnWriteArraySet/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实践系列-Filter 中的异常处理和 Controller 中的异常处理</title>
    <link href="http://www.glmapper.com/2020/02/12/springboot-series-filter-exception/"/>
    <id>http://www.glmapper.com/2020/02/12/springboot-series-filter-exception/</id>
    <published>2020-02-12T06:28:44.000Z</published>
    <updated>2020-04-05T11:43:36.444Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要是记录如何使用 SpringBoot 所提供的 ErrorController 这个接口能力；其内置了一个 BasicErrorController 对异常进行统一的处理，当在 Controller 发生异常的时候会自动把请求 forward 到 /error 这个请求 path 下(/error 是 SpringBoot 提供的一个默认的mapping)。BasicErrorController 提供两种返回错误：1、页面返回；2、json 返回。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>开发中遇到的一个问题：项目中所有的 rest 请求均是通过 json 形式返回，且自定义了一个统一的数据结构对象，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 数据</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="comment">// success 标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> success;</span><br><span class="line">    <span class="comment">// 异常信息</span></span><br><span class="line">    <span class="keyword">private</span> String error;</span><br><span class="line">    <span class="comment">// 省略 get set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个结构非常常见，相信很多开发者都这么玩过。项目中 rest 请求返回的所有结果都是以 Response 对象形式返回，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"test"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Response&lt;String&gt; <span class="title">testApi</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Response&lt;String&gt; result = <span class="keyword">new</span> Response&lt;&gt;();</span><br><span class="line">    result.setData(<span class="string">"this is glmapper blog"</span>);</span><br><span class="line">    result.setSuccess(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这基本是最简化版的一个模型；出于安全考虑，现在有个需求是需要对每个请求做校验，比如校验请求中是否携带 token 这种。思路很简单就是通过拦截器或者过滤器的方式来对请求做拦截检验。</p><p>其实不管是拦截器还是过滤器，需要考虑的一个问题是，在校验不通过或者校验时产生异常的情况下，怎么把异常信息以项目中规定的统一数据格式返回，即返回 Response。</p><h2 id="直接将-Response-写回去"><a href="#直接将-Response-写回去" class="headerlink" title="直接将 Response 写回去"></a>直接将 Response 写回去</h2><p>利用 ServletResponse 中提供的 PrintWriter，将 Response 以 json 格式直接 print 回去。大概代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">                        FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">    String requestURI = request.getRequestURI();</span><br><span class="line">    <span class="comment">// mock 测试异常请求</span></span><br><span class="line">    <span class="keyword">if</span> (requestURI.contains(<span class="string">"testTokenError"</span>)) &#123;</span><br><span class="line">        Response&lt;String&gt; response = <span class="keyword">new</span> Response&lt;&gt;();</span><br><span class="line">        response.setError(<span class="string">"token validation fails"</span>);</span><br><span class="line">        <span class="comment">// 回写异常信息</span></span><br><span class="line">        returnResponse((HttpServletResponse)servletResponse,JSONObject.toJSONString(response));</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    chain.doFilter(servletRequest, servletResponse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">returnResponse</span><span class="params">(HttpServletResponse response, String data)</span> </span>&#123;</span><br><span class="line">    PrintWriter writer = <span class="keyword">null</span>;</span><br><span class="line">    response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">    response.setContentType(<span class="string">"text/html; charset=utf-8"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        writer = response.getWriter();</span><br><span class="line">        <span class="comment">// 通过 PrintWriter 将 data 数据直接 print 回去</span></span><br><span class="line">        writer.print(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (writer != <span class="keyword">null</span>)</span><br><span class="line">            writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式比较简单和直接，print 异常数据之后直接 return，不在继续过滤器链。</p><h2 id="抛出异常，通过-BasicErrorController-方式处理"><a href="#抛出异常，通过-BasicErrorController-方式处理" class="headerlink" title="抛出异常，通过 BasicErrorController 方式处理"></a>抛出异常，通过 BasicErrorController 方式处理</h2><p>这种方式是利用了 SpringBoot 本身提供的能力，可以更优雅的处理错误信息。代码大致如下：</p><p><strong>1、是在 Filter 中就直接抛出一个异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">                        FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">    String requestURI = request.getRequestURI();</span><br><span class="line">    <span class="comment">// mock 测试异常请求</span></span><br><span class="line">    <span class="keyword">if</span> (requestURI.contains(<span class="string">"testTokenError"</span>)) &#123;</span><br><span class="line">        <span class="comment">// 直接返回一个自定义的异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ValidationException(<span class="string">"token validation fails"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    chain.doFilter(servletRequest, servletResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、定义一个异常处理的 Controller</strong></p><p>这里定义一个 TokenErrorController ，继承自 SpringBoot 提供的 BasicErrorController 这个类，然后重写 error 这个方法（如果是页面的话，重写 errorHtml 这个方法），用于返回自定义的 Response 数据。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenErrorController</span> <span class="keyword">extends</span> <span class="title">BasicErrorController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重写 error 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(produces = &#123; MediaType.APPLICATION_JSON_VALUE &#125;)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; body = getErrorAttributes(request,</span><br><span class="line">            isIncludeStackTrace(request, MediaType.ALL));</span><br><span class="line">        HttpStatus status = getStatus(request);</span><br><span class="line">        <span class="comment">// 拿到 body 中的异常 message </span></span><br><span class="line">        String message = body.get(<span class="string">"message"</span>).toString();</span><br><span class="line">        <span class="comment">// 构建 Response 对象</span></span><br><span class="line">        Response response = <span class="keyword">new</span> Response();</span><br><span class="line">        <span class="comment">// 将 message 的 设置到 response </span></span><br><span class="line">        response.setError(message);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity(response, status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以实现在不改动之前工程任何代码的情况下只处理额外 Filter 中抛出的异常了。需要注意的是，上述是通过 BasicErrorController 来接受了 Filter 抛出的异常信息，然后再通过 BasicErrorController 将异常信息进行包装并且返回。为什么要提一下这个呢？主要是为了和 SpringBoot 中基于 REST 请求层所提供的两个用于处理全局异常的注解区分，这两个注解分别是 @ControllerAdvice 和 @RestControllerAdvice，通过注解的名字其实就能看出，SpringBoot 中，可以通过这两个注解来实现对 @Controller 和  @RestController 标注的类进行全局拦截，因为是 Controller 层面的 AOP 拦截，所以对于 Filter 中抛出的异常，通过 @ControllerAdvice 和 @RestControllerAdvice 两个注解定义的全局异常处理器是没法处理的。</p><p>下面就简单介绍下 @ControllerAdvice 和 @RestControllerAdvice 这两个注解的使用。</p><h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><p>自定义一个 OtherExcepetion ，然后再使用基于 @RestControllerAdvice 注解编写一个全局异常处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里只处理 OtherException 异常类型</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = OtherException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response&lt;String&gt; <span class="title">otherExceptionHandler</span><span class="params">(HttpServletRequest req, OtherException e)</span></span>&#123;</span><br><span class="line">        Response response = <span class="keyword">new</span> Response();</span><br><span class="line">        response.setError(e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当然你也可以定义处理其他异常的 @ExceptionHandler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式是没法处理 Filter 中异常的，只能处理 Controller 里面抛出的异常。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇主要记录了在 SpringBoot 中如何保证 Filter 中抛出的异常能和业务一样以指定类型的对象返回，并对 SpringBoot 中提供的基于 Controller 层异常捕获处理进行简单介绍。两者处理异常的思路是不同的：</p><ul><li>BasicErrorController：接受来自 /error 的异常请求处理，Filter 中抛出的异常先 forward 到 /error，然后处理。</li><li>@RestControllerAdvice：通过对于所有 @Controller 注解所标注的类进行 AOP 拦截，能够根据异常类型匹配具体的 ExceptionHandler 进行处理。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇主要是记录如何使用 SpringBoot 所提供的 ErrorController 这个接口能力；其内置了一个 BasicErrorController 对异常进行统一的处理，当在 Controller 发生异常的时候会自动把请求 forward 到 /error 这个
      
    
    </summary>
    
      <category term="springboot" scheme="http://www.glmapper.com/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://www.glmapper.com/tags/springboot/"/>
    
      <category term="springmvc" scheme="http://www.glmapper.com/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>菜鸟成长系列-适配器模式</title>
    <link href="http://www.glmapper.com/2020/01/28/java-design-model-adapter/"/>
    <id>http://www.glmapper.com/2020/01/28/java-design-model-adapter/</id>
    <published>2020-01-28T07:32:14.000Z</published>
    <updated>2020-01-28T09:13:18.963Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为阅读 《JAVA与模式》的个人笔记，文中相关概念及背景描述参考书本。如有不当，请联系指正。</p></blockquote><p><strong>定义：适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配为无法在一起工作的两个类能够在一起工作 -《JAVA与模式》</strong></p><p>适配、包装、转换几个字眼从汉字的字面意思来说是不同的，不同在于这几个词所对应的行为不同；但是他们所期望的目的是差不多一致的，就是将不可用变成可用。所以常说的适配器模式、转换器模式以及包装模式指的都是一个模式。</p><h2 id="适配器模式的两种形式"><a href="#适配器模式的两种形式" class="headerlink" title="适配器模式的两种形式"></a>适配器模式的两种形式</h2><p>在 java 语言体系中，根据适配类型的不同。适配器模式可以分为：<strong>类的适配器模式</strong>和<strong>对象的适配器模式</strong>。</p><h3 id="类的适配器模式"><a href="#类的适配器模式" class="headerlink" title="类的适配器模式"></a>类的适配器模式</h3><p>顾名思义，类的适配器模式是把被适配的类的 API 转换成为目标类的 API。</p><p>这里涉及到三个角色：</p><ul><li>目标角色：客户端期待的接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 源类没有的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sampleOperation1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 源类没有的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sampleOperation2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>源角色：现有需要被适配的接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sampleOperation1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// todo your biz</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>适配器角色：把源接口转换成目标接口的适配器类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// todo your biz</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于源类没有 sampleOperation2 方法，因此适配器类中补充上这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// todo your biz</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Target 接口申明了两个方法：sampleOperation1 和 sampleOperation2 ，而源角色 Adaptee 是一个具体的类，它只有一个 sampleOperation1 方法，但是没有 sampleOperation2 这个方法。适配器角色 Adapter 扩展了 Adaptee ，同时又实现了目标接口，由于 Adaptee 没有 sampleOperation2 方法，而目标接口又要求这个方法，因此适配器角色 Adapter 实现了这个方法。</p><p>适配器模式所达到的效果是：<strong>使用一个具体类把源（Adaptee）适配到目标（Target）中，这样一来，如果源以及源的子类都使用此类适配，就行不通了。由于适配器类是源的子类，因此可以在适配器类中置换掉源的一些方法；另外，由于只引进了一个适配器类，因此只有一个路线达到目标类，使问题得到简化。</strong></p><h3 id="对象的适配器模式"><a href="#对象的适配器模式" class="headerlink" title="对象的适配器模式"></a>对象的适配器模式</h3><p>与类的适配器模式一样，对象的适配器模式把被适配的类的 API 转换成为目标类的 API ，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到 Adaptee 类，而是使用委派关系连接到 Adaptee 类。这里我们只需要对前面的 Adapter 做简单的修改即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjAdapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjAdapter</span><span class="params">(Adaptee adaptee)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.sampleOperation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// todo your biz</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实际上这里所说的委派就是组合。</p></blockquote><p>适配器模式的用意在于将接口不同而功能相同或者相近的两个接口加以转换，这里面包括适配器角色补充了一个源角色没有的方法。需要注意的是，不要误以为适配器模式就是为了补充源角色没有的方法而准备的。</p><h2 id="在什么情况下需要使用适配器模式"><a href="#在什么情况下需要使用适配器模式" class="headerlink" title="在什么情况下需要使用适配器模式"></a>在什么情况下需要使用适配器模式</h2><p>书中提到的有三种场景，但是在实际的工程中，场景要远远多于书中所说的。</p><ul><li>1、系统需要使用现有的类，而此类的接口不符合系统的需要</li><li>2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有很复杂的接口</li><li>3、在设计里，需要改变多个已有的子类的接口，如果使用类的适配器模式，就需要针对每一个子类做一个适配器，而这不太实际。</li></ul><h2 id="与一些模式的区别"><a href="#与一些模式的区别" class="headerlink" title="与一些模式的区别"></a>与一些模式的区别</h2><h3 id="与桥接器模式的区别"><a href="#与桥接器模式的区别" class="headerlink" title="与桥接器模式的区别"></a>与桥接器模式的区别</h3><p>桥接器模式的用意是要把实现和它的接口分开，以便于它们可以独立的变化。桥接器模式并不是用来把一个已有的对象接到不匹配的接口上的，当一个客户端只知道一个特定的接口，但是又必须与具有不同接口的类打交道时，就应当使用适配器模式。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/designmodel/bridge.jpg" alt=""></p><h3 id="与装饰模式的区别"><a href="#与装饰模式的区别" class="headerlink" title="与装饰模式的区别"></a>与装饰模式的区别</h3><p>一个装饰类也是位于客户端和另一个 Component 对象之间的，在它接到客户端的调用后把调用传给一个或者几个 Component 对象。一个纯粹的装饰类必须与 Component 对象在接口上的完全相同，并增强后者的功能。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/designmodel/decrator.jpg" alt=""><br>与适配器类不同的是，装饰类不能改变它所装饰的 Component 对象的接口。</p><blockquote><p>装饰模式可以这样理解，《开局一把枪，装备全靠打：皮肤、装备加持就是角色的装饰》</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇是在阅读 《JAVA与模式》一书所做的笔记记录，以备后续方便查阅。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为阅读 《JAVA与模式》的个人笔记，文中相关概念及背景描述参考书本。如有不当，请联系指正。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;定义：适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配为无法在
      
    
    </summary>
    
      <category term="架构之路" scheme="http://www.glmapper.com/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="设计模式" scheme="http://www.glmapper.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="读书笔记" scheme="http://www.glmapper.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>一文详解蚂蚁金服分布式链路组件 SOFATracer 的埋点机制</title>
    <link href="http://www.glmapper.com/2020/01/20/sofa-tracer-integration-analysis/"/>
    <id>http://www.glmapper.com/2020/01/20/sofa-tracer-integration-analysis/</id>
    <published>2020-01-20T03:43:56.000Z</published>
    <updated>2020-02-02T06:56:42.868Z</updated>
    
    <content type="html"><![CDATA[<p>SOFATracer 是一个用于分布式系统调用跟踪的组件，通过统一的 TraceId 将调用链路中的各种网络调用情况以日志的方式记录下来，以达到透视化网络调用的目的，这些链路数据可用于故障的快速发现，服务治理等。</p><blockquote><p>GITHUB 地址：<a href="https://github.com/sofastack/sofa-tracer/pulls" target="_blank" rel="noopener">https://github.com/sofastack/sofa-tracer/pulls</a> （欢迎 star）<br>官方文件地址：<a href="https://www.sofastack.tech/projects/sofa-tracer/overview/" target="_blank" rel="noopener">https://www.sofastack.tech/projects/sofa-tracer/overview/</a></p></blockquote><p>2018 年末时至 2019 年初，SOFA 团队发起过 <a href="https://www.sofastack.tech/tags/%E5%89%96%E6%9E%90-sofatracer-%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">剖析-sofatracer-框架</a> 的源码解析系列文章。这个系列中，基本对 SOFATracer 所提供的能力及实现原理都做了比较全面的分析，有兴趣的同学可以看下。</p><p>从官方文档及 PR 来看，目前 SOFATracer 已经支持了对以下开源组件的埋点支持：</p><ul><li>Spring MVC</li><li>RestTemplate</li><li>HttpClient</li><li>OkHttp3</li><li>JDBC </li><li>Dubbo(2.6/2.7)</li><li>SOFARPC</li><li>Redis</li><li>MongoDB</li><li>Spring Message</li><li>Spring Cloud Stream (基于 Spring Message 的埋点)</li><li>RocketMQ</li><li>Spring Cloud FeignClient</li><li>Hystrix</li></ul><blockquote><p>大多数能力提供在 3.x 版本，2.x 版本从官方 issue 中可以看到后续将不在继续提供新的功能更新；这也是和 SpringBoot 宣布不在继续维护 1.x 版本有关系。</p></blockquote><p>本文将从插件的角度来分析，SOFATracer 是如何实现对上述组件进行埋点的；通过本文，除了了解 SOFATracer 的埋点机制之外，也可以对上述组件的基本扩展机制以及基本原理有一点学习。</p><h2 id="标准-Servlet-规范埋点原理"><a href="#标准-Servlet-规范埋点原理" class="headerlink" title="标准 Servlet 规范埋点原理"></a>标准 Servlet 规范埋点原理</h2><p>SOFATracer 支持对标准 Servlet 规范的 web mvc 埋点，包括普通的 servlet 和 Springmvc 等；基本原理就是基于 Servelt 规范所提供的 <code>javax.servlet.Filter</code> 过滤器接口扩展实现。</p><blockquote><p>过滤器位于 client 和 web 应用程序之间，用于检查和修改两者之间流过的请求和响应信息。在请求到达 Servlet 之前，过滤器截获请求。在响应送给客户端之前，过滤器截获响应。多个过滤器形成一个 FilterChain，FilterChain 中不同过滤器的先后顺序由部署文件 web.xml 中过滤器映射<filter-mapping>的顺序决定。最先截获客户端请求的过滤器将最后截获 Servlet 的响应信息。</filter-mapping></p></blockquote><p>web 应用程序一般作为请求的接收方，在 Tracer 中应用是作为 server 存在的，其在解析 SpanContext 时所对应的事件为 sr (server receive)。</p><p>SOFATracer 在 sofa-tracer-springmvc-plugin 插件中解析及产生 span 的过程大致如下：</p><ul><li>Servlet Filter 拦截到 request 请求</li><li>从请求中解析 SpanContext </li><li>通过 SpanContext 构建当前 MVC 的 span </li><li>给当前 span 设置 tag、log。</li><li>在 filter 处理的最后，结束 span。</li></ul><p>当然这里面还会设计到其他很多细节，比如给 span 设置哪些 tag 属性、如果处理异步线程透传等等。本篇不展开细节探讨，有兴趣的同学可以自行阅读代码或者和我交流。</p><h2 id="Dubbo-埋点原理"><a href="#Dubbo-埋点原理" class="headerlink" title="Dubbo 埋点原理"></a>Dubbo 埋点原理</h2><p>Dubbo 埋点在 SOFATracer 中实际上提供了两个插件，分别用于支持 Dubbo 2.6.x 和 Dubbo 2.7.x；Duddo 埋点也是基于 Filter ，此Filter 是 Dubbo 提供的 SPI 扩展-<a href="http://dubbo.apache.org/zh-cn/docs/dev/impls/filter.html" target="_blank" rel="noopener">调用拦截扩展</a> 机制实现。</p><p>像 Dubbo 或者 SOFARpc 等 rpc 框架的埋点，通常需要考虑的点比较多，首先是 rpc 框架分客户端和服务端，所以在埋点时 rpc 的客户端和服务端必须要有所区分；再者就是 rpc 的调用方式包括很多种，如常见的同步调用、异步调用、oneway 等等，调用方式不同，所对应的 span 的结束时机也不同，重要是的基本所有的 rpc 框架都会使用线程池用来发起和处理请求，那么如何保证 tracer 在多线程环境下不串也很重要。</p><p>另外 Dubbo 2.6.x 和 Dubbo 2.7.x 在异步回调处理上差异比较大，Dubbo 2.7.x 中提供了 onResponse 方法（后面又升级为 Listener，包括 onResponse 和 onError 两个方法）；而 Dubbo 2.6.x 中则并未提供相应的机制，只能通过对 future 的硬编码处理来完成埋点和上报。</p><blockquote><p>这个问题 zipkin brave 对 Dubbo 2.6.x 的埋点时其实也没有考虑到，在做 SOFATracer 支持 Dubbo 2.6.x 时发现了这个 bug，并做了修复。</p></blockquote><p>SOFATracer 中提供的 DubboSofaTracerFilter 类： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span>(group = &#123; CommonConstants.PROVIDER, CommonConstants.CONSUMER &#125;, value = <span class="string">"dubboSofaTracerFilter"</span>, order = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboSofaTracerFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// todo trace</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SOFATracer 中用于处理 Dubbo 2.6.x 版本中异步回调处理的核心代码：</p><blockquote><p>Dubbo 异步处理依赖 ResponseFuture 接口，但是 ResponseFuture 在核心链路上并非是以数据或者 list 的形式存在，所以在链路上只会存在一个 ResponseFuture，因此如果我自定义一个类来实现 ResponseFuture 接口是没法达到预期目的的，因为运行期会存在覆盖 ResponseFuture 的问题。所以在设计上，SOFATracer 会通过 ResponseFuture 构建一个新的 FutureAdapter出来用于传递。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">ensureSpanFinishes</span><span class="params">(Future&lt;Object&gt; future, Invocation invocation, Invoker&lt;?&gt; invoker)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> deferFinish = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (future <span class="keyword">instanceof</span> FutureAdapter) &#123;</span><br><span class="line">        deferFinish = <span class="keyword">true</span>;</span><br><span class="line">        ResponseFuture original = ((FutureAdapter&lt;Object&gt;) future).getFuture();</span><br><span class="line">        ResponseFuture wrapped = <span class="keyword">new</span> AsyncResponseFutureDelegate(invocation, invoker, original);</span><br><span class="line">        <span class="comment">// Ensures even if no callback added later, for example when a consumer, we finish the span</span></span><br><span class="line">        wrapped.setCallback(<span class="keyword">null</span>);</span><br><span class="line">        RpcContext.getContext().setFuture(<span class="keyword">new</span> FutureAdapter&lt;&gt;(wrapped));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deferFinish;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="http-客户端埋点原理"><a href="#http-客户端埋点原理" class="headerlink" title="http 客户端埋点原理"></a>http 客户端埋点原理</h2><p>http 客户端埋点包括 HttpClient、OkHttp、RestTemplate 等，此类埋点一般都是基于拦截器机制来实现的，如 HttpClient 使用的 HttpRequestInterceptor、HttpResponseInterceptor；OkHttp 使用的 okhttp3.Interceptor；RestTemplate 使用的 ClientHttpRequestInterceptor。</p><p>以 OkHttp 为例，简单分析下 http 客户端埋点的实现原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取请求</span></span><br><span class="line">    Request request = chain.request();</span><br><span class="line">    <span class="comment">// 解析出 SpanContext ，然后构建 Span</span></span><br><span class="line">    SofaTracerSpan sofaTracerSpan = okHttpTracer.clientSend(request.method());</span><br><span class="line">    <span class="comment">// 发起具体的调用</span></span><br><span class="line">    Response response = chain.proceed(appendOkHttpRequestSpanTags(request, sofaTracerSpan));</span><br><span class="line">    <span class="comment">// 结束 span</span></span><br><span class="line">    okHttpTracer.clientReceive(String.valueOf(response.code()));</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Datasource-埋点原理"><a href="#Datasource-埋点原理" class="headerlink" title="Datasource 埋点原理"></a>Datasource 埋点原理</h2><p>和标准 servlet 规范实现一样，所有基于 <code>javax.sql.DataSource</code> 实现的 DataSource 均可以使用 SOFATracer 进行埋点。因为 DataSource 并没有提供像 Servlet 那样的过滤器或者拦截器，所以 SOFATracer 中没法直接通过常规的方式（Filter/SPI扩展拦截/拦截器等）进行埋点，而是使用了代理模式的方式来实现的。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/tracers/datasource.jpg" alt=""></p><p>上图为 SOFATracer 中 DataSource 代理类实现的类继承结构体系；可以看出，SOFATracer 中自定义了一个 BaseDataSource 抽象类，该抽象类继承 <code>javax.sql.DataSource</code> 接口，SmartDataSource 作为 BaseDataSource 的唯一子类，也就是 SOFATracer 中所使用的 代理类。所以如果你使用了 <code>sofa-tracer-datasource-plugin</code> 插件的话，可以看到最终运行时的 Datasource 类型是 <code>com.alipay.sofa.tracer.plugins.datasource.SmartDataSource</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实际被代理的 datasource</span></span><br><span class="line">    <span class="keyword">protected</span> DataSource        delegate;</span><br><span class="line">    <span class="comment">//  sofatracer 中自定义的拦截器，用于对连接操作、db操作等进行拦截埋点</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;Interceptor&gt; interceptors;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Interceptor&gt; dataSourceInterceptors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Interceptor 主要包括以下三种类型：</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/tracers/datasourceinteceptor.jpg" alt=""></p><p>以 StatementTracerInterceptor 为例 StatementTracerInterceptor 将将会拦截到所有 PreparedStatement 接口的方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatementTracerInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tracer 类型为 client </span></span><br><span class="line">    <span class="keyword">private</span> DataSourceClientTracer clientTracer;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClientTracer</span><span class="params">(DataSourceClientTracer clientTracer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// tracer 对象实例</span></span><br><span class="line">        <span class="keyword">this</span>.clientTracer = clientTracer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 记录当前系统时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        String resultCode = SofaTracerConstant.RESULT_SUCCESS;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开始一个 span</span></span><br><span class="line">            clientTracer.startTrace(chain.getOriginalSql());</span><br><span class="line">            <span class="comment">// 执行</span></span><br><span class="line">            <span class="keyword">return</span> chain.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            resultCode = SofaTracerConstant.RESULT_FAILED;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 这里计算执行时间 System.currentTimeMillis() - start</span></span><br><span class="line">            <span class="comment">// 结束一个 span</span></span><br><span class="line">            clientTracer.endTrace(System.currentTimeMillis() - start, resultCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体思路是，Datasource 通过组合的方式自定义一个代理类（实际上也可以理解为适配器模式中的对象适配模型方式），对所有目标对象的方式进行代理拦截，在执行具体的 sql 或者连接操作之前创建 datasource 的 span，在操作结束之后结束 span，并进行上报。</p><h2 id="消息埋点"><a href="#消息埋点" class="headerlink" title="消息埋点"></a>消息埋点</h2><p>消息框架组件包括很多，像常见的 RocketMQ、Kafka 等；处理各个组件自己提供的客户端之外，像 Spring 就提供了很多消息组件的封装，包括Spring Cloud Stream、Spring Integration、Spring Message 等等。SOFATracer 基于 Spring Message 标准实现了对常见消息组件和 Spring Cloud Stream 的埋点支持，同时也提供了基于 RocketMQ 客户端模式的埋点实现。</p><h3 id="Spring-Messaging-埋点实现原理"><a href="#Spring-Messaging-埋点实现原理" class="headerlink" title="Spring Messaging 埋点实现原理"></a>Spring Messaging 埋点实现原理</h3><p>spring-messaging 模块为集成 messaging api 和消息协议提供支持。这里我们先看一个 pipes-and-filters 架构模型：</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/mq/spring-messaging.jpg" alt=""></p><p>spring-messaging 的 support 模块中提供了各种不同的 MessageChannel 实现和 channel interceptor 支持，因此在对 spring-messaging 进行埋点时我们自然就会想到去使用 channel interceptor。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SOFATracer 实现的基于 spring-messaging 消息拦截器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaTracerChannelInterceptor</span> <span class="keyword">implements</span> <span class="title">ChannelInterceptor</span>, <span class="title">ExecutorChannelInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// todo trace</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// THIS IS ChannelInterceptor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 发送之前</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送后</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">postSend</span><span class="params">(Message&lt;?&gt; message, MessageChannel channel, <span class="keyword">boolean</span> sent)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成发送之后</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">afterSendCompletion</span><span class="params">(Message&lt;?&gt; message, MessageChannel channel, <span class="keyword">boolean</span> sent, @Nullable Exception ex)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收消息之前</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">preReceive</span><span class="params">(MessageChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收后</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Message&lt;?&gt; postReceive(Message&lt;?&gt; message, MessageChannel channel) &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成接收消息之后</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">afterReceiveCompletion</span><span class="params">(@Nullable Message&lt;?&gt; message, MessageChannel channel, @Nullable Exception ex)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 ChannelInterceptor 实现了消息传递全生命周期的管控，通过暴露出来的方法，可以轻松的实现各个阶段的扩展埋点。</p><h3 id="RocketMQ-埋点实现原理"><a href="#RocketMQ-埋点实现原理" class="headerlink" title="RocketMQ 埋点实现原理"></a>RocketMQ 埋点实现原理</h3><p>RocketMQ 本身是提供了对 Opentracing 规范支持的，由于其支持的版本较高，与 SOFATracer 所实现的 Opentracing 版本不一致，所以在一定程度上不兼容；因此 SOFATracer（opentracing 0.22.0 版本）自身又单独提供了 RocketMQ  的插件。</p><p>RocketMQ 埋点其实是通过两个 hook 接口来完成，实际上在 RocketMQ 的官方文档中貌似并没有提到这两个点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RocketMQ 消息消费端 hook 接口埋点实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaTracerConsumeMessageHook</span> <span class="keyword">implements</span> <span class="title">ConsumeMessageHook</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RocketMQ 消息发送端 hook 接口埋点实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaTracerSendMessageHook</span> <span class="keyword">implements</span> <span class="title">SendMessageHook</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>首先是 SendMessageHook 接口，SendMessageHook 接口提供了两个方法，sendMessageBefore 和 sendMessageAfter，SOFATracer 在实现埋点时，sendMessageBefore 中用来解析和构建 span，sendMessageAfter 中用于拿到结果然后结束 span。</p><p>同样的，ConsumeMessageHook 中也提供了两个方法（consumeMessageBefore和consumeMessageAfter），可以提供给 SOFATracer 来从消息中解析出透传的 tracer 信息然后再将 tracer 信息透传到下游链路中去。</p><h2 id="redis-埋点原理"><a href="#redis-埋点原理" class="headerlink" title="redis 埋点原理"></a>redis 埋点原理</h2><p>SOFATracer 中的 redis 埋点是基于 spring data redis 实现的，没有针对具体的 redis 客户端来埋点。另外 redis 埋点部分参考的是开源社区<a href="https://github.com/opentracing-contrib/java-spring-cloud/tree/master/instrument-starters/opentracing-spring-cloud-redis-starter" target="_blank" rel="noopener">opentracing-spring-cloud-redis-starter</a>中的实现逻辑。</p><p>redis 的埋点实现与 Datasource 的锚点实现基本思路是一致的，都是通过一层代理来是实现的拦截。<code>sofa-tracer-redis-plugin</code> 中对所有的 redis 操作都通过 RedisActionWrapperHelper 进行了一层包装，在执行具体的命令前后通过 SOFATracer 自己提供的 API 进行埋点操作。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">doInScope</span><span class="params">(String command, Supplier&lt;T&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建 span</span></span><br><span class="line">    Span span = buildSpan(command);</span><br><span class="line">    <span class="keyword">return</span> activateAndCloseSpan(span, supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 span 的生命周期内执行具体命令</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">activateAndCloseSpan</span><span class="params">(Span span, Supplier&lt;T&gt; supplier)</span> </span>&#123;</span><br><span class="line">    Throwable candidateThrowable = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行命令</span></span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        candidateThrowable = t;</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidateThrowable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过 tracer api 结束一个span</span></span><br><span class="line">        redisSofaTracer.clientReceiveTagFinish((SofaTracerSpan) span, <span class="string">"00"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之后 mongodb 的埋点也是基于 spring data 实现，埋点的实现思路和 redis 基本相同，这里就不在单独分析。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对蚂蚁金服分布式链路组件 SOFATracer 的埋点机制做了简要的介绍；从各个组件的埋点机制来看，整体思路就是对组件操作进行包装，在请求或者命令执行的前后进行 span 构建和上报。目前一些主流的链路跟踪组件像 brave 也是基于此思路，区别在于 brave 并非是直接基于 opentracing 规范进行编码，而是其自己封装了一整套 api ，然后通过面向 opentracing api 进行一层适配；另外一个非常流行的 skywalking 则是基于 java agent 实现，埋点实现的机制上与 SOFATracer 和 brave 不同。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.sofastack.tech/projects/sofa-tracer/overview/" target="_blank" rel="noopener">SOFATracer</a></li><li><a href="https://www.cnblogs.com/davidwang456/p/4446796.html" target="_blank" rel="noopener">spring源码分析之spring-messaging模块详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SOFATracer 是一个用于分布式系统调用跟踪的组件，通过统一的 TraceId 将调用链路中的各种网络调用情况以日志的方式记录下来，以达到透视化网络调用的目的，这些链路数据可用于故障的快速发现，服务治理等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GITHUB 地址：
      
    
    </summary>
    
      <category term="SOFA" scheme="http://www.glmapper.com/categories/SOFA/"/>
    
    
      <category term="SOFATracer" scheme="http://www.glmapper.com/tags/SOFATracer/"/>
    
      <category term="OpenTracing" scheme="http://www.glmapper.com/tags/OpenTracing/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 源码系列-自动配置及 starter 机制解析</title>
    <link href="http://www.glmapper.com/2020/01/05/springboot-series-auto-configure/"/>
    <id>http://www.glmapper.com/2020/01/05/springboot-series-auto-configure/</id>
    <published>2020-01-05T09:50:13.000Z</published>
    <updated>2020-04-05T11:42:35.448Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一家之言，如有任何错误，请批评指出，不胜感激 </p></blockquote><p><strong>本篇主要来讨论研究两个问题：1、什么自动配置，2、如何编写自动配置</strong></p><p>在使用 Spring 作为项目开发框架的过程中，当需要集成某个组件时，通常需要大量的 xml 配置才可以让项目工程 run 起来，下面先以 mybatis 为例，来看下如何使用 mybatis-Spring 模块，需要哪些必不可少的依赖和配置。</p><h2 id="使用-mybatis-spring"><a href="#使用-mybatis-spring" class="headerlink" title="使用 mybatis-spring"></a>使用 mybatis-spring</h2><p>任何组件的集成都绕不过两个问题：依赖和配置，关于配置在<a href=""></a>这篇文章中介绍了配置的一些点，有兴趣的可以看下。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>从 mybatis 的官方文当可以了解到，要使用 MyBatis-Spring 模块，需要在类路径下包含 mybatis-spring.jar 文件和相关依赖（如：mysql-connector-java）即可。如果使用 Maven 作为构建工具，则在 pom.xml 中加入以下代码即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;latest.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="bean-配置"><a href="#bean-配置" class="headerlink" title="bean 配置"></a>bean 配置</h2><p>Spirng 集成 mybatis 通常需要以下 bean 配置：</p><p><strong>1、dataSource</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">    // 省略其他配置</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2、sqlSessionFactory</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3、其他：包扫描和事务配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- DAO 接口所在包名，Spring 会自动查找其下的类，并将其定义为一个 Spring Bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.glmapper.bridge.boot.dao"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- (事务管理)transaction manager --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些个 bean 是在 Spring 中使用 mybatis 框架时基本必不可少的配置。那么在 SpringBoot 中呢？</p><h2 id="SpringBoot-中如何集成-mybatis-的"><a href="#SpringBoot-中如何集成-mybatis-的" class="headerlink" title="SpringBoot 中如何集成 mybatis 的"></a>SpringBoot 中如何集成 mybatis 的</h2><p>SpringBoot 集成 mybatis 非常简单，加一下下面的 starter ，再在 application.properties 配置下数据库连接配置即可；不需要配置 datasource，sqlSessionFactory 等这些 bean。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>官方文档：<a href="https://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/" target="_blank" rel="noopener">https://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/</a></p></blockquote><h2 id="mybatis-starter-是如何规避-bean-配置的"><a href="#mybatis-starter-是如何规避-bean-配置的" class="headerlink" title="mybatis starter 是如何规避 bean 配置的"></a>mybatis starter 是如何规避 bean 配置的</h2><p>引用 <code>mybatis-spring-boot-starter</code> 既然可以不用在 xml 中配置 bean ，那肯定是这些 bean 是在 <code>mybatis-spring-boot-starter</code> 中通过某种方式被创建了。</p><blockquote><p>在 SpringBoot 官方文档的描述中，starter 只是用来管理依赖的，一般不会有代码，自动配置的代码一般在 <code>xxxx-autoconfigure</code> 中。mybatis 的自动配置相关代码是在 <code>mybatis-spring-boot-autoconfigure</code> 中。</p></blockquote><p><code>mybatis-spring-boot-autoconfigure</code> 这依赖中只有简单的几个类，其中最核心的就是 MybatisAutoConfiguration 这个配置类。另外一个 MybatisProperties 是 mybatis spring boot 的属性配置类，就是常见的 mybatis.xxxx。</p><h3 id="MybatisAutoConfiguration-自动配置类"><a href="#MybatisAutoConfiguration-自动配置类" class="headerlink" title="MybatisAutoConfiguration 自动配置类"></a>MybatisAutoConfiguration 自动配置类</h3><p>MybatisAutoConfiguration 的定义及其生效条件：</p><ul><li>1.当前 classpath 下必须有 SqlSessionFactory 和 SqlSessionFactoryBean 这两个类</li><li>2.存在 DataSource bean 实例 </li><li>3.有配置类 MybatisProperties 实例</li><li>4.在 DataSourceAutoConfiguration 和 MybatisLanguageDriverAutoConfiguration 两个自动配置类之后刷新</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)</span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate</span>(DataSource.class)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(MybatisProperties.class)</span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(&#123; DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisAutoConfiguration</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义 SqlSessionFactory bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkConfigFileExists();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码片段大体可以知道 MybatisAutoConfiguration 所做的事情主要包括以下几点：1、刷新 SqlSessionFactory 和 SqlSessionFactoryBean 两个 bean；2、afterPropertiesSet 中做一些准备或者检验工作（这里就是 check 了 mybatis 的配置文件是否配置了）</p><p>关于 DataSource 的 bean ，则是由 DataSourceAutoConfiguration 这个配置类中来定义。</p><blockquote><p>具体代码有兴趣的读者可以自己查阅相关源码，这里就不展开了。</p></blockquote><p>所以整体看来， MybatisAutoConfiguration 及其所依赖的 xxxConfiguration 会帮助用户定义 bean 和解析配置。</p><h2 id="mybatis-自动配置的-bean-是如何生效的"><a href="#mybatis-自动配置的-bean-是如何生效的" class="headerlink" title="mybatis 自动配置的 bean 是如何生效的"></a>mybatis 自动配置的 bean 是如何生效的</h2><p>上面分析到 MybatisAutoConfiguration 及其依赖的配置自动类会帮助创建运行时所需要的 bean，那么这些 bean 是如何被 SpringBoot 框架感知并加载的呢？</p><p>其实一般的项目工程中，如果我们在一个类上打了 @Configuration 注解的话，Spring 会直接能够加载到的（前提是这个类所在的包在启动类的子包下）。但是在框架层面，项目的包和所引入的组件包的包路径肯定是有差异的，所以在一些情况下会刷不到依赖中的 bean。</p><p>SpringBoot 中提供了一种类似于 SPI 机制的方式来帮忙加载 EnableAutoConfiguration、ApplicationListner、ApplicationContextInitializer 等类型的 bean。比如 mybatis 自动配置的配置如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration,\</span><br><span class="line">org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</span><br></pre></td></tr></table></figure><p>其处理逻辑在 SpringApplication 类中，具体解析方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">createSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">ClassLoader classLoader, Object[] args, Set&lt;String&gt; names)</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; instances = <span class="keyword">new</span> ArrayList&lt;&gt;(names.size());</span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);</span><br><span class="line">            Assert.isAssignable(type, instanceClass);</span><br><span class="line">            <span class="comment">// 反射拿到构造函数</span></span><br><span class="line">            Constructor&lt;?&gt; constructor = instanceClass.getDeclaredConstructor(parameterTypes);</span><br><span class="line">            <span class="comment">// 创建 bean </span></span><br><span class="line">            T instance = (T) BeanUtils.instantiateClass(constructor, args);</span><br><span class="line">            instances.add(instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot instantiate "</span> + type + <span class="string">" : "</span> + name, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何编写自己的-starter"><a href="#如何编写自己的-starter" class="headerlink" title="如何编写自己的 starter"></a>如何编写自己的 starter</h2><p>本小节将结合上面的描述，自定义一个 starter，让你的项目和 xml bean 配置说再见。</p><p><strong>场景描述：有两个 bean,一个 parentBean，一个 childBean，parentBean 需要依赖 childBean，parentBean中又要依赖 http 包</strong></p><p>原来的 xml 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"parentBean"</span> <span class="attr">class</span>=<span class="string">"com.glmapper.bridge.boot.service.impl.ParentBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"childBean"</span> <span class="attr">ref</span>=<span class="string">"childBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"childBean"</span> <span class="attr">class</span>=<span class="string">"com.glmapper.bridge.boot.service.impl.ChildBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>下面考虑的是将这些 bean 作为公共组件提供给其他项目工程用，从框架角度来看，最佳实践是：</p><ul><li>提供一个 autoconfigure 模块用于编写自动配置类代码</li><li>提供一个 starter，用于提供给外部用户使用</li></ul><h3 id="编写-autoconfigure"><a href="#编写-autoconfigure" class="headerlink" title="编写 autoconfigure"></a>编写 autoconfigure</h3><ul><li>自动配置类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// parentBean 依赖 HttpClient，所以如果没有 HttpClient 则不会刷新当前自动配置类</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(HttpClient.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmpperAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ParentBean bean 定义</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>   <span class="comment">// 如果当前 Spring 容器中已经存在 parentBean则不会再创建</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ParentBean <span class="title">parentBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParentBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ChildBean bean 定义</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChildBean <span class="title">childBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ChildBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>依赖 scope 使用 provided，不直接打在 autoconfigure 依赖中</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>编写 spring.factories，在 resources/META-INF/ 新建一个 spring.factories 文件，配置如下：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  com.glmapper.bridge.boot.autoconfigure.GlmpperAutoConfiguration</span><br></pre></td></tr></table></figure><h3 id="编写-starter"><a href="#编写-starter" class="headerlink" title="编写 starter"></a>编写 starter</h3><p>starter 里面没有代码，只做依赖管控</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.glmapper.bridge.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guides-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>starter 里面包括了自动配置的依赖和 httpclient 的依赖，所以用户在引入 starter 之后所有生效条件都满足了，就会在启动时直接刷新。</p><blockquote><p>示例工程: <a href="https://github.com/glmapper/springboot-series-guides.git（guides-autoconfigure" target="_blank" rel="noopener">https://github.com/glmapper/springboot-series-guides.git（guides-autoconfigure</a> 模块和 guides-starter 模块）</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><p>本篇是介于源码解析和实践系列之间的一篇，作为源码解析的终篇和实践的开篇。</p></blockquote><p>本篇以 mybatis 为例，对 spring 环境和 SpringBoot 环境下的使用方式做了简单对比；以此为切入点，介绍了 SpringBoot 中的自动配置及 starter 最佳实践。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/glmapper-2.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一家之言，如有任何错误，请批评指出，不胜感激 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇主要来讨论研究两个问题：1、什么自动配置，2、如何编写自动配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在使用 Spring 作为项目开发框架的过
      
    
    </summary>
    
      <category term="springboot" scheme="http://www.glmapper.com/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://www.glmapper.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实践系列-外部化配置优先级问题</title>
    <link href="http://www.glmapper.com/2020/01/03/springboot-series-externalize-prop/"/>
    <id>http://www.glmapper.com/2020/01/03/springboot-series-externalize-prop/</id>
    <published>2020-01-03T15:27:29.000Z</published>
    <updated>2020-04-05T11:43:03.204Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要针对 <code>spring.profiles.active</code>、<code>spring.config.location</code> 以及 <code>spring.config.additional-location</code> 的作用机制及优先级问题进行实践对比。</p><blockquote><p>本文案例工程已上传 github 仓库：<a href="https://github.com/glmapper/springboot-series-guides/tree/master/guides-properties" target="_blank" rel="noopener">https://github.com/glmapper/springboot-series-guides/tree/master/guides-properties</a></p></blockquote><h2 id="spring-profiles-active"><a href="#spring-profiles-active" class="headerlink" title="spring.profiles.active"></a>spring.profiles.active</h2><p>除了 application.properties 文件之外，profile-specific 配置也可以通过以下命名方式来定义:application-{profile}.properties。在没有使用 active 指定 profiles 的情况下，Environment 会指定一组默认的 profiles（默认情况下是[default])，换句话说就是，如果没有显示的激活 profiles 配置文件，则默认加载的是 application-default.properties 配置文件。</p><p>profile-specific 配置文件的属性与标准 application.properties 从相同的位置加载（一般是 classpath 下）；profile-specific 指定的 properties 配置文件始终覆盖默认配置。</p><p>在案例工程中(guides-properties)，resources 下面包括 application.properties 和 application-dev.properties 两份配置文件</p><ul><li>application.properties 文件配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=appNameInner</span><br><span class="line">testKey=key-default</span><br></pre></td></tr></table></figure><ul><li>application-dev.properties 文件配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testKey=key-dev</span><br></pre></td></tr></table></figure><p>通过以下代码在启动时将配置值输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;testKey&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String testKey;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">    System.out.println(testKey);</span><br><span class="line">    System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不指定-spring-profiles-active-时"><a href="#不指定-spring-profiles-active-时" class="headerlink" title="不指定 spring.profiles.active 时"></a>不指定 spring.profiles.active 时</h3><p>通过 <code>java -jar guides-properties/target/guides-properties-0.0.1-SNAPSHOT.jar</code> 启动工程，console 输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2020-01-04 00:08:47.279  INFO 11050 --- [           main] com.glmapper.bridge.boot.BootStrap       : No active profile set, falling back to default profiles: default</span><br><span class="line">-------------------------------</span><br><span class="line">key-default</span><br><span class="line">-------------------------------</span><br></pre></td></tr></table></figure><p>结论是，如果不显示指定 profiles，则使用默认的。</p><h3 id="指定-spring-profiles-active-时"><a href="#指定-spring-profiles-active-时" class="headerlink" title="指定 spring.profiles.active 时"></a>指定 spring.profiles.active 时</h3><p>通过 <code>java -jar -Dspring.profiles.active=dev guides-properties/target/guides-properties-0.0.1-SNAPSHOT.jar</code> 启动工程，console 输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2020-01-04 00:08:14.426  INFO 11040 --- [           main] com.glmapper.bridge.boot.BootStrap       : The following profiles are active: dev</span><br><span class="line">-------------------------------</span><br><span class="line">key-dev</span><br><span class="line">-------------------------------</span><br></pre></td></tr></table></figure><p>结论是，在显示指定 profiles 的情况下，会覆盖默认 application.properties 中的配置值。</p><h2 id="spring-config-location"><a href="#spring-config-location" class="headerlink" title="spring.config.location"></a>spring.config.location</h2><p>在 SpringBoot 2.x 中 spring.config.location 的语义发生了变更(此项配置会导致 classpath 中的 application.properties 不再生效)。原因如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Set&lt;String&gt; <span class="title">getSearchLocations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// spring.config.location 直接使用此份文件，不会再处理其他配置文件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.environment.containsProperty(CONFIG_LOCATION_PROPERTY)) &#123;</span><br><span class="line">        <span class="keyword">return</span> getSearchLocations(CONFIG_LOCATION_PROPERTY);</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;String&gt; locations = getSearchLocations(CONFIG_ADDITIONAL_LOCATION_PROPERTY);</span><br><span class="line">    locations.addAll(</span><br><span class="line">            asResolvedSet(ConfigFileApplicationListener.<span class="keyword">this</span>.searchLocations, DEFAULT_SEARCH_LOCATIONS));</span><br><span class="line">    <span class="keyword">return</span> locations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在工程的根目录的 <code>conf</code> 目录下新建一个 <code>application-conf.properties</code> 配置文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testKey=key-spring.config.location</span><br></pre></td></tr></table></figure><p>通过 <code>java -jar -Dspring.config.location=conf/application-conf.properties guides-properties/target/guides-properties-0.0.1-SNAPSHOT.jar</code> 启动工程，发现启动报错，原因是因为 application-conf.properties 中没有 配置 <code>spring.application.name</code>，而 <code>spring.application.name</code> 是在 resources 目录下的 application.properties 中的，所以也间接说明前面提到的，会使 classpath 下的配置失效。新增 <code>spring.application.name</code> 之后，重新启动工程，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=guides-properties</span><br><span class="line">testKey=key-spring.config.location</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2020-01-04 00:19:12.225  INFO 11147 --- [           main] com.glmapper.bridge.boot.BootStrap       : No active profile set, falling back to default profiles: default</span><br><span class="line">-------------------------------</span><br><span class="line">key-spring.config.location</span><br><span class="line">-------------------------------</span><br></pre></td></tr></table></figure><p>所以在使用 <code>spring.config.location</code> 指定外部配置文件时，需要此份配置文件需全量满足当前工程运行时所需，因为它不会去与 resources 目录下的配置文件去做 merge 操作。</p><h2 id="spring-config-additional-location"><a href="#spring-config-additional-location" class="headerlink" title="spring.config.additional-location"></a>spring.config.additional-location</h2><p>在使用 <code>spring.config.additional-location</code> 这种方式自定义 locations 时，除了默认 locations 之外，还会使用 <code>spring.config.additional-location</code> 指定的。</p><blockquote><p>additional-location：言外之意就是增量的配置</p></blockquote><p>在工程的根目录的 <code>conf</code> 目录下新建一个 <code>application-addition.properties</code> 配置文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testKey=key-addition</span><br></pre></td></tr></table></figure></p><p>通过 <code>java -jar -Dspring.config.additional-location=conf/application-addition.properties guides-properties/target/guides-properties-0.0.1-SNAPSHOT.jar</code> 启动工程，输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2020-01-04 00:28:30.048  INFO 11384 --- [           main] com.glmapper.bridge.boot.BootStrap       : No active profile set, falling back to default profiles: default</span><br><span class="line">-------------------------------</span><br><span class="line">key-addition</span><br><span class="line">-------------------------------</span><br></pre></td></tr></table></figure></p><p>结论是，会覆盖默认 application.properties 中的配置值。</p><h2 id="spring-config-additional-location-与-spring-profiles-active-配置加载关系"><a href="#spring-config-additional-location-与-spring-profiles-active-配置加载关系" class="headerlink" title="spring.config.additional-location 与 spring.profiles.active 配置加载关系"></a>spring.config.additional-location 与 spring.profiles.active 配置加载关系</h2><p><code>spring.config.location</code> 不用多说，它就是独立的一份，使用它就不能使用其它的。所以这里只分析 <code>spring.config.additional-location</code> 与 <code>spring.profiles.active</code> 配置加载关系。</p><h3 id="同时指定两个配置"><a href="#同时指定两个配置" class="headerlink" title="同时指定两个配置"></a>同时指定两个配置</h3><p>通过 <code>java -jar -Dspring.profiles.active=dev -Dspring.config.additional-location=conf/application-addition.properties guides-properties/target/guides-properties-0.0.1-SNAPSHOT.jar</code> 启动工程，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2020-01-04 00:32:59.044  INFO 11451 --- [           main] com.glmapper.bridge.boot.BootStrap       : The following profiles are active: dev</span><br><span class="line">-------------------------------</span><br><span class="line">key-dev</span><br><span class="line">-------------------------------</span><br></pre></td></tr></table></figure><p>为了排除与 -D 参数顺序有关，也使用如下方式再执行一次：<code>java -jar -Dspring.config.additional-location=conf/application-addition.properties -Dspring.profiles.active=dev  guides-properties/target/guides-properties-0.0.1-SNAPSHOT.jar</code>，输出结果与前面相同，所以可以得出，<code>spring.profiles.active</code> 的优先级比 <code>spring.config.additional-location</code> 要高。</p><h3 id="spring-config-additional-location-指定差异增量配置"><a href="#spring-config-additional-location-指定差异增量配置" class="headerlink" title="spring.config.additional-location 指定差异增量配置"></a><code>spring.config.additional-location</code> 指定差异增量配置</h3><p>在 <code>spring.config.additional-location</code> 中增加 additionKey</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testKey=key-addition</span><br><span class="line">additionKey=testAddition</span><br></pre></td></tr></table></figure><p>使用 <code>java -jar -Dspring.config.additional-location=conf/application-addition.properties -Dspring.profiles.active=dev  guides-properties/target/guides-properties-0.0.1-SNAPSHOT.jar</code> 启动工程，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2020-01-04 11:44:42.227  INFO 12821 --- [           main] com.glmapper.bridge.boot.BootStrap       : The following profiles are active: dev</span><br><span class="line">-------------------------------</span><br><span class="line">key-dev</span><br><span class="line">testAddition</span><br><span class="line">-------------------------------</span><br></pre></td></tr></table></figure><p>结论是 <code>spring.config.additional-location</code> 可以用于提供出 profiles 机制或者默认方式之外的增量配置。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在使用外部化配置文件时，执行顺序为：</p><p><code>spring.config.location</code> &gt; <code>spring.profiles.active</code> &gt; <code>spring.config.additional-location</code> &gt; 默认的 <code>application.proerties</code>。</p><p>其中通过 <code>spring.profiles.active</code> 和 <code>spring.config.additional-location</code>指定的配置文件会与 默认的<code>application.proerties</code> merge 作为最终的配置，<code>spring.config.location</code> 则不会。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要针对 &lt;code&gt;spring.profiles.active&lt;/code&gt;、&lt;code&gt;spring.config.location&lt;/code&gt; 以及 &lt;code&gt;spring.config.additional-location&lt;/code&gt; 的作用机制及优先
      
    
    </summary>
    
      <category term="springboot" scheme="http://www.glmapper.com/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://www.glmapper.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 源码系列-配置解析</title>
    <link href="http://www.glmapper.com/2019/12/29/springboot-series-propertysource/"/>
    <id>http://www.glmapper.com/2019/12/29/springboot-series-propertysource/</id>
    <published>2019-12-29T12:41:49.000Z</published>
    <updated>2020-04-05T11:44:08.536Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：本文基于 SpringBoot 2.1.11 版本</p></blockquote><p><strong>说到配置，你能想到的是什么？</strong> </p><p>在日常的开发和运维过程中，可以说配置都是及其重要的，因为它可能影响到应用的正常启动或者正常运行。相信在之前 Spring xml 时代，很多人都会被一堆 xml 配置折腾的够呛，除此之外，还有像数据库连接配置、缓存配置、注册中心配置、消息配置等等，这些相信大家都不会陌生。</p><p>配置对于开发人员或者运维人员来说可以比喻成一把”钥匙“，可以通过这把”钥匙“让我们的程序 run 起来，可以通过这把 ”钥匙“ 开启或者关闭应用程序的某一个功能。那么为什么会需要配置，对于一个应用来说，配置的意义又是什么呢？</p><h2 id="配置对于框架组件和应用程序的意义"><a href="#配置对于框架组件和应用程序的意义" class="headerlink" title="配置对于框架组件和应用程序的意义"></a>配置对于框架组件和应用程序的意义</h2><p>配置对于框架组件和应用程序的意义是什么？我的理解是可以让框架组件和应用程序变得灵活，通过配置可以使得一个框架组件或者一个应用程序在不需要做任何自身代码变更的情况下跑在不同的环境、不同的场景下。例如 Dubbo ，用户可以通过配置使得 Dubbo 将服务注册到不同的注册中心，nacos、zookeeper、SOFARegistry 等等；再比如，我有一个应用程序，在 dev 环境和生产环境需要连接不同的数据库，但是我又不想去在代码里面去做修改来适配不同的环境，那么同样我也可以使用配置的方式来做控制。配置可以让框架组件和应用程序变得灵活、不强耦合在某一个场景或者环境下，它可以有很多种存在形态，如常见的是存在文件中、配置中心中、系统环境变量中，对于 JAVA 程序来说还可以是命令行参数或者 -D 参数。可以说任何优秀的框架或者应用，都离不开配置。</p><p>那么作为 Java 语言生态里面最优秀的框架， Spring 是如何管理和使用配置的呢？本篇将以 SpringBoot 中的配置为切入点，来进行详细的剖析。</p><h2 id="SpringBoot-中的配置"><a href="#SpringBoot-中的配置" class="headerlink" title="SpringBoot 中的配置"></a>SpringBoot 中的配置</h2><p>Spring Boot 官方文章中使用了单独的章节和大量的篇幅对配置进行了描述，可以见得，配置对于 SpringBoot 来说，是相当重要的。 Spring Boot 允许用户将配置外部化，以便可以在不同的环境中使用相同的应用程序代码，用户可以使用 properties 文件、YAML 文件、环境变量和命令行参数来具体化配置。属性值可以通过使用 @Value 注释直接注入 bean，可以通过 Spring 的环境抽象访问，也可以通过 @ConfigurationProperties 绑定到结构化对象。</p><p>在日常的开发中，对于 SpringBoot 中的配置，可能直接想到的就是 application.properties，实际上，从 SpringBoot 官方文档可以看到，SpringBoot 获取配置的方式有多达 17 种；同时 Spring Boot 也提供了一种非常特殊的 PropertyOrder，来允许用户可以在适当的场景下覆盖某些属性值，下面就是官方文档中描述的属性优先加载顺序:</p><ul><li>1.在主目录（当 devtools 被激活，则为 ~/.spring-boot-devtools.properties ）中的 Devtools 全局设置属性。</li><li>2.在测试中使用到的 @TestPropertySource 注解。</li><li>3.在测试中使用到的 properties 属性，可以是 @SpringBootTest 和用于测试应用程序某部分的测试注解。</li><li>4.命令行参数。</li><li>5.来自 SPRING_APPLICATION_JSON 的属性（嵌入在环境变量或者系统属性【system propert】中的内联 JSON）</li><li>6.ServletConfig 初始化参数。</li><li>7.ServletContext 初始化参数。</li><li>8.来自 java:comp/env 的 JNDI 属性。</li><li>9.Java 系统属性（System.getProperties()）。</li><li>10.操作系统环境变量。</li><li>11.只有 random.* 属性的 RandomValuePropertySource。</li><li>12.在已打包的 fatjar 外部的指定 profile 的应用属性文件（application-{profile}.properties 和 YAML 变量）。</li><li>13.在已打包的 fatjar 内部的指定 profile 的应用属性文件（application-{profile}.properties 和 YAML 变量）。</li><li>14.在已打包的 fatjar 外部的应用属性文件（application.properties 和 YAML 变量）。</li><li>15.在已打包的 fatjar 内部的应用属性文件（application.properties 和 YAML 变量）。</li><li>16.在 @Configuration 类上的 @PropertySource 注解。</li><li>17.默认属性（使用 SpringApplication.setDefaultProperties 指定）。</li></ul><p>相信绝大多数都是你不曾用过的，不用纠结，其实用不到也很正常，但是我们还是需要能够知道它提供的方式有哪些，以便于在适当的场景下掏出来镇楼！</p><p>Spring 中对于配置最终都是交给 Environment 对象来管理，也就是我们常说的 Spring 环境。比如可以通过以下方式从 Environment 中获取配置值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableEnvironment environment = context.getEnvironment();</span><br><span class="line">environment.getProperty(<span class="string">"key"</span>);</span><br></pre></td></tr></table></figure><p>那么 Environment 是如何被构建的呢？Environment 与配置的关系又是什么？</p><h2 id="Environment-构建"><a href="#Environment-构建" class="headerlink" title="Environment 构建"></a>Environment 构建</h2><p>Environment 的构建发生在 prepareEnvironment 中，关于 SpringBoot 启动过程想了解更多，可以参考这篇 <a href="http://www.glmapper.com/2019/12/07/springboot-series-started/">SpringBoot系列-启动过程分析</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableEnvironment <span class="title">getOrCreateEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.environment != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.environment;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) &#123;</span><br><span class="line">        <span class="comment">// 标准的 web 应用</span></span><br><span class="line"><span class="keyword">case</span> SERVLET:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> StandardServletEnvironment();</span><br><span class="line">        <span class="comment">// webflux 应用</span></span><br><span class="line"><span class="keyword">case</span> REACTIVE:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> StandardReactiveWebEnvironment();</span><br><span class="line">        <span class="comment">// 非web应用</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本篇基于非 web 应用分析，所有主要围绕 StandardEnvironment 这个类展开分析。</p></blockquote><p>Environment 类继承结构体系：</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/env/env-class.jpg" alt=""></p><h3 id="systemProperties-amp-systemEnvironment"><a href="#systemProperties-amp-systemEnvironment" class="headerlink" title="systemProperties &amp; systemEnvironment"></a>systemProperties &amp; systemEnvironment</h3><p>在构建 StandardEnvironment 对象的过程中，会初始化 systemProperties &amp; systemEnvironment 两个 PropertySource。其触发时机是在其父类 AbstractEnvironment 的构造函数中。customizePropertySources 方法在 AbstractEnvironment 中并没有具体的实现，其依赖子类完成，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    customizePropertySources(<span class="keyword">this</span>.propertySources);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 StandardEnvironment 中的实现逻辑</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizePropertySources</span><span class="params">(MutablePropertySources propertySources)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建 systemProperties 配置</span></span><br><span class="line">    propertySources.addLast(</span><br><span class="line">            <span class="keyword">new</span> PropertiesPropertySource(SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties()));</span><br><span class="line">    <span class="comment">// // 构建 systemEnvironment 配置</span></span><br><span class="line">    propertySources.addLast(</span><br><span class="line">            <span class="keyword">new</span> SystemEnvironmentPropertySource(SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以我本机为例，来分别看下 systemProperties 和 systemEnvironment 主要是哪些东西</p><ul><li>systemProperties</li></ul><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/env/sysProperties.jpg" alt=""></p><ul><li>systemEnvironment</li></ul><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/env/sysEnvoriment.jpg" alt=""></p><h3 id="defaultProperties-amp-commandLineArgs"><a href="#defaultProperties-amp-commandLineArgs" class="headerlink" title="defaultProperties &amp; commandLineArgs"></a>defaultProperties &amp; commandLineArgs</h3><p>在构建完默认的 Environment 完成之后就是配置 Environment ，这里主要就包括默认的 defaultProperties 和命令行参数两个部分。defaultProperties 可以通过以下方式设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; defaultProperties = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">defaultProperties.put(<span class="string">"defaultKey"</span>,<span class="string">"defaultValue"</span>);</span><br><span class="line">SpringApplication springApplication = <span class="keyword">new</span> SpringApplication(BootStrap.class);</span><br><span class="line">springApplication.setDefaultProperties(defaultProperties);</span><br><span class="line">springApplication.run(args);</span><br></pre></td></tr></table></figure><p>配置 defaultProperties 和命令行参数过程的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configurePropertySources</span><span class="params">(ConfigurableEnvironment environment, String[] args)</span> </span>&#123;</span><br><span class="line">    MutablePropertySources sources = environment.getPropertySources();</span><br><span class="line">    <span class="comment">// 如果 springApplication 设置了则构建 defaultProperties，没有就算了</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.defaultProperties != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.defaultProperties.isEmpty()) &#123;</span><br><span class="line">        sources.addLast(<span class="keyword">new</span> MapPropertySource(<span class="string">"defaultProperties"</span>, <span class="keyword">this</span>.defaultProperties));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 命令行参数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.addCommandLineProperties &amp;&amp; args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// PropertySource 名为 commandLineArgs</span></span><br><span class="line">        String name = CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME;</span><br><span class="line">        <span class="keyword">if</span> (sources.contains(name)) &#123;</span><br><span class="line">            PropertySource&lt;?&gt; source = sources.get(name);</span><br><span class="line">            CompositePropertySource composite = <span class="keyword">new</span> CompositePropertySource(name);</span><br><span class="line">            composite.addPropertySource(</span><br><span class="line">                    <span class="keyword">new</span> SimpleCommandLinePropertySource(<span class="string">"springApplicationCommandLineArgs"</span>, args));</span><br><span class="line">            composite.addPropertySource(source);</span><br><span class="line">            sources.replace(name, composite);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sources.addFirst(<span class="keyword">new</span> SimpleCommandLinePropertySource(args));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringBoot 打成 fatjar 包后通过命令行传入的参数 包括以下 3 种实现方式</p><ul><li>java -jar xxx.jar  a b c : 通过 main 方法的参数获取，即 args </li><li>java -jar xxx.jar -Dp1=a -Dp2=b -Dp3=c : -D 参数方式，会被设置到系统参数中</li><li>java -jar xxx.jar –p1=a –p2=b –p3=c : SpringBoot 规范方式，可以通过 @Value(“${p1}”） 获取</li></ul><h3 id="配置-Profiles"><a href="#配置-Profiles" class="headerlink" title="配置 Profiles"></a>配置 Profiles</h3><p>为 application enviroment 配置哪些配置文件是 active 的(或者默认情况下是 active)。在配置文件处理期间，可以通过 spring.profiles.active 配置属性来激活其他配置文件。主要包括两种：</p><ul><li>通过 spring.profiles.active 配置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;String&gt; <span class="title">doGetActiveProfiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.activeProfiles) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.activeProfiles.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 获取 spring.profiles.active 配置值</span></span><br><span class="line">            <span class="comment">// 如：spring.profiles.active=local ，profiles 为 local</span></span><br><span class="line">            <span class="comment">// 如：spring.profiles.active=local,dev ，profiles 为 local,dev</span></span><br><span class="line">            String profiles = getProperty(ACTIVE_PROFILES_PROPERTY_NAME);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(profiles)) &#123;</span><br><span class="line">                <span class="comment">// 按 ，分割成 String[] 数组</span></span><br><span class="line">                setActiveProfiles(StringUtils.commaDelimitedListToStringArray(</span><br><span class="line">                        StringUtils.trimAllWhitespace(profiles)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回，这里还没有解析和 merge 配置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.activeProfiles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 SpringApplication 对象 setAdditionalProfiles 配置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication springApplication = <span class="keyword">new</span> SpringApplication(BootStrap.class);</span><br><span class="line"><span class="comment">// 设置 dev</span></span><br><span class="line">springApplication.setAdditionalProfiles(<span class="string">"dev"</span>);</span><br><span class="line">springApplication.run(args);</span><br></pre></td></tr></table></figure><p>以上两种方式设置的 profiles 会作为最后生效的 activeProfiles。</p><h3 id="configurationProperties"><a href="#configurationProperties" class="headerlink" title="configurationProperties"></a>configurationProperties</h3><p>将 ConfigurationPropertySource 支持附加到指定的 Environment。将 Environment 管理的每个 PropertySource 调整为 ConfigurationPropertySource 类型，并允许 PropertySourcesPropertyResolver 使用 ConfigurationPropertyName 调用解析。附加的解析器将动态跟踪任何来自基础环境属性源的添加或删除（这个也是 SpringCloud Config 的底层支持原理）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 类型检查</span></span><br><span class="line">    Assert.isInstanceOf(ConfigurableEnvironment.class, environment);</span><br><span class="line">    MutablePropertySources sources = ((ConfigurableEnvironment) environment).getPropertySources();</span><br><span class="line">    <span class="comment">// 获取名为 configurationProperties 的 PropertySource</span></span><br><span class="line">    PropertySource&lt;?&gt; attached = sources.get(ATTACHED_PROPERTY_SOURCE_NAME);</span><br><span class="line">    <span class="comment">// 如果存在先移除，保证每次都是最新的 PropertySource</span></span><br><span class="line">    <span class="keyword">if</span> (attached != <span class="keyword">null</span> &amp;&amp; attached.getSource() != sources) &#123;</span><br><span class="line">        sources.remove(ATTACHED_PROPERTY_SOURCE_NAME);</span><br><span class="line">        attached = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (attached == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 重新将名为 configurationProperties 的 PropertySource 放到属性源中</span></span><br><span class="line">        sources.addFirst(<span class="keyword">new</span> ConfigurationPropertySourcesPropertySource(ATTACHED_PROPERTY_SOURCE_NAME,</span><br><span class="line">                <span class="keyword">new</span> SpringConfigurationPropertySources(sources)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绑定-Environment-到-SpringApplication"><a href="#绑定-Environment-到-SpringApplication" class="headerlink" title="绑定 Environment 到 SpringApplication"></a>绑定 Environment 到 SpringApplication</h3><p>在 Spring Boot 2.0 中，用于绑定 Environment 属性的机制 @ConfigurationProperties 已经完全彻底修改; 所以相信很多人在迁移 SpringBoot 从 1.x 到 2.x 系列时，或者或少都会踩这块的坑。</p><p>新的 API 可以使得 @ConfigurationProperties 直接在你自己的代码之外使用。绑定规则可以参考：<a href="https://github.com/spring-projects/spring-boot/wiki/Relaxed-Binding-2.0" target="_blank" rel="noopener">Relaxed-Binding-2.0</a>。这里简单演示下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定 CustomProp</span></span><br><span class="line">List&lt;CustomProp&gt; props = Binder.get(run.getEnvironment())</span><br><span class="line">                .bind(<span class="string">"glmapper.property"</span>, Bindable.listOf(CustomProp.class))</span><br><span class="line">                .orElseThrow(IllegalStateException::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置类</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"glmapper.property"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomProp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 省略 get&amp;set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性配置：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">glmapper:</span></span><br><span class="line"><span class="attr">  property:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">glmapper</span></span><br><span class="line"><span class="attr">      age:</span> <span class="number">26</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">slg</span></span><br><span class="line"><span class="attr">      age:</span> <span class="number">26</span></span><br></pre></td></tr></table></figure></p><p>从上面整个构建过程来看，Enviroment 对象构建实际就是 MutablePropertySources 对象填充的过程。Environment 的静态属性和存储容器都是在AbstractEnvironment 中定义的，ConfigurableWebEnvironment 接口提供的 getPropertySources() 方法可以获取到返回的 MutablePropertySources 实例，然后添加额外的 PropertySource。实际上，Environment 的存储容器就是 PropertySource 的子类集合，而 AbstractEnvironment 中使用的实例就是 MutablePropertySources。</p><p>那么到这里相比 Environment 与配置的关系就非常清楚了，一句话概括就是：Environment 是所有配置的管理器，是 Spring 对提供配置的统一接口。前面提到 Environment 管理了所有 Spring 的环境配置，这些配置最终是以 MutablePropertySources 对象的形态存在 Environment  中。下图为 MutablePropertySources 类的继承体系：</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/env/propertySource.jpg" alt=""></p><p>下面继续来看 PropertySources。</p><h2 id="PropertySource-amp-PropertySources"><a href="#PropertySource-amp-PropertySources" class="headerlink" title="PropertySource &amp; PropertySources"></a>PropertySource &amp; PropertySources</h2><p>从名字就能直观看出，PropertySources 是持有一个或者多个 PropertySource 的类。PropertySources 提供了一组基本管理 PropertySource 的方法。</p><h3 id="PropertySource"><a href="#PropertySource" class="headerlink" title="PropertySource"></a>PropertySource</h3><p>下面看下 PropertySource 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertySource</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(getClass());</span><br><span class="line">    <span class="comment">// 属性名</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">// 属性源</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> T source;</span><br><span class="line">    <span class="comment">// 根据指定 name 和 source 构建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PropertySource</span><span class="params">(String name, T source)</span> </span>&#123;</span><br><span class="line">Assert.hasText(name, <span class="string">"Property source name must contain at least one character"</span>);</span><br><span class="line">Assert.notNull(source, <span class="string">"Property source must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.source = source;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据指定 name 构建，source 默认为 Object 类型</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PropertySource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(name, (T) <span class="keyword">new</span> Object());</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 返回当前 PropertySource 的 name</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 返回当前 PropertySource 的 source</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.source;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (getProperty(name) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">getProperty</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="comment">// 返回用于集合比较目的的 PropertySource 实现 (ComparisonPropertySource)。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> PropertySource&lt;?&gt; named(String name) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ComparisonPropertySource(name);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 省略其他两个内部类实现，无实际意义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 PropertySource 实例对应一个 name，例如 systemProperties、enviromentProperties 等。 PropertySource 包括多种类型的实现，主要包括：</p><ul><li>1、AnsiPropertySource：Ansi.*，包括 AnsiStyle、AnsiColor、AnsiBackground 等</li><li>2、StubPropertySource：在实际的属性源不能在 application context 创建时立即初始化的情况下用作占位符。例如，基于 ServletContext 的属性源必须等待，直到  ServletContext 对象对其封装的 ApplicationContext 可用。在这种情况下，应该使用存根来保存属性源的默认位置/顺序，然后在上下文刷新期间替换存根。<ul><li>ComparisonPropertySource：继承自 StubPropertySource ，所有属性访问方法强制抛出异常，作用就是一个不可访问属性的空实现。</li></ul></li><li>3、EnumerablePropertySource：可枚举的 PropertySource，在其父类的基础上扩展了 getPropertyNames 方法<ul><li>CompositePropertySource：source 为组合类型的 PropertySource 实现</li><li>CommandLinePropertySource：source 为命令行参数类型的 PropertySource 实现，包括两种命令行参数和 java opts 参数两种。</li><li>MapPropertySource：source 为 Map 类型的 PropertySource 实现<ul><li>PropertiesPropertySource：内部的 Map 实例由 Properties 实例转换而来</li><li>JsonPropertySource：内部的 Map 实例由 Json 实例转换而来</li><li>SystemEnvironmentPropertySource：内部的 Map 实例由 system env 获取</li></ul></li></ul></li></ul><p>其他还有 ServletConfigPropertySource、ServletContextPropertySource、AnnotationsPropertySource 等，均可根据名字知晓其 source 来源。</p><h3 id="PropertySources"><a href="#PropertySources" class="headerlink" title="PropertySources"></a>PropertySources</h3><p>PropertySources 接口比较简单，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PropertySources</span> <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">PropertySource</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 从 5.1 版本才提供的</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;PropertySource&lt;?&gt;&gt; stream() &#123;</span><br><span class="line"><span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// check name 为 「name」 的数据源是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="comment">// 根据 name」 获取数据源</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">PropertySource&lt;?&gt; get(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面在分析 Enviroment 构建中，可以看到整个过程都是以填充 MutablePropertySources 为主线。MutablePropertySources 是 PropertySources 的默认实现，它允许对包含的属性源进行操作，并提供了一个构造函数用于复制现有的 PropertySources 实例。此外，其内部在 addFirst 和 addLast 等方法中提到了 precedence（优先顺序） ，这些将会影响 PropertyResolver 解析给定属性时搜索属性源的顺序。</p><p>MutablePropertySources 内部就是对 propertySourceList 的一系列管理操作（增删改成等），propertySourceList 其实就是整个配置系统最底层的存储容器，所以就很好理解，配置解析为什么都是在填充 MutablePropertySources 这个对象了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置最终都被塞到这里了</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;PropertySource&lt;?&gt;&gt; propertySourceList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>最后我们再来看下，Spring 中 Environment 属性是如何被访问的。</p><h2 id="Environment-属性访问"><a href="#Environment-属性访问" class="headerlink" title="Environment 属性访问"></a>Environment 属性访问</h2><p>单从 Environment 代码来看，其内部并没有提供访问属性的方法，这些访问属性的方法都由其父类接口 PropertyResolver 提供。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PropertyResolver</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断属性是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsProperty</span><span class="params">(String key)</span></span>;</span><br><span class="line">    <span class="comment">// 获取属性</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getProperty</span><span class="params">(String key)</span></span>;</span><br><span class="line">    <span class="comment">// 获取属性，如果没有则提供默认值</span></span><br><span class="line"><span class="function">String <span class="title">getProperty</span><span class="params">(String key, String defaultValue)</span></span>;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getProperty</span><span class="params">(String key, Class&lt;T&gt; targetType)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getProperty</span><span class="params">(String key, Class&lt;T&gt; targetType, T defaultValue)</span></span>;</span><br><span class="line">    <span class="comment">// 获取 Required 属性</span></span><br><span class="line"><span class="function">String <span class="title">getRequiredProperty</span><span class="params">(String key)</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getRequiredProperty</span><span class="params">(String key, Class&lt;T&gt; targetType)</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br><span class="line">    <span class="comment">// 解析占位符</span></span><br><span class="line"><span class="function">String <span class="title">resolvePlaceholders</span><span class="params">(String text)</span></span>;</span><br><span class="line">    <span class="comment">// 解析 Required占位符</span></span><br><span class="line"><span class="function">String <span class="title">resolveRequiredPlaceholders</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Environment 中提供默认访问属性的对象实现是 PropertySourcesPropertyResolver，其定义在 AbstractEnvironment 这个抽象类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConfigurablePropertyResolver propertyResolver =</span><br><span class="line"><span class="keyword">new</span> PropertySourcesPropertyResolver(<span class="keyword">this</span>.propertySources);</span><br></pre></td></tr></table></figure><p>那文章最后就来看下 PropertySourcesPropertyResolver 是如何访问配置属性的吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">getProperty</span><span class="params">(String key, Class&lt;T&gt; targetValueType, <span class="keyword">boolean</span> resolveNestedPlaceholders)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.propertySources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历所有的 PropertySource</span></span><br><span class="line">        <span class="keyword">for</span> (PropertySource&lt;?&gt; propertySource : <span class="keyword">this</span>.propertySources) &#123;</span><br><span class="line">            <span class="comment">// 省略日志</span></span><br><span class="line">            <span class="comment">// 从 propertySource 中根据指定的 key 获取值</span></span><br><span class="line">            Object value = propertySource.getProperty(key);</span><br><span class="line">            <span class="comment">// 如果值不为空-&gt;选用第一个不为 null 的匹配 key 的属性值</span></span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 解析占位符替换, 如$&#123;server.port&#125;，底层委托到 PropertyPlaceholderHelper 完成</span></span><br><span class="line">                <span class="keyword">if</span> (resolveNestedPlaceholders &amp;&amp; value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                    value = resolveNestedPlaceholders((String) value);</span><br><span class="line">                &#125;</span><br><span class="line">                logKeyFound(key, propertySource, value);</span><br><span class="line">                <span class="comment">// 进行一次类型转换，具体由 DefaultConversionService 处理</span></span><br><span class="line">                <span class="keyword">return</span> convertValueIfNecessary(value, targetValueType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略日志 ...</span></span><br><span class="line">    <span class="comment">// 没有的话就返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一点需要注意，就是如果出现多个 PropertySource 中存在同名的 key，则只会返回第一个 PropertySource 对应 key 的属性值。在实际的业务开发中，如果需要自定义一些环境属性，最好要对各个 PropertySource 的顺序有足够的掌握。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整体看来，Spring 中对于配置的管理还是比较简单的，从 Environment 到 PropertySource 整个过程没有那么绕，就是单纯的把来自各个地方的配置统一塞到 MutablePropertySources 中，对外又通过 Environment 接口对外提供接口访问。</p><p>最后感谢大家一年来的关注和支持，**和 2019 说声再见，和 2020 说声你好！祝大家元旦快乐。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;注：本文基于 SpringBoot 2.1.11 版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;说到配置，你能想到的是什么？&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;在日常的开发和运维过程中，可以说配置都是及其重要的，因为它可能影响到应
      
    
    </summary>
    
      <category term="springboot" scheme="http://www.glmapper.com/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://www.glmapper.com/tags/springboot/"/>
    
      <category term="PropertySource" scheme="http://www.glmapper.com/tags/PropertySource/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 源码解析系列 &amp; SpringBoot 实践系列综述</title>
    <link href="http://www.glmapper.com/2019/12/24/springboot-series-summary/"/>
    <id>http://www.glmapper.com/2019/12/24/springboot-series-summary/</id>
    <published>2019-12-24T10:55:55.000Z</published>
    <updated>2020-04-06T04:30:53.817Z</updated>
    
    <content type="html"><![CDATA[<ul><li>源码解析系列：<ul><li><a href="http://www.glmapper.com/2019/10/13/springboot-series-fatjar/">SpringBoot 系列-FatJar技术解析</a></li><li><a href="http://www.glmapper.com/2019/12/07/springboot-series-started/">SpringBoot 系列-启动过程解析</a></li><li><a href="http://www.glmapper.com/2019/04/13/springboot-series-event/">SpringBoot 系列-事件机制解析</a></li><li><a href="http://www.glmapper.com/2019/12/14/springboot-series-bean-life/">SpringBoot 系列-Bean 的生命周期与扩展</a></li><li><a href="http://www.glmapper.com/2019/12/14/springboot-series-log/">SpringBoot 系列-日志框架解析</a></li><li><a href="http://www.glmapper.com/2019/12/09/springboot-series-access-resource/">SpringBoot 系列-资源访问解析</a></li><li><a href="http://www.glmapper.com/2019/10/06/springboot-series-server-tomcat/">SpringBoot 系列-内嵌Web容器解析</a></li><li><a href="http://www.glmapper.com/2019/12/29/springboot-series-propertysource/">SpringBoot 系列-配置解析</a></li><li><a href="http://www.glmapper.com/2020/01/05/springboot-series-auto-configure/">SpringBoot 系列-自动配置及 starter 机制解析</a></li><li><a href="http://www.glmapper.com/2020/01/03/springboot-series-externalize-prop/">SpringBoot 实践-外部化配置优先级问题</a></li></ul></li><li>实践系列<ul><li><a href="http://www.glmapper.com/2020/04/05/springboot-series-rocketmq/">SpringBoot 实践-集成 RocketMQ</a></li><li><a href="http://www.glmapper.com/2019/03/07/springboot-series-kafka-introduction/">SpringBoot 实践-Kafka简介&amp;集成SpringBoot</a></li><li>SpringBoot 实践-集成 Mybatis</li><li>SpringBoot 实践-集成 Dubbo</li><li>SpringBoot 实践-集成 REDIS</li><li>SpringBoot 实践-集成 NOSQL</li><li>SpringBoot 实践-集成 Oauth2</li><li>SpringBoot 实践-集成 Quartz Scheduler</li><li>SpringBoot 实践-集成 服务链路跟踪组件</li><li>SpringBoot 实践-镜像化部署</li><li>SpringBoot 实践-使用 K8S 部署 SpringBoot 工程</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;源码解析系列：&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.glmapper.com/2019/10/13/springboot-series-fatjar/&quot;&gt;SpringBoot 系列-FatJar技术解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a hre
      
    
    </summary>
    
      <category term="springboot" scheme="http://www.glmapper.com/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://www.glmapper.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>git ssh 配置及使用</title>
    <link href="http://www.glmapper.com/2019/12/20/tool-config-git-ssh/"/>
    <id>http://www.glmapper.com/2019/12/20/tool-config-git-ssh/</id>
    <published>2019-12-20T06:50:23.000Z</published>
    <updated>2019-12-20T07:14:55.687Z</updated>
    
    <content type="html"><![CDATA[<p>配置使用 ssh 方式来提交和克隆代码大概可以分为以下几个步骤：</p><ul><li>设置 Git 的 user name 和 email：(如果是第一次的话)</li><li>检查是否已经有 SSH Key。</li><li>生成密钥</li><li>添加密钥到 ssh-agent</li><li>登陆 github, 添加 ssh</li></ul><h2 id="设置-Git-的-user-name-和-email"><a href="#设置-Git-的-user-name-和-email" class="headerlink" title="设置 Git 的 user name 和 email"></a>设置 Git 的 user name 和 email</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户名替换成自己的用户名</span></span><br><span class="line">git config --global user.name <span class="string">"glmapper"</span></span><br><span class="line"><span class="comment"># 邮箱替换换成自己的邮箱</span></span><br><span class="line">git config --global user.email  <span class="string">"glmapper_2018@163.com"</span></span><br></pre></td></tr></table></figure><h2 id="检查是否已经有-SSH-Key"><a href="#检查是否已经有-SSH-Key" class="headerlink" title="检查是否已经有 SSH Key"></a>检查是否已经有 SSH Key</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 到 .ssh 目录下</span></span><br><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure><p>ls 列出所有文件，看是否存在 id_isa 和 id_isa.pub 文件（也可以是别的文件名，只要 yourName 和 yourName.pub 成对存在），如果存在的话，证明已经存在 ssh key了，可以直接跳过 <code>生成密钥</code> 这一步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alipaynet_rsa      alipaynet_rsa.pub  config             id_rsa             id_rsa.pub         known_hosts        ssh-rsa-bridge     ssh-rsa-bridge.pub</span><br></pre></td></tr></table></figure><h2 id="生成秘钥"><a href="#生成秘钥" class="headerlink" title="生成秘钥"></a>生成秘钥</h2><p>上述因为我已经配置过了，如果没有的话，可参考本节进行相关操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成秘钥</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"glmapper_2018@163.com"</span></span><br></pre></td></tr></table></figure><p>如果不需要密码的话，上述执行过程可以一直回车跳过；执行完成之后将会得到两个文件：id_rsa 和 id_rsa.pub。windows 下默认的路径是 <code>C:\Users\Administrator\.ssh</code> , Mac/Linux 默认是 <code>~/.ssh</code>。</p><h2 id="添加密钥到-ssh-agent"><a href="#添加密钥到-ssh-agent" class="headerlink" title="添加密钥到 ssh-agent"></a>添加密钥到 ssh-agent</h2><p>确保 ssh-agent 是可用的。ssh-agent 是一种控制用来保存公钥身份验证所使用的私钥的程序，ssh-agent 就是一个密钥管理器，运行 ssh-agent 以后，使用ssh-add 将私钥交给 ssh-agent 保管，其他程序需要身份验证的时候可以将验证申请交给 ssh-agent 来完成整个认证过程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># start the ssh-agent in the background</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(ssh-agent -s)</span>"</span></span><br></pre></td></tr></table></figure><p>执行完之后将会输出如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Agent pid 64345   #  64345 为agent 的进程号</span><br></pre></td></tr></table></figure><p>添加生成的 SSH key 到 ssh-agent：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><h2 id="登陆-Github，-添加-ssh"><a href="#登陆-Github，-添加-ssh" class="headerlink" title="登陆 Github， 添加 ssh"></a>登陆 Github， 添加 ssh</h2><p><a href="https://github.com/settings/keys" target="_blank" rel="noopener">https://github.com/settings/keys</a> 添加 SSH key，把 id_rsa.pub 文件里的内容复制到这里即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;配置使用 ssh 方式来提交和克隆代码大概可以分为以下几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置 Git 的 user name 和 email：(如果是第一次的话)&lt;/li&gt;
&lt;li&gt;检查是否已经有 SSH Key。&lt;/li&gt;
&lt;li&gt;生成密钥&lt;/li&gt;
&lt;li&gt;添加密钥
      
    
    </summary>
    
      <category term="git" scheme="http://www.glmapper.com/categories/git/"/>
    
    
      <category term="git" scheme="http://www.glmapper.com/tags/git/"/>
    
      <category term="工具" scheme="http://www.glmapper.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 源码系列-Bean 的生命周期与扩展</title>
    <link href="http://www.glmapper.com/2019/12/14/springboot-series-bean-life/"/>
    <id>http://www.glmapper.com/2019/12/14/springboot-series-bean-life/</id>
    <published>2019-12-14T03:24:14.000Z</published>
    <updated>2020-04-05T11:42:45.865Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇基于 SpringBoot 2.2.2.RELEASE 版本，Spring  各个版本之间多少存在一些差异，不过主流程基本相同；大家在阅读过程中需关注这点。</p></blockquote><p>继续承接上一篇 <a href="http://www.glmapper.com/2019/12/07/springboot-series-started/">SpringBoot 系列-启动过程分析</a>，本篇围绕一个 bean 的生命周期，对 bean 进行一些修改和扩展。本篇将涉及到以下主要内容：</p><ul><li><a href="">阅读之前</a></li><li><a href="">BeanDefinition 解析时机和过程</a><ul><li><a href="">invokeBeanFactoryPostProcessors 执行过程分析</a></li><li><a href="">invokeBeanDefinitionRegistryPostProcessors 执行过程分析</a></li></ul></li><li><a href="">BeanFactoryPostProcessor 对 BeanDefinition 的修改</a><ul><li><a href="">案例工程中 BeanFactoryPostProcessor 的实现</a></li></ul></li><li><a href="">通过监听 ApplicationEnvironmentPreparedEvent 事件修改属性值</a></li><li><a href="">@Value 注入 &amp; @Autowired 注入</a><ul><li><a href="">Bean 属性注入发生的时机</a></li><li><a href="">Bean 属性注入发生的过程</a></li></ul></li><li><a href="">Bean 的实例化过程</a><ul><li><a href="">BeanPostProcessor 的处理时机</a></li><li><a href="">使用 BeanPostProcessor 修改 Bean</a></li><li><a href="">使用 InitializingBean</a></li><li><a href="">指定 Bean 的 init-method 方法</a></li></ul></li><li><a href="">总结</a><ul><li><a href="">BeanFactoryPostProcessor 对于 init-method 的影响</a></li><li><a href="">附：案例工程地址及参考</a></li></ul></li></ul><h2 id="阅读之前"><a href="#阅读之前" class="headerlink" title="阅读之前"></a>阅读之前</h2><p>下面是本篇文章的“主人公” TestBeanService ，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBeanService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 依赖注入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> InjectBeanService injectBeanService;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 属性注入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.application.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> injectBeanService.testInject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TestBeanService 里面包括两个属性，一个是 injectBeanService ，另外一个是 appName，分别通过 @Autowired 和 @Value 注入值。本篇最终希望完成的目标是能够完成了解 Bean 属性注入的过程，以及 Bean 的实例化过程；除此之外，从 Spring 扩展的角度，来对 BeanFactoryPostProcess、BeanPostProcess、ApplicationListener、InitializingBean 以及 initMethod 的执行时机和作用进行分析。</p><h2 id="TestBeanService-被解析成-BeanDifinition-的时机与过程"><a href="#TestBeanService-被解析成-BeanDifinition-的时机与过程" class="headerlink" title="TestBeanService 被解析成 BeanDifinition 的时机与过程"></a>TestBeanService 被解析成 BeanDifinition 的时机与过程</h2><blockquote><p>Spring 容器刷新流程非常复杂，当我们想 debug BeanDifinition 加载过程时可能没法很快找到入口，这里可以直接面向 BeanDifinition 的最终去向来 debug。我们知道 BeanFactory 接口本身是不具体注册 BeanDifinition 能力的，这个能力是由 BeanDefinitionRegistry 接口提供。那么就看下 BeanDefinitionRegistry 的 registerBeanDefinition 方法有几个具体的实现，然后在这几个实现出打上断点，执行找到具体的处理入口。</p></blockquote><p>我们将断点打在 DefaultListableBeanFactory#registerBeanDefinition 这个方法入口处，debug 模式运行工程，可以看到断点进入时的情况如下图所示：</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/beanlife/life-one.jpg" alt=""></p><p>这里通过执行堆栈逆向找到 BeanDifinition 的加载入口是容器刷新阶段的 invokeBeanFactoryPostProcessors 方法；这里就详细分析下 testBeanService 这个 beandifition 是怎么被注册到容器中的。</p><h3 id="invokeBeanFactoryPostProcessors-执行过程分析"><a href="#invokeBeanFactoryPostProcessors-执行过程分析" class="headerlink" title="invokeBeanFactoryPostProcessors 执行过程分析"></a>invokeBeanFactoryPostProcessors 执行过程分析</h3><p>invokeBeanFactoryPostProcessors 这个方法实现非常长，但是基本处理过程很简单，存在很多重复的步骤。为了方便理解整个过程，这里还是有必要贴一下代码，代码中会详细标注所做的事情是什么，这个过程是构建 BeanFactory 非常重要一步。掌握这个过程，就可以随意玩转 BeanFactoryPostProcessor 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">    Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 当前 beanFactory 是否是 BeanDefinitionRegistry 类型</span></span><br><span class="line">    <span class="comment">// 只有是 BeanDefinitionRegistry 类型，才具备注册 beanDefinition 的能力</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">        BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">        <span class="comment">// 普通的 BeanFactoryPostProcessor 集合</span></span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// BeanDefinitionRegistryPostProcessor 类型处理器集合</span></span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 这里 beanFactoryPostProcessors 是在 SharedMetadataReaderFactoryContextInitializer 中加进来的，是 Spring 自己的处理器</span></span><br><span class="line">        <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">            <span class="comment">// 如果是 BeanDefinitionRegistryPostProcessor 类型，就加到 registryProcessors</span></span><br><span class="line">            <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">                BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">                        (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">                <span class="comment">// 执行 BeanDefinitionRegistryPostProcessor 后置处理</span></span><br><span class="line">                registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">                registryProcessors.add(registryProcessor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则就放到 regularPostProcessors</span></span><br><span class="line">                regularPostProcessors.add(postProcessor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不要在这里初始化 FactoryBeans：需要保留所有未初始化的常规bean，以使 beanFacotryPostProcessor 对其处理！</span></span><br><span class="line">        <span class="comment">// 分离实现 PriorityOrdered，Ordered和其余优先级的 BeanDefinitionRegistryPostProcessor。</span></span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先，调用实现 PriorityOrdered 的 BeanDefinitionRegistryPostProcessors。</span></span><br><span class="line">        String[] postProcessorNames =</span><br><span class="line">                beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 遍历 BeanDefinitionRegistryPostProcessors</span></span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="comment">// 只处理实现 PriorityOrdered 接口的 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">            <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                <span class="comment">// 符合上述条件的 BeanDefinitionRegistryPostProcessor 放到 currentRegistryProcessors 中，供后面使用</span></span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                <span class="comment">// 标记当前 postProcessor 已经处理过了</span></span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        <span class="comment">// 调用 BeanDefinitionRegistryPostProcessor 后置处理器</span></span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接下来，调用实现 Ordered的BeanDefinitionRegistryPostProcessors</span></span><br><span class="line">        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后，调用所有其他 BeanDefinitionRegistryPostProcessor，直到不再出现（保证全部处理完）。</span></span><br><span class="line">        <span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">            reiterate = <span class="keyword">false</span>;</span><br><span class="line">            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                    processedBeans.add(ppName);</span><br><span class="line">                    reiterate = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">            registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">            currentRegistryProcessors.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在，调用到目前为止已处理的所有处理器的 postProcessBeanFactory 回调。</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">        invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用在上下文实例中注册的工厂处理器。就是前面提到的 SharedMetadataReaderFactoryContextInitializer 中注册的</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里再次拿到所有的 BeanFactoryPostProcessor</span></span><br><span class="line">    String[] postProcessorNames =</span><br><span class="line">            beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同样将实现 PriorityOrdered、Order 和普通的 BeanFactoryPostProcessor 分离开</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">            <span class="comment">// 跳过-已在上述第一阶段处理过</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">            orderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先，调用实现PriorityOrdered的BeanFactoryPostProcessors。</span></span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    <span class="comment">// 优先执行实现 PriorityOrdered 接口的 BeanFactoryPostProcessor</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来，调用实现Ordered的BeanFactoryPostProcessors。</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    <span class="comment">// 执行实现 Ordered 接口的 BeanFactoryPostProcessor</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后，调用所有其他 BeanFactoryPostProcessor</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行其他没有实现任何优先级接口的 BeanFactoryPostProcessor</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line">    <span class="comment">// 清除缓存的合并 beanDefinition，因为后处理器可能已经修改了原始元数据</span></span><br><span class="line">    beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码段中大体就是，先处理 BeanDefinitionRegistryPostProcessor 类型的 BeanFactoryPostProcessor ，然后再处理普通的 BeanFactoryPostProcessor；在这里处理过程中，会根据一些排序规则来调整各个 BeanFactoryPostProcessor 的执行顺序。</p><p>这里先处理 BeanDefinitionRegistryPostProcessor 类型的 BeanFactoryPostProcessor 是一定的，因为需要在这个阶段去注册 BeanDefinition。在 classpath 下的所有 BeanDefinition 都被注册之后，再执行普通 BeanFactoryPostProcessor 的后置回调，这样就可以覆盖所有的 BeanDefinition。</p><h3 id="invokeBeanDefinitionRegistryPostProcessors-执行过程分析"><a href="#invokeBeanDefinitionRegistryPostProcessors-执行过程分析" class="headerlink" title="invokeBeanDefinitionRegistryPostProcessors 执行过程分析"></a>invokeBeanDefinitionRegistryPostProcessors 执行过程分析</h3><p>在第一次调用 invokeBeanDefinitionRegistryPostProcessors 时，当前的 BeanDefinitionRegistryPostProcessor 只有一个，就是 org.springframework.context.annotation.ConfigurationClassPostProcessor 。</p><blockquote><p>在 ConfigurationClassPostProcessor 类中，会解析 @Configuration、@ComponentScan、@ComponentScans、@Import 等注解。ConfigurationClassPostProcessor 实现了 BeanDefinitionRegistryPostProcessor 接口，而 BeanDefinitionRegistryPostProcessor 接口继承了 BeanFactoryPostProcessor 接口，所以 ConfigurationClassPostProcessor 中需要重写 postProcessBeanDefinitionRegistry() 方法和 postProcessBeanFactory() 方法。而 ConfigurationClassPostProcessor 类的作用就是通过这两个方法去实现的。更多细节可以参考 <a href="https://blog.csdn.net/qq_34436819/article/details/100944204" target="_blank" rel="noopener">ConfigurationClassPostProcessor源码解析</a> 这篇文章，写的非常 nice。</p></blockquote><p>invokeBeanDefinitionRegistryPostProcessors 处理的核心过程如下：</p><ul><li>1、ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry：BeanDefinition 触发加载的入口</li><li>2、ConfigurationClassPostProcessor#processConfigBeanDefinitions：解析配置类，在此处会解析配置类上的注解(ComponentScan扫描出的类，@Import注册的类，以及@Bean方法定义的类)</li><li>3、ComponentScanAnnotationParser#parse：根据注解的属性值来过滤加载 classpath 下的 beanDefinition（默认条件就是 basePackages，默认的 basePackages 为当前启动类的根包）</li><li>4、ClassPathBeanDefinitionScanner#doScan：处理 basePackages 下所以的 beanDefinition，被打了 @Service、@Compoment 等注解的类都会被解析到</li><li>5、DefaultListableBeanFactory#registerBeanDefinition：将 beanDefinition 注册到 BeanFactory 中（beanDefinitionMap 中）</li></ul><p>那么到这里 TestBeanService 的 BeanDefinition 就被注册到 BeanFactory 中了。</p><h2 id="BeanFactoryPostProcessor-对-BeanDefinition-的修改"><a href="#BeanFactoryPostProcessor-对-BeanDefinition-的修改" class="headerlink" title="BeanFactoryPostProcessor 对 BeanDefinition 的修改"></a>BeanFactoryPostProcessor 对 BeanDefinition 的修改</h2><p>在本篇文章所对应的案例工程中，也实现了一个 BeanFactoryPostProcessor ，没有实现任何排序接口。这个 TestBeanServiceBeanFactoryPostProcessor 的作用是将原来的 TestBeanService 修改为 ProxyTestBeanService。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBeanServiceBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 根据类型拿到所有的 beanNames</span></span><br><span class="line">        Iterable&lt;String&gt; beanNames = getBeanNames(beanFactory, TestBeanService.class);</span><br><span class="line">        <span class="comment">// 这里因为只有一个 TestBeanService ，所以只处理第一个</span></span><br><span class="line">        beanNames.forEach(beanName -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"begin to execute BeanFactoryPostProcessor..."</span>);</span><br><span class="line">            BeanDefinitionRegistry beanDefinitionRegistry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">            <span class="comment">// 先从工程中拿到原始 beanDefinition</span></span><br><span class="line">            BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">            <span class="comment">// 这里构建一个新的 BeanDefinition，类型为 ProxyTestBeanService，ProxyTestBeanService 是 TestBeanService 的子类</span></span><br><span class="line">            RootBeanDefinition proxy = <span class="keyword">new</span> RootBeanDefinition(ProxyTestBeanService.class);</span><br><span class="line">            <span class="comment">// 这里设置指定的initMethod</span></span><br><span class="line">            proxy.setInitMethodName(beanDefinition.getInitMethodName());</span><br><span class="line">            <span class="comment">// 设置一些属性</span></span><br><span class="line">            proxy.setPropertyValues(beanDefinition.getPropertyValues());</span><br><span class="line">            proxy.setPrimary(beanDefinition.isPrimary());</span><br><span class="line">            proxy.setRole(BeanDefinition.ROLE_APPLICATION);</span><br><span class="line">            <span class="comment">// 将原始 beanDefinition 移除掉</span></span><br><span class="line">            beanDefinitionRegistry.removeBeanDefinition(beanName);</span><br><span class="line">            <span class="comment">// 将代理的新的 beanDefinition 注册进去</span></span><br><span class="line">            beanDefinitionRegistry.registerBeanDefinition(beanName,proxy);</span><br><span class="line">            System.out.println(<span class="string">"current bean type is : "</span> + proxy.getBeanClass().getTypeName());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <a href="">invokeBeanFactoryPostProcessors 执行过程分析</a>中已经分析了 BeanFactoryPostProcessor 执行的时机和过程，这里不再赘述。TestBeanServiceBeanFactoryPostProcessor 的作用就是先将原始的 TestBeanService 的 Beandefinition 从容器中移除掉，然后构建一个 ProxyTestBeanService 的 Beandefinition，然后注册到容器中，beanName 没有变，所以通过 BeanFactoryPostProcessor 可以修改最原始的 Bean 信息，也可以通过 BeanFactoryPostProcessor 来动态注册一个新的 Bean。</p><h2 id="通过监听-ApplicationEnvironmentPreparedEvent-事件修改属性值"><a href="#通过监听-ApplicationEnvironmentPreparedEvent-事件修改属性值" class="headerlink" title="通过监听 ApplicationEnvironmentPreparedEvent 事件修改属性值"></a>通过监听 ApplicationEnvironmentPreparedEvent 事件修改属性值</h2><p>上面完成了对 TestBeanService 的 BeanDefinition 的修改，将 TestBeanService 对象换成了 ProxyTestBeanService。前面提到 TestBeanService 中有两个需要注入的值，一个是通过 @Autowired 注入，一个是通过 @Value 注入，先来看 @Value 注入。@Value 注入的值来自 Enviroment，这里关于 Enviroment 和配置解析及构建不多说，本篇中关注的是如何将 @Value 注入的值改变掉。</p><p>ApplicationEnvironmentPreparedEvent 事件是在环境准备完成时发送的事件，此时 Enviroment 已经准备好，可以随时为容器刷新提供环境变量支持。那么既然此时容器中的 Enviroment 对象已经 ready ，说明配置的 application.properties、系统参数等均已经被解析好了，而此时目标 Bean 还没有被刷新，其内部需要被注入的属性值还没有被注入，那么此时就可以通过监听这个事件，来对 Enviroment 中已经准备好的值进行修改，以改变实际被注入的值。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeAppNameListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEnvironmentPreparedEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEnvironmentPreparedEvent event)</span> </span>&#123;</span><br><span class="line">        ConfigurableEnvironment environment = event.getEnvironment();</span><br><span class="line">        <span class="comment">// 获取原始 spring.application.name 的值</span></span><br><span class="line">        String applicationName = environment.getProperty(<span class="string">"spring.application.name"</span>);</span><br><span class="line">        System.out.println(<span class="string">"origin applicationName is : "</span> + applicationName);</span><br><span class="line">        <span class="comment">// 修改 spring.application.name</span></span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">"spring.application.name"</span>, <span class="string">"updateAppName"</span>);</span><br><span class="line">        environment.getPropertySources().addFirst(<span class="keyword">new</span> PropertiesPropertySource(<span class="string">"decrypted_properties"</span>, props));</span><br><span class="line"></span><br><span class="line">        applicationName = environment.getProperty(<span class="string">"spring.application.name"</span>);</span><br><span class="line">        System.out.println(<span class="string">"updated applicationName is : "</span> + applicationName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Value-注入-amp-Autowired-注入"><a href="#Value-注入-amp-Autowired-注入" class="headerlink" title="@Value 注入 &amp; @Autowired 注入"></a>@Value 注入 &amp; @Autowired 注入</h2><p>在 Spring 中，无论是 @Value 注入还是 @Autowired 注入，都是由 AutowiredAnnotationBeanPostProcessor 这个后置处理器处理的。</p><blockquote><p>在很多开源的框架中，其内部自定义的注解也大都是通过 BeanPostProcessor 这个后置处理器来处理的。</p></blockquote><p>AutowiredAnnotationBeanPostProcessor 中有个 AutowiredFieldElement 内部类，这个内部类的作用就是注入目标 bean 的属性值的。这里就包括 @Value 的注入和 @Autowired 注入。</p><h3 id="Bean-属性注入发生的时机"><a href="#Bean-属性注入发生的时机" class="headerlink" title="Bean 属性注入发生的时机"></a>Bean 属性注入发生的时机</h3><p>容器刷新及属性注入调用堆栈如下：</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/beanlife/life-two.jpg" alt=""></p><p>从堆栈看出，在容器刷新的最后阶段，会通过 finishBeanFactoryInitialization 这个方法实例化所有剩余的（非延迟初始化）单例 bean；这个过程就是绝大多数 bean 实例化的过程。这个过程中会涉及到以下两个比较重要的点：1、BeanPostProcessor 处理，2、依赖注入。从上面其实也可以看出，依赖注入的发生就是通过 BeanPostProcessor 处理完成的。下图为遍历所有目标属性，依次注入属性的过程：</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/beanlife/life-three.jpg" alt=""></p><h3 id="Bean-属性注入发生的过程"><a href="#Bean-属性注入发生的过程" class="headerlink" title="Bean 属性注入发生的过程"></a>Bean 属性注入发生的过程</h3><p>这里以 @Autowired 注入为例，@Value 注入和 @Autowired 注入过程基本是一样的。@Autowired 注入相比于 @Value 注入，会涉及到初始化另外一个 Bean 的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建一个依赖描述符对象</span></span><br><span class="line">DependencyDescriptor desc = <span class="keyword">new</span> DependencyDescriptor(field, <span class="keyword">this</span>.required);</span><br><span class="line"><span class="comment">// 设置包含此依赖项的具体类</span></span><br><span class="line">desc.setContainingClass(bean.getClass());</span><br><span class="line"><span class="comment">// 初始化一个注入的 beanName 集合，用于后面注册到容器中</span></span><br><span class="line"><span class="comment">// 这里实际上只有一个，如果有多个实例 bean 存在，则需要通过 Qualifier 指定了</span></span><br><span class="line">Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">Assert.state(beanFactory != <span class="keyword">null</span>, <span class="string">"No BeanFactory available"</span>);</span><br><span class="line">TypeConverter typeConverter = beanFactory.getTypeConverter();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 解析依赖，依赖注入</span></span><br><span class="line">    value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">    <span class="comment">// 抛出注入失败异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedDependencyException(<span class="keyword">null</span>, beanName, <span class="keyword">new</span> InjectionPoint(field), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.cached) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span> || <span class="keyword">this</span>.required) &#123;</span><br><span class="line">            <span class="keyword">this</span>.cachedFieldValue = desc;</span><br><span class="line">            <span class="comment">// 注册依赖的 bean</span></span><br><span class="line">            registerDependentBeans(beanName, autowiredBeanNames);</span><br><span class="line">            <span class="keyword">if</span> (autowiredBeanNames.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                String autowiredBeanName = autowiredBeanNames.iterator().next();</span><br><span class="line">                <span class="comment">// 判断容器中是否存在此依赖 bean,并且校验 bean 的类型是否匹配</span></span><br><span class="line">                <span class="keyword">if</span> (beanFactory.containsBean(autowiredBeanName) &amp;&amp;</span><br><span class="line">                        beanFactory.isTypeMatch(autowiredBeanName, field.getType())) &#123;</span><br><span class="line">                    <span class="comment">// 缓存注入值</span></span><br><span class="line">                    <span class="keyword">this</span>.cachedFieldValue = <span class="keyword">new</span> ShortcutDependencyDescriptor(</span><br><span class="line">                            desc, autowiredBeanName, field.getType());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有找到 依赖bean 实例，且 required 为 false </span></span><br><span class="line">            <span class="keyword">this</span>.cachedFieldValue = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.cached = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// value 为解析到的属性值，如果不为空，则通过反射设置给目标 Bean，完成属性的注入</span></span><br><span class="line"><span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ReflectionUtils.makeAccessible(field);</span><br><span class="line">    field.set(bean, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性注入发生在 populateBean（填充 Bean）的过程，在 Bean 属性填充完成之后就是 Bean 的实例化过程。</p><h2 id="Bean-的实例化过程"><a href="#Bean-的实例化过程" class="headerlink" title="Bean 的实例化过程"></a>Bean 的实例化过程</h2><p>这里截取 AbstractAutowireCapableBeanFactory#doCreateBean 方法中的一小段代码，来承接上下文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化bean实例。</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 填充 Bean</span></span><br><span class="line">    populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">    <span class="comment">// 实例化 Bean</span></span><br><span class="line">    exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">// 省略异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过代码就很好的和上一小节的内容关联起来了，即填充 Bean -&gt; 实例化 Bean 。在 Bean 的实例化阶段会涉及到两个比较重要的扩展：1、BeanPostProcessor，2、InitializingBean。</p><h3 id="BeanPostProcessor-的处理时机"><a href="#BeanPostProcessor-的处理时机" class="headerlink" title="BeanPostProcessor 的处理时机"></a>BeanPostProcessor 的处理时机</h3><p>BeanPostProcessor 有两个抽象方法，一个是实例化之前调用，一个是实例化之后调用。InitializingBean 接口只有一个 afterPropertiesSet 方法，afterPropertiesSet 方法的执行介于实例化之前实例化之后调用之间。BeanPostProcessor 的处理时机是在调用 initializeBean 方法中触发的，下面为 initializeBean 方法中的部分代码片段： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Object wrappedBean = bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">    <span class="comment">// 实例化之前调用</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 InitializingBean 和指定的 init-method 方法</span></span><br><span class="line">    invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">            beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">    <span class="comment">// 实例化之后调用</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的 bean 对象实际上已经是完整的 bean 了，postProcessBeforeInitialization 和 postProcessAfterInitialization 是相对于是否执行 InitializingBean 的 afterPropertiesSet 和执行 Bean 指定的 initMethod 方法而言的。</p></blockquote><h3 id="使用-BeanPostProcessor-修改-Bean"><a href="#使用-BeanPostProcessor-修改-Bean" class="headerlink" title="使用 BeanPostProcessor 修改 Bean"></a>使用 BeanPostProcessor 修改 Bean</h3><p>从 initializeBean 方法中可以看出，了，postProcessBeforeInitialization 和 postProcessAfterInitialization 两处回调返回放回的是 wrappedBean，也就意味着我们可以在这两个方法中对容器中的原始 Bean 做一些处理，比如代理一层原始的 Bean，或者修改 Bean 中的一些属性等。</p><p>在案例工程中提供了一个 TestBeanServiceProcessor ，其作用是对 TestBeanService 类型的 Bean 做一层代理，使得在执行 TestBeanService 中方法的前后做一些埋点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TestBeanServiceProcessor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBeanServiceProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 bean 的类型是 TestBeanService，则将其包装成 TestBeanWrapperService 并返回</span></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> TestBeanService)&#123;</span><br><span class="line">            System.out.println(<span class="string">"begin to execute postProcessBeforeInitialization."</span>);</span><br><span class="line">            TestBeanWrapperService testBeanService = <span class="keyword">new</span> TestBeanWrapperService((TestBeanService)bean);</span><br><span class="line">            <span class="keyword">return</span> testBeanService;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> TestBeanService)&#123;</span><br><span class="line">            System.out.println(<span class="string">"begin to execute postProcessAfterInitialization."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理类 TestBeanWrapperService，注意这里代理类也应该是 TestBeanService 类型，否在是后面使用时就会找不到 Bean 实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBeanWrapperService</span> <span class="keyword">extends</span> <span class="title">TestBeanService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TestBeanService delegate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestBeanWrapperService</span><span class="params">(TestBeanService delegate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现对 test 方法执行前后进行拦截</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            before();</span><br><span class="line">            <span class="keyword">return</span> delegate.test();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            after();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before execute test."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after execute test."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-InitializingBean"><a href="#使用-InitializingBean" class="headerlink" title="使用 InitializingBean"></a>使用 InitializingBean</h3><p>如果一个 bean 集成了 InitializingBean 接口，那么就需要重写其 afterPropertiesSet 方法。这里感觉有点漏洞，afterPropertiesSet 动作其实早就完成了，另外因为 afterPropertiesSet  是在 postProcessAfterInitialization 方法之前调用，所以还是可以在 postProcessAfterInitialization 对属性做修改。实际使用过程中需要关注下这个点，一般情况下，我们会在 afterPropertiesSet 中做一些初始化动作，比如启动连接 Zookeeper。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBeanService</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"begin to execute afterPropertiesSet..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指定-Bean-的-init-method-方法"><a href="#指定-Bean-的-init-method-方法" class="headerlink" title="指定 Bean 的 init-method 方法"></a>指定 Bean 的 init-method 方法</h3><p>init-method 方法只能通过 @Bean 或者 xml 方式指定，如果是使用 @Component 或者 @Service 注解标准的 Bean ，则可以通过 @PostConstruct 注解标注方法，对应的是 destroy-method 和 @PreDestroy 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBeanService</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span></span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// init 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"begin to execute init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在自动配置类或者 xml 文件中指定 initMethod</span></span><br><span class="line"><span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> TestBeanService <span class="title">testBeanService</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TestBeanService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇围绕 TestBeanService 这个 Bean 展开，对其生命周期，及其生命周期各个阶段扩展点进行了介绍，包括修改注入的属性值、修改其 BeanDefinition、修改 Bean 实例等等，从扩展点的视角来洞悉一个 Bean 的生命周期。</p><h3 id="BeanFactoryPostProcessor-对于-init-method-的影响"><a href="#BeanFactoryPostProcessor-对于-init-method-的影响" class="headerlink" title="BeanFactoryPostProcessor 对于 init-method 的影响"></a>BeanFactoryPostProcessor 对于 init-method 的影响</h3><p>因为 init-method 这个点是后面想起来加上去的，在实际测试过程中，发现 TestBeanService 中指定的 init 方法没有被执行（正常情况下是在 afterPropertiesSet 之后就会执行的）；对于这个 TestBeanService 在案例工程中有两处对其进行了修改，一个是修改其 BeanDefinition ，一个是修改 其 Bean 实例；最终拿到的 bean 的类型是 TestBeanWrapperService，在此之前 Bean 的类型是 ProxyTestBeanService ，无论是TestBeanWrapperService 还是 ProxyTestBeanService 都是 TestBeanService 的子类，init 方法又是 public 的，所以从这个角度来看，不可能不生效。所以基本可以排除因为访问权限问题导致。最后 debug 下面代码发现，mbd.getInitMethodName() 返回的是 null， mbd 是 RootBeanDefinition；</p><blockquote><p>PS: BeanDefinition 中 getInitMethodName 方法是在 Spring 5.1 版本之后才有的，之前版本都是 在 AbstractBeanDefinition 这个抽象类中定义。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; bean.getClass() != NullBean.class) &#123;</span><br><span class="line">    <span class="comment">// 从当前 bean  的 BeanDefinition 对象中获取 initMethod 方法名</span></span><br><span class="line">    String initMethodName = mbd.getInitMethodName();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;</span><br><span class="line">            !(isInitializingBean &amp;&amp; <span class="string">"afterPropertiesSet"</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">            !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">        invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题出在这里，在 TestBeanServiceBeanFactoryPostProcessor 处理时，没有将原始 BeanDefinition 的 initMethod 给新的 ProxyTestBeanService，所以导致后面所有基于此实例化的 bean 的 BeanDefinition 都没有 initMethod 方法。在TestBeanServiceBeanFactoryPostProcessor#postProcessBeanFactory 方法中补充设置 InitMethodName 之后问题解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里设置指定的initMethod</span></span><br><span class="line">proxy.setInitMethodName(beanDefinition.getInitMethodName());</span><br></pre></td></tr></table></figure><h3 id="附：案例工程地址及参考"><a href="#附：案例工程地址及参考" class="headerlink" title="附：案例工程地址及参考"></a>附：案例工程地址及参考</h3><ul><li>工程地址：<a href="https://github.com/glmapper/glmapper-blog-samples/tree/master/glmapper-blog-bean-lifecycle" target="_blank" rel="noopener">glmapper-blog-bean-lifecycle</a></li><li>参考文档：<a href="https://blog.csdn.net/qq_34436819/article/details/100944204" target="_blank" rel="noopener">ConfigurationClassPostProcessor源码解析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本篇基于 SpringBoot 2.2.2.RELEASE 版本，Spring  各个版本之间多少存在一些差异，不过主流程基本相同；大家在阅读过程中需关注这点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;继续承接上一篇 &lt;a href=&quot;http:
      
    
    </summary>
    
      <category term="springboot" scheme="http://www.glmapper.com/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://www.glmapper.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 源码系列-日志详解</title>
    <link href="http://www.glmapper.com/2019/12/14/springboot-series-log/"/>
    <id>http://www.glmapper.com/2019/12/14/springboot-series-log/</id>
    <published>2019-12-14T03:17:40.000Z</published>
    <updated>2020-04-05T11:44:00.535Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot 使用 Commons Logging 进行所有内部日志记录，但保留底层日志实现。为 Java Util Logging、Log4J2 和 Logback 提供了默认配置。在每种情况下，loggers 都预先配置为使用 console 输出，并且也提供可选的文件输出。</p><p>默认情况下，如果使用 “starters”，则使用 Logback 进行日志记录。还包括适当的 Logback 路由，以确保使用 Java Util 日志记录、Commons 日志记录、Log4J 或 SLF4J 的依赖库都能正常工作。</p><p>下面先来看一个最简单的 SpringBoot demo 工程的日志输出，以此来展开日志格式、控制台输出、日志颜色、日志文件配置、日志体系解析等几个方面的介绍。</p><p>新建一个 SpringBoot 工程，默认在什么都不加的情况下直接启动，其启动日志大概如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2019-12-24 20:41:31.866  INFO 87851 --- [           main] com.glmapper.bridge.boot.BootStrap       : No active profile set, falling back to default profiles: default</span><br><span class="line">2019-12-24 20:41:32.003  INFO 87851 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@314c508a: startup date [Tue Dec 24 20:41:31 CST 2019]; root of context hierarchy</span><br><span class="line">2019-12-24 20:41:32.556  INFO 87851 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup</span><br><span class="line">2019-12-24 20:41:32.568  INFO 87851 --- [           main] com.glmapper.bridge.boot.BootStrap       : Started BootStrap in 1.035 seconds (JVM running for 2.13)</span><br><span class="line">2019-12-24 20:41:32.569  INFO 87851 --- [       Thread-4] s.c.a.AnnotationConfigApplicationContext : Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@314c508a: startup date [Tue Dec 24 20:41:31 CST 2019]; root of context hierarchy</span><br><span class="line">2019-12-24 20:41:32.571  INFO 87851 --- [       Thread-4] o.s.j.e.a.AnnotationMBeanExporter        : Unregistering JMX-exposed beans on shutdown</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h2><p>上面是 Spring Boot 的默认日志输出，从日志格式来看，主要包括以下几项：</p><ul><li>日期时间: 例如 2019-12-24 20:41:31.866 (毫秒精度)</li><li>日志级别: 例如 INFO (ERROR, WARN, INFO, DEBUG, or TRACE.)</li><li>当前进程: 例如 87851</li><li>— 分隔符，用于区分实际日志消息的开头。</li><li>线程名称: 例如 Thread-4 (用方括号括起来(为了控制台输出可能被截断)).</li><li>日志名称: 这通常是源类名(通常是缩写)。</li><li>日志信息: 具体的日志消息</li></ul><p>比如这条记录：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-12-24 20:41:31.866  INFO 87851 --- [           main] com.glmapper.bridge.boot.BootStrap       : No active profile set, falling back to default profiles: default</span><br></pre></td></tr></table></figure><p>是在 org.springframework.boot.SpringApplication#logStartupProfileInfo 方法中打印的，日志级别为 INFO。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/log-boot-print.jpg" alt=""></p><h2 id="Console-输出"><a href="#Console-输出" class="headerlink" title="Console 输出"></a>Console 输出</h2><p>SpringBoot 默认会将日志输出到 Console，默认情况下，会记录 error 级别、warn 级别和 info 级别的消息。还可以通过使用 <code>—-debug</code> 参数启动应用程序来使用 “debug” 级别。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar myapp.jar --debug</span><br></pre></td></tr></table></figure><blockquote><p>也可以在 application.properties 中指定 debug=true 来启用 debug 级别</p></blockquote><p>当启用 debug 级别时，将配置一系列核心日志记录器(嵌入式容器、Hibernate 和 Spring Boot) 以输出更多信息。启用 debug 模式并不会将应用程序配置为记录所有具有 debug 级别的消息。同样的，也可以使用 <code>—-trace</code> 标记来启动 trace 级别模式来启动应用程序。</p><h2 id="彩色编码输出"><a href="#彩色编码输出" class="headerlink" title="彩色编码输出"></a>彩色编码输出</h2><p>如果你的终端支持 ANSI，你可以通过设置 “spring.output.ansi.enable“ 配置项值来指定颜色（前提是官方已经支持的颜色）。颜色编码是通过使用 <code>%clr</code> 转换字来配置的，最简单的就是根据日志级别对输出的日志进行着色，如下面的示例所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%clr(%5p)</span><br></pre></td></tr></table></figure><p>下表是官方提供的描述日志级别到颜色的映射关系表:</p><table><thead><tr><th>Level</th><th>Color</th></tr></thead><tbody><tr><td>FATAL</td><td>Red</td></tr><tr><td>ERROR</td><td>Red</td></tr><tr><td>WARN</td><td>Yellow</td></tr><tr><td>INFO</td><td>Green</td></tr><tr><td>DEBUG</td><td>Green</td></tr><tr><td>TRACE</td><td>Green</td></tr></tbody></table><p>如果你想要使文本变成黄色，可以使用以下设置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;yellow&#125;</span><br></pre></td></tr></table></figure><p>目前支持的颜色和样式包括 : blue、cyan、faint、green、magenta、red、yellow。</p><h2 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h2><p>默认情况下，Spring 引导日志只输出到 Console，不会写入到日志文件中。如果希望在 Console 输出之外还写入到日志文件，则需要设置 logging.file 和 logging.path 属性(在 application.properties 中)。下表显示了 logging.* 属性如何一起使用:</p><table><thead><tr><th>logging.file</th><th>logging.path</th><th>Example</th><th>Description</th></tr></thead><tbody><tr><td>none</td><td>none</td><td></td><td>控制台日志</td></tr><tr><td>指定文件</td><td>none</td><td>my.log</td><td>写入指定的日志文件，名称可以是精确位置或相对于当前目录。</td></tr><tr><td>none</td><td>指定文件</td><td>/var/log</td><td>将 spring.log 写入指定的目录，名称可以是精确位置或相对于当前目录。</td></tr></tbody></table><p>日志文件在达到 10 MB 时会进行 Rolling，与 Console 输出一样，默认情况下会记录 ERROR 级别、WARN 级别和 INFO 级别的消息。可以使用 logging.file.max-size 属性更改大小限制。除非已设置 logging.file.max-history 属性，否则以前 Rolling 的文件将无限期归档。</p><blockquote><p>日志系统在应用程序生命周期的早期初始化。因此，在通过 @PropertySource 注释加载的属性文件中是找不到日志属性的。另外，logging 属性独立于实际的logging 基础结构。所以，Spring Boot 不会管理特定的配置密钥（例如 Logback 的 logback.configurationFile）。</p></blockquote><h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><p>SpringBoot 中所支持的日志系统都可以通过 <code>logging.level.&lt;logger-name&gt;=&lt;level&gt;</code> 在 Spring 环境中设置日志的级别(比如在application.properties 中)。日志级别主要包括 TRACE, DEBUG, INFO, WARN, ERROR, FATAL 和 OFF 几种。除此之外，还可以使用  <code>logging.level.root</code> 配置 root logger 的日志级别。下面的示例展示了如何在 application.properties 中配置日志级别:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logging.level.root=warn</span><br><span class="line">logging.level.org.springframework.web=debug</span><br><span class="line">logging.level.org.hibernate=error</span><br></pre></td></tr></table></figure><p>除了 application.properties 之外，也可以使用环境变量设置日志级别。例如，LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=DEBUG 将 org.springframework.web 包下的日志打印级别设置为 DEBUG。</p><blockquote><p>上面的方法只适用于包级别的日志记录。由于 <a href="https://docs.spring.io/spring-boot/docs/2.0.4.RELEASE/reference/htmlsingle/#boot-features-external-config-relaxed-binding" target="_blank" rel="noopener">Relaxed Binding</a> 总是将环境变量转换为小写形式，因此不可能以这种方式为单个类配置日志记录。如果需要为一个类配置日志记录，可以使用 <a href="https://docs.spring.io/spring-boot/docs/2.1.11.RELEASE/reference/html/boot-features-external-config.html#boot-features-external-config-application-json" target="_blank" rel="noopener">SPRING_APPLICATION_JSON</a> 变量。</p></blockquote><h2 id="日志-Groups"><a href="#日志-Groups" class="headerlink" title="日志 Groups"></a>日志 Groups</h2><p>将相关的 loggers 分组在一起通常很有用，这样就可以同时对它们进行配置，Spring Boot 允许在 Spring 环境中定义日志组。例如将 “tomcat” 组添加到 application.properties。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.group.tomcat=org.apache.catalina, org.apache.coyote, org.apache.tomcat</span><br></pre></td></tr></table></figure><p>这样，我们就可以通过一行配置来设置一组日志的日志级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.level.tomcat=TRACE</span><br></pre></td></tr></table></figure><p>Spring Boot 包含以下可以开箱即用的预定义日志组:</p><table><thead><tr><th>Name</th><th>Loggers</th></tr></thead><tbody><tr><td>web</td><td>org.springframework.core.codec, org.springframework.http, org.springframework.web, org.springframework.boot.actuate.endpoint.web, org.springframework.boot.web.servlet.ServletContextInitializerBeans</td></tr><tr><td>sql</td><td>org.springframework.jdbc.core, org.hibernate.SQL</td></tr></tbody></table><h2 id="自定义日志配置"><a href="#自定义日志配置" class="headerlink" title="自定义日志配置"></a>自定义日志配置</h2><p>可以通过在类路径中包含适当的库来激活各种日志系统，还可以通过在类路径的根目录中提供适当的配置文件或在 Spring 环境的 <code>logging.config</code> 属性指定的位置提供适当的配置文件来进一步定制日志系统。</p><p>比如可以使用 <code>org.springframework.boot.logging.LoggingSystem</code> 配置属性强制 Spring 引导使用指定的日志系统。该值应该是 LoggingSystem 实现的完全限定类名；如果配置为 none 的话，则表示完全禁用 Spring Boot 的日志配置。下表描述了 SpringBoot 中日志系统所对应的日志配置文件：</p><table><thead><tr><th>Logging System</th><th>Customization</th></tr></thead><tbody><tr><td>Logback</td><td>logback-spring.xml, logback-spring.groovy, logback.xml, or logback.groovy</td></tr><tr><td>Log4j2</td><td>org.springframework.jdbc.core, org.hibernate.SQL</td></tr><tr><td>JDK (Java Util Logging)</td><td>logging.properties</td></tr></tbody></table><blockquote><p>SpringBoot 官方建议在日志配置中使用 <code>-spring</code> 的配置方式(例如，使用 <code>logback-spring.xml</code> 而不是 <code>logback.xml</code>)。如果使用标准配置位置，Spring 无法完全控制日志初始化。</p></blockquote><blockquote><p>另外官方文档中有明确提到，JUL(ava Util Logging) 在 FATJAR 场景下存在一些已知的类加载问题，所以要尽量避免在 FATJAR 场景下使用 JUL。</p></blockquote><p>为了辅助对日志系统进行定制，Spring 会将环境变量属性设置成系统属性，如下表所示:</p><table><thead><tr><th>Spring Environment</th><th>System Property</th><th>Comments</th></tr></thead><tbody><tr><td>logging.exception-conversion-word</td><td>LOG_EXCEPTION_CONVERSION_WORD</td><td>记录异常时使用的 conversion word</td></tr><tr><td>logging.file</td><td>LOG_FILE</td><td>如果已定义，则在默认日志配置中使用。</td></tr><tr><td>logging.file.max-size</td><td>LOG_FILE_MAX_SIZE</td><td>最大日志文件大小(如果启用了LOG_FILE)。(只支持默认的Logback设置)</td></tr><tr><td>logging.file.max-history</td><td>LOG_FILE_MAX_HISTORY</td><td>要保留的归档日志文件的最大数量(如果启用了LOG_FILE)。(只支持默认的Logback设置。)</td></tr><tr><td>logging.path</td><td>LOG_PATH</td><td>如果已定义，则在默认日志配置中使用。</td></tr><tr><td>logging.pattern.console</td><td>CONSOLE_LOG_PATTERN</td><td>要在控制台(stdout)上使用的日志模式。(只支持默认的Logback设置。)</td></tr><tr><td>logging.pattern.dateformat</td><td>LOG_DATEFORMAT_PATTERN</td><td>日志日期格式的附加模式。(只支持默认的 Logback 设置。)</td></tr><tr><td>logging.pattern.file</td><td>FILE_LOG_PATTERN</td><td>最大日志文件大小(如果启用了LOG_FILE)。(只支持默认的Logback设置)</td></tr><tr><td>logging.pattern.level</td><td>LOG_LEVEL_PATTERN</td><td>呈现日志级别时使用的格式(默认%5p)。(只支持默认的Logback设置。)</td></tr><tr><td>PID</td><td>PID</td><td>当前进程ID</td></tr></tbody></table><p>所有支持的日志系统在解析配置文件时都可以参考系统属性进行配置解析。</p><blockquote><p>如果希望在日志属性中使用占位符，应该使用 SpringBoot 的语法，而不是底层框架的语法。需要注意的是，如果使用 Logback，应该使用<code>:</code>作为属性名及其默认值之间的分隔符，而不是使用<code>:-</code>。</p></blockquote><h2 id="springProfile-配置"><a href="#springProfile-配置" class="headerlink" title="springProfile 配置"></a>springProfile 配置</h2><p> <springprofile> 允许用户根据激活的 Spring profiles 选择包含或排除配置部分。profile 文件部分在 <configuration> 元素的任何地方都受支持。可以使用 name 属性指定哪个配置文件接受配置。<springprofile> 可以包含简单的 profile 文件名称(例如 dev )或 profile 文件表达式。profile 文件表达式允许一些比较复杂的 profile 文件逻辑，例如: “production &amp; (eu-central | eu-west)”。下面的显示了三个配置文件示例:</springprofile></configuration></springprofile></p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 激活 dev 环境的配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev | pre"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 激活 dev 和 pre 的环境变量 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"!prod"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 所有非 prod 环境的都激活 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="环境属性"><a href="#环境属性" class="headerlink" title="环境属性"></a>环境属性</h2><p> <springproperty> 标记允许用户传递 Spring Environment 中的属性，以便在 Logback 中使用。比如在 Logback 配置中访问 application.properties 文件中的值。<springproperty> 的作用机制与 Logback 的标准 <property> 标签类似。但是，不是指定直接 value，而是指定属性的 source（来自Environment）。如果需要将属性存储在 local 范围以外的其他位置，则可以使用 scope 属性来控制。如果需要默认值（如果未在 Environment 中设置该属性），则可以使用 defaultValue 属性配置。以下示例描述了如何传递在 Logback 中使用的属性：</property></springproperty></springproperty></p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">"context"</span> <span class="attr">name</span>=<span class="string">"fluentHost"</span> <span class="attr">source</span>=<span class="string">"myapp.fluentd.host"</span></span></span><br><span class="line"><span class="tag"><span class="attr">defaultValue</span>=<span class="string">"localhost"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FLUENT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.more.appenders.DataFluentAppender"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">remoteHost</span>&gt;</span>$&#123;fluentHost&#125;<span class="tag">&lt;/<span class="name">remoteHost</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前面基于 SpringBoot 官方文档对于 Logger 的支持描述做了简单的介绍，下面将通过分析源码来深入的掌握上述这些特性。本文以 log4j2 为例进行分析。</p><p>在 <a href="http://www.glmapper.com/2019/04/13/springboot-series-event/#SpringBoot-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%98%B6%E6%AE%B5">SpringBoot 系列-事件机制详解</a> 文章中其实有提到过 logging 初始化的时机。这里简单回顾下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">// 省略其他</span><br><span class="line">org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\</span><br><span class="line">org.springframework.boot.context.logging.LoggingApplicationListener,\</span><br></pre></td></tr></table></figure><p>这两个 logging 的监听器中，主要作用的是 LoggingApplicationListener ，这个监听器就是 SpringBoot 中日志初始化的入口。</p><h2 id="日志初始化入口"><a href="#日志初始化入口" class="headerlink" title="日志初始化入口"></a>日志初始化入口</h2><p>LoggingApplicationListener 继承了 GenericApplicationListener 这个接口，其父接口是 ApplicationListener，GenericApplicationListener 中扩展了对于事件类型的支持判断。这里主要关心的是 onApplicationEvent 这个回调方法，关于这个方法中所提到的几个事件类型，可以参考 <a href="http://www.glmapper.com/2019/04/13/springboot-series-event">SpringBoot 系列-事件机制详解</a> 这篇文章的介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ApplicationStartingEvent </span></span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationStartingEvent) &#123;</span><br><span class="line">        onApplicationStartingEvent((ApplicationStartingEvent) event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ApplicationEnvironmentPreparedEvent </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEnvironmentPreparedEvent) &#123;</span><br><span class="line">        onApplicationEnvironmentPreparedEvent((ApplicationEnvironmentPreparedEvent) event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ApplicationPreparedEvent</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationPreparedEvent) &#123;</span><br><span class="line">        onApplicationPreparedEvent((ApplicationPreparedEvent) event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ContextClosedEvent</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent</span><br><span class="line">            &amp;&amp; ((ContextClosedEvent) event).getApplicationContext().getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        onContextClosedEvent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ApplicationFailedEvent</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationFailedEvent) &#123;</span><br><span class="line">        onApplicationFailedEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ApplicationStartingEvent-阶段的处理"><a href="#ApplicationStartingEvent-阶段的处理" class="headerlink" title="ApplicationStartingEvent 阶段的处理"></a>ApplicationStartingEvent 阶段的处理</h3><p>在收到 ApplicationStartingEvent 事件时，SpringBoot 将通过当前应用的 classloader 来构建一个 loggingSystem 对象，然后执行初始化之前的一些准备工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onApplicationStartingEvent</span><span class="params">(ApplicationStartingEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过当前应用的 classloader 构建 loggingSystem 对象</span></span><br><span class="line">    <span class="keyword">this</span>.loggingSystem = LoggingSystem.get(event.getSpringApplication().getClassLoader());</span><br><span class="line">    <span class="comment">// loggingSystem 初始化之前准备</span></span><br><span class="line">    <span class="keyword">this</span>.loggingSystem.beforeInitialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以来看下 loggingSystem 是如何被构建出来的，这个过程可以使得我们非常清楚的了解到，为什么通过引入日志框架依赖或者使用 <code>org.springframework.boot.logging.LoggingSystem</code> 配置能够自动的完成日志框架的选择。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LoggingSystem <span class="title">get</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// SYSTEM_PROPERTY=org.springframework.boot.logging.LoggingSystem</span></span><br><span class="line">    <span class="comment">// 这里先从系统变量中获取下 org.springframework.boot.logging.LoggingSystem，看下是否用户自己指定了 LoggingSystem 的类型</span></span><br><span class="line">    String loggingSystem = System.getProperty(SYSTEM_PROPERTY);</span><br><span class="line">    <span class="comment">// 如果 org.springframework.boot.logging.LoggingSystem=xx 有配置值 </span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(loggingSystem)) &#123;</span><br><span class="line">        <span class="comment">// 是否配置的是 none</span></span><br><span class="line">        <span class="keyword">if</span> (NONE.equals(loggingSystem)) &#123;</span><br><span class="line">            <span class="comment">// 如果配置的是 none ，则返回 NoOpLoggingSystem</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NoOpLoggingSystem();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据指定的日志类型通过反射创建 loggingSystem 对象</span></span><br><span class="line">        <span class="keyword">return</span> get(classLoader, loggingSystem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SYSTEMS.entrySet().stream().filter((entry) -&gt; ClassUtils.isPresent(entry.getKey(), classLoader))</span><br><span class="line">            .map((entry) -&gt; get(classLoader, entry.getValue())).findFirst()</span><br><span class="line">            .orElseThrow(() -&gt; <span class="keyword">new</span> IllegalStateException(<span class="string">"No suitable logging system located"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的最后基于 SYSTEMS 一个 Map 结构的数据进行一系列的处理，主要就是通过判断 entry.getKey() 是否在当前 classpath 中存在，如果存在则通过反射构建类型为 entry.getValue() 的对象；SYSTEMS 是 LoggingSystem 抽象类中的一个静态的 MAP 结构变量，其初始化是在静态代码块中完成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; systems = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 添加 logback 的 LoggingSystem</span></span><br><span class="line">    systems.put(<span class="string">"ch.qos.logback.core.Appender"</span>, <span class="string">"org.springframework.boot.logging.logback.LogbackLoggingSystem"</span>);、</span><br><span class="line">     <span class="comment">// 添加 log4j2 的 LoggingSystem</span></span><br><span class="line">    systems.put(<span class="string">"org.apache.logging.log4j.core.impl.Log4jContextFactory"</span>,</span><br><span class="line">            <span class="string">"org.springframework.boot.logging.log4j2.Log4J2LoggingSystem"</span>);</span><br><span class="line">    <span class="comment">// 添加 JUL 的 LoggingSystem</span></span><br><span class="line">    systems.put(<span class="string">"java.util.logging.LogManager"</span>, <span class="string">"org.springframework.boot.logging.java.JavaLoggingSystem"</span>);</span><br><span class="line">    SYSTEMS = Collections.unmodifiableMap(systems);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看来就比较清晰，如果当前 classpath 中存在 logback、log4j2 或者 JUL 的依赖，则就构建对应的 LoggingSystem 对象。LoggingSystem 对象构建之后还会调用 beforeInitialize 方法，假设引入的是 log4j2 的依赖，则最后构建的 LoggingSystem 就是 Log4J2LoggingSystem 。beforeInitialize 是 LoggingSystem 提供的抽象方法，其具体实现是由子类实现。下面在源码分析部分会展开分析。</p><h3 id="ApplicationEnvironmentPreparedEvent-阶段的处理"><a href="#ApplicationEnvironmentPreparedEvent-阶段的处理" class="headerlink" title="ApplicationEnvironmentPreparedEvent 阶段的处理"></a>ApplicationEnvironmentPreparedEvent 阶段的处理</h3><p>接收到 ApplicationEnvironmentPreparedEvent 事件说明 Environment 对象已经构建完成，环境变量都已经初始化完成了。所以这里主要的工作就是初始化日志框架。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onApplicationEnvironmentPreparedEvent</span><span class="params">(ApplicationEnvironmentPreparedEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里会再 check 一次loggingSystem 是否已经被创建</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.loggingSystem == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.loggingSystem = LoggingSystem.get(event.getSpringApplication().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过环境和类路径表达的首选项初始化日志系统。</span></span><br><span class="line">    initialize(event.getEnvironment(), event.getSpringApplication().getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// initialize</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableEnvironment environment, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Spring 环境转移到系统属性</span></span><br><span class="line">    <span class="keyword">new</span> LoggingSystemProperties(environment).apply();</span><br><span class="line">    <span class="comment">// 解析得到 logFile，依赖 logging.file 和 loggin.path 两个配置值</span></span><br><span class="line">    <span class="keyword">this</span>.logFile = LogFile.get(environment);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//设置logging.file-&gt;LOG_FILE</span></span><br><span class="line">        <span class="comment">// loggin.path -&gt; LOG_PATH</span></span><br><span class="line">        <span class="keyword">this</span>.logFile.applyToSystemProperties();</span><br><span class="line">    &#125;</span><br><span class="line">    initializeEarlyLoggingLevel(environment);</span><br><span class="line">    <span class="comment">// 根据 log 的配置文件初始化 日志</span></span><br><span class="line">    initializeSystem(environment, <span class="keyword">this</span>.loggingSystem, <span class="keyword">this</span>.logFile);</span><br><span class="line">    <span class="comment">// 绑定 logging.group , 设置 logging.level</span></span><br><span class="line">    initializeFinalLoggingLevels(environment, <span class="keyword">this</span>.loggingSystem);</span><br><span class="line">    <span class="comment">// 注册 logging.register-shutdown-hook 配置的 钩子</span></span><br><span class="line">    registerShutdownHookIfNecessary(environment, <span class="keyword">this</span>.loggingSystem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个阶段就是根据我们配置的日志相关的属性和配置文件对日志进行一系列的初始化工作，这里所涉及到的属性和配置在文章前面部分均有提及到。</p><h3 id="ApplicationPreparedEvent-阶段的处理"><a href="#ApplicationPreparedEvent-阶段的处理" class="headerlink" title="ApplicationPreparedEvent 阶段的处理"></a>ApplicationPreparedEvent 阶段的处理</h3><p>接收到 ApplicationPreparedEvent 事件表示应用程序已经准备好，这里会注册两个 bean ， 一个是 springBootLoggingSystem，一个是 pringBootLogFile 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onApplicationPreparedEvent</span><span class="params">(ApplicationPreparedEvent event)</span> </span>&#123;</span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = event.getApplicationContext().getBeanFactory();</span><br><span class="line">    <span class="comment">// 注册 springBootLoggingSystem bean </span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsBean(LOGGING_SYSTEM_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(LOGGING_SYSTEM_BEAN_NAME, <span class="keyword">this</span>.loggingSystem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册 pringBootLogFile bean</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logFile != <span class="keyword">null</span> &amp;&amp; !beanFactory.containsBean(LOGFILE_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(LOGFILE_BEAN_NAME, <span class="keyword">this</span>.logFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ContextClosedEvent-和-ApplicationFailedEvent"><a href="#ContextClosedEvent-和-ApplicationFailedEvent" class="headerlink" title="ContextClosedEvent 和 ApplicationFailedEvent"></a>ContextClosedEvent 和 ApplicationFailedEvent</h3><p>ContextClosedEvent 事件是 Spring 容器关闭时发送的事件，这里主要就是在 Spring 容器关闭时对日志系统做的一些清理操作；ApplicationFailedEvent 是应用启动失败发送的事件，这里也会对日志系统做清理操作。清理方法由各个子 LoggingSystem 提供具体的实现，以 log4j2 为例，log4j2 的清理主要包括注销桥接处理器（前面初始化阶段有提到）、LogContext 置为null、移除 FILTER，基本上就是初始化阶段的逆过程。</p><h2 id="LoggingSystem-分析"><a href="#LoggingSystem-分析" class="headerlink" title="LoggingSystem 分析"></a>LoggingSystem 分析</h2><p>LoggingSystem 是 SpringBoot 对日志框架进行的一层抽象封装，LoggingSystem 使得我们可以很方便地使用一些日志框架，只需要定义对应日志框架的配置文件，比如 Logback、Log4j、Log4j2 等，代码内部便可以直接使用。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/logging-system.jpg" alt=""></p><p>上图为 LoggingSystem 的类继承结构，可以看到 LoggingSystem 的实现子类有 Logback（LogbackLoggingSystem）、Log4j2（Log4J2LoggingSystem）以及 JDK 内置的 Log (JavaLoggingSystem)。LoggingSystem 是个抽象类，内部有这几个方法：</p><ul><li>beforeInitialize：日志系统初始化之前需要处理的事情</li><li>initialize：初始化日志系统</li><li>cleanUp：日志系统的清除工作</li><li>getShutdownHandler：返回一个 Runnable 用于当 jvm 退出的时候处理日志系统关闭后需要进行的操作，默认返回 null</li><li>setLogLevel：设置 logger 的级别</li></ul><p>这几个方法在上面分析启动入口和日志初始化时都有看到，上述几个方法在 LoggingSystem 要么是抽象方法，要么是空实现，均需要有具体的子类来完成的具体日志框架的处理。从类继承结构图看到有一个 AbstractLoggingSystem，日志实现子类都是继承自这个类，而这个类也是一个抽象类，它又是 LoggingSystem 的子类。所以下面就分别看下 AbstractLoggingSystem 和 Log4J2LoggingSystem 两个类是怎么重写上述几个方法的，这也是 SpringBoot 中日志框架处理的核心逻辑。</p><h3 id="AbstractLoggingSystem-处理逻辑"><a href="#AbstractLoggingSystem-处理逻辑" class="headerlink" title="AbstractLoggingSystem 处理逻辑"></a>AbstractLoggingSystem 处理逻辑</h3><p>beforeInitialize 在 AbstractLoggingSystem 中没有具体的处理逻辑，是个空方法，所以主要是看下 initialize 这个方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(LoggingInitializationContext initializationContext, String configLocation, LogFile logFile)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果指定了日志配置文件，则通过此配置文件进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(configLocation)) &#123;</span><br><span class="line">        initializeWithSpecificConfig(initializationContext, configLocation, logFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有指定配置文件，则使用默认的方式查找配置文件并加载</span></span><br><span class="line">    initializeWithConventions(initializationContext, logFile);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过指定的配置文件初始化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeWithSpecificConfig</span><span class="params">(LoggingInitializationContext initializationContext, String configLocation,</span></span></span><br><span class="line"><span class="function"><span class="params">LogFile logFile)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里会处理日志配置文件中的占位符</span></span><br><span class="line">    configLocation = SystemPropertyUtils.resolvePlaceholders(configLocation);</span><br><span class="line">    <span class="comment">// 抽象方法，由具体子类实现（不同的日志框架处理配置文件的方式由其自身决定）</span></span><br><span class="line">    loadConfiguration(initializationContext, configLocation, logFile);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过默认方式查找配置文件并初始化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeWithConventions</span><span class="params">(LoggingInitializationContext initializationContext, LogFile logFile)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找配置文件，以 log4j2 为例，默认会在 classpath 下查找文件名为 </span></span><br><span class="line">    <span class="comment">// log4j2.properties、log4j2.yaml, log4j2.yml、log4j2.json，log4j2.jsn，log4j2.xml 的文件</span></span><br><span class="line">    String config = getSelfInitializationConfig();</span><br><span class="line">    <span class="keyword">if</span> (config != <span class="keyword">null</span> &amp;&amp; logFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 发生了自初始化，在属性发生变化时重新初始化</span></span><br><span class="line">        reinitialize(initializationContext);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 查找 Spring 规则方式的配置，</span></span><br><span class="line">        <span class="comment">// log4j2-spring.properties、log4j2-spring.xml 等</span></span><br><span class="line">        config = getSpringInitializationConfig();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config != <span class="keyword">null</span>) &#123;</span><br><span class="line">        loadConfiguration(initializationContext, config, logFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抽象方法，由具体的日志系统实现</span></span><br><span class="line">    loadDefaults(initializationContext, logFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initialize 里主要就是找配置文件，然后通过配置文件进行日志系统的初始化，如果找不到就使用日志系统提供的默认方式进行初始化。上面代码中关于如何 load 配置文件和 load 默认都是在子类中实现的。所以下面就看下在 log4j2 的情况下，是怎么玩的。</p><h3 id="Log4J2LoggingSystem-处理逻辑"><a href="#Log4J2LoggingSystem-处理逻辑" class="headerlink" title="Log4J2LoggingSystem 处理逻辑"></a>Log4J2LoggingSystem 处理逻辑</h3><p>Log4J2LoggingSystem 并非是 AbstractLoggingSystem 的直接子类，而是 Slf4JLoggingSystem 的直接子类，Slf4JLoggingSystem 这个抽象类从代码来看其实就是为了做一些桥接处理，这里不展开分析。</p><h4 id="beforeInitialize-在-Log4J2LoggingSystem-中的实现"><a href="#beforeInitialize-在-Log4J2LoggingSystem-中的实现" class="headerlink" title="beforeInitialize 在 Log4J2LoggingSystem 中的实现"></a>beforeInitialize 在 Log4J2LoggingSystem 中的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeInitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建、获取 LoggerContext 对象</span></span><br><span class="line">    LoggerContext loggerContext = getLoggerContext();</span><br><span class="line">    <span class="comment">// 判断当前 LoggerContext 是否已经初始化过了，如果已经初始化过了则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isAlreadyInitialized(loggerContext)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用父类 Slf4JLoggingSystem 的 beforeInitialize 的方法，父类这个方法主要就是配置JDK Logging 的桥接处理器</span></span><br><span class="line">    <span class="keyword">super</span>.beforeInitialize();</span><br><span class="line">    <span class="comment">// 给 loggerContext 添加默认的 FILTER</span></span><br><span class="line">    loggerContext.getConfiguration().addFilter(FILTER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>getLoggerContext 是 log4j2 自己构建 LoggerContext 的过程，此处就先 pass。</p></blockquote><h4 id="initialize-在-Log4J2LoggingSystem-中的实现"><a href="#initialize-在-Log4J2LoggingSystem-中的实现" class="headerlink" title="initialize 在 Log4J2LoggingSystem 中的实现"></a>initialize 在 Log4J2LoggingSystem 中的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(LoggingInitializationContext initializationContext, String configLocation, LogFile logFile)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拿到当前 loggerContext</span></span><br><span class="line">    LoggerContext loggerContext = getLoggerContext();</span><br><span class="line">    <span class="comment">// 判断下是否已经初始化过了</span></span><br><span class="line">    <span class="keyword">if</span> (isAlreadyInitialized(loggerContext)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除默认的 FILTER</span></span><br><span class="line">    loggerContext.getConfiguration().removeFilter(FILTER);</span><br><span class="line">    <span class="comment">// 调用父类 initialize，就是在找日志配置文件并且初始化</span></span><br><span class="line">    <span class="keyword">super</span>.initialize(initializationContext, configLocation, logFile);</span><br><span class="line">    <span class="comment">// 标记已经完成初始化</span></span><br><span class="line">    markAsInitialized(loggerContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里核心 initialize方法 还是使用的父类的处理逻辑，前面也提到 initialize 在 AbstractLoggingSystem 中最核心的是 load 配置配置文件的过程（loadConfiguration/loadDefaults），而这个 load 的过程是子类实现的。所以下面就看下 log4j2 中 load 配置文件的过程。</p><ul><li>loadConfiguration：有配置文件的情况</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadConfiguration</span><span class="params">(String location, LogFile logFile)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(location, <span class="string">"Location must not be null"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        LoggerContext ctx = getLoggerContext();</span><br><span class="line">        <span class="comment">// 拿到资源url</span></span><br><span class="line">        URL url = ResourceUtils.getURL(location);</span><br><span class="line">        <span class="comment">// 构建 ConfigurationSource 对象</span></span><br><span class="line">        ConfigurationSource source = getConfigurationSource(url);</span><br><span class="line">        <span class="comment">// 这里会根据配置的类型选择不同的解析器来解析配置文件,比如</span></span><br><span class="line">        <span class="comment">// XmlConfigurationFactory、PropertiesConfigurationFactory...</span></span><br><span class="line">        <span class="comment">// 以指定的 configuration 启动</span></span><br><span class="line">        ctx.start(ConfigurationFactory.getInstance().getConfiguration(ctx, source));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not initialize Log4J2 logging from "</span> + location, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单概括：通过指定的配置文件地址构建 ConfigurationSource 配置资源对象，然后根据配置资源的文件类型选择不同的 ConfigurationFactory 来解析配置文件，最后日志框架根据此配置文件初始化日志系统。</p><ul><li>loadDefaults：没有配置文件的情况</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadDefaults</span><span class="params">(LoggingInitializationContext initializationContext, LogFile logFile)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用 classpath:org/springframework/boot/logging/log4j2/log4j2-file.xml</span></span><br><span class="line">        loadConfiguration(getPackagedConfigFile(<span class="string">"log4j2-file.xml"</span>), logFile);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 classpath:org/springframework/boot/logging/log4j2/log4j2.xml</span></span><br><span class="line">        loadConfiguration(getPackagedConfigFile(<span class="string">"log4j2.xml"</span>), logFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单概括：在没有指定日志配置文件或者没有在 classpath 下找到符合指定日志系统的配置文件时，则使用 SpringBoot 提供的默认的配置文件进行初始化。</p><h3 id="日志系统的清理逻辑"><a href="#日志系统的清理逻辑" class="headerlink" title="日志系统的清理逻辑"></a>日志系统的清理逻辑</h3><p>cleanUp 方法也是由具体的 LoggingSystem 实现，主要作用就是清理 LoggingSystem 资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用父类，移除桥接器</span></span><br><span class="line">    <span class="keyword">super</span>.cleanUp();</span><br><span class="line">    LoggerContext loggerContext = getLoggerContext();</span><br><span class="line">    <span class="comment">// 标记loggerContext为未初始化状态，并将内部的 externalContext 置为 null</span></span><br><span class="line">    markAsUninitialized(loggerContext);</span><br><span class="line">    <span class="comment">// 移除默认的 FILTER</span></span><br><span class="line">    loggerContext.getConfiguration().removeFilter(FILTER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些场景分析"><a href="#一些场景分析" class="headerlink" title="一些场景分析"></a>一些场景分析</h2><p>这里面包括日常开发工作中使用日志的一些常见场景，比如项目中没有任何日志配置的情况、在 resources 目录下配置日志配置文件的情况、已经使用 SpringBoot 无法识别的日志篇日志文件的情况。</p><h3 id="没有任何配置文件"><a href="#没有任何配置文件" class="headerlink" title="没有任何配置文件"></a>没有任何配置文件</h3><p>没有任何配置，通过前面的分析可知，initialize 方法执行时，是找不到任何资源的，所以会走默认的 loadDefaults 方法进行加载，LogbackLoggingSystem 的loadDefaults 方法，由于 logFile 为 null，所以会使用 <code>classpath:org/springframework/boot/logging/log4j2/log4j2.xml</code> 这份配置文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"PID"</span>&gt;</span>????<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"LOG_EXCEPTION_CONVERSION_WORD"</span>&gt;</span>%xwEx<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"LOG_LEVEL_PATTERN"</span>&gt;</span>%5p<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"LOG_DATEFORMAT_PATTERN"</span>&gt;</span>yyyy-MM-dd HH:mm:ss.SSS<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"CONSOLE_LOG_PATTERN"</span>&gt;</span>%clr&#123;%d&#123;$&#123;LOG_DATEFORMAT_PATTERN&#125;&#125;&#125;&#123;faint&#125; %clr&#123;$&#123;LOG_LEVEL_PATTERN&#125;&#125; %clr&#123;$&#123;sys:PID&#125;&#125;&#123;magenta&#125; %clr&#123;---&#125;&#123;faint&#125; %clr&#123;[%15.15t]&#125;&#123;faint&#125; %clr&#123;%-40.40c&#123;1.&#125;&#125;&#123;cyan&#125; %clr&#123;:&#125;&#123;faint&#125; %m%n$&#123;sys:LOG_EXCEPTION_CONVERSION_WORD&#125;<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"FILE_LOG_PATTERN"</span>&gt;</span>%d&#123;$&#123;LOG_DATEFORMAT_PATTERN&#125;&#125; $&#123;LOG_LEVEL_PATTERN&#125; $&#123;sys:PID&#125; --- [%t] %-40.40c&#123;1.&#125; : %m%n$&#123;sys:LOG_EXCEPTION_CONVERSION_WORD&#125;<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        // 打在控制台</span><br><span class="line"><span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span> <span class="attr">follow</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;sys:CONSOLE_LOG_PATTERN&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">"org.apache.catalina.startup.DigesterFactory"</span> <span class="attr">level</span>=<span class="string">"error"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">"org.apache.catalina.util.LifecycleBase"</span> <span class="attr">level</span>=<span class="string">"error"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span> <span class="attr">level</span>=<span class="string">"warn"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.apache.sshd.common.util.SecurityUtils"</span> <span class="attr">level</span>=<span class="string">"warn"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">"org.apache.tomcat.util.net.NioSelectorPool"</span> <span class="attr">level</span>=<span class="string">"warn"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">"org.eclipse.jetty.util.component.AbstractLifeCycle"</span> <span class="attr">level</span>=<span class="string">"error"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">"org.hibernate.validator.internal.util.Version"</span> <span class="attr">level</span>=<span class="string">"warn"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.springframework.boot.actuate.endpoint.jmx"</span> <span class="attr">level</span>=<span class="string">"warn"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这份配置文件中值有一个  Appender，就是默认的 Console，所以没有配置任何日志配置文件时，日志会被打在控制台。</p><h3 id="在-resources-目录下配置-log4j2-xml"><a href="#在-resources-目录下配置-log4j2-xml" class="headerlink" title="在 resources 目录下配置 log4j2.xml"></a>在 resources 目录下配置 log4j2.xml</h3><p>这份配置文件是能够被 SpringBoot 识别的，所以在初始化日志时会使用此份配置文件来进行日志系统的初始化。下面这份配置文件为每种日志级别都配置了一个 appender，所以在使用时，会根据日志级别将日志打在不同的日志目录下。（PS:关于能够识别的日志配置文件参考前面的分析）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">"OFF"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"logging.path"</span>&gt;</span>./logs<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--只接受程序中 INFO 级别的日志进行处理 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"INFO"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%d&#123;HH:mm:ss.SSS&#125;] %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--处理DEBUG级别的日志，并把该日志放到logs/debug.log文件中--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--打印出DEBUG级别日志，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"RollingFileDebug"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;logging.path&#125;/debug.log"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">filePattern</span>=<span class="string">"logs/$$&#123;date:yyyy-MM&#125;/debug-%d&#123;yyyy-MM-dd&#125;-%i.log.gz"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Filters</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"INFO"</span> <span class="attr">onMatch</span>=<span class="string">"DENY"</span> <span class="attr">onMismatch</span>=<span class="string">"NEUTRAL"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Filters</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">pattern</span>=<span class="string">"[%d&#123;yyyy-MM-dd HH:mm:ss&#125;] %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"500 MB"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--处理INFO级别的日志，并把该日志放到logs/info.log文件中--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"RollingFileInfo"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;logging.path&#125;/info.log"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">filePattern</span>=<span class="string">"logs/$$&#123;date:yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;-%i.log.gz"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Filters</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--只接受INFO级别的日志，其余的全部拒绝处理--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"INFO"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"WARN"</span> <span class="attr">onMatch</span>=<span class="string">"DENY"</span> <span class="attr">onMismatch</span>=<span class="string">"NEUTRAL"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Filters</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">pattern</span>=<span class="string">"[%d&#123;yyyy-MM-dd HH:mm:ss&#125;] %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"500 MB"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--处理WARN级别的日志，并把该日志放到logs/warn.log文件中--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"RollingFileWarn"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;logging.path&#125;/warn.log"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">filePattern</span>=<span class="string">"logs/$$&#123;date:yyyy-MM&#125;/warn-%d&#123;yyyy-MM-dd&#125;-%i.log.gz"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Filters</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"WARN"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"ERROR"</span> <span class="attr">onMatch</span>=<span class="string">"DENY"</span> <span class="attr">onMismatch</span>=<span class="string">"NEUTRAL"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Filters</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">pattern</span>=<span class="string">"[%d&#123;yyyy-MM-dd HH:mm:ss&#125;] %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"500 MB"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--处理error级别的日志，并把该日志放到logs/error.log文件中--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"RollingFileError"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;logging.path&#125;/error.log"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">filePattern</span>=<span class="string">"logs/$$&#123;date:yyyy-MM&#125;/error-%d&#123;yyyy-MM-dd&#125;-%i.log.gz"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"ERROR"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">pattern</span>=<span class="string">"[%d&#123;yyyy-MM-dd HH:mm:ss&#125;] %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"500 MB"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"RollingFileInfo"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"RollingFileWarn"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"RollingFileError"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"RollingFileDebug"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--log4j2 自带过滤日志--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">"org.apache.catalina.startup.DigesterFactory"</span> <span class="attr">level</span>=<span class="string">"error"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">"org.apache.catalina.util.LifecycleBase"</span> <span class="attr">level</span>=<span class="string">"error"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span> <span class="attr">level</span>=<span class="string">"warn"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.apache.sshd.common.util.SecurityUtils"</span> <span class="attr">level</span>=<span class="string">"warn"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">"org.apache.tomcat.util.net.NioSelectorPool"</span> <span class="attr">level</span>=<span class="string">"warn"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">"org.crsh.plugin"</span> <span class="attr">level</span>=<span class="string">"warn"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.crsh.ssh"</span> <span class="attr">level</span>=<span class="string">"warn"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">"org.eclipse.jetty.util.component.AbstractLifeCycle"</span> <span class="attr">level</span>=<span class="string">"error"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">"org.hibernate.validator.internal.util.Version"</span> <span class="attr">level</span>=<span class="string">"warn"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.thymeleaf"</span> <span class="attr">level</span>=<span class="string">"warn"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">"org.springframework"</span> <span class="attr">level</span>=<span class="string">"warn"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在-resources-下配置一个-log4j2-glmapper-xml"><a href="#在-resources-下配置一个-log4j2-glmapper-xml" class="headerlink" title="在 resources 下配置一个 log4j2-glmapper.xml"></a>在 resources 下配置一个 log4j2-glmapper.xml</h3><p>将上面的配置文件重命名为 log4j2-glmapper.xml ，因为这个命名规则是 SpringBoot 无法默认识别的，所以在日志配置文件加载时和场景一是一样的。如果希望这份配置文件能够被识别，可以使用 logging.config 来指定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.config=classpath:log4j2-glmapper.xml</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇对 SpringBoot 中的日志进行了系统的介绍和分析，文章主要是了解 SpringBoot 中对于日志系统的处理，所以不会太关注日志系统自身的一些处理逻辑，有兴趣的读者可以自行研究或者联系作者一起沟通。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring Boot 使用 Commons Logging 进行所有内部日志记录，但保留底层日志实现。为 Java Util Logging、Log4J2 和 Logback 提供了默认配置。在每种情况下，loggers 都预先配置为使用 console 输出，并且也提供
      
    
    </summary>
    
      <category term="springboot" scheme="http://www.glmapper.com/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://www.glmapper.com/tags/springboot/"/>
    
      <category term="log" scheme="http://www.glmapper.com/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实践系列-资源访问</title>
    <link href="http://www.glmapper.com/2019/12/09/springboot-series-access-resource/"/>
    <id>http://www.glmapper.com/2019/12/09/springboot-series-access-resource/</id>
    <published>2019-12-09T14:49:35.000Z</published>
    <updated>2020-04-05T11:42:24.417Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://smarterco.de/java-load-file-from-classpath-in-spring-boot/" target="_blank" rel="noopener">https://smarterco.de/java-load-file-from-classpath-in-spring-boot/</a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>当我们创建一个 SpringBoot web 应用时，有时候需要从 classpath 去加载一些文件，这里记录下在 war 和 jar 两种不同文件格式下加载文件的解决方案</p><h2 id="The-ResourceLoader"><a href="#The-ResourceLoader" class="headerlink" title="The ResourceLoader"></a>The ResourceLoader</h2><p>在 Java 中 ，我们可以使用当前线程的 classLoader 去尝试加载文件，但是 Spring Framework 为我们提供了更加优雅的解决方案，例如 ResourceLoader。</p><p>使用 ResourceLoader 时，我们只需要使用 @Autowire 自动注入 ResourceLoader，然后调用 getResource(“somePath”) 方法即可。</p><h3 id="在Spring-Boot（WAR）中从资源目录-类路径加载文件的示例"><a href="#在Spring-Boot（WAR）中从资源目录-类路径加载文件的示例" class="headerlink" title="在Spring Boot（WAR）中从资源目录/类路径加载文件的示例"></a>在Spring Boot（WAR）中从资源目录/类路径加载文件的示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"geolocationservice"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeoLocationServiceImpl</span> <span class="keyword">implements</span> <span class="title">GeoLocationService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(GeoLocationServiceImpl.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DatabaseReader reader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GeoLocationServiceImpl</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            LOGGER.info(<span class="string">"GeoLocationServiceImpl: Trying to load GeoLite2-Country database..."</span>);</span><br><span class="line">            Resource resource = resourceLoader.getResource(<span class="string">"classpath:GeoLite2-Country.mmdb"</span>);</span><br><span class="line">            File dbAsFile = resource.getFile();</span><br><span class="line">            <span class="comment">// Initialize the reader</span></span><br><span class="line">            reader = <span class="keyword">new</span> DatabaseReader</span><br><span class="line">                        .Builder(dbAsFile)</span><br><span class="line">                        .fileMode(Reader.FileMode.MEMORY)</span><br><span class="line">                        .build();</span><br><span class="line">            LOGGER.info(<span class="string">"GeoLocationServiceImpl: Database was loaded successfully."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | NullPointerException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Database reader cound not be initialized. "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">"Failed to close the reader."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从-SpringBoot-FatJar-中加载资源"><a href="#从-SpringBoot-FatJar-中加载资源" class="headerlink" title="从 SpringBoot FatJar 中加载资源"></a>从 SpringBoot FatJar 中加载资源</h3><p>如果我们想从 Spring Boot JAR 中的类路径加载文件，则必须使用 resource.getInputStream() 方法将其作为 InputStream 检索。 如果尝试使用resource.getFile()，则会收到错误消息，因为 Spring 尝试访问文件系统路径，但它无法访问 JAR 中的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"geolocationservice"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeoLocationServiceImpl</span> <span class="keyword">implements</span> <span class="title">GeoLocationService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(GeoLocationServiceImpl.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DatabaseReader reader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GeoLocationServiceImpl</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            LOGGER.info(<span class="string">"GeoLocationServiceImpl: Trying to load GeoLite2-Country database..."</span>);</span><br><span class="line">            Resource resource = resourceLoader.getResource(<span class="string">"classpath:GeoLite2-Country.mmdb"</span>);</span><br><span class="line">            InputStream dbAsStream = resource.getInputStream(); <span class="comment">// &lt;-- this is the difference</span></span><br><span class="line">            <span class="comment">// Initialize the reader</span></span><br><span class="line">            reader = <span class="keyword">new</span> DatabaseReader</span><br><span class="line">                        .Builder(dbAsStream)</span><br><span class="line">                        .fileMode(Reader.FileMode.MEMORY)</span><br><span class="line">                        .build();</span><br><span class="line">            LOGGER.info(<span class="string">"GeoLocationServiceImpl: Database was loaded successfully."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | NullPointerException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Database reader cound not be initialized. "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">"Failed to close the reader."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://smarterco.de/java-load-file-from-classpath-in-spring-boot/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://sma
      
    
    </summary>
    
      <category term="springboot" scheme="http://www.glmapper.com/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://www.glmapper.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 源码系列-启动过程分析</title>
    <link href="http://www.glmapper.com/2019/12/07/springboot-series-started/"/>
    <id>http://www.glmapper.com/2019/12/07/springboot-series-started/</id>
    <published>2019-12-07T07:04:28.000Z</published>
    <updated>2020-04-05T11:44:34.802Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>个人博客：<a href="https://juejin.im/user/58fcc0768d6d810058965a06" target="_blank" rel="noopener">glmapper</a><br>更多请关注 <strong><a href="#jump_10">glmapper工作室</a></strong> 微信公众号</p></blockquote><p>SpringBoot 作为目前非常流行的微服务框架，它使得构建独立的 Spring 生产级应用变得非常简单，因此受到很多互联网企业的青睐。</p><p>最近在写 <a href="https://github.com/sofastack/sofa-tracer" target="_blank" rel="noopener">SOFATracer</a> 集成 Spring Cloud Stream RocketMQ 的过程中，遇到了一些问题，比如：BeanPostProcessor 不生效，如何在 BeanPostProcessor 不生效的情况下去修改一个 Bean 等，这些问题其实都是和 Bean 的生命周期有关系的，当然也和容器启动的过程有关系。SpringBoot 的启动过程对于我来说其实不算陌生，也可以说是比较熟悉，但是之前没有完整的梳理过这一块的东西，在实际的应用过程成难免再去踩一些坑。另外想到之前也写过一篇 <a href="http://www.glmapper.com/2019/12/08/springboot-series-fatjar/">SpringBoot系列- FatJar 启动原理</a>，刚好承接上篇，继续来探索 SpringBoot 中的一些知识点。</p><blockquote><p>注：本篇基于 SpringBoot 2.1.0.RELEASE 版本，SpringBoot 各个版本之间可能存在差异，不过大体流程基本差不多，所以各位看官在实际的工作过程中也</p></blockquote><h2 id="从一份配置文件开始说起"><a href="#从一份配置文件开始说起" class="headerlink" title="从一份配置文件开始说起"></a>从一份配置文件开始说起</h2><p>Spring 的启动过程实际上就是 Ioc 容器初始化以及载入 Bean 的过程；SpringBoot 的启动过程最核心的容器刷新流程也是复用了  Spring 容器刷新的逻辑。在分析 SpringBoot 启动过程之前，我们先来简单回顾下 Spring web 应用基于 tomcat 容器部署的启动过程。这就需要从一个大家都熟悉的配置文件开始说起：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在一般的传统 WEB 项目中，项目的启动一般是从 web.xml 文件的载入开始，如果我们的项目中使用了Spring，那么你肯定会在你的 web.xml 文件中看到上面的配置。Spring 正是通过 ContextLoaderListener 监听器作为容器初始化入口的。</p><p>ContextLoaderListener 继承了 ContextLoader 类和 ServletContextListener 接口，并且重写了 ServletContextListener 中的contextInitialized 和 contextDestroyed 方法。在 contextInitialized 中，通过调用父类（ContextLoader）的 initWebApplicationContext 方法进行容器创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">    initWebApplicationContext(event.getServletContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述 Spring 容器引导刷新大概可以分为两个点来做简单的归纳：</p><ul><li><p>1、通过监听 ServletContextEvent 事件，为 web 容器提供一个全局的 ServletContext 上下文环境，并作为后面 spring 容器的宿主环境</p></li><li><p>2、在 contextInitialized 方法被调用时，spring 开始初始化一个上下文，这个上下文被称为根上下文，也就是 WebApplicationContext（实际的实现类是 XmlWebApplicationContext ）。这个 WebApplicationContext 就是 spring 的 IoC 容器，其对应的 Bean 定义的配置文件由 web.xml 中的 context-param 指定。</p></li></ul><p>关于依赖监听 ServletContextEvent 事件来引导启动的过程大致可以描述为一下过程：</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/spring-start.png" alt=""></p><p>相对于通过监听 ServletContextEvent 事件方式引导刷新 Spring 上下文，SpringBoot 给我的感觉是回归了 java 的本源，即通过 main 方法方式引导启动。由于 SpringBoot 中对于 web 容器也是使用了嵌入式+自动配置的方式，所以在启动入口上差异还是比较大的，当然 SpringBoot 除了支持 fatjar 方式之外，也提供了 war 包方式来保持对原有 Spring 工程的兼容。</p><p>本篇文章将承接上一篇《SpringBoot FatJar 启动原理》，来分析下 SpringBoot 的启动过程。希望通过本篇文章，能够让大家了解到与传统基于 servlet 事件引导启动和基于 main 方式启动的不同，从而对 SpringBoot 的整体启动过程有比较清楚的认识。</p><h2 id="启动入口"><a href="#启动入口" class="headerlink" title="启动入口"></a>启动入口</h2><p>在这篇<a href="http://www.glmapper.com/2019/12/08/springboot-series-fatjar/">SpringBoot系列- FatJar 启动原理</a> 文章中介绍得到，JarLaunch 最后是构建了一个 MainMethodRunner 实例对象，然后通过反射的方式调用了 BootStrap 类中的 main 方法，这里的 ’BootStrap 类中的 main 方法‘ 实际上就是 SpringBoot 的业务入口，也就是常见的下面的代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(GlmapperApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以非常直观的了解到，启动是通过调用 SpringApplication 的静态方法 run；这个 run 方法内部其实是会构造一个 SpringApplication 的实例，然后再调用这里实例的 run 方法来启动 SpringBoot 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Static helper that can be used to run a &#123;<span class="doctag">@link</span> SpringApplication&#125; from the</span></span><br><span class="line"><span class="comment">* specified sources using default settings and user supplied arguments.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> primarySources the primary sources to load</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args the application arguments (usually passed from a Java main method)</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the running &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources,</span></span></span><br><span class="line"><span class="function"><span class="params">    String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，如果要分析 SpringBoot 的启动过程，我们需要熟悉 SpringApplication 的构造过程以及 SpringApplication 的 run 方法执行过程即可。</p><h2 id="SpringApplication-实例的构建"><a href="#SpringApplication-实例的构建" class="headerlink" title="SpringApplication 实例的构建"></a>SpringApplication 实例的构建</h2><p>篇幅原因，我们只分析核心的构建流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 资源加载器，默认是 null</span></span><br><span class="line">    <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    <span class="comment">// 启动类 bean </span></span><br><span class="line">    Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    <span class="comment">// 是否是 web 应用</span></span><br><span class="line">    <span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="comment">// 设置了 ApplicationContextInitializer</span></span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">            ApplicationContextInitializer.class));</span><br><span class="line">    <span class="comment">// 设置 ApplicationListener</span></span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    <span class="comment">// 启动类</span></span><br><span class="line">    <span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码段中，需要关注两个点：</p><ul><li>1、初始化 ApplicationContextInitializer；</li><li>2、初始化 ApplicationListener</li></ul><p>要注意的是这里的实例化，并非是通过注解和扫包完成，而是通过一种不依赖 Spring 上下文的加载方法；这种做法是为了能够使得在 Spring 完成启动前做各种配置。Spring 的解决方法是以接口的全限定名作为 key，实现类的全限定名作为 value 记录在项目的 META-INF/spring.factories 文件中，然后通过SpringFactoriesLoader 工具类提供静态方法进行类加载并缓存下来，spring.factories 是 SpringBoot 的核心配置文件。SpringFactoriesLoader 可以理解为 Spring 自己提供的一种 spi 扩展实现。SpringBoot 中提供的默认的 spring.factories 配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># PropertySource Loaders</span><br><span class="line">org.springframework.boot.env.PropertySourceLoader=\</span><br><span class="line">// ..省略</span><br><span class="line"># Run Listeners</span><br><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">// ..省略</span><br><span class="line"># Error Reporters</span><br><span class="line">org.springframework.boot.SpringBootExceptionReporter=\</span><br><span class="line">// ..省略</span><br><span class="line"># Application Context Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\/</span><br><span class="line">// ..省略</span><br><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">// ..省略</span><br><span class="line"># Environment Post Processors</span><br><span class="line">org.springframework.boot.env.EnvironmentPostProcessor=\</span><br><span class="line">// ..省略</span><br><span class="line"># Failure Analyzers</span><br><span class="line">org.springframework.boot.diagnostics.FailureAnalyzer=\</span><br><span class="line">// ..省略</span><br><span class="line"># FailureAnalysisReporters</span><br><span class="line">org.springframework.boot.diagnostics.FailureAnalysisReporter=\</span><br><span class="line">// ..省略</span><br></pre></td></tr></table></figure><p>关于 SpringFactoriesLoader  如何加载这些资源这里就不过多分析，有兴趣的读者可以自行查看相关源码。<a href="">org.springframework.core.io.support.SpringFactoriesLoader#loadSpringFactories</a></p><h2 id="run-方法主流程"><a href="#run-方法主流程" class="headerlink" title="run 方法主流程"></a>run 方法主流程</h2><p>SpringApplication 的 run 方法 SpringBoot 进行 Spring 容器刷新的实际入口方法，这个方法中包括了很多 SpringBoot 自己扩展出来的一些特性机制，比如 SpringApplicationRunListener、打印启动 Banner、统一的异常处理扩展等等。下面就直观的看下代码，然后再逐个分析各个流程的具体细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开启容器启动计时</span></span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// SpringBootExceptionReporter 列表，SpringBoot 允许自定义 Reporter</span></span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 设置java.awt.headless属性为true还是false</span></span><br><span class="line">    <span class="comment">// 可详见解释：https://blog.csdn.net/michaelgo/article/details/81634017</span></span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    <span class="comment">// 获取所有 SpringApplicationRunListener ，也是通过 SpringFactoriesLoader 来获取的</span></span><br><span class="line">    SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">    <span class="comment">// 发布 starting 事件，在首次启动 run方法时立即调用，可用于非常早的初始化，注意此时容器上下文还没有刷新</span></span><br><span class="line">    listeners.starting();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 构建 ApplicationArguments 对象</span></span><br><span class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">                args);</span><br><span class="line">        <span class="comment">// 准备上下文刷新需要的环境属性 -- 详见 prepareEnvironment 过程分析</span></span><br><span class="line">        ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">                applicationArguments);</span><br><span class="line">        <span class="comment">// spring.beaninfo.ignore，如果为空设置为true</span></span><br><span class="line">        configureIgnoreBeanInfo(environment);</span><br><span class="line">        <span class="comment">// 打印 SpringBoot 启动 Banner</span></span><br><span class="line">        Banner printedBanner = printBanner(environment);</span><br><span class="line">        <span class="comment">// 创建上下文，这里会根据 webApplicationType 类型来创建不同的 ApplicationContext</span></span><br><span class="line">        context = createApplicationContext();</span><br><span class="line">        <span class="comment">// 加载获取 exceptionReporters</span></span><br><span class="line">        exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">                SpringBootExceptionReporter.class,</span><br><span class="line">                <span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">        <span class="comment">// 上下文刷新之前的准备工作 -- 详见 prepareContext 过程分析</span></span><br><span class="line">        prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">                printedBanner);</span><br><span class="line">        <span class="comment">// 刷新上下文 -- 详见 refreshContext 过程分析</span></span><br><span class="line">        refreshContext(context);</span><br><span class="line">        <span class="comment">// 刷新之后回调，SpringBoot 中这个方法是空实现，可以自行扩展</span></span><br><span class="line">        afterRefresh(context, applicationArguments);</span><br><span class="line">        <span class="comment">// 停止计时</span></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">                    .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发布 started 事件 </span></span><br><span class="line">        listeners.started(context);</span><br><span class="line">        <span class="comment">// ApplicationRunner 和 CommandLineRunner 调用</span></span><br><span class="line">        callRunners(context, applicationArguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 发布 running 事件 </span></span><br><span class="line">        listeners.running(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面对代码基本都做了一些详细的注释，有几个需要关注的点：</p><ul><li>1、prepareEnvironment 的处理过程</li><li>2、prepareContext 的处理过程</li><li>3、refreshContext 的处理过程</li><li>4、listeners 执行时机及顺序</li><li>5、异常处理逻辑</li></ul><p>关于 Listeners 执行时机及顺序在之前的文章中有做过非常详细的分析，详见：<a href="http://www.glmapper.com/2019/04/13/springboot-series-event/">SpringBoot 系列-事件机制详解</a>。下面就对其他的 4 个点做下详细的分析。</p><blockquote><p>分析启动过程，本质上是对其整个容器生命周期有个了解，包括 listeners 执行各个事件的时机、PostProcessor 执行的时机，Enviroment Ready 的时机等等。掌握这些扩展和时机，可以在实际的业务开发中来做很多事情。</p></blockquote><h3 id="prepareEnvironment-的处理过程"><a href="#prepareEnvironment-的处理过程" class="headerlink" title="prepareEnvironment 的处理过程"></a>prepareEnvironment 的处理过程</h3><p>prepareEnvironment 过程相对来说是比较早的，这里主要就是为上下文刷新提供 Environment。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableEnvironment <span class="title">prepareEnvironment</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">ApplicationArguments applicationArguments)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create and configure the environment</span></span><br><span class="line">    ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">    <span class="comment">// 配置 PropertySources 和 Profiles</span></span><br><span class="line">    <span class="comment">// 1、将参数和一些默认的属性配置到 environment</span></span><br><span class="line">    <span class="comment">// 2、激活 profiles </span></span><br><span class="line">    configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">    <span class="comment">// 发布 ApplicationEnvironmentPreparedEvent 事件</span></span><br><span class="line">    listeners.environmentPrepared(environment);</span><br><span class="line">    <span class="comment">// 绑定 SpringApplication 环境</span></span><br><span class="line">    bindToSpringApplication(environment);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isCustomEnvironment) &#123;</span><br><span class="line">        environment = <span class="keyword">new</span> EnvironmentConverter(getClassLoader())</span><br><span class="line">                .convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 附加的解析器将动态跟踪底层 Environment 属性源的任何添加或删除</span></span><br><span class="line">    ConfigurationPropertySources.attach(environment);</span><br><span class="line">    <span class="keyword">return</span> environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面做的事情就是将我们的配置，包括系统配置、application.properties、-D 参数等等统统打包给 environment。在 Spring 中，我们最常见的 xml 中使用的 ${xxx} 或者代码中使用的 @Value(“${xxxx}”) 等，最后都是从 environment 中拿值的。</p><p>这里需要关注的一个比较重要的点是<strong>发布 ApplicationEnvironmentPreparedEvent 事件</strong>，我们可以通过监听这个事件来<strong>修改 environment</strong>。这里可以参考下 SOFATracer 中 <a href="https://github.com/sofastack/sofa-tracer/blob/master/tracer-sofa-boot-starter/src/main/java/com/alipay/sofa/tracer/boot/listener/SofaTracerConfigurationListener.java" target="_blank" rel="noopener">SofaTracerConfigurationListener</a> 是如何利用这个事件来做环境配置处理的。</p><h3 id="prepareContext-的处理过程"><a href="#prepareContext-的处理过程" class="headerlink" title="prepareContext 的处理过程"></a>prepareContext 的处理过程</h3><p>prepareContext 的处理过程中可以利用的点是非常多的，比如 ApplicationContextInitializer 的执行、ApplicationContextInitializedEvent 和 ApplicationPreparedEvent 事件发布。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置 environment 给 context，所以需要注意的是，在此之前拿到的 context 中，environment 是没有的。</span></span><br><span class="line">    context.setEnvironment(environment);</span><br><span class="line">    <span class="comment">// 对 ApplicationContext 的后置处理，比如注册 BeanNameGenerator 和 ResourceLoader</span></span><br><span class="line">    postProcessApplicationContext(context);</span><br><span class="line">    <span class="comment">// 这里开始执行所有的 ApplicationContextInitializer</span></span><br><span class="line">    applyInitializers(context);</span><br><span class="line">    <span class="comment">// 发布 ApplicationContextInitializedEvent 事件</span></span><br><span class="line">    listeners.contextPrepared(context);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">        logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line">        logStartupProfileInfo(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add boot specific singleton beans</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">    beanFactory.registerSingleton(<span class="string">"springApplicationArguments"</span>, applicationArguments);</span><br><span class="line">    <span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">"springBootBanner"</span>, printedBanner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">        <span class="comment">// 是否允许 bean 覆盖，这里如果是 false ,则可能会导致 BeanDefinitionOverrideException 异常</span></span><br><span class="line">        ((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">                .setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Load the sources</span></span><br><span class="line">    Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">    Assert.notEmpty(sources, <span class="string">"Sources must not be empty"</span>);</span><br><span class="line">    load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">    <span class="comment">// 发布 ApplicationPreparedEvent 事件</span></span><br><span class="line">    listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationContextInitializer 是 spring 容器刷新之前初始化 Spring ConfigurableApplicationContext 的回调接口，ApplicationContextInitializer 的 initialize 方法执行之前，context 是还没有刷新的。可以看到在 applyInitializers 之后紧接着发布了 ApplicationContextInitializedEvent 事件。其实这两个点都可以对 context 搞一些事情，ApplicationContextInitializer 更纯粹些，它只关注 context；而 ApplicationContextInitializedEvent 事件源中除了 context 之外，还有 springApplication 对象和参数 args。</p><p>prepareContext 最后阶段是发布了 ApplicationPreparedEvent 事件，表示上下文已经准备好了，可以随时执行 refresh 了。</p><h3 id="refreshContext-的处理过程"><a href="#refreshContext-的处理过程" class="headerlink" title="refreshContext 的处理过程"></a>refreshContext 的处理过程</h3><p>refreshContext 是 Spring 上下文刷新的过程，这里实际调用的是 AbstractApplicationContext 的 refresh 方法；所以 SpringBoot 也是复用了 Spring 上下文刷新的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁处理</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// 准备刷新此上下文。主要包括占位符的替换及验证所有的 properties</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line">        <span class="comment">// 这里做了很多事情：</span></span><br><span class="line">        <span class="comment">// 1、让子类刷新内部beanFactory ，创建IoC容器（DefaultListableBeanFactory--ConfigurableListableBeanFactory 的实现类）</span></span><br><span class="line">        <span class="comment">// 2、加载解析XML文件（最终存储到Document对象中）</span></span><br><span class="line">        <span class="comment">// 3、读取Document对象，并完成BeanDefinition的加载和注册工作</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">        <span class="comment">// 对 beanFactory 进行一些预处理（设置一些公共属性）</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 允许在 AbstractApplicationContext的子类中对 BeanFactory 进行后置处理，postProcessBeanFactory()这个方法是个空实现。</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">// 调用 BeanFactoryPostProcessor 后置处理器处理 BeanFactory 实例（BeanDefinition）</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// 注册BeanPostProcessor后置处理器，BeanPostProcessors后置处理器用于拦截bean的创建</span></span><br><span class="line">            <span class="comment">// 用于对创建后的bean实例进行处理</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// 初始化消息资源</span></span><br><span class="line">            initMessageSource();</span><br><span class="line">            <span class="comment">//  初始化应用事件广播器</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">            <span class="comment">// 初始化特殊的bean，这个方法是空实现，让AbstractApplicationContext的子类重写</span></span><br><span class="line">            onRefresh();</span><br><span class="line">            <span class="comment">// 注册监听器（ApplicationListener）</span></span><br><span class="line">            registerListeners();</span><br><span class="line">            <span class="comment">// 实例化剩余的单例bean（非懒加载方式）， Bean的 IoC、DI 和 AOP 都是发生在此步骤</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="comment">// 完成刷新</span></span><br><span class="line">            <span class="comment">// 1、发布 ContextRefreshedEvent 事件</span></span><br><span class="line">            <span class="comment">// 2、处理 LifecycleProcessor</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                        <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 销毁已经创建的单例以避免资源悬空。</span></span><br><span class="line">            destroyBeans();</span><br><span class="line">            <span class="comment">// 重置 ”active“ 标记</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 重置Spring内核中的常用自检缓存，清空单例bean内缓存</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个过程涉及到的东西非常多，可扩展的点也非常多，包括 BeanFactoryPostProcessor 处理、BeanPostProcessor 处理、LifecycleProcessor 处理已经 发布 ContextRefreshedEvent 事件等。到这里容器刷新已经完成，容器已经 ready，DI 和 AOP 也已经完成。</p><h4 id="BeanFactoryPostProcessor-处理"><a href="#BeanFactoryPostProcessor-处理" class="headerlink" title="BeanFactoryPostProcessor 处理"></a>BeanFactoryPostProcessor 处理</h4><p> BeanFactoryPostProcessor 可以对我们的 beanFactory 内所有的 beandefinition（未实例化）数据进行修改，这个过程是在 bean 还没有实例化之前做的。所以在这，我们通过自己去注册一些 beandefinition ，也可以对 beandefinition 做一些修改。关于 BeanFactoryPostProcessor 的用法在很多框架中都有体现，这里以 SOFATracer 中修改 Datasource 为例来说明下。</p><blockquote><p>SOFATracer 中为了对有所基于 jdbc 规范的数据源进行埋点，提供了一个 DataSourceBeanFactoryPostProcessor，用于修改原生 DataSource 来实现一层代理。代码详见：<a href="https://github.com/sofastack/sofa-tracer/blob/master/tracer-sofa-boot-starter/src/main/java/com/alipay/sofa/tracer/boot/datasource/processor/DataSourceBeanFactoryPostProcessor.java" target="_blank" rel="noopener">com.alipay.sofa.tracer.boot.datasource.processor.DataSourceBeanFactoryPostProcessor</a></p></blockquote><p> 这里只看核心代码部分，在 postProcessBeanFactory 方法中会根据 Datasource 的类型来创建不同的 DataSourceProxy；创建 DataSourceProxy 的过程就是修改原生 Datasource 的过程。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createDataSourceProxy</span><span class="params">(ConfigurableListableBeanFactory beanFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      String beanName, BeanDefinition originDataSource,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      String jdbcUrl)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// re-register origin datasource bean</span></span><br><span class="line">   BeanDefinitionRegistry beanDefinitionRegistry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">   <span class="comment">// 先把之前已经存在的 Datasource 的 BeanDefinition 移除</span></span><br><span class="line">   beanDefinitionRegistry.removeBeanDefinition(beanName);</span><br><span class="line">   <span class="keyword">boolean</span> isPrimary = originDataSource.isPrimary();</span><br><span class="line">   originDataSource.setPrimary(<span class="keyword">false</span>);</span><br><span class="line">   <span class="comment">// 换个 beanName ,重新注册到容器中</span></span><br><span class="line">   beanDefinitionRegistry.registerBeanDefinition(transformDatasourceBeanName(beanName),</span><br><span class="line">       originDataSource);</span><br><span class="line">   <span class="comment">// 构建代理的 datasource BeanDefinition，类型为 SmartDataSource</span></span><br><span class="line">   RootBeanDefinition proxiedBeanDefinition = <span class="keyword">new</span> RootBeanDefinition(SmartDataSource.class);</span><br><span class="line">   <span class="comment">// 设置 BeanDefinition 相关属性</span></span><br><span class="line">   proxiedBeanDefinition.setRole(BeanDefinition.ROLE_APPLICATION);</span><br><span class="line">   proxiedBeanDefinition.setPrimary(isPrimary);</span><br><span class="line">   proxiedBeanDefinition.setInitMethodName(<span class="string">"init"</span>);</span><br><span class="line">   proxiedBeanDefinition.setDependsOn(transformDatasourceBeanName(beanName));</span><br><span class="line">   <span class="comment">// 获取原生 datasource 的属性值</span></span><br><span class="line">   MutablePropertyValues originValues = originDataSource.getPropertyValues();</span><br><span class="line">   MutablePropertyValues values = <span class="keyword">new</span> MutablePropertyValues();</span><br><span class="line">   String appName = environment.getProperty(TRACER_APPNAME_KEY);</span><br><span class="line">   <span class="comment">// 修改和新增属性</span></span><br><span class="line">   Assert.isTrue(!StringUtils.isBlank(appName), TRACER_APPNAME_KEY + <span class="string">" must be configured!"</span>);</span><br><span class="line">   values.add(<span class="string">"appName"</span>, appName);</span><br><span class="line">   values.add(<span class="string">"delegate"</span>, <span class="keyword">new</span> RuntimeBeanReference(transformDatasourceBeanName(beanName)));</span><br><span class="line">   values.add(<span class="string">"dbType"</span>,</span><br><span class="line">       DataSourceUtils.resolveDbTypeFromUrl(unwrapPropertyValue(originValues.get(jdbcUrl))));</span><br><span class="line">   values.add(<span class="string">"database"</span>,</span><br><span class="line">       DataSourceUtils.resolveDatabaseFromUrl(unwrapPropertyValue(originValues.get(jdbcUrl))));</span><br><span class="line">   <span class="comment">// 将新的 values 设置给代理 BeanDefinition</span></span><br><span class="line">   proxiedBeanDefinition.setPropertyValues(values);</span><br><span class="line">   <span class="comment">// 将代理的 datasource BeanDefinition 注册到容器中</span></span><br><span class="line">   beanDefinitionRegistry.registerBeanDefinition(beanName, proxiedBeanDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码就是 BeanFactoryPostProcessor 一种典型的应用场景，就是修改 BeanDefinition。</p><p>BeanFactoryPostProcessor 处理过程代码比较长，这里就不在具体分析处理的流程。需要关注的点是：1、BeanFactoryPostProcessor 的作用，它能做哪些事情；2、它是在容器启动的哪个阶段执行的。</p><h4 id="registerBeanPostProcessors-的处理过程"><a href="#registerBeanPostProcessors-的处理过程" class="headerlink" title="registerBeanPostProcessors 的处理过程"></a>registerBeanPostProcessors 的处理过程</h4><p>registerBeanPostProcessors 是用于注册 BeanPostProcessor 的。BeanPostProcessor 的作用时机相对于 BeanFactoryPostProcessor 来说要晚一些，BeanFactoryPostProcessor 处理的是 BeanDefinition，Bean 还没有实例化；BeanPostProcessor 处理的是 Bean，BeanPostProcessor 包括两个方法，分别用于在 Bean 实例化之前和实例化之后回调。</p><p>开篇有提到，在某些场景下会出现 BeanPostProcessor 不生效。对于 Spring 来说，BeanPostProcessor 本身也会被注册成一个 Bean，那么自然就可能会出现，BeanPostProcessor  处理的 bean 在 BeanPostProcessor 本身初始化之前就已经完成了的情况。</p><p>registerBeanPostProcessors 大体分为以下几个部分：</p><ul><li>注册 BeanPostProcessorChecker。（当一个 bean 在 BeanPostProcessor 实例化过程中被创建时，即当一个bean没有资格被所有 BeanPostProcessor 处理时，它记录一个信息消息）</li><li>实现优先排序、排序和其他操作的 BeanPostProcessor 之间进行排序</li><li>注册实现 PriorityOrdered 的 BeanPostProcessor</li><li>注册实现 Ordered 的 </li><li>注册所有常规的 BeanPostProcessor</li><li>重新注册所有的内部 BeanPostProcessor</li><li>将后处理器注册为用于检测内部 bean 的 applicationlistener，将其移动到处理器链的末端(用于获取代理等)。</li></ul><blockquote><p>这里还是以扩展时机为主线，Bean 的 IoC、DI 和 AOP 初始化过程不细究。</p></blockquote><h4 id="LifecycleProcessor-的处理过程"><a href="#LifecycleProcessor-的处理过程" class="headerlink" title="LifecycleProcessor 的处理过程"></a>LifecycleProcessor 的处理过程</h4><p>LifecycleProcessor 的处理过程是在 finishRefresh 方法中执行，下面先看下 finishRefresh 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清除上下文级的资源缓存(比如扫描的ASM元数据)。</span></span><br><span class="line">    clearResourceCaches();</span><br><span class="line">    <span class="comment">// 为此上下文初始化 LifecycleProcessor。</span></span><br><span class="line">    initLifecycleProcessor();</span><br><span class="line">    <span class="comment">// 首先将 refresh 传播到 LifecycleProcessor。</span></span><br><span class="line">    getLifecycleProcessor().onRefresh();</span><br><span class="line">    <span class="comment">// 发布 ContextRefreshedEvent 事件</span></span><br><span class="line">    publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line">    <span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line">    LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化 initLifecycleProcessor 是从容器中拿到所有的 LifecycleProcessor ，如果业务代码中没有实现 LifecycleProcessor 接口的 bean ，则使用默认的 DefaultLifecycleProcessor。</p><p>onRefresh 过程是 最后会调用到 Lifecycle 接口的 start 方法。LifeCycle 定义 Spring 容器对象的生命周期，任何 spring 管理对象都可以实现该接口。然后，当 ApplicationContext 本身接收启动和停止信号(例如在运行时停止/重启场景)时，spring 容器将在容器上下文中找出所有实现了 LifeCycle 及其子类接口的类，并一一调用它们实现的类。spring 是通过委托给生命周期处理器 LifecycleProcessor 来实现这一点的。Lifecycle 接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动当前组件</span></span><br><span class="line"><span class="comment">     * 1、如果组件已经在运行，不应该抛出异常</span></span><br><span class="line"><span class="comment">     * 2、对于容器，这将把开始信号传播到应用的所有组件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通常以同步方式停止该组件，当该方法执行完成后,该组件会被完全停止。当需要异步停止行为时，考虑实现 SmartLifecycle 和它的 stop</span></span><br><span class="line"><span class="comment">     * (Runnable) 方法变体。注意，此停止通知在销毁前不能保证到达:在常规关闭时，&#123;<span class="doctag">@code</span> Lifecycle&#125; bean将首先收到一个停止通知，然后才传播</span></span><br><span class="line"><span class="comment">     * 常规销毁回调;然而，在上下文的生命周期内的热刷新或中止的刷新尝试上，只调用销毁方法。对于容器，这将把停止信号传播到应用的所有组件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      *  检查此组件是否正在运行。</span></span><br><span class="line"><span class="comment">      *  1. 只有该方法返回 false 时，start方法才会被执行。</span></span><br><span class="line"><span class="comment">      *  2. 只有该方法返回 true 时，stop(Runnable callback) 或 stop() 方法才会被执行。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，容器刷新其实已经就完成了。可以看到 Spring 或者 SpringBoot 在整个启动过程中，有非常多的口子暴露出来，供用户使用，非常灵活。</p><h3 id="异常处理逻辑"><a href="#异常处理逻辑" class="headerlink" title="异常处理逻辑"></a>异常处理逻辑</h3><p>与正常流程类似，异常处理流程同样作为 SpringBoot 生命周期的一个环节，在异常发生时，会通过一些机制来处理收尾过程。异常处理部分 SpringBoot 1.x 版本和 SpringBoot 2.x 版本差异还是比较大的。这里只分析 SpringBoot 2.x 的处理过程。这里直接贴一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleRunFailure</span><span class="params">(ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">Throwable exception,</span></span></span><br><span class="line"><span class="function"><span class="params">Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters,</span></span></span><br><span class="line"><span class="function"><span class="params">SpringApplicationRunListeners listeners)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// exitCode</span></span><br><span class="line">            handleExitCode(context, exception);</span><br><span class="line">            <span class="keyword">if</span> (listeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// failed</span></span><br><span class="line">                listeners.failed(context, exception);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 这里也是扩展的口子</span></span><br><span class="line">            reportFailure(exceptionReporters, exception);</span><br><span class="line">            <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">                context.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Unable to close ApplicationContext"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    ReflectionUtils.rethrowRuntimeException(exception);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码片段主要做了以下几件事：</p><ul><li>handleExitCode： 这里会拿到异常的 exitCode，随后发布一个 ExitCodeEvent 事件，最后交由 SpringBootExceptionHandler 处理。</li><li>SpringApplicationRunListeners#failed： 循环遍历调用所有 SpringApplicationRunListener 的 failed 方法</li><li>reportFailure：用户可以自定义扩展 SpringBootExceptionReporter 接口来实现定制化的异常上报逻辑</li></ul><p>在 SpringApplicationRunListeners#failed 中，业务产生的异常将直接被抛出，而不会影响异常处理的主流程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，SpringBoot 启动的主流程已经全部分析完成了。从扩展和扩展时机的角度来看，整个过程中，SpringBoot 提供了非常多的扩展口子，让用户可以在容器启动的各个阶段（无论是启动，环境准备，容器刷新等等）做一些定制化的操作。用户可以利用这些扩展接口来修改 bean 、修改环境变量，给用户极大的空间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;个人博客：&lt;a href=&quot;https://juejin.im/user/58fcc0768d6d810058965a06&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;glmapper&lt;/a&gt;&lt;br&gt;更多请关注 &lt;strong&gt;
      
    
    </summary>
    
      <category term="springboot" scheme="http://www.glmapper.com/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://www.glmapper.com/tags/springboot/"/>
    
  </entry>
  
</feed>
