<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>glmapper</title>
  
  <subtitle>大家都喊我磊叔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.glmapper.com/"/>
  <updated>2019-04-13T14:12:37.306Z</updated>
  <id>http://www.glmapper.com/</id>
  
  <author>
    <name>GuoLei Song</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ZooKeeper 客户端之 Curator</title>
    <link href="http://www.glmapper.com/2019/04/13/zookeeper-client-curator/"/>
    <id>http://www.glmapper.com/2019/04/13/zookeeper-client-curator/</id>
    <published>2019-04-13T14:09:30.000Z</published>
    <updated>2019-04-13T14:12:37.306Z</updated>
    
    <content type="html"><![CDATA[<p>ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p><p>Curator 是 Netflix 公司开源的一套  Zookeeper 客户端框架，解决了很多 Zookeeper 客户端非常底层的细节开发工作，包括连接重连、反复注册 Watcher 和 NodeExistsException 异常等等。Curator 包含了几个包：</p><ul><li>curator-framework：对 Zookeeper 的底层 api 的一些封装</li><li>curator-client：提供一些客户端的操作，例如重试策略等</li><li>curator-recipes：封装了一些高级特性，如：Cache 事件监听、选举、分布式锁、分布式计数器、分布式Barrier 等</li></ul><h2 id="Curator-和-zookeeper-的版本问题"><a href="#Curator-和-zookeeper-的版本问题" class="headerlink" title="Curator 和 zookeeper 的版本问题"></a>Curator 和 zookeeper 的版本问题</h2><p>目前 Curator 有 2.x.x 和 3.x.x 两个系列的版本，支持不同版本的 Zookeeper。其中Curator 2.x.x 兼容 Zookeeper的 3.4.x 和 3.5.x。而 Curator 3.x.x 只兼容 Zookeeper 3.5.x，并且提供了一些诸如动态重新配置、watch删除等新特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Curator 2.x.x - compatible with both ZooKeeper 3.4.x and ZooKeeper 3.5.x</span><br><span class="line">Curator 3.x.x - compatible only with ZooKeeper 3.5.x and includes support for new</span><br></pre></td></tr></table></figure><p>如果跨版本会有兼容性问题，很有可能导致节点操作失败，我当时在使用的时候就踩了这个坑，抛了如下的异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KeeperErrorCode = Unimplemented for /***</span><br></pre></td></tr></table></figure><h2 id="Curator-API"><a href="#Curator-API" class="headerlink" title="Curator   API"></a>Curator   API</h2><p>这里就不对比与原生 API 的区别了，Curator 的 api 直接通过 org.apache.curator.framework.CuratorFramework 接口来看，并结合相应的案例进行使用，以备后用。</p><blockquote><p>为了可以直观的看到zookeeper 的节点信息，可以考虑弄一个zk的管控界面，常见的有 zkui 和 zkweb。</p><p>zkui：<a href="https://github.com/DeemOpen/zkui" target="_blank" rel="noopener">https://github.com/DeemOpen/zkui</a></p><p>zkweb：<a href="https://github.com/zhitom/zkweb" target="_blank" rel="noopener">https://github.com/zhitom/zkweb</a></p><p>我用的 zkweb ，虽然界面上看起来没有 zkui 精简，但是在层次展示和一些细节上感觉比 zkui 好一点</p></blockquote><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>之前写的一个在 <a href="http://www.glmapper.com/2019/03/04/zk-on-linux">Linux 上安装部署 Zookeeper</a> 的笔记，其他操作系统请自行谷歌教程吧；</p><p>本文案例工程已经同步到了 github，<a href="https://github.com/glmapper/glmapper-blog-samples" target="_blank" rel="noopener">传送门</a>。</p><blockquote><p>PS : 目前还没有看过Curator的具体源码，所以不会涉及到任何源码解析、实现原理的东西；本篇主要是实际使用时的一些记录，以备后用。如果文中错误之处，希望各位指出。</p></blockquote><h2 id="Curator-客户端的初始化和初始化时机"><a href="#Curator-客户端的初始化和初始化时机" class="headerlink" title="Curator 客户端的初始化和初始化时机"></a>Curator 客户端的初始化和初始化时机</h2><p>在实际的工程中，Zookeeper 客户端的初始化会在程序启动期间完成。</p><h3 id="初始化时机"><a href="#初始化时机" class="headerlink" title="初始化时机"></a>初始化时机</h3><p>在 Spring 或者 SpringBoot 工程中最常见的就是绑定到容器启动的生命周期或者应用启动的生命周期中：</p><ul><li>监听 ContextRefreshedEvent 事件，在容器刷新完成之后初始化 Zookeeper</li><li>监听 ApplicationReadyEvent/ApplicationStartedEvent 事件，初始化 Zookeeper 客户端</li></ul><p>除了上面的方式之外，还有一种常见的是绑定到 bean 的生命周期中</p><ul><li>实现 InitializingBean 接口 ，在 afterPropertiesSet 中完成 Zookeeper 客户端初始化</li></ul><blockquote><p>关于 SpringBoot中的事件机制可以参考之前写过的一篇文章：<a href="https://juejin.im/post/5c2af8915188252a94130422#heading-8" target="_blank" rel="noopener">SpringBoot-SpringBoot中的事件机制</a>。</p></blockquote><h3 id="Curator-初始化"><a href="#Curator-初始化" class="headerlink" title="Curator 初始化"></a>Curator 初始化</h3><p>这里使用 InitializingBean 的这种方式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperCuratorClient</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CuratorFramework curatorClient;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;glmapper.zookeeper.address:localhost:2181&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String           connectString;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;glmapper.zookeeper.baseSleepTimeMs:1000&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>              baseSleepTimeMs;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;glmapper.zookeeper.maxRetries:3&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>              maxRetries;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;glmapper.zookeeper.sessionTimeoutMs:6000&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>              sessionTimeoutMs;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;glmapper.zookeeper.connectionTimeoutMs:6000&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>              connectionTimeoutMs;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// custom policy</span></span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(baseSleepTimeMs, maxRetries);</span><br><span class="line">        <span class="comment">// to build curatorClient</span></span><br><span class="line">        curatorClient = CuratorFrameworkFactory.builder().connectString(connectString)</span><br><span class="line">                .sessionTimeoutMs(sessionTimeoutMs).connectionTimeoutMs(connectionTimeoutMs)</span><br><span class="line">                .retryPolicy(retryPolicy).build();</span><br><span class="line">        curatorClient.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CuratorFramework <span class="title">getCuratorClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curatorClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>glmapper.zookeeper.xxx 是本例中需要在配置文件中配置的 zookeeper 的一些参数，参数解释如下：</p><ul><li>baseSleepTimeMs：重试之间等待的初始时间</li><li>maxRetries：最大重试次数</li><li>connectString：要连接的服务器列表</li><li>sessionTimeoutMs：session 超时时间</li><li>connectionTimeoutMs：连接超时时间</li></ul><p>另外，Curator 客户端初始化时还需要指定重试策略，RetryPolicy 接口是 Curator 中重试连接(当zookeeper失去连接时使用)策略的顶级接口，其类继承体系如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/13/16a17065aa98b194?w=1024&amp;h=302&amp;f=png&amp;s=73757" alt=""></p><ul><li>RetryOneTime：只重连一次</li><li>RetryNTime：指定重连的次数N</li><li>RetryUtilElapsed：指定最大重连超时时间和重连时间间隔，间歇性重连直到超时或者链接成功</li><li>ExponentialBackoffRetry：基于 “backoff”方式重连，和 RetryUtilElapsed 的区别是重连的时间间隔是动态的。</li><li>BoundedExponentialBackoffRetry： 同 ExponentialBackoffRetry的区别是增加了最大重试次数的控制</li></ul><p>除上述之外，在一些场景中，需要对不同的业务进行隔离，这种情况下，可以通过设置 namespace 来解决，namespace 实际上就是指定zookeeper的根路径，设置之后，后面的所有操作都会基于该根目录。</p><h2 id="Curator-基础-API-使用"><a href="#Curator-基础-API-使用" class="headerlink" title="Curator 基础 API 使用"></a>Curator 基础 API 使用</h2><h3 id="检查节点是否存在"><a href="#检查节点是否存在" class="headerlink" title="检查节点是否存在"></a>检查节点是否存在</h3><p>checkExists 方法返回的是一个 ExistsBuilder 构造器，这个构建器将返回一个 Stat 对象，就像调用了 org.apache.zookeeper.ZooKeeper.exists()一样。null 表示它不存在，而实际的 Stat 对象表示存在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkNodeExist</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Stat stat = curatorClient.checkExists().forPath(path);</span><br><span class="line">    <span class="keyword">if</span> (stat != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"path = "</span>+path +<span class="string">" has bean exist."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议在实际的应用中，操作节点时对所需操作的节点进行 checkExists。</p><h3 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h3><ul><li><p>非递归方式创建节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.create().forPath(&quot;/glmapper&quot;);</span><br><span class="line">curatorClient.create().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure><p>先创建/glmapper，然后再在/glmapper 下面创建 /test ，如果直接使用 /glmapper/test 没有先创建 /glmapper 时，会抛出异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.zookeeper.KeeperException$NoNodeException: KeeperErrorCode = NoNode for /glmapper/test</span><br></pre></td></tr></table></figure><p>如果需要在创建节点时指定节点中数据，则可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.create().forPath(&quot;/glmapper&quot;,&quot;data&quot;.getBytes());</span><br></pre></td></tr></table></figure><p>指定节点类型(EPHEMERAL 临时节点)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.create().withMode(CreateMode.EPHEMERAL).forPath(&quot;/glmapper&quot;,&quot;data&quot;.getBytes());</span><br></pre></td></tr></table></figure></li><li><p>递归方式创建节点</p><p>递归方式创建节点有两个方法，creatingParentsIfNeeded 和 creatingParentContainersIfNeeded。在新版本的 zookeeper 这两个递归创建方法会有区别； creatingParentContainersIfNeeded() 以容器模式递归创建节点，如果旧版本 zookeeper，此方法等于creatingParentsIfNeeded()。</p><p>在非递归方式情况下，如果直接创建 /glmapper/test 会报错，那么在递归的方式下则是可以的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.create().creatingParentContainersIfNeeded().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure><p>在递归调用中，如果不指定 CreateMode，则默认<code>PERSISTENT</code>，如果指定为临时节点，则最终节点会是临时节点，父节点仍旧是<code>PERSISTENT</code></p></li></ul><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><ul><li><p>非递归删除节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.delete().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure><p>指定具体版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.delete().withVersion(-1).forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure><p>使用 guaranteed 方式删除，guaranteed 会保证在session有效的情况下，后台持续进行该节点的删除操作，直到删除掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.delete().guaranteed().withVersion(-1).forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure></li><li><p>递归删除当前节点及其子节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.delete().deletingChildrenIfNeeded().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="获取节点数据"><a href="#获取节点数据" class="headerlink" title="获取节点数据"></a>获取节点数据</h3><p>获取节点数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte[] data = curatorClient.getData().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure><p>根据配置的压缩提供程序对数据进行解压缩处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte[] data = curatorClient.getData().decompressed().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure><p>读取数据并获得Stat信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stat stat = new Stat();</span><br><span class="line">byte[] data = curatorClient.getData().storingStatIn(stat).forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure><h3 id="更新节点数据"><a href="#更新节点数据" class="headerlink" title="更新节点数据"></a>更新节点数据</h3><p>设置指定值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.setData().forPath(&quot;/glmapper/test&quot;,&quot;newData&quot;.getBytes());</span><br></pre></td></tr></table></figure><p>设置数据并使用配置的压缩提供程序压缩数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.setData().compressed().forPath(&quot;/glmapper/test&quot;,&quot;newData&quot;.getBytes());</span><br></pre></td></tr></table></figure><p>设置数据，并指定版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.setData().withVersion(-1).forPath(&quot;/glmapper/test&quot;,&quot;newData&quot;.getBytes());</span><br></pre></td></tr></table></figure><h3 id="获取子列表"><a href="#获取子列表" class="headerlink" title="获取子列表"></a>获取子列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; childrenList = curatorClient.getChildren().forPath(&quot;/glmapper&quot;);</span><br></pre></td></tr></table></figure><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>Curator 也对 Zookeeper 典型场景之事件监听进行封装，这部分能力实在 curator-recipes 包下的。</p><h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><p>在使用不同的方法时会有不同的事件发生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CuratorEventType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Corresponds to &#123;@link CuratorFramework#create()&#125;</span></span><br><span class="line">    CREATE,</span><br><span class="line">    <span class="comment">//Corresponds to &#123;@link CuratorFramework#delete()&#125;</span></span><br><span class="line">    DELETE,</span><br><span class="line"><span class="comment">//Corresponds to &#123;@link CuratorFramework#checkExists()&#125;</span></span><br><span class="line">    EXISTS,</span><br><span class="line"><span class="comment">//Corresponds to &#123;@link CuratorFramework#getData()&#125;</span></span><br><span class="line">    GET_DATA,</span><br><span class="line"><span class="comment">//Corresponds to &#123;@link CuratorFramework#setData()&#125;</span></span><br><span class="line">    SET_DATA,</span><br><span class="line"><span class="comment">//Corresponds to &#123;@link CuratorFramework#getChildren()&#125;</span></span><br><span class="line">    CHILDREN,</span><br><span class="line"><span class="comment">//Corresponds to &#123;@link CuratorFramework#sync(String, Object)&#125;</span></span><br><span class="line">    SYNC,</span><br><span class="line"><span class="comment">//Corresponds to &#123;@link CuratorFramework#getACL()&#125;</span></span><br><span class="line">    GET_ACL,</span><br><span class="line"><span class="comment">//Corresponds to &#123;@link CuratorFramework#setACL()&#125;</span></span><br><span class="line">    SET_ACL,</span><br><span class="line"><span class="comment">//Corresponds to &#123;@link Watchable#usingWatcher(Watcher)&#125; or &#123;@link Watchable#watched()&#125;</span></span><br><span class="line">    WATCHED,</span><br><span class="line"><span class="comment">//Event sent when client is being closed</span></span><br><span class="line">    CLOSING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><h4 id="一次性监听方式：Watcher"><a href="#一次性监听方式：Watcher" class="headerlink" title="一次性监听方式：Watcher"></a>一次性监听方式：Watcher</h4><p>利用 Watcher 来对节点进行监听操作，可以典型业务场景需要使用可考虑，但一般情况不推荐使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">byte</span>[] data = curatorClient.getData().usingWatcher(<span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"监听器 watchedEvent："</span> + watchedEvent);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;).forPath(<span class="string">"/glmapper/test"</span>);</span><br><span class="line">System.out.println(<span class="string">"监听节点内容："</span> + <span class="keyword">new</span> String(data));</span><br><span class="line"><span class="comment">// 第一次变更节点数据</span></span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test"</span>,<span class="string">"newData"</span>.getBytes());</span><br><span class="line"><span class="comment">// 第二次变更节点数据</span></span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test"</span>,<span class="string">"newChangedData"</span>.getBytes());</span><br></pre></td></tr></table></figure><p>上面这段代码对 /glmapper/test 节点注册了一个 Watcher 监听事件，并且返回当前节点的内容。后面进行两次数据变更，实际上第二次变更时，监听已经失效，无法再次获得节点变动事件了。测试中控制台输出的信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">监听节点内容：data</span><br><span class="line">watchedEvent：WatchedEvent state:SyncConnected type:NodeDataChanged path:/glmapper/test</span><br></pre></td></tr></table></figure><h4 id="CuratorListener-方式"><a href="#CuratorListener-方式" class="headerlink" title="CuratorListener 方式"></a>CuratorListener 方式</h4><p>CuratorListener 监听，此监听主要针对 background 通知和错误通知。使用此监听器之后，调用inBackground 方法会异步获得监听，对于节点的创建或修改则不会触发监听事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CuratorListener listener = <span class="keyword">new</span> CuratorListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eventReceived</span><span class="params">(CuratorFramework client, CuratorEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"event : "</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="comment">// 绑定监听器</span></span><br><span class="line">curatorClient.getCuratorListenable().addListener(listener);</span><br><span class="line"><span class="comment">// 异步获取节点数据</span></span><br><span class="line">curatorClient.getData().inBackground().forPath(<span class="string">"/glmapper/test"</span>);</span><br><span class="line"><span class="comment">// 更新节点数据</span></span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test"</span>,<span class="string">"newData"</span>.getBytes());</span><br></pre></td></tr></table></figure><p>测试中控制台输出的信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">event : CuratorEventImpl&#123;type=GET_DATA, resultCode=0, path=&apos;/glmapper/test&apos;, name=&apos;null&apos;, children=null, context=null, stat=5867,5867,1555140974671,1555140974671,0,0,0,0,4,0,5867</span><br><span class="line">, data=[100, 97, 116, 97], watchedEvent=null, aclList=null&#125;</span><br></pre></td></tr></table></figure><p>这里只触发了一次监听回调，就是 getData 。</p><h4 id="Curator-引入的-Cache-事件监听机制"><a href="#Curator-引入的-Cache-事件监听机制" class="headerlink" title="Curator 引入的 Cache 事件监听机制"></a>Curator 引入的 Cache 事件监听机制</h4><p>Curator 引入了 Cache 来实现对 Zookeeper 服务端事件监听，Cache 事件监听可以理解为一个本地缓存视图与远程 Zookeeper 视图的对比过程。Cache 提供了反复注册的功能。Cache 分为两类注册类型：节点监听和子节点监听。</p><ul><li><p>NodeCache</p><p>监听数据节点本身的变化。对节点的监听需要配合回调函数来进行处理接收到监听事件之后的业务处理。NodeCache 通过 NodeCacheListener 来完成后续处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String path = <span class="string">"/glmapper/test"</span>;</span><br><span class="line"><span class="keyword">final</span> NodeCache nodeCache = <span class="keyword">new</span> NodeCache(curatorClient,path);</span><br><span class="line"><span class="comment">//如果设置为true则在首次启动时就会缓存节点内容到Cache中。 nodeCache.start(true);</span></span><br><span class="line">nodeCache.start();</span><br><span class="line">nodeCache.getListenable().addListener(<span class="keyword">new</span> NodeCacheListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"触发监听回调，当前节点数据为："</span> + <span class="keyword">new</span> String(nodeCache.getCurrentData().getData()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">curatorClient.setData().forPath(path,<span class="string">"1"</span>.getBytes());</span><br><span class="line">curatorClient.setData().forPath(path,<span class="string">"2"</span>.getBytes());</span><br><span class="line">curatorClient.setData().forPath(path,<span class="string">"3"</span>.getBytes());</span><br><span class="line">curatorClient.setData().forPath(path,<span class="string">"4"</span>.getBytes());</span><br><span class="line">curatorClient.setData().forPath(path,<span class="string">"5"</span>.getBytes());</span><br><span class="line">curatorClient.setData().forPath(path,<span class="string">"6"</span>.getBytes());</span><br></pre></td></tr></table></figure><p>注意：在测试过程中，nodeCache.start()，NodeCache 在先后多次修改监听节点的内容时，出现了丢失事件现象，在用例执行的5次中，仅一次监听到了全部事件；如果 nodeCache.start(true)，NodeCache 在先后多次修改监听节点的内容时，不会出现丢失现象。</p><blockquote><p>NodeCache不仅可以监听节点内容变化，还可以监听指定节点是否存在。如果原本节点不存在，那么Cache就会在节点被创建时触发监听事件，如果该节点被删除，就无法再触发监听事件。</p></blockquote></li><li><p>PathChildrenCache</p><p>PathChildrenCache 不会对二级子节点进行监听，只会对子节点进行监听。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">String path = <span class="string">"/glmapper"</span>;</span><br><span class="line">PathChildrenCache pathChildrenCache = <span class="keyword">new</span> PathChildrenCache(curatorClient,path,<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 如果设置为true则在首次启动时就会缓存节点内容到Cache中。 nodeCache.start(true);</span></span><br><span class="line">pathChildrenCache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);</span><br><span class="line">pathChildrenCache.getListenable().addListener(<span class="keyword">new</span> PathChildrenCacheListener() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework curatorFramework, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"-----------------------------"</span>);</span><br><span class="line">    System.out.println(<span class="string">"event:"</span>  + event.getType());</span><br><span class="line">    <span class="keyword">if</span> (event.getData()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      System.out.println(<span class="string">"path:"</span> + event.getData().getPath());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"-----------------------------"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">zookeeperCuratorClient.createNode(<span class="string">"/glmapper/test"</span>,<span class="string">"data"</span>.getBytes(),CreateMode.PERSISTENT);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test"</span>,<span class="string">"1"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test"</span>,<span class="string">"2"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">zookeeperCuratorClient.createNode(<span class="string">"/glmapper/test/second"</span>,<span class="string">"data"</span>.getBytes(),CreateMode.PERSISTENT);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test/second"</span>,<span class="string">"1"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test/second"</span>,<span class="string">"2"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>注意：在测试过程中发现，如果连续两个操作之间不进行一定时间的间隔，会导致无法监听到下一次事件。因此只会监听子节点，所以对二级子节点 /second 下面的操作是监听不到的。测试中控制台输出的信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------</span><br><span class="line">event:CHILD_ADDED</span><br><span class="line">path:/glmapper/test</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:INITIALIZED</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:CHILD_UPDATED</span><br><span class="line">path:/glmapper/test</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:CHILD_UPDATED</span><br><span class="line">path:/glmapper/test</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure></li><li><p>TreeCache</p><p>TreeCache 使用一个内部类<code>TreeNode</code>来维护这个一个树结构。并将这个树结构与ZK节点进行了映射。所以TreeCache 可以监听当前节点下所有节点的事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String path = <span class="string">"/glmapper"</span>;</span><br><span class="line">TreeCache treeCache = <span class="keyword">new</span> TreeCache(curatorClient,path);</span><br><span class="line">treeCache.getListenable().addListener((client,event)-&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"-----------------------------"</span>);</span><br><span class="line">    System.out.println(<span class="string">"event:"</span>  + event.getType());</span><br><span class="line">    <span class="keyword">if</span> (event.getData()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      System.out.println(<span class="string">"path:"</span> + event.getData().getPath());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"-----------------------------"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">treeCache.start();</span><br><span class="line">zookeeperCuratorClient.createNode(<span class="string">"/glmapper/test"</span>,<span class="string">"data"</span>.getBytes(),CreateMode.PERSISTENT);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test"</span>,<span class="string">"1"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test"</span>,<span class="string">"2"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">zookeeperCuratorClient.createNode(<span class="string">"/glmapper/test/second"</span>,<span class="string">"data"</span>.getBytes(),CreateMode.PERSISTENT);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test/second"</span>,<span class="string">"1"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test/second"</span>,<span class="string">"2"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>测试中控制台输出的信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------</span><br><span class="line">event:NODE_ADDED</span><br><span class="line">path:/glmapper</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:NODE_ADDED</span><br><span class="line">path:/glmapper/test</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:NODE_UPDATED</span><br><span class="line">path:/glmapper/test</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:NODE_UPDATED</span><br><span class="line">path:/glmapper/test</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:NODE_ADDED</span><br><span class="line">path:/glmapper/test/second</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:NODE_UPDATED</span><br><span class="line">path:/glmapper/test/second</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:NODE_UPDATED</span><br><span class="line">path:/glmapper/test/second</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure></li></ul><h2 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h2><p> CuratorFramework 的实例包含 inTransaction( ) 接口方法，调用此方法开启一个 ZooKeeper 事务。 可以复合create、 setData、 check、and/or delete 等操作然后调用 commit() 作为一个原子操作提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启事务  </span></span><br><span class="line">CuratorTransaction curatorTransaction = curatorClient.inTransaction();</span><br><span class="line">Collection&lt;CuratorTransactionResult&gt; commit = </span><br><span class="line">  <span class="comment">// 操作1 </span></span><br><span class="line">curatorTransaction.create().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">"/glmapper/transaction"</span>)</span><br><span class="line">  .and()</span><br><span class="line">  <span class="comment">// 操作2 </span></span><br><span class="line">  .delete().forPath(<span class="string">"/glmapper/test"</span>)</span><br><span class="line">  .and()</span><br><span class="line">  <span class="comment">// 操作3</span></span><br><span class="line">  .setData().forPath(<span class="string">"/glmapper/transaction"</span>, <span class="string">"data"</span>.getBytes())</span><br><span class="line">  .and()</span><br><span class="line">  <span class="comment">// 提交事务</span></span><br><span class="line">  .commit();</span><br><span class="line">Iterator&lt;CuratorTransactionResult&gt; iterator = commit.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">  CuratorTransactionResult next = iterator.next();</span><br><span class="line">  System.out.println(next.getForPath());</span><br><span class="line">  System.out.println(next.getResultPath());</span><br><span class="line">  System.out.println(next.getType());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里debug看了下Collection<curatortransactionresult>信息，面板如下：</curatortransactionresult></p><p><img src="https://user-gold-cdn.xitu.io/2019/4/13/16a1706f1bfb589c?w=2126&amp;h=890&amp;f=png&amp;s=558056" alt=""></p><h2 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h2><p>前面提到的增删改查都是同步的，但是 Curator 也提供了异步接口，引入了 BackgroundCallback 接口用于处理异步接口调用之后服务端返回的结果信息。BackgroundCallback 接口中一个重要的回调值为 CuratorEvent，里面包含事件类型、响应吗和节点的详细信息。</p><p>在使用上也是非常简单的，只需要带上 inBackground() 就行，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.getData().inBackground().forPath(<span class="string">"/glmapper/test"</span>);</span><br></pre></td></tr></table></figure><p>通过查看 inBackground 方法定义可以看到，inBackground 支持自定义线程池来处理返回结果之后的业务逻辑。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">inBackground</span><span class="params">(BackgroundCallback callback, Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p>这里就不贴代码了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要围绕 Curator 的基本 API 进行了学习记录，对于原理及源码部分没有涉及。这部分如果有时间在慢慢研究吧。另外像分布式锁、分布式自增序列等实现停留在理论阶段，没有实践，不敢妄论，用到再码吧。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.cnblogs.com/felixzh/p/5869212.html" target="_blank" rel="noopener">http://www.cnblogs.com/felixzh/p/5869212.html</a></li><li><a href="https://my.oschina.net/roccn/blog/918209" target="_blank" rel="noopener">https://my.oschina.net/roccn/blog/918209</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="zookeeper" scheme="http://www.glmapper.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Kafka简介&amp;集成SpringBoot</title>
    <link href="http://www.glmapper.com/2019/03/07/springboot-kafka-introduction/"/>
    <id>http://www.glmapper.com/2019/03/07/springboot-kafka-introduction/</id>
    <published>2019-03-06T16:08:19.000Z</published>
    <updated>2019-03-06T16:12:01.265Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 近期在做 SOFA 与 SpringCloud 的集成，希望通过一系列的 DEMO 工程去帮助大家更好的使用 SOFA 和 SpringCloud；同时也希望大家一起来参与共建和 star。</p><p>GitHub传送门：<a href="https://github.com/alipay/spring-cloud-sofastack-samples/issues/1" target="_blank" rel="noopener">spring-cloud-sofastack-samples</a></p></blockquote><h2 id="Kafka-简介"><a href="#Kafka-简介" class="headerlink" title="Kafka 简介"></a>Kafka 简介</h2><blockquote><p>官方网站：<a href="https://kafka.apache.org/" target="_blank" rel="noopener">https://kafka.apache.org/</a></p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/3/6/16953b2c0f37bd3f?w=500&amp;h=500&amp;f=png" alt="img"></p><h3 id="功能提供"><a href="#功能提供" class="headerlink" title="功能提供"></a>功能提供</h3><p>Apache Kafka™ 是 一个分布式数据流平台，从官方文档的解释来看，其职能大体如下：</p><ul><li>Publish and subscribe to streams of records, similar to a message queue or enterprise messaging system。发布和订阅数据流，与消息队列或企业级消息系统很像。</li><li>Store streams of records in a fault-tolerant durable way。具有很强容灾性的存储数据流</li><li>Process streams of records as they occur。及时的处理数据流。</li></ul><p>作为一个后端司机，大多数情况下都是把 Kafka 作为一个分布式消息队列来使用的，分布式消息队列可以提供应用解耦、流量消峰、消息分发等功能，已经是大型互联网服务架构不可缺少的基础设置了。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="topic-和-partition"><a href="#topic-和-partition" class="headerlink" title="topic 和 partition"></a>topic 和 partition</h4><p>Kafka 对数据提供的核心抽象，topic 是发布的数据流的类别或名称。topic 在 Kafka 中，支持多订阅者； 也就是说，topic 可以有零个、一个或多个消费者订阅写到相应 topic 的数据。对应每一个 topic，Kafka 集群会维护像一个如下这样的分区的日志：<br><img src="https://user-gold-cdn.xitu.io/2019/3/6/16953b447bde1972?w=416&amp;h=267&amp;f=png&amp;s=19579" alt="img"><br>每个 Partition 都是一个有序的、不可变的并且不断被附加的记录序列，也就是一个结构化提交日志（commit log）。为了保证唯一标性识 Partition 中的每个数据记录，Partition 中的记录每个都会被分配一个叫做偏移（offset）顺序的ID号。通过一个可配置的保留期，Kafka 集群会保留所有被发布的数据，不管它们是不是已经被消费者处理。例如，如果保留期设置为两天，则在发布记录后的两天内，数据都可以被消费，之后它将被丢弃以释放空间。 Kafka 的性能是不为因为数据量大小而受影响的，因此长时间存储数据并不成问题。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/6/16953b472c441053?w=2041&amp;h=1243&amp;f=png&amp;s=139658" alt="img"><br>事实上，在每个消费者上保留的唯一元数据是消费者在日志中的偏移位置，这个偏移由消费者控制：通常消费者会在读取记录时线性地提高其偏移值（offset++），但实际上，由于偏移位置由消费者控制，它可以以任何顺序来处理数据记录。 例如，消费者可以重置为较旧的偏移量以重新处理来自过去的数据，或者跳过之前的记录，并从“现在”开始消费。 这种特征的组合意味着 Kafka 消费者非常轻量级，随意的开启和关闭并不会对其他的消费者有大的影响。</p><p>日志中的 Partition 有几个目的：</p><ul><li>保证日志的扩展性，topic 的大小不受单个服务器大小的限制。每个单独的 Partition 大小必须小于托管它的服务器磁盘大小，但 topic 可能有很多 Partition，因此它可以处理任意数量的海量数据。</li><li>作为并行处理的单位 (<a href="https://www.zhihu.com/question/28925721/answer/139861200" target="_blank" rel="noopener">知乎-Partition</a>：Kafka可以将主题划分为多个分区（Partition），会根据分区规则选择把消息存储到哪个分区中，只要如果分区规则设置的合理，那么所有的消息将会被均匀的分布到不同的分区中，这样就实现了负载均衡和水平扩展。另外，多个订阅者可以从一个或者多个分区中同时消费数据，以支撑海量数据处理能力)</li></ul><h4 id="kafka中的topic为什么要进行分区"><a href="#kafka中的topic为什么要进行分区" class="headerlink" title="kafka中的topic为什么要进行分区"></a>kafka中的topic为什么要进行分区</h4><blockquote><p>原贴：<a href="https://www.zhihu.com/question/28925721" target="_blank" rel="noopener">kafka中的topic为什么要进行分区</a> ，由于不能转载，此处不摘抄原文~</p></blockquote><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>生产者将数据发布到他们选择的 topic ， 生产者负责选择要吧数据分配给 topic 中哪个 Partition。这可以通过循环方式（round-robin）简单地平衡负载，或者可以根据某些语义进行分区（例如基于数据中的某些关键字）来完成。</p><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>消费者们使用消费群组(<em>consumer group</em> )名称来标注自己，几个消费者共享一个 group，每一个发布到 topic 的数据会被传递到每个消费群组(<em>consumer group</em> )中的一个消费者实例。 消费者实例可以在不同的进程中或不同的机器上。</p><p>如果所有的消费者实例具有相同的 consumer group，则记录将在所有的消费者实例上有效地负载平衡</p><p>如果所有的消费者实例都有不同的 consumer group，那么每个记录将被广播给所有的消费者进程，每个数据都发到了所有的消费者。<br><img src="https://user-gold-cdn.xitu.io/2019/3/6/16953b5f8c6e51e8?w=474&amp;h=200&amp;f=png&amp;s=26820" alt="img"></p><blockquote><p>上图解释源自<a href="http://ifeve.com/kafka-introduction/" target="_blank" rel="noopener">《Kafka 官方文档》 介绍</a>：</p><p>如上图，一个两个服务器节点的Kafka集群， 托管着4个分区(P0-P3)，分为两个消费者群. 消费者群A有2个消费者实例，消费者群B有4个. 然而，更常见的是，我们发现主题具有少量的消费者群，每个消费者群代表一个“逻辑订户”。每个组由许多消费者实例组成，保证可扩展性和容错能力。这可以说是“发布-订阅”语义，但用户是一组消费者而不是单个进程。 在Kafka中实现消费的方式，是通过将日志中的分区均分到消费者实例上，以便每个实例在任何时间都是“相应大小的一块”分区的唯一消费者。维护消费者组成员资格的过程，由卡夫卡协议动态处理。 如果新的实例加入组，他们将从组中的其他成员接管一些分区; 如果一个实例消失，其分区将被分发到剩余的实例。 Kafka仅提供单个<em>分区内</em>的记录的顺序，而不是主题中的不同分区之间的总顺序。 每个分区排序结合按键分区，足以满足大多数应用程序的需求。 但是，如果您需要使用总顺序，则可以通过仅具有一个分区的主题来实现，尽管这仅意味着每个消费者组只有一个消费者进程。</p></blockquote><h3 id="Kafka-作为消息系统"><a href="#Kafka-作为消息系统" class="headerlink" title="Kafka 作为消息系统"></a>Kafka 作为消息系统</h3><p>消息系统传统上有两种模式: <a href="http://en.wikipedia.org/wiki/Message_queue" target="_blank" rel="noopener">队列</a>和<a href="http://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" target="_blank" rel="noopener">发布-订阅</a>。 </p><ul><li>队列模式中，消费者池可以从服务器读取，每条记录只会被某一个消费者消费<ul><li>允许在多个消费者实例上分配数据处理，但是一旦数据被消费之后，数据就没有了</li></ul></li><li>发布订阅模式中，记录将广播给所有消费者<ul><li>允许将数据广播到多个进程，但无法缩放和扩容，因为每个消息都发送给每个订阅用户</li></ul></li></ul><blockquote><p>本篇只介绍 Kafka 作为消息队列的一些基本概念，更多介绍请参考<a href="https://kafka.apache.org/intro" target="_blank" rel="noopener">官方文档</a>。</p></blockquote><h2 id="Kafka-安装"><a href="#Kafka-安装" class="headerlink" title="Kafka 安装"></a>Kafka 安装</h2><p>这里来看下如何安装 kafka，下载地址：<a href="https://kafka.apache.org/downloads。本篇使用的版本是" target="_blank" rel="noopener">https://kafka.apache.org/downloads。本篇使用的版本是</a> <strong>kafka_2.12-1.1.1</strong>。</p><ul><li><p>获取包文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; wget http://mirrors.shu.edu.cn/apache/kafka/1.1.1/kafka_2.12-1.1.1.tgz</span><br></pre></td></tr></table></figure></li><li><p>解压压缩包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; tar -zxvf kafka_2.12-1.1.1.tgz</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cd kafka_2.12-1.1.1/config</span><br><span class="line">&gt; vim server.properties</span><br></pre></td></tr></table></figure><p>我这里主要修改项包括以下几个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># The id of the broker. This must be set to a unique integer for each broker.</span><br><span class="line">broker.id=0</span><br><span class="line"></span><br><span class="line">listeners=PLAINTEXT://192.168.0.1:9092</span><br><span class="line"></span><br><span class="line">advertised.listeners=PLAINTEXT://192.168.0.1:9092</span><br><span class="line"># zookeeper 地址，可以多个</span><br><span class="line">zookeeper.connect=192.168.0.6:2181</span><br></pre></td></tr></table></figure><p>  Kafka 服务启动需要依赖 Zookeeper ，所以在配置文件中需要指定 Zookeeper 集群地址。Kafka 自己的安装包中解压之后是包括 Zookeeper 的，可以通过以下的方式来启动一个单节点 Zookeeper 实例：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; sh zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br></pre></td></tr></table></figure><blockquote><p>这里我是指定了之前部署的一台ZK机器，所以可以直接将ZK地址指到已部署好的地址。Zookeeper 安装可以参考： <a href="http://www.glmapper.com/2019/03/04/zk-on-linux/">Linux 下安装 Zookeeper</a> </p></blockquote><p>  通过上述操作，下面就可以直接来启动Kafka 服务了：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; sh kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure></li></ul><h2 id="SpringBoot-集成-Kafka"><a href="#SpringBoot-集成-Kafka" class="headerlink" title="SpringBoot 集成 Kafka"></a>SpringBoot 集成 Kafka</h2><h3 id="构建一个简单的-Kafka-Producer-工具依赖"><a href="#构建一个简单的-Kafka-Producer-工具依赖" class="headerlink" title="构建一个简单的 Kafka Producer 工具依赖"></a>构建一个简单的 Kafka Producer 工具依赖</h3><ul><li>依赖引入</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="comment">&lt;!--$NO-MVN-MAN-VER$--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>producer</li></ul><p>为了可以把 Kafka 封装已提供给其他模块使用，大家可以将 Kafka 的生产端工具类使用 SpringBoot 的自动配置机制进行包装，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaProducerAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KafkaSender <span class="title">kafkaSender</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KafkaSender(kafkaTemplate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>KafkaSender</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaSender</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KafkaSender</span><span class="params">(KafkaTemplate&lt;String, String&gt; kafkaTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kafkaTemplate = kafkaTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * send message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String topic, String message)</span> </span>&#123;</span><br><span class="line">        kafkaTemplate.send(topic, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自动配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">io.sofastack.cloud.core.kafka.configuration.KafkaProducerAutoConfiguration</span><br></pre></td></tr></table></figure><p>工程模块如下：<br>image-20190306151759441.png<br><img src="https://user-gold-cdn.xitu.io/2019/3/6/16953bb00a2a4276?w=1728&amp;h=610&amp;f=png&amp;s=205269" alt=""></p><h3 id="案例测试"><a href="#案例测试" class="headerlink" title="案例测试"></a>案例测试</h3><p>在测试工程中引入依赖，这个依赖就是上面工程打包来的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.sofastack.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofastack-cloud-core-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>在 resources 目录下新建 application.properties 配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#============== kafka ===================</span><br><span class="line"># 指定kafka 代理地址，可以多个,这里的192.168.0.1是上面Kafka 启动配置文件中对应的</span><br><span class="line"># 注：网上一些帖子中说 Kafka 这里的配置只能是主机名，不支持 ip，没有验证过，</span><br><span class="line"># 如果您在验证时出现问题，可以尝试本机绑定下 host</span><br><span class="line">spring.kafka.bootstrap-servers= 192.168.0.1:9092</span><br><span class="line">#=============== provider  =======================</span><br><span class="line">spring.kafka.producer.retries=0</span><br><span class="line"># 每次批量发送消息的数量</span><br><span class="line">spring.kafka.producer.batch-size=16384</span><br><span class="line">spring.kafka.producer.buffer-memory=33554432</span><br><span class="line"># 指定消息key和消息体的编解码方式</span><br><span class="line">spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line">spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line">#=============== consumer  =======================</span><br><span class="line"># 指定默认消费者group id</span><br><span class="line">spring.kafka.consumer.group-id=test-consumer-group</span><br><span class="line">spring.kafka.consumer.auto-offset-reset=earliest</span><br><span class="line">spring.kafka.consumer.enable-auto-commit=true</span><br><span class="line">spring.kafka.consumer.auto-commit-interval=100ms</span><br><span class="line"># 指定消息key和消息体的编解码方式</span><br><span class="line">spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line">spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line">spring.application.name=kafka-test</span><br><span class="line">logging.path=./logs</span><br></pre></td></tr></table></figure></li><li><p>启动类中模拟发送消息</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:application-kafka.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext run = SpringApplication.run(ProviderApplication.class, args);</span><br><span class="line">        <span class="comment">// 这里通过容器获取，正常使用情况下，可以直接使用 Autowired 注入</span></span><br><span class="line">        KafkaSender bean = run.getBean(KafkaSender.class);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//调用消息发送类中的消息发送方法</span></span><br><span class="line">            bean.sendMessage(KafkaContants.TRADE_TOPIC, <span class="string">"send a test message"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编写消费者，在 SpringBoot 工程中，消费者实现非常简单</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaReceiver</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 配置监听的主体，groupId 和配置文件中的保持一致</span></span><br><span class="line">    <span class="meta">@KafkaListener</span>(topics = &#123; KafkaContants.TRADE_TOPIC &#125;, groupId = <span class="string">"test-consumer-group"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(ConsumerRecord&lt;?, ?&gt; record)</span> </span>&#123;</span><br><span class="line">        Optional&lt;?&gt; kafkaMessage = Optional.ofNullable(record.value());</span><br><span class="line">        <span class="keyword">if</span> (kafkaMessage.isPresent()) &#123;</span><br><span class="line">            Object message = kafkaMessage.get();</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动工程后，可以在控制台看下消费者打印的信息：<br><img src="https://user-gold-cdn.xitu.io/2019/3/7/16953bcf93439fac?w=1890&amp;h=138&amp;f=png&amp;s=145531" alt=""><br>这里保持应用正常运行，再通过服务端来手动发送消息，看下是当前消费者能够正确监听到对应的 topic 并消费。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; sh kafka-console-producer.sh --broker-list 192.168.0.1:9092 --topic trading</span><br></pre></td></tr></table></figure></p><p>执行上述命令之后，命令行将会等待输入，这里输入先后输入 glmapper 和 sofa :<br><img src="https://user-gold-cdn.xitu.io/2019/3/7/16953bda46779241?w=902&amp;h=79&amp;f=png&amp;s=21656" alt=""><br>然后再看下应用程序控制台输入结果如下：<br>image-20190306153452565.png<br><img src="https://user-gold-cdn.xitu.io/2019/3/7/16953be13fac86d4?w=1906&amp;h=188&amp;f=png&amp;s=51083" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://kafka.apache.org/intro" target="_blank" rel="noopener">Introduction</a></li><li><a href="http://ifeve.com/kafka-introduction/#more-32041" target="_blank" rel="noopener">《Kafka 官方文档》介绍</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 近期在做 SOFA 与 SpringCloud 的集成，希望通过一系列的 DEMO 工程去帮助大家更好的使用 SOFA 和 SpringCloud；同时也希望大家一起来参与共建和 star。&lt;/p&gt;
&lt;p&gt;GitHub传送门：&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="springboot" scheme="http://www.glmapper.com/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://www.glmapper.com/tags/springboot/"/>
    
      <category term="kafka" scheme="http://www.glmapper.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下安装 Zookeeper</title>
    <link href="http://www.glmapper.com/2019/03/04/zk-on-linux/"/>
    <id>http://www.glmapper.com/2019/03/04/zk-on-linux/</id>
    <published>2019-03-04T12:29:18.000Z</published>
    <updated>2019-03-04T12:39:21.968Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装-Zookeeper"><a href="#安装-Zookeeper" class="headerlink" title="安装 Zookeeper"></a>安装 Zookeeper</h2><p>目前 Curator 有 2.x.x 和 3.x.x 两个系列的版本，支持不同版本的 Zookeeper。其中 Curator 2.x.x 兼容 Zookeeper的 3.4.x 和 3.5.x。而 Curator 3.x.x 只兼容 Zookeeper 3.5.x。</p><blockquote><p>Curator 2.x.x - compatible with both ZooKeeper 3.4.x and ZooKeeper 3.5.x<br>Curator 3.x.x - compatible only with ZooKeeper 3.5.x and includes support for new</p></blockquote><p>选择使用 3.4.x 版本 Zookeeper。</p><ul><li><p><a href="http://apache.fayea.com/zookeeper/" target="_blank" rel="noopener">下载 Zookeeper</a> ，选择相应的版本，这里以 3.4.13 版本为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> wget http://apache.fayea.com/zookeeper/zookeeper-3.4.13/zookeeper-3.4.13.tar.gz</span></span><br></pre></td></tr></table></figure><p>  执行上述命令进行下载，下载完成之后对文件进行解压。</p></li><li><p>解压文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> tar -zxvf zookeeper-3.4.13.tar.gz</span></span><br></pre></td></tr></table></figure></li><li><p>创建数据和日志目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> zookeeper-3.4.13</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mkdir data</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mkdir logs</span></span><br></pre></td></tr></table></figure></li><li><p>配置文件修改<br>首先将默认的 zoo_sample.cfg 命名为 zoo.cfg</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> conf</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cp zoo_sample.cfg zoo.cfg</span></span><br></pre></td></tr></table></figure><p>  编辑 zoo.cfg ， 将数据目录和日志目录路径修改为上述步骤中创建的两个文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置dataDir 和 dataLogDir</span></span><br><span class="line">dataDir=/home/admin/server/zookeeper-3.4.13/data</span><br><span class="line">dataLogDir=/home/admin/server/zookeeper-3.4.13/logs</span><br></pre></td></tr></table></figure></li><li><p>启动 zookeeper<br>到你安装的zookeeper的bin目录下，如：/home/admin/server/zookeeper-3.4.13/bin</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> /home/admin/server/zookeeper-3.4.13/bin</span></span><br></pre></td></tr></table></figure><p>  执行 start 启动</p><pre><code class="shell"><span class="meta">&gt;</span><span class="bash"> zkServer.sh start</span></code></pre><p>上述是简单的在 linux 环境下安装配置 Zookeeper 的过程，对于在实际的生成环境，请根据自己项目需求进行更加细化的配置。</p></li></ul><h2 id="安装-Zookeeper-可视化工具"><a href="#安装-Zookeeper-可视化工具" class="headerlink" title="安装 Zookeeper 可视化工具"></a>安装 Zookeeper 可视化工具</h2><p>为了可以直观的看到 zookeeper 的节点信息，可以考虑部署一个 zookeeper 的管控界面，常见的有 zkui 和 zkweb。</p><ul><li><a href="https://github.com/DeemOpen/zkui" target="_blank" rel="noopener">zkui</a></li><li><a href="https://github.com/zhitom/zkweb" target="_blank" rel="noopener">zkweb</a></li></ul><p>zkui 界面更加简单一点，zkweb 在一些细节展示上更加有优势，这里推荐使用  zkweb。具体部署方式见官方文档。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装-Zookeeper&quot;&gt;&lt;a href=&quot;#安装-Zookeeper&quot; class=&quot;headerlink&quot; title=&quot;安装 Zookeeper&quot;&gt;&lt;/a&gt;安装 Zookeeper&lt;/h2&gt;&lt;p&gt;目前 Curator 有 2.x.x 和 3.x.x 两个系
      
    
    </summary>
    
      <category term="运维" scheme="http://www.glmapper.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="linux" scheme="http://www.glmapper.com/tags/linux/"/>
    
      <category term="zookeeper" scheme="http://www.glmapper.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-网关 Gateway 入门体验</title>
    <link href="http://www.glmapper.com/2019/01/19/springcloud-gateway-predicate-project/"/>
    <id>http://www.glmapper.com/2019/01/19/springcloud-gateway-predicate-project/</id>
    <published>2019-01-18T16:21:33.000Z</published>
    <updated>2019-01-18T16:26:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>网关服务核心是将进入的请求正确合理的路由到下层具体的服务进行业务处理，从它的功能来看，网关服务的核心就是路由信息的构建。</p><p>Spring Cloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Netflix Zuul，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全、监控、埋点和限流等。下面是官方提供的一个工作原理图：</p><p><img src="https://oscimg.oschina.net/oscnet/e9d92479a1dbcdf618d33918468b30c2c8b.jpg" alt=""></p><p>客户端发送请求到 Spring Cloud Gateway，Gateway Handler Mapping 确定请求与路由匹配，则会将请求交给Gateway Web Handler 处理。在代理前后可以执行多个过滤器。最后代理到具体的服务。</p><h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><ul><li>Route：Gateway 中的基本元素，它有自己的 ID、URI 、 Predicate 集合和 Filter 集合</li><li>Predicate：判断请求的 Url 是否匹配当前的 Route</li><li>Filter ：匹配通过之后对请求和响应的处理及修饰</li></ul><p>Spring-Cloud-Gateway 构建路由的数据流向：</p><p><img src="https://oscimg.oschina.net/oscnet/2d7cd3c3fd3452d70112893a4c175943ae0.jpg" alt=""></p><p>RouteDefinition 模型是对 Route 模型中 route 的定义以及描述，Spring-Cloud-Gateway 最终会通过RouteDefinition 来构建起 Route 实例信息。其中 RouteDefinition 代码包含两个数组分别是PredicateDefinition，FilterDefinition。</p><h3 id="内置的-Predicate"><a href="#内置的-Predicate" class="headerlink" title="内置的 Predicate"></a>内置的 Predicate</h3><p>Spring Cloud Gateway 是通过 Spring WebFlux 的 <code>HandlerMapping</code> 做为底层支持来匹配到转发路由，Spring Cloud Gateway 内置了很多 Predicates 工厂，这些 Predicates 工厂通过不同的 HTTP 请求参数来匹配，多个 Predicates 工厂可以组合使用。下面是内置的Predicates：</p><table><thead><tr><th>组件</th><th>备注</th></tr></thead><tbody><tr><td>After Route Predicate Factory</td><td>此谓词匹配当前日期时间之后发生的请求。</td></tr><tr><td>Before Route Predicate Factory</td><td>此谓词匹配在当前日期时间之前发生的请求。</td></tr><tr><td>Between Route Predicate Factory</td><td>此谓词匹配datetime1之后和datetime2之前发生的请求。 datetime2参数必须在datetime1之后。</td></tr><tr><td>Cookie Route Predicate Factory</td><td>Cookie Route Predicate Factory有两个参数，cookie名称和正则表达式。此谓词匹配具有给定名称且值与正则表达式匹配的cookie。</td></tr><tr><td>Header Route Predicate Factory</td><td>Header Route Predicate Factory有两个参数，标题名称和正则表达式。与具有给定名称且值与正则表达式匹配的标头匹配。</td></tr><tr><td>Host Route Predicate Factory</td><td>Host Route Predicate Factory采用一个参数：主机名模式。该模式是一种Ant样式模式“.”作为分隔符。此谓词匹配与模式匹配的Host标头。</td></tr><tr><td>Method Route Predicate Factory</td><td>Method Route Predicate Factory采用一个参数：要匹配的HTTP方法。</td></tr><tr><td>Path Route Predicate Factory</td><td>匹配请求的path</td></tr><tr><td>Query Route Predicate Factory</td><td>Query Route Predicate Factory有两个参数：一个必需的参数和一个可选的正则表达式。</td></tr><tr><td>RemoteAddr Route Predicate Factory</td><td>RemoteAddr Route Predicate Factory采用CIDR符号（IPv4或IPv6）字符串的列表（最小值为1），例如， 192.168.0.1/16（其中192.168.0.1是IP地址，16是子网掩码）。</td></tr></tbody></table><h2 id="工程代码"><a href="#工程代码" class="headerlink" title="工程代码"></a>工程代码</h2><p>本篇将通过一个简单的 gateway 工程来演示如何使用上面的 Predicate 来实现路由。</p><h3 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h3><p>这里新建一个 <a href="https://github.com/glmapper/glmapper-cloud-parent" target="_blank" rel="noopener">glmapper-cloud-gateway</a> 工程，具体细节如下</p><h3 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h3><p>首先在当前工程的pom文件中引入spring cloud gateway 的依赖：spring-cloud-starter-gateway</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件部分，除了常规的端口，应用名之外；关于spring cloud 的路由规则也可以通过配置文件进行配置，下面先以最简单的 path的方式来演示，最终达到的目标是，当输入：<a href="http://localhost:8866/gateway" target="_blank" rel="noopener">http://localhost:8866/gateway</a> 时，请求信息将会被路由到 <a href="http://localhost:8086/hello" target="_blank" rel="noopener">http://localhost:8086/hello</a>(这个是一个eureka client，对外提供rest服务，工程详见<a href="https://github.com/glmapper/glmapper-cloud-parent/tree/master/glmapper-eureka-provider" target="_blank" rel="noopener">glmapper-eureka-provider</a>)。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span>   <span class="comment">#eureka server 的地址</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8866</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">glmapper-cloud-gateway</span>  <span class="comment">#应用名</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://localhost:8086/hello</span>   <span class="comment">#目标地址</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Path=/gateway</span>   <span class="comment">#路由规则</span></span><br></pre></td></tr></table></figure><h3 id="启动应用-amp-验证"><a href="#启动应用-amp-验证" class="headerlink" title="启动应用&amp;验证"></a>启动应用&amp;验证</h3><p>这里直接启动这个工程，SpringCloud Gateway 不需要额外的注解来开启网关服务，所以这里省略启动类的代码。先后启动 glmapper-eureka-server 、glmapper-eureka-provider、glmapper-cloud-gateway。</p><p>在浏览器中输入：<a href="http://localhost:8866/gateway" target="_blank" rel="noopener">http://localhost:8866/gateway</a> ，输出的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Glmapper! Now Port is 8086 And hostname is HelloGlmapperService</span><br></pre></td></tr></table></figure><p>这里输出的实际上是  <a href="http://localhost:8086/hello" target="_blank" rel="noopener">http://localhost:8086/hello</a> 提供的资源，说明我们的路由规则已经生效。</p><h2 id="内置-Predicate-规则配置"><a href="#内置-Predicate-规则配置" class="headerlink" title="内置 Predicate 规则配置"></a>内置 Predicate 规则配置</h2><p>上面已经罗列了所有的 spring cloud gateway 一些内置的 Predicate  ，下面将来使用这些规则来演示下。</p><h3 id="时间匹配"><a href="#时间匹配" class="headerlink" title="时间匹配"></a>时间匹配</h3><p>Predicate 支持设置一个时间，在请求进行转发的时候，可以通过判断在这个时间之前或者之后进行转发。在上面的列表中可以看出，基于时间的匹配支持某时间节点之前、之后，还支持介于两个时间之间的某个时间段内的匹配。基于某个时间段内的匹配规则常见的场景是限时抢购。</p><ul><li>After Route Predicate</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span>     <span class="comment">#自定义的路由ID</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://www.glmapper.com</span> <span class="comment">#目标服务地址</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">After=2019-01-10T00:00:00+08:00[Asia/Shanghai]</span> <span class="comment">#通过时间匹配 2019年1月10日</span></span><br></pre></td></tr></table></figure><p>After Route Predicate 是指在这个时间之后的请求都转发到目标地址。请求时间在 2019年1月10日日00点00分00秒之后的所有请求都转发到地址 <a href="http://www.glmapper.com。+08:00是指时间和UTC时间相差八个小时，时间地区为" target="_blank" rel="noopener">http://www.glmapper.com。+08:00是指时间和UTC时间相差八个小时，时间地区为</a> Asia/Shanghai。</p><ul><li>Before Route Predicate</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span>     <span class="comment">#自定义的路由ID</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://www.glmapper.com</span> <span class="comment">#目标服务地址</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Before=2019-01-10T00:00:00+08:00[Asia/Shanghai]</span> <span class="comment">#通过时间匹配 2019年1月10日</span></span><br></pre></td></tr></table></figure><p>Before Route Predicate 与 After Route Predicate 刚好相反，在某个时间之前的请求的请求都进行转发。</p><ul><li>Between Route Predicate</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">       - id:</span> <span class="string">glmapper</span><span class="comment">#自定义的路由ID</span></span><br><span class="line">       <span class="attr">uri:</span> <span class="attr">http://www.glmapper.com</span><span class="comment">#目标服务地址</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">         -</span> <span class="string">Between=2019-01-10T00:00:00+08:00[Asia/Shanghai],</span> <span class="number">2019</span><span class="bullet">-01</span><span class="bullet">-10</span><span class="attr">T06:00:00+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure><p>在2019年1月10 零点至6点之间的请求将会被路由到 <a href="http://www.glmapper.com">http://www.glmapper.com</a> ，其他的请求将不会被路由。</p><h3 id="Cookie-或者-Header"><a href="#Cookie-或者-Header" class="headerlink" title="Cookie 或者 Header"></a>Cookie 或者 Header</h3><ul><li>Cookie Route Predicate</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://localhost:8086/hello</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Cookie=name,glmapper</span></span><br></pre></td></tr></table></figure><p>这里，如果我的请求信息中存在 cookie name 为 glmapper，值匹配到 glmapper 的串，那么请求将会被路由。</p><p><img src="https://oscimg.oschina.net/oscnet/05fc182cf12e602fa1e7e467c83d7b31da3.jpg" alt="cookie"></p><blockquote><p>PS：这里在配置的时候要注意下 routes 后面格式缩进，否则会抛出一些异常，如：</p><pre><code>Property: spring.cloud.gateway.routes[0].uriValue: nullReason: 不能为nullProperty: spring.cloud.gateway.routes[0].predicatesValue: []Reason: 不能为空</code></pre></blockquote><p>当cookie的值不满足时，访问时404</p><p><img src="https://oscimg.oschina.net/oscnet/680e41ff99bcc15910217ba1ec40812d9a6.jpg" alt="cookie404"></p><ul><li>Header Route Predicate</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">glmapper-cloud-gateway</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://localhost:8086/hello</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br></pre></td></tr></table></figure><p>上面这段配置用于配置 Header 中 X-Request-Id值数字的请求：</p><p><img src="https://oscimg.oschina.net/oscnet/2a88bdad6acd7902f2415089e943b3390f0.jpg" alt="header"></p><p>同样，如果是非数字的话将会返回 404。</p><h3 id="域名匹配"><a href="#域名匹配" class="headerlink" title="域名匹配"></a>域名匹配</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">glmapper-cloud-gateway</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://localhost:8086/hello</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Host=**.glmapper.com</span></span><br></pre></td></tr></table></figure><p>上面这段配置用于匹配 host 为 xxx.glmapper.com 域名的请求：</p><p><img src="https://oscimg.oschina.net/oscnet/b2b68159505c906007107ecd2195bcb7326.jpg" alt="host"></p><p>关于其他的内置 Predicate 均可在官方文档中有实例参考，这里就不一一罗列了。</p><h3 id="组合匹配"><a href="#组合匹配" class="headerlink" title="组合匹配"></a>组合匹配</h3><p>最后我们来将上面的一些进行组合，假设我需要在 <code>2019.1.10 0点至2019.1.10 6点之间，cookie中带有name=glmapper，header 的 X-Request-Id 为数字，域名是 xx.glmapper.com ，path为 /gateway ，请求方式为GET，参数名为queryParam</code> 的请求路由到 <a href="http://localhost:8086/hello。那么具体配置如下" target="_blank" rel="noopener">http://localhost:8086/hello。那么具体配置如下</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">glmapper-cloud-gateway</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://localhost:8086/hello</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Host=**.glmapper.com</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Path=/gateway</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Method=GET</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Header=X-Request-Id,\d+</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Query=queryParam</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Cookie=name,glmapper</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Between=2019-01-10T00:00:00+08:00[Asia/Shanghai],</span> <span class="number">2019</span><span class="bullet">-01</span><span class="bullet">-10</span><span class="attr">T06:00:00+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure><p>还是通过curl 命令来执行以下：</p><p><img src="https://oscimg.oschina.net/oscnet/d78beeac5d4959ba1ade7577c0e54ba9489.jpg" alt="composite"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.0.2.RELEASE/single/spring-cloud-gateway.html#gateway-starter" target="_blank" rel="noopener">Spring Cloud Gateway</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网关服务核心是将进入的请求正确合理的路由到下层具体的服务进行业务处理，从它的功能来看，网关服务的核心就是路由信息的构建。&lt;/p&gt;
&lt;p&gt;Spring Cloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Netflix Zuul，其不仅提
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="Gateway" scheme="http://www.glmapper.com/tags/Gateway/"/>
    
      <category term="网关" scheme="http://www.glmapper.com/tags/%E7%BD%91%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-断路器 Hystrix</title>
    <link href="http://www.glmapper.com/2019/01/09/springcloud-hystrix-project/"/>
    <id>http://www.glmapper.com/2019/01/09/springcloud-hystrix-project/</id>
    <published>2019-01-09T11:28:18.000Z</published>
    <updated>2019-01-09T14:46:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Hystrix 是 Netflix 的一个开源项目，它能够在服务失效的情况下，通过隔离系统依赖服务的方式，防止服务级联失败，造成服务雪崩。同时Hystrix 还提供了失败回滚机制，使得系统能够更快的从异常中恢复。Hystrix 为服务间调用提供了保护和控制。</p><p>Hystrix 具有的功能如下：</p><ul><li>当通过客户端调用服务出现高延迟或者调用失败时，能够为系统提供保护机制</li><li>在复杂的分布式场景下，可以防止服务雪崩效应</li><li>提供快速失败（Fail Fast） 同时能够快速恢复</li><li>提供失败回滚和优雅的服务降级机制</li><li>提供近实时的监控、报警和运维控制手段</li></ul><p>Hystrix 在实际应用过程中的使用方式很丰富，可以通过注解，也可以通过集成 HystrixCommand 和HystrixObservableCommand 。本篇将通过案例简单说明下说用方式。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK</td><td>1.8.0_162</td></tr><tr><td>SOFABoot/SpringBoot</td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE</td></tr><tr><td>SpringCloud</td><td>Finchley.RC1</td></tr><tr><td>IDE</td><td>IDEA</td></tr></tbody></table><h2 id="工程背景"><a href="#工程背景" class="headerlink" title="工程背景"></a>工程背景</h2><p>本节将会创建一个 sofa-hystrix-client 工程，通过 Spring Cloud 提供的负载均衡器 hystrix 实现服务的熔断降级。</p><h2 id="新建-sofa-hystrix-client"><a href="#新建-sofa-hystrix-client" class="headerlink" title="新建 sofa-hystrix-client"></a>新建 sofa-hystrix-client</h2><p>本工程继续使用《SpringCloud-Eureka 服务注册》中的父工程来构建。</p><p>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p><ul><li>artifactId：sofa-hystrix-client</li></ul><h3 id="修改pom文件"><a href="#修改pom文件" class="headerlink" title="修改pom文件"></a>修改pom文件</h3><p>pom文件中加入 hysterix 的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">hystrix-client</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8787</span></span><br></pre></td></tr></table></figure><p>没有什么特殊的配置，还是作为一个 eureka-client 存在。</p><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>启动类上增加开启断路器的注解@EnableCircuitBreaker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaHystrixApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaHystrixApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="资源类"><a href="#资源类" class="headerlink" title="资源类"></a>资源类</h3><ul><li>NormalService </li></ul><p>中通过@HystrixCommand标准一个受保护的资源方法 getByServiceId()。getByServiceId 中通过restTemplate 来调用远程服务。@HystrixCommand注解的 fallbackMethod 属性指定当服务不可用时需要执行的 fallback 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"fallBack"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getByServiceId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://HELLOSOFABOOTSERVICE/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">fallBack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Filed to get data"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>HystrixRibbonController：通过instanceService调用上面的NormalService资源类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixRibbonController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> NormalService instanceService;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hystrix"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instanceService.getByServiceId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动-amp-验证"><a href="#启动-amp-验证" class="headerlink" title="启动&amp;验证"></a>启动&amp;验证</h3><p>先后启动sofa-eureka-server-center 、sofa-eureka-provider、sofa-hystrix-client 三个工程。浏览器中输入：</p><p><a href="http://localhost:8787/hystrix" target="_blank" rel="noopener">http://localhost:8787/hystrix</a> ，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello SOFA! Now Port is 8086 And hostname is HelloSOFABootService</span><br></pre></td></tr></table></figure><p>关闭 sofa-eureka-provider ，刷新浏览器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Filed to get data</span><br></pre></td></tr></table></figure><p>执行了 NormalService 中的 fallback 方法了。</p><h2 id="资源隔离"><a href="#资源隔离" class="headerlink" title="资源隔离"></a>资源隔离</h2><p>hystrix 中提供了两中隔离策略，一种是基于线程池的隔离、另外一种是基于信号量的隔离。本篇只演示案例，具体原理请参看 hystrix 原理分析 相关文章。</p><h3 id="基于线程池的隔离实现"><a href="#基于线程池的隔离实现" class="headerlink" title="基于线程池的隔离实现"></a>基于线程池的隔离实现</h3><p>新建一个 SofaThreadPoolHystrixCommand 类，继承 HystrixCommand。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaThreadPoolHystrixCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SofaThreadPoolHystrixCommand</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initailize());</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HystrixCommand.<span class="function">Setter <span class="title">initailize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 线程池配置</span></span><br><span class="line">        HystrixThreadPoolProperties.Setter hystrixThreadPoolProperties = </span><br><span class="line">            HystrixThreadPoolProperties.Setter()</span><br><span class="line">                .withCoreSize(<span class="number">5</span>)</span><br><span class="line">                .withKeepAliveTimeMinutes(<span class="number">5</span>)</span><br><span class="line">                <span class="comment">// 线程等待队列最大长度,默认值:-1 表示不等待直接拒绝,测试表明线程池使用直接决绝策略+ 合适大小的非回缩线程池效率最高.所以不建议修改此值。</span></span><br><span class="line">                .withMaxQueueSize(<span class="number">10</span>)</span><br><span class="line">                .withQueueSizeRejectionThreshold(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 命令属性配置,这里指定隔离策略是 THREAD</span></span><br><span class="line">        HystrixCommandProperties.Setter hystrixCommand = </span><br><span class="line">            HystrixCommandProperties.Setter() .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD)</span><br><span class="line">                <span class="comment">//意味着线程最多允许执行fallback的并发数为10,超过10 报fallback execution rejected</span></span><br><span class="line">                .withFallbackIsolationSemaphoreMaxConcurrentRequests(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        HystrixCommand.Setter setter = HystrixCommand.Setter</span><br><span class="line">            .withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"SofaThreadPoolHystrixCommand"</span>))</span><br><span class="line">                .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">"sofaBootService"</span>))</span><br><span class="line">                .andCommandPropertiesDefaults(hystrixCommand)</span><br><span class="line">                .andThreadPoolPropertiesDefaults(hystrixThreadPoolProperties)</span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">"sofa-hystrix-thread"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> setter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 受保护的资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://HELLOSOFABOOTSERVICE/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 失败执行的保护方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"this is fail back policy"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关参数说明：</p><ul><li>HystrixCommandGroupKey：配置全局唯一标识服务分组的名称，比如账户系统就是一个服务分组，监控时，相同分组的服务会聚合在一起，必填选项。</li><li>HystrixCommandKey：配置全局唯一标识服务的名称，比如账户系统有一个获取账号名的服务，那么就可以为这个服务起一个名字来唯一识别该服务，如果不配置，则默认是简单类名。</li><li>HystrixThreadPoolKey：配置全局唯一标识线程池的名称，相同线程池名称的线程池是同一个，如果不配置，则默认是分组名，此名字也是线程池中线程名字的前缀。</li><li>HystrixThreadPoolProperties：配置线程池参数</li><li>HystrixCommandProperties：配置该命令的一些参数，如 executionIsolationStrategy 配置执行隔离策略，默认是使用线程隔离。配置为 THREAD，线程池隔离；配置为 SEMAPHORE ，信号量隔离</li></ul><p>这里为了模拟并发，使用 CountDownLatch 类来控制，在 HystrixRibbonController 中添加 testThread 资源方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testThread"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUM; i ++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ConsumerThread(countDownLatch)).start();</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.countDown();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"data"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部定义一个内部类，模拟调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startLatch;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConsumerThread</span><span class="params">(CountDownLatch startLatch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.startLatch = startLatch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 线程等待</span></span><br><span class="line">                startLatch.await();</span><br><span class="line">                <span class="comment">// 执行操作</span></span><br><span class="line">                SofaThreadPoolHystrixCommand sofaThreadPoolHystrixCommand = <span class="keyword">new</span> SofaThreadPoolHystrixCommand(restTemplate);</span><br><span class="line">                System.out.println(sofaThreadPoolHystrixCommand.execute().toString());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重启当前工程，浏览器执行 <a href="http://localhost:8787/testThread" target="_blank" rel="noopener">http://localhost:8787/testThread</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this is fail back policy</span><br><span class="line">this is fail back policy</span><br><span class="line">this is fail back policy</span><br><span class="line">this is fail back policy</span><br><span class="line">this is fail back policy</span><br><span class="line">// ... 省略</span><br><span class="line">Hello SOFA! Now Port is 8086 And hostname is HelloSOFABootService</span><br><span class="line">// ... 省略</span><br></pre></td></tr></table></figure><h3 id="基于信号量隔离"><a href="#基于信号量隔离" class="headerlink" title="基于信号量隔离"></a>基于信号量隔离</h3><p>新建一个 SofaSemaphoreHystrixCommand 类，继承 HystrixCommand。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaSemaphoreHystrixCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SofaSemaphoreHystrixCommand</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initailize());</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HystrixCommand.<span class="function">Setter <span class="title">initailize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 命令属性配置,这里指定隔离策略是 THREAD</span></span><br><span class="line">        HystrixCommandProperties.Setter hystrixCommand = HystrixCommandProperties.Setter()</span><br><span class="line">                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.SEMAPHORE)</span><br><span class="line">                 <span class="comment">//至少有10个请求，熔断器才进行错误率的计算</span></span><br><span class="line">                .withCircuitBreakerRequestVolumeThreshold(<span class="number">0</span>)</span><br><span class="line">                <span class="comment">//熔断器中断请求5秒后会进入半打开状态,放部分流量过去重试</span></span><br><span class="line">                .withCircuitBreakerSleepWindowInMilliseconds(<span class="number">5000</span>)</span><br><span class="line">                <span class="comment">//错误率达到50开启熔断保护</span></span><br><span class="line">                .withCircuitBreakerErrorThresholdPercentage(<span class="number">50</span>)</span><br><span class="line">                <span class="comment">//最大并发请求量</span></span><br><span class="line">                .withExecutionIsolationSemaphoreMaxConcurrentRequests(<span class="number">10</span>)</span><br><span class="line">                <span class="comment">//意味着信号量最多允许执行fallback的并发数为10,超过10 报fallback execution rejected</span></span><br><span class="line">                .withFallbackIsolationSemaphoreMaxConcurrentRequests(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        HystrixCommand.Setter setter = HystrixCommand.Setter.</span><br><span class="line">                withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"SofaSemaphoreHystrixCommand"</span>))</span><br><span class="line">                .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">"sofaBootService"</span>))</span><br><span class="line">                .andCommandPropertiesDefaults(hystrixCommand)</span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">"sofa-hystrix-thread"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> setter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 受保护的资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://HELLOSOFABOOTSERVICE/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 失败执行的保护方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"this is fail back policy"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样使用 CountDownLatch  来模拟并发。在 HystrixRibbonController 中添加 testSemaphore 资源方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testSemaphore"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testSemaphore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUM; i ++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ConsumerSemaphore(countDownLatch)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"data"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>内部定义一个内部类 ConsumerSemaphore ，模拟调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerSemaphore</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startLatch;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConsumerSemaphore</span><span class="params">(CountDownLatch startLatch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.startLatch = startLatch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 线程等待</span></span><br><span class="line">                startLatch.await();</span><br><span class="line">                <span class="comment">// 执行操作</span></span><br><span class="line">                SofaSemaphoreHystrixCommand sofaThreadPoolHystrixCommand = <span class="keyword">new</span> SofaSemaphoreHystrixCommand(restTemplate);</span><br><span class="line">                System.out.println(sofaThreadPoolHystrixCommand.execute().toString());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果和线程隔离的差不多。不贴结果了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Hystrix 是 Netflix 的一个开源项目，它能够在服务失效的情况下，通过隔离系统依赖服务的方式，防止服务级联失败，造成服务雪崩。同
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="spring cloud" scheme="http://www.glmapper.com/tags/spring-cloud/"/>
    
      <category term="Hystrix" scheme="http://www.glmapper.com/tags/Hystrix/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-配置中心 Apollo</title>
    <link href="http://www.glmapper.com/2019/01/09/springcloud-config-apollo/"/>
    <id>http://www.glmapper.com/2019/01/09/springcloud-config-apollo/</id>
    <published>2019-01-09T11:18:42.000Z</published>
    <updated>2019-01-09T15:40:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Apollo（阿波罗）是携程框架部门研发的开源配置管理中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性。</p><p>本篇将搭建一套 Apollo 配置中心环境，并通过一个 demo 案例来演示如何在 SpringCloud 体系中使用 Apollo。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK</td><td>1.8.0_162</td></tr><tr><td>SOFABoot/SpringBoot</td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE</td></tr><tr><td>SpringCloud</td><td>Finchley.RC1</td></tr><tr><td>IDE</td><td>IDEA</td></tr><tr><td>Mysql</td><td>5.7.24</td></tr><tr><td>CentOS</td><td>7</td></tr></tbody></table><p> Apollo 自身需要依赖 Mysql，在部署 Apollo 时需要提前安装 Mysql 数据库。关于 Mysql 的安装可以参考：<a href="http://www.glmapper.com/2019/01/05/mysql-on-linux/">Linux 下安装Mysql数据库</a>。</p><p>根据官方文档，Apollo 服务端需运行在 jdk 1.8 以上，客户端需运行在1.7 以上，Mysql 版本需在 5.6.5 版本以上。具体信息可参考：<a href="https://github.com/ctripcorp/apollo/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">分布式部署指南</a>。</p><h2 id="部署-Apollo"><a href="#部署-Apollo" class="headerlink" title="部署 Apollo"></a>部署 Apollo</h2><p>部署步骤共三步：</p><ul><li><p>创建数据库</p><ul><li>Apollo 服务端依赖于 MySQL 数据库，所以需要事先创建并完成初始化</li></ul></li><li><p>获取安装包</p><ul><li>Apollo 服务端安装包共有3个：apollo-configservice, apollo-adminservice, apollo-portal</li><li>可以直接下载事先打好的安装包，也可以自己通过源码构建</li></ul></li><li><p>部署 Apollo 服务端</p><ul><li>获取安装包后就可以部署到公司的测试和生产环境了</li></ul></li></ul><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>Apollo 服务端共需要两个数据库：<code>ApolloPortalDB</code>和<code>ApolloConfigDB</code>，我们把数据库、表的创建和样例数据都分别准备了 sql 文件，只需要导入数据库即可。</p><blockquote><p>需要注意的是 ApolloPortalDB 只需要在生产环境部署一个即可，而 ApolloConfigDB 需要在每个环境部署一套，如 fat、uat 和 pro 分别部署 3 套 ApolloConfigDB。</p></blockquote><blockquote><p>注意：如果本地已经创建过 Apollo 数据库，请注意备份数据；sql 文件会清空 Apollo 相关的表。</p></blockquote><p>两份 SQL 文件：</p><ul><li><a href="https://github.com/ctripcorp/apollo/blob/master/scripts/db/migration/portaldb/V1.0.0__initialization.sql" target="_blank" rel="noopener">apolloportaldb.sql</a></li><li><a href="https://github.com/ctripcorp/apollo/blob/master/scripts/db/migration/configdb/V1.0.0__initialization.sql" target="_blank" rel="noopener">apolloconfigdb.sql</a></li></ul><p>下载下来之后可通过 Mysql 图形界面工具(如 Navicat )等进行导入。导入完成之后，可以进行如下验证。</p><h4 id="portalDB-验证"><a href="#portalDB-验证" class="headerlink" title="portalDB 验证"></a>portalDB 验证</h4><p>执行 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">`Id`</span>, <span class="string">`Key`</span>, <span class="string">`Value`</span>, <span class="string">`Comment`</span> <span class="keyword">from</span> <span class="string">`ApolloPortalDB`</span>.<span class="string">`ServerConfig`</span> <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>查询结果：</p><table><thead><tr><th>Id</th><th>Key</th><th>Value</th><th>Comment</th></tr></thead><tbody><tr><td>1</td><td>apollo.portal.envs</td><td>dev</td><td>可支持的环境列表</td></tr></tbody></table><h4 id="configDB-验证"><a href="#configDB-验证" class="headerlink" title="configDB 验证"></a>configDB 验证</h4><p>执行 SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">`Id`</span>, <span class="string">`Key`</span>, <span class="string">`Value`</span>, <span class="string">`Comment`</span> <span class="keyword">from</span> <span class="string">`ApolloConfigDB`</span>.<span class="string">`ServerConfig`</span> <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>执行结果：</p><table><thead><tr><th>Id</th><th>Key</th><th>Value</th><th>Comment</th></tr></thead><tbody><tr><td>1</td><td>eureka.service.url</td><td><a href="http://127.0.0.1:8080/eureka/" target="_blank" rel="noopener">http://127.0.0.1:8080/eureka/</a></td><td>Eureka服务Url</td></tr></tbody></table><blockquote><p>本过程只针对新建工程，如果涉及到数据迁移，请参考 Apollo 官方文档</p></blockquote><p>数据库部分完成之后，接下来就是部署 Apollo 的三个工程。</p><h3 id="工程配置修改"><a href="#工程配置修改" class="headerlink" title="工程配置修改"></a>工程配置修改</h3><p>Apollo 配置中心 使用需要启动三个工程：apollo-configservice、apollo-adminservice、apollo-portal。</p><p>在自己的服务器上新建一个目录 /thirdserver/apollo/ 将官方提供的安装包直接下载到这个目录下，然后解压得到如下列表：</p><p><img src="https://oscimg.oschina.net/oscnet/20886e6df68aa3e20bc026e77811ae9bf5b.jpg" alt="image-20190107114836135"></p><h4 id="apollo-configservice-部署"><a href="#apollo-configservice-部署" class="headerlink" title="apollo-configservice 部署"></a>apollo-configservice 部署</h4><p>Apollo 服务端需要知道如何连接到你前面创建的数据库，数据库连接串信息位于上一步下载的压缩包中的<code>apollo-configservice-1.2.0-github/config/application-github.properties</code>中，这里把里面默认的数据库连接地址和账密信息替换成我们自己的就可以。这里使用的是 ApolloConfigDB 库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># DataSource</span><br><span class="line">spring.datasource.url = jdbc:mysql://$&#123;serverhost&#125;:3306/ApolloConfigDB?characterEncoding=utf8</span><br><span class="line">spring.datasource.username = $&#123;yourusername&#125;</span><br><span class="line">spring.datasource.password = $&#123;yourpassword&#125;</span><br></pre></td></tr></table></figure><h4 id="apollo-adminservice-配置文件修改"><a href="#apollo-adminservice-配置文件修改" class="headerlink" title="apollo-adminservice 配置文件修改"></a>apollo-adminservice 配置文件修改</h4><p>这里同样是修改  config/application-github.properties 下面的数据库连接信息。这里也使用的是 ApolloConfigDB 库。配置信息和上面一样。</p><h4 id="apollo-portal-配置文件修改"><a href="#apollo-portal-配置文件修改" class="headerlink" title="apollo-portal 配置文件修改"></a>apollo-portal 配置文件修改</h4><ul><li><p>portal 使用的是 ApolloPortalDB，修改数据库配置信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># DataSource</span><br><span class="line">spring.datasource.url = jdbc:mysql://$&#123;serverhost&#125;:3306/ApolloPortalDB?characterEncoding=utf8</span><br><span class="line">spring.datasource.username = $&#123;yourusername&#125;</span><br><span class="line">spring.datasource.password = $&#123;yourpassword&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改 meta service 信息，Apollo Portal 需要在不同的环境访问不同的 meta service(apollo-configservice) 地址，所以我们需要在配置中提供这些信息。默认情况下，meta service 和 config service 是部署在同一个 JVM进程，所以 meta service 的地址就是 config service 的地址。配置文件  /config/apollo-env.properties </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># $&#123;serverhost&#125; 是你当前机器的主机地址</span><br><span class="line">local.meta=http://localhost:8080</span><br><span class="line">dev.meta=http://$&#123;serverhost&#125;:8080</span><br><span class="line">fat.meta=http://$&#123;serverhost&#125;:8080</span><br><span class="line">uat.meta=http://$&#123;serverhost&#125;:8080</span><br><span class="line">lpt.meta=http://$&#123;serverhost&#125;:8080</span><br><span class="line">pro.meta=http://$&#123;serverhost&#125;:8080</span><br></pre></td></tr></table></figure><p>这里是把所有环境配置成一样的了，如果没有不需要这些环境，可以删除掉。</p></li></ul><h3 id="工程部署"><a href="#工程部署" class="headerlink" title="工程部署"></a>工程部署</h3><p>在每一个工程的解压包中，都有一个 scripts 文件夹，这里面是 Apollo 工程的启动脚本。三个工程分别先后启动：apollo-configservice、apollo-adminservice、apollo-portal，就是分别执行这三个工程下面的 /scripts/startup.sh 脚本即可，关闭执行的是 /scripts/shutdown.sh 脚本。</p><p>访问：http://${serverhost}:8070/</p><p><img src="https://oscimg.oschina.net/oscnet/2e9128be00850d0a34e9a437c37250f5757.jpg" alt="image-20190107133404554"></p><p>可以看到配置中心管控端的界面。</p><h3 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h3><ul><li>点击 创建项目，填写一些基本信息，然后提交</li></ul><p><img src="https://oscimg.oschina.net/oscnet/9829aa94cc189b32e6b8ed1958aa2ba7646.jpg" alt="image-20190107133541629"></p><ul><li>新增一个配置项，填写基本信息，然后提交</li></ul><p><img src="https://oscimg.oschina.net/oscnet/3004cbe4c0af7a9e376a4ab34d4d5d7e90b.jpg" alt="image-20190107133835832"></p><ul><li>当前工程界面</li></ul><p><img src="https://oscimg.oschina.net/oscnet/cce2da4dec2286f502863b33337d9110845.jpg" alt="image-20190107133936932"></p><ul><li>发布配置</li></ul><p><img src="https://oscimg.oschina.net/oscnet/3c0448a87c7124bb7e3ac170a269537a8e4.jpg" alt="image-20190107134958570"></p><h2 id="SpringCloud-工程案例"><a href="#SpringCloud-工程案例" class="headerlink" title="SpringCloud 工程案例"></a>SpringCloud 工程案例</h2><p>新建 sofa-config-apollo 工程。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>引入 apollo 客户端依赖及其他相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ctrip.framework.apollo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>apollo-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 需要与前面 Apollo 中创建项目的appId保持一致</span><br><span class="line">app.id=sofa-config-apollo</span><br><span class="line"># 设置 apollo meta service 的地址，因为前面meta和config是部署在一起的，所以就是configService的地址</span><br><span class="line">apollo.meta=http://$&#123;serverhost&#125;:8080</span><br><span class="line"># 配置项</span><br><span class="line">sofa.alipay.glmapper.name=glmapper</span><br></pre></td></tr></table></figure><h3 id="资源类-amp-启动类"><a href="#资源类-amp-启动类" class="headerlink" title="资源类&amp;启动类"></a>资源类&amp;启动类</h3><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><p>启动类上需要开启对 apollo 的支持，使用 @EnableApolloConfig 注解标注</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableApolloConfig</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaConfigApolloApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaConfigApolloApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="资源类"><a href="#资源类" class="headerlink" title="资源类"></a>资源类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApolloConfigController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApolloConfig</span></span><br><span class="line">    <span class="keyword">private</span> Config config;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;sofa.alipay.glmapper.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/apollo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，我在配置文件中指定的是 sofa.alipay.glmapper.name 值是 glmapper，而在配置中心配置的值是glmapper@leishu。同时这里也把 apollo 自己的这个 Config 配置类也注入进来，稍后看下这的对象的信息。</p><h3 id="运行程序-amp-验证"><a href="#运行程序-amp-验证" class="headerlink" title="运行程序&amp;验证"></a>运行程序&amp;验证</h3><p>启动当前工程之前需要确保 Apollo 的相关服务已经起来了，然后运行当前应用。在浏览器中输入：</p><p><a href="http://localhost:8080/config" target="_blank" rel="noopener">http://localhost:8080/config</a> ，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glmapper@leishu</span><br></pre></td></tr></table></figure><p>可以看到这里拿到的是配置中心的配置值，覆盖了我们本地配置文件中的配置。断点看到 config 的信息：</p><p><img src="https://oscimg.oschina.net/oscnet/617181dcfdd599e4fe37c85a7a5f9889049.jpg" alt="image-20190107140226085"></p><p>Config 对象就是当前集群环境下，指定 appId 的所有配置信息的集合。</p><h4 id="更改配置-amp-及时刷新"><a href="#更改配置-amp-及时刷新" class="headerlink" title="更改配置&amp;及时刷新"></a>更改配置&amp;及时刷新</h4><ul><li>更改配置</li></ul><p><img src="https://oscimg.oschina.net/oscnet/8cbe27b1b8334b0d866a0cd7af8fbe938b5.jpg" alt="image-20190107142508567"></p><ul><li>发布配置</li></ul><p><img src="https://oscimg.oschina.net/oscnet/277990a3c311039e4b3ac14593a19ffe32d.jpg" alt="image-20190107142537478"></p><ul><li>刷新 <a href="http://localhost:8080/apollo" target="_blank" rel="noopener">http://localhost:8080/apollo</a> 地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glmapper@leishu-update</span><br></pre></td></tr></table></figure><p>这里没有重启服务，配置动态更新了</p><h4 id="ApolloConfigChangeListener-来监听配置变更"><a href="#ApolloConfigChangeListener-来监听配置变更" class="headerlink" title="@ApolloConfigChangeListener 来监听配置变更"></a>@ApolloConfigChangeListener 来监听配置变更</h4><p>资源类 ApolloConfigController 中增加一个监听方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApolloConfigChangeListener</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(ConfigChangeEvent changeEvent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"发生变更了..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后重新在配置中心的界面上修改配置值：glmapper@leishu-update -&gt; glmapper@leishu-update-event，然后发布。然后可以在控制台看到日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发生变更了...</span><br><span class="line">2019-01-07 14:36:08.939  INFO 39072 --- [Apollo-Config-1] c.f.a.s.p.AutoUpdateConfigChangeListener : Auto update apollo changed value successfully, new value: glmapper@leishu-update-event, key: sofa.alipay.glmapper.name, beanName: apolloConfigController, field: com.alipay.sofa.cloud.controller.ApolloConfigController.name</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Apollo（阿波罗）是携程框架部门研发的开源配置管理中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="Config" scheme="http://www.glmapper.com/tags/Config/"/>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/tags/spring-cloud/"/>
    
      <category term="Apollo" scheme="http://www.glmapper.com/tags/Apollo/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-Config 配置中心原理</title>
    <link href="http://www.glmapper.com/2019/01/05/springcloud-config-analysis/"/>
    <id>http://www.glmapper.com/2019/01/05/springcloud-config-analysis/</id>
    <published>2019-01-05T13:03:20.000Z</published>
    <updated>2019-01-05T13:10:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇可以配合《<a href="http://www.glmapper.com/2018/12/31/springcoud-config-project/">SpringCloud-配置中心 Config</a>》来看，《<a href="http://www.glmapper.com/2018/12/31/springcoud-config-project/">SpringCloud-配置中心 Config</a>》中是基于SOFABoot 来集成 Spring Cloud Config 的一个 demo 案例。</p><p>在demo中，涉及到三个角色：</p><ul><li>配置中心服务端：为配置客户端提供对应的配置信息，配置信息的来源是配置仓库。应用启动时，会从配置仓库拉取配置信息缓存到本地仓库中。</li><li>配置中心客户端：应用启动时从配置服务端拉取配置信息。</li><li>配置仓库：为配置中心服务端提供配置信息存储，Spring Cloud Config 默认是使用git作为仓库的。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/3586089d566730b5fc6f5df08e96e5bb0b1.jpg" alt="image.png"></p><p>整体过程：</p><ul><li>环境部署之前，将所需的配置信息推送到配置仓库</li><li>启动配置中心服务端，将配置仓库的配置信息拉取到服务端，配置服务端对外提供REST接口</li><li>启动配置客户端，客户端根据 spring.cloud.config 配置的信息去服务器拉取相应的配置</li></ul><h2 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h2><p>配置中心服务端主要做了几件事情：连接配置仓库、拉取远程配置&amp;本地缓存、对外提供API接口服务。</p><h3 id="EnableConfigServer-及配置类"><a href="#EnableConfigServer-及配置类" class="headerlink" title="@EnableConfigServer 及配置类"></a>@EnableConfigServer 及配置类</h3><p>注解 EnableConfigServer 可以开启应用服务对配置中心的支持。当开启之后，配置服务器就会在启动时进行自动配置。具体对应的配置类是 ConfigServerAutoConfiguration，然后又在 ConfigServerAutoConfiguration 这个配置类中引入了其他很多配置类。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(&#123;Marker.class&#125;)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;ConfigServerProperties.class&#125;)</span><br><span class="line"><span class="meta">@Import</span>(&#123;EnvironmentRepositoryConfiguration.class, CompositeConfiguration.class, ResourceRepositoryConfiguration.class, ConfigServerEncryptionConfiguration.class, ConfigServerMvcConfiguration.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConfigServerAutoConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>EnvironmentRepositoryConfiguration： 环境变量存储相关的配置类</li><li>CompositeConfiguration：组合方式的环境仓库配置类</li><li>ResourceRepositoryConfiguration：资源仓库相关的配置类</li><li>ConfigServerEncryptionConfiguration：加密断点相关的配置类</li><li>ConfigServerMvcConfiguration：对外暴露的MVC端点控制器的配置类</li></ul><p>无论是 Spring Cloud 自身提供的默认实现 git ，还是 zk，或者 apollo ；基本思路都是在程序启动时将远端配置拉取到本地作为环境变量来使用，但这些是针对客户端角度来说的。Spring Cloud Config Server 因为其本身是以服务端存在，所以 Config Server 本身的实现思路也值得后面开发借鉴。</p><p>对于服务端来说，其基本职责就是能够将具体存储中的配置信息先拿到，然后提供出 API 供客户端来调用。下面从ConfigServerAutoConfiguration 中 import的这些配置类来具体看下实现。</p><h3 id="EnvironmentRepositoryConfiguration"><a href="#EnvironmentRepositoryConfiguration" class="headerlink" title="EnvironmentRepositoryConfiguration"></a>EnvironmentRepositoryConfiguration</h3><p>EnvironmentRepositoryConfiguration 是环境变量存储相关的配置类，它本身也提供了很多实现：</p><p><img src="https://oscimg.oschina.net/oscnet/3b93eff5aa7978c04010c2b0bb75f7bae17.jpg" alt="image.png"></p><p>上图中可以看到，环境配置仓库支持的有JDBC、SVN、本地文件系统、Git等等。这些对不同环境仓库的支持，在实现上基本都差不多，下面以默认提供的方式git来分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"git"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitRepositoryConfiguration</span> <span class="keyword">extends</span> <span class="title">DefaultRepositoryConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GitRepositoryConfiguration 集成了 DefaultRepositoryConfiguration，这也说明了 Spring Cloud Config 默认使用的是Git。不同的配置类实现都会被标注一个@Profile，可以通过这个来激活相应的配置类；具体做法是在配置服务端的 application.properties(application.yml) 中来指定：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.profile.active=git</span><br></pre></td></tr></table></figure><p>没有设置就是默认使用 GIt。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = EnvironmentRepository.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultRepositoryConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ConfigurableEnvironment environment;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ConfigServerProperties server;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> TransportConfigCallback customTransportConfigCallback;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MultipleJGitEnvironmentRepository <span class="title">defaultEnvironmentRepository</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        MultipleJGitEnvironmentRepositoryFactory gitEnvironmentRepositoryFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">MultipleJGitEnvironmentProperties environmentProperties)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> gitEnvironmentRepositoryFactory.build(environmentProperties);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultRepositoryConfiguration 的 ConditionalOnMissingBean 可以知道，如果上下文中没有 EnvironmentRepository，那么就使用 DefaultRepositoryConfiguration。</p><h3 id="MultipleJGitEnvironmentRepository"><a href="#MultipleJGitEnvironmentRepository" class="headerlink" title="MultipleJGitEnvironmentRepository"></a>MultipleJGitEnvironmentRepository</h3><p>MultipleJGitEnvironmentRepository 是 Git 存储的具体实现类，下面是类图结构：<br><img src="https://oscimg.oschina.net/oscnet/00a410c73f4e93c55f8ce2e386e5254718e.jpg" alt="image.png"></p><p>MultipleJGitEnvironmentRepository 的顶层接口是 EnvironmentRepository ，当然其他的实现也都是实现了这个接口的。另外一个需要关注的是 SearchPathLocator。</p><ul><li>EnvironmentRepository：定义了获取指定应用服务环境信息的方法，返回一个Enviroment</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EnvironmentRepository</span> </span>&#123;</span><br><span class="line"><span class="function">Environment <span class="title">findOne</span><span class="params">(String application, String profile, String label)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个参数，application、profile、label；《<a href="http://www.glmapper.com/2018/12/31/springcoud-config-project/">SpringCloud-配置中心 Config</a>》 中客户端部分有对这三个的参数的说明及使用方式，通过这三个参数可以具体定位到配置信息。</p><ul><li>SearchPathLocator ： 根据传入客户端应用信息，获取对应的配置环境文件的位置。代码见：<a href="[https://github.com/spring-cloud/spring-cloud-config/blob/master/spring-cloud-config-server/src/main/java/org/springframework/cloud/config/server/environment/SearchPathLocator.java](https://github.com/spring-cloud/spring-cloud-config/blob/master/spring-cloud-config-server/src/main/java/org/springframework/cloud/config/server/environment/SearchPathLocator.java">SearchPathLocator</a>)。</li></ul><p>SearchPathLocator 中有一个内部类 Locations ，Locdations中定义了应用服务配置存储信息。</p><p>除了这两个之外，还有一个 AbstractScmAccessor，这个抽象类里面定义了一些列与git存储相关的属性和方法。包括远程仓库的地址、账户、密码、ssh 私钥、本地仓库的地址等等。</p><blockquote><p>SCM : 软件配置管理</p></blockquote><h3 id="AbstractScmEnvironmentRepository"><a href="#AbstractScmEnvironmentRepository" class="headerlink" title="AbstractScmEnvironmentRepository"></a>AbstractScmEnvironmentRepository</h3><p>AbstractScmEnvironmentRepository 实现了 AbstractScmAccessor 和 EnvironmentRepository ，主要就是EnvironmentRepository 中 findOne 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Environment <span class="title">findOne</span><span class="params">(String application, String profile, String label)</span> </span>&#123;</span><br><span class="line"><span class="comment">//新建了一个本地仓库作为代理仓库来使用</span></span><br><span class="line">  NativeEnvironmentRepository delegate = <span class="keyword">new</span> NativeEnvironmentRepository(getEnvironment(),</span><br><span class="line"><span class="keyword">new</span> NativeEnvironmentProperties());</span><br><span class="line">    <span class="comment">//获取本地仓库中指定应用的位置</span></span><br><span class="line">Locations locations = getLocations(application, profile, label);</span><br><span class="line">delegate.setSearchLocations(locations.getLocations());</span><br><span class="line">  <span class="comment">//根据这个路径搜索应用服务的配置信息</span></span><br><span class="line">Environment result = delegate.findOne(application, profile, <span class="string">""</span>);</span><br><span class="line">result.setVersion(locations.getVersion());</span><br><span class="line">result.setLabel(label);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.cleaner.clean(result, getWorkingDirectory().toURI().toString(),</span><br><span class="line">getUri());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getLocations 是一个模板方法，Config Server中提供了三种实现：</p><p><img src="https://oscimg.oschina.net/oscnet/5c29f16cdb3057306c9eb7d95a19188ef36.jpg" alt="image.png"></p><p>分别是单 Git 仓库，多 Git 仓库和 Svn 仓库实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Locations <span class="title">getLocations</span><span class="params">(String application, String profile,</span></span></span><br><span class="line"><span class="function"><span class="params">String label)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (label == <span class="keyword">null</span>) &#123;</span><br><span class="line">label = <span class="keyword">this</span>.defaultLabel;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 获取最新的版本号</span></span><br><span class="line">String version = refresh(label);</span><br><span class="line">    <span class="comment">// 根据最新的版本号返回 Locations 定位到资源的搜索路径</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Locations(application, profile, label, version,</span><br><span class="line">getSearchLocations(getWorkingDirectory(), application, profile, label));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>refresh 方法做的作用就是刷新本地仓库的配置状态，这样就能保证每次都能拉取到最新的配置信息。下面来分析这个方法。</p><h3 id="JGitEnvironmentRepository-refresh"><a href="#JGitEnvironmentRepository-refresh" class="headerlink" title="JGitEnvironmentRepository#refresh"></a>JGitEnvironmentRepository#refresh</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">refresh</span><span class="params">(String label)</span> </span>&#123;</span><br><span class="line">Git git = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建一个git客户端</span></span><br><span class="line">git = createGitClient();</span><br><span class="line">      <span class="comment">// 是否需要执行 git pull</span></span><br><span class="line"><span class="keyword">if</span> (shouldPull(git)) &#123;</span><br><span class="line">FetchResult fetchStatus = fetch(git, label);</span><br><span class="line"><span class="keyword">if</span> (deleteUntrackedBranches &amp;&amp; fetchStatus != <span class="keyword">null</span>) &#123;</span><br><span class="line">deleteUntrackedLocalBranches(fetchStatus.getTrackingRefUpdates(), git);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取后checkout，这样我们就可以获得任何新的分支、tag等。</span></span><br><span class="line">checkout(git, label);</span><br><span class="line">tryMerge(git, label);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 没有什么要更新，所以只是checkout和merge。</span></span><br><span class="line"><span class="comment">// 合并是因为远程分支以前可能已经更新过</span></span><br><span class="line">checkout(git, label);</span><br><span class="line">tryMerge(git, label);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回当前的版本</span></span><br><span class="line"><span class="keyword">return</span> git.getRepository().findRef(<span class="string">"HEAD"</span>).getObjectId().getName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// 异常处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 关闭git</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个里面基本就是通过git客户端的一些操作。先是检查远程仓库的状态，然后判断本地仓库是否要执行刷新操作。如果有状态更新，比如新的提交时，Git客户端就会执行fetch，然后再进行merge，更新到本地仓库。</p><blockquote><p>MultipleJGitEnvironmentRepository 多仓库的支持，实际上就是遍历了所有的仓库。其他仓库和单仓库是一样的。</p></blockquote><h2 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h2><p>Spring Cloud Config Client 没有像其他组件一样提供@EnableConfigClient注解，这里没有必要去标注是一个配置客户端，只要引入了spring-cloud-config-client 依赖即可。</p><p>思路也很清楚，就是在启动时从服务端把配置信息拉取到本地，然后设置到 Enviroment 中。Spring Cloud Config中有两种形式，一种是指定 url，另外一种是通过服务发现，默认是通过指定URI的方式。这里还是先从客户端的自动配置来分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServiceBootstrapConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ConfigurableEnvironment environment;</span><br><span class="line">  <span class="comment">// 客户端配置属性</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigClientProperties <span class="title">configClientProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ConfigClientProperties client = <span class="keyword">new</span> ConfigClientProperties(<span class="keyword">this</span>.environment);</span><br><span class="line"><span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 从远程服务器上请求对应的配置信息</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(ConfigServicePropertySourceLocator.class)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"spring.cloud.config.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigServicePropertySourceLocator <span class="title">configServicePropertySource</span><span class="params">(ConfigClientProperties properties)</span> </span>&#123;</span><br><span class="line">ConfigServicePropertySourceLocator locator = <span class="keyword">new</span> ConfigServicePropertySourceLocator(</span><br><span class="line">properties);</span><br><span class="line"><span class="keyword">return</span> locator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重试机制</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"spring.cloud.config.fail-fast"</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Retryable.class, Aspect.class, AopAutoConfiguration.class &#125;)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRetry</span>(proxyTargetClass = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@Import</span>(AopAutoConfiguration.class)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(RetryProperties.class)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(name = <span class="string">"configServerRetryInterceptor"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RetryOperationsInterceptor <span class="title">configServerRetryInterceptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">RetryProperties properties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> RetryInterceptorBuilder</span><br><span class="line">.stateless()</span><br><span class="line">.backOffOptions(properties.getInitialInterval(),</span><br><span class="line">properties.getMultiplier(), properties.getMaxInterval())</span><br><span class="line">.maxAttempts(properties.getMaxAttempts()).build();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置类中初始化了两个bean:</p><ul><li>ConfigClientProperties : 对客户端的属性进行配置。</li><li>ConfigServicePropertySourceLocator：从远程服务器上请求对应的配置信息，然后注册到容器的Enviroment 对象中去。</li></ul><p>ConfigClientProperties 中就是客户端的一些属性，如：profile、应用名、标签、远端服务地址等。没有什么特殊的逻辑。主要来看下 ConfigServicePropertySourceLocator 。</p><h3 id="ConfigServicePropertySourceLocator"><a href="#ConfigServicePropertySourceLocator" class="headerlink" title="ConfigServicePropertySourceLocator"></a>ConfigServicePropertySourceLocator</h3><p>ConfigServicePropertySourceLocator 实现了 PropertySourceLocator 接口，PropertySourceLocator 接口的作用就是用来定位 PropertySource 的。直接看locate方法的实现(删除了无关代码)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Retryable</span>(interceptor = <span class="string">"configServerRetryInterceptor"</span>)</span><br><span class="line"><span class="keyword">public</span> PropertySource&lt;?&gt; locate(Environment environment) &#123;</span><br><span class="line">ConfigClientProperties properties = <span class="keyword">this</span>.defaultProperties.override(environment);</span><br><span class="line">CompositePropertySource composite = <span class="keyword">new</span> CompositePropertySource(<span class="string">"configService"</span>);</span><br><span class="line">   <span class="comment">// 实例化一个 restTemplate，用来调用服务端的 API</span></span><br><span class="line">RestTemplate restTemplate = <span class="keyword">this</span>.restTemplate == <span class="keyword">null</span></span><br><span class="line">? getSecureRestTemplate(properties)</span><br><span class="line">: <span class="keyword">this</span>.restTemplate;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// labels ，对对应于profile 如，dev,pre,test这些</span></span><br><span class="line">String[] labels = <span class="keyword">new</span> String[] &#123; <span class="string">""</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(properties.getLabel())) &#123;</span><br><span class="line">labels = StringUtils.commaDelimitedListToStringArray(properties.getLabel());</span><br><span class="line">&#125;</span><br><span class="line">String state = ConfigClientStateHolder.getState();</span><br><span class="line"><span class="comment">// 遍历所有的标签，循环调用获取远程配置信息</span></span><br><span class="line"><span class="keyword">for</span> (String label : labels) &#123;</span><br><span class="line">       <span class="comment">// h获取远端环境配置信息</span></span><br><span class="line">Environment result = getRemoteEnvironment(restTemplate, properties,</span><br><span class="line">label.trim(), state);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">log(result);</span><br><span class="line">         <span class="comment">// result.getPropertySources() can be null if using xml</span></span><br><span class="line">         <span class="comment">//使用 xml，可能会为 null</span></span><br><span class="line"><span class="keyword">if</span> (result.getPropertySources() != <span class="keyword">null</span>) &#123; </span><br><span class="line"><span class="keyword">for</span> (PropertySource source : result.getPropertySources()) &#123;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) source</span><br><span class="line">.getSource();</span><br><span class="line">composite.addPropertySource(</span><br><span class="line"><span class="keyword">new</span> MapPropertySource(source.getName(), map));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">         <span class="comment">// 设置客户端状态和版本号信息</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(result.getState())</span><br><span class="line">|| StringUtils.hasText(result.getVersion())) &#123;</span><br><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">putValue(map, <span class="string">"config.client.state"</span>, result.getState());</span><br><span class="line">putValue(map, <span class="string">"config.client.version"</span>, result.getVersion());</span><br><span class="line">composite.addFirstPropertySource(</span><br><span class="line"><span class="keyword">new</span> MapPropertySource(<span class="string">"configClient"</span>, map));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> composite;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// 如果设置了fial fast ，失败时抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (properties.isFailFast()) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码片段中实际从远端获取配置信息是在 getRemoteEnvironment 这个方法中，以Http 请求的方式获取。获取到配置信息之后是放在 CompositePropertySource 对象中，代码较长，逻辑也比较简单，建议直接阅读源码。源于这部分 <a href="http://www.glmapper.com/2018/12/31/springcoud-context-analysis/">自定义属性源</a>也有说明。</p><h3 id="注入到-Enviroment-中"><a href="#注入到-Enviroment-中" class="headerlink" title="注入到 Enviroment 中"></a>注入到 Enviroment 中</h3><p>这部分操作是在 Spring Cloud Context 中的入口来完成的。具体参考<a href="http://www.glmapper.com/2018/12/31/springcoud-context-analysis/"> bootstrapServiceContext 创建&amp;启动</a> 。<br>这里会通过 Spring Cloud Context 中的 PropertySourceBootstrapConfiguration 配置类将PropertySourceLocator 自定义属性值添加到引导上下文的环境当中。</p><h3 id="基于服务发现的方式获取配置"><a href="#基于服务发现的方式获取配置" class="headerlink" title="基于服务发现的方式获取配置"></a>基于服务发现的方式获取配置</h3><p>前面两个小节均是基于指定 http url 的方式获取配置文件的。Spring Cloud Config 中还有一种方式就是基于服务发现的方式。其实这种方式说到底还是基于指定 http url的方式调用，只是通过服务发现找到服务端地址；当然既然有服务的发现与注册，也就会涉及到客户端与服务端之间的会话保证，及时更新可用服务列表这些功能。</p><ul><li>获取服务地址</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retryable</span>(interceptor = <span class="string">"configServerRetryInterceptor"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ServiceInstance&gt; <span class="title">getConfigServerInstances</span><span class="params">(String serviceId)</span> </span>&#123;</span><br><span class="line">logger.debug(<span class="string">"Locating configserver ("</span> + serviceId + <span class="string">") via discovery"</span>);</span><br><span class="line">List&lt;ServiceInstance&gt; instances = <span class="keyword">this</span>.client.getInstances(serviceId);</span><br><span class="line"><span class="keyword">if</span> (instances.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">"No instances found of configserver ("</span> + serviceId + <span class="string">")"</span>);</span><br><span class="line">&#125;</span><br><span class="line">logger.debug(<span class="string">"Located configserver ("</span> + serviceId</span><br><span class="line">+ <span class="string">") via discovery. No of instances found: "</span> + instances.size());</span><br><span class="line"><span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 DiscoveryClient 客户端，以指定serviceId的方式拿到服务地址。</p><p>DiscoveryClientConfigServiceBootstrapConfiguration 这个自动配置类实现了 ApplicationListener，用于监听上下文刷新事件；DiscoveryClient 在具体的实现中会将上下文刷新事件进行广播，然后执行刷新操作。心跳里面也是执行的刷新操作。对应的方法是DiscoveryClientConfigServiceBootstrapConfiguration#refresh。也就是 refresh方法会根据上下文环境和心跳事件，刷新服务实例。</p><h2 id="以-ZK-作为配置中心"><a href="#以-ZK-作为配置中心" class="headerlink" title="以 ZK 作为配置中心"></a>以 ZK 作为配置中心</h2><p>《<a href="http://www.glmapper.com/2019/01/05/springcloud-config-zk-project/">SpringCloud-配置中心 spring-cloud-zk</a>》demo 中介绍了如何使用 zk 作为配置中心。以zk作为配置中心也就是配置信息将从zk中来获取；具体实现也就是实现 PropertySourceLocator 接口，在locate方法中通过zk客户端从zk服务端拉取配置信息。具体实现在ZookeeperPropertySourceLocator#locate中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PropertySource&lt;?&gt; locate(Environment environment) &#123;</span><br><span class="line"><span class="keyword">if</span> (environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">      <span class="comment">//省略 ...</span></span><br><span class="line"><span class="comment">// 获取外部配置源</span></span><br><span class="line">PropertySource propertySource = create(propertySourceContext);</span><br><span class="line">      <span class="comment">//省略 ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他代码片段都省略了，获取 PropertySource 是在 create 方法中，create 方法返回一个 ZookeeperPropertySource 实例对象。在构造函数中，有通过zk客户端去拉取配置信息，具体逻辑在findProperties 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findProperties</span><span class="params">(String path, List&lt;String&gt; children)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 省略 ... </span></span><br><span class="line"><span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">String childPath = path + <span class="string">"/"</span> + child;</span><br><span class="line">List&lt;String&gt; childPathChildren = getChildren(childPath);</span><br><span class="line">        <span class="comment">// 获取节点信息</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = getPropertyBytes(childPath);</span><br><span class="line"><span class="keyword">if</span> (bytes == <span class="keyword">null</span> || bytes.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (childPathChildren == <span class="keyword">null</span> || childPathChildren.isEmpty()) &#123;</span><br><span class="line">registerKeyValue(childPath, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">registerKeyValue(childPath, <span class="keyword">new</span> String(bytes, Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查子节点，即使我们已经找到当前znode的值</span></span><br><span class="line">findProperties(childPath, childPathChildren);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line"><span class="comment">// 省略 ... </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动刷新机制"><a href="#自动刷新机制" class="headerlink" title="自动刷新机制"></a>自动刷新机制</h3><p>当修改配置信息之后，通过zk自身的监听机制，通知客户端。这个机制是在ZookeeperConfigAutoConfiguration自动配置类中提供。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(RefreshEndpoint.class)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkRefreshConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(name = <span class="string">"spring.cloud.zookeeper.config.watcher.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigWatcher <span class="title">configWatcher</span><span class="params">(ZookeeperPropertySourceLocator locator,</span></span></span><br><span class="line"><span class="function"><span class="params">CuratorFramework curator)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConfigWatcher(locator.getContexts(), curator);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConfigWatcher 实现了 Closeable、TreeCacheListener 和 ApplicationEventPublisherAware 三个接口。Tree Cache 用于观察所有节点的所有数据状态，ApplicationEventPublisherAware用户提供一个publiser，用来发布RefreshEvent 事件。Closeable 用于实现优雅关闭。</p><p>所有当我们改变zk数据节点时，就是触发例如 NODE_ADDED 、NODE_REMOVED、NODE_UPDATED 等事件类型，然后publiser就会发布一个 RefreshEvent 事件，通知客户端进行配置更新操作。从而实现配置的自动刷新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇可以配合《&lt;a href=&quot;http://www.glmapper.com/2018/12/31/springcoud-config-project/&quot;&gt;SpringCloud-配置中心 Config&lt;/a&gt;》来看，《&lt;a href=&quot;http://www.glmapp
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="zookeeper" scheme="http://www.glmapper.com/tags/zookeeper/"/>
    
      <category term="Config" scheme="http://www.glmapper.com/tags/Config/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-配置中心 spring-cloud-config-zookeeper</title>
    <link href="http://www.glmapper.com/2019/01/05/springcloud-config-zk-project/"/>
    <id>http://www.glmapper.com/2019/01/05/springcloud-config-zk-project/</id>
    <published>2019-01-05T09:12:07.000Z</published>
    <updated>2019-01-05T12:39:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>SpringCloud 除了config自己的client/server 这套配置中心之外，还可以集成使用 zookeeper 。本篇将演示如何使用 spring-cloud-confg-zookeeper。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK<br></td><td>1.8.0_162<br></td></tr><tr><td>SOFABoot/SpringBoot<br></td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE<br></td></tr><tr><td>SpringCloud<br></td><td>Finchley.RC1<br></td></tr><tr><td>IDE<br></td><td>IDEA<br></td></tr></tbody></table><h2 id="zk-amp-zkui"><a href="#zk-amp-zkui" class="headerlink" title="zk &amp; zkui"></a>zk &amp; zkui</h2><p>这里我是把 zk 和 zkui 部署在一台 linux 服务器上的。</p><h3 id="zk"><a href="#zk" class="headerlink" title="zk"></a>zk</h3><p>从 ZooKeeper官网 下载 zookeeper-3.4.13.tar.gz。</p><ul><li><p>解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf zookeeper-3.4.13.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>目录重命名(可选)</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv zookeeper-3.4.13 zookeeper</span><br></pre></td></tr></table></figure><ul><li>在 zookeeper 下加一个data目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">cd</span> zookeeper</span><br><span class="line">&gt; mkdir data</span><br></pre></td></tr></table></figure><ul><li>修改 zoo.cfg</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim zoo.cfg</span><br></pre></td></tr></table></figure><ul><li>修改 dataDir 地址：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/$&#123;your path&#125;/zookeeper/data</span><br></pre></td></tr></table></figure><ul><li>其他随意，启动 zk</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure><h3 id="zkui"><a href="#zkui" class="headerlink" title="zkui"></a>zkui</h3><p>下载zkui代码，然后本地安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://gitee.com/ilanni/zkui.git</span><br><span class="line">$ <span class="built_in">cd</span> zkui/ </span><br><span class="line">$ mvn clean install <span class="comment"># 进行maven打包，执行成功后会生成target文件夹，其中有jar文件。</span></span><br></pre></td></tr></table></figure><p>执行结束后在zkui文件夹下生成一个target文件夹。</p><ul><li>将config.cfg文件复制到target文件夹下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp config.cfg target/</span><br></pre></td></tr></table></figure><p>target文件夹中有两个jar包，我们只需要启动<code>zkui-2.0-SNAPSHOT-jar-with-dependencies.jar</code>就可以了。</p><ul><li>修改 config.cfg文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">cd</span> target</span><br><span class="line">&gt; vim config.cfg</span><br></pre></td></tr></table></figure><p>按需修改serverPort、zkServer、userSet 等。</p><ul><li>启动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar zkui-2.0-SNAPSHOT-jar-with-dependencies.jar</span><br><span class="line"><span class="comment"># nohup java -jar zkui-2.0-SNAPSHOT-jar-with-dependencies.jar &amp;   #退出窗口不退出进程</span></span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>既然是以 zk 作为配置中，那么就需要将测试用的配置数据先在zk上进行初始化。有两种方式（均基于zkui）：</p><ul><li>zkui 界面通过 import 进行导入，这里新建一个 config.txt ，内容如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/config/sofa/sofa-config-zk,dev=server.port=8085</span><br></pre></td></tr></table></figure><p>设置当前应用启动的端口，这里的 root 为 /config/sofa，应用名是 sofa-config-zk，dev是环境 ，server.port=8085 是具体的配置kv。</p><ul><li>手动 add node</li></ul><p>这里为了方便，采用import的方式，结果如下：<br><img src="https://oscimg.oschina.net/oscnet/afaf490914a21de6eb087ec02582cc7f1d2.jpg" alt="image.png"></p><h2 id="新建-sofa-config-zookeeper"><a href="#新建-sofa-config-zookeeper" class="headerlink" title="新建 sofa-config-zookeeper"></a>新建 sofa-config-zookeeper</h2><p>新建一个 SOFABoot 工程，项目为 sofa-config-zookeeper。</p><h3 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring-cloud-config zk 的依赖，必选--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- spring-cloud-config zk 的依赖，为了自动刷新监听等--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sofa-config-zk</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">  cloud:</span><br><span class="line">    zookeeper:</span><br><span class="line">      enabled: true  # true:开启zookeeper外部化配置, false:读取本地配置;</span><br><span class="line">      connect-string: sofa.cloud.alipay.net:2181</span><br><span class="line">      config:</span><br><span class="line">        root: /config/sofa   #指定zookeeper中属性的根目录</span><br><span class="line">        enabled: true</span><br><span class="line">        watcher:</span><br><span class="line">          enabled: true    #默认值是true, 监控配置变更后是否自动更新，需配合Spring Boot Actuators 使用</span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaConfigZookeeperApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaConfigZookeeperApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有任何特殊，不需要加额外的注解。</p><h3 id="资源类"><a href="#资源类" class="headerlink" title="资源类"></a>资源类</h3><p>其实这里可以完全不用通过rest来打印这个属性值，但是为了方便看，还是写一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperConfigController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/config"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serverPort;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动-amp-验证"><a href="#启动-amp-验证" class="headerlink" title="启动&amp;验证"></a>启动&amp;验证</h3><p>启动应用，如果成功的话，会有如下的日志：State change: CONNECTED</p><p><img src="https://oscimg.oschina.net/oscnet/42dfc087c51e1b5e1044b0d87900b3003ca.jpg" alt="image.png"></p><p>tomcat 启动端口:</p><p><img src="https://oscimg.oschina.net/oscnet/b506f78b41460610be7057b8be7b421d9d5.jpg" alt="image.png"></p><p>因为在上面配置文件部分是没有指定 server.port 的，通常情况下默认是 8080 ，所以可以确定，已经拿到了配置中心的数据了。</p><h2 id="动态刷新"><a href="#动态刷新" class="headerlink" title="动态刷新"></a>动态刷新</h2><p>这里还是需要依赖 actuator 的 /refresh 。上面依赖中已经加入了 actuator的相关依赖，所以只需要在资源类上加一个 <a href="#">@RefreshScope</a> 注解即可。</p><ul><li>在 ZookeeperConfigController 类上加 <a href="#">@RefreshScope</a>  注解，然后重启应用</li><li>通过 zkui 修改 server.port 为 8086</li><li>访问 <a href="http://localhost:8065/config" target="_blank" rel="noopener">http://localhost:8085/config</a> ，返回8086</li></ul><blockquote><p>需要注意，这里因为我们启动时应用时拿到的配置是8085，所以当前服务对外提供服务暴露的端口就是8085 ，当我们修改了zk上的值之后，他会改变 当前运行环境中 Enviroment 的值，但是不会使得服务的端口发生变化，除非重启。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SpringCloud 除了config自己的client/server 这套配置中心之外，还可以集成使用 zookeeper 。本篇将演示如何使用 spring-cloud-confg-zookeeper。&lt;/p&gt;
&lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="zookeeper" scheme="http://www.glmapper.com/tags/zookeeper/"/>
    
      <category term="Config" scheme="http://www.glmapper.com/tags/Config/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下安装 Mysql 数据库</title>
    <link href="http://www.glmapper.com/2019/01/05/mysql-on-linux/"/>
    <id>http://www.glmapper.com/2019/01/05/mysql-on-linux/</id>
    <published>2019-01-05T09:09:15.000Z</published>
    <updated>2019-01-05T09:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在搞 Apollo ，熟悉的同学应该知道，Apollo 需要依赖 Mysql。本以为很容易搞定，但是却踩了一路坑，眼高手低，也参考了网上很多博客，果然是残缺就是美！本篇就简单记录一下这个过程，以便后面参考。</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li><p>linux：centOS 7</p></li><li><p>jdk：8</p></li><li><p>Mysql：5.7.24</p></li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>安装前，我们可以检测系统是否自带安装 MySQL:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep mysql</span><br></pre></td></tr></table></figure><p>如果你系统有安装，那可以选择进行卸载，有两种模式：</p><ul><li><p>普通删除模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e mysql</span><br></pre></td></tr></table></figure></li><li><p>强力删除模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps mysql</span><br></pre></td></tr></table></figure><p>如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除</p></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>下载mysql安装包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm</span><br><span class="line"></span><br><span class="line">-2018-06-06 16:41:46--  https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm</span><br><span class="line">正在解析主机 dev.mysql.com (dev.mysql.com)... xxxx</span><br><span class="line">正在连接 dev.mysql.com (dev.mysql.com)|xxxxx|:443... 已连接。</span><br><span class="line">已发出 HTTP 请求，正在等待回应... 302 Found</span><br><span class="line">位置：https://repo.mysql.com//mysql57-community-release-el7-9.noarch.rpm [跟随至新的 URL]</span><br><span class="line">--2018-06-06 16:41:48--  https://repo.mysql.com//mysql57-community-release-el7-9.noarch.rpm</span><br><span class="line">正在解析主机 repo.mysql.com (repo.mysql.com)... xxxxx</span><br><span class="line">正在连接 repo.mysql.com (repo.mysql.com)|xxxx|:443... 已连接。</span><br><span class="line">已发出 HTTP 请求，正在等待回应... 200 OK</span><br><span class="line">长度：9224 (9.0K) [application/x-redhat-package-manager]</span><br><span class="line">正在保存至: “mysql57-community-release-el7-9.noarch.rpm”</span><br><span class="line"></span><br><span class="line">100%[==========================================================&gt;] 9,224       --.-K/s 用时 0s      </span><br><span class="line"></span><br><span class="line">2018-06-06 16:41:48 (169 MB/s) - 已保存 “mysql57-community-release-el7-9.noarch.rpm” [9224/9224])</span><br></pre></td></tr></table></figure><ul><li>安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql57-community-release-el7-9.noarch.rpm</span><br><span class="line"></span><br><span class="line">准备中...                          ################################# [100%]</span><br><span class="line">正在升级/安装...</span><br><span class="line">   1:mysql57-community-release-el7-9  ################################# [100%]</span><br></pre></td></tr></table></figure><ul><li>下载安装依赖包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql-server</span><br><span class="line"></span><br><span class="line">已加载插件：fastestmirror, langpacks</span><br><span class="line">mysql-connectors-community                                                   | 2.5 kB  00:00:00     </span><br><span class="line">mysql-tools-community                                                        | 2.5 kB  00:00:00     </span><br><span class="line">mysql57-community                                                            | 2.5 kB  00:00:00     </span><br><span class="line">(1/3): mysql-connectors-community/x86_64/primary_db                          |  20 kB  00:00:00     </span><br><span class="line">(2/3): mysql-tools-community/x86_64/primary_db                               |  41 kB  00:00:00     </span><br><span class="line">(3/3): mysql57-community/x86_64/primary_db                                   | 144 kB  00:00:00     </span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.cn99.com</span><br><span class="line"> * extras: mirrors.cn99.com</span><br><span class="line"> * updates: mirrors.cn99.com</span><br><span class="line">正在解决依赖关系 </span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>第一次下载这里会比较慢</p><ul><li><p>验证是否安装成功</p><ul><li>mysqladmin –version</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin  Ver 8.42 Distrib 5.7.22, for Linux on x86_64</span><br></pre></td></tr></table></figure><ul><li>mysql -V</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql  Ver 14.14 Distrib 5.7.24, for Linux (x86_64) using  EditLine wrapper</span><br></pre></td></tr></table></figure></li><li><p>启动MySQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start mysqld</span><br></pre></td></tr></table></figure></li><li><p>查看 MySQL 运行状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status mysqld</span><br></pre></td></tr></table></figure></li><li><p>停止 MySQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop mysqld</span><br></pre></td></tr></table></figure></li><li><p>重启 MySQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart mysqld</span><br></pre></td></tr></table></figure></li></ul><h3 id="关于密码"><a href="#关于密码" class="headerlink" title="关于密码"></a>关于密码</h3><p>Mysql 5.7 默认安装之后 root 是有密码的，获取 MySQL 的临时密码 为了加强安全性，MySQL 5.7 为 root 用户随机生成了一个密码，在 error log 中，关于 error log 的位置，如果安装的是 RPM 包，则默认是 /var/log/mysqld.log 。 只有启动过一次 mysql 才可以查看临时密码。</p><p>在利用 YUM 安装 mysql 数据库过程中，系统会自动生成一个临时密码，获取方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &apos;temporary password&apos; /var/log/mysqld.log</span><br></pre></td></tr></table></figure><ul><li><p>没有密码</p><p>如果以前安装过 mysql，这时的 mysqld.log 中就不会有 temporary password<br>这时就需要删除 mysql 残留的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /var/lib/mysql</span><br></pre></td></tr></table></figure><p>执行完毕后需要重新启动MySQL服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart mysqld</span><br></pre></td></tr></table></figure><p>这时就可以通过上面的命令去查找数据库生成的临时密码了</p></li></ul><h3 id="mysql-1130-错误"><a href="#mysql-1130-错误" class="headerlink" title="mysql 1130 错误"></a>mysql 1130 错误</h3><p>可能是你的帐号不允许从远程登陆，只能在 localhost。这个时候只要在 localhost 的那台电脑，登入 mysql 后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称”%”</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -pvmwaremysql&gt;use mysql;</span><br><span class="line">mysql&gt; update user set host = '%' where user = 'root';</span><br><span class="line">mysql&gt; select host, user from user;</span><br></pre></td></tr></table></figure><p>使得我们当前的账户和密码能够应用的所有的远程主机连接：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; GRANT ALL PRIVILEGES ON . TO 'myuser'@'%' IDENTIFIED BY 'mypassword' WITH GRANT OPTION;</span><br><span class="line">&gt; FLUSH   PRIVILEGES;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在搞 Apollo ，熟悉的同学应该知道，Apollo 需要依赖 Mysql。本以为很容易搞定，但是却踩了一路坑，眼高手低，也参考了网上很多博客，果然是残缺就是美！本篇就简单记录一下这个过程，以便后面参考。&lt;/p&gt;
&lt;h3 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; c
      
    
    </summary>
    
      <category term="运维" scheme="http://www.glmapper.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="mysql" scheme="http://www.glmapper.com/tags/mysql/"/>
    
      <category term="linux" scheme="http://www.glmapper.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-Spring Cloud Context</title>
    <link href="http://www.glmapper.com/2018/12/31/springcoud-context-analysis/"/>
    <id>http://www.glmapper.com/2018/12/31/springcoud-context-analysis/</id>
    <published>2018-12-30T16:17:28.000Z</published>
    <updated>2018-12-30T16:18:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引导程序应用上下文"><a href="#引导程序应用上下文" class="headerlink" title="引导程序应用上下文"></a>引导程序应用上下文</h2><blockquote><p>A Spring Cloud application operates by creating a “bootstrap” context, which is a parent context for the main application. It is responsible for loading configuration properties from the external sources and for decrypting properties in the local external configuration files. The two contexts share an Environment, which is the source of external properties for any Spring application.</p><p>By default, bootstrap properties (not bootstrap.properties but properties that are loaded during the bootstrap phase) are added with high precedence, so they cannot be overridden by local configuration.</p><p>The bootstrap context uses a different convention for locating external configuration than the main application context. Instead of application.yml (or .properties), you can use bootstrap.yml, keeping the external configuration for bootstrap and main context nicely separate.</p></blockquote><blockquote><p>释文：Spring Cloud 应用程序通过创建“引导程序”上下文来运行，<strong>该上下文是主应用程序的父上下文</strong>共享一个 Environment**，它是任何Spring应用程序的外部属性的来源。</p><p>默认情况下，引导属性（不是bootstrap.properties，而是在引导阶段加载的属性）以<strong>高优先级添加</strong>，因此本地配置无法覆盖它们。</p><p>引导上下文使用与主应用程序上下文不同的外部配置约定。 因此使用 bootstrap.yml application.yml（或.properties）代替引导和主上下文的外部配置，保持引导程序和主上下文的外部配置很好地分开。</p></blockquote><p><br><br>上面是 SpringCloud 关于引导上下文的一个解释，详见 <a href="https://cloud.spring.io/spring-cloud-static/Finchley.SR2/single/spring-cloud.html#_the_bootstrap_application_context" target="_blank" rel="noopener">这里</a>。</p><p>spring cloud 有自己的一套配置初始化机制，所以它实际上是自己启动了一个Spring 上下文，也就是我们说的引导上文。在上面的描述中有提到，引导上下文会以应用上下文的父类存在；在Spring中，如果上下文存在父子关系，也就意味着子上下文会集成父上下文的属性源和配置文件。在SpringBoot的启动过程中，prepareContext 这个操作会进行父子上下文的关系设置，调用栈如下:</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2018/png/97619/1546070770372-d7a4ec62-f29b-477f-adc0-844709415a32.png#wh=561x165" alt="image.png"></p><p>setParent 方法代码片段如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParent</span><span class="params">(@Nullable ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.parent = parent;</span><br><span class="line">       <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Environment parentEnvironment = parent.getEnvironment();</span><br><span class="line">           <span class="keyword">if</span> (parentEnvironment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">               <span class="keyword">this</span>.getEnvironment().merge((ConfigurableEnvironment)parentEnvironment);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>这个可以看到，子上下文会合并掉父上下文的 Environment 。关于父子上下文是怎么关联起来的，下面来看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(context.getParent() != <span class="keyword">null</span> &amp;&amp; context.getParent() != context) &#123;</span><br><span class="line">  context = (ConfigurableApplicationContext)context.getParent();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.reorderSources(context.getEnvironment());</span><br><span class="line">  (<span class="keyword">new</span> ParentContextApplicationContextInitializer(<span class="keyword">this</span>.parent)).initialize(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="BootstrapApplicationListener"><a href="#BootstrapApplicationListener" class="headerlink" title="BootstrapApplicationListener"></a>BootstrapApplicationListener</h3><p>上面的代码片段定位在 org.springframework.cloud.bootstrap.BootstrapApplicationListener 这个类；这个监听器监听的事件是  ApplicationEnvironmentPreparedEvent ，对应在SpringBoot启动过程，就是在执行 prepareEnvironment 时触发事件调用。</p><p>BootstrapApplicationListener 的 onApplicationEvent 回调方法中实际上就是用够构建和启动 Spring Cloud  context 的。<br>spring cloud context 算是一个特殊的 spring boot context， 在分析代码的过程中（bootstrapServiceContext方法中）发现，它只扫描 BootstrapConfiguration 这个注解标注的组件。</p><p>这里就着重分析下 SpringCloud Context 的启动过程。</p><h3 id="SpringCloud-Context-启动过程"><a href="#SpringCloud-Context-启动过程" class="headerlink" title="SpringCloud Context 启动过程"></a>SpringCloud Context 启动过程</h3><p><br></p><h4 id="通过-spring-cloud-bootstrap-enabled-配置来禁用引导上下文"><a href="#通过-spring-cloud-bootstrap-enabled-配置来禁用引导上下文" class="headerlink" title="通过 spring.cloud.bootstrap.enabled 配置来禁用引导上下文"></a>通过 spring.cloud.bootstrap.enabled 配置来禁用引导上下文</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!environment.getProperty(<span class="string">"spring.cloud.bootstrap.enabled"</span>, Boolean.class,<span class="keyword">true</span>)) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调函数的开始就会对 spring.cloud.bootstrap.enabled 这个配置值进行校验，来决定是否需要禁止引导。这个在官方文档里面也有明确提到。</p><h4 id="获取-configName"><a href="#获取-configName" class="headerlink" title="获取 configName"></a>获取 configName</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String configName = environment</span><br><span class="line">.resolvePlaceholders(<span class="string">"$&#123;spring.cloud.bootstrap.name:bootstrap&#125;"</span>);</span><br></pre></td></tr></table></figure><p><br><br>可以使用 spring.cloud.bootstrap.name（默认“bootstrap”）或spring.cloud.bootstrap.location（默认为空）指定bootstrap.yml（或.properties）位置，例如在系统属性中。<br><br></p><h4 id="bootstrapServiceContext-创建-amp-启动"><a href="#bootstrapServiceContext-创建-amp-启动" class="headerlink" title="bootstrapServiceContext 创建&amp;启动"></a>bootstrapServiceContext 创建&amp;启动</h4><p>bootstrapServiceContext 是完成此过程的核心方法。</p><ul><li>加载 BootstrapConfiguration 自动配置类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Bootstrap components</span><br><span class="line">org.springframework.cloud.bootstrap.BootstrapConfiguration=\</span><br><span class="line">org.springframework.cloud.bootstrap.config.PropertySourceBootstrapConfiguration,\</span><br><span class="line">org.springframework.cloud.bootstrap.encrypt.EncryptionBootstrapConfiguration,\</span><br><span class="line">org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration</span><br></pre></td></tr></table></figure><p>PropertySourceBootstrapConfiguration 将会把 PropertySourceLocator 自定义属性值添加到引导上下文的环境当中，包括如何从远端仓库拉取配置等过程。</p><ul><li><p>构建 SpringApplicationBuilder 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SpringApplicationBuilder builder = <span class="keyword">new</span> SpringApplicationBuilder()</span><br><span class="line">.profiles(environment.getActiveProfiles()).bannerMode(Mode.OFF)</span><br><span class="line">.environment(bootstrapEnvironment)</span><br><span class="line"><span class="comment">// Don't use the default properties in this builder</span></span><br><span class="line">.registerShutdownHook(<span class="keyword">false</span>).logStartupInfo(<span class="keyword">false</span>)</span><br><span class="line">.web(WebApplicationType.NONE);</span><br></pre></td></tr></table></figure></li><li><p>构建 引导上下文并 run</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ConfigurableApplicationContext context = builder.run();</span><br></pre></td></tr></table></figure></li></ul><p>这个 build.run 实际执行的就是 SpringApplication.run 方法。</p><ul><li>为关联父子上下文准备<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addAncestorInitializer(application, context);</span><br></pre></td></tr></table></figure></li></ul><p>这里会把 ParentContextApplicationContextInitializer 加到应用的 spring context 里，来把自己设置为应用的context 的 parent，具体是在SpringBoot启动过程的 prepareContext 中完成 。</p><h2 id="重载远程属性"><a href="#重载远程属性" class="headerlink" title="重载远程属性"></a>重载远程属性</h2><p>通过Bootstrap 上下文添加到应用程序的属性源通常是远程的，比如说来自配置中心的，一般情况下本地的配置文件不能覆盖这些远程属性源。</p><p>那么如果想覆盖远程属性源怎么办呢？可以通过启动命令行参数方式设定（启动命令行参数的优先级高于远程配置的优先级）。</p><p>如果想使用应用程序的系统属性或者配置文件覆盖远程属性，那么远程属性源必须设置为 spring.cloud.config.allowOverride = true，这个配置在本地设置时不会生效的。在远程属性源中设定上述配置后，就可以通过更为细粒度的设置来控制远程属性是否能被重载，具体配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">overrideNone:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      overrideSystemProperties:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li>overrideNone true，本地属性覆盖所有的远程属性</li><li>overrideSystemProperties ，仅覆盖远程属性源中的系统属性和环境变量</li></ul><h2 id="自定义-Bootstrap-属性源"><a href="#自定义-Bootstrap-属性源" class="headerlink" title="自定义 Bootstrap 属性源"></a>自定义 Bootstrap 属性源</h2><p>默认情况下，Bootstrap 的外部配置属性源是 spring cloud config server ，也就是使用配置中心加载外部属性，但是Spring中也允许用户通过将 ProoertySourceLocator 类型的Bean实例添加到 Bootstrap 上下文，也就是在 spring.factories 中添加相应的配置类，来添加额外的属性源来源。这里可以通过SpringCloud里面提供的测试用例来看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertySourceConfiguration</span> <span class="keyword">implements</span> <span class="title">PropertySourceLocator</span> </span>&#123;</span><br><span class="line"><span class="comment">// 省略其他代码</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertySource&lt;?&gt; locate(Environment environment) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.name != <span class="keyword">null</span>) &#123;</span><br><span class="line">      assertEquals(<span class="keyword">this</span>.name,</span><br><span class="line">                   environment.getProperty(<span class="string">"spring.application.name"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fail) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Planned"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MapPropertySource(<span class="string">"testBootstrap"</span>, MAP);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码段中传入的Envirement 参数用于创建应用上下文，它具有 SpringBoot 提供的属性源，可以使用它们来加载指定的属性源。</p><p>最后将这个自定义的 PropertySourceLocator 配置到 spring.factories 中，这样应用程序就可以使用这个 PropertySourceConfiguration 作为其属性源了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.cloud.bootstrap.BootstrapConfiguration=\</span><br><span class="line">xx.xx.x.x.PropertySourceConfiguration</span><br></pre></td></tr></table></figure><h2 id="关于Enviroment-的变化"><a href="#关于Enviroment-的变化" class="headerlink" title="关于Enviroment 的变化"></a>关于Enviroment 的变化</h2><p>配置中心客户端（Spring Cloud Config Client） 应用会监听  EnviromentChangeEvent 事件，当监听到这个事件时，它将持有一个被改变的键值对列表，然后客户端应用会使用这些值来做一些事情：</p><ul><li>重新绑定所有的@ConfigurationProperties的Bean<a href="#">@ConfigurationProperties</a> 实例，更新本地的配置属性。</li><li>设置日志等级（logging.level.* 相关配置）</li></ul><p>Spring Cloud 中，配置中心服务端使用 Spring Cloud Bus 将EnviromentChangeEvent 事件广播到所有的客户端中，通过这种方式来通过它们 Enviroment 发生变化。<br><br></p><h2 id="RefreshScope"><a href="#RefreshScope" class="headerlink" title="RefreshScope"></a>RefreshScope</h2><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>RefreshScope 注解的作用是，当被这个注解标记的Bean实例在配置发生变化时可以重新进行初始化，可参考 <a href="https://yuque.antfin-inc.com/guolei.sgl/springcloud/krv1v3#43d58bbd" target="_blank" rel="noopener">动态刷新配置</a> 这个demo。这个注解很好的解决了状态Bean实例只能在初始化的时候才能进行属性注入的问题。</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>org.springframework.cloud.context.scope.refresh.RefreshScope 是上下文中的一个Bean实例，在它的 refreshAll 这个方法中，可以通过清除目标缓存来刷新作用域中的所有Bean实例。RefreshScope中也提供了一个 refresh方法，可以按照名字来刷新单个Bean。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引导程序应用上下文&quot;&gt;&lt;a href=&quot;#引导程序应用上下文&quot; class=&quot;headerlink&quot; title=&quot;引导程序应用上下文&quot;&gt;&lt;/a&gt;引导程序应用上下文&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;A Spring Cloud application op
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="spring cloud" scheme="http://www.glmapper.com/tags/spring-cloud/"/>
    
      <category term="commons" scheme="http://www.glmapper.com/tags/commons/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-配置中心 Config</title>
    <link href="http://www.glmapper.com/2018/12/31/springcoud-config-project/"/>
    <id>http://www.glmapper.com/2018/12/31/springcoud-config-project/</id>
    <published>2018-12-30T16:16:07.000Z</published>
    <updated>2019-01-09T15:38:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在分布式系统中，每一个功能模块都能拆分成一个独立的服务，一次请求的完成，可能会调用很多个服务协调来完成，为了方便服务配置文件统一管理，更易于部署、维护，所以就需要一个地方来管理这些配置信息。</p><p>在 spring cloud Config 就提供了这样的能力，通过集中化管理的方式，支持配置文件放在在配置服务的内存中远程 Git 仓库以及Subversion。</p><p>本篇将通过一个简单的 demo ，使用 spring cloud Config 原生提供的基于 Git 的方式来实现微服务体系下的配置管理功能。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK<br></td><td>1.8.0_162<br></td></tr><tr><td>SOFABoot/SpringBoot<br></td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE<br></td></tr><tr><td>SpringCloud<br></td><td>Finchley.RC1<br></td></tr><tr><td>IDE<br></td><td>IDEA<br></td></tr></tbody></table><h2 id="工程背景"><a href="#工程背景" class="headerlink" title="工程背景"></a>工程背景</h2><p>本节将通过 SOFABoot 来集成 Spring Cloud Config ，以 git 作为存储，来实现分布式环境下的配置管理。本工程的父工程仍然是《SpringCloud-Eureka 服务注册》中构建的父工程。 </p><p>由于我们是以 git 来存储配置文件的，因此我们需要在 github 上新建一个存储配置文件的空间，为了更方面的模拟，这里创建了两个配置文件：</p><ul><li>glmapper-dev.properties</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=leishu@glmapper_dev</span><br><span class="line">blog=http://www.glmapper.com</span><br><span class="line">version=dev</span><br></pre></td></tr></table></figure><ul><li>glmapper-pre.properties</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=leishu@glmapper_pre</span><br><span class="line">blog=http://www.glmapper.com</span><br><span class="line">version=pre</span><br></pre></td></tr></table></figure><blockquote><p>github 地址：<a href="https://github.com/glmapper/glmapper-config-repository" target="_blank" rel="noopener">https://github.com/glmapper/glmapper-config-repository</a></p></blockquote><h2 id="新建-sofa-config-server"><a href="#新建-sofa-config-server" class="headerlink" title="新建 sofa-config-server"></a>新建 sofa-config-server</h2><p>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p><ul><li>artifactId：sofa-config-server</li></ul><h3 id="修改-pom-文件"><a href="#修改-pom-文件" class="headerlink" title="修改 pom 文件"></a>修改 pom 文件</h3><p>这里直接引入 config 的依赖即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8091</span></span><br><span class="line">  <span class="comment">#服务名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">sofa-config-server</span></span><br><span class="line">  <span class="comment">#服务的git仓库地址</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      server:</span></span><br><span class="line"><span class="attr">        git:</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">https://github.com/glmapper/glmapper-config-repository</span></span><br><span class="line"><span class="attr">          search-paths:</span> <span class="string">/**</span></span><br><span class="line"><span class="attr">          username:</span> <span class="string">glmapper_2018@163.com</span></span><br><span class="line"><span class="attr">          password:</span> <span class="string">******</span></span><br><span class="line">      <span class="comment">#指定分支</span></span><br><span class="line"><span class="attr">      label:</span> <span class="string">master</span></span><br><span class="line"><span class="comment">#服务注册中心</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><blockquote><p>如果你的 github 仓库是公开的话，就不需要输入账户和密码就可以访问。</p></blockquote><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>在启动类上加 @EnableConfigServer 注解，激活对配置中心的支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaConfigServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaConfigServerApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动-amp-验证"><a href="#启动-amp-验证" class="headerlink" title="启动 &amp; 验证"></a>启动 &amp; 验证</h3><p>因为配置中心作为一个独立的服务，所以不需要依赖其他服务的先启动，直接运行当前程序即可。这里我们首先需要验证下 server 端是否已经成功拉取到了 github 上面的配置信息：</p><p>访问：<a href="http://localhost:8091/glmapper/pre/master" target="_blank" rel="noopener">http://localhost:8091/glmapper/pre/master</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"glmapper"</span>,</span><br><span class="line">    <span class="attr">"profiles"</span>: [</span><br><span class="line">        <span class="string">"pre"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"label"</span>: <span class="string">"master"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"f9e8c1f2825d23031cb13d40e396a23c0f975d2d"</span>,</span><br><span class="line">    <span class="attr">"state"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"propertySources"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"https://github.com/glmapper/glmapper-config-repository/glmapper-pre.properties"</span>,</span><br><span class="line">            <span class="attr">"source"</span>: &#123;</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"leishu@glmapper-pre"</span>,</span><br><span class="line">                <span class="attr">"blog"</span>: <span class="string">"http://www.glmapper.com"</span>,</span><br><span class="line">                <span class="attr">"version"</span>: <span class="string">"pre"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK ，说明服务端已经成功拉取到了github上的配置文件了。</p><blockquote><p>关于地址的说明：<a href="http://localhost:8091/glmapper/pre/master" target="_blank" rel="noopener">http://localhost:8091/glmapper/pre/master</a> 。前半部分是ip和端口，没什么好说的。<br>glmapper/pre/master，因为我在github上新建的配置文件名是 glmapper-dev.properties 和 glmapper-pre .properties ;所以这里地址的规则就是 /glmapper/pre ，后面的 master 可带可不带，区别在于返回的 JSON 数据 label 是 null 还是 master，label 指向分支。</p></blockquote><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>本节构建一个简单的客户端工程 sofa-config-client ，用于从 sofa-config-server 上获取配置文件并展示。sofa-config-client 同样基于《SpringCloud-Eureka 服务注册》中构建的父工程。 </p><h3 id="修改-pom-文件-1"><a href="#修改-pom-文件-1" class="headerlink" title="修改 pom 文件"></a>修改 pom 文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-config-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入 spring-cloud-starter-config 和  spring-boot-starter-web 依赖。</p><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件包括两个，一个是 application.yml ，另一个是 bootstrap.yml</p><ul><li>application.yml</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sofa-config-client</span><br><span class="line">server:</span><br><span class="line">  port: 8099</span><br></pre></td></tr></table></figure><ul><li>bootstrap.yml</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      name: glmapper</span><br><span class="line">      profile: pre</span><br><span class="line">      uri: http://localhost:8091/   #指向配置中心的地址</span><br><span class="line">      label: master</span><br></pre></td></tr></table></figure><h3 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h3><p>启动类不需要做什么修改，也不需要额外加什么注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaConfigClientApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaConfigClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="资源类"><a href="#资源类" class="headerlink" title="资源类"></a>资源类</h3><p>新建一个资源类，用于输出展示拉取到的配置信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;blog&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span>  String blog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;version&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span>  String version;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/config"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">config</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name:"</span>+name+<span class="string">" ,blog:"</span>+blog+<span class="string">" ,version:"</span>+version;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="启动和运行"><a href="#启动和运行" class="headerlink" title="启动和运行"></a>启动和运行</h3><p>先后启动配置中心服务端和客户端程序。在浏览器中输入：<a href="http://localhost:8099/config" target="_blank" rel="noopener">http://localhost:8099/config</a> ，返回如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name:leishu@glmapper-pre ,blog:http://www.glmapper.com ,version:pre</span><br></pre></td></tr></table></figure></p><p>我们尝试下将 github 中 glmapper-pre.properties 这个配置文件进行修改，看下是否在这能获取到最新的依赖，修改之后，如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=leishu@glmapper_pre_update</span><br><span class="line">blog=http://www.glmapper.com</span><br><span class="line">version=pre</span><br></pre></td></tr></table></figure></p><p>重新刷新浏览器地址，返回如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name:leishu@glmapper-pre ,blog:http://www.glmapper.com ,version:pre</span><br></pre></td></tr></table></figure></p><p>这里并没有发生任何变换，因为 SpringBoot 项目只会在项目启动时才会获取一次配置文件信息，当我们修改了 github 上的配置文件之后，当前的配置中心客户端并没有主动去获取配置值，所以不会有新的值，我们获取到的还是旧的值。那么下面通过修改和增加一些组件和配置来实现不停服动态更新配置。</p><h3 id="配置动态更新"><a href="#配置动态更新" class="headerlink" title="配置动态更新"></a>配置动态更新</h3><p>要实现配置的动态更新，需要借助于 springboot 的 actuator 监控模块。所有需要在客户端pom文件中引入 actuator 的依赖信息。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>配置文件 application.yml 中增加配置，将/actuator/refresh 断点暴露出来，注意不要配置在 boostrap.yml 中。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sofa-config-client</span><br><span class="line">server:</span><br><span class="line">  port: 8099</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: refresh</span><br></pre></td></tr></table></figure></p><p>资源类中开启更新机制，在 ConfigClientController 类中增加 @RefreshScope 注解，然后重启客户端。</p><p>首先执行：<a href="http://localhost:8099/config" target="_blank" rel="noopener">http://localhost:8099/config</a> ，得到结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name:leishu@glmapper-pre ,blog:http://www.glmapper.com ,version:pre&lt;br /&gt;</span><br></pre></td></tr></table></figure></p><p>更新 github 上配置文件的值，将 name 改为 name:leishu@glmapper-pre，通过 curl 或者 postman 执行下 刷新：</p><p><img src="https://oscimg.oschina.net/oscnet/64907646317fdc6038cb4ab46f713fbc231.jpg" alt="image.png"></p><p>再次刷新执行 <a href="http://localhost:8099/config" target="_blank" rel="noopener">http://localhost:8099/config</a> ，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name:leishu@glmapper-pre-update ,blog:http://www.glmapper.com ,version:pre</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;在分布式系统中，每一个功能模块都能拆分成一个独立的服务，一次请求的完成，可能会调用很多个服务协调来完成，为了方便服务配置文件统一管理，更易于
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="Config" scheme="http://www.glmapper.com/tags/Config/"/>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-负载均衡器 Ribbon</title>
    <link href="http://www.glmapper.com/2018/12/31/springcoud-ribbon-project/"/>
    <id>http://www.glmapper.com/2018/12/31/springcoud-ribbon-project/</id>
    <published>2018-12-30T16:15:01.000Z</published>
    <updated>2019-01-09T15:32:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇 <a href="http://www.glmapper.com/2018/12/31/springcoud-feign-project/">SpringCloud-声明式服务调用 Feign</a> 中介绍了如何使用 Feign 来完成服务调用。因为 Feign 本身已经集成了 Ribbon ，所以也具有负载均衡的能力。那么本篇将使用 RestTemplate + Ribbon 来实现服务调用和负载均衡策略。</p><h2 id="Ribbon-简介"><a href="#Ribbon-简介" class="headerlink" title="Ribbon 简介"></a>Ribbon 简介</h2><p>Ribbon 是管理HTTP和TCP服务客户端的负载均衡器。Ribbon 具有一些列带有名称的客户端，也就是带有名称的Ribbon 客户端。每个客户端由可配置的组件构成，负责一类服务的调用请求。Spring Cloud 通过RibbonClientConfiguration 为每个Ribbon 客户端创建一个ApplicationContext 上下文来进行组件装配。Ribbon 作为 Spring Cloud的负载均衡机制的实现，可以与OpenFeign 和 RestTemplate 进行无缝集成，让二者也具有负载均衡的能力。</p><h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><table><thead><tr><th><strong>策略类</strong><br></th><th><strong>命名</strong><br></th><th>备注<br></th></tr></thead><tbody><tr><td>RoundRobinRule<br></td><td>轮训策略<br></td><td>按顺序循环选择 Server<br></td></tr><tr><td>RandomRule<br></td><td>随机策略<br></td><td>随机选择 Server<br></td></tr><tr><td>RetryRule<br></td><td>重试策略<br></td><td>在一个配置时问段内当选择 Server 不成功，则一直尝试选择一个可用的 Server<br></td></tr><tr><td>BestAvailableRule<br></td><td>最低并发策略<br></td><td>逐个考察 Server，如果 Server 断路器打开，则忽略，再选择其中并发连接最低的 Server    <br></td></tr><tr><td>AvailabilityFilteringRule<br></td><td>可用过滤策略<br></td><td>过滤掉一直连接失败并被标记为 <code>circuit tripped</code> 的 Server，过滤掉那些高并发连接的 Server（active connections 超过配置的网值）<br></td></tr><tr><td>ResponseTimeWeightedRule<br></td><td>响应时间加权策略<br></td><td>根据 Server 的响应时间分配权重。响应时间越长，权重越低，被选择到的概率就越低；响应时间越短，权重越高，被选择到的概率就越高。这个策略很贴切，综合了各种因素，如：网络、磁盘、IO等，这些因素直接影响着响应时间<br></td></tr><tr><td>ZoneAvoidanceRule<br></td><td>区域权衡策略<br></td><td>综合判断 Server 所在区域的性能和 Server 的可用性轮询选择 Server，并且判定一个 AWS Zone 的运行性能是否可用，剔除不可用的 Zone 中的所有 Server<br></td></tr></tbody></table><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK<br></td><td>1.8.0_162<br></td></tr><tr><td>SOFABoot/SpringBoot<br></td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE<br></td></tr><tr><td>SpringCloud<br></td><td>Finchley.RC1<br></td></tr><tr><td>IDE<br></td><td>IDEA<br></td></tr></tbody></table><h2 id="工程背景"><a href="#工程背景" class="headerlink" title="工程背景"></a>工程背景</h2><p>本节将会创建一个 sofa-eureka-consumer-Ribbon 工程，通过 Spring Cloud 提供的负载均衡器 Ribbon 实现服务的负载均衡，并对 Ribbon 中的负载均衡策略进行验证。</p><h2 id="新建-sofa-eureka-consumer-ribbon"><a href="#新建-sofa-eureka-consumer-ribbon" class="headerlink" title="新建 sofa-eureka-consumer-ribbon"></a>新建 sofa-eureka-consumer-ribbon</h2><p>本工程继续使用《SpringCloud-Eureka 服务注册》中的父工程来构建。</p><p>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p><ul><li>artifactId：sofa-eureka-consumer-ribbon</li></ul><p>前面我们已经对feign进行的实际操作，因此本节使用 Ribbon + RestTemplate 组合实现具体的负载均衡实验。</p><h3 id="修改-pom-文件"><a href="#修改-pom-文件" class="headerlink" title="修改 pom 文件"></a>修改 pom 文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-consumer-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8889</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka-consumer-ribbon</span></span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>这里需要引入 @EnableEurekaClient 注解，表示当前是一个客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaEurekaConsumerRibbonApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaEurekaConsumerRibbonApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@LoadBalanced ： Spring Cloud 为客户端负载均衡创建了特定的注解，被该注解修饰的 RestTemplate Bean实例，Spring Cloud 就会让 RestTemplate 使用相关的负载均衡策略，默认情况下使用的就是 Ribbon。</p><h3 id="资源类"><a href="#资源类" class="headerlink" title="资源类"></a>资源类</h3><p>这里我们通过 restTemplate 去访问 Provider 提供的服务，需要注意，这里为了演示作用，直接将资源 Url 固定写成：<a href="http://HELLOSOFASERVICE/hello" target="_blank" rel="noopener">http://HELLOSOFASERVICE/hello</a> ，<a href="http://hellosofaservice/hello" target="_blank" rel="noopener">HELLOSOFASERVICE</a> 为 Provider 提供的服务的实例名称，也就是 Eureka 服务端界面上对应的 <strong>Application。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://HELLOSOFASERVICE/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>这里正常先后启动 服务注册中心 sofa-eureka-server-center ；服务提供方 sofa-eureka-provider ，服务提供方为了方便演示，这里启动4个实例，对应的端口分别为：8081，8082，8083，8084，如下：</p><p><img src="https://oscimg.oschina.net/oscnet/71ffa9b404d5727807a4cfbdc44cdfa8346.jpg" alt="image.png"></p><p>然后启动当前 sofa-eurek-consumer-ribbon 工程。默认情况下，不指定任何负载均衡策略，使用的是轮询策略。</p><p>浏览器输入 <a href="http://localhost:8889/hello" target="_blank" rel="noopener">http://localhost:8889/hello</a> ，调用10次：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8082</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8084</span> And hostname is HelloSOFAService</span><br><span class="line">  </span><br><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8082</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8084</span> And hostname is HelloSOFAService</span><br><span class="line">  </span><br><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8082</span> And hostname is HelloSOFAService</span><br></pre></td></tr></table></figure></p><p>从结果来看，默认策略应该是轮询（不用情况下，调用顺序不一定是1-2-3-4，但是以每4组为一组来看，存在周期性）。</p><h2 id="负载均衡策略设置"><a href="#负载均衡策略设置" class="headerlink" title="负载均衡策略设置"></a>负载均衡策略设置</h2><h3 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h3><p>全局设置就是自己定义一个配置类，然后在配置类中指定具体的负载均衡策略。在com.alipay.sofa.cloud.configuration 包下面新建一个配置类，这里使用的策略是随机策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonGlobalLoadBalancingConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器输入 <a href="http://localhost:8889/hello" target="_blank" rel="noopener">http://localhost:8889/hello</a> ，调用10次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8084</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8084</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">  </span><br><span class="line">Hello SOFA! Now Port is <span class="number">8082</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8082</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8084</span> And hostname is HelloSOFAService</span><br><span class="line">  </span><br><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br></pre></td></tr></table></figure><p>从结果来看，具有随机属性。</p><h3 id="针对单个服务的-Ribbon-负载均衡策略"><a href="#针对单个服务的-Ribbon-负载均衡策略" class="headerlink" title="针对单个服务的 Ribbon 负载均衡策略"></a>针对单个服务的 Ribbon 负载均衡策略</h3><p>新建一个 RibbonRandomLBConfiguration 配置类，这里有个前提是需要删除 全局配置类  。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonRandomLBConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>修改启动类，增加 @RibbonClient 注解，并且通过 configuration 指定负载均衡策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@RibbonClient</span>(name=<span class="string">"HELLOSOFASERVICE"</span>,configuration = RibbonRandomLBConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaEurekaConsumerRibbonApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaEurekaConsumerRibbonApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器输入 <a href="http://localhost:8889/hello" target="_blank" rel="noopener">http://localhost:8889/hello</a> ，调用10次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">  </span><br><span class="line">Hello SOFA! Now Port is <span class="number">8084</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8082</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8082</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br><span class="line">  </span><br><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br></pre></td></tr></table></figure><p>从结果来看，具有随机属性。</p><p>@RibbonClient 注解属性中，name 并非是一个数组，也就是说只能指定一个服务实例。那么基于上述情况，如果还存在另外一个服务，比如 SOFABOOTHELLOSERVICE ，那么对于此服务的调用会是什么情况呢？</p><p>先向注册中心注册两个服务：<strong>HELLOSOFABOOTSERVICE 和 </strong>HELLOSOFASERVICE<em>**</em></p><p><img src="https://oscimg.oschina.net/oscnet/4ec12075c7fca68bf15d4c6793a6294d760.jpg" alt="image.png"></p><p>修改 RibbonController ，增加一个 /helloBoot 资源地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://HELLOSOFASERVICE/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/helloBoot"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloBoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://HELLOSOFABOOTSERVICE/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启启动当前服务。</p><p>浏览器中输入：<a href="http://localhost:8889/hello" target="_blank" rel="noopener">http://localhost:8889/hello</a> ，验证结果满足随机调用。</p><p>浏览器中输入：<a href="http://localhost:8889/helloBoot" target="_blank" rel="noopener">http://localhost:8889/helloBoot</a> ，验证结果满足轮询调用。</p><h3 id="基于配置文件的负载均衡策略设置"><a href="#基于配置文件的负载均衡策略设置" class="headerlink" title="基于配置文件的负载均衡策略设置"></a>基于配置文件的负载均衡策略设置</h3><p>个人感觉基于配置文件配置方式更加直观，而且对于多个服务对应不同的负载策略设置也更加清晰，下面对HELLOSOFASERVICE 和  HELLOSOFABOOTSERVICE 均使用随机策略。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">HELLOSOFASERVICE:</span></span><br><span class="line"><span class="attr">  ribbon:</span></span><br><span class="line"><span class="attr">    NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br><span class="line"></span><br><span class="line"><span class="attr">HELLOSOFABOOTSERVICE:</span></span><br><span class="line"><span class="attr">  ribbon:</span></span><br><span class="line"><span class="attr">    NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure><p>启动类中删除以下注解配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"HELLOSOFASERVICE"</span>, configuration = RibbonRandomLBConfiguration.class)</span><br></pre></td></tr></table></figure><p>重启启动当前服务。</p><p>浏览器中输入：<a href="http://localhost:8889/hello" target="_blank" rel="noopener">http://localhost:8889/hello</a> ，验证结果满足随机调用。<br>浏览器中输入：<a href="http://localhost:8889/helloBoot" target="_blank" rel="noopener">http://localhost:8889/helloBoot</a> ，验证结果满足随机调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇 &lt;a href=&quot;http://www.glmapper.com/2018/12/31/springcoud-feign-project/&quot;&gt;SpringCloud-声明式服务调用 Feign&lt;/a&gt; 中介绍了如何使用 Feign 来完成服务调用。因为 Feign 
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="spring cloud" scheme="http://www.glmapper.com/tags/spring-cloud/"/>
    
      <category term="Ribbon" scheme="http://www.glmapper.com/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-声明式服务调用 Feign</title>
    <link href="http://www.glmapper.com/2018/12/31/springcoud-feign-project/"/>
    <id>http://www.glmapper.com/2018/12/31/springcoud-feign-project/</id>
    <published>2018-12-30T16:14:06.000Z</published>
    <updated>2019-01-09T15:23:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Fegin 是一个声明式的 web 服务客户端，它使得编写 web 服务客户端变得更加容易。使用 Fegin 创建一个接口并对它进行注解。它具有可插拔的注解支持包括 Feign 注解与 JAX-RS 注解，Feign 还支持可插拔的编码器与解码器，Spring Cloud 增加了对 Spring MVC 的注解，Spring Web 默认使用了 HttpMessageConverters。Fegin 还可以集成 Ribbon 和 Hystrix 来提供负载均衡和网络断路器的功能。</p><p>本篇将使用 Fegin + eureka client 来完成服务发现和调用。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK<br></td><td>1.8.0_162<br></td></tr><tr><td>SOFABoot/SpringBoot<br></td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE<br></td></tr><tr><td>SpringCloud<br></td><td>Finchley.RC1<br></td></tr><tr><td>IDE<br></td><td>IDEA<br></td></tr></tbody></table><h2 id="工程背景"><a href="#工程背景" class="headerlink" title="工程背景"></a>工程背景</h2><p>本节将会创建一个 sofa-eureka-consumer-feign 工程，使用 Feign 提供的 web 客户端来访问 sofa-eureka-provider 发布的服务。同时也基于此工程验证基于 Feign 实现的负载均衡。</p><h2 id="新建-sofa-eureka-consumer-feign"><a href="#新建-sofa-eureka-consumer-feign" class="headerlink" title="新建 sofa-eureka-consumer-feign"></a>新建 sofa-eureka-consumer-feign</h2><p>本工程继续使用《SpringCloud-Eureka 服务注册》中的父工程来构建。</p><p>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p><ul><li>artifactId：sofa-eureka-consumer-feign</li></ul><h3 id="修改pom文件"><a href="#修改pom文件" class="headerlink" title="修改pom文件"></a>修改pom文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-server-center<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencys</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencys</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.port=8888</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:8761/eureka/</span><br><span class="line">spring.application.name=eureka-consumer-feign</span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>这里需要添加 @EnableEurekaClient 和 @EnableFeignClients 两个注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaEurekaConsumerFeignApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaEurekaConsumerFeignApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="资源类"><a href="#资源类" class="headerlink" title="资源类"></a>资源类</h3><ul><li>com.alipay.sofa.cloud.service 包下新建  HelloSOFAService</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"helloSOFAService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloSOFAService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>com.alipay.sofa.cloud.controller 包下新建  FeignController</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloSOFAService helloSOFAService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloSOFAService.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动-amp-验证"><a href="#启动-amp-验证" class="headerlink" title="启动 &amp; 验证"></a>启动 &amp; 验证</h3><p>启动当前工程，在此之前请以此启动 注册中心 sofa-eureka-server-center 和 sofa-eureka-provider 两个工程。</p><blockquote><p>注：这里我启动了两个 provider 工程</p></blockquote><p>浏览器输入：http:localhost:8888/hello，观察到浏览器中依次展示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello SOFA! Now Port is 8081 And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is 8082 And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is 8081 And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is 8082 And hostname is HelloSOFAService</span><br></pre></td></tr></table></figure></p><p>这里可以看待 通过 feign 提供的客户端能力已经访问到了远程服务，由于 feign 集成了 ribbon 因此也就默认实现了负载均衡的能力。从结果来看，默认的负载均衡策略是轮询。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Fegin 是一个声明式的 web 服务客户端，它使得编写 web 服务客户端变得更加容易。使用 Fegin 创建一个接口并对它进行注解。它
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="spring cloud" scheme="http://www.glmapper.com/tags/spring-cloud/"/>
    
      <category term="Feign" scheme="http://www.glmapper.com/tags/Feign/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud-Eureka Client 原理解析</title>
    <link href="http://www.glmapper.com/2018/12/31/springcoud-eureka-client-analysis/"/>
    <id>http://www.glmapper.com/2018/12/31/springcoud-eureka-client-analysis/</id>
    <published>2018-12-30T16:12:46.000Z</published>
    <updated>2019-01-11T15:20:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面一些 demo 中已经介绍了如何使用 SOFABoot 来集成 Spring Cloud Netflix Eureka 组件。本篇将来先解析下 Eureka Client 的工作原理。</p><h2 id="Netflix-和-SpringCloud"><a href="#Netflix-和-SpringCloud" class="headerlink" title="Netflix 和 SpringCloud"></a>Netflix 和 SpringCloud</h2><p>spring-cloud-commons 模块是 spring 在分布式领域上(服务发现，服务注册，断路器，负载均衡)的规范定义。spring-cloud-netflix 是基于此规范的具体实现，Netflix OSS 里的各种组件也都实现了这个 commons 规范。关系如下：<br><img src="https://oscimg.oschina.net/oscnet/955bbfee782856642563be3bbbdb8e32d4e.jpg" alt="image.png"></p><h2 id="Spring-Cloud-Netflix-Eureka-服务发现实现原理"><a href="#Spring-Cloud-Netflix-Eureka-服务发现实现原理" class="headerlink" title="Spring Cloud Netflix Eureka 服务发现实现原理"></a>Spring Cloud Netflix Eureka 服务发现实现原理</h2><p>基于上图，这里以 Eureka 中的服务发现为例，来具体讲下是如何实现的。Spring Cloud common 中提供了用于服务发现的两个关键类：DiscoveryClient 接口 和 EnableDiscoveryClient 注解。</p><h3 id="DiscoveryClient-接口"><a href="#DiscoveryClient-接口" class="headerlink" title="DiscoveryClient 接口"></a>DiscoveryClient 接口</h3><p>下面这张图描述的是在服务发现这个功能上，SpringCloud 是如何与 Netflix 整合的。<br>在 spring-cloud-netflix-eureka-client 中对 Spring Cloud Common 中的 DiscoveryClient 接口进行了实现，实现类是 EurekaDiscoveryClient 。<br><img src="https://oscimg.oschina.net/oscnet/a123885eae0d4c0ab198c02d5ad551475bd.jpg" alt="image.png"></p><p>DiscoveryClient 的接口定义与方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DiscoveryClient表示服务发现常用的读取操作，例如Netflix Eureka或consul.io</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spencer Gibb</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscoveryClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现描述</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the description</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">description</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取与特定serviceId关联的所有ServiceInstances</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> serviceId the serviceId to query</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a List of ServiceInstance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;ServiceInstance&gt; <span class="title">getInstances</span><span class="params">(String serviceId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回所有已知的服务ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getServices</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EurekaDiscoveryClient 中实现了这几个方法，但是 EurekaDiscoveryClient 自身没有实现如何与服务端交互的逻辑，而是通过 com.netflix.DiscoveryClient 类来完成。所以 spring-cloud-netflix-eureka-client 干的事情就是实现了 Spring Cloud Common 规范，然后在实现上包装了 netflix 。</p><h3 id="EnableDiscoveryClient-注解"><a href="#EnableDiscoveryClient-注解" class="headerlink" title="@EnableDiscoveryClient 注解"></a>@EnableDiscoveryClient 注解</h3><p><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import</span>(EnableDiscoveryClientImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableDiscoveryClient &#123;</span><br><span class="line">  <span class="comment">//是否自动注册，默认是true。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">autoRegister</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>EnableDiscoveryClientImportSelector 将会从 META-INF/spring.factories 里找出 key 为org.springframework.cloud.client.discovery.EnableDiscoveryClient 的类。</p><p>对于 autoRegister ：</p><ul><li>如果自动注册属性为true，会在找出的这些类里再加上一个类：AutoServiceRegistrationConfiguration， AutoServiceRegistrationConfiguration 内部会使用@EnableConfigurationProperties(AutoServiceRegistrationProperties.class) 触发构造AutoServiceRegistrationProperties 这个 bean。像eureka，nacos，它们的自动化配置类里都使用了@ConditionalOnBean(AutoServiceRegistrationProperties.class) 来确保存在AutoServiceRegistrationProperties 这个 bean 存在的时候才会构造 AutoServiceRegistration 进行注册。</li><li>如果自动注册属性为 false，在Environment 里加一个 PropertySource，内部的配置项是spring.cloud.service-registry.auto-registration.enabled，值是false(代表不构造AutoServiceRegistrationProperties.class)。这样 eureka 就不会注册。</li></ul><p>对应上面这段逻辑的代码如下：</p><p><img src="https://oscimg.oschina.net/oscnet/219321a0468aaa9abbd81af27292bc927d6.jpg" alt="image.png"></p><p>spring-cloud-netflix-eureka-client 自己也提供了一个注解 EnableEurekaClient，其作用于这个注解一样</p><h2 id="Eureka-架构图"><a href="#Eureka-架构图" class="headerlink" title="Eureka 架构图"></a>Eureka 架构图</h2><p><img src="https://oscimg.oschina.net/oscnet/a43e024e39d5d351b0e4961bd61e4bd71de.jpg" alt="image.png"></p><ul><li>consumer  : 服务消费方，eureka client 角色，可以从 eureka server 上拉取到其他已注册服务的信息，从而根据这些信息找到自己所需的服务，然后发起远程调用。</li><li>provider : 服务提供方，eureka client 角色，可以向 eureka server 上注册和更新自己的信息，当然作为 eureka client ，它也可以从server 上获取到其他服务的信息。</li><li>Eureka server : 服务注册中心，提供服务注册和服务发现功能；</li><li>同步复制 ： eureka server 之间进行注册服务信息的同步，这样可以保证集群中每个server 都能提供完整的服务信息。</li></ul><blockquote><p>关于 AWS 上 Regin 和 Availability Zone 的概念，请自行查阅相关资料</p></blockquote><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="配置信息读取"><a href="#配置信息读取" class="headerlink" title="配置信息读取"></a>配置信息读取</h3><p>Eureka Client的自动配置类是 org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration ，这里面主要就负责了一些配置信息的服务诸如 DiscoveryClient 、EurekaServiceRegistry等主要bean的初始化工作。</p><p>另外还有一个 EurekaDiscoveryClientConfiguration 类，负责配置自动注册和应用的健康检查器初始化。</p><h4 id="读取-eureka-client"><a href="#读取-eureka-client" class="headerlink" title="读取 eureka.client.*"></a>读取 eureka.client.*</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = EurekaClientConfig.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="function"><span class="keyword">public</span> EurekaClientConfigBean <span class="title">eurekaClientConfigBean</span><span class="params">(ConfigurableEnvironment env)</span> </span>&#123;</span><br><span class="line">EurekaClientConfigBean client = <span class="keyword">new</span> EurekaClientConfigBean();</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"bootstrap"</span>.equals(<span class="keyword">this</span>.env.getProperty(<span class="string">"spring.config.name"</span>))) &#123;</span><br><span class="line">    <span class="comment">// 默认情况下，我们不会在引导过程中注册，但是以后会有另一个机会。</span></span><br><span class="line">    client.setRegisterWithEureka(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EurekaClientConfigBean 封装的是 eureka client 和 eureka server 交互所需要的配置信息，比如前面demo工程中的 eureka.client.service-url.defaultZone 的配置。</p><h4 id="读取-eureka-instance"><a href="#读取-eureka-instance" class="headerlink" title="读取 eureka.instance.*"></a>读取 eureka.instance.*</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = EurekaInstanceConfig.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="function"><span class="keyword">public</span> EurekaInstanceConfigBean <span class="title">eurekaInstanceConfigBean</span><span class="params">(InetUtils inetUtils,</span></span></span><br><span class="line"><span class="function"><span class="params">ManagementMetadataProvider managementMetadataProvider)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 代码较长，此处省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EurekaInstanceConfigBean 封装的是 eureka client 自身实例的配置信息，提供服务注册的基本元数据信息。</p><h3 id="核心组件-bean-初始化"><a href="#核心组件-bean-初始化" class="headerlink" title="核心组件 bean 初始化"></a>核心组件 bean 初始化</h3><p>这里也实例化了一些核心的组件bean。</p><h4 id="ApplicationInfoManager"><a href="#ApplicationInfoManager" class="headerlink" title="ApplicationInfoManager"></a>ApplicationInfoManager</h4><ul><li>EurekaClientConfiguration#eurekaApplicationInfoManager</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = ApplicationInfoManager.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApplicationInfoManager <span class="title">eurekaApplicationInfoManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">EurekaInstanceConfig config)</span> </span>&#123;</span><br><span class="line">  InstanceInfo instanceInfo = <span class="keyword">new</span> InstanceInfoFactory().create(config);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ApplicationInfoManager(config, instanceInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>RefreshableEurekaClientConfiguration#eurekaApplicationInfoManager<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = ApplicationInfoManager.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="meta">@org</span>.springframework.cloud.context.config.annotation.RefreshScope</span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ApplicationInfoManager <span class="title">eurekaApplicationInfoManager</span><span class="params">(EurekaInstanceConfig config)</span> </span>&#123;</span><br><span class="line">  InstanceInfo instanceInfo = <span class="keyword">new</span> InstanceInfoFactory().create(config);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ApplicationInfoManager(config, instanceInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>RefreshScope ，被此注解标注的情况下，将会被动态刷新。包括属性信息等，注意，对于动态刷新，被RefreshScope标记的类不能是final的。</p></blockquote><p>ApplicationInfoManager 是应用信息管理器，用于管理服务实例的信息类 InstanceInfo 和服务实例的配置信息类 EurekaInstanceConfig 。</p><h4 id="DiscoveryClient"><a href="#DiscoveryClient" class="headerlink" title="DiscoveryClient"></a>DiscoveryClient</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DiscoveryClient <span class="title">discoveryClient</span><span class="params">(EurekaInstanceConfig config, EurekaClient client)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> EurekaDiscoveryClient(config, client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DiscoveryClient ，前面说到，这个类是Spring Cloud 中用于服务发现使用的客户端接口。注意这里是SpringCloud提供的接口，不是netflix中的类。</p><h4 id="EurekaServiceRegistry"><a href="#EurekaServiceRegistry" class="headerlink" title="EurekaServiceRegistry"></a>EurekaServiceRegistry</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EurekaServiceRegistry <span class="title">eurekaServiceRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> EurekaServiceRegistry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EurekaServiceRegistry 是 ServiceRegistry 的实现类。ServiceRegistry 是 SpringCloud 提供了注册和注销等方法，这些方法允许用户提供自定义注册服务。</p><h4 id="EurekaRegistration"><a href="#EurekaRegistration" class="headerlink" title="EurekaRegistration"></a>EurekaRegistration</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(AutoServiceRegistrationProperties.class)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"spring.cloud.service-registry.auto-registration.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> EurekaRegistration <span class="title">eurekaRegistration</span><span class="params">(EurekaClient eurekaClient, CloudEurekaInstanceConfig instanceConfig, ApplicationInfoManager applicationInfoManager, ObjectProvider&lt;HealthCheckHandler&gt; healthCheckHandler)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> EurekaRegistration.builder(instanceConfig)</span><br><span class="line">.with(applicationInfoManager)</span><br><span class="line">.with(eurekaClient)</span><br><span class="line">.with(healthCheckHandler)</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 ServiceRegistry 实现都有自己的 Registry 实现。</p><ul><li>ZookeeperRegistration -&gt; ZookeeperServiceRegistry</li><li>ZookeeperRegistration -&gt; EurekaServiceRegistry</li><li>ConsulRegistration       -&gt; ConsulServiceRegistry</li></ul><p>如果你需要自定义实现 ServiceRegistry ，则也不要提供一个 Registration  的实现。</p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>服务发现的基本情况在上面已经提到了，但是由于 SpingCloud 中并没有提供具体的交互操作而是由 com.netflix.discovery.DiscoveryClient 来完成具体工作。所以关于服务服务发现这里就直接围绕这个类来展开。</p><p><img src="https://oscimg.oschina.net/oscnet/a03127ebf5610a9684598a7b12faafd8582.jpg" alt="image.png"></p><h3 id="LookopService"><a href="#LookopService" class="headerlink" title="LookopService"></a>LookopService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LookupService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 根据服务实例注册的appName 来获取 Application</span></span><br><span class="line">    <span class="function">Application <span class="title">getApplication</span><span class="params">(String appName)</span></span>;</span><br><span class="line">    <span class="comment">// 返回当前注册表中所有的服务实例信息</span></span><br><span class="line">    <span class="function">Applications <span class="title">getApplications</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 根据服务实例Id获取服务实例信息</span></span><br><span class="line">    <span class="function">List&lt;InstanceInfo&gt; <span class="title">getInstancesById</span><span class="params">(String id)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个可能的服务器，以处理来自从eureka接收到的注册表信息的请求。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@virtualHostname</span> 与服务器关联的虚拟主机名。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@secure</span> 指示是HTTP还是HTTPS请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">InstanceInfo <span class="title">getNextServerFromEureka</span><span class="params">(String virtualHostname, <span class="keyword">boolean</span> secure)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LookupService 接口的作用就是用于查找活动服务实例；总共提供了四个方法，很好理解。每个方法的作用见注释。</p><h3 id="EurekaClient"><a href="#EurekaClient" class="headerlink" title="EurekaClient"></a>EurekaClient</h3><p>EurekaClient 也是一个接口，集成并且扩展了 LookupService。<br><br></p><blockquote><p>This interface does NOT try to clean up the current client interface for eureka 1.x. Rather it tries<br>to provide an easier transition path from eureka 1.x to eureka 2.x.<br>从这来看，EurekaClient 的存在是为了给 Eureka1.x 向 Eureka 2.x 升级提供容错能力。</p></blockquote><p>EurekaClient 在 LookupService 基础上扩展了很多方法，如下：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EurekaClient</span> <span class="keyword">extends</span> <span class="title">LookupService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 省去@Deprecated方法和获取服务实例信息的接口方法</span></span><br><span class="line"><span class="comment">// 注册健康检查处理器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerHealthCheck</span><span class="params">(HealthCheckHandler healthCheckHandler)</span></span>;</span><br><span class="line"><span class="comment">// 监听client服务信息的更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerEventListener</span><span class="params">(EurekaEventListener eventListener)</span></span>;</span><br><span class="line">   <span class="comment">// 取消监听</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unregisterEventListener</span><span class="params">(EurekaEventListener eventListener)</span></span>;</span><br><span class="line"> <span class="comment">// 获取当前健康检查处理器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HealthCheckHandler <span class="title">getHealthCheckHandler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 关闭 eureka 客户端。还向eureka服务器发送撤销注册请求。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// EurekaClientConfig</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EurekaClientConfig <span class="title">getEurekaClientConfig</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="comment">// ApplicationInfoManager</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationInfoManager <span class="title">getApplicationInfoManager</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>HealthCheckHandler 这个是用于检查当前客户端状态的，这个在后面心跳机制里面会说道。</p><h3 id="DiscoveryClient-1"><a href="#DiscoveryClient-1" class="headerlink" title="DiscoveryClient"></a>DiscoveryClient</h3><p>com.netflix.discovery.DiscoveryClient，这个类会在构造函数中完成一系列重要的操作，如：拉取注册表信息，服务注册，初始化心跳机制，缓存刷新，按需注册定时任务等等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DiscoveryClient(ApplicationInfoManager applicationInfoManager, </span><br><span class="line"> EurekaClientConfig config, </span><br><span class="line">                AbstractDiscoveryClientOptionalArgs args,</span><br><span class="line">                Provider&lt;BackupRegistry&gt; backupRegistryProvider) &#123;</span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>几个参数的释义如下：</p><ul><li>applicationInfoManager ：应用信息管理器</li><li>config ：client 与 server 交互的配置信息</li><li>args ：客户端提供的过滤器类型(支持jersey1和jersey2)，后面用来构建 EurekaTransport</li><li>backupRegistryProvider ： 备份注册中心</li></ul><h3 id="服务发现-1"><a href="#服务发现-1" class="headerlink" title="服务发现"></a>服务发现</h3><p>下面代码片段也是在 DiscoveryClient 的构造函数里面的，这里就是拉取注册服务信息的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(<span class="keyword">false</span>)) &#123;</span><br><span class="line">fetchRegistryFromBackup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clientConfig.shouldFetchRegistry() 这个方法拿到的就是配置文件中 eureka.client.fetch-registry 的值，默认为true，表示从 eureka server 拉取注册表信息。</p><p>fetchRegistry(boolean)是从 eureka server 拉取注册信息的方法，参数用于表示是否是强制拉取全量的注册信息；此方法除非在协调eureka服务器和客户端注册表信息方面存在问题，否则此方法只尝试在第一次进行全量获取，后面均是增量获取。</p><p>fetchRegistryFromBackup() 如果 eureka server 服务不可用，则采用的备用方案。</p><h4 id="底层通信实现-EurekaTransport"><a href="#底层通信实现-EurekaTransport" class="headerlink" title="底层通信实现 EurekaTransport"></a>底层通信实现 EurekaTransport</h4><p>EurekaTransport 是 DiscoveryClient 的内部类，EurekaTransport 封装了具体的基于 jersey 的底层通信实现。</p><h4 id="FetchRegistry"><a href="#FetchRegistry" class="headerlink" title="FetchRegistry"></a>FetchRegistry</h4><p><img src="https://oscimg.oschina.net/oscnet/9ade5582f8c167659c4d35702063518bec0.jpg" alt="image.png"><br>上图为拉取注册信息的整个过程。对于黄色贴条上的条件，如果满足其中一个，则都会进行全量拉取；否则进行增量拉取。计算 hash 值是为了后面可以与server端应用信息的进行对比，用于感知是否需要重新进行拉取操作。</p><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><p>服务注册逻辑也是在 DiscoveryClient 的构造函数中完成，代码片段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka() &amp;&amp; clientConfig.shouldEnforceRegistrationAtInit()) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!register() ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Registration error at startup. Invalid server response."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">    logger.error(<span class="string">"Registration error at startup: &#123;&#125;"</span>, th.getMessage());</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(th);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向server端注册需要满足的两个条件是：1、允许向server端注册  2、是否在客户端初始化期间强制注册<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">register</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  logger.info(PREFIX + <span class="string">"&#123;&#125;: registering service..."</span>, appPathIdentifier);</span><br><span class="line">  EurekaHttpResponse&lt;Void&gt; httpResponse;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  httpResponse = eurekaTransport.registrationClient.register(instanceInfo);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.warn(PREFIX + <span class="string">"&#123;&#125; - registration failed &#123;&#125;"</span>, appPathIdentifier, e.getMessage(), e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">  logger.info(PREFIX + <span class="string">"&#123;&#125; - registration status: &#123;&#125;"</span>, appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> httpResponse.getStatusCode() == <span class="number">204</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过 eurekaTransport 对象，基于 REST 调用向 eureka server 进行服务注册。</p><h2 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h2><p>心跳机制的初始化工作也是在 DiscoveryClient 构造函数中完成。在DiscoveryClient构造函数的最后，有一个初始化调度任务的方法，在这个方法里就包括心跳的初始化。</p><p>heartbeatExecutor 心跳线程池：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">heartbeatExecutor = new ThreadPoolExecutor(</span><br><span class="line">                    1, clientConfig.getHeartbeatExecutorThreadPoolSize(), 0, TimeUnit.SECONDS,</span><br><span class="line">                    new SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                    new ThreadFactoryBuilder()</span><br><span class="line">                            .setNameFormat(&quot;DiscoveryClient-HeartbeatExecutor-%d&quot;)</span><br><span class="line">                            .setDaemon(true)</span><br><span class="line">                            .build()</span><br></pre></td></tr></table></figure><p>scheduler 提交周期执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Heartbeat timer</span></span><br><span class="line">scheduler.schedule(</span><br><span class="line">                  <span class="keyword">new</span> TimedSupervisorTask(</span><br><span class="line">                  <span class="string">"heartbeat"</span>,</span><br><span class="line">                  scheduler,</span><br><span class="line">                  heartbeatExecutor,</span><br><span class="line">                  renewalIntervalInSecs,</span><br><span class="line">                  TimeUnit.SECONDS,</span><br><span class="line">                  expBackOffBound,</span><br><span class="line">                  <span class="keyword">new</span> HeartbeatThread()</span><br><span class="line">                  ),</span><br><span class="line">renewalIntervalInSecs, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></p><p>TimedSupervisorTask 是 eureka 中自动调节间隔的周期性任务类。HeartbeatThread 是具体执行任何的线程，run方法中执行的就是 renew() 续期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">renew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 eurekaTransport 来与 server 通信续期</span></span><br><span class="line">    httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, <span class="keyword">null</span>);</span><br><span class="line">    logger.debug(PREFIX + <span class="string">"&#123;&#125; - Heartbeat status: &#123;&#125;"</span>, appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">    <span class="comment">// 404 标识当前服务实例不存在</span></span><br><span class="line">    <span class="keyword">if</span> (httpResponse.getStatusCode() == <span class="number">404</span>) &#123;</span><br><span class="line">      <span class="comment">// 记录心跳次数</span></span><br><span class="line">      REREGISTER_COUNTER.increment();</span><br><span class="line">      logger.info(PREFIX + <span class="string">"&#123;&#125; - Re-registering apps/&#123;&#125;"</span>, appPathIdentifier, instanceInfo.getAppName());</span><br><span class="line">      <span class="keyword">long</span> timestamp = instanceInfo.setIsDirtyWithTime();</span><br><span class="line">      <span class="comment">// 重新注册</span></span><br><span class="line">      <span class="keyword">boolean</span> success = register();</span><br><span class="line">      <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      instanceInfo.unsetIsDirty(timestamp);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 200 状态正常</span></span><br><span class="line">    <span class="keyword">return</span> httpResponse.getStatusCode() == <span class="number">200</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    logger.error(PREFIX + <span class="string">"&#123;&#125; - was unable to send heartbeat!"</span>, appPathIdentifier, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务下线"><a href="#服务下线" class="headerlink" title="服务下线"></a>服务下线</h2><p>关闭 eureka client，还向 eureka server 发送撤销注册请求。该方法在DiscoveryClient#shutdown 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 保证原子操作</span></span><br><span class="line">        <span class="keyword">if</span> (isShutdown.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            logger.info(<span class="string">"Shutting down DiscoveryClient ..."</span>);</span><br><span class="line">            <span class="keyword">if</span> (statusChangeListener != <span class="keyword">null</span> &amp;&amp; applicationInfoManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 应用管理器取消状态监听</span></span><br><span class="line">                applicationInfoManager.unregisterStatusChangeListener(statusChangeListener.getId());</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 清理任务调度执行</span></span><br><span class="line">            cancelScheduledTasks();</span><br><span class="line">            <span class="comment">// If APPINFO was registered</span></span><br><span class="line">            <span class="keyword">if</span> (applicationInfoManager != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; clientConfig.shouldRegisterWithEureka()</span><br><span class="line">                    &amp;&amp; clientConfig.shouldUnregisterOnShutdown()) &#123;</span><br><span class="line">              <span class="comment">//设置服务实例状态为 DOWN</span></span><br><span class="line">                applicationInfoManager.setInstanceStatus(InstanceStatus.DOWN);</span><br><span class="line">              <span class="comment">//注销注册</span></span><br><span class="line">                unregister();</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 关闭 jersey 客户端</span></span><br><span class="line">            <span class="keyword">if</span> (eurekaTransport != <span class="keyword">null</span>) &#123;</span><br><span class="line">                eurekaTransport.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">            heartbeatStalenessMonitor.shutdown();</span><br><span class="line">            registryStalenessMonitor.shutdown();</span><br><span class="line">            logger.info(<span class="string">"Completed shut down of DiscoveryClient"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面一些 demo 中已经介绍了如何使用 SOFABoot 来集成 Spring Cloud Netflix Eureka 组件。本篇将来先解析下 Eureka Client 的工作原理。&lt;/p&gt;
&lt;h2 id=&quot;Netflix-和-SpringCloud&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="spring cloud" scheme="http://www.glmapper.com/tags/spring-cloud/"/>
    
      <category term="Eureka" scheme="http://www.glmapper.com/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-Eureka 服务发现</title>
    <link href="http://www.glmapper.com/2018/12/31/springcoud-eureka-discovery/"/>
    <id>http://www.glmapper.com/2018/12/31/springcoud-eureka-discovery/</id>
    <published>2018-12-30T16:06:53.000Z</published>
    <updated>2019-01-09T15:13:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇将继续接着上一篇 <a href="http://www.glmapper.com/2018/12/31/springcoud-eureka-register/">SpringCloud-服务注册</a> ，通过使用 DiscoveryClient 来实现服务发现，并且消费。</p><p>DiscoveryClient 源自于 spring-cloud-client-discovery ，是 spring cloud 中被定义用来服务发现的公共接口，在 spring cloud 的各类服务发现组件中，都有对应的实现，如 eureka、consul、zookeeper 。它提供从服务注册中心获取服务实例信息的能力。如果我们想自己实现一个服务发现组件，集成到spring cloud 中，就完全可以通过实现此接口来完成。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK<br></td><td>1.8.0_162<br></td></tr><tr><td>SOFABoot/SpringBoot<br></td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE<br></td></tr><tr><td>SpringCloud<br></td><td>Finchley.RC1<br></td></tr><tr><td>IDE<br></td><td>IDEA<br></td></tr></tbody></table><h2 id="工程背景"><a href="#工程背景" class="headerlink" title="工程背景"></a>工程背景</h2><p>本案例使用 SOFABoot 3.0.x 版本集成 SringCloud F版。工程如下：</p><ul><li>sofa-eureka-consumer-discovery     服务消费方</li></ul><p>本工程的父工程继续使用《SpringCloud-Eureka 服务注册》文中新建的父工程。</p><h2 id="新建-sofa-eureka-consumer-discovery"><a href="#新建-sofa-eureka-consumer-discovery" class="headerlink" title="新建 sofa-eureka-consumer-discovery"></a>新建 sofa-eureka-consumer-discovery</h2><p>这里我们通过 sofa-eureka-consumer-discovery 这个工程来手动发现服务。</p><p>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p><ul><li>artifactId：sofa-eureka-consumer-discovery。</li></ul><h3 id="修改-pom-文件"><a href="#修改-pom-文件" class="headerlink" title="修改 pom 文件"></a>修改 pom 文件</h3><p>引入 spring-cloud-starter-netflix-eureka-client 依赖。<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-consumer-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.port=8088</span><br><span class="line">spring.application.name=sofa-eureka-discovery</span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/</span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaEurekaConsumerDiscoveryApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaEurekaConsumerDiscoveryApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务获取"><a href="#服务获取" class="headerlink" title="服务获取"></a>服务获取</h3><p>这里通过 DiscoveryClient 对像手动获取到 HELLOSOFASERVICE 服务对应的所有实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscoveryController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/instance"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(<span class="string">"HELLOSOFASERVICE"</span>);</span><br><span class="line">        System.out.println(<span class="string">"current service size = "</span> + discoveryClient.getServices().size());</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>( String s :  discoveryClient.getServices())&#123;</span><br><span class="line">            stringBuilder.append(<span class="string">"services="</span> + s).append(<span class="string">"\n"</span>);</span><br><span class="line">            List&lt;ServiceInstance&gt; serviceInstances =  discoveryClient.getInstances(s);</span><br><span class="line">            <span class="keyword">for</span>(ServiceInstance si : serviceInstances)&#123;</span><br><span class="line">                stringBuilder.append(<span class="string">"url="</span>).append(si.getUri()).append(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuilder.append(<span class="string">"instance num"</span>).append(<span class="string">"="</span>).append(list.size());</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动-amp-验证"><a href="#启动-amp-验证" class="headerlink" title="启动 &amp; 验证"></a>启动 &amp; 验证</h3><p>启动当前工程，在此之前确保 注册中心和服务提供工程均已正常启动。然后在浏览器中输入：http:localhost:8088/instance</p><p><img src="https://oscimg.oschina.net/oscnet/1f7ea4c0b3f4e1eaccc37a5cc3baba5d47e.jpg" alt="image.png"></p><p>可以看到获取到的实例信息与注册中心上的实例信息是匹配的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇将继续接着上一篇 &lt;a href=&quot;http://www.glmapper.com/2018/12/31/springcoud-eureka-register/&quot;&gt;SpringCloud-服务注册&lt;/a&gt; ，通过使用 DiscoveryClient 来实现服务发现，并且
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="spring cloud" scheme="http://www.glmapper.com/tags/spring-cloud/"/>
    
      <category term="Eureka" scheme="http://www.glmapper.com/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-Eureka 服务注册</title>
    <link href="http://www.glmapper.com/2018/12/31/springcoud-eureka-register/"/>
    <id>http://www.glmapper.com/2018/12/31/springcoud-eureka-register/</id>
    <published>2018-12-30T16:05:40.000Z</published>
    <updated>2019-01-09T15:04:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spring Cloud Netflix Eureka 是 Spring Cloud 提供的用于服务注册和发现的基础组件，在 Spring Cloud 微服务体系中承担着相当重要的角色。Eureka 作为一个开箱即用的基础组件，其屏蔽了底层 Client 和 Server 交互的细节，使得开发者能够快速入手，将更多的精力投入到业务逻辑上去。</p><p>Eureka 是基于 Rest 实现的，及底层客户端和服务端之间的交互是通过 Rest 服务进行交互的。Eureka 包括两个部分，即服务端可客户端。</p><ul><li>服务端：Eureka Server ,提供服务注册和发现的功能</li><li>客户端：Eureka Client ,将自己的信息注册到 Eureka Server ，并从 Eureka Server 中发现其他服务。</li></ul><p>Eureka 本篇将先来搭建一个服务端，以作为后续篇幅的注册中心来使用。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK<br></td><td>1.8.0_162<br></td></tr><tr><td>SOFABoot/SpringBoot<br></td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE<br></td></tr><tr><td>SpringCloud<br></td><td>Finchley.RC1<br></td></tr><tr><td>IDE<br></td><td>IDEA<br></td></tr></tbody></table><h2 id="工程背景"><a href="#工程背景" class="headerlink" title="工程背景"></a>工程背景</h2><p>本案例使用 SOFABoot 3.0.x 版本集成 SringCloud F版。工程如下：</p><ul><li>sofa-eureka-server         服务注册中心</li><li>sofa-eureka-provider      服务提供方</li><li>sofa-eureka-comsumer   服务消费方</li></ul><p>本工程都是在同一个父工程下面的，因此工程构建开始会新建一个 SOFABoot 工程作为父工程。</p><h2 id="新建父工程"><a href="#新建父工程" class="headerlink" title="新建父工程"></a>新建父工程</h2><p>这里父工程直接新建一个SpringBoot 工程。可以使用 IDEA 的生成，也可以通过 <a href="http://www.sofastack.tech/sofa-boot/docs/QuickStart" target="_blank" rel="noopener">SOFABoot 快速开始</a> 新建一个 SpringBoot 工程，删除 src 目录，然后修改 pom.xml 文件。</p><ul><li>gourpId : com.alipay.sofa</li><li>artifactId : sofa-eureka-parent</li></ul><h3 id="parent-依赖修改"><a href="#parent-依赖修改" class="headerlink" title="parent 依赖修改"></a><strong>parent 依赖修改</strong></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofaboot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="管控-SpringCloud-依赖"><a href="#管控-SpringCloud-依赖" class="headerlink" title="管控 SpringCloud 依赖"></a>管控 SpringCloud 依赖</h3><p>在主 pom 里面加入 SpringCloud 的依赖管控。版本为 Finchley.RC1<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.RC1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="配置-SpringCloud-仓库"><a href="#配置-SpringCloud-仓库" class="headerlink" title="配置 SpringCloud 仓库"></a>配置 SpringCloud 仓库</h3><p>在主pom.xml 中添加如下配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Milestones<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>OK，到这里，父工程创建完毕。</p><h2 id="新建-sofa-eureka-server-center"><a href="#新建-sofa-eureka-server-center" class="headerlink" title="新建 sofa-eureka-server-center"></a>新建 sofa-eureka-server-center</h2><p>sofa-eureka-server-center 作为注册中心的服务端。</p><p>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p><ul><li>artifactId：sofa-eureka-server-center。</li></ul><h3 id="pom-文件修改"><a href="#pom-文件修改" class="headerlink" title="pom 文件修改"></a>pom 文件修改</h3><p>引入 spring-cloud-starter-netflix-eureka-server 依赖，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-server-center<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="新建资源文件-application-yml"><a href="#新建资源文件-application-yml" class="headerlink" title="新建资源文件 application.yml"></a>新建资源文件 application.yml</h3><p>在 /src/main/resources 目录下新建 application.yml 或者 application.properties。这里以.yml文件为例：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span>    <span class="comment">#指定服务端口</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">sofa-eureka-server</span></span><br></pre></td></tr></table></figure></p><blockquote><p>配置文件后面统一说明</p></blockquote><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>在 /src/main/resources 目录下新建 com.alipay.sofa.cloud 包目录，并且在当前包路劲下新建 SofaEurekaServerApplication 类，并且类上加上 @EnableEurekaServer 注解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaEurekaServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaEurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="启动程序-amp-验证"><a href="#启动程序-amp-验证" class="headerlink" title="启动程序 &amp; 验证"></a>启动程序 &amp; 验证</h3><p>启动当前应用。并且浏览器中输入：<a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a></p><p><img src="https://oscimg.oschina.net/oscnet/e46c56c9b7d431b2dc113e479255fa3eff7.jpg" alt="image.png"></p><p>服务正常运行，界面如上图所示；此时还没有服务注册进来，因此红色框内显示 ：No instances available</p><h2 id="新建-sofa-eureka-provider"><a href="#新建-sofa-eureka-provider" class="headerlink" title="新建 sofa-eureka-provider"></a>新建 sofa-eureka-provider</h2><p>sofa-eureka-provider 作为服务提供方，将会向注册中心 sofa-eureka-server-center 上注册服务。</p><p>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p><ul><li>artifactId：sofa-eureka-provider。</li></ul><h3 id="pom-文件修改-1"><a href="#pom-文件修改-1" class="headerlink" title="pom 文件修改"></a>pom 文件修改</h3><p>引入 spring-cloud-starter-netflix-eureka-client 和 spring-boot-starter-web 依赖，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="新建资源文件"><a href="#新建资源文件" class="headerlink" title="新建资源文件"></a>新建资源文件</h3><p>在 /src/main/resources 目录下新建 application.yml 或者 application.properties。这里以.yml文件为例：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span>  <span class="comment">#指定注册中心地址</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">HelloSOFAService</span>   <span class="comment">#服务名称</span></span><br></pre></td></tr></table></figure></p><h3 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h3><p>在 /src/main/resources 目录下新建 com.alipay.sofa.cloud 包目录，并且在当前包路劲下新建 SofaEurekaProviderApplication 类，并且类上加上 @EnableEurekaClient 注解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaEurekaProviderApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaEurekaProviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="服务提供类"><a href="#服务提供类" class="headerlink" title="服务提供类"></a>服务提供类</h3><p>这里在  com.alipay.sofa.cloud.controller 包下新建 SofaController 类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.application.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String hostname;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello SOFA! Now Port is "</span>+port +<span class="string">" And hostname is "</span> +hostname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里在接口中返回 hostname 和 port ，方便后面验证负载均衡测试使用。</p><h3 id="启动程序-amp-验证-1"><a href="#启动程序-amp-验证-1" class="headerlink" title="启动程序 &amp; 验证"></a>启动程序 &amp; 验证</h3><p>在启动 sofa-eureka-provider 之前，需要先启动 sofa-wureka-server-center 。两个都启动成功之后，浏览器输入：<a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a> </p><p><img src="https://oscimg.oschina.net/oscnet/18b13b668adc275175ae8d6bacab52895e4.jpg" alt="image1.png"></p><p>此时我将 sofa-eureka-provider 中的配置文件的端口修改为 8081，再注册一个。</p><p><img src="https://oscimg.oschina.net/oscnet/d7a8333f1eabcb09b7a38f56aec860e56f4.jpg" alt="image2.png"></p><p>可以看到 服务为 HELLOSOFASERVICE 的有两个服务提供方。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Spring Cloud Netflix Eureka 是 Spring Cloud 提供的用于服务注册和发现的基础组件，在 Spring 
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="spring cloud" scheme="http://www.glmapper.com/tags/spring-cloud/"/>
    
      <category term="Eureka" scheme="http://www.glmapper.com/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud 总览</title>
    <link href="http://www.glmapper.com/2018/12/31/springcloud-overview/"/>
    <id>http://www.glmapper.com/2018/12/31/springcloud-overview/</id>
    <published>2018-12-30T16:00:15.000Z</published>
    <updated>2018-12-30T16:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列基于Spring Cloud <strong>Finchley SR2 &amp; SpringBoot 2.0.7.</strong>RELEASE</p></blockquote><p>Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性令牌、全局锁、leader选举、分布式session、集群状态）。分布式系统的协调导致了样板模式, 使用 Spring Cloud 开发人员可以快速地支持实现这些模式的服务和应用程序。它们可以在任何分布式环境中很好地工作，包括开发人员自己的笔记本电脑，裸机数据中心，以及Cloud Foundry等托管平台。</p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><hr><p>Spring Cloud专注于为典型用例提供良好的开箱即用体验，并为其他用户提供可扩展性机制。</p><ul><li>Distributed/versioned configuration       分布式/版本化配置</li><li>Service registration and discovery         服务注册和发现</li><li>Routing                                                  智能路由</li><li>Service-to-service calls                         service-to-service调用</li><li>Load balancing                                       负载均衡</li><li>Circuit Breakers                                      断路器</li><li>Global locks                                            全局锁</li><li>Leadership election and cluster state     leader选举和集群状态管理</li><li>Distributed messaging                            分布式消息</li></ul><h2 id="主要项目"><a href="#主要项目" class="headerlink" title="主要项目"></a>主要项目</h2><hr><table><thead><tr><th>项目名称<br></th><th>项目职能<br></th></tr></thead><tbody><tr><td>Spring Cloud Config<br></td><td>Spring Cloud 提供的分布式配置中心，为外部配置提供了客户端和服务端的支持。<br></td></tr><tr><td>Spring Cloud Netflix<br></td><td>与各种Netflix OSS组件集成（Eureka，Hystrix，Zuul，Archaius等）。<br></td></tr><tr><td>Spring Cloud Bus<br></td><td>用于将服务和服务实例与分布式消息传递连接在一起的事件总线。用于跨群集传播状态更改（例如，配置更改事件）。<br></td></tr><tr><td>Spring Cloud Cloudfoundry<br></td><td>提供应用程序与 Pivotal Cloud Foundry 集成。提供服务发现实现，还可以轻松实现受SSO和OAuth2保护的资源。<br></td></tr><tr><td>Spring Cloud Open Service Broker<br></td><td>为构建实现 Open service broker API 的服务代理提供了一个起点。    <br></td></tr><tr><td>Spring Cloud Cluster<br></td><td>提供Leadership选举，如：Zookeeper, Redis, Hazelcast, Consul等常见状态模式的抽象和实现。<br></td></tr><tr><td>Spring Cloud Consul<br></td><td>封装了Consul操作，consul 是一个服务发现与配置工具，与Docker容器可以无缝集成。<br></td></tr><tr><td>Spring Cloud Security<br></td><td>基于spring security的安全工具包，为你的应用程序添加安全控制。在Zuul代理中为负载平衡的OAuth2 rest客户端和身份验证头中继提供支持。<br></td></tr><tr><td>Spring Cloud Sleuth<br></td><td>Spring Cloud 提供的分布式链路跟踪组件，兼容zipkin、HTracer和基于日志的跟踪（ELK）<br></td></tr><tr><td>Spring Cloud Data Flow<br></td><td>大数据操作工具，作为Spring XD的替代产品，它是一个混合计算模型，结合了流数据与批量数据的处理方式。<br></td></tr><tr><td>Spring Cloud Stream<br></td><td>数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。<br></td></tr><tr><td>Spring Cloud CLI<br></td><td>基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。<br></td></tr><tr><td>Spring Cloud OpenFeign<br></td><td>一个http client客户端，致力于减少http client客户端构建的复杂性。<br></td></tr><tr><td>Spring Cloud Gateway<br></td><td>Spring Cloud 提供的网关服务组件<br></td></tr><tr><td>Spring Cloud Stream App Starters<br></td><td>Spring Cloud Stream App Starters是基于Spring Boot的Spring 集成应用程序，可提供与外部系统的集成。<br></td></tr><tr><td>Spring Cloud Task</td><td>提供云端计划任务管理、任务调度。<br></td></tr><tr><td>Spring Cloud Task App Starters<br></td><td>Spring Cloud任务应用程序启动器是SpringBoot应用程序，它可以是任何进程，包括不会永远运行的Spring批处理作业，并且在有限的数据处理周期后结束/停止。<br></td></tr><tr><td>Spring Cloud Zookeeper<br></td><td>操作Zookeeper的工具包，用于使用zookeeper方式的服务发现和配置管理。<br></td></tr><tr><td>Spring Cloud AWS<br></td><td>提供与托管的AWS集成<br></td></tr><tr><td>Spring Cloud Connectors<br></td><td>便于云端应用程序在各种PaaS平台连接到后端，如：数据库和消息代理服务。<br></td></tr><tr><td>Spring Cloud Starters<br></td><td>Spring Boot式的启动项目，为Spring Cloud提供开箱即用的依赖管理。<br></td></tr><tr><td>Spring Cloud Contract<br></td><td>Spring Cloud Contract是一个总体项目，其中包含帮助用户成功实施消费者驱动合同方法的解决方案。<br></td></tr><tr><td>Spring Cloud Pipelines<br></td><td>Spring Cloud Pipelines提供了一个固定意见的部署管道，其中包含确保您的应用程序可以零停机方式部署并轻松回滚出错的步骤。<br></td></tr><tr><td>Spring Cloud Function<br></td><td>Spring Cloud Function通过函数促进业务逻辑的实现。 它支持Serverless 提供商之间的统一编程模型，以及独立运行（本地或PaaS）的能力。<br></td></tr></tbody></table><h2 id="SpringCloud-与-SpringBoot-版本兼容关系"><a href="#SpringCloud-与-SpringBoot-版本兼容关系" class="headerlink" title="SpringCloud 与 SpringBoot 版本兼容关系"></a>SpringCloud 与 SpringBoot 版本兼容关系</h2><table><thead><tr><th>Release Train</th><th>Boot Version</th></tr></thead><tbody><tr><td>Greenwich<br></td><td>2.1.x<br></td></tr><tr><td>Finchley<br></td><td>2.0.x<br></td></tr><tr><td>Edgware<br></td><td>1.5.x<br></td></tr><tr><td>Dalston<br></td><td>1.5.x<br></td></tr></tbody></table><h2 id="SpringCloud-与子工程版本关系"><a href="#SpringCloud-与子工程版本关系" class="headerlink" title="SpringCloud 与子工程版本关系"></a>SpringCloud 与子工程版本关系</h2><table><thead><tr><th>Component</th><th>Edgware.SR5</th><th>Finchley.SR2</th><th>Finchley.BUILD-SNAPSHOT</th></tr></thead><tbody><tr><td>spring-cloud-aws<br></td><td>1.2.3.RELEASE<br></td><td>2.0.1.RELEASE<br></td><td>2.0.1.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-bus<br></td><td>1.3.3.RELEASE<br></td><td>2.0.0.RELEASE<br></td><td>2.0.1.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-cli<br></td><td>1.4.1.RELEASE<br></td><td>2.0.0.RELEASE<br></td><td>2.0.1.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-commons<br></td><td>1.3.5.RELEASE<br></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-contract<br></td><td>1.2.6.RELEASE<br></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-config<br></td><td>1.4.5.RELEASE<br></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-netflix<br></td><td>1.4.6.RELEASE<br></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-security<br></td><td>1.2.3.RELEASE<br></td><td>2.0.1.RELEASE<br></td><td>2.0.1.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-cloudfoundry<br></td><td>1.1.2.RELEASE<br></td><td>2.0.1.RELEASE<br></td><td>2.0.1.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-consul<br></td><td>1.3.5.RELEASE<br></td><td>2.0.1.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-sleuth<br></td><td>1.3.5.RELEASE<br></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-stream<br></td><td>Ditmars.SR4<br></td><td>Elmhurst.SR1<br></td><td>Elmhurst.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-zookeeper<br></td><td>1.2.2.RELEASE<br></td><td>2.0.0.RELEASE<br></td><td>2.0.1.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-boot<br></td><td>1.5.16.RELEASE<br></td><td>2.0.6.RELEASE<br></td><td>2.0.7.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-task<br></td><td>1.2.3.RELEASE<br></td><td>2.0.0.RELEASE<br></td><td>2.0.1.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-vault<br></td><td>1.1.2.RELEASE<br></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-gateway<br></td><td>1.0.2.RELEASE<br></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-openfeign<br></td><td></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-function<br></td><td>1.0.1.RELEASE<br></td><td>1.0.0.RELEASE<br></td><td>1.0.1.BUILD-SNAPSHOT<br></td></tr></tbody></table><ul><li>Finchley 构建并使用Spring Boot 2.0.x，与 Spring Boot 1.5.x 不兼容。</li><li>Dalston 和 Edgware 基于 Spring Boot 1.5.x 构建，不兼容 SpringBoot 2.0.x </li><li>Camden 版本迭代正式结束，Dalston 将于2018年12月结束使用，Edgware 将遵循 Spring Boot 1.5.x 的生命周期结束。</li><li>Camden 基于SpringBoot 1.4.x 构建，但是也会支持 1.5.x 版本</li><li>Brixton 和 Angel 迭代结束时间是2017年7月，Brixton 基于SpringBoot 1.3.x ，同时也支持 1.4.x 版本</li><li>Angel 基于 SpringBoot 1.2.x ,在某些方式不兼容 SpringBoot 1.3.x 。</li><li>Brixton 构建在SpringBoot 1.3.x ，不兼容 SpringBoot 1.2.x 。一些基于Angel的库和大多数应用程序可以在Brixton上正常运行，但如果OAuth2具备spring-cloud-security 1.0的特性，则需要在任何地方进行更改。x被使用(它们大多在1.3.0中被移到Spring Boot中)。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列基于Spring Cloud &lt;strong&gt;Finchley SR2 &amp;amp; SpringBoot 2.0.7.&lt;/strong&gt;RELEASE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Spring Cloud 为开发人员提供了快速构
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="spring cloud" scheme="http://www.glmapper.com/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringSession系列-sessionId解析和Cookie读写策略</title>
    <link href="http://www.glmapper.com/2018/12/23/springsession-id-resolver/"/>
    <id>http://www.glmapper.com/2018/12/23/springsession-id-resolver/</id>
    <published>2018-12-22T16:10:59.000Z</published>
    <updated>2018-12-22T17:18:53.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>首先需求在这里说明下，SpringSession的版本迭代的过程中肯定会伴随着一些类的移除和一些类的加入，目前本系列使用的版本是github上对象的master的代码流版本。如果有同学对其他版本中的一些类或者处理有疑惑，欢迎交流。</p></blockquote><p>本篇将来介绍下<code>SpringSession</code>中两种<code>sessionId</code>解析的策略，这个在之前的文章中其实是有提到过的，这里再拿出来和<code>SpringSession</code>中<code>Cookie</code>相关策略一起学习下。</p><h1 id="sessionId-解析策略"><a href="#sessionId-解析策略" class="headerlink" title="sessionId 解析策略"></a>sessionId 解析策略</h1><p><code>SpringSession</code>中对于<code>sessionId</code>的解析相关的策略是通过<code>HttpSessionIdResolver</code>这个接口来体现的。<code>HttpSessionIdResolver</code>有两个实现类：<br><img src="https://img-blog.csdnimg.cn/20181216224001789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzI1NTE4MzQ5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这两个类就分别对应<code>SpringSession</code>解析<code>sessionId</code>的两种不同的实现策略。再深入了解不同策略的实现细节之前，先来看下<code>HttpSessionIdResolver</code>接口定义的一些行为有哪些。</p><h2 id="HttpSessionIdResolver"><a href="#HttpSessionIdResolver" class="headerlink" title="HttpSessionIdResolver"></a>HttpSessionIdResolver</h2><p><code>HttpSessionIdResolver</code>定义了<code>sessionId</code>解析策略的契约（<code>Contract</code>）。允许通过请求解析sessionId，并通过响应发送sessionId或终止会话。接口定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpSessionIdResolver</span> </span>&#123;</span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">resolveSessionIds</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSessionId</span><span class="params">(HttpServletRequest request, HttpServletResponse response,String sessionId)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">expireSession</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>HttpSessionIdResolver</code>中有三个方法：</p><ul><li><code>resolveSessionIds</code>：解析与当前请求相关联的<code>sessionId</code>。<code>sessionId</code>可能来自<code>Cookie</code>或请求头。</li><li><code>setSessionId</code>：将给定的<code>sessionId</code>发送给客户端。这个方法是在创建一个新<code>session</code>时被调用，并告知客户端新<code>sessionId</code>是什么。</li><li><code>expireSession</code>：指示客户端结束当前<code>session</code>。当<code>session</code>无效时调用此方法，并应通知客户端<code>sessionId</code>不再有效。比如，它可能删除一个包含<code>sessionId</code>的<code>Cookie</code>，或者设置一个<code>HTTP</code>响应头，其值为空就表示客户端不再提交<code>sessionId</code>。</li></ul><p>下面就针对上面提到的两种策略来进行详细的分析。</p><h2 id="基于Cookie解析sessionId"><a href="#基于Cookie解析sessionId" class="headerlink" title="基于Cookie解析sessionId"></a>基于Cookie解析sessionId</h2><p>这种策略对应的实现类是<code>CookieHttpSessionIdResolver</code>，通过从<code>Cookie</code>中获取<code>session</code>；具体来说，这个实现将允许使用<code>CookieHttpSessionIdResolver#setCookieSerializer(CookieSerializer)</code>指定<code>Cookie</code>序列化策略。默认的<code>Cookie</code>名称是“<code>SESSION</code>”。创建一个<code>session</code>时，<code>HTTP</code>响应中将会携带一个指定 <code>Cookie name</code>且<code>value</code>是<code>sessionId</code>的<code>Cookie</code>。<code>Cookie</code> 将被标记为一个 <code>session cookie</code>，<code>Cookie</code> 的 <code>domain path</code> 使用 <code>context path</code>，且被标记为<code>HttpOnly</code>，如果<code>HttpServletRequest#isSecure()</code>返回<code>true</code>，那么<code>Cookie</code>将标记为安全的。如下：</p><blockquote><p>关于<code>Cookie</code>，可以参考：<a href="http://www.glmapper.com/2018/11/10/sessionone/">聊一聊session和cookie</a>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Set-Cookie: SESSION=f81d4fae-7dec-11d0-a765-00a0c91e6bf6; Path=/context-root; Secure; HttpOnly</span><br></pre></td></tr></table></figure><p>这个时候，客户端应该通过在每个请求中指定相同的<code>Cookie</code>来包含<code>session</code>信息。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /messages/ HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Cookie: SESSION=f81d4fae-7dec-11d0-a765-00a0c91e6bf6</span><br></pre></td></tr></table></figure></p><p>当会话无效时，服务器将发送过期的<code>HTTP</code>响应<code>Cookie</code>，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Set-Cookie: SESSION=f81d4fae-7dec-11d0-a765-00a0c91e6bf6; Expires=Thur, 1 Jan 1970 00:00:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure><p><code>CookieHttpSessionIdResolver</code> 类的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieHttpSessionIdResolver</span> <span class="keyword">implements</span> <span class="title">HttpSessionIdResolver</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WRITTEN_SESSION_ID_ATTR = CookieHttpSessionIdResolver.class</span><br><span class="line">.getName().concat(<span class="string">".WRITTEN_SESSION_ID_ATTR"</span>);</span><br><span class="line"><span class="comment">// Cookie序列化策略，默认是 DefaultCookieSerializer</span></span><br><span class="line"><span class="keyword">private</span> CookieSerializer cookieSerializer = <span class="keyword">new</span> DefaultCookieSerializer();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">resolveSessionIds</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据提供的cookieSerializer从请求中获取sessionId</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.cookieSerializer.readCookieValues(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSessionId</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">String sessionId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sessionId.equals(request.getAttribute(WRITTEN_SESSION_ID_ATTR))) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">request.setAttribute(WRITTEN_SESSION_ID_ATTR, sessionId);</span><br><span class="line"><span class="comment">// 根据提供的cookieSerializer将sessionId回写到cookie中</span></span><br><span class="line"><span class="keyword">this</span>.cookieSerializer</span><br><span class="line">.writeCookieValue(<span class="keyword">new</span> CookieValue(request, response, sessionId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireSession</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 这里因为是过期，所以回写的sessionId的值是“”，当请求下次进来时，就会取不到sessionId，也就意味着当前会话失效了</span></span><br><span class="line"><span class="keyword">this</span>.cookieSerializer.writeCookieValue(<span class="keyword">new</span> CookieValue(request, response, <span class="string">""</span>));</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 指定Cookie序列化的方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCookieSerializer</span><span class="params">(CookieSerializer cookieSerializer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cookieSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"cookieSerializer cannot be null"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.cookieSerializer = cookieSerializer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里可以看到<code>CookieHttpSessionIdResolver</code> 中的读取操作都是围绕<code>CookieSerializer</code>来完成的。<code>CookieSerializer</code> 是<code>SpringSession</code>中对于<code>Cookie</code>操作提供的一种机制。下面细说。</p><h2 id="基于请求头解析sessionId"><a href="#基于请求头解析sessionId" class="headerlink" title="基于请求头解析sessionId"></a>基于请求头解析sessionId</h2><p>这种策略对应的实现类是<code>HeaderHttpSessionIdResolver</code>，通过从请求头<code>header</code>中解析出<code>sessionId</code>。具体地说，这个实现将允许使用<code>HeaderHttpSessionIdResolver(String)</code>来指定头名称。还可以使用便利的工厂方法来创建使用公共头名称(例如<code>“X-Auth-Token”</code>和<code>“authenticing-info”</code>)的实例。创建会话时，<code>HTTP</code>响应将具有指定名称和<code>sessionId</code>值的响应头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用X-Auth-Token作为headerName</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeaderHttpSessionIdResolver <span class="title">xAuthToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HeaderHttpSessionIdResolver(HEADER_X_AUTH_TOKEN);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用Authentication-Info作为headerName</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeaderHttpSessionIdResolver <span class="title">authenticationInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HeaderHttpSessionIdResolver(HEADER_AUTHENTICATION_INFO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HeaderHttpSessionIdResolver</code>在处理<code>sessionId</code>上相比较于<code>CookieHttpSessionIdResolver</code>来说简单很多。就是围绕<code>request.getHeader(String)</code>和<code>request.setHeader(String,String)</code><br>两个方法来玩的。</p><p><code>HeaderHttpSessionIdResolver</code>这种策略通常会在无线端来使用，以弥补对于无<code>Cookie</code>场景的支持。</p><h1 id="Cookie-序列化策略"><a href="#Cookie-序列化策略" class="headerlink" title="Cookie 序列化策略"></a>Cookie 序列化策略</h1><p>基于<code>Cookie</code>解析<code>sessionId</code>的实现类<code>CookieHttpSessionIdResolver</code> 中实际对于<code>Cookie</code>的读写操作都是通过<code>CookieSerializer</code>来完成的。<code>SpringSession</code> 提供了<code>CookieSerializer</code>接口的默认实现<code>DefaultCookieSerializer</code>，当然在实际应用中，我们也可以自己实现这个接口，然后通过<code>CookieHttpSessionIdResolver#setCookieSerializer(CookieSerializer)</code>方法来指定我们自己的实现方式。</p><blockquote><p>PS：不得不说，强大的用户扩展能力真的是<code>Spring</code>家族的优良家风。</p></blockquote><p>篇幅有限，这里就只看下两个点：</p><ul><li><code>CookieValue</code> 存在的意义是什么</li><li><code>DefaultCookieSerializer</code>回写<code>Cookie</code>的的具体实现，读<code>Cookie</code>在 <a href="http://www.glmapper.com/2018/11/24/springsessiontwo/">SpringSession系列-请求与响应重写</a> 这篇文章中有介绍过，这里不再赘述。</li><li>jvm_router的处理</li></ul><h2 id="CookieValue"><a href="#CookieValue" class="headerlink" title="CookieValue"></a>CookieValue</h2><p><code>CookieValue</code>是<code>CookieSerializer</code>中的内部类，封装了向<code>HttpServletResponse</code>写入所需的所有信息。其实<code>CookieValue</code>的存在并没有什么特殊的意义，个人觉得作者一开始只是想通过<code>CookieValue</code>的封装来简化回写<code>cookie</code>链路中的参数传递的问题，但是实际上貌似并没有什么减少多少工作量。</p><h2 id="Cookie-回写"><a href="#Cookie-回写" class="headerlink" title="Cookie 回写"></a>Cookie 回写</h2><p><code>Cookie</code> 回写我觉得对于分布式<code>session</code>的实现来说是必不可少的；基于标准<code>servlet</code>实现的<code>HttpSession</code>，我们在使用时实际上是不用关心回写<code>cookie</code>这个事情的，因为<code>servlet</code>容器都已经做了。但是对于分布式<code>session</code>来说，由于重写了<code>response</code>，所以需要在返回<code>response</code>时需要将当前<code>session</code>信息通过<code>cookie</code>的方式塞到<code>response</code>中返回给客户端-这就是<code>Cookie</code>回写。下面是<code>DefaultCookieSerializer</code>中回写<code>Cookie</code>的逻辑，细节在代码中通过注释标注出来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeCookieValue</span><span class="params">(CookieValue cookieValue)</span> </span>&#123;</span><br><span class="line">HttpServletRequest request = cookieValue.getRequest();</span><br><span class="line">HttpServletResponse response = cookieValue.getResponse();</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.append(<span class="keyword">this</span>.cookieName).append(<span class="string">'='</span>);</span><br><span class="line">String value = getValue(cookieValue);</span><br><span class="line"><span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">validateValue(value);</span><br><span class="line">sb.append(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxAge = getMaxAge(cookieValue);</span><br><span class="line"><span class="keyword">if</span> (maxAge &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">sb.append(<span class="string">"; Max-Age="</span>).append(cookieValue.getCookieMaxAge());</span><br><span class="line">OffsetDateTime expires = (maxAge != <span class="number">0</span>)</span><br><span class="line">? OffsetDateTime.now().plusSeconds(maxAge)</span><br><span class="line">: Instant.EPOCH.atOffset(ZoneOffset.UTC);</span><br><span class="line">sb.append(<span class="string">"; Expires="</span>)</span><br><span class="line">.append(expires.format(DateTimeFormatter.RFC_1123_DATE_TIME));</span><br><span class="line">&#125;</span><br><span class="line">String domain = getDomainName(request);</span><br><span class="line"><span class="keyword">if</span> (domain != <span class="keyword">null</span> &amp;&amp; domain.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">validateDomain(domain);</span><br><span class="line">sb.append(<span class="string">"; Domain="</span>).append(domain);</span><br><span class="line">&#125;</span><br><span class="line">String path = getCookiePath(request);</span><br><span class="line"><span class="keyword">if</span> (path != <span class="keyword">null</span> &amp;&amp; path.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">validatePath(path);</span><br><span class="line">sb.append(<span class="string">"; Path="</span>).append(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isSecureCookie(request)) &#123;</span><br><span class="line">sb.append(<span class="string">"; Secure"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.useHttpOnlyCookie) &#123;</span><br><span class="line">sb.append(<span class="string">"; HttpOnly"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.sameSite != <span class="keyword">null</span>) &#123;</span><br><span class="line">sb.append(<span class="string">"; SameSite="</span>).append(<span class="keyword">this</span>.sameSite);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response.addHeader(<span class="string">"Set-Cookie"</span>, sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这上面就是拼凑字符串，然后塞到Header里面去，最终再浏览器中显示大体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: SESSION=f81d4fae-7dec-11d0-a765-00a0c91e6bf6; Path=/context-root; Secure; HttpOnly</span><br></pre></td></tr></table></figure><h2 id="jvm-router的处理"><a href="#jvm-router的处理" class="headerlink" title="jvm_router的处理"></a>jvm_router的处理</h2><p>在<code>Cookie</code>的读写代码中都涉及到对于<code>jvmRoute</code>这个属性的判断及对应的处理逻辑。</p><p>1、读取<code>Cookie</code>中的代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.jvmRoute != <span class="keyword">null</span> &amp;&amp; sessionId.endsWith(<span class="keyword">this</span>.jvmRoute)) &#123;</span><br><span class="line">sessionId = sessionId.substring(<span class="number">0</span>,</span><br><span class="line">sessionId.length() - <span class="keyword">this</span>.jvmRoute.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、回写<code>Cookie</code>中的代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.jvmRoute != <span class="keyword">null</span>) &#123;</span><br><span class="line">actualCookieValue = requestedCookieValue + <span class="keyword">this</span>.jvmRoute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>jvm_route</code>是<code>Nginx</code>中的一个模块，其作用是通过<code>session cookie</code>的方式来获取<code>session</code>粘性。如果在<code>cookie</code>和<code>url</code>中并没有<code>session</code>，则这只是个简单的 <code>round-robin</code> 负载均衡。其具体过程分为以下几步：</p><ul><li>1.第一个请求过来，没有带<code>session</code>信息，<code>jvm_route</code>就根据<code>round robin</code>策略发到一台<code>tomcat</code>上面。</li><li>2.<code>tomcat</code>添加上 <code>session</code> 信息，并返回给客户。</li><li>3.用户再次请求，<code>jvm_route</code>看到<code>session</code>中有后端服务器的名称，它就把请求转到对应的服务器上。</li></ul><p>从本质上来说，<code>jvm_route</code>也是解决<code>session</code>共享的一种解决方式。这种和 <a href="http://www.glmapper.com/2018/11/24/springsessionthree/">SpringSession系列-分布式Session实现方案</a> 中提到的基于<code>IP-HASH</code>的方式有点类似。那么同样，这里存在的问题是无法解决宕机后<code>session</code>数据转移的问题，既宕机就丢失。</p><p><code>DefaultCookieSerializer</code> 中除了<code>Cookie</code>的读写之后，还有一些细节也值得关注下，比如对<code>Cookie</code>中值的验证、<code>remember-me</code>的实现等。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://docs.spring.io/spring-session/docs/2.1.2.RELEASE/reference/html5/" target="_blank" rel="noopener">SpringSession官方文档</a></li><li><a href="https://blog.csdn.net/cao_j/article/details/51191764" target="_blank" rel="noopener">jvm_router原理</a></li><li><a href="https://github.com/glmapper/spring-session/tree/cn-spring-session" target="_blank" rel="noopener">SpringSession中文注释持续更新代码分支</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;首先需求在这里说明下，SpringSession的版本迭代的过程中肯定会伴随着一些类的移除和一些类的加入，目前本系列使用的版本是github上对象的master的代码流版本。如果有同学对其他版本中的一些类或者处理有疑惑，欢迎交流。&lt;/p&gt;
&lt;/bl
      
    
    </summary>
    
      <category term="spring" scheme="http://www.glmapper.com/categories/spring/"/>
    
      <category term="session" scheme="http://www.glmapper.com/categories/spring/session/"/>
    
    
      <category term="spring" scheme="http://www.glmapper.com/tags/spring/"/>
    
      <category term="session" scheme="http://www.glmapper.com/tags/session/"/>
    
  </entry>
  
  <entry>
    <title>20181216-书法练习</title>
    <link href="http://www.glmapper.com/2018/12/16/shufa-20181216/"/>
    <id>http://www.glmapper.com/2018/12/16/shufa-20181216/</id>
    <published>2018-12-16T07:30:58.000Z</published>
    <updated>2019-01-05T09:17:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>春江花月夜 -张若虚<br>春江潮水连海平，海上明月共潮生。<br>滟滟随波千万里，何处春江无月明！<br>江流宛转绕芳甸，月照花林皆似霰；<br>空里流霜不觉飞，汀上白沙看不见。<br>江天一色无纤尘，皎皎空中孤月轮。<br>江畔何人初见月？江月何年初照人？<br>人生代代无穷已，江月年年只相似。<br>不知江月待何人，但见长江送流水。<br>白云一片去悠悠，青枫浦上不胜愁。<br>谁家今夜扁舟子？何处相思明月楼？<br>可怜楼上月徘徊，应照离人妆镜台。<br>玉户帘中卷不去，捣衣砧上拂还来。<br>此时相望不相闻，愿逐月华流照君。<br>鸿雁长飞光不度，鱼龙潜跃水成文。<br>昨夜闲潭梦落花，可怜春半不还家。<br>江水流春去欲尽，江潭落月复西斜。<br>斜月沉沉藏海雾，碣石潇湘无限路。<br>不知乘月几人归，落月摇情满江树。</p></blockquote><p><img src="https://github.com/glmapper/glmapper.github.io/blob/master/images/self/shufa-yb-chunjianghuayueye.jpg?raw=true" alt=""></p><p><img src="https://github.com/glmapper/glmapper.github.io/blob/master/images/self/shufa-rb-chunjianghuayueye.jpg?raw=true" alt=""></p><blockquote><p>闻王昌龄左迁龙标遥有此寄 -李白<br>杨花落尽子规啼，闻道龙标过五溪。<br>我寄愁心与明月，随风直到夜郎西。</p></blockquote><p><img src="https://github.com/glmapper/glmapper.github.io/blob/master/images/self/shufa-yanghualuojinziguiti.jpg?raw=true" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;春江花月夜 -张若虚&lt;br&gt;春江潮水连海平，海上明月共潮生。&lt;br&gt;滟滟随波千万里，何处春江无月明！&lt;br&gt;江流宛转绕芳甸，月照花林皆似霰；&lt;br&gt;空里流霜不觉飞，汀上白沙看不见。&lt;br&gt;江天一色无纤尘，皎皎空中孤月轮。&lt;br&gt;江畔何人初见月？江月
      
    
    </summary>
    
      <category term="书法" scheme="http://www.glmapper.com/categories/%E4%B9%A6%E6%B3%95/"/>
    
    
      <category term="书法" scheme="http://www.glmapper.com/tags/%E4%B9%A6%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringSession系列-存储机制之Redis&amp;Map</title>
    <link href="http://www.glmapper.com/2018/12/16/spring-session-redis-map/"/>
    <id>http://www.glmapper.com/2018/12/16/spring-session-redis-map/</id>
    <published>2018-12-15T17:30:38.000Z</published>
    <updated>2018-12-22T16:10:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>@<a href="SpringSession：存储机制设计">TOC</a><br>在之前的文章中已经对<code>SpringSession</code>的功能结构，请求/响应重写等做了介绍。本文将继续来介绍下<code>SpringSession</code>中存储部分的设计。存储是分布式<code>session</code>中算是最核心的部分，通过引入三方的存储容器来实现<code>session</code>的存储，从而有效的解决<code>session</code>共享的问题。</p><h2 id="1、SpringSession存储的顶级抽象接口"><a href="#1、SpringSession存储的顶级抽象接口" class="headerlink" title="1、SpringSession存储的顶级抽象接口"></a>1、SpringSession存储的顶级抽象接口</h2><p><code>SpringSession</code>存储的顶级抽象接口是<code>org.springframework.session</code>包下的<code>SessionRepository</code>这个接口。<code>SessionRepository</code>的类图结构如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef7ce8c6b58?w=1662&amp;h=600&amp;f=png&amp;s=66844" alt=""></p><p>这里先来看下<code>SessionRepository</code>这个顶层接口中定义了哪些方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SessionRepository</span>&lt;<span class="title">S</span> <span class="keyword">extends</span> <span class="title">Session</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个session</span></span><br><span class="line"><span class="function">S <span class="title">createSession</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//保存session</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(S session)</span></span>;</span><br><span class="line"><span class="comment">//通过ID查找session</span></span><br><span class="line"><span class="function">S <span class="title">findById</span><span class="params">(String id)</span></span>;</span><br><span class="line"><span class="comment">//通过ID删除一个session</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码来看还是很简单的，就是增删查。下面看具体实现。在2.0版本开始<code>SpringSession</code>中也提供了一个和<code>SessionRepository</code>具体相同能力的<code>ReactiveSessionRepository</code>，用于支持响应式编程模式。</p><h2 id="2、MapSessionRepository"><a href="#2、MapSessionRepository" class="headerlink" title="2、MapSessionRepository"></a>2、MapSessionRepository</h2><p>基于HashMap实现的基于内存存储的存储器实现，这里就主要看下对于接口中几个方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapSessionRepository</span> <span class="keyword">implements</span> <span class="title">SessionRepository</span>&lt;<span class="title">MapSession</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer defaultMaxInactiveInterval;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Session&gt; sessions;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到就是一个<code>Map</code>，那后面关于增删查其实就是操作这个<code>Map</code>了。</p><h3 id="createSession"><a href="#createSession" class="headerlink" title="createSession"></a>createSession</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MapSession <span class="title">createSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MapSession result = <span class="keyword">new</span> MapSession();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.defaultMaxInactiveInterval != <span class="keyword">null</span>) &#123;</span><br><span class="line">result.setMaxInactiveInterval(</span><br><span class="line">Duration.ofSeconds(<span class="keyword">this</span>.defaultMaxInactiveInterval));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很直接，就是<code>new</code>了一个<code>MapSession</code>，然后设置了<code>session</code>的有效期。</p><h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(MapSession session)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!session.getId().equals(session.getOriginalId())) &#123;</span><br><span class="line"><span class="keyword">this</span>.sessions.remove(session.getOriginalId());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.sessions.put(session.getId(), <span class="keyword">new</span> MapSession(session));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面先判断了<code>session</code>中的两个<code>ID</code>，一个<code>originalId</code>，一个当前<code>id</code>。<code>originalId</code>是第一次生成<code>session</code>对象时创建的，后面都不会在变化。通过源码来看，对于<code>originalId</code>，只提供了<code>get</code>方法。对于<code>id</code>呢，其实是可以通过<code>changeSessionId</code>来改变的。</p><p>这里的这个操作实际上是一种优化行为，及时的清除掉老的<code>session</code>数据来释放内存空间。</p><h3 id="findById"><a href="#findById" class="headerlink" title="findById"></a>findById</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MapSession <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">Session saved = <span class="keyword">this</span>.sessions.get(id);</span><br><span class="line"><span class="keyword">if</span> (saved == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (saved.isExpired()) &#123;</span><br><span class="line">deleteById(saved.getId());</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MapSession(saved);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个逻辑也很简单，先从<code>Map</code>中根据<code>id</code>取出<code>session</code>数据，如果没有就返回<code>null</code>，如果有则再判断下是否过期了，如果过期了就删除掉，然后返回<code>null</code>。如果查到了，并且没有过期的话，则构建一个<code>MapSession</code>返回。</p><p>OK，基于内存存储的实现系列就是这些了，下面继续来看其他存储的实现。</p><h2 id="3、FindByIndexNameSessionRepository"><a href="#3、FindByIndexNameSessionRepository" class="headerlink" title="3、FindByIndexNameSessionRepository"></a>3、FindByIndexNameSessionRepository</h2><p><code>FindByIndexNameSessionRepository</code>继承了<code>SessionRepository</code>接口，用于扩展对第三方存储的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FindByIndexNameSessionRepository</span>&lt;<span class="title">S</span> <span class="keyword">extends</span> <span class="title">Session</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">SessionRepository</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">String PRINCIPAL_NAME_INDEX_NAME = FindByIndexNameSessionRepository.class.getName()</span><br><span class="line">.concat(<span class="string">".PRINCIPAL_NAME_INDEX_NAME"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">Map&lt;String, S&gt; <span class="title">findByIndexNameAndIndexValue</span><span class="params">(String indexName, String indexValue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> Map&lt;String, S&gt; <span class="title">findByPrincipalName</span><span class="params">(String principalName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> findByIndexNameAndIndexValue(PRINCIPAL_NAME_INDEX_NAME, principalName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FindByIndexNameSessionRepository</code>添加一个单独的方法为指定用户查询所有会话。这是通过设置名为<code>FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME</code>的<code>Session</code>的属性值为指定用户的<code>username</code>来完成的。开发人员有责任确保属性被赋值，因为<code>SpringSession</code>不会在意被使用的认证机制。官方文档中给出的例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String username = <span class="string">"username"</span>;</span><br><span class="line"><span class="keyword">this</span>.session.setAttribute(</span><br><span class="line">FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME, username);</span><br></pre></td></tr></table></figure><p><code>FindByIndexNameSessionRepository</code>的一些实现会提供一些钩子自动的索引其他的<code>session</code>属性。比如，很多实现都会自动的确保当前的<code>Spring Security</code>用户名称可通过索引名称<code>FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME</code>进行索引。一旦会话被索引，就可以通过下面的代码检索：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String username = <span class="string">"username"</span>;</span><br><span class="line">Map&lt;String, Session&gt; sessionIdToSession = </span><br><span class="line"><span class="keyword">this</span>.sessionRepository.findByIndexNameAndIndexValue(</span><br><span class="line">FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME,username);</span><br></pre></td></tr></table></figure><p>下图是<code>FindByIndexNameSessionRepository</code>接口的三个实现类：<br><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef0284d86a5?w=1624&amp;h=258&amp;f=png&amp;s=66960" alt="FindByIndexNameSessionRepository"></p><p>下面来分别分析下这三个存储的实现细节。</p><h3 id="3-1-RedisOperationsSessionRepository"><a href="#3-1-RedisOperationsSessionRepository" class="headerlink" title="3.1 RedisOperationsSessionRepository"></a>3.1 RedisOperationsSessionRepository</h3><p><code>RedisOperationsSessionRepository</code>的类图结构如下，<code>MessageListener</code>是<code>redis</code>消息订阅的监听接口。<br><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef029530952?w=1128&amp;h=596&amp;f=png&amp;s=67475" alt="在这里插入图片描述"></p><p>代码有点长，就不在这里面贴了，一些注释可以在这个 <a href="https://github.com/glmapper/spring-session/tree/cn-spring-session" target="_blank" rel="noopener">SpringSession中文分支</a> 来看。这里还是主要来看下对于那几个方法的实现。</p><h4 id="3-1-1-createSession"><a href="#3-1-1-createSession" class="headerlink" title="3.1.1 createSession"></a>3.1.1 createSession</h4><p>这里和<code>MapSessionRepository</code>的实现基本一样的，那区别就在于<code>Session</code>的封装模型不一样，这里是<code>RedisSession</code>，实际上<code>RedisSession</code>的实现是对<code>MapSession</code>又包了一层。下面会分析<code>RedisSession</code>这个类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisSession <span class="title">createSession</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// RedisSession,这里和MapSession区别开</span></span><br><span class="line">RedisSession redisSession = <span class="keyword">new</span> RedisSession();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.defaultMaxInactiveInterval != <span class="keyword">null</span>) &#123;</span><br><span class="line">redisSession.setMaxInactiveInterval(</span><br><span class="line">Duration.ofSeconds(<span class="keyword">this</span>.defaultMaxInactiveInterval));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> redisSession;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在看其他两个方法之前，先来看下<code>RedisSession</code>这个类。</p><h4 id="3-1-2-RedisSession"><a href="#3-1-2-RedisSession" class="headerlink" title="3.1.2 RedisSession"></a>3.1.2 RedisSession</h4><p>这个在模型上是对<code>MapSession</code>的扩展，增加了<code>delta</code>这个东西。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSession</span> <span class="keyword">implements</span> <span class="title">Session</span> </span>&#123;</span><br><span class="line">       <span class="comment">// MapSession 实例对象，主要存数据的地方</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MapSession cached;</span><br><span class="line"><span class="comment">// 原始最后访问时间</span></span><br><span class="line"><span class="keyword">private</span> Instant originalLastAccessTime;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; delta = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 是否是新的session对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isNew;</span><br><span class="line"><span class="comment">// 原始主名称</span></span><br><span class="line"><span class="keyword">private</span> String originalPrincipalName;</span><br><span class="line"><span class="comment">// 原始sessionId</span></span><br><span class="line"><span class="keyword">private</span> String originalSessionId;</span><br></pre></td></tr></table></figure></p><p><code>delta</code>是一个Map结构，那么这里面到底是放什么的呢？具体细节见 <a href="https://github.com/glmapper/spring-session/blob/cn-spring-session/spring-session-data-redis/src/main/java/org/springframework/session/data/redis/RedisOperationsSessionRepository.java" target="_blank" rel="noopener">saveDelta</a> 这个方法。<code>saveDelta</code> 这个方法会在两个地方被调用，一个是下面要说道的<code>save</code>方法，另外一个是 <code>flushImmediateIfNecessary</code> 这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushImmediateIfNecessary</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (RedisOperationsSessionRepository.<span class="keyword">this</span>.redisFlushMode == RedisFlushMode.IMMEDIATE) &#123;</span><br><span class="line">saveDelta();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>RedisFlushMode</code>提供了两种推送模式：</p><ul><li>ON_SAVE：只有在调用<code>save</code>方法时执行，在<code>web</code>环境中这样做通常是尽快提交HTTP响应</li><li>IMMEDIATE：只要有变更就会直接写到<code>redis</code>中，不会像<code>ON_SAVE</code>一样，在最后<code>commit</code>时一次性写入</li></ul><p>追踪<code>flushImmediateIfNecessary</code> 方法调用链如下：<br><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef032721690?w=1008&amp;h=258&amp;f=png&amp;s=89571" alt="在这里插入图片描述"><br>那么到这里基本就清楚了，首先<code>save</code>这个方法，当主动调用<code>save</code>时就是将数据推到<code>redis</code>中去的，也就是<code>ON_SAVE</code>这种情况。那么对于<code>IMMEDIATE</code>这种情况，只有调用了上面的四个方法，<code>SpringSession</code> 才会将数据推送到<code>redis</code>。</p><p>所以<code>delta</code>里面存的是当前一些变更的 <code>key-val</code> 键值对象，而这些变更是由<code>setAttribute</code>、<code>removeAttribute</code>、<code>setMaxInactiveIntervalInSeconds</code>、<code>setLastAccessedTime</code>这四个方法触发的；比如<code>setAttribute(k,v)</code>，那么这个<code>k-&gt;v</code>就会被保存到<code>delta</code>里面。</p><h4 id="3-1-3-save"><a href="#3-1-3-save" class="headerlink" title="3.1.3 save"></a>3.1.3 save</h4><p>在理解了<code>saveDelta</code>方法之后再来看<code>save</code>方法就简单多了。<code>save</code> 对应的就是<code>RedisFlushMode.ON_SAVE</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(RedisSession session)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 直接调用 saveDelta推数据到redis</span></span><br><span class="line">session.saveDelta();</span><br><span class="line"><span class="keyword">if</span> (session.isNew()) &#123;</span><br><span class="line">   <span class="comment">// sessionCreatedKey-&gt;channl</span></span><br><span class="line">String sessionCreatedKey = getSessionCreatedChannel(session.getId());</span><br><span class="line"><span class="comment">// 发布一个消息事件，新增 session，以供 MessageListener 回调处理。</span></span><br><span class="line"><span class="keyword">this</span>.sessionRedisOperations.convertAndSend(sessionCreatedKey, session.delta);</span><br><span class="line">session.setNew(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-4-findById"><a href="#3-1-4-findById" class="headerlink" title="3.1.4 findById"></a>3.1.4 findById</h4><p>查询这部分和基于<code>Map</code>的差别比较大，因为这里并不是直接操作<code>Map</code>，而是与<code>Redis</code> 进行一次交互。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisSession <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getSession(id, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用<code>getSession</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RedisSession <span class="title">getSession</span><span class="params">(String id, <span class="keyword">boolean</span> allowExpired)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据ID从redis中取出数据</span></span><br><span class="line">Map&lt;Object, Object&gt; entries = getSessionBoundHashOperations(id).entries();</span><br><span class="line"><span class="keyword">if</span> (entries.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转换成MapSession</span></span><br><span class="line">MapSession loaded = loadSession(id, entries);</span><br><span class="line"><span class="keyword">if</span> (!allowExpired &amp;&amp; loaded.isExpired()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转换成RedisSession</span></span><br><span class="line">RedisSession result = <span class="keyword">new</span> RedisSession(loaded);</span><br><span class="line">result.originalLastAccessTime = loaded.getLastAccessedTime();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>loadSession</code>中构建<code>MapSession</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MapSession <span class="title">loadSession</span><span class="params">(String id, Map&lt;Object, Object&gt; entries)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 生成MapSession实例</span></span><br><span class="line">MapSession loaded = <span class="keyword">new</span> MapSession(id);</span><br><span class="line"><span class="comment">//遍历数据</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entries.entrySet()) &#123;</span><br><span class="line">String key = (String) entry.getKey();</span><br><span class="line"><span class="keyword">if</span> (CREATION_TIME_ATTR.equals(key)) &#123;</span><br><span class="line">    <span class="comment">// 设置创建时间</span></span><br><span class="line">loaded.setCreationTime(Instant.ofEpochMilli((<span class="keyword">long</span>) entry.getValue()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (MAX_INACTIVE_ATTR.equals(key)) &#123;</span><br><span class="line"> <span class="comment">// 设置最大有效时间</span></span><br><span class="line">loaded.setMaxInactiveInterval(Duration.ofSeconds((<span class="keyword">int</span>) entry.getValue()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (LAST_ACCESSED_ATTR.equals(key)) &#123;</span><br><span class="line"><span class="comment">// 设置最后访问时间</span></span><br><span class="line">loaded.setLastAccessedTime(Instant.ofEpochMilli((<span class="keyword">long</span>) entry.getValue()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key.startsWith(SESSION_ATTR_PREFIX)) &#123;</span><br><span class="line"><span class="comment">// 设置属性</span></span><br><span class="line">loaded.setAttribute(key.substring(SESSION_ATTR_PREFIX.length()),</span><br><span class="line">entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> loaded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-5-deleteById"><a href="#3-1-5-deleteById" class="headerlink" title="3.1.5 deleteById"></a>3.1.5 deleteById</h4><p>根据<code>sessionId</code>删除<code>session</code>数据。具体过程看代码注释。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(String sessionId)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取 RedisSession</span></span><br><span class="line">RedisSession session = getSession(sessionId, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">if</span> (session == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// 清楚当前session数据的索引</span></span><br><span class="line">cleanupPrincipalIndex(session);</span><br><span class="line"><span class="comment">//执行删除操作</span></span><br><span class="line"><span class="keyword">this</span>.expirationPolicy.onDelete(session);</span><br><span class="line">String expireKey = getExpiredKey(session.getId());</span><br><span class="line"><span class="comment">//删除expireKey</span></span><br><span class="line"><span class="keyword">this</span>.sessionRedisOperations.delete(expireKey);</span><br><span class="line"><span class="comment">//session有效期设置为0</span></span><br><span class="line">session.setMaxInactiveInterval(Duration.ZERO);</span><br><span class="line">save(session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-1-6-onMessage"><a href="#3-1-6-onMessage" class="headerlink" title="3.1.6 onMessage"></a>3.1.6 onMessage</h4><p>最后来看下这个订阅回调处理。这里看下核心的一段逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isDeleted = channel.equals(<span class="keyword">this</span>.sessionDeletedChannel);</span><br><span class="line"><span class="comment">// Deleted 还是 Expired ？</span></span><br><span class="line"><span class="keyword">if</span> (isDeleted || channel.equals(<span class="keyword">this</span>.sessionExpiredChannel)) &#123;</span><br><span class="line"><span class="comment">// 此处省略无关代码</span></span><br><span class="line"><span class="comment">// Deleted</span></span><br><span class="line"><span class="keyword">if</span> (isDeleted) &#123;</span><br><span class="line">   <span class="comment">// 发布一个 SessionDeletedEvent 事件</span></span><br><span class="line">handleDeleted(session);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Expired</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 发布一个 SessionExpiredEvent 事件</span></span><br><span class="line">handleExpired(session);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-Redis-存储的一些思考"><a href="#3-2-Redis-存储的一些思考" class="headerlink" title="3.2 Redis 存储的一些思考"></a>3.2 Redis 存储的一些思考</h3><p>首先按照我们自己常规的思路来设计的话，我们会怎么来考虑这个事情。这里首先要声明下，我对 <code>Redis</code> 这个东西不是很熟，没有做过深入的研究；那如果是我来做，可能也就仅仅限于存储。</p><ul><li><code>findByIndexNameAndIndexValue</code>的设计，这个的作用是通过<code>indexName</code>和<code>indexValue</code>来返回当前用户的所有会话。但是这里需要考虑的一个事情是，通常情况下，一个用户只会关联到一个会话上面去，那这种设计很显然，我的理解是为了支持单用户多会话的场景。<ul><li>indexName：FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME</li><li>indexValue：username</li></ul></li><li><p>实现 <code>MessageListener</code> 接口，增加事件通知能力。通过监听这些事件，可以做一些<code>session</code>操作管控。但是实际上 <code>SpringSession</code> 中并没有做任何事情，从代码来看，<code>publishEvent</code>方法是空实现。等待回复中 <a href="https://github.com/spring-projects/spring-session/issues/1287" target="_blank" rel="noopener">#issue 1287</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ApplicationEventPublisher eventPublisher = <span class="keyword">new</span> ApplicationEventPublisher() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>RedisFlushMode</code> ，<code>SpringSession</code>中提供了两种模式的推送，一种是<code>ON_SAVE</code>，另外一种是<code>IMMEDIATE</code>。默认是<code>ON_SAVE</code>，也就是常规的在请求处理结束时进行一次<code>sessionCommit</code>操作。<code>RedisFlushMode</code> 的设计感觉是为<code>session</code>数据持久化的时机提供了另外一种思路。</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>存储机制设计部分就一基于内存和基于<code>Redis</code>两种来分析；另外基于<code>jdbc</code>和<code>hazelcast</code>有兴趣的同学可以自己查看源码。</p><p>最后也欢迎访问我的个人博客：<a href="http://www.glmapper.com">www.glmapper.com</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/zyhlwzy/article/details/78062646" target="_blank" rel="noopener">https://blog.csdn.net/zyhlwzy/article/details/78062646</a></li><li><a href="https://docs.spring.io/spring-session/docs/2.0.0.M4/reference/html5/#api" target="_blank" rel="noopener">https://docs.spring.io/spring-session/docs/2.0.0.M4/reference/html5/#api</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@&lt;a href=&quot;SpringSession：存储机制设计&quot;&gt;TOC&lt;/a&gt;&lt;br&gt;在之前的文章中已经对&lt;code&gt;SpringSession&lt;/code&gt;的功能结构，请求/响应重写等做了介绍。本文将继续来介绍下&lt;code&gt;SpringSession&lt;/code&gt;中存储部
      
    
    </summary>
    
      <category term="spring" scheme="http://www.glmapper.com/categories/spring/"/>
    
      <category term="session" scheme="http://www.glmapper.com/categories/spring/session/"/>
    
    
      <category term="spring" scheme="http://www.glmapper.com/tags/spring/"/>
    
      <category term="session" scheme="http://www.glmapper.com/tags/session/"/>
    
  </entry>
  
</feed>
