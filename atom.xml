<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>glmapper</title>
  
  <subtitle>大家都喊我磊叔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.glmapper.com/"/>
  <updated>2021-07-25T14:53:35.852Z</updated>
  <id>http://www.glmapper.com/</id>
  
  <author>
    <name>GuoLei Song</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记：SOFA Meepup 合肥站-SOFA 微服务体系技术生态于实践</title>
    <link href="http://www.glmapper.com/2021/07/25/shares/shares-sofa-meetup-7/"/>
    <id>http://www.glmapper.com/2021/07/25/shares/shares-sofa-meetup-7/</id>
    <published>2021-07-25T12:35:40.000Z</published>
    <updated>2021-07-25T14:53:35.852Z</updated>
    
    <content type="html"><![CDATA[<p>SOFA Meepup 合肥站从5月份开始筹划，至 7.24 在合肥成功举办，历时 2 个月的时间，从到场人数来看，并没有受到大雨的影响，合肥开发者同学对于技术的热衷没有我们预想的那么佛系，尤其是在微服务领域；在线观看人数也大于预测，这对于所有参与组织活动的同学及给予大力支持的社区来说，都是极大的鼓励和反馈。</p><p>点点滴滴，希望以文字的形式记录下来，记录这次活动之旅。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/meetup-hf/hf/mesh-practice.jpeg" alt=""></p><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>SOFA 是蚂蚁集团（当时叫蚂蚁金服）在 2018 年一季度开始陆陆续续对外开源的一系列产品族，除了微服务体系之外，还有云原生相关的产品组件；期间历经一次品牌升级，托管的 github 仓库也从 alipay 迁移至 sofastack，目前蚂蚁集团 sofa 产品在社区由 sofastack 社区和蚂蚁集团 sofa 团队共同维护发展。下面是其官网地址和 github 仓库地址：</p><ul><li>官网：<a href="https://www.sofastack.tech/" target="_blank" rel="noopener">https://www.sofastack.tech/</a></li><li>github： <a href="https://github.com/sofastack" target="_blank" rel="noopener">https://github.com/sofastack</a></li></ul><p>其实在 2019 年的时候，将 sofa meetup 活动办到合肥的想法已经萌生，只不过局限于当时的一些特殊情况，没能继续推进这个事情的落地。2021 年 5 月份，我从蚂蚁集团 sofa 团队离职，当时和 sofa 团队负责人鲁大师（鲁直）又提及这个事情，他表示非常支持让 sofa meetup 能够在合肥举办，在推进这个事情上给我打了一针强心剂。</p><p>回到合肥之后，第一时间和安徽开发者社区（嗨码社区）江总（江冬勤，阿里云 mvp）一起，就 sofa meetup 在合肥举办的事情做了初步的沟通，并着手联系 sofastack 社区负责同学，开始推进活动落地，随后活动社区发起者合肥清博大数据王总（王欢）、七牛老白、apisix 头哥也加入到活动策划小组中来，使得活动的整体落地节奏大大加快。</p><h2 id="进行时"><a href="#进行时" class="headerlink" title="进行时"></a>进行时</h2><blockquote><p>2019 年，我曾以讲师的身份参与了 sofa meetup 上海站的活动，当时并没有觉得举办活动是个多麻烦的事情，定个场地，发发宣传这种；但是作为参与整个合肥站从发起到结束这样的整个流程人来说，才知道是真的不容易，这里必须给 SOFAGirl 花花（英花）同学点赞；法务、财务、讲师、主题、场地、直播、礼品、主持、物料、策划组定期进度同步、现场安排… 从来都亲力亲为。</p></blockquote><p>临近活动，sofastack 社区同学和头哥从上海、成都、杭州等地陆续赶来，受 “烟花” 台风影响，他们的高铁乘次都遭遇了被取消的问题，虽然活动有备案，是进行视频直播分享，但相对于现场分享来说，其力度和影响是远远不够的，大家又紧急的调整购买了可行的乘次，sofastack 的有两位同学直到晚上 9 点多才到合肥。</p><p>活动是 7.24 号下午 1.30 开始，合肥早上天气还是挺好的，有点风，不下雨；到了中午 12.30 左右，天气换了个风格，开始降起了暴雨，当时我们在会场调侃说，本来报名的同学是开始准备过来参加活动了，刚准备出门看到这么大的雨，然后就不来了；但是事实是，大雨并没有对此产生多大的影响，至中场休息前，会前准备的座位已经不够了，又在后面加了一排；这也说明了，对于技术人来说，无关环境，期望的是通过技术分享来接收一些新的知识理念和技术思路，是学习的态度。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/meetup-hf/hf/huichang.jpeg" alt=""></p><p>1.30 开始，英花做了开场主持，老白介绍了社区的一些情况，我做了《微服务技术生态体系》的主题开场，后面就是讲师们精彩的 topic 分享。</p><p>1、禅总（忘禅）《蚂蚁注册中心 SOFARegistry 分享》<br><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/meetup-hf/hf/IMG_1801.JPG" alt=""></p><p>2、头哥（王晔倞）《基于API 网关的微服务治理演进与架构实践》<br><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/meetup-hf/hf/IMG_1802.JPG" alt=""></p><p>3、纶珥小师弟《蚂蚁集团分布式链路组件 SOFATracer 原理与实践》<br><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/meetup-hf/hf/IMG_1803.JPG" alt=""><br>(ps: 单身…..)</p><p>4、思科吕思泉老师《准实时的日志聚合平台》<br><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/meetup-hf/hf/IMG_1804.JPG" alt=""></p><p>5、MOSNBoy 良恩《Service Mesh 在蚂蚁集团的实践》<br><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/meetup-hf/hf/IMG_1805.JPG" alt=""></p><blockquote><p>ppt 资料可以从 sofastack 官网直接下载：<a href="https://www.sofastack.tech/activities/sofa-meetup-8/" target="_blank" rel="noopener">https://www.sofastack.tech/activities/sofa-meetup-8/</a></p></blockquote><h2 id="相聚"><a href="#相聚" class="headerlink" title="相聚"></a>相聚</h2><p>sofastack 是我深度参与的第一个开源项目，也经历了从 sofa 团队成员到 sofastack 社区成员的角色变换；这次来合肥的 sofastack 讲师和运营同学，曾都是我在 sofa 团队时并肩作战的小伙伴和师兄，晚上在接到他们时，感觉格外亲切，吃饭唠嗑，逛逛合肥的罍街，夜游天鹅湖，比较遗憾的是，没有留下一些合照留念。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/meetup-hf/hf/ml.jpeg" alt=""></p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>参与技术社区，不仅仅是出于对于技术的追求和热爱，更珍贵的是可以认识很多非常优秀的技术人和同路者；最后感谢各位来到现场的同学和在线观看直播和互动的同学，你们的参与是社区更具活力的根本。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/meetup-hf/hf/team.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SOFA Meepup 合肥站从5月份开始筹划，至 7.24 在合肥成功举办，历时 2 个月的时间，从到场人数来看，并没有受到大雨的影响，合肥开发者同学对于技术的热衷没有我们预想的那么佛系，尤其是在微服务领域；在线观看人数也大于预测，这对于所有参与组织活动的同学及给予大力支
      
    
    </summary>
    
      <category term="社区" scheme="http://www.glmapper.com/categories/%E7%A4%BE%E5%8C%BA/"/>
    
    
      <category term="sofa" scheme="http://www.glmapper.com/tags/sofa/"/>
    
  </entry>
  
  <entry>
    <title>Spring Aop 中的代理模式变化及 AopContext 问题小记</title>
    <link href="http://www.glmapper.com/2021/07/17/spring/spring-aop-proxy-and-aopcontext/"/>
    <id>http://www.glmapper.com/2021/07/17/spring/spring-aop-proxy-and-aopcontext/</id>
    <published>2021-07-17T11:19:05.000Z</published>
    <updated>2021-07-18T03:32:16.209Z</updated>
    
    <content type="html"><![CDATA[<p>AOP 称为面向切面编程，其底层原理就是动态代理；JAVA 中比较常见的动态代理有两种，分别是 JDK 动态代理和 CGLIB 动态代理，这点从 Spring Aop 的 AopProxy 的实现就可以得出验证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AopProxy</span><br><span class="line">    --- JdkDynamicAopProxy</span><br><span class="line">    --- CglibAopProxy</span><br></pre></td></tr></table></figure><p>Spring 作为 Java 应用领域最 牛 X 的基础框架产品，在对于一些版本变更导致的兼容性问题的处理上一直被诟病，对于这两种代理方式的选择上，Spring 不同版本存在一定的差异，这也是本文产生的一个原因。</p><h2 id="从一个异常说起"><a href="#从一个异常说起" class="headerlink" title="从一个异常说起"></a>从一个异常说起</h2><p>本来是打算写个 AOP demo 来验证下 AopContext 在跨线程场景下丢失 proxy 对象问题的，由于在 pom 中指定依赖了 spring-aop 版本（5.1.2），而工程 spring-boot 版本使用是 2.4.2，启动时就抛出了如下的异常（仅截取了后 3 段 casuse by）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;jdkServiceImpl&apos; defined in file [/Users/sgl/Documents/projects/github/aop-guides/target/classes/com/glmapper/bridge/boot/jdk/JdkServiceImpl.class]: Initialization of bean failed; nested exception is org.springframework.aop.framework.AopConfigException: Unexpected AOP exception; nested exception is java.lang.IllegalStateException: Unable to load cache item</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:617)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:531)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335)</span><br><span class="line">at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208)</span><br><span class="line">at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276)</span><br><span class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1380)</span><br><span class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1300)</span><br><span class="line">at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:640)</span><br><span class="line">... 46 more</span><br><span class="line">Caused by: org.springframework.aop.framework.AopConfigException: Unexpected AOP exception; nested exception is java.lang.IllegalStateException: Unable to load cache item</span><br><span class="line">at org.springframework.aop.framework.CglibAopProxy.getProxy(CglibAopProxy.java:214)</span><br><span class="line">at org.springframework.aop.framework.ProxyFactory.getProxy(ProxyFactory.java:110)</span><br><span class="line">at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.createProxy(AbstractAutoProxyCreator.java:473)</span><br><span class="line">at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.wrapIfNecessary(AbstractAutoProxyCreator.java:352)</span><br><span class="line">at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(AbstractAutoProxyCreator.java:301)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:444)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:609)</span><br><span class="line">... 55 more</span><br><span class="line">Caused by: java.lang.IllegalStateException: Unable to load cache item</span><br><span class="line">at org.springframework.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:79)</span><br><span class="line">at org.springframework.cglib.core.internal.LoadingCache.get(LoadingCache.java:34)</span><br><span class="line">at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:134)</span><br><span class="line">at org.springframework.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:319)</span><br><span class="line">at org.springframework.cglib.proxy.Enhancer.createHelper(Enhancer.java:572)</span><br><span class="line">at org.springframework.cglib.proxy.Enhancer.createClass(Enhancer.java:419)</span><br><span class="line">at org.springframework.aop.framework.ObjenesisCglibAopProxy.createProxyClassAndInstance(ObjenesisCglibAopProxy.java:58)</span><br><span class="line">at org.springframework.aop.framework.CglibAopProxy.getProxy(CglibAopProxy.java:205)</span><br><span class="line">... 62 more</span><br><span class="line">Caused by: java.lang.VerifyError: Stack map does not match the one at exception handler 9</span><br><span class="line">Exception Details:</span><br><span class="line">  Location:</span><br><span class="line">    com/glmapper/bridge/boot/jdk/JdkServiceImpl$$EnhancerBySpringCGLIB$$3045df64.&lt;init&gt;()V @9: athrow</span><br><span class="line">  Reason:</span><br><span class="line">    Current frame&apos;s flags are not assignable to stack map frame&apos;s.</span><br><span class="line">  Current Frame:</span><br><span class="line">    bci: @0</span><br><span class="line">    flags: &#123; flagThisUninit &#125;</span><br><span class="line">    locals: &#123; uninitializedThis &#125;</span><br><span class="line">    stack: &#123; &apos;java/lang/RuntimeException&apos; &#125;</span><br><span class="line">  Stackmap Frame:</span><br><span class="line">    bci: @9</span><br><span class="line">    flags: &#123; &#125;</span><br><span class="line">    locals: &#123; &#125;</span><br><span class="line">    stack: &#123; &apos;java/lang/Throwable&apos; &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>看到这个异常有点莫名其妙，然后尝试通过关键字去网上搜了下，确实找到了一个非常类似的 case <a href="https://stackoverflow.com/questions/60601994/unexpected-aop-exception-nested-exception-is-java-lang-illegalstateexception-u" target="_blank" rel="noopener">Unexpected AOP exception; nested exception is java.lang.IllegalStateException: Unable to load cache item</a>。从问题描述来看，大致有以下几个方向：</p><ul><li>1、spring boot devtools 热部署导致</li><li>2、CGLIB 或 Objenesis 不理解 Java 13 字节代码</li><li>3、依赖问题</li></ul><p>在我的 demo 中，1 和 2 都是未涉及的，所以将专注点放在 3 上面。一开始尝试 <code>Stack map does not match the one at exception handler 9</code> 全局查找，尝试找到产生堆栈的代码片段，实际上是没有在代码中找到的；随后翻看了 openjdk 的源码才找到。<strong>另一个比较疑惑的问题在于：这个异常产生仅当通过 run test unit 的时候才会有，正常通过启动工程并发起调用并不会出现</strong>。当我把 Spring Aop 版本切换到 5.3.3 时，run test unit 也可以正常被执行。</p><p>图1：spring-aop 版本为 5.3.3, Class.forName 正常执行到下一行</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75ea7642a9724e358e25e0673e733e4e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>图2：spring-aop 版本为 5.1.2<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61f0a50cd8e84637bfe7c5b2ba476b5d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>执行直接报错</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b88cef96f3b743e08ab0ae4c455904df~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>其实堆栈来看，两者并无差异。到这里不打算继续深究原因，回到 VerifyError 异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当 “verifier” 检测到 classfile 虽然格式良好，但包含某种内部不一致或安全问题时抛出。</span><br></pre></td></tr></table></figure></p><p>加上产生的条件：在 springboot 测试场景下，使用低于管控版本的 spring aop 从而导致该问题；合理规避吧…</p><h2 id="Spring-aop-动态代理机制在不同版本中的差异"><a href="#Spring-aop-动态代理机制在不同版本中的差异" class="headerlink" title="Spring aop 动态代理机制在不同版本中的差异"></a>Spring aop 动态代理机制在不同版本中的差异</h2><p>这里仅作为备忘点介绍一下，大多数情况下在使用的时候并不会关注到。</p><ul><li>1、Spring 5.x 版本开始，AOP 默认依旧使用 JDK 动态代理，并非网上说的默认改成了 CGLIB。</li><li>2、SpringBoot 2.x 开始，由于使用 JDK 动态代理可能导致的类型转化异常问题，默认使用 CGLIB。</li><li>3、SpringBoot 2.x 中，如果需要默认使用 JDK 动态代理可以通过配置项 <code>spring.aop.proxy-target-class=false</code> 来进行修改，proxyTargetClass 配置已无效。</li></ul><p>相关论证可以见：AopAutoConfiguration、@EnableAspectJAutoProxy 及官方文档说明。</p><h2 id="AopContext"><a href="#AopContext" class="headerlink" title="AopContext"></a>AopContext</h2><p>关于 AopContext 可能部分开发者对其是陌生的；但是有这样一种场景一定是你遇到过的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkServiceImpl</span> <span class="keyword">implements</span> <span class="title">JdkService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Metrics</span>(name = <span class="string">"helloJdk"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloJdk</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// invoke inner</span></span><br><span class="line">        inner();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Metrics</span>(name = <span class="string">"inner"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is Jdk inner method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当你写了一个自定义注解，然后通过 aop 去拦截时，对于类内部方法之间的调用无法拦截，如上代码片段，在 helloJdk 中调用 inner，同样打上了 @Metrics 注解，实际上 inner 的调用是不会被 aop 拦截到的；原因在于，这里的 inner 调用实际上等同于 <code>this.inner()</code>，而当前的 this 对象是 JdkServiceImpl 对象本身，并非代理类，所以切不到是正常的。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bd32ccc640d4eeea2c5531bc5a52036~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>那这里其实就可能通过 AopContext 来辅助一下，这里有个前提条件，通过注解添加配置（加在类上）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">true</span>, exposeProxy = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><p>或通过 xml 配置文件添加配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span> <span class="attr">expose-proxy</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>否则会跑出如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot find current proxy: Set &apos;exposeProxy&apos; property on Advised to &apos;true&apos; to make it available.</span><br></pre></td></tr></table></figure><p>原因在于，当 exposeProxy 为 true 时，才会将当前 proxy 对象塞到 AopContext 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line"><span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AopContext 的实现很简单，就是在内部维护了一个 ThreadLocal：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Object&gt; currentProxy = <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current AOP proxy"</span>);</span><br></pre></td></tr></table></figure></p><p>所以在使用这个工具类的时候，还需要关注另一个问题，就是当在跨线程，或者使用线程池的情况下，需要手动将 proxy 透传到新的线程中，否则，即使开始 exposeProxy = true，同样也会出现 <code>Cannot find current proxy: Set &#39;exposeProxy&#39;</code> 报错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AOP 称为面向切面编程，其底层原理就是动态代理；JAVA 中比较常见的动态代理有两种，分别是 JDK 动态代理和 CGLIB 动态代理，这点从 Spring Aop 的 AopProxy 的实现就可以得出验证。&lt;/p&gt;
&lt;figure class=&quot;highlight p
      
    
    </summary>
    
      <category term="spring aop" scheme="http://www.glmapper.com/categories/spring-aop/"/>
    
    
      <category term="spring" scheme="http://www.glmapper.com/tags/spring/"/>
    
      <category term="aop" scheme="http://www.glmapper.com/tags/aop/"/>
    
  </entry>
  
  <entry>
    <title>使用 docker 部署 kafka 集群</title>
    <link href="http://www.glmapper.com/2021/07/13/docker/docker-compose-kakfa-install/"/>
    <id>http://www.glmapper.com/2021/07/13/docker/docker-compose-kakfa-install/</id>
    <published>2021-07-13T14:18:55.000Z</published>
    <updated>2021-07-18T04:03:07.432Z</updated>
    
    <content type="html"><![CDATA[<p>参考文档：<a href="https://github.com/wurstmeister/kafka-docker" target="_blank" rel="noopener">https://github.com/wurstmeister/kafka-docker</a></p><p>在你的文件系统中找个目录，然后新建一个 docker-compose.yaml 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  kafka-guides </span><br><span class="line">total 8</span><br><span class="line">-rw-r--r--@ 1 sgl  staff   1.1K  7 13 21:56 docker-compose.yaml</span><br></pre></td></tr></table></figure><p>编辑 docker-compose.yaml 文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  zookeeper:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">wurstmeister/zookeeper</span>   <span class="comment">## zk 镜像</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"2181:2181"</span>                 <span class="comment">## 对外暴露的端口号</span></span><br><span class="line"><span class="attr">  kafka:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">wurstmeister/kafka</span>       <span class="comment">## kafka 镜像</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">/etc/localtime:/etc/localtime</span> <span class="comment">## 挂载位置（kafka镜像和宿主机器之间时间保持一致）</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"9092:9092"</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      KAFKA_ADVERTISED_HOST_NAME:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.67</span>     <span class="comment">## 修改:宿主机IP  ---- 192.168.10.67  是我当前的机器ip</span></span><br><span class="line"><span class="attr">      KAFKA_ZOOKEEPER_CONNECT:</span> <span class="attr">zookeeper:2181</span>       <span class="comment">## kafka 运行是基于zookeeper的</span></span><br><span class="line"><span class="attr">      KAFKA_ADVERTISED_PORT:</span> <span class="number">9092</span></span><br><span class="line"><span class="attr">      KAFKA_LOG_RETENTION_HOURS:</span> <span class="number">120</span></span><br><span class="line"><span class="attr">      KAFKA_MESSAGE_MAX_BYTES:</span> <span class="number">10000000</span></span><br><span class="line"><span class="attr">      KAFKA_REPLICA_FETCH_MAX_BYTES:</span> <span class="number">10000000</span></span><br><span class="line"><span class="attr">      KAFKA_GROUP_MAX_SESSION_TIMEOUT_MS:</span> <span class="number">60000</span></span><br><span class="line"><span class="attr">      KAFKA_NUM_PARTITIONS:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">      KAFKA_DELETE_RETENTION_MS:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">  kafka-manager:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">sheepkiller/kafka-manager</span>                <span class="comment">## 镜像：kafka-manager</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">        ZK_HOSTS:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.67</span>                     <span class="comment">## 修改:宿主机IP</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"9001:9000"</span>                                 <span class="comment">## 暴露端口 9001</span></span><br></pre></td></tr></table></figure><p>启动服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">~ docker-compose up -d</span><br><span class="line"><span class="comment"># 执行日志大致如下</span></span><br><span class="line">Pulling kafka (wurstmeister/kafka:)...</span><br><span class="line">latest: Pulling from wurstmeister/kafka</span><br><span class="line">540db60ca938: Pull complete</span><br><span class="line">789c480dd801: Pull complete</span><br><span class="line">0705a4c47ffe: Pull complete</span><br><span class="line">661f40345821: Pull complete</span><br><span class="line">a84fa3c6a2b3: Pull complete</span><br><span class="line">Digest: sha256:4bad02cf8f07d0bf65d5cc73cce7aa75f9a90e32b585f867fce7c3fff229bd6d</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> wurstmeister/kafka:latest</span><br><span class="line">Pulling kafka-manager (sheepkiller/kafka-manager:)...</span><br><span class="line">latest: Pulling from sheepkiller/kafka-manager</span><br><span class="line">469cfcc7a4b3: Pull complete</span><br><span class="line">4458b033eac3: Pull complete</span><br><span class="line">838a0ff6e24f: Pull complete</span><br><span class="line">0128a98dafdb: Pull complete</span><br><span class="line">Digest: sha256:615f3b99d38aba2d5fdb3fb750a5990ba9260c8fb3fd29c7e776e8c150518b78</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> sheepkiller/kafka-manager:latest</span><br><span class="line">Creating kafka-guides_kafka-manager_1 ... <span class="keyword">done</span></span><br><span class="line">Creating kafka-guides_zookeeper_1     ... <span class="keyword">done</span></span><br><span class="line">Creating kafka-guides_kafka_1         ... <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>此时可以通过访问 <a href="http://localhost:9001/" target="_blank" rel="noopener">http://localhost:9001/</a> 来打开 kafka manager 页面进行验证。也可以通过 <code>docker-compose ps</code> 查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  kafka-guides docker-compose ps</span><br><span class="line">            Name                          Command               State                        Ports</span><br><span class="line">------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">kafka-guides_kafka-manager_1   ./start-kafka-manager.sh         Up      0.0.0.0:9001-&gt;9000/tcp,:::9001-&gt;9000/tcp</span><br><span class="line">kafka-guides_kafka_1           start-kafka.sh                   Up      0.0.0.0:9092-&gt;9092/tcp,:::9092-&gt;9092/tcp</span><br><span class="line">kafka-guides_zookeeper_1       /bin/sh -c /usr/sbin/sshd  ...   Up      0.0.0.0:2181-&gt;2181/tcp,:::2181-&gt;2181/tcp,</span><br><span class="line">                                                                        22/tcp, 2888/tcp, 3888/tcp</span><br></pre></td></tr></table></figure><p>停止服务 <code>docker-compose stop</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">➜  kafka-guides docker-compose stop</span><br><span class="line">Stopping kafka-guides_kafka_1         ... <span class="keyword">done</span></span><br><span class="line">Stopping kafka-guides_zookeeper_1     ... <span class="keyword">done</span></span><br><span class="line">Stopping kafka-guides_kafka-manager_1 ... <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>停止并删除服务 <code>docker-compose down</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考文档：&lt;a href=&quot;https://github.com/wurstmeister/kafka-docker&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/wurstmeister/kafka-docker&lt;/
      
    
    </summary>
    
      <category term="docker" scheme="http://www.glmapper.com/categories/docker/"/>
    
    
      <category term="kafka" scheme="http://www.glmapper.com/tags/kafka/"/>
    
      <category term="docker" scheme="http://www.glmapper.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>你知道 Junit 是怎么跑的吗？</title>
    <link href="http://www.glmapper.com/2021/07/02/tests/junit-run-principle/"/>
    <id>http://www.glmapper.com/2021/07/02/tests/junit-run-principle/</id>
    <published>2021-07-02T11:28:43.000Z</published>
    <updated>2021-07-02T11:31:04.141Z</updated>
    
    <content type="html"><![CDATA[<p>Junit 是由 Kent Beck 和 Erich Gamma 于 1995 年底着手编写的框架，自此以后，Junit 框架日益普及，现在已经成为单元测试 Java 应用程序的事实上的标准。<br></p><blockquote><p>在软件开发领域中，从来没有这样的事情：少数几行代码对大量代码起着如此重要的作用  — Martin Fowler</p></blockquote><h2 id="从一个简单的例子开始认识-Junit"><a href="#从一个简单的例子开始认识-Junit" class="headerlink" title="从一个简单的例子开始认识 Junit"></a>从一个简单的例子开始认识 Junit</h2><p>本文注重点在于研究 Junit 运行的基本原理和执行单元测试的流程，所以对于一些额外的信息和数据不单独准备，本文所使用的测试 case 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.bridge.boot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JunitSamplesTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">".....this is before test......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">".....this is after test......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beforeClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">".....this is before class test......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">".....this is after class test......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is test one"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is test two"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.....<span class="keyword">this</span> is before <span class="class"><span class="keyword">class</span> <span class="title">test</span>......</span></span><br><span class="line">Disconnected from the target VM, address: '127.0.0.1:65400', transport: 'socket'</span><br><span class="line">.....<span class="keyword">this</span> is before test......</span><br><span class="line"><span class="keyword">this</span> is test one</span><br><span class="line">.....<span class="keyword">this</span> is after test......</span><br><span class="line">.....<span class="keyword">this</span> is before test......</span><br><span class="line"><span class="keyword">this</span> is test two</span><br><span class="line">.....<span class="keyword">this</span> is after test......</span><br><span class="line">.....<span class="keyword">this</span> is after <span class="class"><span class="keyword">class</span> <span class="title">test</span>......</span></span><br></pre></td></tr></table></figure></p><p>从代码和执行结果来看，BeforeClass 和 AfterClass 注解分别在测试类开始之前和之后执行，Before 和 After 注解在测试类中每个测试方法的前后执行。</p><h2 id="问题域"><a href="#问题域" class="headerlink" title="问题域"></a>问题域</h2><p>从开发者的角度来看，对于任何一个技术产品组件，如果想要更好的使用它，就意味着必须了解它。通过上面提供的 case 可以看到，Junit  使用非常简单，基本 0 门槛上手，通过给测试的方法加一个 @Test 注解，然后将待测试逻辑放在 被 @Test 标注的方法内，然后 run 就好了。简单源于组件开发者的顶层抽象和封装，将技术细节屏蔽，然后以最简洁的 API 或者注解面向用户，这也是 Junit 能够让广大开发者容易接受的根本原因，值得我们借鉴学习。</p><p>回归正题，基于上面分析，Junit 使用简单在于其提供了非常简洁的 API 和注解，那对于我们来说，这些就是作为分析 Junit 的基本着手点；通过这些，来拨开 Junit  的基本原理。基于第一节的小案例，这里抛出这样几个问题：</p><ul><li>Junit 是怎么触发执行的</li><li>为什么被标注 @Test 注解的方法会被执行，而没有标注的不会</li><li>Before 和 After 执行时机</li><li>BeforeClass 和 AfterClass 执行时机</li><li>Junit 是怎么将执行结果收集并返回的（这里不关注 IDE 提供的渲染）</li></ul><h2 id="Junit-是如何执行的？"><a href="#Junit-是如何执行的？" class="headerlink" title="Junit 是如何执行的？"></a>Junit 是如何执行的？</h2><p>这里把断点直接打在目标测试方法位置，然后 debug 执行<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ce445e985e74b5db137c2fa9f596e88~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><p>通过堆栈来找到用例执行的整个路径。因为本 case 是通过 idea 启动执行，所以可以看到的入口实际是被 idea 包装过的。但是这里也抓到了 JUnitCore 这样的一个入口。</p><p>JUnitCore  是运行测试用例的门面入口，通过源码注释可以看到，JUnitCore 从 junit 4 才有，但是其向下兼容了 3.8.x 版本系列。我们在跑测试用例时，其实大多数情况下在本地都是通过 IDE 来触发用例运行，或者通过 mvn test 来运行用例，实际上，不管是 IDE 还是 mvn 都是对 JUnitCore 的封装。我们完全可以通过 main 方法的方式来运行，比如运行下面代码的 main 方法来通过一个 JUnitCore 实例，然后指定被测试类来触发用例执行，为了尽量使得堆栈更贴近 Junit 自己的代码，我们通过这种方式启动来减少堆栈对于代码执行路径的干扰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JunitSamplesTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">".....this is before test......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">".....this is after test......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beforeClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">".....this is before class test......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">".....this is after class test......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is test one"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is test two"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JUnitCore jUnitCore = <span class="keyword">new</span> JUnitCore();</span><br><span class="line">        jUnitCore.run(JunitSamplesTest.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里得到了最简化的测试执行入口：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d86f198548e04c89bbd0477cb36d9a48~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><p>如果使用 java 命令来引导启动，其实就是从 JunitCore 内部自己的 main 方法开始执行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Run the tests contained in the classes named in the args. If all tests run successfully, exit with a status of 0. Otherwise exit with a status of 1. Write</span></span><br><span class="line"><span class="comment"> * feedback while tests are running and write stack traces for all failed tests after the tests all complete.</span></span><br><span class="line"><span class="comment"> * Params:</span></span><br><span class="line"><span class="comment"> * args – names of classes in which to find tests to run</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    Result result = <span class="keyword">new</span> JUnitCore().runMain(<span class="keyword">new</span> RealSystem(), args);</span><br><span class="line">    System.exit(result.wasSuccessful() ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么被标注-Test-注解的方法会被执行，而没有标注的不会"><a href="#为什么被标注-Test-注解的方法会被执行，而没有标注的不会" class="headerlink" title="为什么被标注 @Test 注解的方法会被执行，而没有标注的不会"></a>为什么被标注 @Test 注解的方法会被执行，而没有标注的不会</h2><p>这里比较好理解，被打了 @Test 注解的方法，一定是 Junit 通过某种方式将其扫描到了，然后作为待执行的一个集合或者队列中。下面通过分析代码来论证下。</p><blockquote><p>org.junit.runners.BlockJUnit4ClassRunner#getChildren</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;FrameworkMethod&gt; <span class="title">getChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> computeTestMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过方法 computeTestMethods 方法名其实就可以看出其目的，就是计算出所有的测试方法。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2fa2031531d4580ae83efdaf90e039f~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><p>etAnnotatedMethods 通过指定的 annotationClass 类型，将当前 TestClass 中类型为 annotationClass 类型注解标注的方法过滤出来，</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd07e404cba6485e96b2061d800ef93c~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><p>getFilteredChildren 中最后将获取得到的测试方法放在 filteredChildren 中缓存起来。这里简单汇总下 @Test 注解被识别的整个过程（其他注解如 @Before 都是一样的）</p><ul><li>1、Junit 在初始化构建 Runner 的过程，内部会基于给定的 测试类创建一个 TestClass 对象模型，用于描述当前测试类在 Junit 中的表示。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clazz 是待测试类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestClass</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="keyword">null</span> &amp;&amp; clazz.getConstructors().length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 测试类不能有有参构造函数</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">            <span class="string">"Test class can only have one constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Class&lt;? extends Annotation&gt;, List&lt;FrameworkMethod&gt;&gt; methodsForAnnotations =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap&lt;Class&lt;? extends Annotation&gt;, List&lt;FrameworkMethod&gt;&gt;();</span><br><span class="line">    Map&lt;Class&lt;? extends Annotation&gt;, List&lt;FrameworkField&gt;&gt; fieldsForAnnotations =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap&lt;Class&lt;? extends Annotation&gt;, List&lt;FrameworkField&gt;&gt;();</span><br><span class="line">    <span class="comment">// 扫描待测试类中所有的 Junit 注解，包括 @Test @Before @After 等等</span></span><br><span class="line">    scanAnnotatedMembers(methodsForAnnotations, fieldsForAnnotations);</span><br><span class="line"><span class="comment">// 过滤出打在方法上的注解，</span></span><br><span class="line">    <span class="keyword">this</span>.methodsForAnnotations = makeDeeplyUnmodifiable(methodsForAnnotations);</span><br><span class="line">    <span class="comment">// 过滤出打在变量上的注解</span></span><br><span class="line">    <span class="keyword">this</span>.fieldsForAnnotations = makeDeeplyUnmodifiable(fieldsForAnnotations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>methodsForAnnotations 和 fieldsForAnnotations 缓存了当前待测试类所有被 junit 注解标注过的方法和变量</p><ul><li>2、getFilteredChildren 中，从 methodsForAnnotations 中筛选出所有 @Test 注解标注的方法。（getDescription()-&gt; getFilteredChildren  -&gt; computeTestMethods -&gt; 从 methodsForAnnotations 按类型过滤）</li><li>3、返回所有 @Test 注解标注的方法</li></ul><h2 id="Before-和-After-执行时机"><a href="#Before-和-After-执行时机" class="headerlink" title="Before 和 After 执行时机"></a>Before 和 After 执行时机</h2><p>要搞定这个问题，其实有必要了解下 Junit 中一个比较重要的概念 Statement。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Statement</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the action, throwing a &#123;<span class="doctag">@code</span> Throwable&#125; if anything goes wrong.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">evaluate</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Statement 从 junit 4.5 版本被提出，Statement 表示在运行 JUnit 测试组件的过程中要在运行时执行的一个或多个操作，简单说就是，对于被 @Before @After 注解标注的方法，在 JUnit  会被作为一种 Statement  存在，分别对应于 RunBefores 和 RunnerAfter，这些 statement 中持有了当前运行所有的 FrameworkMethod。</p><p>FrameworkMethod 是 JUnit   中所有被 junit 注解标注方式的内部描述，@Test, @Before, @After, @BeforeClass, @AfterClass 标注的方法最终都作为 FrameworkMethod  实例存在。</p><p>Statement  的创建有两种方式，基于 FrameworkMethod 的 methodBlock 和基于 RunNotifier 的 classBlock，这里介绍 methodBlock ，classBlock 下节讨论。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Statement <span class="title">methodBlock</span><span class="params">(<span class="keyword">final</span> FrameworkMethod method)</span> </span>&#123;</span><br><span class="line">        Object test;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test = <span class="keyword">new</span> ReflectiveCallable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> Object <span class="title">runReflectiveCall</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> createTest(method);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Fail(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Statement statement = methodInvoker(method, test);</span><br><span class="line">        statement = possiblyExpectingExceptions(method, test, statement);</span><br><span class="line">        statement = withPotentialTimeout(method, test, statement);</span><br><span class="line">        statement = withBefores(method, test, statement);</span><br><span class="line">        statement = withAfters(method, test, statement);</span><br><span class="line">        statement = withRules(method, test, statement);</span><br><span class="line">        statement = withInterruptIsolation(statement);</span><br><span class="line">        <span class="keyword">return</span> statement;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>withAfters、withBefores 会将 RunAfters 和 RunBefore 绑定到 statement，最后 形成一个 statement 链，这个链的执行入口时  RunAfters#evaluate。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evaluate</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    List&lt;Throwable&gt; errors = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        next.evaluate();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        errors.add(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 在 finally 中执行 after 方法</span></span><br><span class="line">        <span class="keyword">for</span> (FrameworkMethod each : afters) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                invokeMethod(each);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                errors.add(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MultipleFailureException.assertEmpty(errors);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>next 链中包括 before 和待执行的测试方法</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecbff5e3cc0045f9bed189ad1dd675ea~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><p>所以我们看到的就是 before -&gt; testMethod -&gt; after。</p><blockquote><p>这里其实和预想的不太一样，关于 before 和 after 这种逻辑，第一想法是通过代理的方式，对测试方法进行代理拦截，类似 Spring AOP 中的 Before 和 After，其实不然。</p></blockquote><h2 id="BeforeClass-和-AfterClass-执行时机"><a href="#BeforeClass-和-AfterClass-执行时机" class="headerlink" title="BeforeClass 和 AfterClass 执行时机"></a>BeforeClass 和 AfterClass 执行时机</h2><p>前面分析了 methodBlock，了解到 junit 中通过这个方法创建 statement 并且将 before 和 after 的方法绑定给 statement，以此推断，classBlock 的作用就是将 BeforeClass 和 AfterClass 绑定给statement 。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Statement <span class="title">classBlock</span><span class="params">(<span class="keyword">final</span> RunNotifier notifier)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// childrenInvoker 这里会调用到 methodBlock</span></span><br><span class="line">    Statement statement = childrenInvoker(notifier);</span><br><span class="line">    <span class="keyword">if</span> (!areAllChildrenIgnored()) &#123;</span><br><span class="line">        statement = withBeforeClasses(statement);</span><br><span class="line">        statement = withAfterClasses(statement);</span><br><span class="line">        statement = withClassRules(statement);</span><br><span class="line">        statement = withInterruptIsolation(statement);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>BeforeClass  和 before  都会对应创建一个 RunnerBefores，区别在于 BeforeClass   在创建 RunnerBefores 时，不会指定目标测试方法。</p><ul><li>BeforeClass  在执行 statement 之前，运行该类和超类上所有非覆盖的@BeforeClass方法;如果有抛出异常，停止执行并传递异常。</li><li>AfterClass 在执行 statement链最后，在该类和超类上运行所有未覆盖的 @AfterClass 方法；始终执行所有 AfterClass 方法：如有必要，将前面步骤抛出的异常与来自 AfterClass 方法的异常合并到 org.junit.runners.model.MultipleFailureException 中。</li></ul><h2 id="Junit-是怎么将执行结果收集并返回的"><a href="#Junit-是怎么将执行结果收集并返回的" class="headerlink" title="Junit 是怎么将执行结果收集并返回的"></a>Junit 是怎么将执行结果收集并返回的</h2><p>junit 所有执行的结果都存放在 Result 中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有 case 数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count;</span><br><span class="line"><span class="comment">// 忽略执行的 case 数（被打了 ignore）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ignoreCount;</span><br><span class="line"><span class="comment">// 失败 case 数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger assumptionFailureCount;</span><br><span class="line"><span class="comment">// 所有失败 case 的结果</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;Failure&gt; failures;</span><br><span class="line"><span class="comment">// 执行时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong runTime;</span><br><span class="line"><span class="comment">// 开始时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong startTime;</span><br></pre></td></tr></table></figure></p><p>Result  中内置了一个默认的来监听器，这个监听器会在每个 case 执行完成之后进行相应的回调，Listener 如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunListener</span>.ThreadSafe</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Listener</span> <span class="keyword">extends</span> <span class="title">RunListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置开始时间</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRunStarted</span><span class="params">(Description description)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            startTime.set(System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行完所有 case</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRunFinished</span><span class="params">(Result result)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">            runTime.addAndGet(endTime - startTime.get());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 执行完某个 case</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFinished</span><span class="params">(Description description)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            count.getAndIncrement();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 执行完某个 case 失败</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFailure</span><span class="params">(Failure failure)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            failures.add(failure);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 执行完某个ignore case</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIgnored</span><span class="params">(Description description)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ignoreCount.getAndIncrement();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAssumptionFailure</span><span class="params">(Failure failure)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Assumption 产生的失败</span></span><br><span class="line">            assumptionFailureCount.getAndIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>JUnit 4 开始在测试中支持假设 Assumptions，在 Assumptions 中，封装了一组使用的方法，以支持基于假设的条件测试执行。假设实际就是指定某个特定条件，假如不能满足假设条件，假设不会导致测试失败，只是终止当前测试。这也是假设与断言的最大区别，因为对于断言而言，会导致测试失败。</p></blockquote><p>所以 JUnit  通过监听器机制收集所有的测试信息，最终封装到 Result 中返回。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Junit 中有一些比较基本的概念，比如 Runner，statement 等；在初始化时，默认情况下 junit 会构建出 BlockJUnit4ClassRunner 这样的一个 Runner，并且在这个 Runner 中会持有被测试类的所有信息。Runner 运行测试并在执行此操作时将重要事件通知 RunNotifier。</p><blockquote><p>也可以使用 RunWith 调用自定义 Runner，这里只要你的 Runner 是 org.junit.runner.Runner 子类即可；创建自定义运行程序时，除了在此处实现抽象方法外，还必须提供一个构造函数，这个构造函数将包含测试的类作为参数–如：SpringRunner。</p></blockquote><p>Runner 的 run 方法内部就是构建和执行 Statement 链的过程，Statement  中描述了单元测试中需要执行的一系列操作，每个 case 均以 RunnerAfter -&gt; TargetMethod -&gt; RunnerBefore 的执行顺序依次执行；执行过程中，junit 通过监听器机制回调 case 调用的每个生命周期阶段，并将各个case 执行的信息进行收集汇总，最终返回执行结果 Result 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Junit 是由 Kent Beck 和 Erich Gamma 于 1995 年底着手编写的框架，自此以后，Junit 框架日益普及，现在已经成为单元测试 Java 应用程序的事实上的标准。&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在软件开发领域中，从来没有这样的
      
    
    </summary>
    
      <category term="测试" scheme="http://www.glmapper.com/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="junit" scheme="http://www.glmapper.com/tags/junit/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 进程被 kill 排查</title>
    <link href="http://www.glmapper.com/2021/01/06/jvm/jvm-problem-command/"/>
    <id>http://www.glmapper.com/2021/01/06/jvm/jvm-problem-command/</id>
    <published>2021-01-06T11:40:08.000Z</published>
    <updated>2021-07-18T04:05:05.793Z</updated>
    
    <content type="html"><![CDATA[<p>可能会导致 JAVA 进程被 kill 的原因</p><ul><li>Java应用程序的问题：发生 OOM 导致进程 Crash</li><li>JVM自身故障：JVM 或J DK 自身的 Bug 导致进程 Crash</li><li>被操作系统 OOM-Killer</li></ul><h4 id="Java应用程序的问题：发生-OOM-导致进程-Crash"><a href="#Java应用程序的问题：发生-OOM-导致进程-Crash" class="headerlink" title="Java应用程序的问题：发生 OOM 导致进程 Crash"></a>Java应用程序的问题：发生 OOM 导致进程 Crash</h4><p>一般情况下，出现 OOM 异常，JVM 的 GC 会进行回收，是不会直接导致 JVM 进程退出的。如果出现退出的情况，那就是内存泄漏，由于内存占用越来越大，最后就直接到 crash 了，这种 JVM 的 OOM 导致的异常，比较好排查。排查步骤如下：</p><ul><li>1、-XX:+HeapDumpOnOutOfMemoryError 和 -XX:HeapDumpPath=*/java.hprof</li><li>2、根据 HeapDumpPath 指定的路径查看是否产生 dump 文件</li><li>3、根据 dump 文件进行分析</li></ul><h4 id="JVM自身故障：JVM-或-JDK-自身的-Bug-导致进程-Crash"><a href="#JVM自身故障：JVM-或-JDK-自身的-Bug-导致进程-Crash" class="headerlink" title="JVM自身故障：JVM 或 JDK 自身的 Bug 导致进程 Crash"></a>JVM自身故障：JVM 或 JDK 自身的 Bug 导致进程 Crash</h4><p>当 JVM 出现致命错误时，会生成一个 hs_err_pid_xxx.log 这样的文件，该文件包含了导致 JVM crash 的重要信息，可以通过分析该文件定位到导致 crash 的根源，从而改善以保证系统稳定。当出现 crash 时，该文件默认会生成到工作目录下，然而可以通过 JVM 参数 -XX:ErrorFile 指定生成路径</p><blockquote><p>-XX:ErrorFile=/xxx/xxx/hs_err_pid<pid>.log<br>附 Java BUG dataBase 库：<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8134389" target="_blank" rel="noopener">https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8134389</a></pid></p></blockquote><h4 id="被操作系统-OOM-Killer"><a href="#被操作系统-OOM-Killer" class="headerlink" title="被操作系统 OOM-Killer"></a>被操作系统 OOM-Killer</h4><p>Linux 内核有个机制叫 OOM killer（Out-Of-Memory killer），该机制会监控那些占用内存过大，尤其是瞬间很快消耗大量内存的进程，为了防止内存耗尽而内核会把该进程杀掉。可以去 /var/log/messages 里翻系统报错日志，执行如下命令:</p><ul><li>dmesg | grep java </li><li>grep -i ‘killed process’ /var/log/messages</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可能会导致 JAVA 进程被 kill 的原因&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java应用程序的问题：发生 OOM 导致进程 Crash&lt;/li&gt;
&lt;li&gt;JVM自身故障：JVM 或J DK 自身的 Bug 导致进程 Crash&lt;/li&gt;
&lt;li&gt;被操作系统 OOM-Kille
      
    
    </summary>
    
      <category term="java" scheme="http://www.glmapper.com/categories/java/"/>
    
    
      <category term="JVM" scheme="http://www.glmapper.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>docker 基础备忘</title>
    <link href="http://www.glmapper.com/2020/12/24/docker/docker-docker-command/"/>
    <id>http://www.glmapper.com/2020/12/24/docker/docker-docker-command/</id>
    <published>2020-12-24T06:08:44.000Z</published>
    <updated>2021-07-18T04:03:11.708Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 已经不是什么新鲜的事物了，Docker 崛起的核心是因为 Docker 镜像的存在，这个创新使得 Docker 在短短几年内就可以迅速地改变了整个云计算领域的发展历程。Docker 镜像的存在解决了传统 paas 平台对于打包问题的根本难题，使得“压缩包”赋予了一种极其宝贵的能力：本地环境和云端环境的高度一致！</p><blockquote><p>Docker 镜像，其实就是一个压缩包。但是这个压缩包里的内容，比 PaaS 的应用可执行文件 + 启停脚本的组合就要丰富多了。实际上，大多数 Docker 镜像是直接由一个完整操作系统的所有文件和目录构成的，所以这个压缩包里的内容跟你本地开发和测试环境用的操作系统是完全一样的</p></blockquote><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">namespace</a>，以及 OverlayFS 类的 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 containerd。</p><blockquote><p>runc 是一个 Linux 命令行工具，用于根据 <a href="https://github.com/opencontainers/runtime-spec" target="_blank" rel="noopener">OCI容器运行时规范</a> 创建和运行容器。<br>containerd 是一个守护程序，它管理容器生命周期，提供了在一个节点上执行容器和管理镜像的最小功能集。</p></blockquote><h2 id="容器技术与-Docker-架构"><a href="#容器技术与-Docker-架构" class="headerlink" title="容器技术与 Docker 架构"></a>容器技术与 Docker 架构</h2><h3 id="容器到底是什么玩意？"><a href="#容器到底是什么玩意？" class="headerlink" title="容器到底是什么玩意？"></a>容器到底是什么玩意？</h3><p>容器技术是一种沙盒技术，就是能够像一个“箱子”一样，把你的应用“装”起来的技术。通过这样一种“箱子”，使的应用与应用之间相互不干扰，另外就是被装进“箱子”的应用，也具备了可以被方便地搬来搬去的灵活性。</p><p>容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”。对于 Docker 等大多数 Linux 容器来说，Cgroups 技术是用来制造约束的主要手段，而 Namespace 技术则是用来修改进程视图的主要方法。实际上是在创建容器进程时，指定了这个进程所需要启用的一组 Namespace 参数。这样，容器就只能“看”到当前 Namespace 所限定的资源、文件、设备、状态，或者配置。而对于宿主机以及其他不相关的程序，它就完全看不到了。就是 Linux 容器最基本的实现原理了，所以说，容器，其实是一种特殊的进程而已。</p><h3 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h3><p>下图是 Docker 官方提供的 Docker 架构图：</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/docker/docker-on-linux.png" alt="Docker 架构"></p><p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p><p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/docker/docker-model.jpg" alt=""></p><p>在这个对比图里，我们应该把 Docker 画在跟应用同级别并且靠边的位置。这意味着，用户运行在容器里的应用进程，跟宿主机上的其他进程一样，都由宿主机操作系统统一管理，只不过这些被隔离的进程拥有额外设置过的 Namespace 参数。而 Docker 项目在这里扮演的角色，更多的是旁路式的辅助和管理工作。</p><h3 id="隔离与限制"><a href="#隔离与限制" class="headerlink" title="隔离与限制"></a>隔离与限制</h3><p>使用虚拟化技术作为应用沙盒，就必须要由 Hypervisor 来负责创建虚拟机，这个虚拟机是真实存在的，并且它里面必须运行一个完整的 Guest OS 才能执行用户的应用进程。这就不可避免地带来了额外的资源消耗和占用。而相比之下，容器化后的用户应用，却依然还是一个宿主机上的普通进程，这就意味着这些因为虚拟化而带来的性能损耗都是不存在的；而另一方面，使用 Namespace 作为隔离手段的容器并不需要单独的 Guest OS，这就使得容器额外的资源占用几乎可以忽略不计。所以说，“敏捷”和“高性能”是容器相较于虚拟机最大的优势，但是万事都有两面，有利就有弊，对于 Docker 这种基于 Linux Namespace 的隔离机制，相比于虚拟化技术最大的不足就是：<strong>隔离得不彻底</strong>。</p><ul><li>1、多个容器之间使用的就还是同一个宿主机的操作系统内核。</li></ul><blockquote><p>通过 Mount Namespace 单独挂载其他不同版本的操作系统文件，比如 CentOS 或者 Ubuntu，但这并不能改变共享宿主机内核的事实。这意味着，如果你要在 Windows 宿主机上运行 Linux 容器，或者在低版本的 Linux 宿主机上运行高版本的 Linux 容器，都是行不通的。而相比之下，拥有硬件虚拟化技术和独立 Guest OS 的虚拟机就要方便得多了。最极端的例子是，Microsoft 的云计算平台 Azure，实际上就是运行在 Windows 服务器集群上的，但这并不妨碍你在它上面创建各种 Linux 虚拟机出来</p></blockquote><ul><li>2、在 Linux 内核中，有很多资源和对象是不能被 Namespace 化的，最典型的例子就是：时间。</li></ul><blockquote><p>你的容器中的程序使用 settimeofday(2) 系统调用修改了时间，整个宿主机的时间都会被随之修改，这显然不符合用户的预期。相比于在虚拟机里面可以随便折腾的自由度，在容器里部署应用的时候，“什么能做，什么不能做”，就是用户必须考虑的一个问题</p></blockquote><p>正是这种隔离不彻底上的问题，使得还需要另外一种技术来保障容器的稳定性，不至于资源都被一个容器全部吃掉，或者因为某个容器的修改导致其他容器也受到影响。这里就需要提到 Cgroups。</p><p>Linux Cgroups 的全称是 Linux Control Group，它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等；Linux Cgroups 的设计是比较易用的，简单理解就是给每一个子系统目录加上一组资源限制文件的组合；对于 Docker 等 Linux 容器项目来说，只需要在每个子系统下面，为每个容器创建一个控制组（即创建一个新目录），然后在启动容器进程之后，把这个进程的 PID 填写到对应控制组的 tasks 文件中就可以了。如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --cpu-period=100000 --cpu-quota=20000 ubuntu /bin/bash</span><br></pre></td></tr></table></figure><h2 id="Docker-中的三个角色"><a href="#Docker-中的三个角色" class="headerlink" title="Docker 中的三个角色"></a>Docker 中的三个角色</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>由于镜像会包括操作系统完整的 root 文件系统，所以我们一般看到的镜像都是比较大的。Docker 在设计时，其充分利用了 Union FS 的技术，将镜像设计为分层存储的架构模式。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 namespace 。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样</p><blockquote><p>容器也是分层存储，每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。<br>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡，所以按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者 绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高</p></blockquote><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>集中的存储、分发镜像的服务：Docker Registry。</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>待补充…</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>《深入剖析Kubernetes：张磊》</li><li><a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noopener">https://yeasy.gitbook.io/docker_practice/</a></li><li><a href="https://www.cnblogs.com/bjlhx/p/13202505.html" target="_blank" rel="noopener">https://www.cnblogs.com/bjlhx/p/13202505.html</a></li><li><a href="http://dockone.io/article/783" target="_blank" rel="noopener">http://dockone.io/article/783</a></li><li><a href="http://merrigrove.blogspot.com/2015/10/visualizing-docker-containers-and-images.html" target="_blank" rel="noopener">http://merrigrove.blogspot.com/2015/10/visualizing-docker-containers-and-images.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Docker 已经不是什么新鲜的事物了，Docker 崛起的核心是因为 Docker 镜像的存在，这个创新使得 Docker 在短短几年内就可以迅速地改变了整个云计算领域的发展历程。Docker 镜像的存在解决了传统 paas 平台对于打包问题的根本难题，使得“压缩包”赋予
      
    
    </summary>
    
      <category term="docker" scheme="http://www.glmapper.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://www.glmapper.com/tags/docker/"/>
    
      <category term="dockerfile" scheme="http://www.glmapper.com/tags/dockerfile/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码系列：BeanFactory的创建</title>
    <link href="http://www.glmapper.com/2020/12/16/spring/spring-series-beanfactory/"/>
    <id>http://www.glmapper.com/2020/12/16/spring/spring-series-beanfactory/</id>
    <published>2020-12-16T05:17:17.000Z</published>
    <updated>2020-12-16T05:17:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>Spring的Ioc容器其实就是一个bean的关系网，依赖于core，bean，context三个组件来构建的。在spring中最核心的就是对于bean的管理。而bean又依托于我们的容器。本文将从顶层分析一下spring中beanFactory的具体创建过程，为后续的bean的生命周期提供一个基础。</p><p><strong>BeanFactory的继承体系</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/1/29/16141a440ba09c49?w=1249&amp;h=708&amp;f=png&amp;s=25412" alt=""><br>从上图可以看到，BeanFactory有三个子类：</p><ul><li>ListableBeanFactory</li><li>HierarchicalBeanFactory</li><li>AutowireCapableBeanFactory</li></ul><p><em>（上述三个类的子类体系小伙伴们可以自己对着源码看下，实在太多）</em></p><p>看下上图中最底层的DefaultListableBeanFactory类的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractAutowireCapableBeanFactory</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ConfigurableListableBeanFactory</span>, <span class="title">BeanDefinitionRegistry</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></p><p>这个其实就是BeanFactory的默认实现类，它直接或者间接的实现了所有的接口。其实在看spring源码的时候都会遇到类似的设计模式，对于某一个具体的功能，通常都会定义很多层的接口，层层包装，层层委托。这种做法的好处就是，对于不同的场合都会有特定的接口；这样一来就可以在spring内部对对象的传递和转化操作都会有一些访问限制。</p><p>例如ListableBeanFactory接口表示这些Bean是可列表的，而HierarchicalBeanFactory表示的是这些Bean是有继承关系的，也就是每个Bean有可能有父Bean。AutowireCapableBeanFactory接口定义Bean的自动装配规则。这四个接口共同定义了Bean的集合、Bean之间的关系、以及Bean行为。</p><p><strong>BeanFactory的创建</strong></p><p>在之前的文章中说过了容器的刷新过程。BeanFactory的创建也在wac.refresh()方法中。具体看下到底是通过哪些子类来完成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通知子类刷新内部的bean工厂。</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br></pre></td></tr></table></figure><p><strong><em>1.AbstractApplicationContext中的obtainFreshBeanFactory</em></strong></p><p>下面是obtainFreshBeanFactory的方法逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个是具体创建的方法，由子类实现</span></span><br><span class="line">refreshBeanFactory();</span><br><span class="line"><span class="comment">//获取BeanFactory实例对象（ConfigurableListableBeanFactory类型的）</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>refreshBeanFactory并未有具体的实现逻辑，这个方法主要是通过委托给子类的refreshBeanFactory方法来实现，在AbstractApplicationContext中refreshBeanFactory是一个抽象模板方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;</span><br></pre></td></tr></table></figure><p><strong><em>2.refreshBeanFactory方法(AbstractRefreshableApplicationContext类中)：</em></strong></p><p><code>下面只注释与beanFactory创建相关的代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">//是否已经有BeanFactory了</span></span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        <span class="comment">//销毁原有的Bean</span></span><br><span class="line">    destroyBeans();</span><br><span class="line">    <span class="comment">//关闭工厂</span></span><br><span class="line">    closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个新的beanFactory</span></span><br><span class="line">    DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">    beanFactory.setSerializationId(getId());</span><br><span class="line">    customizeBeanFactory(beanFactory);</span><br><span class="line">    loadBeanDefinitions(beanFactory);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition </span></span><br><span class="line"><span class="string">    source for "</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是实现执行这个上下文的底层bean工厂的实际刷新，如果有的话之前有BeanFactory存在，则关闭以前的bean工厂。并为上下文生命周期的下一个阶段初始化一个新鲜的bean工厂。</p><p><strong><em>3.createBeanFactory(AbstractRefreshableApplicationContext类中)</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DefaultListableBeanFactory <span class="title">createBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DefaultListableBeanFactory(getInternalParentBeanFactory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就是为当前上下文创建一个内部的bean工厂。每次调用refresh()方法是都会创建尝试创建。默认实现是创建一个DefaultListableBeanFactory。并通过getInternalParentBeanFactory（）获取内部bean工厂来作为父级bean工厂。可以在子类中重写，例如自定义DefaultListableBeanFactory的设置。</p><p><strong><em>getInternalParentBeanFactory（AbstractApplicationContext类中）</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanFactory <span class="title">getInternalParentBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (getParent() <span class="keyword">instanceof</span> ConfigurableApplicationContext) ?</span><br><span class="line">((ConfigurableApplicationContext) getParent()).getBeanFactory() : getParent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>4.DefaultListableBeanFactory的构造函数</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过给定的父类创建一个新的DefaultListableBeanFactory容器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentBeanFactory the parent BeanFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultListableBeanFactory</span><span class="params">(BeanFactory parentBeanFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(parentBeanFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>super(parentBeanFactory)调用的是AbstractAutowireCapableBeanFactory的构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过给定的父类构建新的AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentBeanFactory parent bean factory, or &#123;<span class="doctag">@code</span> null&#125; if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractAutowireCapableBeanFactory</span><span class="params">(BeanFactory parentBeanFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>();</span><br><span class="line"><span class="comment">//设置父工厂</span></span><br><span class="line">setParentBeanFactory(parentBeanFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>this(),还是AbstractAutowireCapableBeanFactory的构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建一个新的AbstractAutowireCapableBeanFactory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractAutowireCapableBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">ignoreDependencyInterface(BeanNameAware.class);</span><br><span class="line">ignoreDependencyInterface(BeanFactoryAware.class);</span><br><span class="line">ignoreDependencyInterface(BeanClassLoaderAware.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>super()  ;     AbstractBeanFactory的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建一个新的AbstractBeanFactory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring的Ioc容器其实就是一个bean的关系网，依赖于core，bean，context三个组件来构建的。在spring中最核心的就是对于bean的管理。而bean又依托于我们的容器。本文将从顶层分析一下spring中beanFactory的具体创建过程，为后续的be
      
    
    </summary>
    
      <category term="spring" scheme="http://www.glmapper.com/categories/spring/"/>
    
    
      <category term="spring" scheme="http://www.glmapper.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>每天一道算法题：Z字形转换</title>
    <link href="http://www.glmapper.com/2020/12/16/leetcode/leetcodetwo/"/>
    <id>http://www.glmapper.com/2020/12/16/leetcode/leetcodetwo/</id>
    <published>2020-12-16T03:47:38.000Z</published>
    <updated>2020-12-16T03:47:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将字符串 “PAYPALISHIRING” 以Z字形排列成给定的行数：（下面这样的形状）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure><p>之后按逐行顺序依次排列：”PAHNAPLSIIGYIR”</p><p>实现一个将字符串进行指定行数的转换的函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string convert(string text, int nRows);</span><br></pre></td></tr></table></figure><p>convert(“PAYPALISHIRING”, 3) 应当返回 “PAHNAPLSIIGYIR” 。</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算字符串长度</span></span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="comment">//两个周期之间的列数，</span></span><br><span class="line">    <span class="keyword">int</span> slash = numRows - <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//计算行的长度</span></span><br><span class="line">    <span class="keyword">int</span> rowLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//竖列</span></span><br><span class="line">        len = len - numRows;</span><br><span class="line">        rowLength++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//斜着的一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slash &amp;&amp; len &gt; <span class="number">0</span>; i++)&#123;</span><br><span class="line">            len--;</span><br><span class="line">            rowLength++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立一个多一列的数组用于保存我们的字符串,并且全部初始化为空格了</span></span><br><span class="line">    <span class="keyword">char</span> result[] = <span class="keyword">new</span> <span class="keyword">char</span>[numRows* rowLength];</span><br><span class="line">    <span class="comment">// 初始化为空格</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.length; i++) &#123; </span><br><span class="line">        result[i] = <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前处理的行数</span></span><br><span class="line">    <span class="keyword">int</span> curColumn = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面将字符串写入所谓的矩阵中</span></span><br><span class="line">    <span class="keyword">while</span>(index &lt; s.length())&#123;</span><br><span class="line">        <span class="comment">//写入列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows &amp;&amp; index &lt; s.length(); i++)&#123;</span><br><span class="line">            result[rowLength * i + curColumn] = s.charAt(index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curColumn++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入斜线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = numRows - <span class="number">2</span>; i &gt; <span class="number">0</span> &amp;&amp; index &lt; s.length(); i--)&#123;</span><br><span class="line">            result[rowLength * i + curColumn] = s.charAt(index);</span><br><span class="line">            curColumn++;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去空格，定义两个指针循环进行操作</span></span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 找第一个是空格的字符位置</span></span><br><span class="line">    <span class="keyword">while</span> (index &lt; s.length() &amp;&amp; result[index] != <span class="string">' '</span>) &#123; </span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> next = index + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">// 找不是空格的元素</span></span><br><span class="line">        <span class="keyword">while</span> (next &lt; result.length &amp;&amp; result[next] == <span class="string">' '</span>) &#123; </span><br><span class="line">            next++;</span><br><span class="line">        &#125;</span><br><span class="line">        result[index] = result[next];</span><br><span class="line">        index++;</span><br><span class="line">        next++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(result, <span class="number">0</span>, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题目想了两天，之前的思路是建立一个二维数组，然后填充，最后遍历数组拿到结果，但是对于很多边界问题不太好考虑，放弃。这两种方案的首要核心都是计算列数和对斜列的处理，没有数学功底和抽象思维的程序员真的伤不起。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;将字符串 “PAYPALISHIRING” 以Z字形排列成给定的行数：（下面这样的形状）&lt;/p&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="leetcode" scheme="http://www.glmapper.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://www.glmapper.com/tags/leetcode/"/>
    
      <category term="算法" scheme="http://www.glmapper.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>maven 中 repository 是如何工作的</title>
    <link href="http://www.glmapper.com/2020/12/16/maven/maven-repository/"/>
    <id>http://www.glmapper.com/2020/12/16/maven/maven-repository/</id>
    <published>2020-12-16T03:45:31.000Z</published>
    <updated>2020-12-18T06:46:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文中，我们将来看下如何在 maven 项目中定义和解决依赖关系，然后深入研究 maven 存储库如何使这些依赖关系可供使用的。</p><h2 id="什么是-maven-依赖项？"><a href="#什么是-maven-依赖项？" class="headerlink" title="什么是 maven 依赖项？"></a>什么是 maven 依赖项？</h2><p>关于这个相信都不会陌生，就是在 <dependencies> 里面申明这样一个配置</dependencies></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.glmapper.bridge.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="maven-坐标"><a href="#maven-坐标" class="headerlink" title="maven 坐标"></a>maven 坐标</h2><p>大多数的 dependency 申明都会包括 groupId、artifactId、version 这些标签项，这样一组 key/value 对的组合成了maven 坐标，来标识一个特定的 dependency，和地图的经纬度坐标一样，通过这个坐标我们就可以精准的指定一个特定的 dependency。</p><h2 id="maven-是如何定位和解析-dependencies？"><a href="#maven-是如何定位和解析-dependencies？" class="headerlink" title="maven 是如何定位和解析 dependencies？"></a>maven 是如何定位和解析 dependencies？</h2><p>maven 的仓库和其他的像  APT、YUM 等不同，它不存在类似于主索引文件这样的东西存在能够去列举出当前仓库中所有可用的 artifacts。maven 使用的是通过给定依赖项的坐标值，然后再根据 <a href="https://cwiki.apache.org/confluence/display/MAVENOLD/Repository+Layout+-+Final" target="_blank" rel="noopener">maven repository layout</a> 构造出依赖的 URL。</p><h2 id="maven-repository-layout-映射"><a href="#maven-repository-layout-映射" class="headerlink" title="maven repository layout 映射"></a>maven repository layout 映射</h2><p>对于一个 maven artifact，它的 URL 大概格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/$groupId[0]/../$&#123;groupId[n]/$artifactId/$version/$artifactId-$version.$extension</span><br><span class="line"># 如 /com/glmapper/bridge/boot/client/1.0.0/client-1.0.0.jar</span><br></pre></td></tr></table></figure><h2 id="groupId-的规则"><a href="#groupId-的规则" class="headerlink" title="groupId 的规则"></a>groupId 的规则</h2><p>groupId 是一个字符串数组，以 . 分隔，如 <code>org.springframework.boot</code>，那实际上实际路径会转换成的文件路径是 /org/springframework/boot/ 。</p><h2 id="artifact"><a href="#artifact" class="headerlink" title="artifact"></a>artifact</h2><p>maven 的核心功能之一是其处理传递依赖性的能力。也就是说，以递归的方式查找和下载依赖项的依赖项以及它们的依赖项，直到它们全部满足为止。</p><h2 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h2><p>我们把 com.glmapper.bridge.boot 的 groupId 转换成 /com/glmapper/bridge/boot，然后用 $artifactId 和$versionId 构造 URL 的其余部分，像这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/com/glmapper/bridge/boot/client/1.0.0/client-1.0.0.pom</span><br></pre></td></tr></table></figure><h2 id="jar"><a href="#jar" class="headerlink" title="jar"></a>jar</h2><p>和 pom 差不多，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/com/glmapper/bridge/boot/client/1.0.0/client-1.0.0.jar</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.packagecloud.io/eng/2017/03/09/how-does-a-maven-repository-work/#maven-metadataxml" target="_blank" rel="noopener">https://blog.packagecloud.io/eng/2017/03/09/how-does-a-maven-repository-work/#maven-metadataxml</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文中，我们将来看下如何在 maven 项目中定义和解决依赖关系，然后深入研究 maven 存储库如何使这些依赖关系可供使用的。&lt;/p&gt;
&lt;h2 id=&quot;什么是-maven-依赖项？&quot;&gt;&lt;a href=&quot;#什么是-maven-依赖项？&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="maven" scheme="http://www.glmapper.com/categories/maven/"/>
    
    
      <category term="java" scheme="http://www.glmapper.com/tags/java/"/>
    
      <category term="maven" scheme="http://www.glmapper.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>概念基础-Linux 中的 namespace</title>
    <link href="http://www.glmapper.com/2020/12/12/linux/linux-concept-namespace/"/>
    <id>http://www.glmapper.com/2020/12/12/linux/linux-concept-namespace/</id>
    <published>2020-12-12T02:54:43.000Z</published>
    <updated>2021-07-18T03:55:47.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>namespace 是 Linux 内核用来隔离内核资源的方式。通过 namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源，这两拨进程根本就感觉不到对方的存在。具体的实现方式是把一个或多个进程的相关资源指定在同一个 namespace 中。</p><p>Linux namespaces 是对全局系统资源的一种封装隔离，使得处于不同 namespace 的进程拥有独立的全局系统资源，改变一个 namespace 中的系统资源只会影响当前 namespace 里的进程，对其他 namespace 中的进程没有影响。</p><h2 id="namespace-的作用"><a href="#namespace-的作用" class="headerlink" title="namespace 的作用"></a>namespace 的作用</h2><p>从前面介绍我们基本明确了 namespace 的作用，那就是“隔离”。Linux 内核实现 namespace 的一个主要目的就是实现轻量级虚拟化(容器)服务；在同一个 namespace 下的进程可以感知彼此的变化，而对外界的进程一无所知。这样就可以让容器中的进程产生错觉，认为自己置身于一个独立的系统中，从而达到隔离的目的。也就是说 linux 内核提供的 namespace 技术为 docker 等容器技术的出现和发展提供了基础条件。</p><p>从 docker 实现者的角度考虑该如何实现一个资源隔离的容器。比如是不是可以</p><ul><li>通过 chroot 命令切换根目录的挂载点，从而隔离文件系统。</li><li>为了在分布式的环境下进行通信和定位，容器必须要有独立的 IP、端口和路由等，这就需要对网络进行隔离。</li><li>容器需要一个独立的主机名以便在网络中标识自己</li><li>进程间的通信隔离。</li><li>用户权限隔离</li><li>运行在容器中的应用需要有进程号(PID)，需要与宿主机中的 PID 进行隔离。</li></ul><p>也就是说这六种隔离能力是实现一个容器的基础，下面就看下 linux 内核的 namespace 特性提供了什么样的隔离能力：</p><table><thead><tr><th>名称</th><th>Flag</th><th>隔离的资源</th></tr></thead><tbody><tr><td>Cgroup</td><td>CLONE_NEWCGROUP</td><td>Cgroup root directory(cgroup 的根目录)</td></tr><tr><td>IPC</td><td>CLONE_NEWIPC</td><td>System V IPC, POSIX message queues(信号量、消息队列和共享内存)</td></tr><tr><td>Network</td><td>CLONE_NEWNET</td><td>Network devices,stacks, ports, etc.（网络设备、网络栈、端口）</td></tr><tr><td>Mount</td><td>CLONE_NEWNS</td><td>Mount points（挂载点）</td></tr><tr><td>PID</td><td>CLONE_NEWPID</td><td>Process IDs（进程 ID）</td></tr><tr><td>Time</td><td>CLONE_NEWTIME</td><td>Boot and monotonic clocks（启动和单调时钟）</td></tr><tr><td>User</td><td>CLONE_NEWUSER</td><td>User and group IDs（用户和用户组）</td></tr><tr><td>UTS</td><td>CLONE_NEWUTS</td><td>Hostname and NIS domian name（主机名和 NIS 域名）</td></tr></tbody></table><blockquote><p>Cgroup namespace 是后面才增加的，本篇不做过多介绍，将另起篇幅。</p></blockquote><h2 id="namespace-的基本操作"><a href="#namespace-的基本操作" class="headerlink" title="namespace 的基本操作"></a>namespace 的基本操作</h2><h3 id="查看进程所属的-namespace"><a href="#查看进程所属的-namespace" class="headerlink" title="查看进程所属的 namespace"></a>查看进程所属的 namespace</h3><p>/proc/[pid]/ns 目录下会包含进程所属的 namespace 信息，使用下面的命令可以查看当前进程所属的 namespace 信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ll /proc/$$/ns</span><br><span class="line">总用量 0</span><br><span class="line">dr-x--x--x 2 admin admin 0 12月 12 11:19 ./</span><br><span class="line">dr-xr-xr-x 9 admin admin 0 12月 12 11:18 ../</span><br><span class="line">lrwxrwxrwx 1 admin admin 0 12月 12 11:19 cgroup -&gt; cgroup:[4026537386]</span><br><span class="line">lrwxrwxrwx 1 admin admin 0 12月 12 11:19 ipc -&gt; ipc:[4026536810]</span><br><span class="line">lrwxrwxrwx 1 admin admin 0 12月 12 11:19 mnt -&gt; mnt:[4026537383]</span><br><span class="line">lrwxrwxrwx 1 admin admin 0 12月 12 11:19 net -&gt; net:[4026536400]</span><br><span class="line">lrwxrwxrwx 1 admin admin 0 12月 12 11:19 pid -&gt; pid:[4026537385]</span><br><span class="line">lrwxrwxrwx 1 admin admin 0 12月 12 11:19 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 admin admin 0 12月 12 11:19 uts -&gt; uts:[4026537384]</span><br></pre></td></tr></table></figure><p>或者 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ll /proc/7370/ns</span><br><span class="line">总用量 0</span><br><span class="line">dr-x--x--x 2 admin admin 0 12月 12 11:20 ./</span><br><span class="line">dr-xr-xr-x 9 admin admin 0 12月  9 18:43 ../</span><br><span class="line">lrwxrwxrwx 1 admin admin 0 12月 12 11:20 cgroup -&gt; cgroup:[4026537386]</span><br><span class="line">lrwxrwxrwx 1 admin admin 0 12月 12 11:20 ipc -&gt; ipc:[4026536810]</span><br><span class="line">lrwxrwxrwx 1 admin admin 0 12月 12 11:20 mnt -&gt; mnt:[4026537383]</span><br><span class="line">lrwxrwxrwx 1 admin admin 0 12月 12 11:20 net -&gt; net:[4026536400]</span><br><span class="line">lrwxrwxrwx 1 admin admin 0 12月 12 11:20 pid -&gt; pid:[4026537385]</span><br><span class="line">lrwxrwxrwx 1 admin admin 0 12月 12 11:20 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 admin admin 0 12月 12 11:20 uts -&gt; uts:[4026537384]</span><br></pre></td></tr></table></figure><p>从输出的 namespace 信息可以看到，namespace 文件都是<a href="https://segmentfault.com/a/1190000011821634" target="_blank" rel="noopener">链接文件</a>; 以 cgroup:[4026537386] 为例：</p><ul><li>cgroup 是 namespace 的类型</li><li>数字（inode number ）标识一个 namespace，可以理解为 namespace 的 ID</li></ul><p>如果两个进程的某个 namespace 文件指向同一个链接文件，说明其相关资源在同一个 namespace 中。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://man7.org/linux/man-pages/man7/namespaces.7.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man7/namespaces.7.html</a></li><li><a href="https://www.cnblogs.com/sparkdev/p/9365405.html" target="_blank" rel="noopener">https://www.cnblogs.com/sparkdev/p/9365405.html</a></li><li><a href="https://segmentfault.com/a/1190000011821634" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011821634</a></li><li><a href="https://segmentfault.com/a/1190000017474527?utm_source=sf-related" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017474527?utm_source=sf-related</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h2&gt;&lt;p&gt;namespace 是 Linux 内核用来隔离内核资源的方式。通过 namespace 可以让一些进程只能看到与自己相关的
      
    
    </summary>
    
      <category term="linux" scheme="http://www.glmapper.com/categories/linux/"/>
    
    
      <category term="namestapce" scheme="http://www.glmapper.com/tags/namestapce/"/>
    
  </entry>
  
  <entry>
    <title>JVM 性能调优监控工具</title>
    <link href="http://www.glmapper.com/2020/10/26/jvm/jvm-self-command/"/>
    <id>http://www.glmapper.com/2020/10/26/jvm/jvm-self-command/</id>
    <published>2020-10-26T01:59:20.000Z</published>
    <updated>2021-07-18T04:05:09.520Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要学习记录下工作中常用的 <code>JDK</code> 自带的一些 <code>JVM</code> 性能调优监控工具，通过了解这些工具，可以在排查问题时给予我们非常大的帮助，将一些隐藏在底下的东西拿到明面上来做分析。</p><h1 id="jps-Java-Virtual-Machine-Process-Status-Tool"><a href="#jps-Java-Virtual-Machine-Process-Status-Tool" class="headerlink" title="jps(Java Virtual Machine Process Status Tool)"></a>jps(Java Virtual Machine Process Status Tool)</h1><p><code>jps</code> 主要用来输出 <code>JVM</code> 中运行的进程状态信息。语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure><p>如果不指定 <code>hostid</code> 就默认为当前主机或服务器，命令行参数选项说明如下：</p><h4 id="q-不输出类名、Jar名和传入main方法的参数"><a href="#q-不输出类名、Jar名和传入main方法的参数" class="headerlink" title="-q 不输出类名、Jar名和传入main方法的参数"></a>-q 不输出类名、Jar名和传入main方法的参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ jps -q</span><br><span class="line">42060</span><br></pre></td></tr></table></figure><h4 id="m-输出传入-main-方法的参数-与默认-jps-指令返回的信息相同"><a href="#m-输出传入-main-方法的参数-与默认-jps-指令返回的信息相同" class="headerlink" title="-m 输出传入 main 方法的参数(与默认 jps 指令返回的信息相同)"></a>-m 输出传入 main 方法的参数(与默认 jps 指令返回的信息相同)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ jps -m</span><br><span class="line">42060 TestSofaBootApplication</span><br></pre></td></tr></table></figure><h4 id="l-输出-main-类或-jar-的全限名"><a href="#l-输出-main-类或-jar-的全限名" class="headerlink" title="-l 输出 main 类或 jar 的全限名"></a>-l 输出 main 类或 jar 的全限名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ jps -l</span><br><span class="line">42060 com.glmapper.bridge.boot.TestSofaBootApplication</span><br></pre></td></tr></table></figure><h4 id="v-输出传入-JVM-的参数"><a href="#v-输出传入-JVM-的参数" class="headerlink" title="-v 输出传入 JVM 的参数"></a>-v 输出传入 JVM 的参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ jps -v</span><br><span class="line">42060 TestSofaBootApplication -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:51645,suspend=y,server=n -XX:TieredStopAtLevel=1 -Xverify:none -Dspring.output.ansi.enabled=always -Dcom.sun.management.jmxremote -Dspring.jmx.enabled=true -Dspring.liveBeansView.mbeanDomain -Dspring.application.admin.enabled=true -javaagent:/Users/xxxx/Library/Caches/JetBrains/IntelliJIdea2020.1/captureAgent/debugger-agent.jar -Dfile.encoding=UTF-8</span><br></pre></td></tr></table></figure><p>在排查问题时，我们通过都会通过 <code>jps</code> 来看下当前机器运行的进程有哪些，通过不同的参数来快速找到我们目标进程所在的 <code>pid</code>，以便于我们后续的一系列排查操作。</p><h1 id="jstack-Java-Stack-Trace"><a href="#jstack-Java-Stack-Trace" class="headerlink" title="jstack(Java Stack Trace)"></a>jstack(Java Stack Trace)</h1><p><strong>jstack</strong> 主要用来查看某个 <code>Java</code> 进程内的线程堆栈信息。如果 <code>java</code> 程序崩溃生成 <code>core</code> 文件，<code>jstack</code> 工具可以用来获得 <code>core</code> 文件的 <code>java stack</code> 和 <code>native stack</code> 的信息，从而可以轻松地知道 <code>java</code> 程序是如何崩溃和在程序何处发生问题。另外，<code>jstack</code> 工具还可以附属到正在运行的 <code>java</code> 程序中，看到当时运行的 <code>java</code> 程序的 <code>java stack</code> 和 <code>native stack</code> 的信息, 如果现在运行的 <code>java</code> 程序呈现 <code>hung</code> 的状态，<code>jstack</code> 是非常有用的。</p><p>下面是 <code>jstack</code> 语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstack [option] pid</span><br><span class="line">jstack [option] executable core</span><br><span class="line">jstack [option] [server-id@]remote-hostname-or-ip</span><br></pre></td></tr></table></figure><p><strong>不管是什么指令，我们都要学会先通过 -h 去查一下</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ jstack -h</span><br><span class="line">Usage:</span><br><span class="line">    jstack [-l] &lt;pid&gt;</span><br><span class="line">        (连接到正在运行的进程)</span><br><span class="line">    jstack -F [-m] [-l] &lt;pid&gt;</span><br><span class="line">        (连接到挂起的进程)</span><br><span class="line">    jstack [-m] [-l] &lt;executable&gt; &lt;core&gt;</span><br><span class="line">        (连接到 core 文件)</span><br><span class="line">    jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (连接到远程调试服务器)</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">    -F  to force a thread dump. Use when jstack &lt;pid&gt; does not respond (process is hung)</span><br><span class="line">    -m  to print both java and native frames (mixed mode)</span><br><span class="line">    -l  long listing. Prints additional information about locks</span><br><span class="line">    -h or -help to print this help message</span><br></pre></td></tr></table></figure><p><code>Options</code> 参数说明如下：</p><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">-F</td><td style="text-align:left">当正常输出的请求不被响应时，强制输出线程堆栈</td></tr><tr><td style="text-align:left">-m</td><td style="text-align:left">如果调用到本地方法的话，可以显示 C/C++ 的堆栈</td></tr><tr><td style="text-align:left">-l</td><td style="text-align:left">除堆栈外，显示关于锁的附加信息，在发生死锁时可以用 jstack -l pid 来观察锁持有情况</td></tr></tbody></table><p>下面我们重点来聊一聊，<code>jstack</code> 中信息到底要怎么看。</p><h2 id="jstack-堆栈信息介绍"><a href="#jstack-堆栈信息介绍" class="headerlink" title="jstack 堆栈信息介绍"></a>jstack 堆栈信息介绍</h2><p>下面是 <code>jstack</code> 输出的一段 <code>tacer</code> 数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot; #1 prio=5 os_prio=31 tid=0x00007fb93b802000 nid=0x2703 waiting on condition [0x0000700005e5d000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at com.glmapper.bridge.boot.TestJstack.testWaitingOnConditionCondition(TestJstack.java:19)</span><br><span class="line">at com.glmapper.bridge.boot.TestJstack.main(TestJstack.java:10)</span><br></pre></td></tr></table></figure><p>通过这段数据我们大概能 <code>get</code> 到的点主要包括以下信息：</p><ul><li>main 线程名</li><li>#1 堆栈序号，没有实际含义，可忽略</li><li>prio 线程优先级</li><li>os_prio 操作系统层次的优先级</li><li>tid 线程标识</li><li>nid 线程id</li></ul><h2 id="线程状态介绍"><a href="#线程状态介绍" class="headerlink" title="线程状态介绍"></a>线程状态介绍</h2><p>从上面 jstack 输出的信息可以看到线程状态相关的信息，比如</p><h4 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING"></a>TIMED_WAITING</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br></pre></td></tr></table></figure><h4 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a>RUNNABLE</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Thread.State: RUNNABLE</span><br></pre></td></tr></table></figure><p>还有一些 <code>&quot;GC task thread#0 (ParallelGC)&quot; os_prio=31 tid=0x00007fcee9004000 nid=0x1f07 runnable</code> 信息，这种是 jvm 用来回收内存的，先不关注，这里主要看下 <code>java.lang.Thread.State</code>;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当线程对象创建时存在的状态，此时线程不可能执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当调用thread.start()后，线程变成为 Runnable 状态。只要得到CPU，就可以执行；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果进入同步方法或同步代码块，没有获取到锁，则会进入该状态；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行thread.join()或在锁对象调用obj.wait()等情况就会进该状态，表明线程正处于等待某个资源或条件发生来唤醒自己；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行Thread.sleep(long)、thread.join(long)或obj.wait(long)等就会进该状态，与Waiting的区别在于Timed_Waiting的等待有时间限制；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 终止</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再回到上面堆栈信息，可以观察到，当状态是 TIMED_WAITING 时，堆栈中会出现 <code>waiting on condition xxxx</code> 信息，类似的还有：</p><ul><li>waiting on monitor entry : 在等待获取锁，一般对应 BLOCKED</li><li>in Object.wait() : 获取锁后又执行obj.wait()放弃锁，一般对应 WAITING</li></ul><p>下面就针对这些状态举一些简单的小例子。</p><h2 id="线程状态举例及-jstack-分析"><a href="#线程状态举例及-jstack-分析" class="headerlink" title="线程状态举例及 jstack 分析"></a>线程状态举例及 jstack 分析</h2><h3 id="waiting-on-condition"><a href="#waiting-on-condition" class="headerlink" title="waiting on condition"></a>waiting on condition</h3><p><strong>1、执行代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产生 waiting on condition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWaitingOnConditionCondition</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">60000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、执行结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot; #1 prio=5 os_prio=31 tid=0x00007fb93b802000 nid=0x2703 waiting on condition [0x0000700005e5d000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at com.glmapper.bridge.boot.TestJstack.testWaitingOnConditionCondition(TestJstack.java:19)</span><br><span class="line">at com.glmapper.bridge.boot.TestJstack.main(TestJstack.java:10)</span><br></pre></td></tr></table></figure><p><strong>3、结果分析</strong></p><p>这里就比较明显的是 main 线程中正在 sleep 方法。不过这里 TIMED_WAITING 后面的括号里还特殊表明了 <code>sleeping</code>，在一些场景下，常见的还有 parking，下面继续看例子。</p><h3 id="waiting-on-condition-parking"><a href="#waiting-on-condition-parking" class="headerlink" title="waiting on condition (parking)"></a>waiting on condition (parking)</h3><p><strong>1、执行代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWaitingOnConditionConditionWithParking</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 提供一个阻塞对了</span></span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 先加一个</span></span><br><span class="line">    blockingQueue.add(<span class="string">"test-parking"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//继续加，这里肯定加不进去，所以会阻塞</span></span><br><span class="line">        blockingQueue.put(<span class="string">"test-parking-xxx"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、执行结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot; #1 prio=5 os_prio=31 tid=0x00007fd6d5008800 nid=0x2803 waiting on condition [0x000070000ffc1000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to wait for  &lt;0x000000076af3a938&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">at java.util.concurrent.ArrayBlockingQueue.put(ArrayBlockingQueue.java:353)</span><br><span class="line">at com.glmapper.bridge.boot.TestJstack.testWaitingOnConditionConditionWithParking(TestJstack.java:113)</span><br><span class="line">at com.glmapper.bridge.boot.TestJstack.main(TestJstack.java:13)</span><br></pre></td></tr></table></figure><p><strong>3、结果分析</strong></p><p>main 线程进入了 waiting on conditon 状态，等待某一个资源，可以看到是在 <code>a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObjec</code> 进行了等待，阻塞住了。</p><h3 id="waiting-on-monitor-entry"><a href="#waiting-on-monitor-entry" class="headerlink" title="waiting on monitor entry"></a>waiting on monitor entry</h3><p><strong>1、执行代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产生 waiting on monitor entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWaitingOnMonitorEntry</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 锁 obj 对象</span></span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">60000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 锁 obj 对象</span></span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">60000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread.setName(<span class="string">"test-thread"</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">    thread1.setName(<span class="string">"test-thread1"</span>);</span><br><span class="line">    thread1.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、执行结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;test-thread1&quot; #14 prio=5 os_prio=31 tid=0x00007f9563880800 nid=0x5c03 waiting for monitor entry [0x000070000b029000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at com.glmapper.bridge.boot.TestJstack$2.run(TestJstack.java:50)</span><br><span class="line">- waiting to lock &lt;0x000000076af261d0&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">&quot;test-thread&quot; #13 prio=5 os_prio=31 tid=0x00007f956387f800 nid=0x5a03 waiting on condition [0x000070000af26000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at com.glmapper.bridge.boot.TestJstack$1.run(TestJstack.java:38)</span><br><span class="line">- locked &lt;0x000000076af261d0&gt; (a java.lang.Object)</span><br></pre></td></tr></table></figure><p><strong>3、结果分析</strong></p><p>test-thread 获取到 obj 对象上的锁，因此正在执行 sleep 操作，状态为 TIMED_WAINTING, 而 test-thread1 由于未获取到 obj 对象上的锁，因此处于BLOCKED 状态。</p><blockquote><p>test-thread1 正在 “waiting to lock <0x000000076af261d0>“，试图在地址为 0x000000076af261d0 所在的对象获取锁，而该锁却被 test-thread 线程占有 [locked <0x000000076af261d0>]。test-thread 线程正在 “waiting on condition”，说明正在等待某个条件触发，由 jstack 来看，此线程正在sleep。</0x000000076af261d0></0x000000076af261d0></p></blockquote><h3 id="object-wait"><a href="#object-wait" class="headerlink" title="object.wait()"></a>object.wait()</h3><p><strong>1、执行代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testObjectWait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.setName(<span class="string">"test-object-wait"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (thread) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、执行结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;test-object-wait&quot; #13 prio=5 os_prio=31 tid=0x00007fd43a809000 nid=0xa803 in Object.wait() [0x0000700010926000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">- waiting on &lt;0x000000076af26140&gt; (a com.glmapper.bridge.boot.TestJstack$3)</span><br><span class="line">at java.lang.Object.wait(Object.java:502)</span><br><span class="line">at com.glmapper.bridge.boot.TestJstack$3.run(TestJstack.java:73)</span><br><span class="line">- locked &lt;0x000000076af26140&gt; (a com.glmapper.bridge.boot.TestJstack$3)</span><br><span class="line"></span><br><span class="line">&quot;main&quot; #1 prio=5 os_prio=31 tid=0x00007fd43b001800 nid=0x2603 waiting on condition [0x000070000f2e4000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at com.glmapper.bridge.boot.TestJstack.testObjectWait(TestJstack.java:93)</span><br><span class="line">- locked &lt;0x000000076af26140&gt; (a com.glmapper.bridge.boot.TestJstack$3)</span><br><span class="line">at com.glmapper.bridge.boot.TestJstack.main(TestJstack.java:10)</span><br></pre></td></tr></table></figure><p><strong>3、结果分析</strong></p><p>由于调用了 object.wait() 方法的时候放弃了锁，所以 <code>test-object-wait</code> 这个线程就出现了 Object.wait() 状态，线程的状态就是 waiting；等待 notify 来进行唤醒。由于 mian 线程在获得 <code>test-object-wait</code> 的线程锁后，调用了 Thread.sleep 方法，所以此时进入了 wating on condition 等待某一个资源，进入到 time_waiting 状态。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>一般情况我们在做问题排查时，如果系统非常慢，我们需要特别关注 <code>Blocked</code>，<code>Waiting on condition</code> 这些状态。如果系统的 cpu 负载比较高的话，则可以死循环等思路去摸查，此时要关注下 <code>Runable</code> 状态；那如果堆栈中有 <code>Deadlock</code>，那就是产生了死锁。</p><h1 id="jstat-JVM统计监测工具"><a href="#jstat-JVM统计监测工具" class="headerlink" title="jstat(JVM统计监测工具)"></a>jstat(JVM统计监测工具)</h1><p><code>jstat</code> 是 JVM 统计监测工具，其语法格式如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br></pre></td></tr></table></figure></p><p> <code>vmid</code> 是 <code>Java</code> 虚拟机 <code>ID</code>，在 <code>Linux/Unix</code> 系统上一般就是进程 <code>ID</code>。<code>interval</code> 是采样时间间隔; <code>count</code> 是采样数目。比如下面输出的是 <code>GC</code> 信息，采样时间间隔为 1000ms，采样数为 3：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ jstat -gc 58950 1000 3</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">10752.0 10752.0  0.0    0.0   65536.0   6554.0   175104.0     0.0     4480.0 785.7  384.0   75.9       0    0.000   0      0.000    0.000</span><br><span class="line">10752.0 10752.0  0.0    0.0   65536.0   6554.0   175104.0     0.0     4480.0 785.7  384.0   75.9       0    0.000   0      0.000    0.000</span><br><span class="line">10752.0 10752.0  0.0    0.0   65536.0   6554.0   175104.0     0.0     4480.0 785.7  384.0   75.9       0    0.000   0      0.000    0.000</span><br></pre></td></tr></table></figure></p><p> 输出信息的列释义：</p><ul><li>S0C、S1C、S0U、S1U：Survivor 0/1区容量（Capacity）和使用量（Used）</li><li>EC、EU：Eden区容量和使用量</li><li>OC、OU：年老代容量和使用量</li><li>PC、PU：永久代容量和使用量</li><li>YGC、YGT：年轻代 GC 次数和 GC 耗时</li><li>FGC、FGCT：Full GC 次数和 Full GC耗时</li><li>GCT：GC 总耗时</li></ul><h1 id="jmap-Memory-Map"><a href="#jmap-Memory-Map" class="headerlink" title="jmap(Memory Map)"></a>jmap(Memory Map)</h1><p><code>jmap</code> 用来查看堆内存使用状况，一般结合 <code>jhat</code> 使用。其使用语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] &lt;pid&gt;</span><br><span class="line">jmap [option] &lt;executable &lt;core&gt;</span><br><span class="line">jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br></pre></td></tr></table></figure><p><code>Options</code> 参数说明如下：</p><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left"><none></none></td><td style="text-align:left">打印与 <code>Solaris pmap</code> 相同的信息</td></tr><tr><td style="text-align:left">-heap</td><td style="text-align:left">打印 <code>java</code> 堆摘要</td></tr><tr><td style="text-align:left">-histo[:live]</td><td style="text-align:left">打印 java 对象堆的直方图;如果指定了“live”子选项，则只计算live对象</td></tr><tr><td style="text-align:left">-clstats</td><td style="text-align:left">打印 classloader 统计信息</td></tr><tr><td style="text-align:left">-finalizerinfo</td><td style="text-align:left">打印 等待终结 对象的信息</td></tr><tr><td style="text-align:left">–dump:<dump-options> :</dump-options></td><td style="text-align:left">以 hprof 二进制格式dump java heap</td></tr><tr><td style="text-align:left">-F</td><td style="text-align:left">使用 -dump:<dump-options> <pid> or -histo 强制执行</pid></dump-options></td></tr><tr><td style="text-align:left">-J<flag></flag></td><td style="text-align:left">将 <flag> 直接传递给运行时系统</flag></td></tr></tbody></table><p>dump-options 又包括以下几个选项：</p><ul><li>live ： 只 dump 活动对象;如果未指定，堆中的所有对象将被dump。</li><li>format=b ： 二进制格式</li><li>file=<file> ： dump 到指定文件</file></li></ul><h2 id="jmap-heap"><a href="#jmap-heap" class="headerlink" title="jmap -heap"></a><code>jmap -heap</code></h2><p>通过指定 <code>pid</code>，可以将当前进程的 <code>heap</code> 信息打印在 <code>console</code> 上，包括使用的 <code>GC</code> 算法、堆配置参数和各代中堆内存使用情况，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -heap 3493</span><br><span class="line">Attaching to process ID 3493, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.172-b245</span><br><span class="line"></span><br><span class="line">using parallel threads in the new generation.(eden 区使用的是并发线程)</span><br><span class="line">using thread-local object allocation.(使用线程本地对象分配)</span><br><span class="line">Concurrent Mark-Sweep GC (使用 CMS 垃圾收集器)</span><br><span class="line"># 堆配置信息</span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 40</span><br><span class="line">   MaxHeapFreeRatio         = 70</span><br><span class="line">   MaxHeapSize              = 2147483648 (2048.0MB)</span><br><span class="line">   NewSize                  = 805306368 (768.0MB)</span><br><span class="line">   MaxNewSize               = 805306368 (768.0MB)</span><br><span class="line">   OldSize                  = 1342177280 (1280.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line"># 堆使用情况</span><br><span class="line">Heap Usage:</span><br><span class="line">New Generation (Eden + 1 Survivor Space):</span><br><span class="line">   capacity = 724828160 (691.25MB)</span><br><span class="line">   used     = 35156456 (33.527809143066406MB)</span><br><span class="line">   free     = 689671704 (657.7221908569336MB)</span><br><span class="line">   4.850315970063856% used</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 644349952 (614.5MB)</span><br><span class="line">   used     = 19878008 (18.95714569091797MB)</span><br><span class="line">   free     = 624471944 (595.542854309082MB)</span><br><span class="line">   3.084970820328392% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 80478208 (76.75MB)</span><br><span class="line">   used     = 15278448 (14.570663452148438MB)</span><br><span class="line">   free     = 65199760 (62.17933654785156MB)</span><br><span class="line">   18.984577787815553% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 80478208 (76.75MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 80478208 (76.75MB)</span><br><span class="line">   0.0% used</span><br><span class="line">concurrent mark-sweep generation:</span><br><span class="line">   capacity = 1342177280 (1280.0MB)</span><br><span class="line">   used     = 166885296 (159.1542205810547MB)</span><br><span class="line">   free     = 1175291984 (1120.8457794189453MB)</span><br><span class="line">   12.433923482894897% used</span><br><span class="line"></span><br><span class="line">55843 interned Strings occupying 6689024 bytes.</span><br></pre></td></tr></table></figure><h2 id="jmap-clstats"><a href="#jmap-clstats" class="headerlink" title="jmap -clstats"></a>jmap -clstats</h2><p>通过指定 pid ，可以将当前进程的 classloader 统计信息打印在 console 上，包括类加载器名称、对象是否存活、对象地址、父类加载器、已加载的类大小等信息，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -clstats  3493</span><br><span class="line">Attaching to process ID 3493, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.172-b245</span><br><span class="line">finding class loader instances ..done.</span><br><span class="line">computing per loader stat ..done.</span><br><span class="line">please wait.. computing liveness.......................liveness analysis may be inaccurate ...</span><br><span class="line">class_loaderclassesbytesparent_loaderalive?type</span><br><span class="line"></span><br><span class="line">&lt;bootstrap&gt;32115818395  null  live&lt;internal&gt;</span><br><span class="line">0x00000000b150ed50114910x00000000b0020830deadsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class="line">0x00000000b87156701900    0x00000000b0020830deadsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class="line">0x00000000cb417140115030x00000000b0020830deadsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class="line">0x00000000b98b438811491  null  deadsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class="line">0x00000000b5a419a01900    0x00000000b0020830deadsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class="line">0x00000000b358df50114930x00000000b0020830deadsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class="line">0x00000000b7b277b8115030x00000000b0020830deadsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class="line">0x00000000c2527c58115050x00000000b0020830deadsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class="line">0x00000000b98b4580114910x00000000b0026260deadsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class="line">0x00000000b9b307b8114930x00000000b0020830deadsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class="line">0x00000000e236b0381900    0x00000000b0020830deadsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class="line">0x00000000b0108400114930x00000000b0020830deadsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class="line">0x00000000b010bc00379460x00000000b0022f60liveorg/jacoco/compass/agent/rt/internal/fastjson/util/ASMClassLoader@0x00000001000eb830</span><br><span class="line">0x00000000b358e148114930x00000000b0020830deadsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br></pre></td></tr></table></figure><h2 id="jmap-histo"><a href="#jmap-histo" class="headerlink" title="jmap -histo"></a>jmap -histo</h2><p>使用 jmap -histo pid 可以查看堆内存中的对象数目、大小统计直方图，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># jmap -histo:live 1493  带上 live 则只统计存活对象</span><br><span class="line">$ jmap -histo 1493  </span><br><span class="line">num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:       1314509      144436976  [C</span><br><span class="line">   2:       1572864       37748736  org.apache.logging.log4j.core.async.AsyncLoggerConfigDisruptor$Log4jEventWrapper</span><br><span class="line">   3:         77458       32776608  [B</span><br><span class="line">   4:       1061561       25477464  java.lang.String</span><br><span class="line">   5:        731623       23411936  java.util.HashMap$Node</span><br><span class="line">   6:         32930       22826616  [I</span><br><span class="line">   7:        150340       15546784  [Ljava.util.HashMap$Node;</span><br><span class="line">   8:        144895       14968208  [Ljava.lang.Object;</span><br><span class="line">   9:        377379       12076128  java.util.concurrent.ConcurrentHashMap$Node</span><br><span class="line">  10:        230943       11085264  java.util.HashMap</span><br><span class="line">  11:         81124        3893952  java.nio.HeapByteBuffer</span><br><span class="line">  12:          3396        3869944  [Ljava.util.concurrent.ConcurrentHashMap$Node;</span><br><span class="line">  13:         78418        3764064  java.nio.HeapCharBuffer</span><br><span class="line">  14:         75784        3031360  java.util.TreeMap$Entry</span><br><span class="line">  15:         72865        2914600  java.util.LinkedHashMap$Entry</span><br><span class="line">  16:        166213        2659408  java.util.HashSet</span><br><span class="line">  17:         18355        2643120  com.mysql.jdbc.Field</span><br><span class="line">  18:         18394        2044336  java.lang.Class</span><br><span class="line">  19:         19966        1757008  java.lang.reflect.Method</span><br></pre></td></tr></table></figure><blockquote><p>PS: 上图中的 [C [B 指的是 class 的对象类型，下面是常见类型的参考</p><ul><li>B  byte</li><li>C  char</li><li>D  double</li><li>F  float</li><li>I  int</li><li>J  long</li><li>Z  boolean</li><li>[  数组，如 [I 表示 int[]</li><li>[L+类名 其他对象，如 [Ljava.lang.Object</li></ul></blockquote><h2 id="jmap-dump"><a href="#jmap-dump" class="headerlink" title="jmap -dump"></a>jmap -dump</h2><p>绝大多数情况下，我们不会直接在 console 来打印分析，更常规的做法是 dump 到指定的文件，然后通过一些可视化工具来辅助分析；那执行 dump 到文件一般使用如下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=dumpFileName pid   # 语法</span><br><span class="line"></span><br><span class="line">$ jmap -dump:format=b,file=test-dump.bin 85716  # 举例</span><br><span class="line">Dumping heap to /Users/guolei.sgl/test-dump.bin ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure><p>对于 dump 下来的文件，可以通过 jprofile 等图形化工具来分析，如下</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/jprofile.jpg" alt=""></p><p>也可以通过 jhat 查看，操作方式如下：</p><p><strong>1、起 http 服务</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jhat -port 9300 test-dump.bin</span><br><span class="line">Reading from test-dump.bin...</span><br><span class="line">Dump file created Wed Oct 28 17:54:24 CST 2020</span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving 1151952 objects...</span><br><span class="line">Chasing references, expect 230 dots......................................................................................................................................................................................................................................</span><br><span class="line">Eliminating duplicate references......................................................................................................................................................................................................................................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 9300</span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure><p><strong>2、dump 类概要信息</strong></p><p>访问 localhost:9300 查看 dump 概要信息</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/jvm/jhat.jpg" alt=""></p><p><strong>3、class 详情</strong></p><p>点击某个类查看详细信息</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/jvm/jhat-details.jpg" alt=""></p><h1 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了一些 JDK 自带的一些性能调优监控工具，通过对这些工具的掌握，可以使的我们在实际的开发或者运维中能够快速的去定位和解决一些问题，常见的有 OOM、内存泄漏、线程死锁、CPU 负载高等等；目前社区也有很多好用的工具，例如 <a href="https://arthas.aliyun.com/doc/" target="_blank" rel="noopener">Arthas</a>，<a href="https://www.perfma.com/" target="_blank" rel="noopener">perfma</a> 等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇主要学习记录下工作中常用的 &lt;code&gt;JDK&lt;/code&gt; 自带的一些 &lt;code&gt;JVM&lt;/code&gt; 性能调优监控工具，通过了解这些工具，可以在排查问题时给予我们非常大的帮助，将一些隐藏在底下的东西拿到明面上来做分析。&lt;/p&gt;
&lt;h1 id=&quot;jps-Java-V
      
    
    </summary>
    
      <category term="java" scheme="http://www.glmapper.com/categories/java/"/>
    
    
      <category term="性能调优" scheme="http://www.glmapper.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>yum 指令</title>
    <link href="http://www.glmapper.com/2020/10/26/linux/linux-cmd-yum/"/>
    <id>http://www.glmapper.com/2020/10/26/linux/linux-cmd-yum/</id>
    <published>2020-10-26T01:57:28.000Z</published>
    <updated>2021-07-18T03:55:58.459Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://yum.baseurl.org/" target="_blank" rel="noopener">yum(Yellowdog Updater Modified)</a>：是一个基于 RPM 的软件包管理器，能够从指定服务器自动下载RPM包并且安装，可以处理软件之间的依赖关系，一次性安装所有依赖的软件包，无需一个个下载安装。</p></blockquote><h2 id="工作原理示意图"><a href="#工作原理示意图" class="headerlink" title="工作原理示意图"></a>工作原理示意图</h2><p><code>yum</code> 客户端及服务器的工作原理如下图所示</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/linux/yum.jpg" alt=""></p><h2 id="yum-的配置文件"><a href="#yum-的配置文件" class="headerlink" title="yum 的配置文件"></a>yum 的配置文件</h2><p>配置文件所在目录：<code>/etc/yum.repos.d</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/yum.repos.d/alios.repo</span><br><span class="line">----------------------------------------</span><br><span class="line">[alios.7u2.base.$basearch]</span><br><span class="line">name=alios</span><br><span class="line">baseurl=http://yum.tbsite.net/alios/7u2/os/$basearch/  # $basearch：系统基础架构，如 x86_64</span><br><span class="line">gpgcheck=0</span><br><span class="line">----------------------------------------</span><br></pre></td></tr></table></figure></p><p><code>x.repo</code> 文件相关配置 <code>key</code> 简介：</p><blockquote><ul><li>1、[alios.7u2.base.$basearch]: 仓库的ID，可以取任意名字，只要不和其他的ID冲突即可</li><li>2、name=xxx: 用于描述容器含义</li><li>3、enabled={1|0}: 是否启用这个仓库，0表示不启用，1表示启用，默认是启用的</li><li>4、mirrorlist: 列出这个容器可以使用的镜像站点（如果不想使用，可以注释，本案例中没有体现）</li><li>5、baseurl=url: 容器地址，mirrorlist 是由 yum 程序自行找镜像站点，baseurl 则是指定一个固定容器地址</li><li>6、gpgcheck={1|0}: 是否进行签名合法性检测，0 表示不启用，1表示启用，如果选择启用 gpg 检查，则需要告知其 key 是什么</li><li>7、gpgkey=url: 如果启用 gpg 检测，则需要指定 gpgkey 的路径，即使导入过 gpgkey，这里仍然需要手动为其指定路径，这个路径可以是远程服务器上的，也可以是本地的，只要让本地客户端访问到即可</li></ul></blockquote><p>如果两个仓库里的 RPM 包是一样的，一个在远程服务器上，另一个在本地光盘上，那么本地光盘的访问速度通常会快于远程服务器上。在配置文件中，我们可以定义这样的两个仓库，为其中一个设定优先级</p><blockquote><p>注: gpgme.GpgmeError: (7, 32870, u’\ufffd\ufffd\ufffd\u8c78\ufffd\ufffd\ufffd\u02b5\ufffd\ufffd\ufffd ioctl \ufffd\ufffd\ufffd\ufffd’)   #如果执行报这个错，表示当前系统字符编码不支持 Unicode，改一下就好**</p></blockquote><h2 id="配置-yum-数据源"><a href="#配置-yum-数据源" class="headerlink" title="配置 yum 数据源"></a>配置 yum 数据源</h2><p>默认情况下 <code>yum</code> 使用的源都是国外的地址，那我们如果期望下载速度更快一些时，就可以考虑使用国内的一些源，比如 <code>aliyun</code> 提供的, 以配置 <code>docker</code> <code>yum</code> 数据源为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">已加载插件：bestyumcache, fastestmirror, langpacks</span><br><span class="line">adding repo from: http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">grabbing file http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo to /etc/yum.repos.d/docker-ce.repo</span><br><span class="line">repo saved to /etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></table></figure><p>然后就可以在 <code>/etc/yum.repos.d/</code> 下看到 <code>docker-ce.repo</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cat docker-ce.repo</span><br><span class="line">[docker-ce-stable]</span><br><span class="line">name=Docker CE Stable - $basearch</span><br><span class="line">baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/7/$basearch/stable</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg</span><br><span class="line"></span><br><span class="line">[docker-ce-stable-debuginfo]</span><br><span class="line">name=Docker CE Stable - Debuginfo $basearch</span><br><span class="line">baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/7/debug-$basearch/stable</span><br><span class="line">enabled=0</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg</span><br><span class="line"></span><br><span class="line">[docker-ce-stable-source]</span><br><span class="line">name=Docker CE Stable - Sources</span><br><span class="line">baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/7/source/stable</span><br><span class="line">enabled=0</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg</span><br><span class="line"></span><br><span class="line"># ...省略其他</span><br></pre></td></tr></table></figure><h2 id="yum-的一些基本功能"><a href="#yum-的一些基本功能" class="headerlink" title="yum 的一些基本功能"></a>yum 的一些基本功能</h2><p>yum 基本功能主要包括：查询、删除、更新/升级以及软件组等</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>yum 查询有以下几种姿势，这里挨个举例。</p><h4 id="yum-search-xxx"><a href="#yum-search-xxx" class="headerlink" title="yum search xxx"></a>yum search xxx</h4><p>搜索某个软件名称或者描述的重要关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ yum search java</span><br><span class="line">已加载插件：bestyumcache, branch, fastestmirror, langpacks</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">kubernetes                                                                                                                                                                  579/579</span><br><span class="line">================================================================================ N/S matched: java =================================================================================</span><br><span class="line">abrt-java-connector.x86_64 : JNI Agent library converting Java exceptions to ABRT problems</span><br><span class="line">aether-javadoc.noarch : Java API documentation for Aether</span><br><span class="line">alicpp-gcc492-netlib-java.x86_64 : alicpp-gcc492-netlib-java-1.1.2.odps</span><br><span class="line">ant-antunit-javadoc.noarch : Javadoc for ant-antunit</span><br><span class="line">ant-contrib-javadoc.noarch : Javadoc for ant-contrib</span><br><span class="line">ant-javadoc.noarch : Javadoc for ant</span><br></pre></td></tr></table></figure><h4 id="yum-info-xxx"><a href="#yum-info-xxx" class="headerlink" title="yum info xxx"></a>yum info xxx</h4><p>列出软件功能（不太方便透露的信息，以 xxxx 代替了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ yum info docker</span><br><span class="line">已加载插件：bestyumcache, branch, fastestmirror, langpacks</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">可安装的软件包</span><br><span class="line">名称    ：docker</span><br><span class="line">架构    ：x86_64</span><br><span class="line">版本    ：xxxx</span><br><span class="line">发布    ：xxxx  </span><br><span class="line">大小    ：103 M</span><br><span class="line">源      ：xxxx</span><br><span class="line">简介    ：xxxx</span><br><span class="line">网址    ：xxxx</span><br><span class="line">协议    ： Commercial</span><br><span class="line">描述    ： CodeUrl:git@xxxx</span><br><span class="line">         : CodeRev:e3xx79d</span><br><span class="line">         : AoneLog: xxxx</span><br><span class="line">         : AoneUrl:xxxx</span><br><span class="line">         : xxx container service docker-xxx; branch: vxxx</span><br></pre></td></tr></table></figure><h4 id="yum-list"><a href="#yum-list" class="headerlink" title="yum list"></a>yum list</h4><p>列出 yum 服务器上面所有的软件名称，这里就不列了（下面一个是按规则搜的）</p><h4 id="yum-list-xxxx"><a href="#yum-list-xxxx" class="headerlink" title="yum list xxxx*"></a>yum list xxxx*</h4><p>找出以 xxx 开头的软件名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ yum list docker</span><br><span class="line">已加载插件：bestyumcache, branch, fastestmirror, langpacks</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">可安装的软件包</span><br><span class="line">docker.x86_64    version-xxx   xxxx</span><br></pre></td></tr></table></figure><h4 id="yum-list-updates"><a href="#yum-list-updates" class="headerlink" title="yum list updates"></a>yum list updates</h4><p>列出 yum 服务器上可提供本机进行升级的软件（返回的信息是 yum list 的子集，这里也不举例了）</p><h3 id="安装-or-升级"><a href="#安装-or-升级" class="headerlink" title="安装 or 升级"></a>安装 or 升级</h3><ul><li>yum install/update 软件名称 </li><li>yum install 软件名称 -y         #安装过程中免输入y确认</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li>yum remove 软件名称</li></ul><h3 id="软件组"><a href="#软件组" class="headerlink" title="软件组"></a>软件组</h3><ul><li>yum grouplist                         //查看容器和本机上可用与安装过的软件组</li><li>yum groupinfo group_name             //查看group内所有组名称</li><li>yum install/remove group_name        //安装与删除</li></ul><p>除此之外，如果我们想升级所有的软件包，可以通过如下方式搞定</p><ul><li>yum -y update  升级所有包，改变软件设置和系统设置,系统版本内核都升级</li><li>yum -y upgrade 升级所有包，不改变软件设置和系统设置，系统版本升级，内核不改变</li></ul><blockquote><p>已经上线的用yum -y upgrade 比较稳，全新的用yum -y update 会更好</p></blockquote><p>editing….</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://yum.baseurl.org/" target="_blank" rel="noopener">http://yum.baseurl.org/</a></li><li><a href="https://blog.csdn.net/guohaosun/article/details/81481848" target="_blank" rel="noopener">https://blog.csdn.net/guohaosun/article/details/81481848</a></li><li><a href="https://blog.51cto.com/wuyelan/1546674" target="_blank" rel="noopener">https://blog.51cto.com/wuyelan/1546674</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://yum.baseurl.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;yum(Yellowdog Updater Modified)&lt;/a&gt;：是一个基于 RPM 的软件包管理器，能够从指定
      
    
    </summary>
    
      <category term="linux" scheme="http://www.glmapper.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.glmapper.com/tags/linux/"/>
    
      <category term="yum" scheme="http://www.glmapper.com/tags/yum/"/>
    
  </entry>
  
  <entry>
    <title>摄影-2</title>
    <link href="http://www.glmapper.com/2020/10/26/photograph/photograph-serise-two/"/>
    <id>http://www.glmapper.com/2020/10/26/photograph/photograph-serise-two/</id>
    <published>2020-10-26T01:46:26.000Z</published>
    <updated>2020-10-26T01:52:23.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、西湖-鸳鸯"><a href="#1、西湖-鸳鸯" class="headerlink" title="1、西湖-鸳鸯"></a>1、西湖-鸳鸯</h4><p><img src="https://glphotographs.oss-cn-hangzhou.aliyuncs.com/photograph/westlaker/826190380.jpg" alt=""></p><h4 id="2、西湖-杭菊"><a href="#2、西湖-杭菊" class="headerlink" title="2、西湖-杭菊"></a>2、西湖-杭菊</h4><p><img src="https://glphotographs.oss-cn-hangzhou.aliyuncs.com/photograph/westlaker/2037567531.jpg" alt=""></p><h4 id="3、西湖-板"><a href="#3、西湖-板" class="headerlink" title="3、西湖-板"></a>3、西湖-板</h4><p><img src="https://glphotographs.oss-cn-hangzhou.aliyuncs.com/photograph/westlaker/367453549.jpg" alt=""></p><h4 id="4、西湖-桥"><a href="#4、西湖-桥" class="headerlink" title="4、西湖-桥"></a>4、西湖-桥</h4><p><img src="https://glphotographs.oss-cn-hangzhou.aliyuncs.com/photograph/westlaker/369450504.jpg" alt=""></p><h4 id="5、西湖-湖中木板桥"><a href="#5、西湖-湖中木板桥" class="headerlink" title="5、西湖-湖中木板桥"></a>5、西湖-湖中木板桥</h4><p><img src="https://glphotographs.oss-cn-hangzhou.aliyuncs.com/photograph/westlaker/611824934.jpg" alt=""></p><h4 id="6、西湖-湖面夕阳"><a href="#6、西湖-湖面夕阳" class="headerlink" title="6、西湖-湖面夕阳"></a>6、西湖-湖面夕阳</h4><p><img src="https://glphotographs.oss-cn-hangzhou.aliyuncs.com/photograph/westlaker/1480602463.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、西湖-鸳鸯&quot;&gt;&lt;a href=&quot;#1、西湖-鸳鸯&quot; class=&quot;headerlink&quot; title=&quot;1、西湖-鸳鸯&quot;&gt;&lt;/a&gt;1、西湖-鸳鸯&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://glphotographs.oss-cn-hangzhou.al
      
    
    </summary>
    
      <category term="算法" scheme="http://www.glmapper.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="西湖" scheme="http://www.glmapper.com/tags/%E8%A5%BF%E6%B9%96/"/>
    
  </entry>
  
  <entry>
    <title>摄影-1</title>
    <link href="http://www.glmapper.com/2020/10/24/photograph/photograph-serise-one/"/>
    <id>http://www.glmapper.com/2020/10/24/photograph/photograph-serise-one/</id>
    <published>2020-10-24T09:31:16.000Z</published>
    <updated>2020-10-26T01:48:05.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、龙井-茶花"><a href="#1、龙井-茶花" class="headerlink" title="1、龙井-茶花"></a>1、龙井-茶花</h4><p><img src="https://glphotographs.oss-cn-hangzhou.aliyuncs.com/photograph/1038777523.jpg" alt=""></p><h4 id="2、南湖-船"><a href="#2、南湖-船" class="headerlink" title="2、南湖-船"></a>2、南湖-船</h4><p><img src="https://glphotographs.oss-cn-hangzhou.aliyuncs.com/photograph/1452756436.jpg" alt=""></p><h4 id="3、杭州-楼角"><a href="#3、杭州-楼角" class="headerlink" title="3、杭州-楼角"></a>3、杭州-楼角</h4><p><img src="https://glphotographs.oss-cn-hangzhou.aliyuncs.com/photograph/297383538.jpg" alt=""></p><h4 id="4、蚂蚁-功夫公仔"><a href="#4、蚂蚁-功夫公仔" class="headerlink" title="4、蚂蚁-功夫公仔"></a>4、蚂蚁-功夫公仔</h4><p><img src="https://glphotographs.oss-cn-hangzhou.aliyuncs.com/photograph/309316863.jpg" alt=""></p><h4 id="5、呼伦贝尔-呼伦湖边的小湖"><a href="#5、呼伦贝尔-呼伦湖边的小湖" class="headerlink" title="5、呼伦贝尔-呼伦湖边的小湖"></a>5、呼伦贝尔-呼伦湖边的小湖</h4><p><img src="https://glphotographs.oss-cn-hangzhou.aliyuncs.com/photograph/445953615.jpg" alt=""></p><h4 id="6、杭州-夕阳"><a href="#6、杭州-夕阳" class="headerlink" title="6、杭州-夕阳"></a>6、杭州-夕阳</h4><p><img src="https://glphotographs.oss-cn-hangzhou.aliyuncs.com/photograph/809702355.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、龙井-茶花&quot;&gt;&lt;a href=&quot;#1、龙井-茶花&quot; class=&quot;headerlink&quot; title=&quot;1、龙井-茶花&quot;&gt;&lt;/a&gt;1、龙井-茶花&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://glphotographs.oss-cn-hangzhou.al
      
    
    </summary>
    
      <category term="算法" scheme="http://www.glmapper.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="草原" scheme="http://www.glmapper.com/tags/%E8%8D%89%E5%8E%9F/"/>
    
      <category term="夕阳" scheme="http://www.glmapper.com/tags/%E5%A4%95%E9%98%B3/"/>
    
  </entry>
  
  <entry>
    <title>Linux Top 命令指南</title>
    <link href="http://www.glmapper.com/2020/08/10/linux/linux-cmd-top/"/>
    <id>http://www.glmapper.com/2020/08/10/linux/linux-cmd-top/</id>
    <published>2020-08-10T08:55:06.000Z</published>
    <updated>2021-07-18T03:55:19.731Z</updated>
    
    <content type="html"><![CDATA[<p><code>top</code> 命令允许用户监视 Linux 上的进程和系统资源使用情况，它是系统管理员工具箱中最有用的工具之一，并且在每个发行版中都预装了它。与 <code>ps</code> 等其他命令不同，它是交互式的，我们可以浏览进程列表、终止进程，等等。本文中，我们将了解如何使用 <code>top</code> 命令。</p><h2 id="Getting-started"><a href="#Getting-started" class="headerlink" title="Getting started"></a>Getting started</h2><p><code>top</code> 命令非常简单，只需要在终端中输入 <code>top</code> 即可。<code>top</code> 指令将启动一个交互式命令行应用程序，如下所示，输出的上半部分包含有关进程和资源使用情况的统计信息，下半部分包含当前运行的进程的列表。可以使用箭头键和页面向上/向下键浏览列表。如果你想退出，只需按<code>q</code>键。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ top</span><br><span class="line">top - 21:07:28 up 21 days,  4:31,  1 user,  load average: 0.12, 0.06, 0.07</span><br><span class="line">Tasks:  33 total,   1 running,  31 sleeping,   0 stopped,   1 zombie</span><br><span class="line">%Cpu(s):  0.2 us,  0.5 sy,  0.0 ni, 89.7 id,  0.0 wa,  0.0 hi,  0.0 si,  9.6 st</span><br><span class="line">KiB Mem : 33554432 total, 31188884 free,   513100 used,  1852448 buff/cache</span><br><span class="line">KiB Swap:  2097148 total,  2097148 free,        0 used. 31188884 avail Mem</span><br><span class="line"></span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 52601 root      39  19 1310268  14900   9836 S   0.3  0.0  22:59.21 logagent-collec</span><br><span class="line">     1 root      20   0   45416   5244   3968 S   0.0  0.0   5:35.71 systemd</span><br><span class="line">   340 root      20   0   64700  21336  17684 S   0.0  0.1   8:33.90 systemd-journal</span><br><span class="line">   357 root      20   0  101836   2768   2312 S   0.0  0.0   0:01.13 gssproxy</span><br><span class="line">   384 dbus      20   0   28632   2800   2464 S   0.0  0.0   0:00.04 dbus-daemon</span><br><span class="line">   432 root      20   0   84760   5852   4984 S   0.0  0.0   0:00.01 sshd</span><br><span class="line">   461 agent     20   0   52376   5200   3684 S   0.0  0.0   0:00.01 ilogtail</span><br><span class="line">  1690 agent     20   0 2193388 246304  11264 S   0.0  0.7  23:45.88 java</span><br><span class="line">  2527 admin     20   0  161744   4268   3704 R   0.0  0.0   0:00.72 top</span><br><span class="line">  3245 root      20   0  559140  12412   5860 S   0.0  0.0  64:48.67 logagent</span><br><span class="line">  3420 root      20   0  745052  58464  43820 S   0.0  0.2  11:16.32 metricbeat</span><br><span class="line">  3447 root      20   0  957796  55548  43708 S   0.0  0.2  10:14.47 metricbeat</span><br><span class="line">  5093 root      20   0 1905356 159280   9584 S   0.0  0.5  35:00.14 java</span><br><span class="line">  7458 root      20   0   13700   2564   2356 S   0.0  0.0   0:00.00 bash</span><br><span class="line">  7464 root      20   0   86268   4436   3740 S   0.0  0.0   0:00.00 sudo</span><br><span class="line">  # ... 省略其他</span><br></pre></td></tr></table></figure></p><p><code>top</code> 有许多变体，但在本文的其余部分中，我们将讨论最常见的变体 — <code>props -ng</code>包附带的变体，下面来运行验证体验下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ top -v</span><br><span class="line">  procps-ng version 3.3.10</span><br><span class="line">Usage:</span><br><span class="line">  top -hv | -bcHiOSs -d secs -n max -u|U user -p pid(s) -o field -w [cols]</span><br></pre></td></tr></table></figure><p>在 <code>top</code> 的界面中发生了相当多的事情，我们将在下一节中对其逐一进行分析。</p><h2 id="了解-top-的界面-the-summary-area"><a href="#了解-top-的界面-the-summary-area" class="headerlink" title="了解 top 的界面 - the summary area"></a>了解 top 的界面 - the summary area</h2><p>第一小节中 <code>top</code> 的输出界面，我们可以比较明显的看到被分成了两个部分，这个小节中我们将关注在上半部分信息，这部分一般被称之为：<code>summary area</code></p><h3 id="系统时间、正常运行时间和用户会话"><a href="#系统时间、正常运行时间和用户会话" class="headerlink" title="系统时间、正常运行时间和用户会话"></a>系统时间、正常运行时间和用户会话</h3><ul><li>系统时间：当前系统的时间(<code>21:07:28</code>)</li><li>正常运行：系统运行时长(<code>21 days,  4:31</code>)</li><li>活动用户会话个数：1 个</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top - 21:07:28 up 21 days,  4:31,  1 user,</span><br></pre></td></tr></table></figure><p>活动用户会话包括 <a href="https://en.wikipedia.org/wiki/Computer_terminal#Text_terminals" target="_blank" rel="noopener">TTY</a> 和 <a href="https://en.wikipedia.org/wiki/Pseudoterminal" target="_blank" rel="noopener">PTY</a> 两种。实际上，如果您通过桌面环境登录到 <code>Linux</code> 系统，然后启动终端模拟器，您将发现将有两个活动会话。</p><blockquote><p>TTY: 通过命令行或桌面环境在系统上物理地运行<br>PTY: 终端模拟器窗口或通过 SSH</p></blockquote><p>如果我们期望得到更多关于活动用户会话的信息，可以通过 <code>who</code> 命令来得到，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ who</span><br><span class="line">admin    pts/0        2020-10-31 17:15 (xx.xx.xx.xx)</span><br></pre></td></tr></table></figure><h3 id="内存使用情况"><a href="#内存使用情况" class="headerlink" title="内存使用情况"></a>内存使用情况</h3><p><code>Memory</code> 部分显示的是关于系统内存使用情况的信息，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KiB Mem : 33554432 total, 31188208 free,   513488 used,  1852736 buff/cache</span><br><span class="line">KiB Swap:  2097148 total,  2097148 free,        0 used. 31188208 avail Mem</span><br></pre></td></tr></table></figure><p><code>Mem</code> 和 <code>Swap</code> 分别显示的是 <code>RAM</code> 和 <code>swap</code> 空间信息；当 <code>RAM</code> 使用率接近满时，<code>RAM</code> 中不经常使用的区域将被写入 <code>Swap</code> 空间，以便稍后需要时检索。但是，由于访问磁盘的速度很慢，过分依赖 <code>Swap</code> 可能会损害系统性能。</p><blockquote><p><strong>关于 Swap</strong></p><ul><li><p>物理内存就是计算机的实际内存大小，由<code>RAM</code>芯片组成的。虚拟内存则是虚拟出来的、使用磁盘代替内存。虚拟内存的出现，让机器内存不够的情况得到部分解决。当程序运行起来由操作系统做具体虚拟内存到物理内存的替换和加载(相应的页与段的虚拟内存管理)。这里的虚拟内存即所谓的 swap;</p></li><li><p>当用户提交程序，然后产生进程，在机器上运行。机器会判断当前物理内存是否还有空闲允许进程调入内存运行，如果有那么则直接调入内存进行运行；如果没有，那么会根据优先级选择一个进程挂起，把该进程交换到swap中等待，然后把新的进程调入到内存中运行。根据这种换入和换出，实现了内存的循环利用，让用户感觉不到内存的限制。从这也可以看出swap扮演了一个非常重要的角色，就是暂存被换出的进程。</p></li><li><p>内存与swap之间是按照内存页为单位来交换数据的，一般Linux中页的大小设置为4kb。而内存与磁盘则是按照块来交换数据的</p></li></ul></blockquote><p><code>total</code>、<code>free</code>、<code>used</code> 就是这些单词含义所描述的一样，分别是当前对应空间的总大小、空闲大小、已使用大小。<code>avail mem</code> 值指的是可以分配给进程而不会导致更多的交换的内存量。</p><p>Linux 内核层面上总是以不同的方式来尝试减少访问磁盘的次数；它在<code>RAM</code>中维护一个“磁盘缓存（disk cache）”，存储磁盘中经常使用的区域，另外，磁盘写被存储到一个“磁盘缓冲区（disk buffer）”，内核最终将它们写到磁盘上。它们消耗的总内存是 <code>buff/cache</code> 值。这看起来像是一件坏事，但实际上不是，原因是缓存使用的内存将在需要时分配给进程。</p><h3 id="任务-Tasks"><a href="#任务-Tasks" class="headerlink" title="任务-Tasks"></a>任务-Tasks</h3><p><code>Tasks</code> 部分显示的是有关系统上运行的进程的统计信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tasks:  33 total,   1 running,  31 sleeping,   0 stopped,   1 zombie</span><br></pre></td></tr></table></figure><p><code>total</code> 比较好理解，它表示的就是当前系统正在运行的进程总数。但是对于其他几个状态相关的数字，我们需要了解一点 <code>Linux</code> 内核如何处理进程的背景知识。</p><p><strong>进程执行是 I/O 限制的工作(如读取磁盘)和 cpu 限制的工作(如执行算术操作)的混合模式。当一个进程执行 I/O 时，CPU 是空闲的，所以 os 在这段时间切换到执行其他进程。此外，该操作系统允许一个给定的进程执行非常短的时间，然后它切换到另一个进程。这就是操作系统“多任务处理”的表现。做所有这些需要我们跟踪流程的“状态”。在 Linux 中，进程可能处于以下状态:</strong></p><blockquote><ul><li>1、Runnable (R): 处于这种状态的进程要么在 CPU 上执行，要么存在于运行队列中，准备执行。</li><li>2、Interruptible sleep(S): 处于这种状态的进程在等待事件完成。</li><li>3、Uninterruptible sleep (D): 在这种情况下，一个进程正在等待一个 I/O 操作完成。</li><li>4、Stopped (T): 这些进程已经被一个作业控制信号(如按 Ctrl+Z)停止，或者因为它们正在被跟踪。</li><li>5、Zombie (Z): 僵尸进程</li></ul></blockquote><p>一个进程可以创建许多子进程，当父进程仍然存在时，这些子进程是可以退出的，但是，这些数据结构必须保留下来，直到父进程获得子进程的状态。这种数据结构仍然存在的终止进程称为僵尸进程。D 和 S 状态都是在 <code>top</code> 信息中体现为 <code>sleeping</code>，T 状态体现为 <code>stopped</code>，<code>Z</code> 状态体现为 <code>zombie</code>。</p><h3 id="CPU-使用情况"><a href="#CPU-使用情况" class="headerlink" title="CPU 使用情况"></a>CPU 使用情况</h3><p>CPU 使用情况，显示了在各种任务上花费的 CPU 时间的百分比。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%Cpu(s):  0.3 us,  0.4 sy,  0.0 ni, 90.3 id,  0.0 wa,  0.0 hi,  0.0 si,  9.0 st</span><br></pre></td></tr></table></figure><p><code>us</code>指的是 CPU 在用户空间中执行进程所花费的时间。类似地，<code>sy</code>指的就是运行内核空间进程所花费的时间。Linux 中使用 <code>nice</code> 值来表示进程的优先级，值越高，优先级越低，后面我们会了解到，默认的 <code>nice</code> 值是可以被修改的。在手动设置 <code>nice</code> 的情况下，执行进程所花费的时间显示为 <code>ni</code> 值。<code>ni</code> 后面是 <code>id</code>，它是CPU 保持空闲的时间，大多数操作系统在 CPU 空闲时将其设置为“省电模式”。接下来是 <code>wa</code>值，它是 CPU 等待 I/O 完成所花费的时间。</p><p>中断(Interrupt)是向处理器发出的有关需要立即关注的事件的信号；外设通常使用硬件中断来告知系统有关事件的信息，例如键盘上的按键。另一方面，软件中断是由于处理器上执行的特定指令而产生的。在这两种情况下，操作系统都将处理它们，处理硬件中断和软件中断所花费的时间分别由<code>hi</code>和<code>si</code>给出。</p><p>在虚拟化环境中，会将一部分 CPU 资源分配给每个虚拟机（VM）。操作系统会检测到何时有工作要做，如果检测到他需要执行但是由于 CPU 在其他 VM 上繁忙而无法执行时，以这种方式浪费的时间就是“窃取”时间，显示为<code>st</code>。</p><h3 id="平均负载-Load-average"><a href="#平均负载-Load-average" class="headerlink" title="平均负载-Load average"></a>平均负载-Load average</h3><p><code>load average</code> 部分表示的是在最近 1、5 和 15 分钟内的系统平均“负载”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load average: 0.11, 0.07, 0.07</span><br></pre></td></tr></table></figure><p><strong>负载</strong>是对系统执行的计算工作量的度量。在Linux上，负载是在任何给定时刻处于 <code>R</code> 和 <code>D</code> 状态的进程数。<strong>load average</strong>值为您提供了必须等待多长时间才能完成任务的相对度量。这里有几个小例子，我们来直观的理解下这两个概念。</p><ul><li>1、在单核心系统上，<code>load average</code> 为 0.4 意味着系统只完成了它能完成的 40% 的工作。<code>load average</code>为 1 意味着系统正好处于满负荷状态——即使添加一点点额外的工作，系统也会过载。一个 <code>load average</code> 为 2.12 的系统意味着它超载了 112% 的工作，超出了它的处理能力。</li><li>2、在多核系统上，应该首先用 <code>load average</code> 除以 CPU 核数，以得到类似的度量。</li></ul><p>此外，<code>load average</code> 实际上并不是我们大多数人所知道的典型的<strong>平均负载</strong>。它是一个“指数移动平均”，这意味着以前的 <code>load average</code> 的一小部分被考虑到当前的值（关于这个点，可以通过<a href="https://www.linuxjournal.com/article/9001" target="_blank" rel="noopener">这篇文章</a>来了解更多技术细节）。</p><h2 id="了解-top-的界面-the-task-area"><a href="#了解-top-的界面-the-task-area" class="headerlink" title="了解 top 的界面 - the task area"></a>了解 top 的界面 - the task area</h2><p><code>summury area</code> 相对简单，通过它我们可以快速了解到当前系统运行的一些摘要统计信息。但是一个细节性的信息，我们只能通过 <code>task area</code> 中来得到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 52601 root      39  19 1310268  14900   9836 S   0.3  0.0  22:59.21 logagent-collec</span><br><span class="line">     1 root      20   0   45416   5244   3968 S   0.0  0.0   5:35.71 systemd</span><br><span class="line">   340 root      20   0   64700  21336  17684 S   0.0  0.1   8:33.90 systemd-journal</span><br><span class="line">   357 root      20   0  101836   2768   2312 S   0.0  0.0   0:01.13 gssproxy</span><br><span class="line">   384 dbus      20   0   28632   2800   2464 S   0.0  0.0   0:00.04 dbus-daemon</span><br><span class="line">   432 root      20   0   84760   5852   4984 S   0.0  0.0   0:00.01 sshd</span><br><span class="line">   461 agent     20   0   52376   5200   3684 S   0.0  0.0   0:00.01 ilogtail</span><br><span class="line">  1690 agent     20   0 2193388 246304  11264 S   0.0  0.7  23:45.88 java</span><br><span class="line">  2527 admin     20   0  161744   4268   3704 R   0.0  0.0   0:00.72 top</span><br><span class="line">  3245 root      20   0  559140  12412   5860 S   0.0  0.0  64:48.67 logagent</span><br><span class="line">  3420 root      20   0  745052  58464  43820 S   0.0  0.2  11:16.32 metricbeat</span><br><span class="line">  3447 root      20   0  957796  55548  43708 S   0.0  0.2  10:14.47 metricbeat</span><br><span class="line">  5093 root      20   0 1905356 159280   9584 S   0.0  0.5  35:00.14 java</span><br><span class="line">  7458 root      20   0   13700   2564   2356 S   0.0  0.0   0:00.00 bash</span><br><span class="line">  7464 root      20   0   86268   4436   3740 S   0.0  0.0   0:00.00 sudo</span><br></pre></td></tr></table></figure><p>先来说明下各个列的含义：</p><p><strong>PID</strong></p><p>这是进程ID，一个惟一的正整数，用于标识进程。</p><p><strong>USER</strong></p><p>这是启动进程的用户的“有效”用户名(映射到用户ID)。Linux 为进程分配一个真实的用户 ID 和一个有效的用户ID；后者允许进程代表另一个用户进行操作。(例如，非 root 用户可以提升到 root 用户来安装软件)</p><p><strong>PR NI</strong><br>“NI” 字段显示进程的 “nice” 值，“PR” 字段是从内核的角度显示了进程的调度优先级，“nice” 值影响的是进程的优先级。</p><p><strong>VIRT, RES, SHR and %MEM</strong></p><p><code>VIRT</code>、<code>RES</code>、<code>SHR</code> 这三个字段都与进程的内存消耗有关。<code>VIRT</code>是一个进程所消耗的内存总量。这包括程序代码、进程在内存中存储的数据，以及已经 <code>swap</code> 到磁盘的任何内存区域。<code>RES</code>是进程在 RAM 中消耗的内存，<code>%MEM</code> 表示这个值占总可用 RAM 的百分比。最后，<code>SHR</code> 是与其他进程共享的内存量。</p><p><strong>S</strong><br>表示进程状态</p><p><strong>TIME+</strong></p><p><code>TIME+</code> 列表示的是进程自启动以来所使用的总 CPU 时间，精确到百分之一秒。</p><p><strong>COMMAND</strong></p><p><code>COMMAND</code> 列表示的是当前进程的名称。</p><h2 id="top-命令的使用示例"><a href="#top-命令的使用示例" class="headerlink" title="top 命令的使用示例"></a>top 命令的使用示例</h2><p>到目前为止，我们已经讨论了 <code>top</code> 的界面信息所描述的含义。但是，<code>top</code> 除了显示这个信息之外，它还可以管理进程，并且我们可以控制 <code>top</code> 输出的各个方面。在本节中，我们将举几个例子。（在下面的大多数例子中，你必须在 <code>top</code> 运行时按下一个键。这些按键是区分大小写的，所以如果你在大写锁定状态下按了<code>k</code>，你实际上已经按了一个<code>k</code>，但是这个命令并不会工作）</p><h3 id="kill-进程"><a href="#kill-进程" class="headerlink" title="kill 进程"></a>kill 进程</h3><p>如果你想杀死一个进程，只要在<code>top</code>运行时按<code>k</code>。这将出现一个提示，它将询问进程的进程ID并按<code>enter</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PID to signal/kill [default pid = 384]</span><br></pre></td></tr></table></figure><p>当然上面的这段输出的后面是可以手动输入进程 ID，下面的 34444444444444 就是手动输入的进程ID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PID to signal/kill [default pid = 384] 34444444444444</span><br></pre></td></tr></table></figure><p>如果保留此空白，<code>top</code> 将使用一个<code>SIGTERM</code>，它允许进程优雅地终止。如果您想强制终止进程，您可以在这里输入<code>SIGKILL</code>。你也可以在这里输入信号号，例如，<code>SIGTERM</code> 的数字是 <code>384</code>，而 <code>SIGKILL</code> 的数字是<code>。如果你将进程ID留空并直接按</code>enter`，它将终止列表中最顶端的进程。正如前面提到的，我们也可以使用箭头键滚动，并通过这种方式更改想要终止的进程。</p><h3 id="排序进程列表"><a href="#排序进程列表" class="headerlink" title="排序进程列表"></a>排序进程列表</h3><p>使用像 <code>top</code> 这样的工具的一个最常见的原因是找出哪个进程消耗的资源最多。我们可以按以下键排序列表:</p><ul><li>M：用于按内存使用情况排序</li><li>P：来按CPU使用率排序</li><li>N：按进程ID排序</li><li>T：来按运行时间排序</li></ul><p>默认情况下，<code>top</code> 按降序显示所有结果，但是我们可以通过按<code>R</code>键切换到升序。还可以使用 <code>-o</code> 开关对列表进行排序。例如，如果想排序进程的<code>CPU</code>使用量，可以这样做:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -o %CPU</span><br></pre></td></tr></table></figure><h3 id="显示线程列表而不是进程列表"><a href="#显示线程列表而不是进程列表" class="headerlink" title="显示线程列表而不是进程列表"></a>显示线程列表而不是进程列表</h3><p>前面已经介绍过 Linux 如何在进程之间切换。我们知道，进程是不共享内存或其他资源的，这使得这种切换相当慢。和其他操作系统一样，Linux 支持一种“轻量级”的替代方案，称为“线程”。“线程”是进程的一部分，“线程”可以共享内存和其他资源的某些区域，同时它们也可以像进程一样并发运行。默认情况下，<code>top</code>在其输出中显示一个进程列表。如果想列出线程代替进程，按 <code>H</code> 即可，此时 “Tasks” 行将显示的是 “Threads”，显示的是线程的数量，而不是进程的数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Threads: 351 total,   2 running, 349 sleeping,   0 stopped,   0 zombie</span><br></pre></td></tr></table></figure><p>细心的读者可能会发现， summury area 中的 “Tasks” 行已经改变成 “Threads” 的了，但是在 task area 中，对应的列表中的属性却没有任何更改，那既然进程和线程不同，这怎么可能呢? 原因是在 <code>Linux</code> 内核内部，线程和进程使用相同的数据结构进行处理，因此，每个线程都有自己的ID、状态等等。如果我们要切换回进程视图，则再次按 <code>H</code> 即可。此外，也可以使用 <code>top -H</code> 在默认情况下显示线程。</p><h3 id="显示进程完整路径"><a href="#显示进程完整路径" class="headerlink" title="显示进程完整路径"></a>显示进程完整路径</h3><p>默认情况下，COMMAND 列下的所有进程名显示的都是摘要名，如果我们期望显示当前进程的完成路径，可以通过按 <code>c</code> 来切换视角，或者直接使用 <code>top -c</code> 来启动交互界面。</p><h3 id="以树形结构显示父子进程"><a href="#以树形结构显示父子进程" class="headerlink" title="以树形结构显示父子进程"></a>以树形结构显示父子进程</h3><p>可以通过在 top 交互中按 <code>V</code> 来切到 <code>forest view</code> 视角，即以以树形结构显示父子进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   432 root      20   0   84760   5852   4984 S   0.0  0.0   0:00.01  `- /usr/sbin/sshd -D</span><br><span class="line"> 98518 root      20   0  118432   6884   5792 S   0.0  0.0   0:00.00      `- sshd: admin [priv]</span><br><span class="line"> 98520 admin     20   0  118432   3648   2556 S   0.0  0.0   0:01.32          `- sshd: admin@pts/0</span><br><span class="line"> 98521 admin     20   0  120656   4936   3768 S   0.0  0.0   0:00.34              `- -bash</span><br><span class="line">130138 admin     20   0  161748   4208   3624 R   0.0  0.0   0:00.27                  `- top -c</span><br></pre></td></tr></table></figure><h3 id="列出用户的进程"><a href="#列出用户的进程" class="headerlink" title="列出用户的进程"></a>列出用户的进程</h3><p>要列出某个用户的进程，请在<code>top</code>运行时按 <code>u</code>。然后，输入用户名，或者留空以显示所有用户的进程；或者直接通过 <code>top -u xxx</code> 来指定 xxx 用户的所有进程信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KiB Swap:  2097148 total,  2097148 free,        0 used. 31179088 avail Mem</span><br><span class="line">Which user (blank for all) root   # waiting for input</span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">     1 root      20   0   45416   5244   3968 S   0.0  0.0   5:37.57 /usr/lib/systemd/systemd --system --deserialize 18</span><br><span class="line">   340 root      20   0   72892  30836  27184 S   0.0  0.1   8:36.56 /usr/lib/systemd/systemd-journald</span><br><span class="line">   357 root      20   0  101836   2768   2312 S   0.0  0.0   0:01.14 /usr/sbin/gssproxy -D</span><br><span class="line">   432 root      20   0   84760   5852   4984 S   0.0  0.0   0:00.01 /usr/sbin/sshd -D</span><br></pre></td></tr></table></figure><h3 id="过滤进程"><a href="#过滤进程" class="headerlink" title="过滤进程"></a>过滤进程</h3><p>如果我们需要处理许多进程，那么简单的排序实际上对我们的帮助并不是很大。那么在这种情况下，我们可以按 <code>o</code> 来激活 <code>top</code> 的过滤模式，然后通过输入一个过滤器表达式来过滤到我们的目前进程。过滤器表达式是指定属性和值之间关系的语句，例如：</p><ul><li>COMMAND=java: 进程名=java 的</li><li>!COMMAND=java: 进程名 !=java 的</li><li>%CPU&gt;3.0: CPU &gt; 3.0  的</li></ul><p>如果要清除所有过滤条件的话，按 <code>=</code> 即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>本文主要是对<a href="https://www.booleanworld.com/guide-linux-top-command/" target="_blank" rel="noopener">A Guide to the Linux “Top” Command</a> 这篇文章的一些内容翻译，感谢原作者提供的分享</p></blockquote><p><code>top</code> 命令对于监视和管理 Linux 系统上的进程非常有帮助，本文只是从表面做了一些简单的介绍，还有很多我们没有涉及到的内容；例如，如何在 <code>top</code> 中添加更多的列。更多信息，可以通过运行 <code>man top</code> 查看 man 页面，来进行更深层面的学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;top&lt;/code&gt; 命令允许用户监视 Linux 上的进程和系统资源使用情况，它是系统管理员工具箱中最有用的工具之一，并且在每个发行版中都预装了它。与 &lt;code&gt;ps&lt;/code&gt; 等其他命令不同，它是交互式的，我们可以浏览进程列表、终止进程，等等。本文中，
      
    
    </summary>
    
      <category term="linux" scheme="http://www.glmapper.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.glmapper.com/tags/linux/"/>
    
      <category term="top" scheme="http://www.glmapper.com/tags/top/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊 BeanPostProcessor 不生效</title>
    <link href="http://www.glmapper.com/2020/06/21/spring/spring-series-factory-bean-and-post-processor/"/>
    <id>http://www.glmapper.com/2020/06/21/spring/spring-series-factory-bean-and-post-processor/</id>
    <published>2020-06-21T13:12:14.000Z</published>
    <updated>2020-12-16T05:17:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于 BeanPostProcessor 各位一定不陌生，在 <a href="http://www.glmapper.com/2019/12/14/springboot-series-bean-life/">SpringBoot 源码系列-Bean 的生命周期与扩展</a> 这篇文章中，我有介绍过 bean 的创建流程及相关扩展，就有提到 BeanPostProcessor，包括它的作用时机及如何使用，这篇文章提到的这种属于比较常规的流程，因此在绝大多数场景下，都是符合我们认知的。但是最近在排查一个问题时，发现在某些场景下，BeanPostProcessor 不生效了…</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>代码详见：<a href="https://github.com/glmapper/glmapper-spring-extention/tree/master/extention-FactoryBean" target="_blank" rel="noopener">extention-FactoryBean</a>; clone 之后可以直接运行 DemoApplication 即可，可以观察到 控制台不输出 GlmapperBeanPostProcessor 里面 print out 的字符串。</p></blockquote><p>运行代码，即可观察到具体的执行现场；代码里除了 BeanPostProcessor 之外，另外一个是 FactoryBean，也就是本篇所要聊的重点：<strong>FactoryBean getObjectType 为 null 时导致 bean 提前初始化，从而使得作用与目标 bean 的 BeanPostProcessors 都失效了。</strong></p><p>下面将基于这个问题，展开进行分析。</p><h2 id="bean-生命周期"><a href="#bean-生命周期" class="headerlink" title="bean 生命周期"></a>bean 生命周期</h2><p>先来看下 ApplicationContext 和 bean 生命周期(仅列出部分关键流程)：</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/beanlife/bean%20init.png" alt=""></p><p>从流程中可以看到：BeanPostProcessor 的注册是在 ApplicationContext 生命周期中完成的，故而当 bean 创建时，如果相应拦截器 BeanPostProcessor 还没有注册，那么其就不会起作用，这个可能有以下两种原因：</p><ul><li>1、bean 本身是一个 BeanPostProcessor ，且实现了 PriorityOrdered 或者 Ordered 接口</li><li>2、bean 由于某种原因，被提前初始化了，初始化的时候相应拦截器 BeanPostProcessor 还没有注册</li></ul><p>关于第一个其实很好理解，不再赘述，本篇主要基于第二个原因进行说明。</p><h2 id="bean-由于某种原因，被提前初始化了，初始化的时候相应拦截器-BeanPostProcessor-还没有注册"><a href="#bean-由于某种原因，被提前初始化了，初始化的时候相应拦截器-BeanPostProcessor-还没有注册" class="headerlink" title="bean 由于某种原因，被提前初始化了，初始化的时候相应拦截器 BeanPostProcessor 还没有注册"></a>bean 由于某种原因，被提前初始化了，初始化的时候相应拦截器 BeanPostProcessor 还没有注册</h2><p>bean 被提前初始化的情况就比较多了，归纳下来都能符合同一个规律：在 创建所有 non-lazy-init bean 这一步之前，也即在创建 BeanFactoryPostProcessor 或者 BeanPostProcessor 的过程中，引发了 bean 的创建，导致其被提前初始化，大体可以分为两种情形：</p><ul><li>用户自定义的 BeanFactoryPostProcessor 或者 BeanPostProcessor 中会通过构造函数、属性注入等方式引用到目标 bean 导致其被提前创建</li><li>在上述过程中由于 Spring 自身对 FactoryBean 的 typeCheck(类型检测) 机制导致目标 bean 被提前创建</li></ul><p>对于第一种情形，比较简单，这个通常是用户的配置导致的，比如我的 TestBeanFactoryPostProcessor 中通过属性注入了目标 bean 导致了其被提前创建，最终拦截器失效(如果去掉相应 TestBeanFactoryPostProcessor 配置，可以看到拦截器是能够成功的 )。</p><blockquote><p>简单代码如下，作用在 TestFacade 上的 BeanFactoryPostProcessor 可能会由于 TestFacade 的提前被创建而失效</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @<span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestFacade testFacade;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>如何找到 bean 被提前初始化的时机呢？可以在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[]) 打一个条件断点，通过 beanName 进行匹配，然后顺着 debug 堆栈往回找，就能够看到是在哪里导致了 bean 被提前创建。</p></blockquote><p>对于第二种情形，其实也是通过上述方法先找到被提前创建的源头，只不过这种情形更加隐晦，也更加复杂，这里我们单独在下面的部分中来分析。</p><h2 id="关于-isTypeMatch"><a href="#关于-isTypeMatch" class="headerlink" title="关于 isTypeMatch"></a>关于 isTypeMatch</h2><p>从 Spring 2.x 版本开始，BeanFactory 中就已经有 isTypeMatch 这个方法了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Check whether the bean with the given name matches the specified type.</span></span><br><span class="line"><span class="comment">* More specifically, check whether a &#123;<span class="doctag">@link</span> #getBean&#125; call for the given name</span></span><br><span class="line"><span class="comment">* would return an object that is assignable to the specified target type.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">* Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> typeToMatch the type to match against (as a &#123;<span class="doctag">@code</span> Class&#125;)</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the bean type matches,</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> false&#125; if it doesn't match or cannot be determined yet</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 2.0.1</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> #getType</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, @Nullable Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br></pre></td></tr></table></figure><p>从方法注释可以简单了解到，isTypeMatch 的作用就是：判断 JavaBean 是否匹配指定的类型。他包括两个参数：</p><ul><li>name：容器中定义的 JavaBean 的名称。</li><li>typeToMatch：要匹配的目标类型。</li></ul><p>回到案例，我们需要关注的是 isTypeMatch 和我们前面提到的<strong>FactoryBean getObjectType 为 null 时导致 bean 提前初始化，从而使得作用与目标 bean 的 BeanPostProcessors 都失效了。</strong>有什么关系呢？这里有两个比较关键的信息：</p><ul><li>1、FactoryBean getObjectType 为 null</li><li>2、目标 bean 的 BeanPostProcessors 都失效了</li></ul><p>其实大概能够猜到的是，<strong>actoryBean getObjectType 为 null 时，导致了 当前 bean 被提前初始化，而此时 bean 的 BeanPostProcessors 还没有被注册到当前 bean ，从而导致了目标 bean 的 BeanPostProcessors 都失效。</strong> 这个也是本篇的结论，但是还是需要来看看具体原因的细节是什么样的。</p><p><strong>我们知道，在 Spring 中，当进行 byType (除了用户主动配置 byType 注入以外，使用 @autowired 以及 @Bean 中的方法参数时等都使用的是 byType  注入) 注入时，会通过 org.springframework.beans.factory.ListableBeanFactory#getBeanNamesForType(java.lang.Class&lt;?&gt;, boolean, boolean) 来寻找相应类型的 bean 。</strong></p><p><strong>针对 FactoryBean 而言，当判断其类型时，会先创建一个简单的(非完整的，仅仅是调用构造函数) bean ，调用其 getObjectType() ，如果发现返回为 null，那么就会再创造完整的 bean ，然后再通过 getObjectType() 获取类型进行匹配。</strong></p><h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><p>基于上面提到的点，结合本案例，来 debug 看下 <strong>FactoryBean typeCheck(类型检测) 机制导致的 BeanPostProcessor 不生效</strong>的原因。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/beanlife/exe-stack.jpg" alt="执行堆栈"></p><p>这里主要还是看下 isTypeMatch 方法执行是如何触发 bean 提前初始化的。</p><h3 id="isTypeMatch-方法"><a href="#isTypeMatch-方法" class="headerlink" title="isTypeMatch 方法"></a>isTypeMatch 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">    String beanName = transformedBeanName(name);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Check manually registered singletons.</span></span><br><span class="line">    Object beanInstance = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 常规情况下，这里 beanInstance 是不为 null 的，但是对于提前加载的 beanInstance == null</span></span><br><span class="line">    <span class="keyword">if</span> (beanInstance != <span class="keyword">null</span> &amp;&amp; beanInstance.getClass() != NullBean.class) &#123;</span><br><span class="line">        <span class="comment">// 判断类型是不是 FactoryBean</span></span><br><span class="line">        <span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">            <span class="comment">// 返回给定名称是否为工厂解除引用(以工厂解除引用前缀开始)。 &amp;xxxx </span></span><br><span class="line">            <span class="keyword">if</span> (!BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">                <span class="comment">// 这里拿 FactoryBean#getObjectType</span></span><br><span class="line">                Class&lt;?&gt; type = getTypeForFactoryBean((FactoryBean&lt;?&gt;) beanInstance);</span><br><span class="line">                <span class="keyword">return</span> (type != <span class="keyword">null</span> &amp;&amp; typeToMatch.isAssignableFrom(type));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 实例类型是否匹配</span></span><br><span class="line">                <span class="keyword">return</span> typeToMatch.isInstance(beanInstance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理泛型和代理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (typeToMatch.isInstance(beanInstance)) &#123;</span><br><span class="line">                <span class="comment">// 直接匹配暴露实例?</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (typeToMatch.hasGenerics() &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">                <span class="comment">// 泛型可能只匹配目标类，而不匹配代理…</span></span><br><span class="line">                RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">                Class&lt;?&gt; targetType = mbd.getTargetType();</span><br><span class="line">                <span class="keyword">if</span> (targetType != <span class="keyword">null</span> &amp;&amp; targetType != ClassUtils.getUserClass(beanInstance) &amp;&amp;</span><br><span class="line">                        typeToMatch.isAssignableFrom(targetType)) &#123;</span><br><span class="line">                    <span class="comment">// 还要检查原始类匹配，确保它在代理上暴露。</span></span><br><span class="line">                    Class&lt;?&gt; classToMatch = typeToMatch.resolve();</span><br><span class="line">                    <span class="keyword">return</span> (classToMatch == <span class="keyword">null</span> || classToMatch.isInstance(beanInstance));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 beanName 的 bean 没有被注册过</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (containsSingleton(beanName) &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">        <span class="comment">// null instance registered</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有找到单例实例-&gt;检查bean定义。</span></span><br><span class="line">    BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">        <span class="comment">// 在这个 factory 中没有找到 bean definition -&gt; 委托 parent。</span></span><br><span class="line">        <span class="keyword">return</span> parentBeanFactory.isTypeMatch(originalBeanName(name), typeToMatch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检索相应的 bean 定义。</span></span><br><span class="line">    RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; classToMatch = typeToMatch.resolve();</span><br><span class="line">    <span class="keyword">if</span> (classToMatch == <span class="keyword">null</span>) &#123;</span><br><span class="line">        classToMatch = FactoryBean.class;</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt;[] typesToMatch = (FactoryBean.class == classToMatch ?</span><br><span class="line">            <span class="keyword">new</span> Class&lt;?&gt;[] &#123;classToMatch&#125; : <span class="keyword">new</span> Class&lt;?&gt;[] &#123;FactoryBean.class, classToMatch&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check decorated bean definition, if any: We assume it'll be easier</span></span><br><span class="line">    <span class="comment">// to determine the decorated bean's type than the proxy's type.</span></span><br><span class="line">    <span class="comment">// 检查修饰 bean definition(如果有的话):我们假设确定修饰 bean 的类型比确定代理的类型更容易。</span></span><br><span class="line">    BeanDefinitionHolder dbd = mbd.getDecoratedDefinition();</span><br><span class="line">    <span class="keyword">if</span> (dbd != <span class="keyword">null</span> &amp;&amp; !BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">        RootBeanDefinition tbd = getMergedBeanDefinition(dbd.getBeanName(), dbd.getBeanDefinition(), mbd);</span><br><span class="line">        <span class="comment">// 预测指定bean的最终bean类型(已处理bean实例的)。由&#123;@link #getType&#125;和&#123;@link #isTypeMatch&#125;调用。不需要专门处理factorybean，因为它只应该操作原始bean类型。</span></span><br><span class="line">        <span class="comment">// 这个实现过于简单，因为它不能处理工厂方法和实例化 awarebeanpostprocessors。对于标准bean，它只能正确地预测bean类型。要在子类中重写，应用更复杂的类型检测。</span></span><br><span class="line">        Class&lt;?&gt; targetClass = predictBeanType(dbd.getBeanName(), tbd, typesToMatch);</span><br><span class="line">        <span class="keyword">if</span> (targetClass != <span class="keyword">null</span> &amp;&amp; !FactoryBean.class.isAssignableFrom(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> typeToMatch.isAssignableFrom(targetClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 推断出 beanType</span></span><br><span class="line">    Class&lt;?&gt; beanType = predictBeanType(beanName, mbd, typesToMatch);</span><br><span class="line">    <span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查 bean class 是否是 FactoryBean 类型。本案例就是在这被处理到 返回 false 的</span></span><br><span class="line">    <span class="keyword">if</span> (FactoryBean.class.isAssignableFrom(beanType)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; beanInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果它是FactoryBean，我们希望看到它创建了什么（getObject），而不是工厂类。</span></span><br><span class="line">            beanType = getTypeForFactoryBean(beanName, mbd);</span><br><span class="line">            <span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 ........</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getTypeForFactoryBean-方法"><a href="#getTypeForFactoryBean-方法" class="headerlink" title="getTypeForFactoryBean 方法"></a>getTypeForFactoryBean 方法</h3><p>这个步骤会向尝试从 FactoryBean 的 getObjectType 方法去获取类型，如果拿不到，则调用父类的进行初始化 bean 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略 其他...</span></span><br><span class="line"><span class="keyword">if</span> (fb != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 尝试从实例的这个早期阶段获取 FactoryBean 的对象类型。这里调用的就是 FactoryBean#getObjectType 方法</span></span><br><span class="line">    Class&lt;?&gt; result = getTypeForFactoryBean(fb);</span><br><span class="line">    <span class="comment">// 本案例中这里返回的是 null, 所以会走到 else</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的意思就是没有通过 FactoryBean#getObjectType 快速获取到类型</span></span><br><span class="line">        <span class="comment">// 将执行实例当前实例，然后再获取</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getTypeForFactoryBean(beanName, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略 其他...</span></span><br></pre></td></tr></table></figure><h3 id="AbstractBeanFactory-getTypeForFactoryBean"><a href="#AbstractBeanFactory-getTypeForFactoryBean" class="headerlink" title="AbstractBeanFactory#getTypeForFactoryBean"></a>AbstractBeanFactory#getTypeForFactoryBean</h3><p>调用父类的 getTypeForFactoryBean 方法，执行 bean 的初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getTypeForFactoryBean(String beanName, RootBeanDefinition mbd) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSingleton()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里开始执行 doGetBean，之前的文章里面有提到，bean 实例化的入口就是 getBean 的时候</span></span><br><span class="line">        FactoryBean&lt;?&gt; factoryBean = doGetBean(FACTORY_BEAN_PREFIX + beanName, FactoryBean.class, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> getTypeForFactoryBean(factoryBean);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">        <span class="comment">// 省略日志打印部分</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 doGetBean 中执行链路中，会在 initializeBean 时给当前 bean 注册 BeanPostProcessor，（applyBeanPostProcessorsBeforeInitialization 方法中) ，这里可以比较清晰的看到 BeanPostProcessor 没有作用于 目标 bean 的。</p><blockquote><p>doGetBean -&gt; createBean -&gt; initializeBean -&gt; applyBeanPostProcessorsBeforeInitialization</p></blockquote><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/beanlife/no-processors.jpg" alt=""></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在本篇的案例中，其实比较明显的可以看到测试工程中 GlmapperFactoryBean 的 getObjectType 返回是为 null 的，也正是因为这个原因导致了 BeanPostProcessor 失效。那么如何在实际的开发过程中来规避呢？</p><ul><li>1、FactoryBean 的 getObjectType() 不要返回 null </li><li>2、定义 BeanPostProcessor 时，需要特别注意 order</li><li>3、在 创建所有 non-lazy-init bean 之前的  getBeanNamesForType 调用，尽量将 eagerInit 传为 false。</li></ul><p>关于第三点，前面提到过 getBeanNamesForType 的调用会触发类型检查，但其实这个方法还有些参数，参考如下：</p><p>String[] getBeanNamesForType(Class&lt;?&gt; type, boolean includeNonSingletons, boolean allowEagerInit);<br>这里有个很重要的参数 allowEagerInit ，可以看到 spring 的注释中对其有非常详细的解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@param allowEagerInit whether to initialize lazy-init singletons and</span><br><span class="line"></span><br><span class="line">* objects created by FactoryBeans (or by factory methods with a</span><br><span class="line">* &quot;factory-bean&quot; reference) for the type check. Note that FactoryBeans need to be</span><br><span class="line">* eagerly initialized to determine their type: So be aware that passing in &quot;true&quot;</span><br><span class="line">* for this flag will initialize FactoryBeans and &quot;factory-bean&quot; references.</span><br></pre></td></tr></table></figure><p>简单来说这个参数能够控制是否允许 FactoryBean 的提前创建，如果是 false，那么也不会引发上述的 类型检测 。可以看到在 Spring 中在获取 BeanFactoryPostProcessor 以及 BeanPostProcessor 时，也都是传入 false 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tring[] postProcessorNames =</span><br><span class="line">        beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">String[] postProcessorNames = </span><br><span class="line">    beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>当然在一些 @Bean 的方法参数注入、@Autowire 注入等场景下，这个默认都是 true 的，无法改变；但针对平时编码过程中，如果是在比较早期的调用中，可根据情况，尽量传入 false。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于 BeanPostProcessor 各位一定不陌生，在 &lt;a href=&quot;http://www.glmapper.com/2019/12/14/springboot-series-bean-life/&quot;&gt;SpringBoot 源码系列-Bean 的生命周期与扩展&lt;/a
      
    
    </summary>
    
      <category term="spring" scheme="http://www.glmapper.com/categories/spring/"/>
    
    
      <category term="spring" scheme="http://www.glmapper.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>什么是中台？</title>
    <link href="http://www.glmapper.com/2020/05/19/solutions/solution-series-zhongtai/"/>
    <id>http://www.glmapper.com/2020/05/19/solutions/solution-series-zhongtai/</id>
    <published>2020-05-19T03:07:17.000Z</published>
    <updated>2021-07-18T03:43:15.291Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文来自 PoemByte 公众号，作者 kayzhao</p></blockquote><h2 id="没有XX台的时代-烟囱式的架构"><a href="#没有XX台的时代-烟囱式的架构" class="headerlink" title="没有XX台的时代 - 烟囱式的架构"></a>没有XX台的时代 - 烟囱式的架构</h2><p>​        在传统IT企业，项目的架构是什么样的呢？无论项目内部的如何复杂，都可简化分为<strong>“前台”</strong>和<strong>“后台”</strong>两部分，也就是<strong>垂直的烟囱式架构</strong>（业内人士把见招拆招、垂直化发展、未做足够抽象通用的架构称之为烟囱型架构）。什么是<strong>前台</strong>？所谓前台即包括各种和消费者用户直接交互的界面业务功能，比如web页面（PC端），手机app（无线端或移动端）。什么是<strong>后台</strong>？后台是面向运营人员的配置管理系统，比如商品管理、物流管理、结算管理。后台为前台提供业务管理等。前台、后台、用户之间的关系，可以用下图简单表示：</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/middleground/1.png" alt="image-20200510183353012" style="zoom: 50%;"></p><p>​        起初，项目的发展相对稳定，并不需要快速的去迭代，所以垂直的烟囱式结构并没有什么问题。但在互联网快速发展的今天，企业之间的竞争越来越激烈，只有以用户为中心，快速响应用户的需求，不断迭代和试错，才能让企业在竞争当中立于不败。在传统的前台-后台架构中，各个项目相对独立，许多项目都在重复发明同样的轮子（比如用户中心，支付业务等），即让项目本身越来越臃肿，也让开发效率越来越低。这种时候，为提高开发效率，我们有必要整合出一个中间组织，为所有的项目提供一些公共资源。而这个中间组织，就是人们所说的平台。</p><h2 id="垂直烟囱的进化-平台化的架构"><a href="#垂直烟囱的进化-平台化的架构" class="headerlink" title="垂直烟囱的进化 - 平台化的架构"></a>垂直烟囱的进化 - 平台化的架构</h2><p>​        为什么会出现平台化架构，还得从烟囱型架构说起（参考上一节）。但烟囱型架构并非一无是处，在早期业务死活未知的情况下，不过度设计架构，能直接有效的支持到业务。不过，当业务发展起来之后，烟囱越树越多，成长的烦恼就如期而至了。</p><p>​        <strong>第一个问题是人不够，业务响应慢了下来。</strong>我们以一个5人研发团队为例来说明一下这个问题。起初团队一个产品都没有，5个人1个月干出一个简单版本的红包系统；几年之后团队增加到10人，但手头要维护10个系统。那么平均人手一个系统，这时候，又来了2个新业务，团队派出3个人去干，大约要干4个月，严重不符合前端业务的响应预期。</p><p>​        <strong>第二个问题是重复建设</strong>，同类烟囱系统中80%的功能是类似的，从数据库模型到主要业务逻辑，都是copy-paste加补丁，一步留神又踩到一个坑。</p><p>​        <strong>第三个问题是维护成本高</strong>。日常升级包、咨询支持服务，团队疲惫不堪。基于此，80%甚至90%的共性问题，能不能抽象出来呢？核心领域模型是否可以是稳定的呢？从下图可以看出，这是可以做到的。</p><p>​        在既要支持不断出现的各种业务，又要支持建设新平台。企业便启动了平台化建设，对前后台业务提供统一的能力露出，由能力组装编排内部服务。研发规则运营、统一后台管理服务等。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/middleground/2.png" alt="image-20200510183513991" style="zoom: 50%;"></p><p>​        总结下来，平台化架构有以下好处：一是快速支撑、响应业务；二是抽象共性，边界清晰。快速支撑，响应业务是以终为始的出发点。架构如果不服务业务，再高大上都是扯淡。技术不是炫技，要服务商业。再谈谈抽象共性的问题，业务平台化要解决业务共性问题，比如天猫、淘宝都有各类营销活动。那么就抽象出一个营销平台来管理营销活动、营销工具的整个的生命周期管理。</p><h2 id="中台的架构思想-大中台小前台"><a href="#中台的架构思想-大中台小前台" class="headerlink" title="中台的架构思想 - 大中台小前台"></a>中台的架构思想 - 大中台小前台</h2><h3 id="中台的起源"><a href="#中台的起源" class="headerlink" title="中台的起源"></a>中台的起源</h3><ul><li><strong>SuperCell</strong></li></ul><p>​        SuperCell是一家芬兰的手机游戏公司，这个名字或许有些陌生，但是说起下面几款游戏，大家一定会很熟悉：部落冲突、海岛奇兵、皇室战争等。SuperCell公司就像是一个高产的游戏孵化器，在几年内开发出了10款以上的游戏，但是大部分用于试错的游戏都在研发过程中被腰斩了，最终呈献给用户的几款游戏都是经典中的经典。是什么让SuperCell公司能够如此高效地试错和迭代呢？他们依靠的是强大的平台资源，支撑起各个游戏开发的小团队。他们开发出的游戏看上去风格迥异，却存在许多共同之处。在业务上，共通的东西包括支付系统、用户系统等等，在技术上，共同的东西包括游戏引擎，内部开发工具等等。而这些共通的资源，都可以由一个强大的“中台”来提供。Supercell的中台，指的是公司将游戏开发过程中公共和通用的游戏素材和算法整合起来，并积累了非常科学的研发工具和框架体系，构建了一个功能非常强大的中台。这样强大的中台可以支持若干个小团队在短时间内开发出一款新的游戏。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/middleground/3.png" alt="image-20200511111247892" style="zoom: 67%;"></p><ul><li><strong>阿里巴巴</strong></li></ul><p>​        马云在2015年的一次欧洲之旅（访问SuperCell公司），将中台的思想结合阿里的现状，提出了<strong>大中台、小前台</strong>的战略架构，从而将中台架构思想引入国内，开启了中台化热潮。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/middleground/4.png" alt="img" style="zoom:67%;"></p><h3 id="中台的定义"><a href="#中台的定义" class="headerlink" title="中台的定义"></a>中台的定义</h3><p>​        中台是什么？简言之，中台是<strong>给业务团队提效为目标的，可复用的技术能力及业务能力的集合</strong>。有业务能力说明理解业务，能复用说明能提效。从这个定义可以看出，中台更接近是一个解决方案。</p><h3 id="中台的分类"><a href="#中台的分类" class="headerlink" title="中台的分类"></a>中台的分类</h3><p>​        <strong>中台 是 可复用的技术能力和业务能力的集合；</strong>与此相对应的，<strong>中间件、技术框架、技术平台 是 可复用的技术能力的集合；</strong>中台和中间件的共同点就是他们都需要被复用才能发挥价值，并不能出去单打独斗。</p><p>​        以此类推：业务中台就是可复用的业务技术能力和组织业务能力的集合；数据中台就是可复用的数据技术能力和数据业务能力的集合；算法中台就是可复用的算法技术能力和算法业务能力的集合；</p><p>​        但是，<strong>技术中台</strong>这种说法有点迷，会让人误解里面都是技术复用，而没有任何业务。如果其实是纯粹的技术复用平台，建议大家在平常交流时还是尽量别用技术中台，直接用<strong>中间件、技术平台、技术框架</strong>的原有概念来沟通即可，没必要赶时髦。</p><h3 id="中台的用户"><a href="#中台的用户" class="headerlink" title="中台的用户"></a>中台的用户</h3><p>​        电商交易系统，前台的用户是消费者，后台的用户是电商运营，中台的用户是谁？</p><p>​        企业管理系统，前台的用户是员工，后台的用户是企业管理员，中台的用户是谁？</p><p>​        数字政务系统，前台的用户是公务员，后台的用户是政府管理员，中台的用户是谁？</p><p>​        大中台，小前台。 这种说法的误导性在于，让人以为中台是为前台服务的。但其实中台可以服务任何业务形态。从Supercell这个故事可以看出，中台不会直面消费者或最终用户。<strong>中台的作用就是为业务团队服务，</strong>让业务团队更好更快的服务最终用户。</p><h2 id="中台是必须？"><a href="#中台是必须？" class="headerlink" title="中台是必须？"></a>中台是必须？</h2><h3 id="从0到1的阶段"><a href="#从0到1的阶段" class="headerlink" title="从0到1的阶段"></a>从0到1的阶段</h3><p>​        <strong>没有必要搭建中台。</strong>从0到1的创业型公司，首要目的是生存下去，以最快的速度打造出产品，证明自身的市场价值。这个时候，让项目野蛮生长才是最好的选择。如果不慌不忙地先去搭建中台，恐怕中台还没搭建好，公司早就饿死了。</p><h3 id="从1到N的阶段"><a href="#从1到N的阶段" class="headerlink" title="从1到N的阶段"></a>从1到N的阶段</h3><p>​        <strong>适合搭建中台。</strong>当企业有了一定规模，产品得到了市场的认可，这时候公司的首要目的不再是活下去，而是活的更好。这个时候，趁着项目复杂度还不是特别高，可以考虑把各项目的通用部分下沉，组建中台，以方便后续新项目的尝试和旧项目的迭代。</p><h3 id="从N到N-1的阶段"><a href="#从N到N-1的阶段" class="headerlink" title="从N到N+1的阶段"></a>从N到N+1的阶段</h3><p>​        <strong>搭建中台势在必行。</strong>当企业已经有了很大的规模，各种产品、服务、部门错综复杂，这时候做架构调整会比较痛苦。但是长痛不如短痛，为了项目的长期发展，还是需要尽早调整架构，实现平台化，以免日后越来越难以维护。</p><h2 id="中台的FAQ"><a href="#中台的FAQ" class="headerlink" title="中台的FAQ"></a>中台的FAQ</h2><h3 id="中心化-平台化-中台化异同？"><a href="#中心化-平台化-中台化异同？" class="headerlink" title="中心化/平台化/中台化异同？"></a>中心化/平台化/中台化异同？</h3><p>​        中心化-&gt;平台化-&gt;中台化，更像是随着组织规模增大，分布式系统下一种架构思想的演进。在业务最早期，业务既量小又简单，一个业务系统、单机或几台机器就支持了。随着业务快速发展，团队增多，带来诸多的效率和稳定性问题，系统架构升级，开始系统拆分，正式进入分布式系统阶段，并由此开启了一段新的架构演进，如下图所示：</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/middleground/5.png" alt="image-20200511140325736" style="zoom: 50%;"></p><p>​        <strong>中心化重在领域建模</strong>，通过对自身领域的抽象建模，对外提供统一标准的数据和服务；</p><p>​        <strong>平台化重在业务抽象和架构开放</strong>，“业务抽象解决共性的80%问题，系统架构开放性解决20%的个性化问题”，既能对外提供标准的数据和服务，还能通过平台配置，或实现指定服务接口，或平台内部实现业务逻辑控制等方式支持不同业务的运行；</p><p>​        <strong>中台化重在建立标准和机制</strong>，通过建立业务身份、能力、扩展点等业务领域概念标准，能力管控、流程编排等系统运行时标准，使大家能互联互通、共享共建，以统一的标准进行需求分析、技术开发和复用。</p><p>​        总的来说：<strong>中心主要负责自身单一领域的建设，而平台要负责对多个业务域的支持，而中台则是要覆盖到所有业务域，建立整个业务域的协同标准和机制。所以中台的技术连通性更强，技术生态性更突出。</strong>淘系业务系统的发展正是这个过程，业务上从淘宝时期到三淘（淘宝、天猫、一淘）时期到现在的淘系生态，系统上从商品中心、店铺中心等到商品平台、店铺平台到今天的电商业务中台。 </p><h3 id="小前台到底多小才算小呢？"><a href="#小前台到底多小才算小呢？" class="headerlink" title="小前台到底多小才算小呢？"></a>小前台到底多小才算小呢？</h3><p>​        小前台只是个代称，并不一定非得是前台团队， 用一个<strong>“快速反应团队”</strong>代之较为合适。<strong>也就是5人、7人、最多十几个人组成的团队</strong>，不宜过大（其实是相对“小”，不用刻意追求数量的少）。过大了惯性也会比较大，掉头就比较不容易，不利于快速反应、创新、试错。</p><h3 id="如何下手建设中台化架构？"><a href="#如何下手建设中台化架构？" class="headerlink" title="如何下手建设中台化架构？"></a>如何下手建设中台化架构？</h3><p>​        从哪里开始？哪种路径更适合打造一个中台？</p><p>​        ① 直接下手开始做中台，逐步扩展到其他业务 </p><p>​        <strong>②</strong> <strong>从最擅长的业务（核心业务）入手，做中台的探索</strong></p><p>​        第一种路径的好处是一开始可以做好中台的规划，技术栈保持一致性。坏处是失败的概率和成本比较高。第二种路径更保险，也是目前来看比较可能结出果实的路径。比如：阿里先有电商业务和互联网金融业务，然后才做了共享业务、星环等中台方案。头条最擅长算法业务，然后才有了算法中台。腾讯在IM领域沉淀了多年，基于IM做中台符合逻辑。</p><h3 id="中台架构到底在学习什么？"><a href="#中台架构到底在学习什么？" class="headerlink" title="中台架构到底在学习什么？"></a>中台架构到底在学习什么？</h3><p>​        <strong>值得我们学习的不是中台本身，而是 Supercell模式。</strong>Supercell模式如何实现，马老师已经给了一种路径：大中台，小前台。 但也许这不是唯一路径，但至少是种思路。18年到19年，有种功利化、蹭热度化、浮躁化的氛围，弥漫在中台的圈子里。大家一哄而上，咋咋呼呼的大跃进式的建设大中台，逢人必谈中台，周报写中台，开会说中台，晋升提中台，甚至借中台之名，行平台之实。 </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://mp.weixin.qq.com/s/fQ98fe3XH6imxzNhwiNaNA" target="_blank" rel="noopener">我看中台</a>：<a href="https://mp.weixin.qq.com/s/fQ98fe3XH6imxzNhwiNaNA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/fQ98fe3XH6imxzNhwiNaNA</a></p><p><a href="https://mp.weixin.qq.com/s/rF7_xJBq4NJP6CmkW3HPpQ" target="_blank" rel="noopener">漫画：什么是中台</a>：<a href="https://mp.weixin.qq.com/s/rF7_xJBq4NJP6CmkW3HPpQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/rF7_xJBq4NJP6CmkW3HPpQ</a></p><p><a href="https://juejin.im/search?query=数据中台" target="_blank" rel="noopener">掘金： 数据中台</a>：<a href="https://juejin.im/search?query=数据中台" target="_blank" rel="noopener">https://juejin.im/search?query=数据中台</a></p><p><a href="https://juejin.im/post/5d79fedff265da03cd0aac81" target="_blank" rel="noopener">读透《阿里巴巴数据中台实践》，其到底有什么高明之处？</a>：<a href="https://juejin.im/post/5d79fedff265da03cd0aac81" target="_blank" rel="noopener">https://juejin.im/post/5d79fedff265da03cd0aac81</a></p><p><a href="https://www.zhihu.com/search?type=content&amp;q=中台如何做到快速响应" target="_blank" rel="noopener">知乎：中台如何做到快速响应</a>：<a href="https://www.zhihu.com/search?type=content&amp;q=中台如何做到快速响应" target="_blank" rel="noopener">https://www.zhihu.com/search?type=content&amp;q=中台如何做到快速响应</a></p><p><a href="https://zhuanlan.zhihu.com/p/59867439" target="_blank" rel="noopener">业务中台探索和实践：软件的根本问题</a>：<a href="https://zhuanlan.zhihu.com/p/59867439" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/59867439</a></p><p><a href="https://zhuanlan.zhihu.com/p/77097815" target="_blank" rel="noopener">什么是中台？什么不是中台？所有的中台都是业务中台</a>：<a href="https://zhuanlan.zhihu.com/p/77097815" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/77097815</a></p><p><a href="https://zhuanlan.zhihu.com/p/77362869" target="_blank" rel="noopener">如何建设中台？中台建设的组织、支撑技术和方法论</a>：<a href="https://zhuanlan.zhihu.com/p/77362869" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/77362869</a></p><p><a href="https://www.zhihu.com/question/332569121/answer/733808658" target="_blank" rel="noopener">什么是人力资源中台模式？</a>：<a href="https://www.zhihu.com/question/332569121/answer/733808658" target="_blank" rel="noopener">https://www.zhihu.com/question/332569121/answer/733808658</a></p><p><a href="https://juejin.im/post/5d8093c251882579f24fb9ed" target="_blank" rel="noopener">中台是什么，到底要解决什么问题？</a>：<a href="https://juejin.im/post/5d8093c251882579f24fb9ed" target="_blank" rel="noopener">https://juejin.im/post/5d8093c251882579f24fb9ed</a></p><p><a href="https://mp.weixin.qq.com/s/dpkteHsQJ4Rwl6YNl2PVeg?" target="_blank" rel="noopener">从平台到中台【上】</a>：<a href="https://mp.weixin.qq.com/s/dpkteHsQJ4Rwl6YNl2PVeg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dpkteHsQJ4Rwl6YNl2PVeg</a>?</p><p><a href="https://mp.weixin.qq.com/s/TirTQfWo0gX9PUw_okdGjQ?" target="_blank" rel="noopener">从平台到中台【下】</a>：<a href="https://mp.weixin.qq.com/s/TirTQfWo0gX9PUw_okdGjQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/TirTQfWo0gX9PUw_okdGjQ</a>?</p><p><a href="https://book.douban.com/subject/27039508/" target="_blank" rel="noopener">陈华编著《企业IT架构转型之道：阿里巴巴中台战略思想与架构实战》</a>：<a href="https://book.douban.com/subject/27039508/" target="_blank" rel="noopener">https://book.douban.com/subject/27039508/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文来自 PoemByte 公众号，作者 kayzhao&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;没有XX台的时代-烟囱式的架构&quot;&gt;&lt;a href=&quot;#没有XX台的时代-烟囱式的架构&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="解决方案" scheme="http://www.glmapper.com/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="解决方案" scheme="http://www.glmapper.com/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
      <category term="中台" scheme="http://www.glmapper.com/tags/%E4%B8%AD%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>ClassLoader 类加载-type checking 对类加载的影响</title>
    <link href="http://www.glmapper.com/2020/05/01/java/java-base-classloader-typecheck/"/>
    <id>http://www.glmapper.com/2020/05/01/java/java-base-classloader-typecheck/</id>
    <published>2020-05-01T01:33:57.000Z</published>
    <updated>2021-07-18T04:03:26.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Type-Checking"><a href="#Type-Checking" class="headerlink" title="Type Checking"></a>Type Checking</h2><p>Type Checking (类型检测) 的作用是分析程序在编译或者运行期间，其类型表达是否一致的一个过程。举个例子：如果一个变量被声明为 int 类型，那么他就不能被赋值为实际的值（或者字符串类型、或者其他任何类型）。java 语言的类型检测分为两种：</p><ul><li>静态类型检测（static checking）: 问题在程序运行之前被自动找到，也就是在编译阶段完成的检查。静态类型检测更多的是关注在”类型“上。</li><li>动态类型检测（dynamic checking）: 问题在运行期间被检测，动态运行检测关注的是在”值“上。</li></ul><p>本文主要介绍静态类型检测。java 语言在编译时会做大量的类型检测，只要你声明了一个变量的类型，编译器将会确保只有相应类型的值可以被赋值给这个变量（或者这个值的类型是变量类型的子类型）。比如，如果你声明了如下变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br></pre></td></tr></table></figure></p><p>这里可以确保它只保存 int 值。但是，如果将变量声明为 List，则该变量可能包含列表的子类型，包括 ArrayList、LinkedList 等。</p><h2 id="Type-Checking-对类加载的影响"><a href="#Type-Checking-对类加载的影响" class="headerlink" title="Type Checking 对类加载的影响"></a>Type Checking 对类加载的影响</h2><p>前面提到静态类型检测主要是对类型的检测，而 java 语言中，类型一致表示的是 <code>类全限定名+ClassLoader</code> 一致，所以在做类型检测时就必定会涉及到某些类的 class load 操作。下面我们就从几个方面来分析下类型检测对于类加载的影响。</p><blockquote><p>在 jvm 参数中配置 -verbose:class 可以观察类加载过程</p></blockquote><h3 id="方法的返回类型"><a href="#方法的返回类型" class="headerlink" title="方法的返回类型"></a>方法的返回类型</h3><p>在下面的例子中， Main 执行过程，check 方法没有被调用，但是该方法返回了一个非 ClassA 的类型，也就是类型 ClassB。那么类型检测就要求就提前加载 ClassA 和 ClassB 类型，加以验证，因此加载顺序如下（ClassA –&gt; ClassB –&gt; ClassC –&gt; ClassD）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> <span class="keyword">extends</span> <span class="title">ClassA</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassC</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassD</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ClassC c;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        c = <span class="keyword">new</span> ClassC();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ClassD();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ClassA <span class="title">check</span><span class="params">(ClassA a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClassB();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行查看类加载顺序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Loaded com.glmapper.bridge.boot.methodreturn.Main from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class="line">[Loaded sun.launcher.LauncherHelper$FXHelper from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded java.lang.Class$MethodArray from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded com.glmapper.bridge.boot.methodreturn.ClassA from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class="line">[Loaded com.glmapper.bridge.boot.methodreturn.ClassB from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class="line">[Loaded java.lang.Void from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded com.glmapper.bridge.boot.methodreturn.ClassC from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class="line">[Loaded com.glmapper.bridge.boot.methodreturn.ClassD from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br></pre></td></tr></table></figure><p>从这里可以看到，静态域不一定会比非静态域先加载，这里就是因为静态检测提前出发了类的加载导致。</p><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><p>先来看下下面这段代码，大家可以想一下类加载顺序是什么样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> <span class="keyword">extends</span> <span class="title">ClassA</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassC</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ClassC c;</span><br><span class="line">    <span class="keyword">static</span>  &#123;</span><br><span class="line">        c = <span class="keyword">new</span> ClassC();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main main = <span class="keyword">new</span> Main();</span><br><span class="line">        main.m(<span class="keyword">new</span> ClassB());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">(ClassA a)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照我们惯性理解，Main 加载之后，会加载 ClassC，然后再加载 ClassA 和 ClassB。但是事实是这样吗？通过 <code>-verbose:class</code> 参数执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Loaded com.glmapper.bridge.boot.paramscheck.Main from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class="line">[Loaded sun.launcher.LauncherHelper$FXHelper from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded java.lang.Class$MethodArray from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded com.glmapper.bridge.boot.paramscheck.ClassA from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class="line">[Loaded com.glmapper.bridge.boot.paramscheck.ClassB from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class="line">[Loaded java.lang.Void from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded com.glmapper.bridge.boot.paramscheck.ClassC from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br></pre></td></tr></table></figure></p><p>但是从这里看到，Main 执行时， ClassA ，ClassB 先于 ClassC 加载了。原因是类型检测过程中，会一行行先行的看你的代码，在这个场景中，它发现有 m(ClassA a) 方法，但是代码中传入了 ClassB 这个类型，那么在真正运行 main 方法之前，在运行 Main 的 static 块之前，先行加载了 ClassA 和 ClassB 两个类型，然后验证它们之间的关系。所以看到的类加载顺序是 ClassA -&gt; ClassB -&gt; ClassC ，而非我们概念中的 ClassC -&gt; ClassA -&gt; ClassB。</p><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>最后一种场景是变量赋值，来看下面的代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> <span class="keyword">extends</span> <span class="title">ClassA</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassC</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassD</span> </span>&#123;</span><br><span class="line">    ClassA a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ClassC c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        c = <span class="keyword">new</span> ClassC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassD d = <span class="keyword">new</span> ClassD();</span><br><span class="line">        d.a = <span class="keyword">new</span> ClassB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 main 方法时，在 jvm 参数中配置 -verbose:class 来观察类型加载顺序；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Loaded com.glmapper.bridge.boot.variableassign.Main from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class="line">[Loaded sun.launcher.LauncherHelper$FXHelper from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded java.lang.Class$MethodArray from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded com.glmapper.bridge.boot.variableassign.ClassA from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class="line">[Loaded com.glmapper.bridge.boot.variableassign.ClassB from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class="line">[Loaded java.lang.Void from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded com.glmapper.bridge.boot.variableassign.ClassC from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class="line">[Loaded com.glmapper.bridge.boot.variableassign.ClassD from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br></pre></td></tr></table></figure><p>是不是又有点出乎意料呢？类型检测发现 Main 中包含了 d.a = new ClassB() 的语句，其中 d.a 的类型不是 ClassB，因此会先于 main 方法执行以及先于 Main 中的 static 块执行进行加载。 类型检测，将类型 ClassA 和 ClassB 的加载“提前”了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要介绍了静态类型检测对于 Class Loader 加载类顺序的影响，了解此逻辑对于在考虑多 class loader 场景处理问题非常有用，对于常规的类似 ClassCastExcetion, LinkageError 等异常排查有一定的意义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Type-Checking&quot;&gt;&lt;a href=&quot;#Type-Checking&quot; class=&quot;headerlink&quot; title=&quot;Type Checking&quot;&gt;&lt;/a&gt;Type Checking&lt;/h2&gt;&lt;p&gt;Type Checking (类型检测) 的作用是分
      
    
    </summary>
    
      <category term="JAVA" scheme="http://www.glmapper.com/categories/JAVA/"/>
    
    
      <category term="classloader" scheme="http://www.glmapper.com/tags/classloader/"/>
    
  </entry>
  
  <entry>
    <title>【译】微服务（microservices）</title>
    <link href="http://www.glmapper.com/2020/04/12/solutions/solution-series-microservices/"/>
    <id>http://www.glmapper.com/2020/04/12/solutions/solution-series-microservices/</id>
    <published>2020-04-12T10:47:34.000Z</published>
    <updated>2021-07-18T03:43:15.244Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">https://martinfowler.com/articles/microservices.html</a></p></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>微服务体系结构的特征</li><li>通过服务拆分实现组件化</li><li>围绕业务功能进行组织</li><li>产品不是项目</li><li>智能端点和轻量级通信</li><li>分散治理</li><li>分散的数据管理</li><li>基础设施自动化</li><li>容错设计</li><li>演进式设计</li><li>微服务是未来的趋势吗?</li></ul><h2 id="Sidebars-扩展"><a href="#Sidebars-扩展" class="headerlink" title="Sidebars-扩展"></a>Sidebars-扩展</h2><ul><li>微服务有多大?</li><li>Microservices和SOA</li><li>多种语言，多种选择</li><li>经过实战检验的标准和强制执行的标准</li><li>让做正确的事情变得容易</li><li>断路器和可随时上线的代码</li><li>同步调用的弊端</li></ul><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><table><thead><tr><th>术语原词</th><th>释义</th></tr></thead><tbody><tr><td>Microservice Architecture</td><td>微服务架构</td></tr><tr><td>automated deployment</td><td>自动部署</td></tr><tr><td>centralized management</td><td>集中管理</td></tr><tr><td>communicating</td><td>通信、交互</td></tr><tr><td>lightweight mechanisms</td><td>轻量级机制</td></tr><tr><td>monolithic application</td><td>单体应用/集中式应用</td></tr><tr><td>load-balancer</td><td>负载均衡器</td></tr><tr><td>modular structure</td><td>模块化结构</td></tr><tr><td>Componentization/components</td><td>组件化/组件</td></tr><tr><td>physical world</td><td>客观世界</td></tr><tr><td>OO programs</td><td>面向对象编程</td></tr><tr><td>encapsulation</td><td>封装</td></tr><tr><td>processes</td><td>进程</td></tr><tr><td>cross-team</td><td>跨团队</td></tr><tr><td>boundaries</td><td>边界</td></tr><tr><td>business capability</td><td>业务能力</td></tr><tr><td>business area</td><td>业务领域</td></tr><tr><td>cross-functional</td><td>跨职能的</td></tr><tr><td>message bus.</td><td>消息总线</td></tr><tr><td>Smart endpoints</td><td>智能端点</td></tr><tr><td>dumb pipes</td><td>轻量级通信</td></tr><tr><td>Decentralized Governance</td><td>去中心化治理</td></tr><tr><td>Infrastructure Automation</td><td>基础设施自动化</td></tr><tr><td>Design for failure</td><td>容错机制设计</td></tr><tr><td>Evolutionary Design</td><td>演进/迭代 设计</td></tr><tr><td>coarser-grained</td><td>粗粒度的</td></tr></tbody></table><h2 id="一个新架构术语的定义"><a href="#一个新架构术语的定义" class="headerlink" title="一个新架构术语的定义"></a>一个新架构术语的定义</h2><blockquote><p>The term “Microservice Architecture” has sprung up over(涌现出了) the last few years to describe a particular(特定的) way of designing software applications as suites of independently deployable services.</p></blockquote><p>过去几年中出现了“微服务架构”一词，用以描述将软件应用程序设计为可独立部署的服务套件的特定方法。</p><blockquote><p>While there is no precise(精确) definition of this architectural style，there are certain(某些) common characteristics around organization around business capability(业务功能), automated deployment(自动部署), intelligence in the endpoints, and decentralized(分散的，去中心化的) control of languages and data.</p></blockquote><p>虽然没有对这种架构风格的精确定义，但围绕业务功能的组织，自动部署，端点智能以及在编程语言和数据方面进行去中心化的控制方面存在某些共同特征。</p><blockquote><p>“Microservices” - yet another new term on the crowded streets of software architecture. Although our natural inclination is to pass such things by with a contemptuous glance, this bit of terminology describes a style of software systems that we are finding more and more appealing.</p></blockquote><p>“微服务” - 在繁多的软件架构术语中又多了一个新的名词。 虽然我们对于这种新的概念打心底里自然是不削一顾的，但这个术语描述了一种对于我们来说越来越有吸引力的软件系统风格。</p><blockquote><p>We’ve seen many projects use this style in the last few years, and results so far have been positive, so much so that for many of our colleagues this is becoming the default style for building enterprise applications.</p></blockquote><p>我们已经看到许多项目在过去几年中使用了这种架构风格，并且都取得了很不错的结果；以至于对于我们的许多同事来说，这已成为构建企业应用程序的默认架构风格了。</p><blockquote><p>Sadly, however, there’s not much information that outlines what the microservice style is and how to do it.</p></blockquote><p>然而，遗憾的是，现在还没有太多信息可以概述微服务是什么，以及我们该如何实现微服务架构。</p><blockquote><p>In short, the microservice architectural style [1] is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API.</p></blockquote><p>简单来说，微服务架构风格[1]就是以开发一组小型服务的方式来开发一个独立的应用系统的，每个单体服务都在自己独立的进程中运行，并以HTTP资源API这种轻量级机制进行通信。</p><blockquote><p>These services are built around business capabilities and independently deployable by fully automated deployment machinery.</p></blockquote><p>这些服务围绕业务功能构建，可通过自动化部署机制进行独立部署。</p><blockquote><p>There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.</p></blockquote><p>这些服务具有最低限度的集中管理，可以用不同的编程语言编写，也可以使用不同的数据存储技术。</p><blockquote><p>To start explaining the microservice style it’s useful to compare it to the monolithic style: a monolithic application built as a single unit.</p></blockquote><p>在开始介绍微服务风格之前，将它与单体应用进行比较是很有用的。</p><blockquote><p>Enterprise Applications are often built in three main parts: a client-side user interface (consisting of HTML pages and javascript running in a browser on the user’s machine) a database (consisting of many tables inserted into a common, and usually relational, database management system), and a server-side application.</p></blockquote><p>企业级应用通常由三个主要部分构成：</p><ul><li>客户端用户界面(由在用户机器上的浏览器中运行的HTML页面和javascript组成)</li><li>数据库(由插入到公共(通常是关系)数据库管理系统中的许多表组成)</li><li>服务器端应用程序。</li></ul><blockquote><p>The server-side application will handle HTTP requests, execute domain logic, retrieve and update data from the database, and select and populate HTML views to be sent to the browser.</p></blockquote><p>服务器端应用负责处理HTTP请求、执行域逻辑、从数据库检索和更新数据，并选择和填充要发送到浏览器的HTML视图。</p><blockquote><p>This server-side application is a monolith - a single logical executable[2]. Any changes to the system involve building and deploying a new version of the server-side application.</p></blockquote><p>这个服务器端应用是一个整体 - 一个可执行的逻辑程序[2]。 对系统的任何更改都涉及构建和部署新版本的服务器端应用程序。</p><blockquote><p>Such a monolithic server is a natural way to approach building such a system.All your logic for handling a request runs in a single process, allowing you to use the basic features of your language to divide up the application into classes, functions, and namespaces.With some care, you can run and test the application on a developer’s laptop, and use a deployment pipeline to ensure that changes are properly tested and deployed into production.</p></blockquote><p>这种单体服务器是构建上述系统的常规方式。所有请求的逻辑处理都运行在单个进程中，允许使用语言的基本特性将应用程序划分为类、函数和命名空间。通过这样一些设计，你可以在开发人员的笔记本电脑上运行和测试应用程序，并使用部署流程平台来确保变更可以被正确地测试然后再将其部署到生产环境中。</p><blockquote><p>You can horizontally scale the monolith by running many instances behind a load-balancer.</p></blockquote><p>最后，通过负载均衡器运行许多实例，已达到将这个单体应用进行横向扩展的目的。</p><blockquote><p>Monolithic applications can be successful, but increasingly people are feeling frustrations with them - especially as more applications are being deployed to the cloud .Change cycles are tied together - a change made to a small part of the application, requires the entire monolith to be rebuilt and deployed. </p></blockquote><p>单体应用架构可以很成功的实现，但是随着越来越多的应用程序被部署到云上时，人们对它们将会越来越感到失望。<br>因为对于单体架构的应用来说，每当对一个小小的功能进行修改时，都会涉及到整个应用的重新构建和部署，实际上这个局部功能的改动是不应该对整个应用造成影响的。</p><blockquote><p>Over time it’s often hard to keep a good modular structure, making it harder to keep changes that ought to only affect one module within that module. Scaling requires scaling of the entire application rather than parts of it that require greater resource.</p></blockquote><p>随着时间的推移，单体应用也很难保持一个良好的模块化结构，因为把一个模块的变更影响控制在该模块内将会变得非常困难。当对系统进行扩展时，不得不扩展整个应用系统，而不是对需要更多资源的部分应用程序进行扩展。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/micro/one-more.png" alt=""></p><p>图1：单应用架构和微服务架构</p><blockquote><p>These frustrations have led to the microservice architectural style: building applications as suites of services.</p></blockquote><p>这一系列的问题导致了微服务架构风格产生：以构建一组服务的方式来构建应用系统。</p><blockquote><p>As well as the fact that services are independently deployable and scalable, each service also provides a firm module boundary, even allowing for different services to be written in different programming languages. They can also be managed by different teams .</p></blockquote><p>除了服务是可独立部署和可伸缩的这一事实之外，每个服务还提供了一个可靠的模块边界，甚至允许用不同的编程语言编写不同的服务。它们也可以由不同的团队管理。</p><blockquote><p>We do not claim that the microservice style is novel or innovative, its roots go back at least to the design principles of Unix. But we do think that not enough people consider a microservice architecture and that many software developments would be better off if they used it.</p></blockquote><p>我们并不认为微服务架构风格是新颖或创新的，它的根源至少可以追溯到Unix的设计原则。但是我们认为目前还没有足够多的人考虑微服务体系架构，如果他们都参与使用这个架构风格的话，许多软件的开发将会变得更好。</p><h2 id="Characteristics-of-a-Microservice-Architecture-微服务架构的特征"><a href="#Characteristics-of-a-Microservice-Architecture-微服务架构的特征" class="headerlink" title="Characteristics of a Microservice Architecture-微服务架构的特征"></a>Characteristics of a Microservice Architecture-微服务架构的特征</h2><blockquote><p>We cannot say there is a formal definition of the microservices architectural style, but we can attempt to describe what we see as common characteristics for architectures that fit the label.</p></blockquote><p>我们不能说微服务体系架构风格有一个正式的定义，但是我们可以尝试去描述我们所看到的符合这个标签的体系结构的一些共同特征。</p><blockquote><p>As with any definition that outlines common characteristics, not all microservice architectures have all the characteristics, but we do expect that most microservice architectures exhibit most characteristics.</p></blockquote><p>与任何概述共同特征的定义一样，并非所有的微服务体系架构都具有所有特征，但我们期望常见的微服务都应该有这些特性。</p><blockquote><p>While we authors have been active members of this rather loose community, our intention is to attempt a description of what we see in our own work and in similar efforts by teams we know of. In particular we are not laying down some definition to conform to.</p></blockquote><p>虽然我们作者是这个相当松散的社区的活跃成员，但我们的意图是尝试描述我们在自己的工作中看到的内容，以及我们所知道的团队在类似的工作中所做的工作。特别是，我们不依赖于那些已经明确过的定义。</p><h2 id="Componentization-via-Services-通过服务拆分实现组件化"><a href="#Componentization-via-Services-通过服务拆分实现组件化" class="headerlink" title="Componentization via Services-通过服务拆分实现组件化"></a>Componentization via Services-通过服务拆分实现组件化</h2><blockquote><p>For as long as we’ve been involved in the software industry, there’s been a desire to build systems by plugging together components, much in the way we see things are made in the physical world.</p></blockquote><p>只要我们参与到软件行业，就一直希望通过将组件集成在一起来构建系统，就像我们在物理世界中看到事物的方式一样。</p><blockquote><p>During the last couple of decades we’ve seen considerable progress with large compendiums of common libraries that are part of most language platforms.</p></blockquote><p>在过去的几十年中，我们已经看到了作为大多数语言平台一部分的公共库，已经在大量组合方面取得了相当大的进展。</p><blockquote><p>When talking about components we run into the difficult definition of what makes a component. Our definition is that a component is a unit of software that is independently replaceable and upgradeable.</p></blockquote><p>在讨论组件时，我们遇到了一个困惑是组件到底是什么。我们的定义是，组件一个可独立替换和升级的软件单元。</p><blockquote><p>Microservice architectures will use libraries, but their primary way of componentizing their own software is by breaking down into services.</p></blockquote><p>微服务架构会使用库，但他们将自己的软件组件化的主要方式是把它拆分成服务</p><blockquote><p>We define libraries as components that are linked into a program and called using in-memory function calls, while services are out-of-process components who communicate with a mechanism such as a web service request, or remote procedure call. (This is a different concept to that of a service object in many OO programs [3].)</p></blockquote><p>我们将库定义为链接到程序并使用内存内函数调用的组件，而服务是进程外组件，它们通过诸如web服务请求或远程过程调用之类的机制进行通信。（这与许多面向对象程序中的服务对象的概念不同[3]。）</p><blockquote><p>One main reason for using services as components (rather than libraries) is that services are independently deployable.</p></blockquote><p>将服务用作组件（而不是库）的一个主要原因是服务可以独立部署。</p><blockquote><p>If you have an application <a href="https://martinfowler.com/articles/microservices.html#footnote-application" target="_blank" rel="noopener">[4]</a> that consists of a multiple libraries in a single process, a change to any single component results in having to redeploy the entire application.</p></blockquote><p>如果您在单个进程中有一个由多个库组成的应用程序[4]，则对任何单个组件的更改都会导致必须重新部署整个应用程序。</p><blockquote><p>But if that application is decomposed into multiple services, you can expect many single service changes to only require that service to be redeployed.</p></blockquote><p>但是，如果将该应用程序分解为多个服务，那你只需要重新部署那个改变的服务就可以。</p><blockquote><p>That’s not an absolute, some changes will change service interfaces resulting in some coordination, but the aim of a good microservice architecture is to minimize these through cohesive service boundaries and evolution mechanisms in the service contracts.</p></blockquote><p>但是这也不是绝对的，比如一些更改将会更改服务接口，从而导致一些协调问题，但是一个好的微服务体系结构的目标是通过服务契约中的内聚服务边界和演进机制将这些更改最小化。</p><blockquote><p>Another consequence of using services as components is a more explicit component interface.Most languages do not have a good mechanism for defining an explicit <a href="https://martinfowler.com/bliki/PublishedInterface.html" target="_blank" rel="noopener">Published Interface</a>.Often it’s only documentation and discipline that prevents clients breaking a component’s encapsulation, leading to overly-tight coupling between components.Services make it easier to avoid this by using explicit remote call mechanisms.</p></blockquote><p>将服务用作组件的另一个结果是将拥有更清晰的组件接口。大多数语言都没有定义显式发布接口的良好机制。通常只有文档和规则的说明来防止客户端破坏组件的封装，避免组件之间的耦合过于紧密。但是通过使用显式远程调用机制，则更容易避免这种情况。</p><blockquote><p>Using services like this does have downsides. Remote calls are more expensive than in-process calls, and thus remote APIs need to be coarser-grained, which is often more awkward to use.</p></blockquote><p>但是这种方式也有不足的地方。主要是远程调用比进程内调用更昂贵，因此远程api需要是粗粒度的，但这会比较难用。</p><blockquote><p>If you need to change the allocation of responsibilities between components, such movements of behavior are harder to do when you’re crossing process boundaries.</p></blockquote><p>如果您需要更改组件之间的职责分配，那么当你需要跨进程时，这种行为的迁移将更加困难。</p><blockquote><p>At a first approximation, we can observe that services map to runtime processes, but that is only a first approximation.</p></blockquote><p>一种可能是，我们可以观察到服务映射到运行时进程上，但这只是一种可能。</p><blockquote><p>A service may consist of multiple processes that will always be developed and deployed together, such as an application process and a database that’s only used by that service.</p></blockquote><p>服务可以由多个进程组成，这些进程可以同时开发和部署，例如一个应用程序进程和一个只能由这个服务使用的数据库。</p><h3 id="Organized-around-Business-Capabilities-围绕业务功能组织"><a href="#Organized-around-Business-Capabilities-围绕业务功能组织" class="headerlink" title="Organized around Business Capabilities-围绕业务功能组织"></a>Organized around Business Capabilities-围绕业务功能组织</h3><blockquote><p>When looking to split a large application into parts, often management focuses on the technology layer, leading to UI teams, server-side logic teams, and database teams. </p></blockquote><p>当希望将大型应用程序分解为多个模块时，管理通常关注于技术层，重要的包括UI团队、服务器端逻辑团队和数据库团队。</p><blockquote><p>When teams are separated along these lines, even simple changes can lead to a cross-team project taking time and budgetary approval.</p></blockquote><p>当团队按照这些原则分开时，即使是简单的更改也可能涉及到跨团队沟通，那么这样项目就会需要增加时间和预算审批等成本。</p><blockquote><p>A smart team will optimise around this and plump for the lesser of two evils - just force the logic into whichever application they have access to. Logic everywhere in other words. This is an example of Conway’s Law<a href="https://martinfowler.com/articles/microservices.html#footnote-conwayslaw" target="_blank" rel="noopener">[5]</a> in action.</p></blockquote><p>一个优秀的团队将围绕这一点进行改善，并选择两害相权取其轻——只需将逻辑强制应用到他们能够访问的任何应用程序中。换句话说，逻辑无处不在。这是康威定律[5]的一个例子。</p><blockquote><p>Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization’s communication structure.<br>任何设计系统(广义定义)的组织都会产生一个结构是组织通信结构副本的设计。<br>– Melvyn Conway, 1967</p></blockquote><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/micro/kangwei.png" alt=""><br>图2:康韦定律的作用</p><blockquote><p>The microservice approach to division is different, splitting up into services organized around <strong>business capability</strong>. </p></blockquote><p>划分微服务方法是不同的，但更倾向于围绕业务功能的组织来进行服务划分。</p><blockquote><p>Such services take a broad-stack implementation of software for that business area, including user-interface, persistant storage, and any external collaborations.</p></blockquote><p>这些服务在商业领域软件上有广泛实施，包括用户界面、持久性存储和任何外部协作。</p><blockquote><p>Consequently the teams are cross-functional, including the full range of skills required for the development: user-experience, database, and project management.</p></blockquote><p>因此，团队是跨职能的，包括开发所需的全方位技能:用户体验、数据库和项目管理。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/micro/service-boundle.png" alt=""><br>图3:由团队边界加强的服务边界</p><blockquote><p>One company organised in this way is <a href="http://www.comparethemarket.com/" target="_blank" rel="noopener">www.comparethemarket.com</a>. Cross functional teams are responsible for building and operating each product and each product is split out into a number of individual services communicating via a message bus.</p></blockquote><p><a href="http://www.comparethemarket.com" target="_blank" rel="noopener">www.comparethemarket.com</a> 就是采样这样组织形式的一家公司。跨职能团队负责同时构建和运维每个产品，每个产品都被划分为许多单个服务，服务间再通过消息总线进行通信。</p><blockquote><p>Large monolithic applications can always be modularized around business capabilities too, although that’s not the common case.Certainly we would urge a large team building a monolithic application to divide itself along business lines. </p></blockquote><p>大型集中式应用程序也可以围绕业务功能进行模块划分，尽管这种情况并不常见。当然，我们会敦促构建完整应用程序的大型团队沿着业务线进行自我划分。</p><blockquote><p>The main issue we have seen here, is that they tend to be organised around <em>too many</em> contexts.</p></blockquote><p>我们在这里看到的主要问题是，它们往往围绕太多的上下文背景进行组织（依赖太多，包袱太重）。</p><blockquote><p>If the monolith spans many of these modular boundaries it can be difficult for individual members of a team to fit them into their short-term memory.Additionally we see that the modular lines require a great deal of discipline to enforce. The necessarily more explicit separation required by service components makes it easier to keep the team boundaries clear.</p></blockquote><p>如果整个应用会跨越许多这样的模块边界时，这对于团队中的一些成员来说也很难短期内可以掌握。此外，我们看到模块化开发需要大量的规范来遵守执行。但是对于服务组件这种需要进行明确的业务划分的要求的情况下，可以使得保持团队职能边界清晰变得更加容易。</p><h3 id="Products-not-Projects-产品不是项目"><a href="#Products-not-Projects-产品不是项目" class="headerlink" title="Products not Projects-产品不是项目"></a>Products not Projects-产品不是项目</h3><blockquote><p>Most application development efforts that we see use a project model: where the aim is to deliver some piece of software which is then considered to be completed. On completion the software is handed over to a maintenance organization and the project team that built it is disbanded.</p></blockquote><p>我们看到的大多数应用程序开发工作都使用这样的项目模式：目标是交付一个他们认为完成的软件。接着，软件被移交给运维团队，项目开发团队被解散。</p><blockquote><p>Microservice proponents tend to avoid this model, preferring instead the notion that a team should own a product over its full lifetime. </p></blockquote><p>微服务的支持者倾向于避免这种模式，他们更希望团队应该负责产品的整个生命周期。</p><blockquote><p>A common inspiration for this is Amazon’s notion of <a href="https://queue.acm.org/detail.cfm?id=1142065" target="_blank" rel="noopener">“you build, you run it”</a> where a development team takes full responsibility for the software in production.This brings developers into day-to-day contact with how their software behaves in production and increases contact with their users, as they have to take on at least some of the support burden. </p></blockquote><p>一个常见的灵感是Amazon的“你构建，你运行它”的概念，在这个概念中，开发团队需要对产品承担全部责任。这使得开发人员能够在日常中关注到软件运行情况，并增加与用户的联系，同时必须承担一些支持工作。</p><blockquote><p>The product mentality, ties in with the linkage to business capabilities. Rather than looking at the software as a set of functionality to be completed, there is an on-going relationship where the question is how can software assist its users to enhance the business capability.</p></blockquote><p>产品的理念，与业务能力联系在一起。与其将软件看作一组要完成的功能，还不如将软件看作是一种持续的关系，在这种关系中，软件是如何帮助用户增强业务能力。</p><blockquote><p>There’s no reason why this same approach can’t be taken with monolithic applications, but the smaller granularity of services can make it easier to create the personal relationships between service developers and their users.</p></blockquote><p>没有理由不能在单体应用程序中采用相同的方法，但是服务粒度越小，就越容易在服务开发人员和用户之间创建个人关系。</p><h3 id="Smart-endpoints-and-dumb-pipes-智能端点和轻量级通信"><a href="#Smart-endpoints-and-dumb-pipes-智能端点和轻量级通信" class="headerlink" title="Smart endpoints and dumb pipes-智能端点和轻量级通信"></a>Smart endpoints and dumb pipes-智能端点和轻量级通信</h3><blockquote><p>When building communication structures between different processes, we’ve seen many products and approaches that stress putting significant smarts into the communication mechanism itself.</p></blockquote><p>在构建不同进程之间的通信结构时，我们看到许多产品和方法都强调在通信机制本身中投入大量的方案。</p><blockquote><p>A good example of this is the Enterprise Service Bus (ESB), where ESB products often include sophisticated facilities for message routing, choreography, transformation, and applying business rules.</p></blockquote><p>这方面的一个很好的例子是企业服务总线(ESB)，ESB产品通常包含用于消息路由、编排、转换和应用业务规则的复杂工具。</p><blockquote><p>The microservice community favours an alternative approach: <em>smart endpoints and dumb pipes</em>. </p></blockquote><p>在微服务社区则支持另一种方法:智能端点和轻量级通信。</p><blockquote><p>Applications built from microservices aim to be as decoupled and as cohesive as possible - they own their own domain logic and act more as filters in the classical Unix sense - receiving a request, applying logic as appropriate and producing a response.</p></blockquote><p>使用微服务构建的应用程序旨在尽可能地解耦和内聚 - 采用独立的业务逻辑，表现的更像经典Unix意义上的过滤器一样，接受请求、处理业务逻辑，然后返回响应。</p><blockquote><p>These are choreographed using simple RESTish protocols rather than complex protocols such as WS-Choreography or BPEL or orchestration by a central tool.</p></blockquote><p>它们更喜欢简单的REST风格，而不是使用复杂的协议，如WS-Choreography、BPEL或集中式框架。</p><blockquote><p>The two protocols used most commonly are HTTP request-response with resource API’s and lightweight messaging<a href="https://martinfowler.com/articles/microservices.html?spm=a2c4e.11153940.blogcont2764.12.fd5b2766lUOPyQ#footnote-protobufs" target="_blank" rel="noopener">[8]</a>.</p></blockquote><p>最常用的两种协议是带有资源API的HTTP请求-响应协议和轻量级消息传递[8]协议。 第一个是最好的描述是:善于利用网络，而不是限制。</p><blockquote><p>Be of the web, not behind the web<br><a href="https://www.amazon.com/gp/product/0596805829?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0596805829" target="_blank" rel="noopener">– Ian Robinson</a></p></blockquote><blockquote><p>Microservice teams use the principles and protocols that the world wide web (and to a large extent, Unix) is built on. Often used resources can be cached with very little effort on the part of developers or operations folk.</p></blockquote><p>微服务团队使用构建在互联网(很大程度上是Unix)上的原则和协议。开发人员或操作人员只需很少的精力就可以缓存经常使用的资源。</p><blockquote><p>The second approach in common use is messaging over a lightweight message bus. The infrastructure chosen is typically dumb (dumb as in acts as a message router only) - simple implementations such as RabbitMQ or ZeroMQ don’t do much more than provide a reliable asynchronous fabric - the smarts still live in the end points that are producing and consuming messages; in the services.</p></blockquote><p>第二种常用的方式是通过轻量级消息总线进行消息传递。所选择的基础设施通常是单一的(只负责消息路由)——像RabbitMQ或者ZeroMQ这样的简单的实现，连可靠的异步机制都没有提供——导致仍然需要依赖产生或者消费消息的终端或者服务来处理这类问题。</p><blockquote><p>In a monolith, the components are executing in-process and communication between them is via either method invocation or function call. The biggest issue in changing a monolith into microservices lies in changing the communication pattern. A naive conversion from in-memory method calls to RPC leads to chatty communications which don’t perform well. Instead you need to replace the fine-grained communication with a coarser -grained approach.</p></blockquote><p>在单体应用中，组件在进程内执行，它们之间的通信要么通过方法调用要么通过回调函数。将单体架构变为微服务架构的最大问题在于改变通信模式。 从内存中的方法调用到RPC调用的简单转换会导致通信性能的下降。因此，你需要用更粗粒度的方法替换细粒度的通信。</p><h3 id="Decentralized-Governance-分散治理"><a href="#Decentralized-Governance-分散治理" class="headerlink" title="Decentralized Governance-分散治理"></a>Decentralized Governance-分散治理</h3><blockquote><p>One of the consequences of centralised governance is the tendency to standardise on single technology platforms. Experience shows that this approach is constricting - not every problem is a nail and not every solution a hammer. We prefer using the right tool for the job and while monolithic applications can take advantage of different languages to a certain extent, it isn’t that common.</p></blockquote><p>集中治理的优势在于可以在单一技术平台上实现标准化。经验表明，这种方法是有局限性的——不是每个问题都是很棘手，也不是每个解决方案都是万能的。我们更喜欢使用适合这项工作的工具，虽然单体应用程序可以在一定程度上利用不同的语言，但这种情况并不常见。</p><blockquote><p>Splitting the monolith’s components out into services we have a choice when building each of them. You want to use Node.js to standup a simple reports page? Go for it. C++ for a particularly gnarly near-real-time component? Fine. You want to swap in a different flavour of database that better suits the read behaviour of one component? We have the technology to rebuild him.</p></blockquote><p>把整体式框架中的组件，拆分成不同的服务，这样构建它们时就会有更多的选择性。 您想使用Node.js站立一个简单的报告页面吗？ 去吧。 C ++是否适用于特别近乎实时的组件？做吧。 您想要交换不同风格的数据库，以更好地适应一个组件的读取行为？ 我们同样有重构它的技术。</p><blockquote><p>Of course, just because you <em>can</em> do something, doesn’t mean you <em>should</em> - but partitioning your system in this way means you have the option.</p></blockquote><p>当然，仅仅因为你可以做一些事情，并不意味着你就应该这么做——但是以这种方式对系统进行划分意味着你可以选择。</p><blockquote><p>Teams building microservices prefer a different approach to standards too. Rather than use a set of defined standards written down somewhere on paper they prefer the idea of producing useful tools that other developers can use to solve similar problems to the ones they are facing.These tools are usually harvested from implementations and shared with a wider group, sometimes, but not exclusively using an internal open source model. Now that git and github have become the de facto version control system of choice, open source practices are becoming more and more common in-house .</p></blockquote><p>与其选用一组写在纸上已经定义好的标准，他们更喜欢编写一些有用的工具，来让其他开发者能够使用，以便解决那些和他们所面临的问题相似的问题。这些工具通常源自他们的微服务实施过程，并且被分享到更大规模的组织中，这种分享有时会使用内部开源的模式来进行。现在，git和github已经成为事实上的首选版本控制系统。在企业内部，开源的做法也正在变得越来越普遍。</p><blockquote><p>Netflix is a good example of an organisation that follows this philosophy. Sharing useful and, above all, battle-tested code as libraries encourages other developers to solve similar problems in similar ways yet leaves the door open to picking a different approach if required. Shared libraries tend to be focused on common problems of data storage, inter-process communication and as we discuss further below, infrastructure automation.</p></blockquote><p>Netflix公司是遵循上述理念的好例子。将实用且经过实战检验的代码以软件库的形式共享出来，能鼓励其他开发人员以相似的方式来解决相似的问题，当然也为在需要的时候选用不同的方案留了一扇门。共享软件库往往集中在解决这样的常见问题，即数据存储、进程间的通信和下面要进一步讨论的基础设施的自动化。</p><blockquote><p>For the microservice community, overheads are particularly unattractive. That isn’t to say that the community doesn’t value service contracts. Quite the opposite, since there tend to be many more of them. It’s just that they are looking at different ways of managing those contracts. Patterns like <a href="https://martinfowler.com/bliki/TolerantReader.html" target="_blank" rel="noopener">Tolerant Reader</a> and <a href="https://martinfowler.com/articles/consumerDrivenContracts.html" target="_blank" rel="noopener">Consumer-Driven Contracts</a> are often applied to microservices. These aid service contracts in evolving independently. Executing consumer driven contracts as part of your build increases confidence and provides fast feedback on whether your services are functioning. Indeed we know of a team in Australia who drive the build of new services with consumer driven contracts. They use simple tools that allow them to define the contract for a service. This becomes part of the automated build before code for the new service is even written. The service is then built out only to the point where it satisfies the contract - an elegant approach to avoid the ‘YAGNI’<a href="https://martinfowler.com/articles/microservices.html#footnote-YAGNI" target="_blank" rel="noopener">[9]</a>dilemma when building new software. These techniques and the tooling growing up around them, limit the need for central contract management by decreasing the temporal coupling between services.</p></blockquote><p>对于微服务社区来说，管理费用特别缺乏吸引力。 这并不是说社区不重视服务合同。 恰恰相反，因为往往会有更多。只是他们正在寻找管理这些合同的不同方式。像“容错读取”和“消费者驱动的契约”这样的模式，经常被运用到微服务中。这些都有助于服务契约进行独立演进。将执行“ 消费者驱动的契约 ”做为软件构建的一部分，能增强开发团队的信心，并提供所依赖的服务是否正常工作的快速反馈。实际上，我们了解到一个在澳大利亚的团队就是使用“ 消费者驱动的契约 ”来驱动构建多个新服务的。他们使用了一些简单的工具，来针对每一个服务定义契约。甚至在新服务的代码编写之前，这件事就已经成为自动化构建的一部分了。接下来服务仅被构建到刚好能满足契约的程度——这是一个在构建新软件时避免YAGNI <strong>[9]</strong> 困境的优雅方法。这些技术和工具在契约周边生长出来，由于减少了服务之间在时域(temporal)上的耦合，从而抑制了对中心契约管理的需求。</p><blockquote><p>Perhaps the apogee of decentralised governance is the build it / run it ethos popularised by Amazon. Teams are responsible for all aspects of the software they build including operating the software 24/7. Devolution of this level of responsibility is definitely not the norm but we do see more and more companies pushing responsibility to the development teams. Netflix is another organisation that has adopted this ethos<a href="https://martinfowler.com/articles/microservices.html#footnote-netflix-flowcon" target="_blank" rel="noopener">[11]</a>. Being woken up at 3am every night by your pager is certainly a powerful incentive to focus on quality when writing your code. These ideas are about as far away from the traditional centralized governance model as it is possible to be.</p></blockquote><p>也许分散治理治理技术的极盛时期，就是亚马逊的“你构建，你运行”的理念开始普及的时候。 每个团队负责他们构建的软件的全生命周期，包括持续的软件的运维。 把运维的这种能力放到团队的做法目前还不是主流的，但我们确实看到越来越多的公司将运维的职责推向开发团队。 Netflix是另一个采用这种模式的组织[11]。 如果你不想每天凌晨3点被喊起来去改bug，那么你就该在编写代码时投入更多的精力和时间。 但是这些想法与传统的集中治理模式相差甚远。</p><h3 id="Decentralized-Data-Management-分散的数据管理"><a href="#Decentralized-Data-Management-分散的数据管理" class="headerlink" title="Decentralized Data Management-分散的数据管理"></a>Decentralized Data Management-分散的数据管理</h3><blockquote><p>Decentralization of data management presents in a number of different ways. At the most abstract level, it means that the conceptual model of the world will differ between systems. This is a common issue when integrating across a large enterprise, the sales view of a customer will differ from the support view. Some things that are called customers in the sales view may not appear at all in the support view. Those that do may have different attributes and (worse) common attributes with subtly different semantics.</p></blockquote><p>分散化的数据管理以多种不同的方式呈现。 在最抽象的层面上来看的话，就意味着各个系统对客观世界所构建的概念模型是彼此各不相同的。 这是在大型企业中集成时的常见问题，比如对于客户来说，销售视角和支持视角肯定是不同的。 销售视角中客户的某些内容可能根本不会出现在支持视角中。即使在两个视角中都能看到的事物，那么各自关注的核心信息也是不同的。极端情况下，甚至两个视角中具有相同属性的事物，或许在语义上也会有细的差距。</p><blockquote><p>This issue is common between applications, but can also occur _within_applications, particular when that application is divided into separate components. A useful way of thinking about this is the Domain-Driven Design notion of <a href="https://martinfowler.com/bliki/BoundedContext.html" target="_blank" rel="noopener">Bounded Context</a>. DDD divides a complex domain up into multiple bounded contexts and maps out the relationships between them. This process is useful for both monolithic and microservice architectures, but there is a natural correlation between service and context boundaries that helps clarify, and as we describe in the section on business capabilities, reinforce the separations.</p></blockquote><p>上述问题在不同的应用程序之间经常出现，当然应用程序内部也会出现，尤其是当一个应用程序被分成不同组件的情况下。思考这类问题的一个可靠的方法，就是使用领域驱动设计（Domain-Driven Design, DDD）中的“限界上下文”的概念。DDD将一个复杂的领域划分为多个限界上下文，并且将其相互之间的关系用图画出来。这一划分过程对于单体架构和微服务架构两者都是有用的，而且就像前面有关“业务功能”一节中所讨论的那样，在服务和各个限界上下文之间所存在的自然的联动关系，能有助于澄清和强化这种划分。</p><blockquote><p>As well as decentralizing decisions about conceptual models, microservices also decentralize data storage decisions. While monolithic applications prefer a single logical database for persistant data, enterprises often prefer a single database across a range of applications - many of these decisions driven through vendor’s commercial models around licensing. Microservices prefer letting each service manage its own database, either different instances of the same database technology, or entirely different database systems - an approach called <a href="https://martinfowler.com/bliki/PolyglotPersistence.html" target="_blank" rel="noopener">Polyglot Persistence</a>. You can use polyglot persistence in a monolith, but it appears more frequently with microservices.</p></blockquote><p>除了关于概念模型的分散决策之外，微服务还分散了数据存储决策。 虽然单体应用程序通常都是使用单个逻辑数据库来存储持久性数据，但企业往往喜欢一系列单体应用共用一个单独的数据库 - 其中许多决策是通过供应商围绕许可的商业模型来实现的（供应商的版权商业模式所驱动）。 微服务体系中更偏向让每个服务实例管理自己的数据库，可以是相同数据库技术的不同实例，也可以是完全不同的数据库系统 – 这种方法称为 Polyglot Persistence（多语言持久化）。在一个单体系统中也能使用多语种持久化，但它在微服务中更常出现。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/micro/persistence.png" alt=""></p><blockquote><p>Decentralizing responsibility for data across microservices has implications for managing updates. The common approach to dealing with updates has been to use transactions to guarantee consistency when updating multiple resources. This approach is often used within monoliths.</p></blockquote><p>跨微服务分散数据责任对管理更新具有影响。处理软件更新的常用方法，是当更新多个资源的时候，需要使用事务来保证一致性。这种方法经常在单块系统中被采用。</p><blockquote><p>Using transactions like this helps with consistency, but imposes significant temporal coupling, which is problematic across multiple services. Distributed transactions are notoriously difficult to implement and as a consequence microservice architectures <a href="http://www.eaipatterns.com/ramblings/18_starbucks.html" target="_blank" rel="noopener">emphasize transactionless coordination between services</a>, with explicit recognition that consistency may only be eventual consistency and problems are dealt with by compensating operations.</p></blockquote><p>通过使用事务，有助于保持数据一致性。但对时间的消耗是严重的，而当在多个服务之间处理事务时也会出现一致性问题。众所周知，分布式事务很难实现，因此微服务架构强调服务间事务协调，明确认识到一致性可能只是最终的一致性及通过补偿操作来处理问题。</p><blockquote><p>Choosing to manage inconsistencies in this way is a new challenge for many development teams, but it is one that often matches business practice. Often businesses handle a degree of inconsistency in order to respond quickly to demand, while having some kind of reversal process to deal with mistakes. The trade-off is worth it as long as the cost of fixing mistakes is less than the cost of lost business under greater consistency.</p></blockquote><p>对于许多开发团队来说，选择以这种方式管理数据的“不一致性”问题是一个新的挑战，但是这又是一种非常常见的业务实践场景。为了对需求做出快速反应，企业通常会允许一定程度上的数据“不一致性”，但同时也会采用一些恢复的进程来处理这种错误 。只要业务上处理强一致性成本比处理错误的成本少时，那么这种“ 不一致性”地管理数据的权衡就是值得的。</p><h3 id="Infrastructure-Automation-基础设施高度自动化"><a href="#Infrastructure-Automation-基础设施高度自动化" class="headerlink" title="Infrastructure Automation-基础设施高度自动化"></a>Infrastructure Automation-基础设施高度自动化</h3><blockquote><p>Infrastructure automation techniques have evolved enormously over the last few years - the evolution of the cloud and AWS in particular has reduced the operational complexity of building, deploying and operating microservices.</p></blockquote><p>在过去几年里，基础设施自动化技术有了很大的发展——云计算和AWS的发展降低了构建、部署和运维微服务的复杂性。</p><blockquote><p>Many of the products or systems being build with microservices are being built by teams with extensive experience of <a href="https://martinfowler.com/bliki/ContinuousDelivery.html" target="_blank" rel="noopener">Continuous Delivery</a> and it’s precursor, <a href="https://martinfowler.com/articles/continuousIntegration.html" target="_blank" rel="noopener">Continuous Integration</a>. Teams building software this way make extensive use of infrastructure automation techniques. This is illustrated in the build pipeline shown below.</p></blockquote><p>许多使用微服务构建的产品或系统都是由具有大量 持续交付与其前身持续集成 经验的团队构建的。以这种方式构建软件的团队广泛使用了基础设施自动化技术。如下图的构建流水线所示：</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/micro/pipeline.png" alt=""></p><p>图5:基本构建流程</p><blockquote><p>Since this isn’t an article on Continuous Delivery we will call attention to just a couple of key features here. We want as much confidence as possible that our software is working, so we run lots of <strong>automated tests</strong>. Promotion of working software ‘up’ the pipeline means we <strong>automate deployment</strong> to each new environment.</p></blockquote><p>由于这不是一篇关于持续交付的文章，我们将在这里只关注几个关键特性。我们希望我们的软件能够正常工作，所以我们运行了大量的自动化测试。让可工作的软件达到“晋级”(Promotion)状态从而“推上”流水线，就意味着可以在 每一个新的环境中，对软件进行 <strong>自动化部署</strong> 。</p><blockquote><p>A monolithic application will be built, tested and pushed through these environments quite happlily. It turns out that once you have invested in automating the path to production for a monolith, then deploying _more_applications doesn’t seem so scary any more. Remember, one of the aims of CD is to make deployment boring, so whether its one or three applications, as long as its still boring it doesn’t matter<a href="https://martinfowler.com/articles/microservices.html#footnote-trickycd" target="_blank" rel="noopener">[12]</a>.</p></blockquote><p>对于单体应用来说，可以轻松的在上述的各个环境中进行构建、测试和发布。其结果是，一旦投入到自动化平台， 那么部署更多的应用系统似乎就不再可怕。记住，持续交付的目的之一，是让“部署”工作变得“无聊”。所以不管是一个还是三个应用系统，只要是部署工作，就依旧很“无聊”，那么就没什么可担心的了 <strong>[12]</strong> 。</p><blockquote><p>Another area where we see teams using extensive infrastructure automation is when managing microservices in production. In contrast to our assertion above that as long as deployment is boring there isn’t that much difference between monoliths and microservices, the operational landscape for each can be strikingly different.</p></blockquote><p>另一个方面，我们发现使用微服务的团队更加依赖于基础设施的自动化。与前面我们对比单体系统和微服务所说的正相反，只要部署工作很无聊，那么在这一点上单块系统和微服务就没什么区别。然而，两者在运维领域的情况却截然不同。</p><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/micro/multi-module.png" alt=""><br>图6:模块部署通常是不同的</p><h3 id="Design-for-failure-“容错”设计"><a href="#Design-for-failure-“容错”设计" class="headerlink" title="Design for failure-“容错”设计"></a>Design for failure-“容错”设计</h3><blockquote><p>A consequence of using services as components, is that applications need to be designed so that they can tolerate the failure of services. Any service call could fail due to unavailability of the supplier, the client has to respond to this as gracefully as possible. This is a disadvantage compared to a monolithic design as it introduces additional complexity to handle it. The consequence is that microservice teams constantly reflect on how service failures affect the user experience. Netflix’s <a href="https://github.com/Netflix/SimianArmy" target="_blank" rel="noopener">Simian Army</a> induces failures of services and even datacenters during the working day to test both the application’s resilience and monitoring.</p></blockquote><p>使用各个微服务来替代组件，其结果是各个应用程序需要设计成能够容忍这些服务所出现的故障。如果服务提供方不可用，那么任何对该服务的调用都会出现故障。客户端要尽可能优雅地应对这种情况。与单体应用设计相比，这是一个劣势。因为这会引人额外的复杂性来处理这种情况。这需要微服务团队要时刻考虑到服务故障情况下的用户体验。Netflix公司所研发的开源测试工具Simian Army，可以为每个应用的服务及数据中心提供日常故障检测和恢复。</p><blockquote><p>This kind of automated testing in production would be enough to give most operation groups the kind of shivers usually preceding a week off work. This isn’t to say that monolithic architectural styles aren’t capable of sophisticated monitoring setups - it’s just less common in our experience.</p></blockquote><p>这种在生产环境中所进行的自动化测试，能足以让大多数运维组织兴奋得浑身颤栗，就像在一周的长假即将到来前那样。这并不是说单体架构风格不能构建先进的监控系统——只是根据我们的经验，这在单体系统中并不常见罢了。</p><blockquote><p>Since services can fail at any time, it’s important to be able to detect the failures quickly and, if possible, automatically restore service. Microservice applications put a lot of emphasis on real-time monitoring of the application, checking both architectural elements (how many requests per second is the database getting) and business relevant metrics (such as how many orders per minute are received). Semantic monitoring can provide an early warning system of something going wrong that triggers development teams to follow up and investigate.</p></blockquote><p>因为每个服务都可能在任何时候发生故障，所以下面两件事就变得很重要，即 快速故障检测 和 自动恢复。各个微服务的应用都将大量的精力放到了应用程序的实时监控上，来检查“架构元素指标”（例如数据库每秒收到多少请求）和“业务相关指标”（例如系统每分钟收到多少订单）。当系统某个地方出现问题，监控系统能提供一个预警，来触发开发团队进行后续的跟进和调查工作。</p><blockquote><p>This is particularly important to a microservices architecture because the microservice preference towards choreography and <a href="https://martinfowler.com/eaaDev/EventCollaboration.html" target="_blank" rel="noopener">event collaboration</a> leads to emergent behavior. While many pundits praise the value of serendipitous emergence, the truth is that emergent behavior can sometimes be a bad thing. Monitoring is vital to spot bad emergent behavior quickly so it can be fixed.</p></blockquote><p>这对于一个微服务架构是非常重要的，因为微服务之间交互通信随时都可能出现一些紧急的意外情况。尽管许多权威人士对于突发情况的价值持积极态度，但事实上，突发情况有时可能会酿成大的灾难。在能够快速发现有坏处的突发情况并进行修复的方面，监控是至关重要的。</p><blockquote><p>Monoliths can be built to be as transparent as a microservice - in fact, they should be. The difference is that you absolutely need to know when services running in different processes are disconnected. With libraries within the same process this kind of transparency is less likely to be useful.</p></blockquote><p>单体系统也能构建像微服务那样来实现透明的一套监控系统——实际上，它们也应该如此。差别是，绝对需要知道那些运行在不同进程中的服务，在何时断掉了。而如果在同一个进程内使用软件库的话，这种透明的监控系统就用处不大了。</p><blockquote><p>Microservice teams would expect to see sophisticated monitoring and logging setups for each individual service such as dashboards showing up/down status and a variety of operational and business relevant metrics. Details on circuit breaker status, current throughput and latency are other examples we often encounter in the wild.</p></blockquote><p>微服务团队希望在每一个单独的服务中，都能看到良好的监控和日志记录装置。例如显示“运行/宕机”状态的仪表盘，和各种运维和业务相关的指标。另外我们经常在工作中会碰到这样一些细节，即断路器的状态、当前的吞吐率和延迟，以及其他一些例子。</p><h3 id="Evolutionary-Design-“演进式”设计"><a href="#Evolutionary-Design-“演进式”设计" class="headerlink" title="Evolutionary Design-“演进式”设计"></a>Evolutionary Design-“演进式”设计</h3><blockquote><p>Microservice practitioners, usually have come from an evolutionary design background and see service decomposition as a further tool to enable application developers to control changes in their application without slowing down change. Change control doesn’t necessarily mean change reduction - with the right attitudes and tools you can make frequent, fast, and well-controlled changes to software.</p></blockquote><p>微服务的从业者们，通常具有演进式设计的背景，他们把服务分解成进一步的工具，以达到可以让应用开发者在不改变速度情况下，控制他们应用的需求变更。变更控制并不一定意味着要减少变化——在正确的方式和工具的帮助下，能在软件中让变更发生得频繁、快速且有良好的控制。</p><blockquote><p>Whenever you try to break a software system into components, you’re faced with the decision of how to divide up the pieces - what are the principles on which we decide to slice up our application? The key property of a component is the notion of independent replacement and upgradeability<a href="https://martinfowler.com/articles/microservices.html#footnote-RCA" target="_blank" rel="noopener">[13]</a> - which implies we look for points where we can imagine rewriting a component without affecting its collaborators. Indeed many microservice groups take this further by explicitly expecting many services to be scrapped rather than evolved in the longer term.</p></blockquote><p>每当试图要将软件系统分解为各个组件时，就会面临这样的问题，即如何进行切分——我们决定切分应用系统时应该遵循的原则是什么？首要的因素，组件可以被独立替换和更新的 <strong>[13]</strong> ——这意味着，需要寻找这些点，即想象着能否在其中一个点上重写该组件，而无须影响该组件的其他合作组件。事实上，许多微服务团队考虑的更多的是，如何明确地预期许多服务将来会报废，而不是守着这些服务做长期迭代。</p><blockquote><p>The Guardian website is a good example of an application that was designed and built as a monolith, but has been evolving in a microservice direction. The monolith still is the core of the website, but they prefer to add new features by building microservices that use the monolith’s API. This approach is particularly handy for features that are inherently temporary, such as specialized pages to handle a sporting event. Such a part of the website can quickly be put together using rapid development languages, and removed once the event is over. We’ve seen similar approaches at a financial institution where new services are added for a market opportunity and discarded after a few months or even weeks.</p></blockquote><p>Guardian网站就是这方面的一个优秀的例子。它初期被设计和构建成一个单体架构应用，然而它已经开始向微服务方向进行迭代演进了。原先的单体系统依旧是该网站的核心，但是在添加新特性时，他们愿意以构建微服务的方式来进行添加，而这些微服务会去调用原先那个单体系统的API。当在开发那些本身就带有临时性特点的新特性时， 这种方法就特别方便，例如开发那些报道一个体育赛事的专门页面。当使用一些快速的开发语言时，像这样的网站页面就能被快速地整合起来。而一旦赛事结束，这样页面就可以被删除。在一个金融机构中，我们已经看到了一些相似的做法，即针对一个市场机会，一些新的服务可以被添加进来。然后在几个月甚至几周之后，这些新服务就作废了。</p><blockquote><p>This emphasis on replaceability is a special case of a more general principle of modular design, which is to drive modularity through the pattern of change <a href="https://martinfowler.com/articles/microservices.html#footnote-beck-rate-of-change" target="_blank" rel="noopener">[14]</a>. You want to keep things that change at the same time in the same module. Parts of a system that change rarely should be in different services to those that are currently undergoing lots of churn. If you find yourself repeatedly changing two services together, that’s a sign that they should be merged.</p></blockquote><p>这种强调可更换性的特点，是模块化设计一般性原则的一个特例，需求变更通过进行模块化的方式实现。大家都愿意将那些能在同时发生变化的东西，放到同一个模块中。系统中那些很少发生变化的部分，应该被放到不同的服务中，以区别于那些当前正在经历大量变动(churn)的部分。如果发现需要同时反复变更两个服务时，这就是它们两个需要被合并的一个信号。</p><blockquote><p>Putting components into services adds an opportunity for more granular release planning. With a monolith any changes require a full build and deployment of the entire application. With microservices, however, you only need to redeploy the service(s) you modified. This can simplify and speed up the release process. The downside is that you have to worry about changes to one service breaking its consumers. The traditional integration approach is to try to deal with this problem using versioning, but the preference in the microservice world is to <a href="https://martinfowler.com/articles/enterpriseREST.html#versioning" target="_blank" rel="noopener">only use versioning as a last resort</a>. We can avoid a lot of versioning by designing services to be as tolerant as possible to changes in their suppliers.</p></blockquote><p>把组件改成服务，增加了作出更加精细的软件发布计划的机会。对于一个单体系统，任何变化都需要做一次整个应用系统的全量构建和部署。然而，对于微服务来说，只需要重新部署修改过的那些服务就够了。这能简化并加快发布过程。但缺点是：必须要考虑当一个服务发生变化时，依赖它并对其进行消费的其他服务可能将无法工作。传统的集成方法是试图使用版本化来解决这个问题。但在微服务世界中，大家更喜欢将版本化作为最后万不得已的手段来使用 。我们需要在设计服务时尽可能的容忍供应商的变更，以避免提供多个版本。</p><h2 id="Are-Microservices-the-Future-未来的方向是“微服务”吗？"><a href="#Are-Microservices-the-Future-未来的方向是“微服务”吗？" class="headerlink" title="Are Microservices the Future?-未来的方向是“微服务”吗？"></a>Are Microservices the Future?-未来的方向是“微服务”吗？</h2><blockquote><p>Our main aim in writing this article is to explain the major ideas and principles of microservices. By taking the time to do this we clearly think that the microservices architectural style is an important idea - one worth serious consideration for enterprise applications. We have recently built several systems using the style and know of others who have used and favor this approach.</p></blockquote><p>我们写这篇文章的主要目的是来解释有关微服务的主要思路和原则。在花了一点时间做了这件事后，我们清楚地认识到，微服务架构风格是一个重要的架构方案——在研发企业应用系统时，值得对它进行认真考虑。我们最近已经使用这种风格构建了一些系统，并且了解到其他一些团队也在使用并支持这种方法。</p><blockquote><p>Those we know about who are in some way pioneering the architectural style include Amazon, Netflix, <a href="http://www.theguardian.com/" target="_blank" rel="noopener">The Guardian</a>, the <a href="https://gds.blog.gov.uk/" target="_blank" rel="noopener">UK Government Digital Service</a>, <a href="https://martinfowler.com/articles/realestate.com.au" target="_blank" rel="noopener">realestate.com.au</a>, Forward and <a href="http://www.comparethemarket.com/" target="_blank" rel="noopener">comparethemarket.com</a>. The conference circuit in 2013 was full of examples of companies that are moving to something that would class as microservices - including Travis CI. In addition there are plenty of organizations that have long been doing what we would class as microservices, but without ever using the name. (Often this is labelled as SOA - although, as we’ve said, SOA comes in many contradictory forms. <a href="https://martinfowler.com/articles/microservices.html#footnote-already" target="_blank" rel="noopener">[15]</a>)</p></blockquote><p>我们所了解到的实践先驱包括：亚马逊、Netflix、The Guardian、The UK Government Digital Service、realestate.com.au、Forward和comparethemarket.com。在2013年的技术大会圈子里充满了各种各样的正在转向微服务的公司案例——包括Travis CI。另外还有大量的组织，它们长期以来一直在做着我们可以归类为微服务的产品，却从未使用过这个名字（这通常被标记为SOA—— 尽管正如我们所说，SOA会表现出各种自相矛盾的形式 <strong>[15]</strong> ）。</p><blockquote><p>Despite these positive experiences, however, we aren’t arguing that we are certain that microservices are the future direction for software architectures. While our experiences so far are positive compared to monolithic applications, we’re conscious of the fact that not enough time has passed for us to make a full judgement.</p></blockquote><p>尽管有这些正面的经验，然而并不是说我们确信微服务是软件架构的未来的方向。尽管到目前为止，与单体应用系统相比，我们对于所经历过的微服务架构的评价都是积极的，但是我们也意识到这样的事实，即能供我们做出完整判断的时间还不够长。</p><blockquote><p>Often the true consequences of your architectural decisions are only evident several years after you made them. We have seen projects where a good team, with a strong desire for modularity, has built a monolithic architecture that has decayed over the years. Many people believe that such decay is less likely with microservices, since the service boundaries are explicit and hard to patch around. Yet until we see enough systems with enough age, we can’t truly assess how microservice architectures mature.</p></blockquote><p>通常，架构决策的真正效果只有在做出这些决策几年之后才会表现出来。我们已经看到由带着强烈的模块化愿望的优秀团队所做的一些项目，最终却构建出一个单体架构，并在几年之内不断腐化。许多人认为，这种腐化不太可能与微服务有关，因为服务的边界是明确的，很难往里面塞新的东西。但是，当我们还没看到足够多的系统运行足够长时间时，我们不能肯定微服务构架是成熟的。</p><blockquote><p>There are certainly reasons why one might expect microservices to mature poorly. In any effort at componentization, success depends on how well the software fits into components. It’s hard to figure out exactly where the component boundaries should lie. Evolutionary design recognizes the difficulties of getting boundaries right and thus the importance of it being easy to refactor them. But when your components are services with remote communications, then refactoring is much harder than with in-process libraries. Moving code is difficult across service boundaries, any interface changes need to be coordinated between participants, layers of backwards compatibility need to be added, and testing is made more complicated.</p></blockquote><p>有人觉得微服务或许很难成熟起来，这当然是有原因的。在组件化上所做的任何工作的是否有效，取决于软件与组件的匹配程度。要想准确地搞清楚某个组件的边界的位置是一件困难的事情。 演进式设计承认难以对边界进行正确定位，所以它将工作的重点放到了易于重构上。但是当各个组件成为各个进行远程通信的服务后，比起在单一进程内进行各个软件库之间的调用，重构就变得更加困难。跨服务边界的代码迁移也会变得困难起来。接口的任何变更，都需要在其各个参与者之间进行协调，向后兼容的层次也需要被添加进来，测试也会变得更加复杂。</p><blockquote><p>Another issue is If the components do not compose cleanly, then all you are doing is shifting complexity from inside a component to the connections between components. Not just does this just move complexity around, it moves it to a place that’s less explicit and harder to control. It’s easy to think things are better when you are looking at the inside of a small, simple component, while missing messy connections between services.</p></blockquote><p>另一个问题在于，如果组件并没有清晰的划分，那么这项工作的复杂性将会从组件内部转向组件间。后果是，不仅仅是将复杂性搬了家，它还将复杂性变得不可控。在一个小的、简单的组件内部考虑事情是很容易的，但也不能忽视了服务之间复杂的连接。</p><blockquote><p>Finally, there is the factor of team skill. New techniques tend to be adopted by more skillful teams. But a technique that is more effective for a more skillful team isn’t necessarily going to work for less skillful teams. We’ve seen plenty of cases of less skillful teams building messy monolithic architectures, but it takes time to see what happens when this kind of mess occurs with microservices. A poor team will always create a poor system - it’s very hard to tell if microservices reduce the mess in this case or make it worse.</p></blockquote><p>最后，对于团队技能也是一个因素。新的技术倾向于被掌握更多的技能的团队使用。适用于技术背景好的团队的技术，不一定适用于一个技术薄弱的团队。我们已经看到大量这样的案例，那些技术薄弱的团队构建出了杂乱的单体架构。当这种杂乱发生到微服务身上时，会出现什么情况？这需要花时间来观察 。一个糟糕的团队，总会构建一个糟糕的系统——在这种情况下，很难讲微服务究竟是减少了杂乱，还是让事情变得更糟。</p><blockquote><p>One reasonable argument we’ve heard is that you shouldn’t start with a microservices architecture. Instead <a href="https://martinfowler.com/bliki/MonolithFirst.html" target="_blank" rel="noopener">begin with a monolith</a>, keep it modular, and split it into microservices once the monolith becomes a problem. (Although <a href="https://martinfowler.com/articles/dont-start-monolith.html" target="_blank" rel="noopener">this advice isn’t ideal</a>, since a good in-process interface is usually not a good service interface.)</p></blockquote><p>我们听到一个合理的说法，是说不要一上来就以微服务架构做为起点。相反，要用一个单体系统做为起点，并保持其模块化。当这个单体系统出现了问题后，再将其分解为微服务。（尽管这个建议并不理想，因为一个良好的单一进程内的接口，通常不是一个良好的服务接口）</p><blockquote><p>So we write this with cautious optimism. So far, we’ve seen enough about the microservice style to feel that it can be <a href="https://martinfowler.com/microservices/" target="_blank" rel="noopener">a worthwhile road to tread</a>. We can’t say for sure where we’ll end up, but one of the challenges of software development is that you can only make decisions based on the imperfect information that you currently have to hand.</p></blockquote><p>因此，我们持谨慎乐观的态度来撰写此文。到目前为止，我们已经看到足够多的有关微服务风格的项目，并且觉得这是一条值得去探索的道路。我们不能肯定地说，道路的尽头在哪里。但是，软件开发的挑战之一，就是只能基于 “目前手上拥有但还不够完善” 的信息来做出决策。</p><h2 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h2><h3 id="Tips1-How-big-is-a-microservice-一个微服务应该有多大？"><a href="#Tips1-How-big-is-a-microservice-一个微服务应该有多大？" class="headerlink" title="Tips1 : How big is a microservice?-一个微服务应该有多大？"></a>Tips1 : How big is a microservice?-一个微服务应该有多大？</h3><blockquote><p>Although “microservice” has become a popular name for this architectural style, its name does lead to an unfortunate focus on the size of service, and arguments about what constitutes “micro”. In our conversations with microservice practitioners, we see a range of sizes of services. The largest sizes reported follow Amazon’s notion of the Two Pizza Team (i.e. the whole team can be fed by two pizzas), meaning no more than a dozen people. On the smaller size scale we’ve seen setups where a team of half-a-dozen would support half-a-dozen services.</p></blockquote><p>尽管“微服务”已经成为一个流行的名字，但是这个名字确实会不幸地导致大家对服务规模的关注，并且产生了有关什么是“微”的争论。在与微服务从业者的交谈中，我们看到了有关服务的一系列规模。所听到的最大的一个服务的规模，是遵循了亚马逊的“两个比萨团队”（即一个团队可以被两个比萨所喂饱）的理念，这意味着这个团队不会多于12人。对于规模较小的服务，我们已经看到一个6人的团队在支持6个服务。</p><blockquote><p>This leads to the question of whether there are sufficiently large differences within this size range that the service-per-dozen-people and service-per-person sizes shouldn’t be lumped under one microservices label. At the moment we think it’s better to group them together, but it’s certainly possible that we’ll change our mind as we explore this style further.</p></blockquote><p>这引出了一个问题，即“每12人做一个服务”和“每人做一个服务”这样有关服务规模的差距，是否已经大到不能将两者都纳入微服务之下？此时，我们认为最好还是把它们归为一类，但是随着进一步探索这种架构风格，绝对有可能我们会在将来改变主意。</p><h3 id="Tips2-Microservices-and-SOA-微服务与SOA"><a href="#Tips2-Microservices-and-SOA-微服务与SOA" class="headerlink" title="Tips2 : Microservices and SOA-微服务与SOA"></a>Tips2 : Microservices and SOA-微服务与SOA</h3><blockquote><p>When we’ve talked about microservices a common question is whether this is just Service Oriented Architecture (SOA) that we saw a decade ago. There is merit to this point, because the microservice style is very similar to what some advocates of SOA have been in favor of. The problem, however, is that SOA means <a href="https://martinfowler.com/bliki/ServiceOrientedAmbiguity.html" target="_blank" rel="noopener">too many different things</a>, and that most of the time that we come across something called “SOA” it’s significantly different to the style we’re describing here, usually due to a focus on ESBs used to integrate monolithic applications.</p></blockquote><p>当我们谈起微服务时，一个常见的问题就会出现：是否微服务仅仅是十多年前所看到的“面向服务的架构”(Service Oriented Architecture, SOA)？这样问是有道理的，因为微服务风格非常类似于一些支持SOA的人所赞成的观点。然而，问题在于SOA这个词儿意味着太多不同的东西。而且大多数时候，我们所遇到的某些被称作”SOA”的事物，明显不同于本文所描述的风格。这通常由于它们专注于ESB，来集成各个单体应用。</p><blockquote><p>In particular we have seen so many botched implementations of service orientation - from the tendency to hide complexity away in ESB’s <a href="https://martinfowler.com/articles/microservices.html#footnote-esb" target="_blank" rel="noopener">[6]</a>, to failed multi-year initiatives that cost millions and deliver no value, to centralised governance models that actively inhibit change, that it is sometimes difficult to see past these problems.</p></blockquote><p>特别地，我们已经看到如此之多的面向服务的拙劣实现——从将系统复杂性隐藏于ESB中的趋势 <strong>[7]</strong> ，到花费数百万进行多年却没有交付任何价值的失败项目，到顽固抑制变化发生的中心化技术治理模型——以至于有时觉得其所造成的种种问题真的不堪回首。</p><blockquote><p>Certainly, many of the techniques in use in the microservice community have grown from the experiences of developers integrating services in large organisations. The <a href="https://martinfowler.com/bliki/TolerantReader.html" target="_blank" rel="noopener">Tolerant Reader</a> pattern is an example of this. Efforts to use the web have contributed, using simple protocols is another approach derived from these experiences - a reaction away from central standards that have reached a complexity that is, <a href="http://wiki.apache.org/ws/WebServiceSpecifications" target="_blank" rel="noopener">frankly, breathtaking</a>. (Any time you need an ontology to manage your ontologies you know you are in deep trouble.)</p></blockquote><p>当然，在微服务社区投入使用的许多技术，源自各个开发人员将各种服务集成到各个大型组织的经验。“容错读取”(Tolerant Reader)模式就是这样一个例子。对于Web的广泛使用，使得人们不再使用一些中心化的标准，而使用一些简单的协议。坦率地说，这些中心化的标准，其复杂性已经达到令人吃惊的程度。（任何时候，如果需要一个本体（ontology）来管理其他各个本体，那么麻烦就大了）</p><blockquote><p>This common manifestation of SOA has led some microservice advocates to reject the SOA label entirely, although others consider microservices to be one form of SOA <a href="https://martinfowler.com/articles/microservices.html#footnote-fine-grained" target="_blank" rel="noopener">[7]</a>, perhaps <em>service orientation done right</em>. Either way, the fact that SOA means such different things means it’s valuable to have a term that more crisply defines this architectural style.</p></blockquote><p>这种常见的SOA的表现，已使得一些微服务的倡导者完全拒绝将自己贴上SOA的标签。尽管其他人会将微服务看作是SOA的 一种形式 <strong>[8]</strong> ，也许微服务就是以正确的形式来实现面向服务的SOA 。不管是哪种情况，SOA意味着很多的不同事物，这表明用一个更加干净利落的术语来命名这种架构风格是很有价值的。</p><h3 id="Tips3-Many-languages-many-options-多种编程语言，多种选择可能"><a href="#Tips3-Many-languages-many-options-多种编程语言，多种选择可能" class="headerlink" title="Tips3 : Many languages, many options-多种编程语言，多种选择可能"></a>Tips3 : Many languages, many options-多种编程语言，多种选择可能</h3><blockquote><p>The growth of JVM as a platform is just the latest example of mixing languages within a common platform. It’s been common practice to shell-out to a higher level language to take advantage of higher level abstractions for decades. As is dropping down to the metal and writing performance sensitive code in a lower level one. However, many monoliths don’t need this level of performance optimisation nor are DSL’s and higher level abstractions that common (to our dismay). Instead monoliths are usually single language and the tendency is to limit the number of technologies in use [10].</p></blockquote><p>做为一个平台，JVM的发展仅仅是一个将各种编程语言混合到一个通用平台的最新例证。近十年以来，在平台外层实现更高层次的编程语言，来利用更高层次的抽象，已经成为一个普遍做法。同样，在平台底层以更低层次的编程语言编写性能敏感的代码也很普遍。然而，许多单体系统并不需要这种级别的性能优化，另外DSL和更高层次的抽象也不常用（这令我们感到失望）。相反，许多单体应用通常就使用单一编程语言，并且有对所使用的技术数量进行 限制 的趋势 <strong>[10]</strong> 。</p><h3 id="Tips4-Battle-tested-standards-and-enforced-standards-”实战检验”的标准与“强制执行”的标准"><a href="#Tips4-Battle-tested-standards-and-enforced-standards-”实战检验”的标准与“强制执行”的标准" class="headerlink" title="Tips4 : Battle-tested standards and enforced standards-”实战检验”的标准与“强制执行”的标准"></a>Tips4 : Battle-tested standards and enforced standards-”实战检验”的标准与“强制执行”的标准</h3><blockquote><p>It’s a bit of a dichotomy that microservice teams tend to eschew the kind of rigid enforced standards laid down by enterprise architecture groups but will happily use and even evangelise the use of open standards such as HTTP, ATOM and other microformats.</p></blockquote><p>微服务的某些做法有点泾渭分明的味道，即他们趋向于避开被那些企业架构组织所制定的硬性实施的标准，而愉快地使用甚至传播一些开放标准，比如 HTTP、ATOM和其他微格式的协议。</p><blockquote><p>The key difference is how the standards are developed and how they are enforced. Standards managed by groups such as the IETF only <em>become</em> standards when there are several live implementations of them in the wider world and which often grow from successful open-source projects.</p></blockquote><p>这里的关键区别是，这些标准是如何被制定以及如何被实施的。像诸如IETF这样的组织所管理的各种标准，只有达到某些条件才能称为标准，即该标准在全球更广阔的地区有一些正在运行的实现案例，而且这些标准经常源自一些成功的开源项目。</p><blockquote><p>These standards are a world apart from many in a corporate world, which are often developed by groups that have little recent programming experience or overly influenced by vendors.</p></blockquote><p>这些标准组成了一个世界，它区别于来自企业世界的许多标准。企业世界中的标准，经常由这样特点的组织来开发，即缺乏用较新技术进行编程的经验，或受到供应商的过度影响。</p><h3 id="Tips5-Make-it-easy-to-do-the-right-thing-让做正确的事情变得容易"><a href="#Tips5-Make-it-easy-to-do-the-right-thing-让做正确的事情变得容易" class="headerlink" title="Tips5 : Make it easy to do the right thing-让做正确的事情变得容易"></a>Tips5 : Make it easy to do the right thing-让做正确的事情变得容易</h3><blockquote><p>One side effect we have found of increased automation as a consequence of continuous delivery and deployment is the creation of useful tools to help developers and operations folk. Tooling for creating artefacts, managing codebases, standing up simple services or for adding standard monitoring and logging are pretty common now. The best example on the web is probably <a href="http://netflix.github.io/" target="_blank" rel="noopener">Netflix’s set of open source tools</a>, but there are others including <a href="http://dropwizard.codahale.com/" target="_blank" rel="noopener">Dropwizard</a> which we have used extensively.</p></blockquote><p>那些因实现持续交付和持续集成所增加的自动化工作的副产品，是创建一些对开发和运维人员有用的工具。现在，能完成下面工作的工具已经相当常见了：即创建工件(artefacts)、管理代码库、启动一些简单的服务、或增加标准的监控和日志功能。Web上最好的例子可能是Netflix提供的一套开源工具集，但也有其他一些好工具，包括我们已经广泛使用的Dropwizard。</p><h3 id="Tips6-The-circuit-breaker-and-production-ready-code-“断路器”与“可随时上线的代码”"><a href="#Tips6-The-circuit-breaker-and-production-ready-code-“断路器”与“可随时上线的代码”" class="headerlink" title="Tips6 : The circuit breaker and production ready code-“断路器”与“可随时上线的代码”"></a>Tips6 : The circuit breaker and production ready code-“断路器”与“可随时上线的代码”</h3><blockquote><p><a href="https://martinfowler.com/bliki/CircuitBreaker.html" target="_blank" rel="noopener">Circuit Breaker</a> appears in <a href="https://www.amazon.com/gp/product/B00A32NXZO?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B00A32NXZO" target="_blank" rel="noopener">Release It!</a><br>alongside other patterns such as Bulkhead and Timeout. Implemented together, these patterns are crucially important when building communicating applications. This <a href="http://techblog.netflix.com/2012/02/fault-tolerance-in-high-volume.html" target="_blank" rel="noopener">Netflix blog entry</a> does a great job of explaining their application of them.</p></blockquote><p>“断路器”(Circuit Breaker )一词与其他一些模式一起出现在《发布！》(Release It! )一书中，例如隔板(Bulkhead)和超时(Timeout)。当构建彼此通信的应用系统时，将这些模式加以综合运用就变得至关重要。Netflix公司的这篇很精彩的博客解释了这些模式是如何应用的。</p><h3 id="Tips7-Synchronous-calls-considered-harmful-同步调用的弊端"><a href="#Tips7-Synchronous-calls-considered-harmful-同步调用的弊端" class="headerlink" title="Tips7 : Synchronous calls considered harmful-同步调用的弊端"></a>Tips7 : Synchronous calls considered harmful-同步调用的弊端</h3><blockquote><p>Any time you have a number of synchronous calls between services you will encounter the multiplicative effect of downtime. Simply, this is when the downtime of your system becomes the product of the downtimes of the individual components. You face a choice, making your calls asynchronous or managing the downtime. At <a href="http://www.guardian.co.uk" target="_blank" rel="noopener">www.guardian.co.uk</a> they have implemented a simple rule on the new platform - one synchronous call per user request while at Netflix, their platform API redesign has built asynchronicity into the API fabric.</p></blockquote><p>一旦在一些服务之间进行多个同步调用，就会遇到宕机的乘法效应。简而言之，这意味着整个系统的宕机时间，是每一个单独模块各自宕机时间的乘积。此时面临着一个选择：是让模块之间的调用异步，还是去管理宕机时间？在<a href="http://www.guardian.co.uk网站，他们在新平台上实现了一个简单的规则——每一个用户请求都对应一个同步调用。然而在Netflix公司，他们重新设计的平台API将异步性构建到API的机制(fabric)中。" target="_blank" rel="noopener">www.guardian.co.uk网站，他们在新平台上实现了一个简单的规则——每一个用户请求都对应一个同步调用。然而在Netflix公司，他们重新设计的平台API将异步性构建到API的机制(fabric)中。</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.aliyun.com/jiaocheng/292444.html" target="_blank" rel="noopener">https://www.aliyun.com/jiaocheng/292444.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://martinfowler.com/articles/microservices.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://martinfowler.com/
      
    
    </summary>
    
    
      <category term="微服务" scheme="http://www.glmapper.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实践系列-集成 RocketMQ</title>
    <link href="http://www.glmapper.com/2020/04/05/springboot/springboot-series-rocketmq/"/>
    <id>http://www.glmapper.com/2020/04/05/springboot/springboot-series-rocketmq/</id>
    <published>2020-04-05T11:39:17.000Z</published>
    <updated>2020-10-28T11:02:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>RocketMQ 简介：Apache RocketMQ是一个分布式消息传递和流媒体平台，具有低延迟、高性能和可靠性、万亿级容量和灵活的可伸缩性。它提供了多种功能，具体参考: <a href="https://github.com/apache/rocketmq" target="_blank" rel="noopener">https://github.com/apache/rocketmq</a> 。</p><h2 id="RocketMQ-快速开始"><a href="#RocketMQ-快速开始" class="headerlink" title="RocketMQ 快速开始"></a>RocketMQ 快速开始</h2><p>官方指导手册快速开始中提到，RocketMQ 安装需要具体以下条件：</p><ul><li>64bit OS, 推荐使用 Linux/Unix/Mac </li><li>64bit JDK 1.8+</li><li>Maven 3.2.x</li><li>4g+ free disk for Broker server （这个需要特别关注下）</li></ul><h3 id="下载安装和编译"><a href="#下载安装和编译" class="headerlink" title="下载安装和编译"></a>下载安装和编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://archive.apache.org/dist/rocketmq/4.7.0/rocketmq-all-4.7.0-source-release.zip</span><br><span class="line">unzip rocketmq-all-4.7.0-source-release.zip</span><br><span class="line"><span class="built_in">cd</span> rocketmq-all-4.7.0/</span><br><span class="line">mvn -Prelease-all -DskipTests clean install -U</span><br><span class="line"><span class="built_in">cd</span> distribution/target/rocketmq-4.7.0/rocketmq-4.7.0</span><br></pre></td></tr></table></figure><p>1、启动 Name Server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; nohup sh bin/mqnamesrv &amp;</span><br><span class="line">&gt; tail -f ~/logs/rocketmqlogs/namesrv.log</span><br><span class="line">The Name Server boot success...</span><br></pre></td></tr></table></figure><p>2、启动 Broker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; nohup sh bin/mqbroker -n localhost:9876 &amp;</span><br><span class="line"><span class="comment"># nohup sh bin/mqbroker -n localhost:9876 autoCreateTopicEnable=true &amp;</span></span><br><span class="line">&gt; tail -f ~/logs/rocketmqlogs/broker.log </span><br><span class="line">The broker[%s, 172.30.30.233:10911] boot success...</span><br></pre></td></tr></table></figure><blockquote><p>autoCreateTopicEnable：使用 RocketMQ 进行发消息时，必须要指定 topic，对于 topic 的设置有一个开关 autoCreateTopicEnable，一般在开发测试环境中会使用默认设置 autoCreateTopicEnable = true，但是这样就会导致 topic 的设置不容易规范管理，没有统一的审核等等，所以在正式环境中会在 Broker 启动时设置参数 autoCreateTopicEnable = false。这样当需要增加 topic 时就需要在 web 管理界面上或者通过 admin tools 添加即可</p></blockquote><h2 id="SpringBoot-集成"><a href="#SpringBoot-集成" class="headerlink" title="SpringBoot 集成"></a>SpringBoot 集成</h2><p>RocketMQ 目前没有提供集成 SpringBoot 的 starter，因此现在接入都是通过引入客户端进行编程。下面来看下 SpringBoot 集成 RocketMQ 的过程。</p><h3 id="引入-RocketMQ-客户端依赖"><a href="#引入-RocketMQ-客户端依赖" class="headerlink" title="引入 RocketMQ 客户端依赖"></a>引入 RocketMQ 客户端依赖</h3><p>github 上目前更新的最新版本是 4.7.0 版本，这里就使用最新版本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="提供生产者的自动配置类"><a href="#提供生产者的自动配置类" class="headerlink" title="提供生产者的自动配置类"></a>提供生产者的自动配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl (glmapper_2018@163.com) 2020/4/5 5:17 PM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQProducerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MQProducerConfiguration.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.producer.groupName&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String             groupName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.producer.namesrvAddr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String             namesrvAddr;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.producer.maxMessageSize&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer            maxMessageSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.producer.sendMsgTimeout&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer            sendMsgTimeout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.producer.retryTimesWhenSendFailed&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer            retryTimesWhenSendFailed;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultMQProducer <span class="title">defaultMQProducer</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="keyword">this</span>.groupName);</span><br><span class="line">        producer.setNamesrvAddr(<span class="keyword">this</span>.namesrvAddr);</span><br><span class="line">        producer.setCreateTopicKey(<span class="string">"AUTO_CREATE_TOPIC_KEY"</span>);</span><br><span class="line">        <span class="comment">//如果需要同一个 jvm 中不同的 producer 往不同的 mq 集群发送消息，需要设置不同的 instanceName</span></span><br><span class="line">        <span class="comment">//producer.setInstanceName(instanceName);</span></span><br><span class="line">        <span class="comment">//如果发送消息的最大限制</span></span><br><span class="line">        producer.setMaxMessageSize(<span class="keyword">this</span>.maxMessageSize);</span><br><span class="line">        <span class="comment">//如果发送消息超时时间</span></span><br><span class="line">        producer.setSendMsgTimeout(<span class="keyword">this</span>.sendMsgTimeout);</span><br><span class="line">        <span class="comment">//如果发送消息失败，设置重试次数，默认为 2 次</span></span><br><span class="line">        producer.setRetryTimesWhenSendFailed(<span class="keyword">this</span>.retryTimesWhenSendFailed);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            producer.start();</span><br><span class="line">            LOGGER.info(<span class="string">"producer is started. groupName:&#123;&#125;, namesrvAddr: &#123;&#125;"</span>, groupName, namesrvAddr);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"failed to start producer."</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> producer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>groupName: 发送同一类消息的设置为同一个 group，保证唯一， 默认不需要设置，rocketmq 会使用 ip@pid(pid代表jvm名字) 作为唯一标示。</li><li>namesrvAddr：Name Server 地址</li><li>maxMessageSize：消息最大限制，默认 4M</li><li>sendMsgTimeout：消息发送超时时间，默认 3 秒</li><li>retryTimesWhenSendFailed：消息发送失败重试次数，默认 2 次</li></ul><h3 id="提供消费者的自动配置类"><a href="#提供消费者的自动配置类" class="headerlink" title="提供消费者的自动配置类"></a>提供消费者的自动配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQConsumerConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger  LOGGER = LoggerFactory.getLogger(MQConsumerConfiguration.class);</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.consumer.namesrvAddr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String                        namesrvAddr;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.consumer.groupName&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String                        groupName;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.consumer.consumeThreadMin&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                           consumeThreadMin;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.consumer.consumeThreadMax&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                           consumeThreadMax;</span><br><span class="line">    <span class="comment">// 订阅指定的 topic </span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.consumer.topics&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String                        topics;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.consumer.consumeMessageBatchMaxSize&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                           consumeMessageBatchMaxSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MQConsumeMsgListenerProcessor mqMessageListenerProcessor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultMQPushConsumer <span class="title">defaultMQPushConsumer</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line"></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(groupName);</span><br><span class="line">        consumer.setNamesrvAddr(namesrvAddr);</span><br><span class="line">        consumer.setConsumeThreadMin(consumeThreadMin);</span><br><span class="line">        consumer.setConsumeThreadMax(consumeThreadMax);</span><br><span class="line">        consumer.registerMessageListener(mqMessageListenerProcessor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 consumer 第一次启动是从队列头部开始消费还是队列尾部开始消费</span></span><br><span class="line">        <span class="comment">// 如果非第一次启动，那么按照上次消费的位置继续消费</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        <span class="comment">// 设置消费模型，集群还是广播，默认为集群</span></span><br><span class="line">        consumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line">        <span class="comment">// 设置一次消费消息的条数，默认为 1 条</span></span><br><span class="line">        consumer.setConsumeMessageBatchMaxSize(consumeMessageBatchMaxSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置该消费者订阅的主题和tag，如果是订阅该主题下的所有tag，使用*；</span></span><br><span class="line">            consumer.subscribe(topics, <span class="string">"*"</span>);</span><br><span class="line">            <span class="comment">// 启动消费</span></span><br><span class="line">            consumer.start();</span><br><span class="line">            LOGGER.info(<span class="string">"consumer is started. groupName:&#123;&#125;, topics:&#123;&#125;, namesrvAddr:&#123;&#125;"</span>,groupName,topics,namesrvAddr);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"failed to start consumer . groupName:&#123;&#125;, topics:&#123;&#125;, namesrvAddr:&#123;&#125;"</span>,groupName,topics,namesrvAddr,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> consumer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数参考上述生产者部分。这里配置只是启动的消费端的监听，具体的消费需要再实现一个 MessageListenerConcurrently 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl (glmapper_2018@163.com) 2020/4/5 5:21 PM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListenerHandler</span> <span class="keyword">implements</span> <span class="title">MessageListenerConcurrently</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MessageListenerHandler.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String TOPIC = <span class="string">"DemoTopic"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(msgs)) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">"receive blank msgs..."</span>);</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">        MessageExt messageExt = msgs.get(<span class="number">0</span>);</span><br><span class="line">        String msg = <span class="keyword">new</span> String(messageExt.getBody());</span><br><span class="line">        <span class="keyword">if</span> (messageExt.getTopic().equals(TOPIC)) &#123;</span><br><span class="line">            <span class="comment">// mock 消费逻辑</span></span><br><span class="line">            mockConsume(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mockConsume</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"receive msg: &#123;&#125;."</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用客户端发送消息"><a href="#使用客户端发送消息" class="headerlink" title="使用客户端发送消息"></a>使用客户端发送消息</h3><p>使用客户端发送消息的逻辑比较简单，就是拿到 DefaultMQProducer 对象，调用 send 方法，支持同步、异步、oneway 等多种调用方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(TestController.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String TOPIC = <span class="string">"DemoTopic"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String TAGS = <span class="string">"glmapperTags"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DefaultMQProducer defaultMQProducer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"send"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Message msg = <span class="keyword">new</span> Message(TOPIC, TAGS, (<span class="string">"Say Hello RocketMQ to Glmapper"</span>).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">        <span class="comment">// 调用客户端发送消息</span></span><br><span class="line">        SendResult sendResult = defaultMQProducer.send(msg);</span><br><span class="line">        LOGGER.info(<span class="string">"sendResult: &#123;&#125;."</span>,sendResult);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"SUCCESS"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>这里的测试应用是将生产端和消费端放在一起的，所以配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=test-rocket</span><br><span class="line">server.port=8008</span><br><span class="line">#producer</span><br><span class="line">rocketmq.producer.isOnOff=on #该应用是否启用生产者</span><br><span class="line">rocketmq.producer.groupName=$&#123;spring.application.name&#125;</span><br><span class="line">rocketmq.producer.namesrvAddr=sofa.cloud.alipay.net:9876</span><br><span class="line">rocketmq.producer.maxMessageSize=4096</span><br><span class="line">rocketmq.producer.sendMsgTimeout=3000</span><br><span class="line">rocketmq.producer.retryTimesWhenSendFailed=2</span><br><span class="line"></span><br><span class="line">#consumer</span><br><span class="line">rocketmq.consumer.isOnOff=on #该应用是否启用消费者</span><br><span class="line">rocketmq.consumer.groupName=$&#123;spring.application.name&#125;</span><br><span class="line">rocketmq.consumer.namesrvAddr=sofa.cloud.alipay.net:9876</span><br><span class="line">rocketmq.consumer.topics=DemoTopic</span><br><span class="line">rocketmq.consumer.consumeThreadMin=20</span><br><span class="line">rocketmq.consumer.consumeThreadMax=64</span><br><span class="line">rocketmq.consumer.consumeMessageBatchMaxSize=1</span><br></pre></td></tr></table></figure><p>启动程序，查看日志输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-04-05 22:53:15.141  INFO 46817 --- [           main] c.g.b.b.c.MQProducerConfiguration        : producer is started. groupName:test-rocket, namesrvAddr: sofa.cloud.alipay.net:9876</span><br><span class="line">2020-04-05 22:53:15.577  INFO 46817 --- [           main] c.g.b.b.c.MQConsumerConfiguration        : consumer is started. groupName:test-rocket, topics:DemoTopic, namesrvAddr:sofa.cloud.alipay.net:9876</span><br></pre></td></tr></table></figure><p>这里看到，生产者和消费者自动配置已经生效并启动完成。通过 curl localhost:8008/send 来触发消息发送:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-04-05 22:54:21.654  INFO 46817 --- [nio-8008-exec-1] c.g.b.boot.controller.TestController     : sendResult: SendResult [sendStatus=SEND_OK, msgId=1E0FC3A2B6E118B4AAC21983B3C50000, offsetMsgId=64583D7C00002A9F0000000000011788, messageQueue=MessageQueue [topic=DemoTopic, brokerName=sofa.cloud.alipay.net, queueId=6], queueOffset=50].</span><br><span class="line">2020-04-05 22:54:21.658  INFO 46817 --- [MessageThread_1] c.g.b.b.p.MessageListenerHandler         : receive msg: Say Hello RocketMQ to Glmapper.</span><br></pre></td></tr></table></figure><p>看到发送消息的日志和接受消息的日志。</p><h2 id="使用-hook-拦截消息"><a href="#使用-hook-拦截消息" class="headerlink" title="使用 hook 拦截消息"></a>使用 hook 拦截消息</h2><p>RocKetMQ 中提供了两个 hook 接口：SendMessageHook 和 ConsumeMessageHook 接口，可以用于在消息发送之前、之后，消息消费之前、之后对消息进行拦截，官方文档中并没有关于这部分的描述，那么这里我们就来看下如何使用这两个 hook 接口来搞点事情。</p><h3 id="SendMessageHook"><a href="#SendMessageHook" class="headerlink" title="SendMessageHook"></a>SendMessageHook</h3><p>自定义一个 ProducerTestHook ，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerTestHook</span> <span class="keyword">implements</span> <span class="title">SendMessageHook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ProducerTestHook.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hookName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ProducerTestHook.class.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessageBefore</span><span class="params">(SendMessageContext sendMessageContext)</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"execute sendMessageBefore. sendMessageContext:&#123;&#125;"</span>, sendMessageContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessageAfter</span><span class="params">(SendMessageContext sendMessageContext)</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"execute sendMessageAfter. sendMessageContext:&#123;&#125;"</span>, sendMessageContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面生产者的自动配置类中，将 ProducerTestHook 注册给 producer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册 SendMessageHook</span></span><br><span class="line">producer.getDefaultMQProducerImpl().registerSendMessageHook(<span class="keyword">new</span> ProducerTestHook());</span><br></pre></td></tr></table></figure><h3 id="ConsumeMessageHook"><a href="#ConsumeMessageHook" class="headerlink" title="ConsumeMessageHook"></a>ConsumeMessageHook</h3><p>自定义一个 ConsumerTestHook ，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTestHook</span> <span class="keyword">implements</span> <span class="title">ConsumeMessageHook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ConsumerTestHook.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hookName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ConsumerTestHook.class.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumeMessageBefore</span><span class="params">(ConsumeMessageContext consumeMessageContext)</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"execute consumeMessageBefore. consumeMessageContext: &#123;&#125;"</span>,consumeMessageContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumeMessageAfter</span><span class="params">(ConsumeMessageContext consumeMessageContext)</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"execute consumeMessageAfter. consumeMessageContext: &#123;&#125;"</span>,consumeMessageContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面消费者的自动配置类中，将 ConsumerTestHook 注册给 consumer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册 ConsumeMessageHook</span></span><br><span class="line">consumer.getDefaultMQPushConsumerImpl().registerConsumeMessageHook(<span class="keyword">new</span> ConsumerTestHook());</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">execute sendMessageBefore. sendMessageContext:org.apache.rocketmq.client.hook.SendMessageContext@a50ea34</span><br><span class="line">execute sendMessageAfter. sendMessageContext:org.apache.rocketmq.client.hook.SendMessageContext@a50ea34</span><br><span class="line">sendResult: SendResult [sendStatus=SEND_OK, msgId=0A0FE8F8C02F18B4AAC21C1275FB0000, offsetMsgId=64583D7C00002A9F0000000000011850, messageQueue=MessageQueue [topic=DemoTopic, brokerName=sofa.cloud.alipay.net, queueId=5], queueOffset=50].</span><br><span class="line">execute consumeMessageBefore. consumeMessageContext: org.apache.rocketmq.client.hook.ConsumeMessageContext@6482209a</span><br><span class="line">receive msg: Say Hello RocketMQ to Glmapper.</span><br><span class="line">execute consumeMessageAfter. consumeMessageContext: org.apache.rocketmq.client.hook.ConsumeMessageContext@6482209a</span><br></pre></td></tr></table></figure><h2 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h2><p>集成过程中遇到几个问题记录如下：</p><p><strong>1、Broker 启动失败。</strong></p><p>我在测试时遇到的情况是，在 Name Server 启动之后，再启动 Boker 时，ssh 连接会直接提示 connect conversation fail. 通过 <code>dmesg | egrep -i -B100 &#39;killed process&#39;</code> 查看进程被 kill 的记录，得到如下日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[2257026.030741] Memory cgroup out of memory: Kill process 110719 (systemd) score 0 or sacrifice child</span><br><span class="line">[2257026.031888] Killed process 100735 (sh) total-vm:15708kB, anon-rss:176kB, file-rss:1800kB, shmem-rss:0kB</span><br><span class="line">[2257026.133506] Memory cgroup out of memory: Kill process 110719 (systemd) score 0 or sacrifice child</span><br><span class="line">[2257026.133539] Killed process 100745 (vsar) total-vm:172560kB, anon-rss:22936kB, file-rss:1360kB, shmem-rss:0kB</span><br><span class="line">[2257026.206872] Memory cgroup out of memory: Kill process 104617 (java) score 3 or sacrifice child</span><br><span class="line">[2257026.207742] Killed process 104617 (java) total-vm:9092924kB, anon-rss:4188528kB, file-rss:496kB, shmem-rss:0kB</span><br></pre></td></tr></table></figure><p>那这里看到的结论是发生了 OOM，这里是启动时没哟分配到足够的空间导致的(默认配置文件初始内存设置的太大了)。解决办法是：进入到编译之后的 distribution/target/apache-rocketmq/bin 目录，找到 runbroker.sh 和 runserver.sh 两个脚本文件，这两个脚本理解启动时默认指定的参数是非常大的（4g/8g/2g），我线下测试机器总共才 1c2g，所以适当的调整了下参数:</p><ul><li>runserver.sh</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms128m -Xmx256m -Xmn256m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</span></span><br></pre></td></tr></table></figure><ul><li>runbroker.sh</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms256m -Xmx256m -Xmn128m"</span></span><br></pre></td></tr></table></figure><p>修改后重新启动 namesrv 和 broker ，正常了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jps</span><br><span class="line">98633 Jps</span><br><span class="line">55689 BrokerStartup</span><br><span class="line">54906 NamesrvStartup</span><br></pre></td></tr></table></figure><p><strong>2、No Topic Route Info，xxx</strong></p><p>这个在官方的 FAQ 里面有提到，说明遇到的频次一定是很高的。官方给出的方案可以详解<a href="http://rocketmq.apache.org/docs/faq/" target="_blank" rel="noopener">这里</a> <a href="http://rocketmq.apache.org/docs/faq/" target="_blank" rel="noopener">http://rocketmq.apache.org/docs/faq/</a> 第4条。我是通过 <strong>If you can’t find this topic, create it on a broker via admin tools command updateTopic or web console.</strong>  这个解决的:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sh mqadmin updateTopic -b localhost:10911 -n localhost:9876 -t DemoTopic <span class="comment"># 执行此指令，创建 DemoTopic</span></span><br><span class="line">RocketMQLog:WARN No appenders could be found <span class="keyword">for</span> logger (io.netty.util.internal.PlatformDependent0).</span><br><span class="line">RocketMQLog:WARN Please initialize the logger system properly.</span><br><span class="line">create topic to localhost:10911 success.</span><br><span class="line">TopicConfig [topicName=DemoTopic, readQueueNums=8, writeQueueNums=8, perm=RW-, topicFilterType=SINGLE_TAG, topicSysFlag=0, order=<span class="literal">false</span>]</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前在做 SOFATracer 集成消息组件时有看过 RocketMQ 的部分代码，但是在实际操作时还是饶了不少弯路。总体来看，SpringBoot 集成 RocketMQ 还是比较简单的，在此记录一下。如果文中有描述有误的地方，还请各位大佬留言指正。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="http://rocketmq.apache.org/docs/quick-start/" target="_blank" rel="noopener">http://rocketmq.apache.org/docs/quick-start/</a></li><li><a href="https://blog.csdn.net/ph3636/article/details/79528638" target="_blank" rel="noopener">https://blog.csdn.net/ph3636/article/details/79528638</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RocketMQ 简介：Apache RocketMQ是一个分布式消息传递和流媒体平台，具有低延迟、高性能和可靠性、万亿级容量和灵活的可伸缩性。它提供了多种功能，具体参考: &lt;a href=&quot;https://github.com/apache/rocketmq&quot; targe
      
    
    </summary>
    
      <category term="springboot" scheme="http://www.glmapper.com/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://www.glmapper.com/tags/springboot/"/>
    
      <category term="rocketmq" scheme="http://www.glmapper.com/tags/rocketmq/"/>
    
  </entry>
  
</feed>
