<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>glmapper</title>
  
  <subtitle>大家都喊我磊叔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.glmapper.com/"/>
  <updated>2018-12-16T07:53:52.000Z</updated>
  <id>http://www.glmapper.com/</id>
  
  <author>
    <name>GuoLei Song</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>20181216-书法练习</title>
    <link href="http://www.glmapper.com/2018/12/16/shufa-20181216/"/>
    <id>http://www.glmapper.com/2018/12/16/shufa-20181216/</id>
    <published>2018-12-16T07:30:58.000Z</published>
    <updated>2018-12-16T07:53:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>春江花月夜 -张若虚<br>春江潮水连海平，海上明月共潮生。<br>滟滟随波千万里，何处春江无月明！<br>江流宛转绕芳甸，月照花林皆似霰；<br>空里流霜不觉飞，汀上白沙看不见。<br>江天一色无纤尘，皎皎空中孤月轮。<br>江畔何人初见月？江月何年初照人？<br>人生代代无穷已，江月年年只相似。<br>不知江月待何人，但见长江送流水。<br>白云一片去悠悠，青枫浦上不胜愁。<br>谁家今夜扁舟子？何处相思明月楼？<br>可怜楼上月徘徊，应照离人妆镜台。<br>玉户帘中卷不去，捣衣砧上拂还来。<br>此时相望不相闻，愿逐月华流照君。<br>鸿雁长飞光不度，鱼龙潜跃水成文。<br>昨夜闲潭梦落花，可怜春半不还家。<br>江水流春去欲尽，江潭落月复西斜。<br>斜月沉沉藏海雾，碣石潇湘无限路。<br>不知乘月几人归，落月摇情满江树。</p></blockquote><p><img src="https://github.com/glmapper/glmapper.github.io/blob/master/images/self/shufa-yb-chunjianghuayueye.jpg?raw=true" alt=""></p><p><img src="https://github.com/glmapper/glmapper.github.io/blob/master/images/self/shufa-rb-chunjianghuayueye.jpg?raw=true" alt=""></p><blockquote><p>闻王昌龄左迁龙标遥有此寄 -李白<br>杨花落尽子规啼，闻道龙标过五溪。<br>我寄愁心与明月，随风直到夜郎西。</p></blockquote><p><img src="https://github.com/glmapper/glmapper.github.io/blob/master/images/self/shufa-yanghualuojinziguiti.jpg?raw=true" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;春江花月夜 -张若虚&lt;br&gt;春江潮水连海平，海上明月共潮生。&lt;br&gt;滟滟随波千万里，何处春江无月明！&lt;br&gt;江流宛转绕芳甸，月照花林皆似霰；&lt;br&gt;空里流霜不觉飞，汀上白沙看不见。&lt;br&gt;江天一色无纤尘，皎皎空中孤月轮。&lt;br&gt;江畔何人初见月？江月
      
    
    </summary>
    
      <category term="书法" scheme="http://www.glmapper.com/categories/%E4%B9%A6%E6%B3%95/"/>
    
    
      <category term="书法" scheme="http://www.glmapper.com/tags/%E4%B9%A6%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringSession:存储机制设计</title>
    <link href="http://www.glmapper.com/2018/12/16/spring-session-redis-map/"/>
    <id>http://www.glmapper.com/2018/12/16/spring-session-redis-map/</id>
    <published>2018-12-15T17:30:38.000Z</published>
    <updated>2018-12-15T17:40:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>@<a href="SpringSession：存储机制设计">TOC</a><br>在之前的文章中已经对<code>SpringSession</code>的功能结构，请求/响应重写等做了介绍。本文将继续来介绍下<code>SpringSession</code>中存储部分的设计。存储是分布式<code>session</code>中算是最核心的部分，通过引入三方的存储容器来实现<code>session</code>的存储，从而有效的解决<code>session</code>共享的问题。</p><h2 id="1、SpringSession存储的顶级抽象接口"><a href="#1、SpringSession存储的顶级抽象接口" class="headerlink" title="1、SpringSession存储的顶级抽象接口"></a>1、SpringSession存储的顶级抽象接口</h2><p><code>SpringSession</code>存储的顶级抽象接口是<code>org.springframework.session</code>包下的<code>SessionRepository</code>这个接口。<code>SessionRepository</code>的类图结构如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef7ce8c6b58?w=1662&amp;h=600&amp;f=png&amp;s=66844" alt=""></p><p>这里先来看下<code>SessionRepository</code>这个顶层接口中定义了哪些方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SessionRepository</span>&lt;<span class="title">S</span> <span class="keyword">extends</span> <span class="title">Session</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个session</span></span><br><span class="line"><span class="function">S <span class="title">createSession</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//保存session</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(S session)</span></span>;</span><br><span class="line"><span class="comment">//通过ID查找session</span></span><br><span class="line"><span class="function">S <span class="title">findById</span><span class="params">(String id)</span></span>;</span><br><span class="line"><span class="comment">//通过ID删除一个session</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码来看还是很简单的，就是增删查。下面看具体实现。在2.0版本开始<code>SpringSession</code>中也提供了一个和<code>SessionRepository</code>具体相同能力的<code>ReactiveSessionRepository</code>，用于支持响应式编程模式。</p><h2 id="2、MapSessionRepository"><a href="#2、MapSessionRepository" class="headerlink" title="2、MapSessionRepository"></a>2、MapSessionRepository</h2><p>基于HashMap实现的基于内存存储的存储器实现，这里就主要看下对于接口中几个方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapSessionRepository</span> <span class="keyword">implements</span> <span class="title">SessionRepository</span>&lt;<span class="title">MapSession</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer defaultMaxInactiveInterval;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Session&gt; sessions;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到就是一个<code>Map</code>，那后面关于增删查其实就是操作这个<code>Map</code>了。</p><h3 id="createSession"><a href="#createSession" class="headerlink" title="createSession"></a>createSession</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MapSession <span class="title">createSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MapSession result = <span class="keyword">new</span> MapSession();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.defaultMaxInactiveInterval != <span class="keyword">null</span>) &#123;</span><br><span class="line">result.setMaxInactiveInterval(</span><br><span class="line">Duration.ofSeconds(<span class="keyword">this</span>.defaultMaxInactiveInterval));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很直接，就是<code>new</code>了一个<code>MapSession</code>，然后设置了<code>session</code>的有效期。</p><h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(MapSession session)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!session.getId().equals(session.getOriginalId())) &#123;</span><br><span class="line"><span class="keyword">this</span>.sessions.remove(session.getOriginalId());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.sessions.put(session.getId(), <span class="keyword">new</span> MapSession(session));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面先判断了<code>session</code>中的两个<code>ID</code>，一个<code>originalId</code>，一个当前<code>id</code>。<code>originalId</code>是第一次生成<code>session</code>对象时创建的，后面都不会在变化。通过源码来看，对于<code>originalId</code>，只提供了<code>get</code>方法。对于<code>id</code>呢，其实是可以通过<code>changeSessionId</code>来改变的。</p><p>这里的这个操作实际上是一种优化行为，及时的清除掉老的<code>session</code>数据来释放内存空间。</p><h3 id="findById"><a href="#findById" class="headerlink" title="findById"></a>findById</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MapSession <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">Session saved = <span class="keyword">this</span>.sessions.get(id);</span><br><span class="line"><span class="keyword">if</span> (saved == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (saved.isExpired()) &#123;</span><br><span class="line">deleteById(saved.getId());</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MapSession(saved);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个逻辑也很简单，先从<code>Map</code>中根据<code>id</code>取出<code>session</code>数据，如果没有就返回<code>null</code>，如果有则再判断下是否过期了，如果过期了就删除掉，然后返回<code>null</code>。如果查到了，并且没有过期的话，则构建一个<code>MapSession</code>返回。</p><p>OK，基于内存存储的实现系列就是这些了，下面继续来看其他存储的实现。</p><h2 id="3、FindByIndexNameSessionRepository"><a href="#3、FindByIndexNameSessionRepository" class="headerlink" title="3、FindByIndexNameSessionRepository"></a>3、FindByIndexNameSessionRepository</h2><p><code>FindByIndexNameSessionRepository</code>继承了<code>SessionRepository</code>接口，用于扩展对第三方存储的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FindByIndexNameSessionRepository</span>&lt;<span class="title">S</span> <span class="keyword">extends</span> <span class="title">Session</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">SessionRepository</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">String PRINCIPAL_NAME_INDEX_NAME = FindByIndexNameSessionRepository.class.getName()</span><br><span class="line">.concat(<span class="string">".PRINCIPAL_NAME_INDEX_NAME"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">Map&lt;String, S&gt; <span class="title">findByIndexNameAndIndexValue</span><span class="params">(String indexName, String indexValue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> Map&lt;String, S&gt; <span class="title">findByPrincipalName</span><span class="params">(String principalName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> findByIndexNameAndIndexValue(PRINCIPAL_NAME_INDEX_NAME, principalName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FindByIndexNameSessionRepository</code>添加一个单独的方法为指定用户查询所有会话。这是通过设置名为<code>FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME</code>的<code>Session</code>的属性值为指定用户的<code>username</code>来完成的。开发人员有责任确保属性被赋值，因为<code>SpringSession</code>不会在意被使用的认证机制。官方文档中给出的例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String username = <span class="string">"username"</span>;</span><br><span class="line"><span class="keyword">this</span>.session.setAttribute(</span><br><span class="line">FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME, username);</span><br></pre></td></tr></table></figure><p><code>FindByIndexNameSessionRepository</code>的一些实现会提供一些钩子自动的索引其他的<code>session</code>属性。比如，很多实现都会自动的确保当前的<code>Spring Security</code>用户名称可通过索引名称<code>FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME</code>进行索引。一旦会话被索引，就可以通过下面的代码检索：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String username = <span class="string">"username"</span>;</span><br><span class="line">Map&lt;String, Session&gt; sessionIdToSession = </span><br><span class="line"><span class="keyword">this</span>.sessionRepository.findByIndexNameAndIndexValue(</span><br><span class="line">FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME,username);</span><br></pre></td></tr></table></figure><p>下图是<code>FindByIndexNameSessionRepository</code>接口的三个实现类：<br><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef0284d86a5?w=1624&amp;h=258&amp;f=png&amp;s=66960" alt="FindByIndexNameSessionRepository"></p><p>下面来分别分析下这三个存储的实现细节。</p><h3 id="3-1-RedisOperationsSessionRepository"><a href="#3-1-RedisOperationsSessionRepository" class="headerlink" title="3.1 RedisOperationsSessionRepository"></a>3.1 RedisOperationsSessionRepository</h3><p><code>RedisOperationsSessionRepository</code>的类图结构如下，<code>MessageListener</code>是<code>redis</code>消息订阅的监听接口。<br><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef029530952?w=1128&amp;h=596&amp;f=png&amp;s=67475" alt="在这里插入图片描述"></p><p>代码有点长，就不在这里面贴了，一些注释可以在这个 <a href="https://github.com/glmapper/spring-session/tree/cn-spring-session" target="_blank" rel="noopener">SpringSession中文分支</a> 来看。这里还是主要来看下对于那几个方法的实现。</p><h4 id="3-1-1-createSession"><a href="#3-1-1-createSession" class="headerlink" title="3.1.1 createSession"></a>3.1.1 createSession</h4><p>这里和<code>MapSessionRepository</code>的实现基本一样的，那区别就在于<code>Session</code>的封装模型不一样，这里是<code>RedisSession</code>，实际上<code>RedisSession</code>的实现是对<code>MapSession</code>又包了一层。下面会分析<code>RedisSession</code>这个类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisSession <span class="title">createSession</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// RedisSession,这里和MapSession区别开</span></span><br><span class="line">RedisSession redisSession = <span class="keyword">new</span> RedisSession();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.defaultMaxInactiveInterval != <span class="keyword">null</span>) &#123;</span><br><span class="line">redisSession.setMaxInactiveInterval(</span><br><span class="line">Duration.ofSeconds(<span class="keyword">this</span>.defaultMaxInactiveInterval));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> redisSession;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在看其他两个方法之前，先来看下<code>RedisSession</code>这个类。</p><h4 id="3-1-2-RedisSession"><a href="#3-1-2-RedisSession" class="headerlink" title="3.1.2 RedisSession"></a>3.1.2 RedisSession</h4><p>这个在模型上是对<code>MapSession</code>的扩展，增加了<code>delta</code>这个东西。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSession</span> <span class="keyword">implements</span> <span class="title">Session</span> </span>&#123;</span><br><span class="line">       <span class="comment">// MapSession 实例对象，主要存数据的地方</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MapSession cached;</span><br><span class="line"><span class="comment">// 原始最后访问时间</span></span><br><span class="line"><span class="keyword">private</span> Instant originalLastAccessTime;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; delta = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 是否是新的session对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isNew;</span><br><span class="line"><span class="comment">// 原始主名称</span></span><br><span class="line"><span class="keyword">private</span> String originalPrincipalName;</span><br><span class="line"><span class="comment">// 原始sessionId</span></span><br><span class="line"><span class="keyword">private</span> String originalSessionId;</span><br></pre></td></tr></table></figure></p><p><code>delta</code>是一个Map结构，那么这里面到底是放什么的呢？具体细节见 <a href="https://github.com/glmapper/spring-session/blob/cn-spring-session/spring-session-data-redis/src/main/java/org/springframework/session/data/redis/RedisOperationsSessionRepository.java" target="_blank" rel="noopener">saveDelta</a> 这个方法。<code>saveDelta</code> 这个方法会在两个地方被调用，一个是下面要说道的<code>save</code>方法，另外一个是 <code>flushImmediateIfNecessary</code> 这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushImmediateIfNecessary</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (RedisOperationsSessionRepository.<span class="keyword">this</span>.redisFlushMode == RedisFlushMode.IMMEDIATE) &#123;</span><br><span class="line">saveDelta();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>RedisFlushMode</code>提供了两种推送模式：</p><ul><li>ON_SAVE：只有在调用<code>save</code>方法时执行，在<code>web</code>环境中这样做通常是尽快提交HTTP响应</li><li>IMMEDIATE：只要有变更就会直接写到<code>redis</code>中，不会像<code>ON_SAVE</code>一样，在最后<code>commit</code>时一次性写入</li></ul><p>追踪<code>flushImmediateIfNecessary</code> 方法调用链如下：<br><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef032721690?w=1008&amp;h=258&amp;f=png&amp;s=89571" alt="在这里插入图片描述"><br>那么到这里基本就清楚了，首先<code>save</code>这个方法，当主动调用<code>save</code>时就是将数据推到<code>redis</code>中去的，也就是<code>ON_SAVE</code>这种情况。那么对于<code>IMMEDIATE</code>这种情况，只有调用了上面的四个方法，<code>SpringSession</code> 才会将数据推送到<code>redis</code>。</p><p>所以<code>delta</code>里面存的是当前一些变更的 <code>key-val</code> 键值对象，而这些变更是由<code>setAttribute</code>、<code>removeAttribute</code>、<code>setMaxInactiveIntervalInSeconds</code>、<code>setLastAccessedTime</code>这四个方法触发的；比如<code>setAttribute(k,v)</code>，那么这个<code>k-&gt;v</code>就会被保存到<code>delta</code>里面。</p><h4 id="3-1-3-save"><a href="#3-1-3-save" class="headerlink" title="3.1.3 save"></a>3.1.3 save</h4><p>在理解了<code>saveDelta</code>方法之后再来看<code>save</code>方法就简单多了。<code>save</code> 对应的就是<code>RedisFlushMode.ON_SAVE</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(RedisSession session)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 直接调用 saveDelta推数据到redis</span></span><br><span class="line">session.saveDelta();</span><br><span class="line"><span class="keyword">if</span> (session.isNew()) &#123;</span><br><span class="line">   <span class="comment">// sessionCreatedKey-&gt;channl</span></span><br><span class="line">String sessionCreatedKey = getSessionCreatedChannel(session.getId());</span><br><span class="line"><span class="comment">// 发布一个消息事件，新增 session，以供 MessageListener 回调处理。</span></span><br><span class="line"><span class="keyword">this</span>.sessionRedisOperations.convertAndSend(sessionCreatedKey, session.delta);</span><br><span class="line">session.setNew(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-4-findById"><a href="#3-1-4-findById" class="headerlink" title="3.1.4 findById"></a>3.1.4 findById</h4><p>查询这部分和基于<code>Map</code>的差别比较大，因为这里并不是直接操作<code>Map</code>，而是与<code>Redis</code> 进行一次交互。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisSession <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getSession(id, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用<code>getSession</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RedisSession <span class="title">getSession</span><span class="params">(String id, <span class="keyword">boolean</span> allowExpired)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据ID从redis中取出数据</span></span><br><span class="line">Map&lt;Object, Object&gt; entries = getSessionBoundHashOperations(id).entries();</span><br><span class="line"><span class="keyword">if</span> (entries.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转换成MapSession</span></span><br><span class="line">MapSession loaded = loadSession(id, entries);</span><br><span class="line"><span class="keyword">if</span> (!allowExpired &amp;&amp; loaded.isExpired()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转换成RedisSession</span></span><br><span class="line">RedisSession result = <span class="keyword">new</span> RedisSession(loaded);</span><br><span class="line">result.originalLastAccessTime = loaded.getLastAccessedTime();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>loadSession</code>中构建<code>MapSession</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MapSession <span class="title">loadSession</span><span class="params">(String id, Map&lt;Object, Object&gt; entries)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 生成MapSession实例</span></span><br><span class="line">MapSession loaded = <span class="keyword">new</span> MapSession(id);</span><br><span class="line"><span class="comment">//遍历数据</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entries.entrySet()) &#123;</span><br><span class="line">String key = (String) entry.getKey();</span><br><span class="line"><span class="keyword">if</span> (CREATION_TIME_ATTR.equals(key)) &#123;</span><br><span class="line">    <span class="comment">// 设置创建时间</span></span><br><span class="line">loaded.setCreationTime(Instant.ofEpochMilli((<span class="keyword">long</span>) entry.getValue()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (MAX_INACTIVE_ATTR.equals(key)) &#123;</span><br><span class="line"> <span class="comment">// 设置最大有效时间</span></span><br><span class="line">loaded.setMaxInactiveInterval(Duration.ofSeconds((<span class="keyword">int</span>) entry.getValue()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (LAST_ACCESSED_ATTR.equals(key)) &#123;</span><br><span class="line"><span class="comment">// 设置最后访问时间</span></span><br><span class="line">loaded.setLastAccessedTime(Instant.ofEpochMilli((<span class="keyword">long</span>) entry.getValue()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key.startsWith(SESSION_ATTR_PREFIX)) &#123;</span><br><span class="line"><span class="comment">// 设置属性</span></span><br><span class="line">loaded.setAttribute(key.substring(SESSION_ATTR_PREFIX.length()),</span><br><span class="line">entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> loaded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-5-deleteById"><a href="#3-1-5-deleteById" class="headerlink" title="3.1.5 deleteById"></a>3.1.5 deleteById</h4><p>根据<code>sessionId</code>删除<code>session</code>数据。具体过程看代码注释。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(String sessionId)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取 RedisSession</span></span><br><span class="line">RedisSession session = getSession(sessionId, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">if</span> (session == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// 清楚当前session数据的索引</span></span><br><span class="line">cleanupPrincipalIndex(session);</span><br><span class="line"><span class="comment">//执行删除操作</span></span><br><span class="line"><span class="keyword">this</span>.expirationPolicy.onDelete(session);</span><br><span class="line">String expireKey = getExpiredKey(session.getId());</span><br><span class="line"><span class="comment">//删除expireKey</span></span><br><span class="line"><span class="keyword">this</span>.sessionRedisOperations.delete(expireKey);</span><br><span class="line"><span class="comment">//session有效期设置为0</span></span><br><span class="line">session.setMaxInactiveInterval(Duration.ZERO);</span><br><span class="line">save(session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-1-6-onMessage"><a href="#3-1-6-onMessage" class="headerlink" title="3.1.6 onMessage"></a>3.1.6 onMessage</h4><p>最后来看下这个订阅回调处理。这里看下核心的一段逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isDeleted = channel.equals(<span class="keyword">this</span>.sessionDeletedChannel);</span><br><span class="line"><span class="comment">// Deleted 还是 Expired ？</span></span><br><span class="line"><span class="keyword">if</span> (isDeleted || channel.equals(<span class="keyword">this</span>.sessionExpiredChannel)) &#123;</span><br><span class="line"><span class="comment">// 此处省略无关代码</span></span><br><span class="line"><span class="comment">// Deleted</span></span><br><span class="line"><span class="keyword">if</span> (isDeleted) &#123;</span><br><span class="line">   <span class="comment">// 发布一个 SessionDeletedEvent 事件</span></span><br><span class="line">handleDeleted(session);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Expired</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 发布一个 SessionExpiredEvent 事件</span></span><br><span class="line">handleExpired(session);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-Redis-存储的一些思考"><a href="#3-2-Redis-存储的一些思考" class="headerlink" title="3.2 Redis 存储的一些思考"></a>3.2 Redis 存储的一些思考</h3><p>首先按照我们自己常规的思路来设计的话，我们会怎么来考虑这个事情。这里首先要声明下，我对 <code>Redis</code> 这个东西不是很熟，没有做过深入的研究；那如果是我来做，可能也就仅仅限于存储。</p><ul><li><code>findByIndexNameAndIndexValue</code>的设计，这个的作用是通过<code>indexName</code>和<code>indexValue</code>来返回当前用户的所有会话。但是这里需要考虑的一个事情是，通常情况下，一个用户只会关联到一个会话上面去，那这种设计很显然，我的理解是为了支持单用户多会话的场景。<ul><li>indexName：FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME</li><li>indexValue：username</li></ul></li><li><p>实现 <code>MessageListener</code> 接口，增加事件通知能力。通过监听这些事件，可以做一些<code>session</code>操作管控。但是实际上 <code>SpringSession</code> 中并没有做任何事情，从代码来看，<code>publishEvent</code>方法是空实现。等待回复中 <a href="https://github.com/spring-projects/spring-session/issues/1287" target="_blank" rel="noopener">#issue 1287</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ApplicationEventPublisher eventPublisher = <span class="keyword">new</span> ApplicationEventPublisher() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>RedisFlushMode</code> ，<code>SpringSession</code>中提供了两种模式的推送，一种是<code>ON_SAVE</code>，另外一种是<code>IMMEDIATE</code>。默认是<code>ON_SAVE</code>，也就是常规的在请求处理结束时进行一次<code>sessionCommit</code>操作。<code>RedisFlushMode</code> 的设计感觉是为<code>session</code>数据持久化的时机提供了另外一种思路。</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>存储机制设计部分就一基于内存和基于<code>Redis</code>两种来分析；另外基于<code>jdbc</code>和<code>hazelcast</code>有兴趣的同学可以自己查看源码。</p><p>最后也欢迎访问我的个人博客：<a href="http://www.glmapper.com">www.glmapper.com</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/zyhlwzy/article/details/78062646" target="_blank" rel="noopener">https://blog.csdn.net/zyhlwzy/article/details/78062646</a></li><li><a href="https://docs.spring.io/spring-session/docs/2.0.0.M4/reference/html5/#api" target="_blank" rel="noopener">https://docs.spring.io/spring-session/docs/2.0.0.M4/reference/html5/#api</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@&lt;a href=&quot;SpringSession：存储机制设计&quot;&gt;TOC&lt;/a&gt;&lt;br&gt;在之前的文章中已经对&lt;code&gt;SpringSession&lt;/code&gt;的功能结构，请求/响应重写等做了介绍。本文将继续来介绍下&lt;code&gt;SpringSession&lt;/code&gt;中存储部
      
    
    </summary>
    
      <category term="spring" scheme="http://www.glmapper.com/categories/spring/"/>
    
      <category term="session" scheme="http://www.glmapper.com/categories/spring/session/"/>
    
    
      <category term="spring" scheme="http://www.glmapper.com/tags/spring/"/>
    
      <category term="session" scheme="http://www.glmapper.com/tags/session/"/>
    
  </entry>
  
  <entry>
    <title>SOFATracer 插件埋点机制详解</title>
    <link href="http://www.glmapper.com/2018/12/07/sofatracer-mvc-plugin/"/>
    <id>http://www.glmapper.com/2018/12/07/sofatracer-mvc-plugin/</id>
    <published>2018-12-07T14:34:14.000Z</published>
    <updated>2018-12-07T14:37:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SOFATracer 是一个用于分布式系统调用跟踪的组件，通过统一的 <code>traceId</code> 将调用链路中的各种网络调用情况以日志的方式记录下来，以达到透视化网络调用的目的。这些日志可用于故障的快速发现，服务治理等。</p></blockquote><p>从 <a href="http://www.sofastack.tech/sofa-tracer/docs/roadmap" target="_blank" rel="noopener">RoadMap</a> 和 <a href="https://github.com/alipay/sofa-tracer/pulls" target="_blank" rel="noopener">PR</a> 来看，目前 SOFATracer 已经支持了丰富的组件插件埋点。</p><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543318400761-682a9d1a-b194-4a87-9fac-9e1a38a9247e.png" alt="img"></p><p>目前还未支持的主要是 Dubbo、MQ 以及 Redis 等。本文将从 SOFATracer 已提供的一个插件源码来分析下 SOFATracer 插件的埋点实现。</p><h2 id="1-SOFATracer-插件埋点机制"><a href="#1-SOFATracer-插件埋点机制" class="headerlink" title="1 SOFATracer 插件埋点机制"></a>1 SOFATracer 插件埋点机制</h2><p>SOFATracer 插件的作用实际上就是对于不同组件进行埋点，以便于收集这些组件的链路数据。SOFATracer 埋点方式一般是通过 Filter、Interceptor 机制实现的。</p><p>另一个是，SOFATracer 的埋点方式并不是基于 OT-api 进行埋点的，而是基于 SOFATracer 自己的 api 进行埋点的，详见 <a href="https://github.com/alipay/sofa-tracer/issues/126" target="_blank" rel="noopener">issue#126</a>。</p><h3 id="1-1-Filter-or-Interceptor"><a href="#1-1-Filter-or-Interceptor" class="headerlink" title="1.1 Filter or Interceptor"></a>1.1 Filter or Interceptor</h3><p>目前已实现的插件中，像 MVC 插件是基于 Filter 进行埋点的，httpclient、resttemplate 等是基于Interceptor进行埋点的。在实现插件时，要根据不同插件的特性来选择具体的埋点方式。</p><p> 当然除了这两种方式之外还可以通过静态代理的方式来实现埋点。比如 sofa-tracer-datasource-plugin 插件就是将不同的数据源进行统一代理给 SmartDatasource，从而实现埋点的。</p><h3 id="1-2-AbstractTracer-API"><a href="#1-2-AbstractTracer-API" class="headerlink" title="1.2 AbstractTracer API"></a>1.2 AbstractTracer API</h3><p>SOFATracer 中所有的插件均需要实现自己的 Tracer 实例，如 Mvc 的 SpringMvcTracer 、HttpClient的 HttpClientTracer 等，这一点与基于 Opentracing-api 接口埋点的实现有所区别。</p><ul><li>1、基于 SOFATracer api 埋点方式插件扩展</li></ul><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543324415543-aba1c5fe-7cb4-46ae-9aee-2fe5441a5f98.png" alt="img"></p><p>AbstractTracer 是 SOFATracer 用于插件扩展使用的一个抽象类，根据插件类型不同，又可以分为 clientTracer 和 serverTracer，分别对应于：AbstractClientTracer 和 AbstractServerTracer，再通过 AbstractClientTracer 和 AbstractServerTracer 衍生出具体的组件 Tracer 实现。这种方式的好处在于，所有的插件实现均由 SOFATracer 本身来管控，对于不同的组件可以轻松的实现差异化和定制化。缺点也源于此，每增加一个组件都需要做一些重复工作。</p><ul><li>2、基于 OpenTracing-api 埋点方式插件扩展</li></ul><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543324680485-cdb3793c-b830-490e-832f-b58e12091f7d.png" alt="img"></p><p>这种埋点方式不基于 SOFATracer  自身提供的 API，而是基于 OpenTracing-api 接口。因为均遵循 OpenTracing-api 规范，所以组件和 Tracer 实现可以独立分开来维护。这样就可以对接开源的一些基于 OpenTracing-api 规范实现的组件。例如：<a href="https://github.com/opentracing-contrib" target="_blank" rel="noopener">OpenTracing API Contributions</a>。</p><p>SOFATracer 在后面将会在 4.0 版本中支持基于 OT-api 的埋点方式，对外部组件接入扩展提供支持。</p><h3 id="1-3-AbstractTracer"><a href="#1-3-AbstractTracer" class="headerlink" title="1.3 AbstractTracer"></a>1.3 AbstractTracer</h3><p>这里先来看下 AbstractTracer  这个抽象类中具体提供了哪些抽象方法，也就是对于 AbstractClientTracer 和 AbstractServerTracer 需要分别扩展哪些能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取client端 摘要日志日志名</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getClientDigestReporterLogName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取client端 摘要日志滚动策略key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getClientDigestReporterRollingKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取client端 摘要日志日志名key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getClientDigestReporterLogNameKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取client端 摘要日志编码器</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getClientDigestEncoder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 创建client端 统计日志Reporter类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> AbstractSofaTracerStatisticReporter <span class="title">generateClientStatReporter</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志日志名</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getServerDigestReporterLogName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志滚动策略key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getServerDigestReporterRollingKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志日志名key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getServerDigestReporterLogNameKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志编码器</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getServerDigestEncoder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 创建server端 统计日志Reporter类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> AbstractSofaTracerStatisticReporter <span class="title">generateServerStatReporter</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>从  AbstractTracer 类提供的抽象方法来看，不管是 client 还是 server，在具体的 Tracer 组件实现中，都必须提供以下实现：</p><ul><li>DigestReporterLogName :当前组件摘要日志的日志名称</li><li>DigestReporterRollingKey : 当前组件摘要日志的滚动策略</li><li>SpanEncoder：对摘要日志进行编码的编码器实现</li><li>AbstractSofaTracerStatisticReporter : 统计日志 reporter 类的实现类。</li></ul><h2 id="2-SpringMVC-插件埋点分析"><a href="#2-SpringMVC-插件埋点分析" class="headerlink" title="2 SpringMVC 插件埋点分析"></a>2 SpringMVC 插件埋点分析</h2><p>这里我们以 SpringMVC 插件为例，来分析下如何实现一个埋点插件的。这里是官方给出的案例工程：基于 <a href="https://github.com/alipay/sofa-tracer/blob/master/tracer-samples/tracer-sample-with-springmvc" target="_blank" rel="noopener">Spring MVC 示例落地日志</a> 。</p><h3 id="2-1-实现-Tracer-实例"><a href="#2-1-实现-Tracer-实例" class="headerlink" title="2.1 实现 Tracer 实例"></a>2.1 实现 Tracer 实例</h3><p>SpringMvcTracer 继承了 AbstractServerTracer 类，是对 serverTracer 的扩展。</p><blockquote><p>PS：如何确定一个组件是client端还是server端呢？就是看当前组件是请求的发起方还是请求的接受方，如果是请求发起方则一般是client端，如果是请求接收方则是 server 端。那么对于 MVC 来说，是请求接受方，因此这里实现了 AbstractServerTracer 类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcTracer</span> <span class="keyword">extends</span> <span class="title">AbstractServerTracer</span></span></span><br></pre></td></tr></table></figure><h4 id="2-1-1-构造函数与单例对象"><a href="#2-1-1-构造函数与单例对象" class="headerlink" title="2.1.1 构造函数与单例对象"></a>2.1.1 构造函数与单例对象</h4><p>在构造函数中，需要传入当前 Tracer 的 traceType，SpringMvcTracer 的 traceType 为 “springmvc”。这里也可以看到，tracer 实例是一个单例对象，对于其他插件也是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SpringMvcTracer springMvcTracer = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * Spring MVC Tracer Singleton</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> singleton</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SpringMvcTracer <span class="title">getSpringMvcTracerSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (springMvcTracer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SpringMvcTracer.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (springMvcTracer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                springMvcTracer = <span class="keyword">new</span> SpringMvcTracer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> springMvcTracer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SpringMvcTracer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"springmvc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-AbstractServerTracer-抽象类"><a href="#2-1-2-AbstractServerTracer-抽象类" class="headerlink" title="2.1.2 AbstractServerTracer 抽象类"></a>2.1.2 AbstractServerTracer 抽象类</h4><p>在看 SpringMvcTracer 实现之前，先来看下 AbstractServerTracer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractServerTracer</span> <span class="keyword">extends</span> <span class="title">AbstractTracer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数，子类必须提供一个构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractServerTracer</span><span class="params">(String tracerType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(tracerType, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为是server端，所以Client先关的提供了默认实现，返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getClientDigestReporterLogName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getClientDigestReporterRollingKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getClientDigestReporterLogNameKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getClientDigestEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AbstractSofaTracerStatisticReporter <span class="title">generateClientStatReporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合上面  AbstractTracer 小节中抽象方法分析，这里在 AbstractServerTracer 中将 client 对应的抽象方法提供了默认实现，也就是说如果要继承 AbstractServerTracer 类，那么就必须实现 server 对应的所有抽象方法。</p><h4 id="2-1-3-SpringMVCTracer-实现"><a href="#2-1-3-SpringMVCTracer-实现" class="headerlink" title="2.1.3 SpringMVCTracer 实现"></a>2.1.3 SpringMVCTracer 实现</h4><p>下面是 SpringMvcTracer 部分对 server 部分抽象方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getServerDigestReporterLogName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SpringMvcLogEnum.SPRING_MVC_DIGEST.getDefaultLogName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getServerDigestReporterRollingKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SpringMvcLogEnum.SPRING_MVC_DIGEST.getRollingKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getServerDigestReporterLogNameKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SpringMvcLogEnum.SPRING_MVC_DIGEST.getLogNameKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getServerDigestEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Boolean.TRUE.toString().equalsIgnoreCase(</span><br><span class="line">        SofaTracerConfiguration.getProperty(SPRING_MVC_JSON_FORMAT_OUTPUT))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringMvcDigestJsonEncoder();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringMvcDigestEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AbstractSofaTracerStatisticReporter <span class="title">generateServerStatReporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> generateSofaMvcStatReporter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前 SOFATracer 日志名、滚动策略key等都是通过枚举类来定义的，也就是一个组件会对应这样一个枚举类，在枚举类里面定义这些常量。</p><h3 id="2-2-SpringMvcLogEnum-类实现"><a href="#2-2-SpringMvcLogEnum-类实现" class="headerlink" title="2.2 SpringMvcLogEnum 类实现"></a>2.2 SpringMvcLogEnum 类实现</h3><p>SpringMVC 插件中的枚举类是 SpringMvcLogEnum。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SpringMvcLogEnum &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 摘要日志相关</span></span><br><span class="line">    SPRING_MVC_DIGEST(<span class="string">"spring_mvc_digest_log_name"</span>, </span><br><span class="line">                      <span class="string">"spring-mvc-digest.log"</span>,</span><br><span class="line">                      <span class="string">"spring_mvc_digest_rolling"</span>), </span><br><span class="line">    <span class="comment">// 统计日志相关</span></span><br><span class="line">    SPRING_MVC_STAT(<span class="string">"spring_mvc_stat_log_name"</span>, </span><br><span class="line">                    <span class="string">"spring-mvc-stat.log"</span>, </span><br><span class="line">                    <span class="string">"spring_mvc_stat_rolling"</span>);</span><br><span class="line">    <span class="comment">// 省略部分代码....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 XXXLogEnum 枚举类中定义了当前组件对应的摘要日志和统计日志的日志名和滚动策略，因为 SOFATracer 目前还没有服务端的能力，链路数据不是直接上报给 server 的，因此 SOFATracer 提供了落到磁盘的能力。不同插件的链路日志也会通过 XXXLogEnum 指定的名称将链路日志输出到各个组件对应的日志目录下。</p><h3 id="2-3-统计日志-Reportor-实现"><a href="#2-3-统计日志-Reportor-实现" class="headerlink" title="2.3 统计日志 Reportor 实现"></a>2.3 统计日志 Reportor 实现</h3><p>SOFATracer 中统计日志打印的实现需要各个组件自己来完成，具体就是需要实现一个AbstractSofaTracerStatisticReporter 的子类，然后实现 doReportStat 这个方法。当然对于目前的实现来说，我们也会重写 print 方法。</p><h4 id="2-3-1-doReportStat"><a href="#2-3-1-doReportStat" class="headerlink" title="2.3.1 doReportStat"></a>2.3.1 doReportStat</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doReportStat</span><span class="params">(SofaTracerSpan sofaTracerSpan)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; tagsWithStr = sofaTracerSpan.getTagsWithStr();</span><br><span class="line">    <span class="comment">// 构建StatMapKey对象</span></span><br><span class="line">    StatMapKey statKey = <span class="keyword">new</span> StatMapKey();</span><br><span class="line">    <span class="comment">// 增加 key:当前应用名</span></span><br><span class="line">    statKey.addKey(CommonSpanTags.LOCAL_APP, tagsWithStr.get(CommonSpanTags.LOCAL_APP));</span><br><span class="line">    <span class="comment">// 增加 key:请求 url</span></span><br><span class="line">    statKey.addKey(CommonSpanTags.REQUEST_URL, tagsWithStr.get(CommonSpanTags.REQUEST_URL));</span><br><span class="line">    <span class="comment">// 增加 key:请求方法</span></span><br><span class="line">    statKey.addKey(CommonSpanTags.METHOD, tagsWithStr.get(CommonSpanTags.METHOD));</span><br><span class="line">    <span class="comment">// 压测标志</span></span><br><span class="line">    statKey.setLoadTest(TracerUtils.isLoadTest(sofaTracerSpan));</span><br><span class="line">    <span class="comment">// 请求响应码</span></span><br><span class="line">    String resultCode = tagsWithStr.get(CommonSpanTags.RESULT_CODE);</span><br><span class="line">    <span class="comment">// 请求成功标识</span></span><br><span class="line">    <span class="keyword">boolean</span> success = (resultCode != <span class="keyword">null</span> &amp;&amp; resultCode.length() &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span></span><br><span class="line">        .isHttpOrMvcSuccess(resultCode));</span><br><span class="line">    statKey.setResult(success ? <span class="string">"true"</span> : <span class="string">"false"</span>);</span><br><span class="line">    <span class="comment">//end</span></span><br><span class="line">    statKey.setEnd(TracerUtils.getLoadTestMark(sofaTracerSpan));</span><br><span class="line">    <span class="comment">//value the count and duration</span></span><br><span class="line">    <span class="keyword">long</span> duration = sofaTracerSpan.getEndTime() - sofaTracerSpan.getStartTime();</span><br><span class="line">    <span class="keyword">long</span> values[] = <span class="keyword">new</span> <span class="keyword">long</span>[] &#123; <span class="number">1</span>, duration &#125;;</span><br><span class="line">    <span class="comment">// reserve</span></span><br><span class="line">    <span class="keyword">this</span>.addStat(statKey, values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里就是就是将统计日志添加到日志槽里，等待被消费(输出到日志)。具体可以参考：SofaTracerStatisticReporterManager.StatReporterPrinter。</p><h4 id="2-3-2-print"><a href="#2-3-2-print" class="headerlink" title="2.3.2 print"></a>2.3.2 print</h4><p>print 方法是实际将数据写入到磁盘的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(StatKey statKey, <span class="keyword">long</span>[] values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isClosePrint.get()) &#123;</span><br><span class="line">        <span class="comment">//关闭统计日志输出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(statKey <span class="keyword">instanceof</span> StatMapKey)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StatMapKey statMapKey = (StatMapKey) statKey;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 构建需要打印的数据串</span></span><br><span class="line">        jsonBuffer.reset();</span><br><span class="line">        jsonBuffer.appendBegin();</span><br><span class="line">        jsonBuffer.append(<span class="string">"time"</span>, Timestamp.currentTime());</span><br><span class="line">        jsonBuffer.append(<span class="string">"stat.key"</span>, <span class="keyword">this</span>.statKeySplit(statMapKey));</span><br><span class="line">        jsonBuffer.append(<span class="string">"count"</span>, values[<span class="number">0</span>]);</span><br><span class="line">        jsonBuffer.append(<span class="string">"total.cost.milliseconds"</span>, values[<span class="number">1</span>]);</span><br><span class="line">        jsonBuffer.append(<span class="string">"success"</span>, statMapKey.getResult());</span><br><span class="line">        <span class="comment">//压测</span></span><br><span class="line">        jsonBuffer.appendEnd(<span class="string">"load.test"</span>, statMapKey.getEnd());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (appender <span class="keyword">instanceof</span> LoadTestAwareAppender) &#123;</span><br><span class="line">            ((LoadTestAwareAppender) appender).append(jsonBuffer.toString(),</span><br><span class="line">                statMapKey.isLoadTest());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            appender.append(jsonBuffer.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里强制刷一次</span></span><br><span class="line">        appender.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        SelfLog.error(<span class="string">"统计日志&lt;"</span> + statTracerName + <span class="string">"&gt;输出异常"</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>print 这个方法里面就是将 statMapKey 中，也就是 doReportStat 中塞进来的数据转换成  json 格式，然后刷到磁盘。需要注意的是这里是强制 flush 了一次。如果没有重写 print 这个方法的话，则是在SofaTracerStatisticReporterManager.StatReporterPrinter 里面调用 print 方法刷到磁盘。</p><h3 id="2-4-数据传播格式实现"><a href="#2-4-数据传播格式实现" class="headerlink" title="2.4 数据传播格式实现"></a>2.4 数据传播格式实现</h3><p>SOFATracer 支持使用 OpenTracing 的内建格式进行上下文传播。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcHeadersCarrier</span> <span class="keyword">implements</span> <span class="title">TextMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, String&gt; headers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpringMvcHeadersCarrier</span><span class="params">(HashMap&lt;String, String&gt; headers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.headers = headers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        headers.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> headers.entrySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-自定义编码格式实现"><a href="#2-5-自定义编码格式实现" class="headerlink" title="2.5 自定义编码格式实现"></a>2.5 自定义编码格式实现</h3><p>这个决定了摘要日志打印的格式，和在统计日志里面的实现要有所区分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcDigestJsonEncoder</span> <span class="keyword">extends</span> <span class="title">AbstractDigestSpanEncoder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重写encode,对span进行编码处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(SofaTracerSpan span)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        JsonStringBuilder jsonStringBuilder = <span class="keyword">new</span> JsonStringBuilder();</span><br><span class="line">        <span class="comment">//日志打印时间</span></span><br><span class="line">        jsonStringBuilder.appendBegin(<span class="string">"time"</span>, Timestamp.format(span.getEndTime()));</span><br><span class="line">        appendSlot(jsonStringBuilder, span);</span><br><span class="line">        <span class="keyword">return</span> jsonStringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具体字段处理</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendSlot</span><span class="params">(JsonStringBuilder jsonStringBuilder, SofaTracerSpan sofaTracerSpan)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        SofaTracerSpanContext context = sofaTracerSpan.getSofaTracerSpanContext();</span><br><span class="line">        Map&lt;String, String&gt; tagWithStr = sofaTracerSpan.getTagsWithStr();</span><br><span class="line">        Map&lt;String, Number&gt; tagWithNumber = sofaTracerSpan.getTagsWithNumber();</span><br><span class="line">        <span class="comment">//当前应用名</span></span><br><span class="line">        jsonStringBuilder</span><br><span class="line">            .append(CommonSpanTags.LOCAL_APP, tagWithStr.get(CommonSpanTags.LOCAL_APP));</span><br><span class="line">        <span class="comment">//TraceId</span></span><br><span class="line">        jsonStringBuilder.append(<span class="string">"traceId"</span>, context.getTraceId());</span><br><span class="line">        <span class="comment">//RpcId</span></span><br><span class="line">        jsonStringBuilder.append(<span class="string">"spanId"</span>, context.getSpanId());</span><br><span class="line">        <span class="comment">//请求 URL</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.REQUEST_URL,</span><br><span class="line">            tagWithStr.get(CommonSpanTags.REQUEST_URL));</span><br><span class="line">        <span class="comment">//请求方法</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.METHOD, tagWithStr.get(CommonSpanTags.METHOD));</span><br><span class="line">        <span class="comment">//Http 状态码</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.RESULT_CODE,</span><br><span class="line">            tagWithStr.get(CommonSpanTags.RESULT_CODE));</span><br><span class="line">        Number requestSize = tagWithNumber.get(CommonSpanTags.REQ_SIZE);</span><br><span class="line">        <span class="comment">//Request Body 大小 单位为byte</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.REQ_SIZE,</span><br><span class="line">            (requestSize == <span class="keyword">null</span> ? <span class="number">0L</span> : requestSize.longValue()));</span><br><span class="line">        Number responseSize = tagWithNumber.get(CommonSpanTags.RESP_SIZE);</span><br><span class="line">        <span class="comment">//Response Body 大小，单位为byte</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.RESP_SIZE, (responseSize == <span class="keyword">null</span> ? <span class="number">0L</span></span><br><span class="line">            : responseSize.longValue()));</span><br><span class="line">        <span class="comment">//请求耗时（MS）</span></span><br><span class="line">        jsonStringBuilder.append(<span class="string">"time.cost.milliseconds"</span>,</span><br><span class="line">            (sofaTracerSpan.getEndTime() - sofaTracerSpan.getStartTime()));</span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.CURRENT_THREAD_NAME,</span><br><span class="line">            tagWithStr.get(CommonSpanTags.CURRENT_THREAD_NAME));</span><br><span class="line">        <span class="comment">//穿透数据放在最后</span></span><br><span class="line">        jsonStringBuilder.appendEnd(<span class="string">"baggage"</span>, baggageSerialized(context));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里其实也可以看出，统计日志和摘要日志的不同点。统计日志里面核心的数据是 span 里面的 tags 数据，但是其主要作用是统计当前组件的次数。摘要日志里面除了 tags 里面的数据之外还会包括例如 traceId 和 spanId 等信息。</p><ul><li>统计日志</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"time"</span>:<span class="string">"2018-11-28 14:42:25.127"</span>,<span class="attr">"stat.key"</span>:&#123;<span class="attr">"method"</span>:<span class="string">"GET"</span>,<span class="attr">"local.app"</span>:<span class="string">"SOFATracerSpringMVC"</span>,<span class="attr">"request.url"</span>:<span class="string">"http://localhost:8080/springmvc"</span>&#125;,<span class="attr">"count"</span>:<span class="number">3</span>,<span class="attr">"total.cost.milliseconds"</span>:<span class="number">86</span>,<span class="attr">"success"</span>:<span class="string">"true"</span>,<span class="attr">"load.test"</span>:<span class="string">"F"</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>摘要日志</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"time"</span>:<span class="string">"2018-11-28 14:46:08.216"</span>,<span class="attr">"local.app"</span>:<span class="string">"SOFATracerSpringMVC"</span>,<span class="attr">"traceId"</span>:<span class="string">"0a0fe91b1543387568214100259231"</span>,<span class="attr">"spanId"</span>:<span class="string">"0.1"</span>,<span class="attr">"request.url"</span>:<span class="string">"http://localhost:8080/springmvc"</span>,<span class="attr">"method"</span>:<span class="string">"GET"</span>,<span class="attr">"result.code"</span>:<span class="string">"200"</span>,<span class="attr">"req.size.bytes"</span>:<span class="number">-1</span>,<span class="attr">"resp.size.bytes"</span>:<span class="number">0</span>,<span class="attr">"time.cost.milliseconds"</span>:<span class="number">2</span>,<span class="attr">"current.thread.name"</span>:<span class="string">"http-nio-8080-exec-2"</span>,<span class="attr">"baggage"</span>:<span class="string">""</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-请求拦截埋点"><a href="#2-6-请求拦截埋点" class="headerlink" title="2.6 请求拦截埋点"></a>2.6 请求拦截埋点</h3><p>对于基于标准 servlet 实现的组件，要实现对请求的拦截过滤，通常就是 Filter 了。sofa-tracer-springmvc-plugin 插件埋点的实现就是基于 Filter 机制完成的。</p><p>SpringMvcSofaTracerFilter 实现了 javax.servlet.Filter 接口，因此遵循标准的 servlet 规范的容器也可以通过此插件进行埋点。参考文档：<a href="https://github.com/alipay/sofa-tracer/tree/master/tracer-samples/tracer-sample-with-springmvc" target="_blank" rel="noopener">对于标准 servlet 容器的支持（ tomcat/jetty 等）</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcSofaTracerFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span></span><br></pre></td></tr></table></figure><h4 id="2-6-1-基本埋点思路"><a href="#2-6-1-基本埋点思路" class="headerlink" title="2.6.1 基本埋点思路"></a>2.6.1 基本埋点思路</h4><p>对于一个组件来说，一次处理过程一般是产生一个 span。这个span的生命周期是从接收到请求到返回响应这段过程。</p><p>但是这里需要考虑的问题是如何与上下游链路关联起来呢？在 Opentracing 规范中，可以在 Tracer 中 extract 出一个跨进程传递的 SpanContext 。然后通过这个 SpanContext 所携带的信息将当前节点关联到整个 tracer 链路中去。当然有提取(extract)就会有对应的注入(inject)。</p><p>链路的构建一般是 client-server-client-server 这种模式的，那这里就很清楚了，就是会在 client 端进行注入(inject)，然后再 server 端进行提取(extract)，反复进行，然后一直传递下去。</p><p> 在拿到 SpanContext 之后，此时当前的 span 就可以关联到这条链路中了，那么剩余的事情就是收集当前组件的一些数据。</p><p>整个过程大概分为以下几个阶段：</p><ul><li>从请求中提取 spanContext</li><li>构建 span，并将当前 span 存入当前 tracer上下文中（SofaTraceContext.push(span)） 。</li><li>设置一些信息到span中</li><li>返回响应</li><li>span结束&amp;上报</li></ul><p>下面逐一分析下这几个过程。</p><h4 id="2-6-2-从请求中提取-spanContext"><a href="#2-6-2-从请求中提取-spanContext" class="headerlink" title="2.6.2 从请求中提取 spanContext"></a>2.6.2 从请求中提取 spanContext</h4><p>这里的提取用到了上面我们提到的#数据传播格式实现#SpringMvcHeadersCarrier 这个类。上面分析到，因为mvc 做作为 server 端存在的，所以在 server 端就是从请求中 extract 出 SpanContext。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SofaTracerSpanContext <span class="title">getSpanContextFromRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="comment">// 获取请求头信息 </span></span><br><span class="line">    Enumeration headerNames = request.getHeaderNames();</span><br><span class="line">    <span class="keyword">while</span> (headerNames.hasMoreElements()) &#123;</span><br><span class="line">        String key = (String) headerNames.nextElement();</span><br><span class="line">        String value = request.getHeader(key);</span><br><span class="line">        headers.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿到 SofaTracer 实例对象</span></span><br><span class="line">    SofaTracer tracer = springMvcTracer.getSofaTracer();</span><br><span class="line">    <span class="comment">// 解析出 SofaTracerSpanContext（SpanContext的实现类）</span></span><br><span class="line">    SofaTracerSpanContext spanContext = (SofaTracerSpanContext) tracer.extract(</span><br><span class="line">        ExtendFormat.Builtin.B3_HTTP_HEADERS, <span class="keyword">new</span> SpringMvcHeadersCarrier(headers));</span><br><span class="line">    spanContext.setSpanId(spanContext.nextChildContextId());</span><br><span class="line">    <span class="keyword">return</span> spanContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-3-获取-span-amp-数据获取"><a href="#2-6-3-获取-span-amp-数据获取" class="headerlink" title="2.6.3 获取 span &amp; 数据获取"></a>2.6.3 获取 span &amp; 数据获取</h4><p>serverReceive 这个方法是在 AbstractTracer 类中提供了实现，子类不需要关注这个。在 SOFATracer 中将请求大致分为以下几个过程：</p><ul><li>客户端发送请求  clientSend      cs</li><li>服务端接受请求  serverReceive sr</li><li>服务端返回结果  serverSend     ss</li><li>客户端接受结果  clientReceive  cr</li></ul><p>无论是哪个插件，在请求处理周期内都可以从上述几个阶段中找到对应的处理方法。因此，SOFATracer 对这几个阶段处理进行了封装。这四个阶段实际上会产生两个 span，第一个 span 的起点是 cs，到 cr 结束；第二个 span是从 sr 开始，到 ss 结束。也就是说当执行 clientSend 和 serverReceive 时会返回一个 span 对象。来看下MVC中的实现：</p><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543395049905-22e60dd7-1b88-4d94-9b2d-39c94ce909c7.png" alt="img"></p><p>红色框内对应的服务端接受请求，也就是 sr 阶段，产生了一个 span 。红色框下面的这段代码是为当前这个 span 设置一些基本的信息，包括当前应用的应用名、当前请求的url、当前请求的请求方法以及请求大小。</p><h4 id="2-6-4-返回响应与结束-span"><a href="#2-6-4-返回响应与结束-span" class="headerlink" title="2.6.4 返回响应与结束 span"></a>2.6.4 返回响应与结束 span</h4><p>在 filter 链执行结束之后，在 finally 块中又补充了当前请求响应结果的一些信息到 span 中去。然后调用serverSend 结束当前 span。这里关于 serverSend 里面的逻辑就不展开说了，不过能够想到的是这里肯定是调用span.finish 这个方法( opentracing 规范中，span.finish 的执行标志着一个 span 的结束)，当前也会包括对于数据上报的一些逻辑处理等。</p><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543395799817-68deb1fd-e481-4230-a338-3bbf8512a8f8.png" alt="img"></p><h2 id="3-思路总结与插件编写流程"><a href="#3-思路总结与插件编写流程" class="headerlink" title="3 思路总结与插件编写流程"></a>3 思路总结与插件编写流程</h2><p>在第2节中以 SpringMVC 插件为例，分析了下  SOFATracer 插件埋点实现的一些细节。那么本节则从整体思路上来总结下如何编写一个 SOFATracer 的插件。</p><ul><li>1、确定所要实现的插件，然后确定以哪种方式来埋点</li><li>2、实现当前插件的 Tracer 实例，这里需要明确当前插件是以 client 存在还是以 server 存在。</li><li>3、实现一个枚举类，用来描述当前组件的日志名称和滚动策略 key 值等</li><li>4、实现插件摘要日志的 encoder ，实现当前组件的定制化输出</li><li>5、实现插件的统计日志 Reporter 实现类，通过继承 AbstractSofaTracerStatisticReporter 类并重写doReportStat。</li><li><p>6、定义当前插件的传播格式</p><p>当然最重要的还是对于要实现插件的理解，要明确我们需要收集哪些数据。</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文先介绍了SOFATracer的埋点方式与标准OT-api 埋点方式的区别，然后对 SOFATracer 中 SpringMVC 插件的埋点实现进行了分析。希望通过本文能够让更多的同学理解埋点实现这样一个过程以及需要关注的一些点。如果有兴趣或者有什么实际的需求，欢迎来讨论。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;SOFATracer 是一个用于分布式系统调用跟踪的组件，通过统一的 &lt;code&gt;traceId&lt;/code&gt; 将调用链路中的各种网络调用情况以日志的方式记录下来，以达到透视化网络调用的目的。这些日志可用于故障的快速发现，服务治理等。&lt;/p&gt;
&lt;/
      
    
    </summary>
    
      <category term="SOFA" scheme="http://www.glmapper.com/categories/SOFA/"/>
    
    
      <category term="SOFATracer" scheme="http://www.glmapper.com/tags/SOFATracer/"/>
    
      <category term="Disruptor" scheme="http://www.glmapper.com/tags/Disruptor/"/>
    
      <category term="OpenTracing" scheme="http://www.glmapper.com/tags/OpenTracing/"/>
    
  </entry>
  
  <entry>
    <title>SpringSession：分布式Session实现方案</title>
    <link href="http://www.glmapper.com/2018/11/24/springsessionthree/"/>
    <id>http://www.glmapper.com/2018/11/24/springsessionthree/</id>
    <published>2018-11-24T08:55:33.000Z</published>
    <updated>2018-11-24T09:01:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章 <a href="https://juejin.im/post/5bdd449b6fb9a04a09557a40" target="_blank" rel="noopener">SpringSession：集成SpringBoot</a> 中介绍了如何在<code>SpringBoot</code>中来集成 <code>SpringSession</code>，整个过程非常简单，同时也简单分析了下<code>SpringSession</code>的作用原理。继上一篇实践之后，本文主要来分析 <code>SpringSession</code> 的原理。</p><h2 id="1、从-session-的一致性方案说起"><a href="#1、从-session-的一致性方案说起" class="headerlink" title="1、从 session 的一致性方案说起"></a>1、从 session 的一致性方案说起</h2><p>关于 <code>session</code> 和<code>cookie</code> 的一些知识，大家可以参考下我之前写的一篇文章：<a href="https://juejin.im/post/5aede266f265da0ba266e0ef" target="_blank" rel="noopener">聊一聊session和cookie</a>。</p><p><code>Session</code>作为服务器端使用的一种记录客户端状态的机制，其对客户端是透明的；但是<code>Session</code> 的正常运作仍然需要客户端浏览器的支持。我们都知道，<code>HTTP</code>协议是无状态的，<code>Session</code>不能依据<code>HTTP</code>连接来判断是否为同一客户，因此服务器需要向客户端浏览器发送一个识别标志（<code>sessionId</code>）,这个识别标志通过是通过<code>Cookie</code>机制来完成。</p><h3 id="1-1、session-一致性问题的由来"><a href="#1-1、session-一致性问题的由来" class="headerlink" title="1.1、session 一致性问题的由来"></a>1.1、session 一致性问题的由来</h3><p>当用户首次访问我们的<code>Servlet</code>时，应用服务器端会给用户创建一个独立的<code>Session</code>，并且存储在内存中。这种情况在单应用服务器场景下是可以满足的（这里不讨论其一个弊端，就是内存占用给服务器带来的压力的问题）。在集群场景下，这种机制就会到来问题：</p><h4 id="1-1-1、单机场景"><a href="#1-1-1、单机场景" class="headerlink" title="1.1.1、单机场景"></a>1.1.1、单机场景</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/4/166dee5cad0e35b8?w=968&amp;h=250&amp;f=png&amp;s=21829" alt=""></p><p>因为是一台应用服务器，用户的每次请求都是由这台机器来处理，所以不会有<code>session</code>共享问题。</p><h4 id="1-1-2、集群场景"><a href="#1-1-2、集群场景" class="headerlink" title="1.1.2、集群场景"></a>1.1.2、集群场景</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/4/166dee88ddb7d0ee?w=960&amp;h=608&amp;f=png&amp;s=42547" alt=""></p><p>假设现在集群中有三台机器，（从上到下：A-&gt;B-&gt;C）。当前用户首次发起访问时，请求被分配到 A 机器处理，<code>Session</code>数据被写入 A 机器的内存中；当再次发起访问 时，请求被分配的 B 处理，但此时 B 内存中并没有当前用户的任何数据，这样就出现了<code>session</code>不一致的情况了。</p><h3 id="1-2、Session-一致性问题的方案"><a href="#1-2、Session-一致性问题的方案" class="headerlink" title="1.2、Session 一致性问题的方案"></a>1.2、Session 一致性问题的方案</h3><p>对于当前服务化、单元化应用盛行的时代，简单的内存型的 <code>Session</code> 已经不能够满足我们的要求了。那么我们就需要寻求一种方案来替换目前单机内存存储实现的方案。</p><h4 id="1-2-1-基于-IP-HASH-的实现机制"><a href="#1-2-1-基于-IP-HASH-的实现机制" class="headerlink" title="1.2.1 基于 IP-HASH 的实现机制"></a>1.2.1 基于 IP-HASH 的实现机制</h4><p>在 1.1.2 中因为我们无法知道请求会被分配到哪台机器来处理，所以会导致<code>session</code>不一致的问题出现。如果我们可以解决让每个用户的请求能够固定的打到某一台机器上，那么上面提到的问题其实也就不存在了。<code>IP-HASH</code> 就是这样一种方案。通过对请求的客户端 <code>IP</code> 进行 <code>HASH</code> 计算，并将计算结果映射到具体一台机器，这样就可以将请求固定分配到某一台机器上，从而有效的避免<code>session</code>一致性问题的出现。</p><p>这种方案的好处在于:</p><ul><li>不需要修改任何应用代码，0 侵入。</li><li>安全性高，不依赖其他三方缓存框架带来的风险</li><li>成本低</li></ul><p>但是问题也很明显，这种方式实际上是规避了<code>session</code>一致性问题的出现，并非是针对<code>session</code>一致性问题给出的解决方案。主要问题：</p><ul><li>基于应用内存，会给应用服务器带来一定的压力</li><li>服务重启会导致<code>session</code>数据丢失</li><li>不利于水平扩展，水平扩展也可能丢失<code>session</code></li><li>存在单点负载高的情况，就是多数请求经过<code>HASH</code>计算之后打到同一台机器，而其他机器处于空闲状态。</li></ul><h4 id="1-2-2-session-复制"><a href="#1-2-2-session-复制" class="headerlink" title="1.2.2 session 复制"></a>1.2.2 session 复制</h4><p>这种方式的实现原理是应用服务器创建<code>session</code>之后通过组播的方式将<code>session</code>发送到组播地址内的其他应用服务器上。这种方式相较于<code>IP-HASH</code> 的方式要靠谱一点：</p><ul><li>同样不需要更改任何业务代码</li><li>能够适应多种负载策略</li><li>机器重启或者宕机之后不怕丢失，因为有冗余备份</li></ul><p>但是这种方式也有比较大的问题：</p><ul><li>首先就是服务器之间同步<code>session</code>会占用一定的网络资源，同时<code>session</code>在不同的机器之间进行同步存在延迟。</li><li>还是基于内存存储，局限于机器内存容量影响，水平扩展能力差</li><li>服务器内存因为需要存储其他机器上的<code>session</code>数据，对内存的消耗会随着集群的规模变大而变大，可能会导致机器频繁触发<code>GC</code>。</li></ul><h4 id="1-2-3-借助三方缓存框架实现-session-集中管理"><a href="#1-2-3-借助三方缓存框架实现-session-集中管理" class="headerlink" title="1.2.3 借助三方缓存框架实现 session 集中管理"></a>1.2.3 借助三方缓存框架实现 session 集中管理</h4><p>上面两种方式都是有服务器自己来管理<code>session</code>的，主要问题还是在于对于性能和内存的影响。而这种方式的原理是将<code>session</code>托管给三方软件（如<code>redis</code>）来统一管理。这种方式可以有效的解决性能、内存占用以及水平扩展等问题。但是因为引入了三方软件，在实现复杂度、运维成本等方面会有所增加。</p><p>目前所接触到的分布式<code>session</code>的实现方案，大多都是基于这种方式来实现的；<code>SpringSession</code> 也不例外。</p><h2 id="2、SpringSession-功能结构分析"><a href="#2、SpringSession-功能结构分析" class="headerlink" title="2、SpringSession 功能结构分析"></a>2、SpringSession 功能结构分析</h2><p>前面对分布式场景下的 <code>Session</code>一致性问题进行了说明，并对解决<code>Session</code>一致性的问题的几种策略进行的分析（有点糙，网上这些知识有很多）。在了解这些背景之后，我们来看下 <code>SpringSession</code> 的实现原理。</p><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p><code>Spring Session</code> 提供了用于管理用户会话信息的<code>API</code>和实现，在不依赖特定于应用程序容器的解决方案的情况下，使得支持群集会话变得更加简单。它还提供了透明的集成：</p><ul><li>允许以应用程序容器（<code>Tomcat</code>等）中立的方式替换 <code>HttpSesseion</code>，支持在 <code>headers</code>中提供 <code>session IDs</code>来使用 <code>RESTful API</code>。</li><li>提供在接收 <code>WebSocket</code> 消息时保持<code>HTTP</code> 会话存活的能力</li><li>允许以应用程序容器中立的方式替换 <code>Spring WebFlux</code> 的 <code>WebSession</code>。</li></ul><blockquote><p>以上来自官网文档翻译 <a href="https://github.com/spring-projects/spring-session" target="_blank" rel="noopener">Spring Session </a></p></blockquote><h3 id="2-2-模块"><a href="#2-2-模块" class="headerlink" title="2.2 模块"></a>2.2 模块</h3><p><code>Spring Session</code> 主要包括 4 个模块：</p><ul><li><code>spring-session-core</code> ：提供了 <code>Spring Session</code> 核心功能和<code>API</code></li><li><code>spring-session-data-redis</code>：以 <code>redis</code> 作为存储机制的 <code>SessionRepository</code> 实现</li><li><code>spring-session-hazelcast</code>：以 <code>Hazelcast</code> 作为存储机制的 <code>SessionRepository</code> 实现</li><li><code>spring-session-jdbc</code>：以关系型数据库作为存储机制的 <code>SessionRepository</code> 实现</li></ul><p>总体来说就是 核心<code>API</code>+存储实现；工程模块截图如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/4/166dec2555f6da9e?w=1070&amp;h=530&amp;f=png&amp;s=77929" alt=""></p><h3 id="2-3-功能结构"><a href="#2-3-功能结构" class="headerlink" title="2.3 功能结构"></a>2.3 功能结构</h3><p>SpringSession整体上可以分为三块：</p><ul><li>对于Web层的处理，这里包括对于请求的重写，自定义的filter加入到filter chain，cookie处理，http header处理等</li><li>公共基础封装，比如存储类的顶层抽象接口定义，自定配置，事件处理等。</li><li>存储部分，这部分实际上是对公共基础封装接口的实现，提供了丰富的存储实现，包括redis，内存存储，jdbc等。</li></ul><h3 id="2-4-多-session-支持"><a href="#2-4-多-session-支持" class="headerlink" title="2.4 多 session 支持"></a>2.4 多 session 支持</h3><p>对于常用的分布式session，在实现上一般会依赖于 cookie。但是在 springsession 中提供了基于header来传递jessionID的策略实现。同时在 2.0.4 版本之前，对于同一个浏览器同一个网站，springsession 支持多个<code>session</code>问题，但是在此版本之后抛弃了对于对 session 的支持。关于更多关于多session支持可以查看 SpringSession 的<a href="https://docs.spring.io/spring-session/docs/1.3.5.BUILD-SNAPSHOT/reference/html5/" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文对分布式 session 的几种实现策略进行了简单的介绍。对于分布式 session 而言，如何解决一致性问题是关键，目前我见过的绝大多数方案均是以 【借助三方缓存框架实现 session 集中管理】 这种来实现的，包括本系列文章中所要介绍的 SpringSession。</p><p>除分布式session一致性方式解决方案的介绍之外，作为SpringSession 的第二篇文章，在这里简单分析了下Springsession的功能模块，以便后续展开对源码的分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇文章 &lt;a href=&quot;https://juejin.im/post/5bdd449b6fb9a04a09557a40&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SpringSession：集成SpringBoot&lt;/a&gt; 中介绍了如何在&lt;cod
      
    
    </summary>
    
      <category term="spring" scheme="http://www.glmapper.com/categories/spring/"/>
    
      <category term="session" scheme="http://www.glmapper.com/categories/spring/session/"/>
    
    
      <category term="spring" scheme="http://www.glmapper.com/tags/spring/"/>
    
      <category term="session" scheme="http://www.glmapper.com/tags/session/"/>
    
  </entry>
  
  <entry>
    <title>SpringSession：请求与响应重写</title>
    <link href="http://www.glmapper.com/2018/11/24/springsessiontwo/"/>
    <id>http://www.glmapper.com/2018/11/24/springsessiontwo/</id>
    <published>2018-11-24T08:54:07.000Z</published>
    <updated>2018-11-24T08:55:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，<code>HttpServletRequset</code>和<code>HttpServletResponse</code>是<code>Servlet</code>标准所指定的<code>Java</code>语言与<code>Web</code>容器进行交互的接口。接口本身只规定<code>java</code>语言对<code>web</code>容器进行访问的行为方式，而具体的实现是由不同的<code>web</code>容器在其内部实现的。</p><p>那么在运行期，当我们需要对<code>HttpServletRequset</code>和<code>HttpServletResponse</code>的默认实例进行扩展时，我们就可以继承<code>HttpServletRequestWrapper</code>和<code>HttpServletResponseWrapper</code>来实现。<br>　　<br>在 <code>SpringSession</code>中因为我们要实现不依赖容器本身的<code>getSession</code> 实现，因此需要扩展 <code>HttpServletRequset</code>，通过重写<code>getSession</code>来实现分布式<code>session</code>的能力。下面就来看下<code>SpringSession</code>中对于<code>HttpServletRequset</code>的扩展。</p><h2 id="1、请求重写"><a href="#1、请求重写" class="headerlink" title="1、请求重写"></a>1、请求重写</h2><p><code>SpringSession</code> 中对于请求重写，在能力上主要体现在存储方面，也就是<code>getSession</code>方法上。在 <code>SessionRepositoryFilter</code> 这个类中，是通过内部类的方式实现了对<code>HttpServletRequset</code>和<code>HttpServletResponse</code>的扩展。</p><h3 id="1-1-HttpServletRequset-扩展实现"><a href="#1-1-HttpServletRequset-扩展实现" class="headerlink" title="1.1 HttpServletRequset 扩展实现"></a>1.1 HttpServletRequset 扩展实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionRepositoryRequestWrapper</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line"><span class="comment">// HttpServletResponse 实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HttpServletResponse response;</span><br><span class="line"><span class="comment">// ServletContext 实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServletContext servletContext;</span><br><span class="line">        <span class="comment">// requestedSession session对象</span></span><br><span class="line">        <span class="keyword">private</span> S requestedSession; </span><br><span class="line">        <span class="comment">// 是否缓存 session</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> requestedSessionCached;</span><br><span class="line"><span class="comment">// sessionId</span></span><br><span class="line"><span class="keyword">private</span> String requestedSessionId;</span><br><span class="line"><span class="comment">// sessionId 是否有效</span></span><br><span class="line"><span class="keyword">private</span> Boolean requestedSessionIdValid;</span><br><span class="line"><span class="comment">// sessionId 是否失效</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> requestedSessionInvalidated;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SessionRepositoryRequestWrapper</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response, ServletContext servletContext)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(request);</span><br><span class="line"><span class="keyword">this</span>.response = response;</span><br><span class="line"><span class="keyword">this</span>.servletContext = servletContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法里面将 <code>HttpServletRequest</code>、<code>HttpServletResponse</code> 以及 <code>ServletContext</code> 实例传递进来，以便于后续扩展使用。</p><h3 id="1-3-getSession-方法"><a href="#1-3-getSession-方法" class="headerlink" title="1.3 getSession 方法"></a>1.3 getSession 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpSessionWrapper <span class="title">getSession</span><span class="params">(<span class="keyword">boolean</span> create)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从当前请求线程中获取 session</span></span><br><span class="line">HttpSessionWrapper currentSession = getCurrentSession();</span><br><span class="line"><span class="comment">// 如果有直接返回</span></span><br><span class="line"><span class="keyword">if</span> (currentSession != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> currentSession;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从请求中获取 session，这里面会涉及到从缓存中拿session的过程</span></span><br><span class="line">S requestedSession = getRequestedSession();</span><br><span class="line"><span class="keyword">if</span> (requestedSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 无效的会话id(不支持的会话存储库)请求属性名称。</span></span><br><span class="line">    <span class="comment">// 这里看下当前的sessionId是否有效</span></span><br><span class="line"><span class="keyword">if</span> (getAttribute(INVALID_SESSION_ID_ATTR) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置当前session的最后访问时间，用于延迟session的有效期</span></span><br><span class="line">requestedSession.setLastAccessedTime(Instant.now());</span><br><span class="line"><span class="comment">// 将requestedSessionIdValid置为true</span></span><br><span class="line"><span class="keyword">this</span>.requestedSessionIdValid = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 包装session</span></span><br><span class="line">currentSession = <span class="keyword">new</span> HttpSessionWrapper(requestedSession, getServletContext());</span><br><span class="line"><span class="comment">// 不是新的session，如果是新的session则需要改变sessionId</span></span><br><span class="line">currentSession.setNew(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 将session设置到当前请求上下文</span></span><br><span class="line">setCurrentSession(currentSession);</span><br><span class="line"><span class="comment">// 返回session</span></span><br><span class="line"><span class="keyword">return</span> currentSession;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 这里处理的是无效的sessionId的情况，但是当前请求线程 session有效</span></span><br><span class="line"><span class="keyword">if</span> (SESSION_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">SESSION_LOGGER.debug(</span><br><span class="line"><span class="string">"No session found by id: Caching result for getSession(false) for this HttpServletRequest."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将invalidSessionId置为true</span></span><br><span class="line">setAttribute(INVALID_SESSION_ID_ATTR, <span class="string">"true"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 是否需要创建新的session</span></span><br><span class="line"><span class="keyword">if</span> (!create) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (SESSION_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">SESSION_LOGGER.debug(</span><br><span class="line"><span class="string">"A new session was created. To help you troubleshoot where the session was created we provided a StackTrace (this is not an error). You can prevent this from appearing by disabling DEBUG logging for "</span></span><br><span class="line">+ SESSION_LOGGER_NAME,</span><br><span class="line"><span class="keyword">new</span> RuntimeException(</span><br><span class="line"><span class="string">"For debugging purposes only (not an error)"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建新的session</span></span><br><span class="line">S session = SessionRepositoryFilter.<span class="keyword">this</span>.sessionRepository.createSession();</span><br><span class="line"><span class="comment">// 设置最后访问时间，也就是指定了当前session的有效期限</span></span><br><span class="line">session.setLastAccessedTime(Instant.now());</span><br><span class="line"><span class="comment">// 包装下当前session</span></span><br><span class="line">currentSession = <span class="keyword">new</span> HttpSessionWrapper(session, getServletContext());</span><br><span class="line"><span class="comment">//设置到当前请求线程</span></span><br><span class="line">setCurrentSession(currentSession);</span><br><span class="line"><span class="keyword">return</span> currentSession;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码有几个点，这里单独来解释下。</p><ul><li><code>getCurrentSession</code><ul><li>这是为了在同一个请求过程中不需要重复的去从存储中获取session，在一个新的进来时，将当前的 session 设置到当前请求中，在后续处理过程如果需要getSession就不需要再去存储介质中再拿一次。</li></ul></li><li><code>getRequestedSession</code><ul><li>这个是根据请求信息去取<code>session</code>，这里面就包括了<code>sessionId</code>解析，从存储获取<code>session</code>对象等过程。</li></ul></li><li>是否创建新的<code>session</code>对象   <ul><li>在当前请求中和存储中都没有获取到<code>session</code>信息的情况下，这里会根据<code>create</code>参数来判断是否创建新的<code>session</code>。这里一般用户首次登录时或者<code>session</code>失效时会走到。</li></ul></li></ul><h3 id="1-4-getRequestedSession"><a href="#1-4-getRequestedSession" class="headerlink" title="1.4 getRequestedSession"></a>1.4 getRequestedSession</h3><p>根据请求信息来获取<code>session</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> S <span class="title">getRequestedSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存的请求session是否存在</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.requestedSessionCached) &#123;</span><br><span class="line">            <span class="comment">// 获取 sessionId</span></span><br><span class="line">            List&lt;String&gt; sessionIds = SessionRepositoryFilter.<span class="keyword">this</span>.httpSessionIdResolver</span><br><span class="line">            .resolveSessionIds(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 通过sessionId来从存储中获取session</span></span><br><span class="line">            <span class="keyword">for</span> (String sessionId : sessionIds) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.requestedSessionId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.requestedSessionId = sessionId;</span><br><span class="line">            &#125;</span><br><span class="line">            S session = SessionRepositoryFilter.<span class="keyword">this</span>.sessionRepository</span><br><span class="line">            .findById(sessionId);</span><br><span class="line">            <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.requestedSession = session;</span><br><span class="line">            <span class="keyword">this</span>.requestedSessionId = sessionId;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.requestedSessionCached = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.requestedSession;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码还是很有意思的，这里获取<code>sessionId</code>返回的是个列表。当然这里是<code>SpringSession</code>的实现策略，因为支持<code>session</code>，所以这里以列表的形式返回的。OK，继续来看如何解析<code>sessionId</code>的：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744a467ce2ada6?w=1394&amp;h=200&amp;f=png&amp;s=80360" alt=""></p><p>这里可以看到<code>SpringSession</code>对于<code>sessionId</code>获取的两种策略，一种是基于<code>cookie</code>，一种是基于<code>header</code>；分别来看下具体实现。</p><h4 id="1-4-1-CookieHttpSessionIdResolver-获取-sessionId"><a href="#1-4-1-CookieHttpSessionIdResolver-获取-sessionId" class="headerlink" title="1.4.1 CookieHttpSessionIdResolver 获取 sessionId"></a>1.4.1 CookieHttpSessionIdResolver 获取 sessionId</h4><p><code>CookieHttpSessionIdResolver</code> 中获取<code>sessionId</code>的核心代码如下：<br><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744a7c7c05a32f?w=1360&amp;h=710&amp;f=png&amp;s=152689" alt=""><br>其实这里没啥好说的，就是读<code>cookie</code>。从<code>request</code>将<code>cookie</code>信息拿出来，然后遍历找当前<code>sessionId</code>对应的<code>cookie</code>,这里的判断也很简单， 如果是以<code>SESSION</code>开头，则表示是 <code>SessionId</code>，毕竟<code>cookie</code>是共享的，不只有<code>sessionId</code>，还有可能存储其他内容。</p><p>另外这里面有个 jvmRoute，这个东西实际上很少能够用到，因为大多数情况下这个值都是null。这个我们在分析<code>CookieSerializer</code>时再来解释。</p><h4 id="1-4-2-HeaderHttpSessionIdResolver-获取-sessionId"><a href="#1-4-2-HeaderHttpSessionIdResolver-获取-sessionId" class="headerlink" title="1.4.2 HeaderHttpSessionIdResolver 获取 sessionId"></a>1.4.2 HeaderHttpSessionIdResolver 获取 sessionId</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744b76477e1904?w=1144&amp;h=196&amp;f=png&amp;s=51550" alt=""><br>这个获取更直接粗暴，就是根据 <code>headerName</code> 从 <code>header</code> 中取值。</p><p>回到<code>getRequestedSession</code>，剩下的代码中核心的都是和<code>sessionRepository</code>这个有关系，这部分就会涉及到存储部分。不在本篇的分析范围之内，会在存储实现部分来分析。</p><h3 id="1-5-HttpSessionWrapper"><a href="#1-5-HttpSessionWrapper" class="headerlink" title="1.5 HttpSessionWrapper"></a>1.5 HttpSessionWrapper</h3><p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744bd83bd21c65?w=1436&amp;h=416&amp;f=png&amp;s=96267" alt=""></p><p>上面的代码中当我们拿到<code>session</code>实例是通常会包装下，那么用到的就是这个<code>HttpSessionWrapper</code>。</p><p><code>HttpSessionWrapper</code> 继承了 <code>HttpSessionAdapter</code>，这个<code>HttpSessionAdapter</code>就是将SpringSession 转换成一个标准<code>HttpSession</code>的适配类。<code>HttpSessionAdapter</code> 实现了标准<code>servlet</code>规范的<code>HttpSession</code>接口。</p><h4 id="1-5-1-HttpSessionWrapper"><a href="#1-5-1-HttpSessionWrapper" class="headerlink" title="1.5.1 HttpSessionWrapper"></a>1.5.1 HttpSessionWrapper</h4><p><code>HttpSessionWrapper</code> 重写了 <code>invalidate</code>方法。从代码来看，调用该方法产生的影响是：</p><ul><li><code>requestedSessionInvalidated</code> 置为<code>true</code>，标识当前 <code>session</code> 失效。</li><li>将当前请求中的<code>session</code>设置为<code>null</code>，那么在请求的后续调用中通过<code>getCurrentSession</code>将拿不到<code>session</code>信息。</li><li>当前缓存的 session 清楚，包括sessionId，session实例等。</li><li>删除存储介质中的session对象。</li></ul><h4 id="1-5-2-HttpSessionAdapter"><a href="#1-5-2-HttpSessionAdapter" class="headerlink" title="1.5.2 HttpSessionAdapter"></a>1.5.2 HttpSessionAdapter</h4><p><code>SpringSession</code>和标准<code>HttpSession</code>的配置器类。这个怎么理解呢，来看下一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getAttribute</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">checkState();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.session.getAttribute(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于基于容器本身实现的<code>HttpSession</code>来说，<code>getAttribute</code>的实现也是有容器本身决定。但是这里做了转换之后，<code>getAttribute</code>将会通过<code>SpringSession</code>中实现的方案来获取。其他的<code>API</code>适配也是基于此实现。</p><h3 id="SessionCommittingRequestDispatcher"><a href="#SessionCommittingRequestDispatcher" class="headerlink" title="SessionCommittingRequestDispatcher"></a>SessionCommittingRequestDispatcher</h3><p>实现了 <code>RequestDispatcher</code> 接口。关于<code>RequestDispatcher</code>可以参考这篇文章<a href="https://www.cnblogs.com/lulipro/p/7471987.html" target="_blank" rel="noopener">【Servlet】关于RequestDispatcher的原理</a>。<code>SessionCommittingRequestDispatcher</code>对<code>forward</code>的行为并没有改变。<br>对于<code>include</code>则是在<code>include</code>之前提交<code>session</code>。为什么这么做呢？</p><p> 因为<code>include</code>方法使原先的<code>Servlet</code>和转发到的<code>Servlet</code>都可以输出响应信息，即原先的<code>Servlet</code>还可以继续输出响应信息；即请求转发后，原先的<code>Servlet</code>还可以继续输出响应信息，转发到的<code>Servlet</code>对请求做出的响应将并入原先<code>Servlet</code>的响应对象中。 </p><p> 所以这个在<code>include</code>调用之前调用<code>commit</code>，这样可以确保被包含的<code>Servlet</code>程序不能改变响应消息的状态码和响应头。</p><h2 id="2-响应重写"><a href="#2-响应重写" class="headerlink" title="2 响应重写"></a>2 响应重写</h2><p>响应重写的目的是确保在请求提交时能够把session保存起来。来看下<code>SessionRepositoryResponseWrapper</code>类的实现：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744deabbf838ec?w=1140&amp;h=678&amp;f=png&amp;s=148489" alt=""><br>这里面实现还就是重写<code>onResponseCommitted</code>，也就是上面说的，在请求提交时能够通过这个回调函数将<code>session</code>保存到存储容器中。</p><h3 id="2-1-session-提交"><a href="#2-1-session-提交" class="headerlink" title="2.1 session 提交"></a>2.1 session 提交</h3><p>最后来看下 commitSession</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744e0fea8b3996?w=1374&amp;h=610&amp;f=png&amp;s=139692" alt=""></p><p>这个过程不会再去存储容器中拿<code>session</code>信息，而是直接从当前请求中拿。如果拿不到，则在回写<code>cookie</code>时会将当前<code>session</code>对应的<code>cookie</code>值设置为空，这样下次请求过来时携带的<code>sessionCookie</code>就是空，这样就会重新触发登陆。</p><p>如果拿到，则清空当前请求中的<code>session</code>信息，然后将<code>session</code>保存到存储容器中，并且将<code>sessionId</code>回写到<code>cookie</code>中。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇主要对<code>SpringSession</code>中重写<code>Request</code>和<code>Response</code>进行了分析。通过重写<code>Request</code>请求来将<code>session</code>的存储与存储容器关联起来，通过重写<code>Response</code>来处理<code>session</code>提交，将<code>session</code>保存到存储容器中。</p><p>后面我们会继续来分析<code>SpringSession</code>的源码。最近也在学习链路跟踪相关的技术，也准备写一写，有兴趣的同学可以一起讨论。</p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><ul><li><a href="https://github.com/alipay" target="_blank" rel="noopener">SOFA 开源社区</a></li><li><a href="https://github.com/alipay/sofa-tracer" target="_blank" rel="noopener">SOFATracer</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道，&lt;code&gt;HttpServletRequset&lt;/code&gt;和&lt;code&gt;HttpServletResponse&lt;/code&gt;是&lt;code&gt;Servlet&lt;/code&gt;标准所指定的&lt;code&gt;Java&lt;/code&gt;语言与&lt;code&gt;Web&lt;/code&gt;容器进行交
      
    
    </summary>
    
      <category term="spring" scheme="http://www.glmapper.com/categories/spring/"/>
    
      <category term="session" scheme="http://www.glmapper.com/categories/spring/session/"/>
    
    
      <category term="spring" scheme="http://www.glmapper.com/tags/spring/"/>
    
      <category term="session" scheme="http://www.glmapper.com/tags/session/"/>
    
  </entry>
  
  <entry>
    <title>SOFABoot 健康检查能力分析</title>
    <link href="http://www.glmapper.com/2018/11/16/sofaboot-health-one/"/>
    <id>http://www.glmapper.com/2018/11/16/sofaboot-health-one/</id>
    <published>2018-11-16T11:10:03.000Z</published>
    <updated>2018-11-16T11:12:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Liveness-Check-amp-Readiness-Check"><a href="#Liveness-Check-amp-Readiness-Check" class="headerlink" title="Liveness Check &amp;  Readiness Check"></a>Liveness Check &amp;  Readiness Check</h2><p><code>Spring Boot</code> 提供了一个基础的健康检查的能力，中间件和应用都可以扩展来实现自己的健康检查逻辑。但是 Spring Boot 的健康检查只有 <code>Liveness Check</code> 的能力，缺少 <code>Readiness Check</code> 的能力，这样会有比较致命的问题。当一个微服务应用启动的时候，必须要先保证启动后应用是健康的，才可以将上游的流量放进来（来自于 RPC，网关，定时任务等等流量），否则就可能会导致一定时间内大量的错误发生。</p><p>针对 <code>Spring Boot</code> 缺少 <code>Readiness Check</code> 能力的情况，<code>SOFABoot</code> 增加了 <code>Spring Boot</code> 现有的健康检查的能力，提供了 <code>Readiness Check</code> 的能力。利用 <code>Readiness Check</code> 的能力，<code>SOFA</code> 中间件中的各个组件只有在 <code>Readiness Check</code> 通过之后，才将流量引入到应用的实例中，比如 <code>RPC</code>，只有在 <code>Readiness Check</code> 通过之后，才会向服务注册中心注册，后面来自上游应用的流量才会进入。</p><p>除了中间件可以利用 <code>Readiness Check</code> 的事件来控制流量的进入之外，<code>PAAS</code> 系统也可以通过访问 <code>http://localhost:8080/actuator/readiness</code> 来获取应用的 <code>Readiness Check</code> 的状况，用来控制例如负载均衡设备等等流量的进入。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p><code>SOFABoot</code> 的健康检查能力需要引入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>healthcheck-sofa-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>区别于<code>SpringBoot</code>的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>详细工程科参考：<a href="https://github.com/alipay/" target="_blank" rel="noopener">sofa-boot</a></p></blockquote><h3 id="健康检查启动日志"><a href="#健康检查启动日志" class="headerlink" title="健康检查启动日志"></a>健康检查启动日志</h3><p><img src="https://user-gold-cdn.xitu.io/2018/11/16/1671b3e9d1e81110?w=1592&amp;h=322&amp;f=png&amp;s=360160" alt=""></p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>既然是个Starter，那么就先从 <strong>spring.factories</strong> 文件来看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">com.alipay.sofa.healthcheck.initializer.SofaBootHealthCheckInitializer</span><br><span class="line"></span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.alipay.sofa.healthcheck.configuration.SofaBootHealthCheckAutoConfiguration</span><br></pre></td></tr></table></figure><h4 id="SofaBootHealthCheckInitializer"><a href="#SofaBootHealthCheckInitializer" class="headerlink" title="SofaBootHealthCheckInitializer"></a>SofaBootHealthCheckInitializer</h4><p><code>SofaBootHealthCheckInitializer</code> 实现了 <code>ApplicationContextInitializer</code> 接口。</p><p><code>ApplicationContextInitializer</code> 是 <code>Spring</code> 框架原有的概念，这个类的主要目的就是在            <code>ConfigurableApplicationContext</code> 类型（或者子类型）的 <code>ApplicationContext</code> 做 <code>refresh</code> 之前，允许我们                   对 <code>ConfigurableApplicationContext</code> 的实例做进一步的设置或者处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaBootHealthCheckInitializer</span> <span class="keyword">implements</span> <span class="title">ApplicationContextInitializer</span>&lt;<span class="title">ConfigurableApplicationContext</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        Environment environment = applicationContext.getEnvironment();</span><br><span class="line">        <span class="keyword">if</span> (SOFABootEnvUtils.isSpringCloudBootstrapEnvironment(environment)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// init logging.level.com.alipay.sofa.runtime argument</span></span><br><span class="line">        String healthCheckLogLevelKey = Constants.LOG_LEVEL_PREFIX</span><br><span class="line">                                        + HealthCheckConstants.SOFABOOT_HEALTH_LOG_SPACE;</span><br><span class="line">        SofaBootLogSpaceIsolationInit.initSofaBootLogger(environment, healthCheckLogLevelKey);</span><br><span class="line">      SofaBootHealthCheckLoggerFactory.getLogger(SofaBootHealthCheckInitializer.class).info(</span><br><span class="line">            <span class="string">"SOFABoot HealthCheck Starting!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SofaBootHealthCheckInitializer</code> 在 <code>initialize</code> 方法中主要做了两件事：</p><ul><li>验证当前 <code>environment</code> 是否是 <code>SpringCloud</code> 的（3.0.0 开始支持 <code>springCloud</code>，之前版本无此 <code>check</code>）</li><li>初始化 <code>logging.level</code> </li></ul><p>这两件事和健康检查没有什么关系，但是既然放在这个模块里面还是来看下。</p><h4 id="1、springCloud-环境验证"><a href="#1、springCloud-环境验证" class="headerlink" title="1、springCloud 环境验证"></a>1、springCloud 环境验证</h4><p>首先就是为什么会有这个验证。<code>SOFABoot</code> 在支持 <code>SpringcLoud</code> 时遇到一个问题，就是当在 <code>classpath</code> 中添加<code>spring-cloud-context</code> 依赖关系时,<code>org.springframework.context.ApplicationContextInitializer</code>会被调用两次。具体背景可参考 <a href="https://github.com/spring-cloud/spring-cloud-config/issues/1151" target="_blank" rel="noopener"># issue1151</a>  &amp;&amp; <a href="https://github.com/alipay/sofa-boot/issues/232" target="_blank" rel="noopener"># issue 232</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SPRING_CLOUD_MARK_NAME = <span class="string">"org.springframework.cloud.bootstrap.BootstrapConfiguration"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSpringCloudBootstrapEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">        <span class="keyword">return</span> !((ConfigurableEnvironment) environment).getPropertySources().contains(</span><br><span class="line">            SofaBootInfraConstants.SOFA_BOOTSTRAP)</span><br><span class="line">               &amp;&amp; isSpringCloud();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSpringCloud</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ClassUtils.isPresent(SPRING_CLOUD_MARK_NAME, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码是 <code>SOFABoot</code> 提供的一个用于区分 引导上下文  和 应用上下文 的方法：</p><ul><li>检验是否有<code>&quot;org.springframework.cloud.bootstrap.BootstrapConfiguration&quot;</code>这个类来判断当前是否引入了<code>spingCloud</code>的引导配置类</li><li>从<code>environment</code> 中获取 <code>MutablePropertySources</code> 实例，验证 <code>MutablePropertySources</code> 中是否包括 <code>sofaBootstrap</code> （ 如果当前环境是 <code>SOFA bootstrap environment</code>，则包含 <code>sofaBootstrap</code>；这个是在 <code>SofaBootstrapRunListener</code> 回调方法中设置进行的 ）</li></ul><h4 id="2、初始化-logging-level"><a href="#2、初始化-logging-level" class="headerlink" title="2、初始化 logging.level"></a>2、初始化 logging.level</h4><p>这里是处理 <code>SOFABoot</code> 日志空间隔离的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initSofaBootLogger</span><span class="params">(Environment environment, String runtimeLogLevelKey)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 logging.path 参数</span></span><br><span class="line">    String loggingPath = environment.getProperty(Constants.LOG_PATH);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(loggingPath)) &#123;</span><br><span class="line">        System.setProperty(Constants.LOG_PATH, environment.getProperty(Constants.LOG_PATH));</span><br><span class="line">        ReportUtil.report(<span class="string">"Actual "</span> + Constants.LOG_PATH + <span class="string">" is [ "</span> + loggingPath + <span class="string">" ]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for example : init logging.level.com.alipay.sofa.runtime argument</span></span><br><span class="line">    String runtimeLogLevelValue = environment.getProperty(runtimeLogLevelKey);</span><br><span class="line">    <span class="keyword">if</span> (runtimeLogLevelValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.setProperty(runtimeLogLevelKey, runtimeLogLevelValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init file.encoding</span></span><br><span class="line">    String fileEncoding = environment.getProperty(Constants.LOG_ENCODING_PROP_KEY);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(fileEncoding)) &#123;</span><br><span class="line">        System.setProperty(Constants.LOG_ENCODING_PROP_KEY, fileEncoding);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SofaBootHealthCheckAutoConfiguration"><a href="#SofaBootHealthCheckAutoConfiguration" class="headerlink" title="SofaBootHealthCheckAutoConfiguration"></a>SofaBootHealthCheckAutoConfiguration</h3><p>这个类是 <code>SOFABoot</code> 健康检查机制的自动化配置实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaBootHealthCheckAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** ReadinessCheckListener: 容器刷新之后回调 */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReadinessCheckListener <span class="title">readinessCheckListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReadinessCheckListener();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** HealthCheckerProcessor: HealthChecker处理器 */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HealthCheckerProcessor <span class="title">healthCheckerProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HealthCheckerProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** HealthCheckerProcessor: HealthIndicator处理器 */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HealthIndicatorProcessor <span class="title">healthIndicatorProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HealthIndicatorProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** AfterReadinessCheckCallbackProcessor: ReadinessCheck之后的回调处理器 */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AfterReadinessCheckCallbackProcessor <span class="title">afterReadinessCheckCallbackProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AfterReadinessCheckCallbackProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 返回 SofaBoot健康检查指标类 实例*/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SofaBootHealthIndicator <span class="title">sofaBootHealthIndicator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SofaBootHealthIndicator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(Endpoint.class)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionReadinessEndpointConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnEnabledEndpoint</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SofaBootReadinessCheckEndpoint <span class="title">sofaBootReadinessCheckEndpoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SofaBootReadinessCheckEndpoint();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(Endpoint.class)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadinessCheckExtensionConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="meta">@ConditionalOnEnabledEndpoint</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ReadinessEndpointWebExtension <span class="title">readinessEndpointWebExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReadinessEndpointWebExtension();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReadinessCheckListener"><a href="#ReadinessCheckListener" class="headerlink" title="ReadinessCheckListener"></a>ReadinessCheckListener</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadinessCheckListener</span> <span class="keyword">implements</span> <span class="title">PriorityOrdered</span>,</span></span><br><span class="line"><span class="class">                                   <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从代码来看，<code>ReadinessCheckListener</code> 实现了 <code>ApplicationListener</code> 监听器接口，其所监听的事件对象是<code>ContextRefreshedEvent</code>，即当容器上下文刷新完成之后回调。 <code>SOFABoot</code> 中通过这个监听器来完成 <code>readniess check</code> 的处理。</p><p><code>onApplicationEvent</code> 回调方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// healthCheckerProcessor init</span></span><br><span class="line">    healthCheckerProcessor.init();</span><br><span class="line">    <span class="comment">// healthIndicatorProcessor init</span></span><br><span class="line">    healthIndicatorProcessor.init();</span><br><span class="line">    <span class="comment">// afterReadinessCheckCallbackProcessor init</span></span><br><span class="line">    afterReadinessCheckCallbackProcessor.init();</span><br><span class="line">    <span class="comment">// readiness health check execute</span></span><br><span class="line">    readinessHealthCheck();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化 <code>healthCheckerProcessor</code>，这个里面就是将当前所有的<code>HealthChecker</code>类型的<code>bean</code>找出来，然后放在一个<code>map</code>中，等待后面的 <code>readiness check</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否已经初始化了</span></span><br><span class="line">    <span class="keyword">if</span> (isInitiated.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// applicationContext 应用上下文不能为null</span></span><br><span class="line">        Assert.notNull(applicationContext, () -&gt; <span class="string">"Application must not be null"</span>);</span><br><span class="line">        <span class="comment">// 获取所有类型是 HealthChecker 的bean</span></span><br><span class="line">        Map&lt;String, HealthChecker&gt; beansOfType = applicationContext</span><br><span class="line">                .getBeansOfType(HealthChecker.class);</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        healthCheckers = HealthCheckUtils.sortMapAccordingToValue(beansOfType,</span><br><span class="line">                applicationContext.getAutowireCapableBeanFactory());</span><br><span class="line">        <span class="comment">// 构建日志信息，对应在健康检查日志里面打印出来的是：</span></span><br><span class="line">        <span class="comment">// ./logs/health-check/common-default.log:Found 0 HealthChecker implementation</span></span><br><span class="line">        StringBuilder healthCheckInfo = <span class="keyword">new</span> StringBuilder(<span class="number">512</span>).append(<span class="string">"Found "</span>)</span><br><span class="line">                .append(healthCheckers.size()).append(<span class="string">" HealthChecker implementation:"</span>)</span><br><span class="line">                .append(String.join(<span class="string">","</span>, healthCheckers.keySet()));</span><br><span class="line">        logger.info(healthCheckInfo.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化 <code>healthIndicatorProcessor</code>，将所有的<code>healthIndicator</code> 类型的<code>bean</code> 找出来，然后放在一个<code>map</code>中等待<code>readiness check</code>。如果想要在 <code>SOFABoot</code> 的 <code>Readiness Check</code> 里面增加一个检查项，那么可以直接扩展 <code>Spring Boot</code> 的<code>HealthIndicator</code>这个接口。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否已经初始化</span></span><br><span class="line">    <span class="keyword">if</span> (isInitiated.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// applicationContext 验证</span></span><br><span class="line">        Assert.notNull(applicationContext, () -&gt; <span class="string">"Application must not be null"</span>);</span><br><span class="line">        <span class="comment">// 获取所有HealthIndicator类型的bean</span></span><br><span class="line">        Map&lt;String, HealthIndicator&gt; beansOfType = applicationContext</span><br><span class="line">                .getBeansOfType(HealthIndicator.class);</span><br><span class="line">        <span class="comment">// 支持 Reactive 方式</span></span><br><span class="line">        <span class="keyword">if</span> (ClassUtils.isPresent(REACTOR_CLASS, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            applicationContext.getBeansOfType(ReactiveHealthIndicator.class).forEach(</span><br><span class="line">                    (name, indicator) -&gt; beansOfType.put(name, () -&gt; indicator.health().block()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        healthIndicators = HealthCheckUtils.sortMapAccordingToValue(beansOfType,</span><br><span class="line">                applicationContext.getAutowireCapableBeanFactory());</span><br><span class="line">        <span class="comment">// 构建日志信息</span></span><br><span class="line">        <span class="comment">// Found 2 HealthIndicator implementation:</span></span><br><span class="line">        <span class="comment">// sofaBootHealthIndicator, diskSpaceHealthIndicator</span></span><br><span class="line">        StringBuilder healthIndicatorInfo = <span class="keyword">new</span> StringBuilder(<span class="number">512</span>).append(<span class="string">"Found "</span>)</span><br><span class="line">                .append(healthIndicators.size()).append(<span class="string">" HealthIndicator implementation:"</span>)</span><br><span class="line">                .append(String.join(<span class="string">","</span>, healthIndicators.keySet()));</span><br><span class="line">        logger.info(healthIndicatorInfo.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化 <code>afterReadinessCheckCallbackProcessor</code>。如果想要在 <code>Readiness Check</code> 之后做一些事情，那么可以扩展 <code>SOFABoot</code> 的这个接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  是否已经初始化</span></span><br><span class="line">    <span class="keyword">if</span> (isInitiated.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// applicationContext 验证</span></span><br><span class="line">        Assert.notNull(applicationContext, () -&gt; <span class="string">"Application must not be null"</span>);</span><br><span class="line">        <span class="comment">// 找到所有 ReadinessCheckCallback 类型的 bean </span></span><br><span class="line">        Map&lt;String, ReadinessCheckCallback&gt; beansOfType = applicationContext</span><br><span class="line">                .getBeansOfType(ReadinessCheckCallback.class);</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        readinessCheckCallbacks = HealthCheckUtils.sortMapAccordingToValue(beansOfType,</span><br><span class="line">                applicationContext.getAutowireCapableBeanFactory());</span><br><span class="line">        <span class="comment">// 构建日志</span></span><br><span class="line">        StringBuilder applicationCallbackInfo = <span class="keyword">new</span> StringBuilder(<span class="number">512</span>).append(<span class="string">"Found "</span>)</span><br><span class="line">                .append(readinessCheckCallbacks.size())</span><br><span class="line">                .append(<span class="string">" ReadinessCheckCallback implementation: "</span>)</span><br><span class="line">                .append(String.join(<span class="string">","</span>, beansOfType.keySet()));</span><br><span class="line">        logger.info(applicationCallbackInfo.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>readinessHealthCheck</code>，前面的几个<code>init</code>方法中均是为<code>readinessHealthCheck</code>做准备的，到这里<code>SOFABoot</code>已经拿到了当前多有的<code>HealthChecker</code>、<code>HealthIndicator</code> 和 <code>ReadinessCheckCallback</code> 类型的 <code>bean</code> 信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readiness health check</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readinessHealthCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否跳过所有check,可以通过 com.alipay.sofa.healthcheck.skip.all 配置项配置决定</span></span><br><span class="line">    <span class="keyword">if</span> (skipAllCheck()) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Skip all readiness health check."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 是否跳过所有 HealthChecker 类型bean的 readinessHealthCheck,</span></span><br><span class="line">        <span class="comment">// 可以通过com.alipay.sofa.healthcheck.skip.component配置项配置</span></span><br><span class="line">        <span class="keyword">if</span> (skipComponent()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Skip HealthChecker health check."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//HealthChecker 的 readiness check</span></span><br><span class="line">            healthCheckerStatus = healthCheckerProcessor</span><br><span class="line">                .readinessHealthCheck(healthCheckerDetails);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否跳过所有HealthIndicator 类型bean的readinessHealthCheck</span></span><br><span class="line">        <span class="comment">// 可以通过 com.alipay.sofa.healthcheck.skip.indicator配置项配置</span></span><br><span class="line">        <span class="keyword">if</span> (skipIndicator()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Skip HealthIndicator health check."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//HealthIndicator 的 readiness check</span></span><br><span class="line">            healthIndicatorStatus = healthIndicatorProcessor</span><br><span class="line">                .readinessHealthCheck(healthIndicatorDetails);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ReadinessCheck 之后的回调函数，做一些后置处理</span></span><br><span class="line">    healthCallbackStatus = afterReadinessCheckCallbackProcessor</span><br><span class="line">        .afterReadinessCheckCallback(healthCallbackDetails);</span><br><span class="line">    <span class="keyword">if</span> (healthCheckerStatus &amp;&amp; healthIndicatorStatus &amp;&amp; healthCallbackStatus) &#123;</span><br><span class="line">        logger.info(<span class="string">"Readiness check result: success"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.error(<span class="string">"Readiness check result: fail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Readiness-Check-做了什么"><a href="#Readiness-Check-做了什么" class="headerlink" title="Readiness Check 做了什么"></a>Readiness Check 做了什么</h4><p>前面是 <code>SOFABoot</code> 健康检查组件处理健康检查逻辑的一个大体流程，了解到了 <code>Readiness</code> 包括检查 <code>HealthChecker</code> 类型的<code>bean</code>和<code>HealthIndicator</code> 类型的 <code>bean</code>。其中<code>HealthIndicator</code>是<code>SpringBoot</code>自己的接口 ，而 <code>HealthChecker</code> 是 <code>SOFABoot</code> 提供的接口。下面继续通过 <code>XXXProcess</code> 来看下 <code>Readiness Check</code> 到底做了什么？</p><h4 id="HealthCheckerProcessor"><a href="#HealthCheckerProcessor" class="headerlink" title="HealthCheckerProcessor"></a>HealthCheckerProcessor</h4><p><code>HealthChecker</code> 的健康检查处理器，<code>readinessHealthCheck</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readinessHealthCheck</span><span class="params">(Map&lt;String, Health&gt; healthMap)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(healthCheckers, <span class="string">"HealthCheckers must not be null."</span>);</span><br><span class="line">    logger.info(<span class="string">"Begin SOFABoot HealthChecker readiness check."</span>);</span><br><span class="line">    <span class="keyword">boolean</span> result = healthCheckers.entrySet().stream()</span><br><span class="line">            .map(entry -&gt; doHealthCheck(entry.getKey(), entry.getValue(), <span class="keyword">true</span>, healthMap, <span class="keyword">true</span>))</span><br><span class="line">            .reduce(<span class="keyword">true</span>, BinaryOperators.andBoolean());</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        logger.info(<span class="string">"SOFABoot HealthChecker readiness check result: success."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.error(<span class="string">"SOFABoot HealthChecker readiness check result: failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里每个<code>HealthChecker</code>又委托给<code>doHealthCheck</code>来检查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doHealthCheck</span><span class="params">(String beanId, HealthChecker healthChecker, <span class="keyword">boolean</span> isRetry,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Map&lt;String, Health&gt; healthMap, <span class="keyword">boolean</span> isReadiness)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(healthMap, <span class="string">"HealthMap must not be null"</span>);</span><br><span class="line">    Health health;</span><br><span class="line">    <span class="keyword">boolean</span> result;</span><br><span class="line">    <span class="keyword">int</span> retryCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// check 类型  readiness ？ liveness</span></span><br><span class="line">    String checkType = isReadiness ? <span class="string">"readiness"</span> : <span class="string">"liveness"</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 Health 对象</span></span><br><span class="line">        health = healthChecker.isHealthy();</span><br><span class="line">        <span class="comment">// 获取 健康检查状态结果</span></span><br><span class="line">        result = health.getStatus().equals(Status.UP);</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            logger.info(<span class="string">"HealthChecker[&#123;&#125;] &#123;&#125; check success with &#123;&#125; retry."</span>, beanId, checkType,retryCount);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.info(<span class="string">"HealthChecker[&#123;&#125;] &#123;&#125; check fail with &#123;&#125; retry."</span>, beanId, checkType,retryCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重试 &amp;&amp; 等待</span></span><br><span class="line">        <span class="keyword">if</span> (isRetry &amp;&amp; retryCount &lt; healthChecker.getRetryCount()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                retryCount += <span class="number">1</span>;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(healthChecker.getRetryTimeInterval());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                logger</span><br><span class="line">                    .error(</span><br><span class="line">                        String</span><br><span class="line">                            .format(</span><br><span class="line">                                <span class="string">"Exception occurred while sleeping of %d retry HealthChecker[%s] %s check."</span>,</span><br><span class="line">                                retryCount, beanId, checkType), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (isRetry &amp;&amp; retryCount &lt; healthChecker.getRetryCount());</span><br><span class="line">    <span class="comment">// 将当前 实例 bean 的健康检查结果存到结果集healthMap中</span></span><br><span class="line">    healthMap.put(beanId, health);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            logger</span><br><span class="line">                .error(</span><br><span class="line">                    <span class="string">"HealthChecker[&#123;&#125;] &#123;&#125; check fail with &#123;&#125; retry; fail details:&#123;&#125;; strict mode:&#123;&#125;"</span>,</span><br><span class="line">                    beanId, checkType, retryCount,</span><br><span class="line">                    objectMapper.writeValueAsString(health.getDetails()),</span><br><span class="line">                    healthChecker.isStrictCheck());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException ex) &#123;</span><br><span class="line">        logger.error(</span><br><span class="line">            String.format(<span class="string">"Error occurred while doing HealthChecker %s check."</span>, checkType), ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回健康检查结果</span></span><br><span class="line">    <span class="keyword">return</span> !healthChecker.isStrictCheck() || result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>doHealthCheck</code> 结果需要依赖具体 <code>HealthChecker</code> 实现类的处理。通过这样一种方式可以<code>SOFABoot</code>可以很友好的实现对所以 <code>HealthChecker</code> 的健康检查。<code>HealthIndicatorProcessor</code> 的 <code>readinessHealthCheck</code> 和<code>HealthChecker</code>的基本差不多；有兴趣的可以自行阅读源码 <a href="https://github.com/alipay/sofa-boot" target="_blank" rel="noopener">Alipay-SOFABoot</a>。</p><h4 id="AfterReadinessCheckCallbackProcessor"><a href="#AfterReadinessCheckCallbackProcessor" class="headerlink" title="AfterReadinessCheckCallbackProcessor"></a>AfterReadinessCheckCallbackProcessor</h4><p>这个接口是 <code>SOFABoot</code> 提供的一个扩展接口， 用于在 <code>Readiness Check</code> 之后做一些事情。其实现思路和前面的<code>XXXXProcessor</code> 是一样的，对之前初始化时得到的所有的<code>ReadinessCheckCallbacks</code>实例<code>bean</code>逐一进行回调处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">afterReadinessCheckCallback</span><span class="params">(Map&lt;String, Health&gt; healthMap)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"Begin ReadinessCheckCallback readiness check"</span>);</span><br><span class="line">    Assert.notNull(readinessCheckCallbacks, <span class="string">"ReadinessCheckCallbacks must not be null."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = readinessCheckCallbacks.entrySet().stream()</span><br><span class="line">            .map(entry -&gt; doHealthCheckCallback(entry.getKey(), entry.getValue(), healthMap))</span><br><span class="line">            .reduce(<span class="keyword">true</span>, BinaryOperators.andBoolean());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        logger.info(<span class="string">"ReadinessCheckCallback readiness check result: success."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.error(<span class="string">"ReadinessCheckCallback readiness check result: failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样也是委托给了<code>doHealthCheckCallback</code>来处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doHealthCheckCallback</span><span class="params">(String beanId,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      ReadinessCheckCallback readinessCheckCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Map&lt;String, Health&gt; healthMap)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(healthMap, () -&gt; <span class="string">"HealthMap must not be null"</span>);</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    Health health = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        health = readinessCheckCallback.onHealthy(applicationContext);</span><br><span class="line">        result = health.getStatus().equals(Status.UP);</span><br><span class="line">        <span class="comment">// print log 省略</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 存入 healthMap</span></span><br><span class="line">        healthMap.put(beanId, health);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展-Readiness-Check-能力"><a href="#扩展-Readiness-Check-能力" class="headerlink" title="扩展 Readiness Check 能力"></a>扩展 Readiness Check 能力</h4><p>按照上面的分析，我们可以自己来实现下这几个扩展。</p><h4 id="实现-HealthChecker-接口"><a href="#实现-HealthChecker-接口" class="headerlink" title="实现 HealthChecker 接口"></a>实现 HealthChecker 接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperHealthChecker</span> <span class="keyword">implements</span> <span class="title">HealthChecker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Health <span class="title">isHealthy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以检测数据库连接是否成功</span></span><br><span class="line">        <span class="comment">// 可以检测zookeeper是否启动成功</span></span><br><span class="line">        <span class="comment">// 可以检测redis客户端是否启动成功</span></span><br><span class="line">        <span class="comment">// everything you want ...</span></span><br><span class="line">        <span class="keyword">if</span>(OK)&#123;</span><br><span class="line">            <span class="keyword">return</span> Health.up().build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Health.down().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getComponentName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 组件名</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"GlmapperComponent"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRetryCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重试次数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getRetryTimeInterval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重试间隔</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStrictCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现-ReadinessCheckCallback-接口"><a href="#实现-ReadinessCheckCallback-接口" class="headerlink" title="实现 ReadinessCheckCallback 接口"></a>实现 ReadinessCheckCallback 接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperReadinessCheckCallback</span> <span class="keyword">implements</span> <span class="title">ReadinessCheckCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Health <span class="title">onHealthy</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        Object glmapperHealthChecker = applicationContext.getBean(<span class="string">"glmapperHealthChecker"</span>);</span><br><span class="line">        <span class="keyword">if</span> (glmapperHealthChecker <span class="keyword">instanceof</span> GlmapperHealthChecker)&#123;</span><br><span class="line">            <span class="keyword">return</span> Health.up().build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Health.down().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看下健康检查日志：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/16/1671b484144d1d65?w=1590&amp;h=386&amp;f=png&amp;s=475058" alt=""></p><p>可以看到我们自己定义的检查类型<code>ready</code>了。</p><p>从日志看到有一个 <code>sofaBootHealthIndicator</code>，实现了<code>HealthIndicator</code> 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaBootHealthIndicator</span> <span class="keyword">implements</span> <span class="title">HealthIndicator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String    CHECK_RESULT_PREFIX = <span class="string">"Middleware"</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HealthCheckerProcessor healthCheckerProcessor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Health <span class="title">health</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Health&gt; healths = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 调用了 healthCheckerProcessor 的 livenessHealthCheck</span></span><br><span class="line">        <span class="keyword">boolean</span> checkSuccessful = healthCheckerProcessor.livenessHealthCheck(healths);</span><br><span class="line">        <span class="keyword">if</span> (checkSuccessful) &#123;</span><br><span class="line">            <span class="keyword">return</span> Health.up().withDetail(CHECK_RESULT_PREFIX, healths).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Health.down().withDetail(CHECK_RESULT_PREFIX, healths).build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>livenessHealthCheck</code> 和 <code>readinessHealthCheck</code> 两个方法都是交给 <code>doHealthCheck</code> 来处理的，没有看出来有什么区别。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文基于 <code>SOFABoot 3.0.0</code> 版本，与之前版本有一些区别。详细变更见：<a href="http://www.sofastack.tech/sofa-boot/docs/upgrade_3_x" target="_blank" rel="noopener">SOFABoot upgrade_3_x</a>。本篇文章简单介绍了 <code>SOFABoot</code> 对 <code>SpringBoot</code> 健康检查能力扩展的具体实现细节。</p><p>最后再来补充下 <code>liveness</code> 和 <code>readiness</code>，从字面意思来理解，<code>liveness</code>就是是否是活的，<code>readiness</code> 就是意思是否可访问的。</p><ul><li><code>readiness</code>：应用即便已经正在运行了，它仍然需要一定时间才能 提供 服务，这段时间可能用来加载数据，可能用来构建缓存，可能用来注册服务，可能用来选举 <code>Leader</code>等等。总之 <code>Readiness</code> 检查通过前是不会有流量发给应用的。目前 <code>SOFARPC</code> 就是在 <code>readiness check</code> 之后才会将所有的服务注册到注册中心去。</li><li><code>liveness</code>：检测应用程序是否正在运行</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Liveness-Check-amp-Readiness-Check&quot;&gt;&lt;a href=&quot;#Liveness-Check-amp-Readiness-Check&quot; class=&quot;headerlink&quot; title=&quot;Liveness Check &amp;amp;  Re
      
    
    </summary>
    
      <category term="SOFA" scheme="http://www.glmapper.com/categories/SOFA/"/>
    
    
      <category term="SOFABoot" scheme="http://www.glmapper.com/tags/SOFABoot/"/>
    
  </entry>
  
  <entry>
    <title>20181111-书法练习</title>
    <link href="http://www.glmapper.com/2018/11/10/shufa-20181111/"/>
    <id>http://www.glmapper.com/2018/11/10/shufa-20181111/</id>
    <published>2018-11-10T12:39:22.000Z</published>
    <updated>2018-12-16T07:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>黄鹤楼送孟浩然之广陵 -李白<br>故人西辞黄鹤楼，烟花三月下扬州<br>孤帆远影碧空尽，唯见长江天际流</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/15/16715f8dc079617e?w=1080&amp;h=1440&amp;f=jpeg&amp;s=101229" alt=""></p><blockquote><p>将进酒 -李白<br>君不见，黄河之水天上来，奔流到海不复回。<br>君不见，高堂明镜悲白发，朝如青丝暮成雪。<br>人生得意须尽欢，莫使金樽空对月。<br>天生我材必有用，千金散尽还复来。<br>烹羊宰牛且为乐，会须一饮三百杯。<br>岑夫子，丹丘生，将进酒，杯莫停。<br>与君歌一曲，请君为我倾耳听。(倾耳听 一作：侧耳听)<br>钟鼓馔玉不足贵，但愿长醉不复醒。(不足贵 一作：何足贵；不复醒 一作：不愿醒/不用醒)<br>古来圣贤皆寂寞，惟有饮者留其名。(古来 一作：自古；惟 通：唯)<br>陈王昔时宴平乐，斗酒十千恣欢谑。<br>主人何为言少钱，径须沽取对君酌。<br>五花马，千金裘，呼儿将出换美酒，与尔同销万古愁。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/15/16715f905c481e3f?w=1440&amp;h=1080&amp;f=jpeg&amp;s=110473" alt=""></p><blockquote><p>青玉案·元夕 -辛弃疾<br>东风夜放花千树。更吹落、星如雨。<br>宝马雕车香满路。凤箫声动，玉壶光转，一夜鱼龙舞。<br>蛾儿雪柳黄金缕。笑语盈盈暗香去。<br>众里寻他千百度。<br>蓦然回首，那人却在，灯火阑珊处。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/15/16715f92aee8f1b7?w=1440&amp;h=1080&amp;f=jpeg&amp;s=131383" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;黄鹤楼送孟浩然之广陵 -李白&lt;br&gt;故人西辞黄鹤楼，烟花三月下扬州&lt;br&gt;孤帆远影碧空尽，唯见长江天际流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/11/15
      
    
    </summary>
    
      <category term="书法" scheme="http://www.glmapper.com/categories/%E4%B9%A6%E6%B3%95/"/>
    
    
      <category term="书法" scheme="http://www.glmapper.com/tags/%E4%B9%A6%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>菜鸟成长系列-策略模式</title>
    <link href="http://www.glmapper.com/2018/11/10/java-design-model-strategy/"/>
    <id>http://www.glmapper.com/2018/11/10/java-design-model-strategy/</id>
    <published>2018-11-10T06:24:27.000Z</published>
    <updated>2018-11-10T09:23:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上次在模板方法模式中有提及到，模板方法模式通常不会单独来试用，在一些实际的应用中会搭配其他的模式来使用，比如说今天要学习的策略模式。</p></blockquote><p>一直我都很喜欢策略这个词，有种莫名的高大上，对三国有了解的小伙伴肯定会知道，有的谋士是比较直接的，献计就是献计，有话当面说；但是也有的谋士就是比较喜欢搞一种神秘感，弄个小布袋子里面塞个小布条（简称：锦囊）；对于一件很棘手的事情，在交代下去的时候就会有这样的嘱咐：“此事关系重大，还望XXX（昵称）务必处理妥帖；这里有三个锦囊，如果XXXX，你就拆开第X个锦囊，然后XXXX”；有时候我就很不解，假如真在遇到事情的时候来看，那路上丢了怎么办？一摸口袋就懵逼了有木有？</p><p>扯远了，不过意思就是这个意思，一个锦囊其实就是一种策略；然后它有一个总的背景（我们称之为上下文环境），这个大背景下，每个不同的场景都会有一中策略来对应处理；</p><p>我们先以上面的列子为背景来撸一个小的例子，然后再去看一个spring中比较典型的策略模式使用，最后再来探讨下策略模式的类图，并以此来说明策略模式中的一些基本角色及其职责。</p><h3 id="锦囊妙计"><a href="#锦囊妙计" class="headerlink" title="锦囊妙计"></a>锦囊妙计</h3><blockquote><p>兵马未动，粮草先行；但是这个运输粮草到底是走水路还是走陆地呢？那这得看往哪运…</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.policy;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 大背景，运输粮草</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/5/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransportFood</span> </span>&#123;</span><br><span class="line">    <span class="comment">//持有一个运输策略的对象</span></span><br><span class="line">    <span class="keyword">private</span> TransportFoodStrategy strategy;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，传入一个具体策略对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strategy    具体策略对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TransportFood</span><span class="params">(TransportFoodStrategy strategy)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 策略方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trasportFood</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        strategy.trasport();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是我们的总体背景，就是运输粮草；但是这个只是说要运输粮草，但是并没有说是怎么运？这就得TransportFoodStrategy这个运输策略有具体的运输方案。</p><ul><li>运输方案1：如果粮草是从武汉到南京，OK，那就走水运吧。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 运输粮草的策略之水运运输</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/5/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaterTransportStrategy</span> <span class="keyword">implements</span> <span class="title">TransportFoodStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trasport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用船，走水运"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运输方案2：如果从内蒙到北京；那就走陆运吧。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 运输粮草的策略之陆地运输</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/5/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LandTransportStrategy</span> <span class="keyword">implements</span> <span class="title">TransportFoodStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trasport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用马车，走陆运"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，来看下妙计使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 决策制定-客户端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/5/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        TransportFoodStrategy strategy =</span><br><span class="line">        getTransportFoodStrategy(<span class="string">"内蒙到北京"</span>);</span><br><span class="line"></span><br><span class="line">        TransportFood transportFood = <span class="keyword">new</span> TransportFood(strategy);</span><br><span class="line">        transportFood.trasportFood();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取运输方案</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lineType 运输路线</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TransportFoodStrategy <span class="title">getTransportFoodStrategy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String lineType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lineType.equals(<span class="string">"内蒙到北京"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LandTransportStrategy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lineType.equals(<span class="string">"武汉到南京"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WaterTransportStrategy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-&gt; 用马车，走陆运</span><br></pre></td></tr></table></figure><p>粮草运完了，真正的表演开始了…</p><h3 id="Spring中典型的策略模式使用"><a href="#Spring中典型的策略模式使用" class="headerlink" title="Spring中典型的策略模式使用"></a>Spring中典型的策略模式使用</h3><p>我们知道spring加载资源文件是通过ResourceLoader来搞定的。在ResourceLoader中提供了一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>;</span><br></pre></td></tr></table></figure><p>这个方法的注解中说道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//允许多个资源调用。</span><br><span class="line">allowing for multiple &#123;@link Resource#getInputStream()&#125; calls.</span><br></pre></td></tr></table></figure><p>这里就很赤裸裸了，他告诉了你要获取资源，但是如果获取资源呢？这就得看有哪些具体的获取策略了。</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/5/1633103f6010a684?w=1724&amp;h=642&amp;f=png&amp;s=329841" alt=""></p><p>上图就是Resource的具体子类实现，也就是一些具体的策略。我们比较常见的应该算是UrlResource（加载URL指定的资源）和ClasspathResource（加载类路径中的资源）这两个。再来看下这个getResource这个方法的实现：</p><blockquote><p>getResource方法是在DefaultResourceLoader中具体实现的；DefaultResourceLoader是ResourceLoader的默认实现。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">Assert.notNull(location, <span class="string">"Location must not be null"</span>);</span><br><span class="line"><span class="comment">//首先使用ProtocolResolver来通过location参数创建Resource对象</span></span><br><span class="line"><span class="comment">// spring4.3.x开始才有的</span></span><br><span class="line"><span class="keyword">for</span> (ProtocolResolver protocolResolver : <span class="keyword">this</span>.protocolResolvers) &#123;</span><br><span class="line">            Resource resource = protocolResolver.resolve(location,<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> resource;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//指定路径的</span></span><br><span class="line"><span class="keyword">if</span> (location.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以classpath开头的</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(</span><br><span class="line">CLASSPATH_URL_PREFIX.length()), getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里是先尝试解析是否是带有网络协议的资源，</span></span><br><span class="line"><span class="comment">//如果解析异常，则是在异常处理中使用了一种默认的机制。</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Try to parse the location as a URL...</span></span><br><span class="line">URL url = <span class="keyword">new</span> URL(location);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line"><span class="comment">// No URL -&gt; resolve as resource path.</span></span><br><span class="line"><span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/io/ProtocolResolver.html" target="_blank" rel="noopener">ProtocolResolver</a></p><p>其实我们可以发现，这里的location其实和我们上面那个例子中的lineType的作用是一样的，根据这个来确定具体使用哪个策略方法。</p><ul><li>策略1：使用ProtocolResolver来通过location参数创建Resource对象，在<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/io/ProtocolResolver.html" target="_blank" rel="noopener">ProtocolResolver</a>中关于ProtocolResolver的解释是：A resolution strategy for protocol-specific resource handles-协议专用资源句柄的解析策略。</li><li>策略2：返回给定路径上资源的资源句柄。</li><li>策略3：以classpath:为前缀的，这种location参数直接返回一个ClassPathResource对象，表示加载classes路径下的资源；</li><li>策略4：使用网络协议作为前缀的，比如http、ftp等，这种直接返回一个UrlResource对象；</li><li>策略5：无前缀的，在默认实现中和第三种一样是加载classes路径下的资源，不同的是此处当作是ClassPathContextResource来处理的。</li></ul><p>Spring中Resource的策(tao)略(lu)说完了，再回过头来看下策略模式的一些具体理论知识。</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><blockquote><p>定义：策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。</p></blockquote><p>结合前面的例子分析和这段定义，可以知道，其实策略模式真的意图不是如何实现策略算法，它更在意的是如何组织这些算法。</p><p>这也是策略模式的使用可以让程序结构更灵活，具有更好的维护性和扩展性的重要因素。</p><p><strong>类图：</strong><br><img src="https://user-gold-cdn.xitu.io/2018/5/6/1633122266b7c893?w=1232&amp;h=570&amp;f=png&amp;s=36574" alt="类图"><br><code>这个类图画的确实是有点丑，但是为了亲手绘制一下，所以还请多多见谅！</code></p><p><strong>类图中的一些角色：</strong></p><ul><li>context：策略背景，也就是需要使用策略的主体；它持有一个strategy类的引用</li><li>strategy：抽象策略，这个角色给出了所有具体策略类所需的接口。所以通常是一个抽象类或者接口。</li><li>strategyPolicy：具体策略，它的作用就是包装具体的算法或者行为</li></ul><p>那么在实际的应用中，策略模式到底给我们带来的好处是什么，它能够帮助我们解决什么样的问题呢？这个需要从模式本身的优缺点来看：</p><p><strong>优点</strong></p><ul><li><p>策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。</p></li><li><p>策略模式可以避免使用多重条件(if-else)语句。通常对于一个背景主体，一般只会有一种策略算法可供使用，使用多重条件句的话不易维护；因为它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起了。</p></li></ul><p><strong>缺点</strong></p><ul><li><p>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。</p></li><li><p>由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。–如果策略很多，通常会采用一些混合策略来避免策略类的不断膨胀。</p></li></ul><p>在了解其优缺点的情况下，我们就可以合理的将其放在一些适当的场景中来；如以下场景：</p><ul><li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 </li><li>一个系统需要动态地在几种算法中选择一种。   </li><li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li></ul><p><strong>参考</strong></p><ul><li>《JAVA与模式》</li><li><a href="http://www.cnblogs.com/java-my-life/archive/2012/05/10/2491891.html" target="_blank" rel="noopener">《JAVA与模式》之策略模式</a></li><li><a href="http://www.runoob.com/design-pattern/strategy-pattern.html" target="_blank" rel="noopener">策略模式</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;上次在模板方法模式中有提及到，模板方法模式通常不会单独来试用，在一些实际的应用中会搭配其他的模式来使用，比如说今天要学习的策略模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一直我都很喜欢策略这个词，有种莫名的高大上，对三国有了解的小伙伴肯定会知
      
    
    </summary>
    
      <category term="架构之路" scheme="http://www.glmapper.com/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="设计模式" scheme="http://www.glmapper.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>菜鸟成长系列-模板方法模式</title>
    <link href="http://www.glmapper.com/2018/11/10/java-design-model-modulemethod/"/>
    <id>http://www.glmapper.com/2018/11/10/java-design-model-modulemethod/</id>
    <published>2018-11-10T06:23:37.000Z</published>
    <updated>2018-11-10T09:22:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>模板方法模式在sring中有大量的应用，一般我们会使用模板方法来将当前的实现委托给子类来实现，增强代码的可扩展性和复用性。因为涉及到父子类关系，所以模板方法模式是基于“继承”来实现的；模板方法模式属于行为型模式。</p></blockquote><p><code>简单地说就是，通过父类来定义一系列的算法骨架，并且约定这些方法及其调用顺序，而具体的某些特定方法由子类实现。</code></p><p>先来看一个小demo；我们以写博客来举例子，一般我们写博客的步骤如下：</p><ul><li>打开目标网站</li><li>打开编辑器</li><li>写文章</li><li>发布文章</li></ul><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><p>首先是定义一个父类，并且提供一个模板方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.mudolmethod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 抽象模板父类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTemplateMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流程方法1：抽象方法，供子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">openTargetWebSite</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流程方法2：子类可选择重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openMarkDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开编辑器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流程方法3：抽象方法，供子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeBlog</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流程方法4：子类可选择重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publisher</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发布文章"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法，此处申明为final，是不希望子类覆盖这个方法，防止更改流程的执行顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">templateWriteBlog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        openTargetWebSite();</span><br><span class="line">        openMarkDown();</span><br><span class="line">        writeBlog();</span><br><span class="line">        publisher();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中我们提供了一个templateWriteBlog方法，这里方法中包括了写博客的一些流程。在这些流程方法中有些方法父类提供了默认实现，而一些具有差异性的方法则让子类来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.mudolmethod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 子类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JueJinTemplateMethodPolicy</span> <span class="keyword">extends</span> <span class="title">AbstractTemplateMethod</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openTargetWebSite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开掘金网站"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBlog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"写一篇Spring相关的文章"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类1：JueJinTemplateMethodPolicy，这个子类中实现了父类中的部分方法，包括：openTargetWebSite和writeBlog。（一般情况下不会去重写父类默认已经实现的方法，仅实现父类中预留的抽象方法来实现）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.mudolmethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 子类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CSDNTemplateMethodPolicy</span> <span class="keyword">extends</span> <span class="title">AbstractTemplateMethod</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openTargetWebSite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开CSDN网站"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBlog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"写一篇设计模式文章"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类2：CSDNTemplateMethodPolicy,这个子类的作用其实和子类1是一样的，只不过是提供了另外的一种实现策略；（很多情况下，模板方法模式都是和策略模式来联合使用的，通过一套模板机制，对于模板中的部分流程通过不同的策略来实现不同的功能）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.mudolmethod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 子类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractTemplateMethod csdnTemplate = <span class="keyword">new</span> CSDNTemplateMethodPolicy();</span><br><span class="line">        csdnTemplate.templateWriteBlog();</span><br><span class="line"></span><br><span class="line">        AbstractTemplateMethod juejinTemplate = <span class="keyword">new</span> JueJinTemplateMethodPolicy();</span><br><span class="line">        juejinTemplate.templateWriteBlog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打开CSDN网站</span><br><span class="line">打开编辑器</span><br><span class="line">写一篇设计模式文章</span><br><span class="line">发布文章</span><br><span class="line"></span><br><span class="line">打开掘金网站</span><br><span class="line">打开编辑器</span><br><span class="line">写一篇Spring相关的文章</span><br><span class="line">发布文章</span><br></pre></td></tr></table></figure><p>上面是客户端代码及输出结果。通过输出我们可以明显的看出，模板中的一些方法将延迟到子类中去实现，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。因此对于模板方法这个模式来说，父类是始终控制着整个流程主动权的，而子类只是辅助父类实现某些可定制的步骤。 </p><h2 id="模式解析"><a href="#模式解析" class="headerlink" title="模式解析"></a>模式解析</h2><p>先看下模板方法模式的类图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/30/163148bb2155fca2?w=459&amp;h=315&amp;f=png&amp;s=85263" alt=""></p><p>从类图中可以看出，模板方法模式中的角色也是很简单的，主要包括两个角色：</p><ul><li><p>抽象模板（AbstractTemplate）：</p><ul><li>定义一个或者多个抽象操作，以便于让子类实现。这些抽象操作就是流程中的基本操作（对应的是模板方法中的某个具体的操作方法）；这些基本操作是一个顶级逻辑的组成步骤</li><li>定义并且实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类中取实现，当然，在这个顶级逻辑中，部分方法也可以由父类来提供默认实现的。</li></ul></li><li><p>具体类（SubTemplateImpl)：</p><ul><li>实现父类所定义的一个或者多个抽象方法</li><li>每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法的不同实现。</li></ul></li></ul><p>模板方法中的这个方法的概念拆开来说包括两种，一种是模板方法，还有一种是模板方法里面的基本方法。模板方法定义游戏规则，基本方法实现规则中的每个部分。</p><p>模板方法带来的优势是显而易见的，它可以帮助我们有效的帮助我们搞定下面的这些场景问题：</p><ul><li>封装不变部分，扩展可变部分。 </li><li>提取公共代码，便于维护。 </li><li>行为由父类控制，子类实现。</li></ul><p>但是缺点也很明显，因为对于每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p><h3 id="典型的模板方法模式的应用"><a href="#典型的模板方法模式的应用" class="headerlink" title="典型的模板方法模式的应用"></a>典型的模板方法模式的应用</h3><p>最先想到的就是servlet，servlet的生命周期(以前经常遇到的面试点，现在已经没人问了吧)</p><ul><li>初始化 init</li><li>处理   service</li><li>销毁   destroy</li></ul><blockquote><p>其实这里我觉得也是模板方法的一种体现，虽然在servlet中没有定义顶层的模板方法来控制这个流程(我的想法是这个流程是由容器来控制的，也可能是一种默认的约定)。</p></blockquote><p>在其子类GenericServlet中对init和destroy有了默认的实现，而service方法则是交由子类来实现的，也就是说任何servlet类均必须实现service方法。</p><p>这里的service方法就是一个模板方法。service方法中调用了7个do方法中的一个或者几个，完成对客户端的响应，这些do方法需要由HttpServlet的具体子类提供。</p><p>HttpServlet中的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse</span></span></span><br><span class="line"><span class="function"><span class="params">resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String method = req.getMethod();</span><br><span class="line">        <span class="keyword">long</span> lastModified;</span><br><span class="line">        <span class="keyword">if</span> (method.equals(<span class="string">"GET"</span>)) &#123;</span><br><span class="line">            lastModified = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">            <span class="keyword">if</span> (lastModified == -<span class="number">1L</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> ifModifiedSince =</span><br><span class="line">                req.getDateHeader(<span class="string">"If-Modified-Since"</span>);</span><br><span class="line">                <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">                    <span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp.setStatus(<span class="number">304</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"HEAD"</span>)) &#123;</span><br><span class="line">            lastModified = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">            <span class="keyword">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">            <span class="keyword">this</span>.doHead(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"POST"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"PUT"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doPut(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"DELETE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doDelete(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"OPTIONS"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doOptions(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"TRACE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doTrace(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String errMsg =</span><br><span class="line">            lStrings.getString(<span class="string">"http.method_not_implemented"</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> Object[]&#123;method&#125;;</span><br><span class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">            resp.sendError(<span class="number">501</span>, errMsg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>FrameworkServlet中的实现(FrameworkServlet是SpringMVC核心控制器DispatchServlet的父类)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Override the parent class implementation in order to intercept</span></span><br><span class="line"><span class="comment"> PATCH requests.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class="line"><span class="keyword">if</span> (HttpMethod.PATCH == httpMethod || httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">super</span>.service(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于模板方法模式的学习就到这里了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;模板方法模式在sring中有大量的应用，一般我们会使用模板方法来将当前的实现委托给子类来实现，增强代码的可扩展性和复用性。因为涉及到父子类关系，所以模板方法模式是基于“继承”来实现的；模板方法模式属于行为型模式。&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
      <category term="架构之路" scheme="http://www.glmapper.com/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="设计模式" scheme="http://www.glmapper.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>菜鸟成长系列-观察者模式</title>
    <link href="http://www.glmapper.com/2018/11/10/java-design-model-obs/"/>
    <id>http://www.glmapper.com/2018/11/10/java-design-model-obs/</id>
    <published>2018-11-10T06:22:46.000Z</published>
    <updated>2018-11-10T09:23:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>最近想深入研究下响应式编程，作为基础很有必要来把观察者模式撸一遍；一开始我是觉得很easy,然后就直接开撸了，撸着撸着发现撸不动了。因为我突然不太明白这个模式了，说好的观察者，到底发布-订阅的两者执行者谁才是观察者？又或者说还有其他角色？但是根据《JAVA与模式》一书中的结构，并没有额外的角色出现。</code></p><p>思考中….，好吧想不出来….，跑步去…</p><p>跑步时我给自己罗列了几个问题：</p><blockquote><p>这里先抛出定义：GOF给观察者模式如下定义：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p></blockquote><ul><li>既然是对象状态发生变更，那么到底是谁的状态发生了变更，又导致了谁被通知。</li><li>观察者模式既然又可以称之为“发布-订阅模式”，那么对应起来，观察者到底承当了“发布”的角色还是“订阅”的角色。就是说观察者到底是主动的还是被动的？</li><li>被观察者又干了什么事？它是主动的还是被动的角色？</li></ul><p>这里由于一些定式思维，总会觉得既然是“被观察者”，那么这个“被”字就是不是就表明“被观察者”是被动接受变更的一方，也就是接受通知的一方呢？</p><p>之前我也是走到这个胡同里了，程序写完总觉得哪里不对；回过头看，还是自己太年轻，没有get到哪些大佬们的点。</p><p>先来看程序；这里用掘金来打个比方，我的博客glmmaper作为被观察者，也就是发布者。掘金小伙伴们作为观察者，也就是订阅者。</p><p>具体逻辑：小伙伴们（订阅者）关注（订阅）了我的博客（发布者），如果我发布了一篇文章（状态变更），就会通知（推送消息）所有关注我的小伙伴。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.observor;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 抽象主题接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增关注者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer 关注的小伙伴</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFocusObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消关注</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer 取消关注的小伙伴</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeFocusObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知机制，通知机制由相关事件来触发，比如说发布文章</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> blogName          博客名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> articleName       文章名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(String blogName,String articleName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个方法，一个是博客主页增加了一个关注者；一个是博客主页有小伙伴取消的关注（对于博客来说就是移除一个关注者，这里不知道是否也会觉得别扭？明明你取消的关注，为啥说成是我移除你，也就是不让你关注了，还能这么玩?这里肯定是需要在引入其他的一些辅助机制，比如说你在客户端发起了一个取消关注的请求，后端处理的时候掘金的工程师们就是在我的关注列表中将你移除的，嗯，这么一想确实是我不让你关注了。😄….）；最后一个方法是发起一个通知。下面是一个具体的博客，比如说是glmapper；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.observor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 这个是具体发布者，这里比喻成我的博客glmapper</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span>  <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 我的当前关注列表 */</span></span><br><span class="line">    List&lt;Observer&gt; Observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">/** 我的博客名 ：求关注 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String blogName = <span class="string">"glmapper"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFocusObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        Observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeFocusObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        Observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(String blogName,String articleName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer:Observers) &#123;</span><br><span class="line">            observer.update(blogName,articleName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里是发布文章，触发通知事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishArticle</span><span class="params">(String articleName)</span></span>&#123;</span><br><span class="line">        notifyObservers(blogName,articleName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面提到，通知事件肯定是由于某些状态发生变更了，才会进行通知，这里就可以比方为我发布了一篇博客，然后通知你（这里只能假如你关注了）。再来看观察者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.observor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 订阅者抽象接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用此方法会更新状态，做出相应的动作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> blogName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> articleName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String blogName,String articleName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象订阅者，有一个update方法，通知你去做出相应的动作，具体动作每个观察者都可能不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.observor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 这个是具体订阅者,这里可以比喻成博客关注者，</span></span><br><span class="line"><span class="comment"> * 收到变更信息之后需要做出相应的动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String blogName,String articleName)</span> </span>&#123;</span><br><span class="line">        System.out.println(blogName+<span class="string">"发布了新的文章，文章名为："</span>+articleName);</span><br><span class="line">        read(articleName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String articleName)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"即将阅读 "</span>+articleName+<span class="string">" 这篇文章"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个具体的关注者，加入说就是你。博客更新之后发了一个通知给你(掘金app推送的消息)，然后你点了一下，这个也是一种动作。例子中举的是read,就是关注者做出阅读的动作。</p><p>看下最后的运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.observor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: [描述文本]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMainIndex</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//博客主体</span></span><br><span class="line">        ConcreteSubject subject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        <span class="comment">//关注者：handSome是帅气的意思</span></span><br><span class="line">        Observer handSome = <span class="keyword">new</span> ConcreteObserver();</span><br><span class="line">        <span class="comment">//增加一个关注者</span></span><br><span class="line">        subject.addFocusObserver(handSome);</span><br><span class="line">        <span class="comment">//发一篇文章</span></span><br><span class="line">        subject.publishArticle(<span class="string">"设计模式-观察者模式"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">glmapper发布了新的文章，文章名为：设计模式-观察者模式</span><br><span class="line">即将阅读 设计模式-观察者模式 这篇文章</span><br></pre></td></tr></table></figure><p><strong>酒桶说：啊，欢乐时光总是短暂的</strong></p><p>所以作为积累，还是需要将一些基本的概念来罗列一下的。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/22/162eddecf0e6a860?w=607&amp;h=253&amp;f=jpeg&amp;s=27115" alt="观察者模式类图"></p><p><strong>主要角色：</strong></p><ul><li>抽象主题角色（Subject：主题角色将所有对观察者对象的引用保存在一个集合中，每个主题可以有任意多个观察者。抽象主题提供了增加和删除等观察者对象的接口。</li><li>抽象观察者角色（Observer）：为所有的具体观察者定义一个接口，在观察的主题发生改变时更新自己。</li><li>具体主题角色（ConcreteSubject）(1个)：存储相关状态到具体观察者对象，当具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个具体子类实现。</li><li>具体观察者角色（ConcretedObserver）(多个)：存储一个具体主题对象，存储相关状态，实现抽象观察者角色所要求的更新接口，以使得其自身状态和主题的状态保持一致。</li></ul><p><strong>具体关系：</strong></p><ul><li><p>抽象主题（Subject）(接口)–&gt;被具体主题（ConcreteSubject）角色(1个)实现</p></li><li><p>抽象观察者（Observer）(接口)–&gt;被具体观察者（ConcretedObserver）角色(N个)实现</p></li><li><p>观察者对象载入主题方法,并在主题方法中调用观察者对象实现的接口方法update来让自己发生变更响应。</p></li></ul><p><strong>一些场景：</strong></p><ul><li>当对一个对象的的改动会引发其他对象的变动时，而且你无法预测有多少个对象需要被改动。</li><li>当一个对象需要有能力通知其他对象，且不需要了解这些对象是什么类型时。</li></ul><p>基于发布订阅的具体实现例子还是很多的，比较典型的就是这种订阅一个博客，然后博客更新推送；还有微信公众号，服务号这些。</p><p>到这里我们再回过头来看一开始留下的几个问题：</p><ul><li>被观察者的状态发生变更，然后“主动通知”观察者，并不是说，观察者主动去获取通知。</li><li>被观察者是消息发布者，观察者是消息订阅者；观察者是被动接受者。</li><li>被观察者的作用就是存储当前的观察者列表，然后提供一些通知机制来告诉观察者自己发生了状态变更，是主动者。</li></ul><p>OK，观察者模式就撸到这里，也欢迎小伙伴们提出自己珍贵的意见；有写的不当之处烦请及时提出。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;最近想深入研究下响应式编程，作为基础很有必要来把观察者模式撸一遍；一开始我是觉得很easy,然后就直接开撸了，撸着撸着发现撸不动了。因为我突然不太明白这个模式了，说好的观察者，到底发布-订阅的两者执行者谁才是观察者？又或者说还有其他角色？但是根据《JAVA与模式
      
    
    </summary>
    
      <category term="架构之路" scheme="http://www.glmapper.com/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="设计模式" scheme="http://www.glmapper.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC源码系列：九大组件小记</title>
    <link href="http://www.glmapper.com/2018/11/10/spring-base-webmvc5/"/>
    <id>http://www.glmapper.com/2018/11/10/spring-base-webmvc5/</id>
    <published>2018-11-10T06:21:07.000Z</published>
    <updated>2018-11-10T06:21:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面几篇文章都是针对于SpringMVC中的具体组件进行源码分析的；本文主要用于补充记录一下关于SpringMVC中九大组件的学习。这个会牵扯出除之前的几篇<code>HandlerMapping</code>之外的其他一些基础组件。</p><p>之前简单的有介绍过<code>DispatcherServlet</code>这个类的体系结构，此处就不再赘述了。在<code>DispatcherServlet</code>类中，其在mvc子容器进行初始化时就会完成对九大组件的初始化工作，具体哪九大组件后面会慢慢说到。先来看下在<code>DispatcherServlet</code>中是通过哪些方法来完成初始化工作的,先贴一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.initMultipartResolver(context);</span><br><span class="line">    <span class="keyword">this</span>.initLocaleResolver(context);</span><br><span class="line">    <span class="keyword">this</span>.initThemeResolver(context);</span><br><span class="line">    <span class="keyword">this</span>.initHandlerMappings(context);</span><br><span class="line">    <span class="keyword">this</span>.initHandlerAdapters(context);</span><br><span class="line">    <span class="keyword">this</span>.initHandlerExceptionResolvers(context);</span><br><span class="line">    <span class="keyword">this</span>.initRequestToViewNameTranslator(context);</span><br><span class="line">    <span class="keyword">this</span>.initViewResolvers(context);</span><br><span class="line">    <span class="keyword">this</span>.initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的<code>onRefresh</code>方法就是<code>DispatcherServlet</code>的入口方法。在<code>onRefresh</code>中又通过调用<code>initStrategies</code>方法来将各个组件的初始化逻辑进行整合，个人理解其实就是策略套策略，在一个就是职责也明确。</p><p>在<code>initStrategies</code>方法中又通过调用组件各自的初始化方法来完成具体的初始化工作。从这个地方其实就可以清楚的看出SpringMVC中的9个组件名称了。下面就来捋一捋这九大组件的基本职责。</p><h2 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h2><p>关于handlermapping在下面几篇文章中做过一些基本介绍，但是还不是很全，对于handlermapping的子类还没有分析完，这个会后期更新的。</p><ul><li><a href="https://juejin.im/post/5a5700705188257323350f42" target="_blank" rel="noopener">SpringMVC源码系列：HandlerMapping</a></li><li><a href="https://juejin.im/post/5a5700db6fb9a01cbf38427a" target="_blank" rel="noopener">SpringMVC源码系列：AbstractHandlerMapping</a></li><li><a href="https://juejin.im/post/5a8e2c486fb9a06357750b12" target="_blank" rel="noopener">SpringMVC源码系列：AbstractUrlHandlerMapping</a></li></ul><p>对于<code>HandlerMapping</code>来说，其作用就是根据<code>request</code>找到相应的处理器<code>Handler</code>和<code>Intecepter</code>拦截器。具体细节参数上面第一篇文章。</p><h2 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h2><p>如果说<code>HandlerMapping</code>是一支笔，那么<code>HandlerAdapter</code>就是用笔的人。也就是说<code>HandlerAdapter</code>就是使用处理器干活的人。为什么呢？来看下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">    <span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, Object var3)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest var1, Object var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是一目了然了，在<code>HandlerAdapter</code>接口中提供了<code>handle</code>这样一个方法，参数中Object handler第三个参数其实就是一个处理器，那我们就知道了，<code>handle</code>方法就是使用<code>handler</code>来处理逻辑的。处理之后返回一个<code>ModelAndView</code>。</p><h2 id="HandlerExceptionResolver"><a href="#HandlerExceptionResolver" class="headerlink" title="HandlerExceptionResolver"></a>HandlerExceptionResolver</h2><p>这个是<code>SpringMVC</code>中的异常处理组件，<code>HandlerExceptionResolver</code>这个组件的作用就是根据异常设置<code>ModelAndView</code>，然后再将处理结果交给<code>render</code>方法进行渲染。当然<code>render</code>也仅仅只是负责将<code>ModelAndView</code>渲染成页面，<code>ModelAndView</code>的具体来源它不关心。</p><p>这里需要说明一下，加入在渲染过程中发生异常怎么办？从上面的分析我们可以清楚的知道，<code>HandlerExceptionResolver</code>这个组件对异常的处理结果是<code>ModelAndView</code>，然后再由<code>render</code>方法进行渲染，也就是说<code>HandlerExceptionResolver</code>是在渲染之前工作的，因此渲染过程中发生异常，<code>HandlerExceptionResolver</code>是不会处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="function">ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, Object var3, Exception var4)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>HandlerExceptionResolver</code>中也只有一个方法，这个方法就是从异常中解析出<code>ModelAndView</code>。</p><h2 id="ViewResolver"><a href="#ViewResolver" class="headerlink" title="ViewResolver"></a>ViewResolver</h2><p><code>ViewResolver</code>的作用是将<code>String</code>类型的逻辑视图根据local解析为<code>View</code>视图的。下面是<code>ViewResolver</code>的源码接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewResolver</span> </span>&#123;</span><br><span class="line">    <span class="function">View <span class="title">resolveViewName</span><span class="params">(String viewName, Locale local)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看到，在<code>ViewResolver</code>中也是只有一个方法，从<code>resolveViewName</code>方法的参数和返回结果就很好的解释了其作用。</p><ul><li>viewName String类型的视图名</li><li>local 区域，可以用来做国际化。</li></ul><p><code>View</code>实际上是用来渲染页面的，也就是说将程序返回的结果填入到具体的模板里面，生成具体的视图文件，比如：jsp，ftl，html等。</p><p>但是这里又会牵扯出两个问题：</p><ul><li>用什么模板？</li><li>参数怎么填入？</li></ul><p>当然，这两个问题也就是本小节说的<code>ViewResolver</code>需要解决的问题。大体分为两种：</p><h3 id="针对单一视图类型的解析器"><a href="#针对单一视图类型的解析器" class="headerlink" title="针对单一视图类型的解析器"></a>针对单一视图类型的解析器</h3><ul><li>InternalResourceViewResolver</li><li>FreeMarkerViewResolver</li></ul><p>上面两种是用的最多的两种，<code>InternalResourceViewResolver</code>用来解析jsp，而<code>FreeMarkerViewResolver</code>则是针对FreeMarker。</p><h3 id="针对同时解析多种类型视图的解析器"><a href="#针对同时解析多种类型视图的解析器" class="headerlink" title="针对同时解析多种类型视图的解析器"></a>针对同时解析多种类型视图的解析器</h3><ul><li><p>BeanNameViewResolver</p><p>  需要同时使用视图名和对应的local来解析视图。它需要将每一个视图名和对应的视图类型配置到相应的properties文件中。（后面讲组件实现细节时给出列子）</p></li><li><p>XmlViewResolver</p><p>  XmlViewResolver和BeanNameViewResolver有点差不多，BeanNameViewResolver使用的是xml格式的配置文件。</p></li><li><p>ResourceBundleViewResolver</p><p>  这个其实就是根据viewName从Spring容器中查找bean，再根据这个bean来找到对应的视图。</p></li></ul><h2 id="LocalResolver"><a href="#LocalResolver" class="headerlink" title="LocalResolver"></a>LocalResolver</h2><p>在上面的<code>ViewResolver</code>中提到，解析视图需要两个参数，一个是String类型的逻辑视图名，另外一个是local。<code>LocalResolver</code>的作用就是从request中解析出local的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LocaleResolver</span> </span>&#123;</span><br><span class="line">    <span class="function">Locale <span class="title">resolveLocale</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLocale</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Locale local)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个方法是从request中解析出local，第二个方法是将local设置到request中。</p><p>关于local大多数情况下都是用来做国际化处理的。</p><h2 id="ThemeResolver"><a href="#ThemeResolver" class="headerlink" title="ThemeResolver"></a>ThemeResolver</h2><p>解析主题的。这个我平时除了SpringMVC自己提供的功能外，很少自己去扩展使用，即使是换主题也没有做过。不过既然存在肯定是有存在的原因的。对于我们常见的网页界面活着手机界面来说，一套主题无非就是换一套图片，活着css样式文件等等。我们通过<code>ThemeResolver</code>这个就可以实现这样的功能。具体使用其实也就是配一套properties文件供系统在不同的时候读取切换；当然使用这个也是可以实现国际化的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThemeResolver</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">resolveThemeName</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setThemeName</span><span class="params">(HttpServletRequest request, HttpServletResponse response, String themeName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RequestToViewNameTranslator"><a href="#RequestToViewNameTranslator" class="headerlink" title="RequestToViewNameTranslator"></a>RequestToViewNameTranslator</h2><p>这个其实还是挺有意思的，就是将request请求转换为视图名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface RequestToViewNameTranslator &#123;</span><br><span class="line">    String getViewName(HttpServletRequest request) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RequestToViewNameTranslator</code>只有一个默认的实现类<code>DefaultRequestToViewNameTranslator</code>。</p><p>在<code>DefaultRequestToViewNameTranslator</code>具体实现了getViewName(HttpServletRequest request)方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getViewName</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    String lookupPath = <span class="keyword">this</span>.urlPathHelper.getLookupPathForRequest(request);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.prefix + <span class="keyword">this</span>.transformPath(lookupPath) + <span class="keyword">this</span>.suffix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是委派给urlPathHelper帮助类得到请求的后缀名称，比如通过 请求路径比如/glmapper/login.do转换得到/login.do  ；具体怎么转换成视图也会在后面的组件介绍中给出具体的例子。</p><h2 id="MultipartResolver"><a href="#MultipartResolver" class="headerlink" title="MultipartResolver"></a>MultipartResolver</h2><p>这个相应小伙伴们也不陌生，做网站多多少少会涉及到文件上传。<code>MultipartResolver</code>就是用来处理上传请求的。其处理方式就是将request包装成<code>MultipartHttpServletRequest</code>。然后我们就可以用<code>MultipartHttpServletRequest</code>这个直接调用getFile获取的文件了。</p><h2 id="FlashMapManager"><a href="#FlashMapManager" class="headerlink" title="FlashMapManager"></a>FlashMapManager</h2><p>这个在redirect是进行参数传递需要用到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlashMapManager</span> </span>&#123;</span><br><span class="line">    <span class="function">FlashMap <span class="title">retrieveAndUpdate</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveOutputFlashMap</span><span class="params">(FlashMap flashMap, HttpServletRequest request, HttpServletResponse response)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>retrieveAndUpdate</code>这个方法是用来恢复参数的，对于恢复过的和超时的参数将都会被删除掉。</p><p><code>saveOutputFlashMap</code>这个方法是用来保存参数的。</p><p><code>FlashMapManager</code>的默认实现机制中参数的存储是放在session中的。我之前在一个项目中就有遇到过这种情况，对于一些我们不想暴露在url中的参数，在进行请求转发时，可以使用@RedirectAttributes将参数保存，然后在下一个处理器中获取到。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇主要是来对九大组件做一个笼统的介绍，细节实现及案例均不涉及；在后续的SpringMVC源码系列中对各个组件的实现细节分析时再一探究竟吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面几篇文章都是针对于SpringMVC中的具体组件进行源码分析的；本文主要用于补充记录一下关于SpringMVC中九大组件的学习。这个会牵扯出除之前的几篇&lt;code&gt;HandlerMapping&lt;/code&gt;之外的其他一些基础组件。&lt;/p&gt;
&lt;p&gt;之前简单的有介绍过&lt;co
      
    
    </summary>
    
      <category term="spring mvc" scheme="http://www.glmapper.com/categories/spring-mvc/"/>
    
    
      <category term="spring" scheme="http://www.glmapper.com/tags/spring/"/>
    
      <category term="web" scheme="http://www.glmapper.com/tags/web/"/>
    
      <category term="mvc" scheme="http://www.glmapper.com/tags/mvc/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC源码系列：AbstractUrlHandlerMapping</title>
    <link href="http://www.glmapper.com/2018/11/10/spring-base-webmvc4/"/>
    <id>http://www.glmapper.com/2018/11/10/spring-base-webmvc4/</id>
    <published>2018-11-10T06:20:26.000Z</published>
    <updated>2018-11-10T06:20:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>AbstractUrlHandlerMapping</code>是通过url来进行匹配的，也就是说通过url与对应的Handler包存到一个Map中，然后在getHandlerInternal方法中使用url作为key从Map中获取我们的handler。</p><p><code>AbstractUrlHandlerMapping</code>实现了从url获取handler的过程，具体的映射关系，也就是handlerMap则是交给具体子类来去完成的。<code>AbstractUrlHandlerMapping</code>中定义了handlerMap用来维护映射关系，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; handlerMap = </span><br><span class="line"><span class="keyword">new</span> LinkedHashMap&lt;String, Object&gt;();</span><br></pre></td></tr></table></figure></p><p>除此之外，还有一个rootHandler,这个用于处理“/”请求。</p><p>在前面三篇文章中提到过，handler的获取是通过getHandlerInternal方法完成的，下面看下具体的源码，分析下handler的获取和handlerMap的构建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找给定请求的URL路径的Handler。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">Exception </span>&#123;</span><br><span class="line">    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">    <span class="comment">//使用lookupPath从Map中查找handler</span></span><br><span class="line">    Object handler = lookupHandler(lookupPath, request);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//临时变量，保存原始的handler</span></span><br><span class="line">    Object rawHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//是否是‘/’根路径</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"/"</span>.equals(lookupPath)) &#123;</span><br><span class="line">        <span class="comment">//获取rootHandler</span></span><br><span class="line">    rawHandler = getRootHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果rawHandler是null</span></span><br><span class="line">    <span class="keyword">if</span> (rawHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取默认的handler</span></span><br><span class="line">    rawHandler = getDefaultHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果rawHandler不是null</span></span><br><span class="line">    <span class="keyword">if</span> (rawHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是string类型，则到容器中查找具体的bean</span></span><br><span class="line">    <span class="keyword">if</span> (rawHandler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    String handlerName = (String) rawHandler;</span><br><span class="line">    <span class="comment">//容器中获取</span></span><br><span class="line">    rawHandler = getApplicationContext().getBean(handlerName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//校验handler和request是否匹配</span></span><br><span class="line">    validateHandler(rawHandler, request);</span><br><span class="line">    <span class="comment">//注册拦截器</span></span><br><span class="line">    handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//日志debug</span></span><br><span class="line">    <span class="keyword">if</span> (handler != <span class="keyword">null</span> &amp;&amp; logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">"Mapping ["</span> + lookupPath + <span class="string">"] to "</span> + handler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (handler == <span class="keyword">null</span> &amp;&amp; logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">"No handler mapping found for ["</span> + lookupPath + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回handler</span></span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>getHandlerInternal</code>方法中有几个方法调用，像getLookupPathForRequest、getRootHandler、getDefaultHandler、lookupHandler、buildPathExposingHandler等。其中getLookupPathForRequest、getRootHandler、getDefaultHandler这几个没啥好说的；比较核心的就是lookupHandler、buildPathExposingHandler这两个方法。</p><ul><li><p>lookupHandler</p><p>  lookupHandler使用getUrlPathHelper().getLookupPathForRequest(request)获取到的lookupPath从Map中查找需要的Handler,通常情况下是直接get不到的。为什么呢？原因在于很多的handler都是使用了Pattern的匹配模式，比如说“/user/*”,星号表示匹配任意内容，并非是指定url串中的字符。如果Pattern中包含了PathVariable,也不能直接从Map中获取到。</p><p>  除此之外，一个url还可能和多个Pattern相匹配，那么这个时候咱们肯定就需要选择最优的，所以说查找过程其实并不是直接从map中获取那么简单。那么就来看下在lookupHandler中都干了哪些事情：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">lookupHandler</span><span class="params">(String urlPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 直接匹配，直接从Map中获取</span></span><br><span class="line">    Object handler = <span class="keyword">this</span>.handlerMap.get(urlPath);</span><br><span class="line">    <span class="comment">//取到了</span></span><br><span class="line">    <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是string类型，则从容器中获取Bean</span></span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    String handlerName = (String) handler;</span><br><span class="line">    handler = getApplicationContext().getBean(handlerName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//验证是否匹配</span></span><br><span class="line">    validateHandler(handler, request);</span><br><span class="line">    <span class="comment">//注册拦截器</span></span><br><span class="line">    <span class="keyword">return</span> buildPathExposingHandler(handler, urlPath, urlPath, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Pattern 匹配，带*号的模式与url进行匹配</span></span><br><span class="line">    List&lt;String&gt; matchingPatterns = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String registeredPattern : <span class="keyword">this</span>.handlerMap.keySet()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getPathMatcher().match(registeredPattern, urlPath)) &#123;</span><br><span class="line">    matchingPatterns.add(registeredPattern);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (useTrailingSlashMatch()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!registeredPattern.endsWith(<span class="string">"/"</span>) &amp;&amp; getPathMatcher().match(registeredPattern + <span class="string">"/"</span>, urlPath)) &#123;</span><br><span class="line">    matchingPatterns.add(registeredPattern +<span class="string">"/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取最佳匹配</span></span><br><span class="line">    String bestPatternMatch = <span class="keyword">null</span>;</span><br><span class="line">    Comparator&lt;String&gt; patternComparator = getPathMatcher().getPatternComparator(urlPath);</span><br><span class="line">    <span class="keyword">if</span> (!matchingPatterns.isEmpty()) &#123;</span><br><span class="line">    Collections.sort(matchingPatterns, patternComparator);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">"Matching patterns for request ["</span> + urlPath + <span class="string">"] are "</span> + matchingPatterns);</span><br><span class="line">    &#125;</span><br><span class="line">    bestPatternMatch = matchingPatterns.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最佳匹配不为null</span></span><br><span class="line">    <span class="keyword">if</span> (bestPatternMatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从Map中看看是否有对应的Handler  </span></span><br><span class="line">    handler = <span class="keyword">this</span>.handlerMap.get(bestPatternMatch);</span><br><span class="line">    <span class="comment">//如果Map中没有</span></span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//是否以/结尾</span></span><br><span class="line">    Assert.isTrue(bestPatternMatch.endsWith(<span class="string">"/"</span>));</span><br><span class="line">    <span class="comment">//去除/之后再获取一次</span></span><br><span class="line">    handler = <span class="keyword">this</span>.handlerMap.get(bestPatternMatch.substring(<span class="number">0</span>, bestPatternMatch.length() - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是String类型，则从容器中获取Bean?</span></span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    String handlerName = (String) handler;</span><br><span class="line">    handler = getApplicationContext().getBean(handlerName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//验证是否匹配</span></span><br><span class="line">    validateHandler(handler, request);</span><br><span class="line">    String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestPatternMatch, urlPath);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可能有多种最佳模式，让我们确保我们有正确的URI模板变量（译）</span></span><br><span class="line">    Map&lt;String, String&gt; uriTemplateVariables = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String matchingPattern : matchingPatterns) &#123;</span><br><span class="line">    <span class="keyword">if</span> (patternComparator.compare(bestPatternMatch, matchingPattern) == <span class="number">0</span>) &#123;</span><br><span class="line">    Map&lt;String, String&gt; vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, urlPath);</span><br><span class="line">    Map&lt;String, String&gt; decodedVars = getUrlPathHelper().decodePathVariables(request, vars);</span><br><span class="line">    uriTemplateVariables.putAll(decodedVars);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">"URI Template variables for request ["</span> + urlPath + <span class="string">"] are "</span> + uriTemplateVariables);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildPathExposingHandler(handler, bestPatternMatch, pathWithinMapping, uriTemplateVariables);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No handler found...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，关于译注的部分需要说一下；代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; uriTemplateVariables = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">for</span> (String matchingPattern : matchingPatterns) &#123;</span><br><span class="line">    <span class="keyword">if</span> (patternComparator.compare(bestPatternMatch, matchingPattern) == <span class="number">0</span>) &#123;</span><br><span class="line">    Map&lt;String, String&gt; vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, urlPath);</span><br><span class="line">    Map&lt;String, String&gt; decodedVars =</span><br><span class="line">    getUrlPathHelper().decodePathVariables(request, vars);</span><br><span class="line">    uriTemplateVariables.putAll(decodedVars);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前是通过sort方法进行排序的，然后将第一个作为bestPatternMatch，但是如果多个pattern的顺序相同，也就是说sort返回的是0,存在多种最佳匹配，那就需要确保我们有正确的URI模板变量。上面代码就是处理这种情况的。</p><ul><li><p>buildPathExposingHandler</p><p>  这个方法在上面的两段代码中都频繁出现，那么这个方法到底有什么作用呢？代码中我注释的是注册拦截器，那么注册的又是什么拦截器？带着这两个问题，我们来看下代码。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//buildPathExposingHandler为给定的rawHandler构建一个Handler对象，并在执</span></span><br><span class="line"><span class="comment">//行处理程序之前暴露实际的处理程序PATH_WITHIN_HANDLER_MAPPING_ATTRIBUT</span></span><br><span class="line"><span class="comment">//E以及URI_TEMPLATE_VARIABLES_ATTRIBUTE。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认实现用一个特殊的拦截器构建一个HandlerExecutionChain，该拦截器暴露</span></span><br><span class="line"><span class="comment">//path属性和uri模板变量。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">buildPathExposingHandler</span><span class="params">(Object rawHandler, </span></span></span><br><span class="line"><span class="function"><span class="params">    String bestMatchingPattern,</span></span></span><br><span class="line"><span class="function"><span class="params">    String pathWithinMapping, </span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;String, String&gt; uriTemplateVariables)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    HandlerExecutionChain chain = <span class="keyword">new</span> HandlerExecutionChain(rawHandler);</span><br><span class="line">    chain.addInterceptor(<span class="keyword">new</span> PathExposingHandlerInterceptor(bestMatchingPattern, pathWithinMapping));</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(uriTemplateVariables)) &#123;</span><br><span class="line">    chain.addInterceptor(<span class="keyword">new</span> UriTemplateVariablesHandlerInterceptor(uriTemplateVariables));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四个参数：</p><ul><li>rawHandler 原始处理程序</li><li>bestMatchingPattern 最佳匹配模式</li><li>pathWithinMapping 在执行Handler之前公开的路径</li><li>uriTemplateVariables 如果没有找到变量，URI模板变量可以是{null}</li></ul><p>从代码注释翻译及代码内容可以了解到，buildPathExposingHandler的作用就是给已经查找到的handler注册两个拦截器</p><ul><li>ExposingHandlerInterceptor</li><li>UriTemplateVariablesHandlerInterceptor</li></ul><p>这两个类均是<code>AbstractUrlHandlerMapping</code>的内部类，也就是两个内部拦截器。这两个拦截器的主要作用就是将与当前url实际匹配的pattern、匹配条件以及url模板参数等设置到request的属性里面去，这样在后面的处理过程中就可以直接从request属性中获取。看下两个内部类的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PathExposingHandlerInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String bestMatchingPattern;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String pathWithinMapping;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathExposingHandlerInterceptor</span><span class="params">(String bestMatchingPattern, String pathWithinMapping)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bestMatchingPattern = bestMatchingPattern;</span><br><span class="line">    <span class="keyword">this</span>.pathWithinMapping = pathWithinMapping;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> </span>&#123;</span><br><span class="line">    exposePathWithinMapping(<span class="keyword">this</span>.bestMatchingPattern,</span><br><span class="line">    <span class="keyword">this</span>.pathWithinMapping, request);</span><br><span class="line">    <span class="comment">//设置request属性</span></span><br><span class="line">    request.setAttribute(HandlerMapping.INTROSPECT_TYPE_LEVEL_MAPPING, supportsTypeLevelMappings());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">UriTemplateVariablesHandlerInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; uriTemplateVariables;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UriTemplateVariablesHandlerInterceptor</span><span class="params">(Map&lt;String, String&gt; uriTemplateVariables)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.uriTemplateVariables = uriTemplateVariables;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">    HttpServletResponse response, Object handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这exposeUriTemplateVariables种设置request属性</span></span><br><span class="line">    exposeUriTemplateVariables(<span class="keyword">this</span>.uriTemplateVariables, request);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从内部类的代码可以看出，这两个内部类是通过在preHandle方法中调用exposePathWithinMapping和exposeUriTemplateVariables完成属性设置到request中的。</p><p>对于查找handler的关键其实就是维护url和handler的映射关系，也就是handlerMap的构建。在<code>AbstractUrlHandlerMapping</code>中是通过registerHandler这个方法来构建handlerMap的。<code>AbstractUrlHandlerMapping</code>提供了两个registerHandler方法，下面就通过代码来看下具体的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandler</span><span class="params">(String[] urlPaths, String beanName)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    Assert.notNull(urlPaths, <span class="string">"URL path array must not be null"</span>);</span><br><span class="line">    <span class="keyword">for</span> (String urlPath : urlPaths) &#123;</span><br><span class="line">    registerHandler(urlPath, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个registerHandler是将多个url注册到一个处理器。beanName其实就是咱们处理器的名称，可以通过beanName到容器中去找到真正的处理器Bean。具体处理就是通过遍历所有的url，然后再通过调用第二个registerHandler将handler注册到handlerMap中。来看第二个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandler</span><span class="params">(String urlPath, Object handler)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    Assert.notNull(urlPath, <span class="string">"URL path must not be null"</span>);</span><br><span class="line">    Assert.notNull(handler, <span class="string">"Handler object must not be null"</span>);</span><br><span class="line">    Object resolvedHandler = handler;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果的handler是string类型，并且不是lazyInitHandlers，则从SpringMV</span></span><br><span class="line">    <span class="comment">//C容器中获取handler</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.lazyInitHandlers &amp;&amp; handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    String handlerName = (String) handler;</span><br><span class="line">    <span class="keyword">if</span> (getApplicationContext().isSingleton(handlerName)) &#123;</span><br><span class="line">    resolvedHandler = getApplicationContext().getBean(handlerName);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Object mappedHandler = <span class="keyword">this</span>.handlerMap.get(urlPath);</span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != resolvedHandler) &#123;</span><br><span class="line">    <span class="comment">//异常处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//是否是跟路径</span></span><br><span class="line">    <span class="keyword">if</span> (urlPath.equals(<span class="string">"/"</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">    logger.info(<span class="string">"Root mapping to "</span> +</span><br><span class="line">    getHandlerDescription(handler));</span><br><span class="line">    &#125;</span><br><span class="line">    setRootHandler(resolvedHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否是*模式</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (urlPath.equals(<span class="string">"/*"</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">    logger.info(<span class="string">"Default mapping to "</span> +</span><br><span class="line">    getHandlerDescription(handler));</span><br><span class="line">    &#125;</span><br><span class="line">    setDefaultHandler(resolvedHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加入到handlerMap中</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.handlerMap.put(urlPath, resolvedHandler);</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Mapped URL path ["</span> + urlPath + <span class="string">"] onto "</span> +</span><br><span class="line">        getHandlerDescription(handler));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个里面首先是看Map中是否有原来传入的url，如果没有就加入，如果有就看下原来保存的和当前注册的handler是否是同一个，如果不是同一个就抛出异常。（同一个url不可能存在两个不同的handler）。</p><p>在put之前，也做了一些“/”和“/*”的验证处理，如果是这两种路径的话就不保存到handlerMap中了。</p><ul><li>“/”：setRootHandler(resolvedHandler);</li><li>“/*”：setDefaultHandler(resolvedHandler);</li></ul><p>OK，到这<code>AbstractUrlHandlerMapping</code>这个类就分析完了，其实<code>AbstractUrlHandlerMapping</code>做的事情就是定义了一个框子，子类只要完成对Map的初始化就可以了。关于<code>AbstractUrlHandlerMapping</code>的子类后续再谈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;AbstractUrlHandlerMapping&lt;/code&gt;是通过url来进行匹配的，也就是说通过url与对应的Handler包存到一个Map中，然后在getHandlerInternal方法中使用url作为key从Map中获取我们的handler。&lt;/p&gt;
      
    
    </summary>
    
      <category term="spring mvc" scheme="http://www.glmapper.com/categories/spring-mvc/"/>
    
    
      <category term="spring" scheme="http://www.glmapper.com/tags/spring/"/>
    
      <category term="web" scheme="http://www.glmapper.com/tags/web/"/>
    
      <category term="mvc" scheme="http://www.glmapper.com/tags/mvc/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码系列：注解说明</title>
    <link href="http://www.glmapper.com/2018/11/10/springbase13/"/>
    <id>http://www.glmapper.com/2018/11/10/springbase13/</id>
    <published>2018-11-10T06:18:34.000Z</published>
    <updated>2018-11-10T06:18:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为要看Spring中注解的具体定义，所以在说之前，先来简单说下JAVA中注解的一些基本知识。</p><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>什么是元注解呢，就是注解的注解。java中提供了以下几种：</p><ul><li>@Target</li></ul><pre><code>注解的作用域描述<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</span><br><span class="line">    <span class="comment">/** 类, 接口 或者枚举 */</span></span><br><span class="line">    TYPE,</span><br><span class="line">    <span class="comment">/** 字段 */</span></span><br><span class="line">    FIELD,</span><br><span class="line">    <span class="comment">/** 方法 */</span></span><br><span class="line">    METHOD,</span><br><span class="line">    <span class="comment">/** 参数 */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line">    <span class="comment">/** 构造方法 */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line">    <span class="comment">/** 局部变量 */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line">    <span class="comment">/** 注解类型 */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line">    <span class="comment">/** 包 */</span></span><br><span class="line">    PACKAGE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>@Retention</p><p>  生命周期描述</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在原文件中有效，被编译器丢弃。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在class文件有效，可能会被虚拟机忽略。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在运行时有效。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Inherited</p><p>  标识性的元注解，它允许子注解继承它。</p></li><li><p>@Documented</p><p>  用于标准生成javadoc时会包含的注解。</p></li></ul><h2 id="JAVA中注解的定义方式"><a href="#JAVA中注解的定义方式" class="headerlink" title="JAVA中注解的定义方式"></a>JAVA中注解的定义方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名 &#123;定义体&#125;</span><br></pre></td></tr></table></figure><hr><p>上面试一些基本概念点，关注注解其他的一些特性和用法就不细说了。直接看Spring中的注解吧。</p><h2 id="1、-Component"><a href="#1、-Component" class="headerlink" title="1、@Component"></a>1、@Component</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Component &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">     * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the suggested component name, if any</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指示注释类是“组件”。 当使用基于注释的配置和类路径扫描时，这些类被认为是自动检测的候选对象。</p><h2 id="2、-Controller"><a href="#2、-Controller" class="headerlink" title="2、@Controller"></a>2、@Controller</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用过Spring mvc的小伙伴对于这个注解肯定不陌生。@Controller表示注释的类是“控制器”（例如Web控制器）。这个注解作为@Component的一个特定方式存在，允许通过类路径扫描来自动检测实现类。通常情况下会结合RequestMapping注解使用。从它的定义层面来看，这个注解只能用于接口或者类上面，不能用于方法或者属性字段上面。</p><h2 id="3、-Service"><a href="#3、-Service" class="headerlink" title="3、@Service"></a>3、@Service</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示注释类是一个“服务”，最初由Domain-Driven Design （Evans，2003）定义为“作为模型中独立的接口提供的操作，没有封装状态”。</p><p>在一般情况下，我们把他用在标准我们的service服务接口的实现类上面，实际上这相当于缩小它们的语义和适当的使用。</p><p>@Service这个注释作为 @Component的一个特例，允许通过类路径扫描来自动检测实现类。</p><h2 id="4、-Repository"><a href="#4、-Repository" class="headerlink" title="4、@Repository"></a>4、@Repository</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Repository &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">     * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the suggested component name, if any</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于标注数据访问组件，即DAO组件</p><h2 id="5、-RequestMapping"><a href="#5、-RequestMapping" class="headerlink" title="5、@RequestMapping"></a>5、@RequestMapping</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Mapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"path"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] path() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    RequestMethod[] method() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    String[] params() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    String[] headers() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    String[] consumes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    String[] produces() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@RequestMapping是一个用来处理地址映射请求的注解，从定义可以看出，可作用于方法或者类上。</p><ul><li>用于类上，大多数是为了进行区分controller</li><li>用于方法上则是对方法进行注解以产生访问的路径。</li></ul><p>它包括了几个属性：</p><ul><li>value 用于设置方法或者类的映射路径，可以直接写路径。我们通常都是直接写，例如：@RequestMapping(“/XXX”);</li><li>method 用于指定请求的方法，可以设置单个或多个，如果请求方法不满足条件则会请求失败。</li><li>params  指定request中必须包含某些参数值是，才让该方法处理。</li><li>name 此映射指定一个名称</li><li>path 仅在Servlet环境中：路径映射URI（例如“/myPath.do”）。也支持Ant风格的路径模式（例如“/myPath/*.do”）。在方法级别，在类型级别表示的主映射内支持相对路径（例如“edit.do”）。 路径映射URI可能包含占位符（例如“/ $ {connect}”）</li><li>consumes 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</li><li>produces 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</li><li>headers 指定request中必须包含某些指定的header值，才能让该方法处理请求。</li></ul><p>其他的几个没怎么用过，确实不了解，有知道的小伙伴，欢迎留言。</p><h2 id="6、-ResponseBody"><a href="#6、-ResponseBody" class="headerlink" title="6、@ResponseBody"></a>6、@ResponseBody</h2><p>@ResponseBody这个我一般是用在做异步请求调用的方法上来使用的。因为在使用@RequestMapping后，返回值通常解析为跳转路径。加上@responsebody后，返回结果直接写入HTTP response body中，不会被解析为跳转路径。</p><p>对于异步请求，我们不希望返回解析视图，二是希望响应的结果是json数据，那么加上@responsebody后，就会直接返回json数据。</p><h2 id="7、-Autowired"><a href="#7、-Autowired" class="headerlink" title="7、@Autowired"></a>7、@Autowired</h2><p>Autowired就是自动装配的意思，其作用是为了消除代码Java代码里面的getter/setter与bean属性中的property。当然，getter看个人需求，如果私有属性需要对外提供的话，就应该保留。</p><p>@Autowired默认按类型匹配的方式，在容器查找匹配的Bean，当有且仅有一个匹配的Bean时，Spring将其注入@Autowired标注的变量中。</p><p>但是当接口存在两个实现类的时候必须使用@Qualifier指定注入哪个实现类，否则可以省略，只写@Autowired。</p><h2 id="8、-Qualifier"><a href="#8、-Qualifier" class="headerlink" title="8、@Qualifier"></a>8、@Qualifier</h2><p>@Qualifier用于指定注入Bean的名称，就是上面说到的，如果容器中有一个以上匹配的Bean，则可以通过@Qualifier注解限定Bean的名称。</p><h2 id="9、-Resource"><a href="#9、-Resource" class="headerlink" title="9、@Resource"></a>9、@Resource</h2><p>这个注解不是Spring的，放在这里是为了和@Autowired做一个区别。<br>@Resource默认按名称装配，当找不到与名称匹配的bean才会按类型装配。</p><h2 id="10、-PathVariable"><a href="#10、-PathVariable" class="headerlink" title="10、@PathVariable"></a>10、@PathVariable</h2><p>当使用@RequestMapping URI template 样式映射时， 即 someUrl/{paramId}, 这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user/&#123;userId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">userCenter</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                            HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                            @PathVariable String userId)</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果方法参数名称和需要绑定的uri template中变量名称不一致，需要在@PathVariable(“name”)指定uri template中的名称。</p><h2 id="11、-RequestParam"><a href="#11、-RequestParam" class="headerlink" title="11、@RequestParam"></a>11、@RequestParam</h2><p>@RequestParam注解有两个属性： value、required；</p><ul><li>value用来指定要传入值的id名称</li><li>required用来指示参数是否必须绑定；</li></ul><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/t_rparam1"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">t_rparam1</span><span class="params">(@RequestParam  Long userId)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//do something   </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/t_rparam2"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">t_rparam2</span><span class="params">(Long userId)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//do something   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>t_rparam1 必须带有参数,也就是说你直接输入localhost:8080/t_rparam1 会报错只能输入localhost:8080/t_rparam1?userId=? 才能执行相应的方法</li><li>t_rparam2  可带参数也可不带参数;也就是说输入localhost:8080/t_rparam2和输入 localhost:8080/t_rparam2?userId=?都可以正常运行</li></ul><p>当然我们也可以设置 @RequestParam 里面的required为false(默认为true 代表必须带参数) 这样t_rparam1就跟t_rparam2是一样的了。</p><h2 id="12、-RequestHeader"><a href="#12、-RequestHeader" class="headerlink" title="12、@RequestHeader"></a>12、@RequestHeader</h2><p>利用@RequestHeader 注解可以把Request请求header部分的值绑定到方法的参数上。</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/9/16179c7273eff4d0?w=636&amp;h=94&amp;f=png&amp;s=46122" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/t_heander"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getRequestHeaderTest</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                            HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                            @RequestHeader(<span class="string">"Accept-Encoding"</span>)</span>String encoding)  </span>&#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//do something </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13、-CookieValue"><a href="#13、-CookieValue" class="headerlink" title="13、@CookieValue"></a>13、@CookieValue</h2><p>@CookieValue就是把Request header中cookie的值绑定到方法的参数上。比如说我们的cookie如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie:JSESSIONID=ka8A5L5t7WTUPXbaLupBieqOdmc0ZpD5MyKvea6oQr7JJSIZzM;userId=001;sysFlag=glmapper</span><br></pre></td></tr></table></figure><p>获取如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/t_cookie"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCookieValueTest</span><span class="params">(@CookieValue(<span class="string">"JSESSIONID"</span>)</span> String cookie)  </span>&#123;  </span><br><span class="line">  <span class="comment">//do something </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="14、-RequestBody"><a href="#14、-RequestBody" class="headerlink" title="14、@RequestBody"></a>14、@RequestBody</h2><p>@RequestBody这个注解常用来处理Content-Type不是application/x-www-form-urlencoded编码的内容，比如说：application/json, application/xml等等；这个和ResonseBody可以反过来理解。</p><h2 id="15、-ModelAttribute"><a href="#15、-ModelAttribute" class="headerlink" title="15、@ModelAttribute"></a>15、@ModelAttribute</h2><ul><li><p>方法上</p><p>  通常用来在处理@RequestMapping之前，为请求绑定需要从后台查询的model；</p></li><li><p>参数上</p><p>  用来通过名称对应，把相应名称的值绑定到注解的参数bean上；</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《Spring技术内幕》</li><li><a href="https://www.cnblogs.com/FrankLei/p/6579843.html" target="_blank" rel="noopener">https://www.cnblogs.com/FrankLei/p/6579843.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为要看Spring中注解的具体定义，所以在说之前，先来简单说下JAVA中注解的一些基本知识。&lt;/p&gt;
&lt;h2 id=&quot;元注解&quot;&gt;&lt;a href=&quot;#元注解&quot; class=&quot;headerlink&quot; title=&quot;元注解&quot;&gt;&lt;/a&gt;元注解&lt;/h2&gt;&lt;p&gt;什么是元注解呢，就是注
      
    
    </summary>
    
      <category term="spring" scheme="http://www.glmapper.com/categories/spring/"/>
    
    
      <category term="spring" scheme="http://www.glmapper.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>JUC·ThreadPoolExecutor 线程池</title>
    <link href="http://www.glmapper.com/2018/11/10/java-up-juc2/"/>
    <id>http://www.glmapper.com/2018/11/10/java-up-juc2/</id>
    <published>2018-11-10T06:17:41.000Z</published>
    <updated>2018-11-10T10:12:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadPoolExecutor算是JUC中最常用的类之一了。ThreadPoolExecutor，顾名思义，thread-pool-executor,硬翻译就是“线程-池-执行者”；java中，通过ThreadPoolExecutor可以很容易的创建一个线程池。但是我们为什么要使用线程池？呢？它能够带来什么样的优势呢？它又是怎么实现的呢？OK，带着这几个问题，我们来学习一下JAVA中的线程池技术。</p><h2 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h2><p>关于这个问题其实有点鸡肋，我觉得再问这个问题之前更应该问为什么要有线程池。那为什么呢?</p><hr><p>this is a 例子：</p><p><code>快递行业最近两年发展的灰常火热，听说工资也非常的高，搞得我一天天的都没有心思去好好写代码了...</code></p><p><code>之前的小快递公司都是没有固定的快递员的，就是说，每次去送一件快递，站点负责人就需要去找一个人来帮忙送，送完之后就没有然后了(当然，钱还是要给的)。</code></p><p><code>但是后来随着货越来越多，找人给钱成本太大，而且农忙时还需要花很长时间去找人，所以就雇用了5个人，签了合同，长期为站点配送。</code></p><p>以前都是随时用随时找，现在不是，现在是成立了一个物流公司，开了一个配送部，配送部门规定正式配送员最多只能有五个人。</p><p><strong>之前配送的缺点是什么：</strong></p><ul><li>每次有货，我都会去临时找一个人，然后签订临时合同，送完之后解除合同。很麻烦。<br>这也是不用线程池的缺点，就是任务来了，我们需要频繁的去创建新的线程，用完之后还需要释放线程资源，对于系统的消耗是很大的。</li><li>因为配送的货车只有那么几个，如果临时签订的人多了，车子不够用，其他人只能等着车子送完之后才能用。</li></ul><p><strong>成立配送部之后解决的问题</strong></p><ul><li>成立配送部之后呢，因为签订的是劳务合同，我们可以重复的让配送员配送不同的货物。达到线程资源的复用。</li><li>因为限定了最多招聘的人数，可以很好的避免招过多无用的人。</li></ul><hr><p>OK，我们以上述例子来对应理解线程池的基本原理</p><p>先来看下，JAVA对ThreadPoolExecutor的类申明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span></span><br></pre></td></tr></table></figure><p>在<a href="https://juejin.im/post/5a7578a05188257a59119951" target="_blank" rel="noopener">【初识】-JUC·Executor框架</a>中给出了Executor的继承体系。ThreadPoolExecutor就是具备线程池功能的集成者。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法一</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">                          </span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">         </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//构造方法二</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         threadFactory, defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造方法三</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造方法四</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，构造方法（一、二、三）都是通过调用（四）来做具体属性初始化的。那么我们直接来看构造方法四；在构造方法四中总共需要7个参数，先来看下每个参数的具体含义：</p><ul><li><p>corePoolSize</p><p>  核心线程数大小。那么什么是核心线程数呢，我们可以类比于上面例子中的配送部中签订劳动合同的人的个数。</p></li><li><p>maximumPoolSize</p><p>  最大线程数。加入说现在是双十一期间，快递异常的多，配送部的5个人完全忙不过来，而且仓库也满了，怎么办呢？这个时候就需要再招聘一些临时配送员，假设maximumPoolSize为10，那么也就是说，临时招聘可以招5个人，配送部签订正式劳动合同的人和签订临时合同的人加一块不能超过配送部规定的最大人数（10人）。所以说，maximumPoolSize就是线程池能够允许的存在的最大线程的数量。</p></li><li><p>keepAliveTime</p><p>  存活时间。为什么要有这个呢？想一下，双十一过去了，货物已经配送的差不多了。临时合同写的是如果临时配送员2天没有配送了，那配送部就有权利终止临时合同，现在已经达到2天这个点了，需要开除这些临时配送专员了。对于线程池来说，keepAliveTime就是用来表示，当除核心线程池之外的线程超过keepAliveTime时间之后，就需要被系统回收了。</p></li><li><p>unit</p><p>  keepAliveTime的时间单位。</p></li><li><p>workQueue</p><p>  工作队列。这个就相当于一个仓库，现在配送部5个人都在配送，但是还不断的有新的快递达到，这个时候就需要一个仓库来存放这些快递。对于线程池来说，当核心线程都有自己的任务处理，并且还有任务进来的时候，就会将任务添加到工作队列中去。</p></li><li><p>threadFactory</p><p>  线程工厂。就是用来创建线程的。可以类比成招聘组，会给每个线程分配名字或者编号这样。</p></li><li><p>handler</p><p>  RejectedExecutionHandler 用来描述拒绝策略的。假设现在我的仓库也满足，并且配送部已经达到10个人了。怎么办呢，那么只能采用一些策略来拒绝任务了。</p><h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="comment">//RUNNING；该状态的线程池接收新任务，并且处理阻塞队列中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//SHUTDOWN；该状态的线程池不接收新任务，但会处理阻塞队列中的任务；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//STOP；不接收新任务，也不处理阻塞队列中的任务，并且会中断正在运行的任务；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//线程池彻底终止，就变成TERMINATED状态。 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><p>下面是在网上发现的一位大牛的图；感觉可以较为直观的描述状态的变更</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/7/161702fd7393291e?w=1033&amp;h=406&amp;f=jpeg&amp;s=82514" alt=""></p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616ff08ec07b0e9?w=543&amp;h=443&amp;f=png&amp;s=136351" alt="线程池执行原理"></p><p>有几个点需要注意。</p><h3 id="1、如何提交一个任务到线程池？"><a href="#1、如何提交一个任务到线程池？" class="headerlink" title="1、如何提交一个任务到线程池？"></a>1、如何提交一个任务到线程池？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//任务为null,直接抛出空指针异常</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//如果线程数大于等于基本线程数，将任务加入队列</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果少于corePoolSize线程正在运行，请尝试使用给定命令启动一个新线程作为其第一个任务。 对addWorker的调用会自动检查runState和workerCount，从而防止错误报警，在不应该的时候通过返回false来添加线程。</li><li>如果一个任务能够成功排队，那么我们仍然需要再次检查是否应该添加一个线程（因为现有的线程自上次检查以来已经死掉）或者自从进入这个方法以来，池关闭了。所以我们重新检查状态，如果当前command已经stop了，那么就退出工作队列，如果没有的话就开始一个新的线程。</li><li>如果队列满了，会想尝试去创建一个新的线程去执行，如果创建不了，那就执行拒绝策略。</li></ul><h3 id="2、如何创建一个线程去处理任务？"><a href="#2、如何创建一个线程去处理任务？" class="headerlink" title="2、如何创建一个线程去处理任务？"></a>2、如何创建一个线程去处理任务？</h3><p>通过实现这个接口去创建一个新的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、如何将任务添加到队列？"><a href="#3、如何将任务添加到队列？" class="headerlink" title="3、如何将任务添加到队列？"></a>3、如何将任务添加到队列？</h3><p>通过addWorker方法来添加，其实在excute中只是作为一个提交任务的入口，实际的处理逻辑都是在addWorker这个方法里来完成的。addWorker有两个参数：</p><ul><li>firstTask 当前任务</li><li>core 用来标注当前需要创建的线程是否是核心线程，如果core为true，则表明创建的是核心线程，也就是说当前还没有达到最大核心线程数。</li></ul><p>先来看下这个方法的前半部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">//自旋方式</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取当前线程池的状态</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//如果状态是STOP，TIDYING,TERMINATED状态的话，则会返回false</span></span><br><span class="line">        <span class="comment">//如果状态是SHUTDOWN，但是firstTask不为空或者workQueue为空的话，那么直接返回false。</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//通过自旋的方式，判断要添加的worker是否为corePool范畴之内的</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>//如果超过CAPACITY限制了则直接返回false<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc &gt;= CAPACITY</span><br></pre></td></tr></table></figure></p><p>//判断当前的workerCount是否大于corePoolsize，否则则判断是否大于maximumPoolSize<br>//具体的比较取决于入参core是true还是false。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc &gt;= (core ? corePoolSize : maximumPoolSize)</span><br></pre></td></tr></table></figure></p><p>如果上面两个有一个满足了，则直接返回false。</p><p>下面是判断WorkerCount通过CAS操作增加1是否成功，成功的话就到此结束<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">    <span class="keyword">break</span> retry;</span><br></pre></td></tr></table></figure></p><p>如果不成功，则再次判断当前线程池的状态，如果现在获取到的状态与进入自旋的状态不一致的话，那么则通过continue retry重新进行状态的判断。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line"><span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">    <span class="keyword">continue</span> retry;</span><br></pre></td></tr></table></figure></p><p><br><br>再来看下这个方法的后面半个部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">Worker w = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    <span class="comment">//创建一个新的Worker对象</span></span><br><span class="line">    w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">    <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在锁定的情况下重新检查。</span></span><br><span class="line">            <span class="comment">// 在一下情况退出：ThreadFactory 创建失败或者在获取锁之前shut down了</span></span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">           <span class="comment">//状态校验</span></span><br><span class="line">            <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.isAlive()) <span class="comment">// 预先检查t是可以启动的</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                <span class="comment">//添加至workers中</span></span><br><span class="line">                workers.add(w);</span><br><span class="line">                <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                <span class="comment">//如果超过了历史最大线程数，则将当前池数量设置为历史最大线程记录数</span></span><br><span class="line">                <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                    largestPoolSize = s;</span><br><span class="line">                <span class="comment">//标识添加工作线程成功</span></span><br><span class="line">                workerAdded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果添加成功则启动当前工作线程</span></span><br><span class="line">        <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">            <span class="comment">//并将当前线程状态设置为已启动</span></span><br><span class="line">            workerStarted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//添加失败</span></span><br><span class="line">    <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">        addWorkerFailed(w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拒绝策略有哪些？"><a href="#拒绝策略有哪些？" class="headerlink" title="拒绝策略有哪些？"></a>拒绝策略有哪些？</h3><p><img src="https://user-gold-cdn.xitu.io/2018/2/7/16170281c265a605?w=591&amp;h=155&amp;f=png&amp;s=75622" alt=""></p><ul><li>1、AbortPolicy：直接抛出异常，默认策略；</li><li>2、CallerRunsPolicy：使用调用者自己的当前线程来执行任务；</li><li>3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li><li>4、DiscardPolicy：直接丢弃任务；</li></ul><p>当然我们也可以自定义拒绝策略。</p><h3 id="常用工作队列类型"><a href="#常用工作队列类型" class="headerlink" title="常用工作队列类型"></a>常用工作队列类型</h3><p><strong>1、ArrayBlockingQueue</strong></p><p>基于数组的阻塞队列，长度有限</p><p><strong>2、LinkedBlockingQuene</strong></p><p>基于链表的阻塞队列，长度无限，使用这个可能会导致我们的拒绝策略失效。因为可以无限的创建新的工作线程。</p><p><strong>3、PriorityBlockingQueue</strong></p><p>具有优先级的无界阻塞队列；</p><p><strong>3、SynchronousQuene</strong></p><p>SynchronousQuene是一个是一个不存储元素的BlockingQueue；每一个put操作必须要等待一个take操作，否则不能继续添加元素。所以这个比较特殊，它不存我们的任务，也就说说它的每个put操作必须等到另一个线程调用take操作，否则put操作一直处于阻塞状态。</p><h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><p>这个是ThreadPoolExecutor的一个内部类，表示一个工作线程。重要的是这个内部类实现了AbstractQueuedSynchronizer（AQS:抽象队列同步器）抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当前work持有的线程 */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** 运行的初始任务。 可能为空。*/</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** 每个线程完成任务的计数器 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">    <span class="comment">// 禁止中断，直到runWorker</span></span><br><span class="line">        setState(-<span class="number">1</span>); </span><br><span class="line">        <span class="comment">//想提交的任务交给当前工作线程</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">//通过线程工厂创建一个新的线程</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将run方法的执行委托给外部runWorker */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否锁定</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 0代表解锁状态。</span></span><br><span class="line">    <span class="comment">// 1代表锁定状态。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试获取锁（重写AQS的方法）</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试释放锁（重写AQS的方法）</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">//尝试加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">//是否锁定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line">    <span class="comment">//如果启动则中断</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h2><p>最后来看下runWorker这个方法（ThreadPoolExecutor中的方法）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = null;</span><br><span class="line">    w.unlock(); // allow interrupts</span><br><span class="line">    boolean completedAbruptly = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            // If pool is stopping, ensure thread is interrupted;</span><br><span class="line">            // if not, ensure thread is not interrupted.  This</span><br><span class="line">            // requires a recheck in second case to deal with</span><br><span class="line">            // shutdownNow race while clearing interrupt</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    thrown = x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                task = null;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>下面是对注释的蹩脚翻译，欢迎吐槽，但注意尺度，O(∩_∩)O哈哈~</code></p><p>主要工作循环运行。重复地从队列中获取任务并执行它们，同时处理一些问题: </p><ul><li>我们可能会从最初的任务开始，在这种情况下，我们不需要得到第一个任务。否则，只要池正在运行，我们就从getTask获得任务。 如果它返回null，则由于更改池状态或配置参数而导致worker退出。其他退出的结果是在外部代码中抛出的异常，在这种情况下completeAbruptly成立，这通常会导致processWorkerExit来取代这个线程。</li><li>在运行任何任务之前，获取锁以防止任务正在执行时发生其他池中断，调用clearInterruptsForTaskRun确保除非池正在停止，则此线程没有设置其中断。</li><li>每个任务运行之前都会调用beforeExecute，这可能会引发一个异常，在这种情况下，我们会导致线程死亡（断开循环completeAbruptly为true），而不处理任务。</li><li>假设beforeExecute正常完成，我们运行任务，收集任何抛出的异常发送到afterExecute。 我们分别处理RuntimeException，Error（这两个规范保证我们陷阱）和任意的Throwables。 因为我们不能在Runnable.run中重新抛出Throwable，所以我们把它们封装在Errors中（到线程的UncaughtExceptionHandler）。 任何抛出的异常也保守地导致线程死亡。</li><li>task.run完成后，我们调用afterExecute，这也可能会抛出一个异常，这也会导致线程死亡。 根据JLS Sec 14.20，即使task.run抛出，这个异常也是有效的。</li></ul><p>异常机制的最终效果是afterExecute和线程的UncaughtExceptionHandler拥有关于用户代码遇到的任何问题的准确信息。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文是JUC的第二篇，意在通过查看源码来了解线程池的具体工作原理。文中如果存在不当的描述，希望小伙伴们能够及时提出。灰常感谢！</p><p><code>欢迎关注微信公众号，干货满满哦~</code><br><img src="https://user-gold-cdn.xitu.io/2018/2/7/161704e6a5057ad6?w=258&amp;h=258&amp;f=jpeg&amp;s=15516" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ThreadPoolExecutor算是JUC中最常用的类之一了。ThreadPoolExecutor，顾名思义，thread-pool-executor,硬翻译就是“线程-池-执行者”；java中，通过ThreadPoolExecutor可以很容易的创建一个线程池。但是我
      
    
    </summary>
    
      <category term="JUC" scheme="http://www.glmapper.com/categories/JUC/"/>
    
    
      <category term="java" scheme="http://www.glmapper.com/tags/java/"/>
    
      <category term="线程" scheme="http://www.glmapper.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="thread" scheme="http://www.glmapper.com/tags/thread/"/>
    
      <category term="并发编程" scheme="http://www.glmapper.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JUC·Executor 框架</title>
    <link href="http://www.glmapper.com/2018/11/10/java-up-juc1/"/>
    <id>http://www.glmapper.com/2018/11/10/java-up-juc1/</id>
    <published>2018-11-10T06:16:22.000Z</published>
    <updated>2018-11-10T06:17:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>多线程和并发这两个东西真的是向往已久，总是有一种神秘的感觉，想去探索一波，又担心水平不够无法驾驭。想以读书笔记的方式来写，但是又觉得缺少自己的一些思考；但是在没有足够并发编程经验的情况下又没法去写出很深刻的东西，毕竟没有踩过坑。所以在阅读spring源码的同时，也想抽点时间来看一看JUC的东西，关于这块只能说是记录自己学习JUC的一个过程，尝试用一些具体的代码demo来加深理解。所以就把本系列写成《【 初识】-JUC·XXXX》，用来让自己打开并发编程的大门。</p><h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><p>JUC即java.util.concurrent；也就是java提供的并发包。JUC中从包结构上来看主要是：</p><ul><li><p>java.util.concurrent</p><p>  在这个包下面主要是线程池、并发集合以及一些并发工具类。线程池相关是围绕Excetor框架来构建；这也是本文下面部分的重点。</p></li><li><p>java.util.concurrent.atomic</p><p>  这个包下面是一些原子操作类，算是并发辅助工具类，基本实现依赖于CAS；</p></li><li><p>java.util.concurrent.locks</p><p>  这个从名字就可以知道它的作用，就是提供锁。</p></li></ul><h2 id="JUC各个模块的类"><a href="#JUC各个模块的类" class="headerlink" title="JUC各个模块的类"></a>JUC各个模块的类</h2><ul><li>整体框架</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/2/6/16169e20a66c9495?w=533&amp;h=297&amp;f=png&amp;s=78638" alt=""></p><ul><li>atomic</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/2/6/16169e2d7ef5a81d?w=411&amp;h=384&amp;f=png&amp;s=87131" alt=""></p><ul><li>locks</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/2/6/16169e3528be1404?w=411&amp;h=297&amp;f=png&amp;s=65720" alt=""></p><ul><li>并发集合</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/2/6/16169e3a4b53404b?w=440&amp;h=563&amp;f=png&amp;s=138892" alt=""></p><ul><li>并发工具</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/2/6/16169e3eca541b38?w=406&amp;h=260&amp;f=png&amp;s=52976" alt=""></p><ul><li><p>forkJoin</p><p>  fork-join在JUC中有下面三个类：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span></span><br></pre></td></tr></table></figure></li></ul><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt;, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinWorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br></pre></td></tr></table></figure></code></pre><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>Future提供了可以获取异步执行结果的方法，区别于Runnable的run方法，run是不提供返回结果的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//取消</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="comment">//如果任务完成前被取消，则返回true。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//如果任务执行结束，无论是正常结束或是中途取消还是发生异常，都返回true。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取异步执行的结果，如果没有结果可用，此方法会阻塞直到异步计算完成。</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="comment">//获取异步执行结果，如果没有结果可用，此方法会阻塞，但是会有时间限制，</span></span><br><span class="line">    <span class="comment">//如果阻塞时间超过设定的timeout时间，该方法将抛出异常。</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, </span></span><br><span class="line"><span class="function">    ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>声明了一个名称为call()的方法，同时这个方法可以有返回值V，也可以抛出异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123; </span><br><span class="line">  <span class="function">V   <span class="title">call</span><span class="params">()</span>   <span class="keyword">throws</span> Exception</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于Callable和Future的使用一般情况下都是结合我们的线程池来使用的。</p><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>Executor接口是线程池实现的顶级接口，其和spring中的BeanFactory所承担的角色差不多，就是提供顶级的功能约束，具体实现交于不同子类来完成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given command at some time in the future.  The command</span></span><br><span class="line"><span class="comment">     * may execute in a new thread, in a pooled thread, or in the calling</span></span><br><span class="line"><span class="comment">     * thread, at the discretion of the &lt;tt&gt;Executor&lt;/tt&gt; implementation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command the runnable task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if this task cannot be</span></span><br><span class="line"><span class="comment">     * accepted for execution.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if command is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是JUC中Executor框架的整体结构：</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/6/16169fcf02873970?w=544&amp;h=381&amp;f=png&amp;s=111229" alt=""></p><h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//关闭线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//是否为Shutdown状态</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//是否为Terminated状态</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//超过超时时间时，会监测ExecutorService是否已经关闭</span></span><br><span class="line">    <span class="comment">//若关闭则返回true，否则返回false。</span></span><br><span class="line">    <span class="comment">//一般情况下会和shutdown方法组合使用。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回一个Future对象，参数接收的是一个Callable的实现</span></span><br><span class="line">    <span class="comment">//Callable接口中的call()方法有一个返回值，可以返回任务的执行结果</span></span><br><span class="line">    <span class="comment">//区别于Runnable接口中的run()方法（void修饰，没有返回值）。</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">    </span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    <span class="comment">//返回一个Future对象，通过返回的Future对象，我们可以检查提交的任务是否执行完成了。 </span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回一个Future的List，其中对应着每个Callable任务执行后的Future对象。</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="comment">//增加了超时控制    </span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="comment">//接收参数是一个Callable的集合，</span></span><br><span class="line">    <span class="comment">//返回的是所有Callable集合任务中某一个任务的执行结果</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="comment">//增加了超时控制</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExecutorService 再Executor接口的基础上扩展了对线程池状态的控制以及提交任务执行的超时控制。线程池的基本功能还不够完善，不能真正的具备处理具体业务的能力（毕竟是个接口，O(∩_∩)O哈哈~）。</p><p>开个篇，慢慢学~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;多线程和并发这两个东西真的是向往已久，总是有一种神秘的感觉，想去探索一波，又担心水平不够无法驾驭。想以读书笔记的方式来写，但是又觉得缺少自己
      
    
    </summary>
    
      <category term="JUC" scheme="http://www.glmapper.com/categories/JUC/"/>
    
    
      <category term="java" scheme="http://www.glmapper.com/tags/java/"/>
    
      <category term="线程" scheme="http://www.glmapper.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="thread" scheme="http://www.glmapper.com/tags/thread/"/>
    
      <category term="并发编程" scheme="http://www.glmapper.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码系列：BeanWrapper</title>
    <link href="http://www.glmapper.com/2018/11/10/springbase12/"/>
    <id>http://www.glmapper.com/2018/11/10/springbase12/</id>
    <published>2018-11-10T06:15:19.000Z</published>
    <updated>2018-11-10T06:15:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>BeanWrapper 是Spring提供的一个用来操作javaBean属性的工具，使用它可以直接修改一个对象的属性。</p><p>对于bean属性的操作，大家熟知的主要有下面这些工具类：</p><ul><li>1.Apache的BeanUtils和PropertyUtils</li><li>2.cglib的BeanMap和BeanCopier</li><li>3.spring的BeanUtils</li></ul><p>Spring中BeanWrapper 的主要功能在于：</p><ul><li>1.支持设置嵌套属性</li><li>2.支持属性值的类型转换（设置ConversionService）</li><li>3.提供分析和操作标准JavaBean的操作：获取和设置属性值（单独或批量），获取属性描述符以及查询属性的可读性/可写性的能力。</li></ul><p>BeanWrapper本身是一个接口，它提供了一整套处理Bean的方法。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanWrapper</span> <span class="keyword">extends</span> <span class="title">ConfigurablePropertyAccessor</span> </span>&#123;</span><br><span class="line"> <span class="comment">//为数组和集合自动增长指定一个限制。在普通的BeanWrapper上默认是无限的。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAutoGrowCollectionLimit</span><span class="params">(<span class="keyword">int</span> autoGrowCollectionLimit)</span></span>;</span><br><span class="line"><span class="comment">//返回数组和集合自动增长的限制。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAutoGrowCollectionLimit</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//如果有的话,返回由此对象包装的bean实例</span></span><br><span class="line"><span class="function">Object <span class="title">getWrappedInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回被包装的JavaBean对象的类型。</span></span><br><span class="line">Class&lt;?&gt; getWrappedClass();</span><br><span class="line"><span class="comment">//获取包装对象的PropertyDescriptors（由标准JavaBeans自省确定）。</span></span><br><span class="line">PropertyDescriptor[] getPropertyDescriptors();</span><br><span class="line"><span class="comment">//获取包装对象的特定属性的属性描述符。</span></span><br><span class="line"><span class="function">PropertyDescriptor <span class="title">getPropertyDescriptor</span><span class="params">(String propertyName)</span> <span class="keyword">throws</span> InvalidPropertyException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的BeanWrapper是基于4.3.6版本的，这个接口在4.1版本之后略有改动。BeanWrapperImpl是BeanWrapper的实现类，BeanWrapperImpl的父类是AbstractNestablePropertyAccessor，通过这个使得BeanWrapper具有处理属性的能力。</p><p>下面是一个使用BeanWrapper 包装对象的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.spring.test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeanWrapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.PropertyAccessorFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.PropertyValue;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BeanWrapper 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanWrapperTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user=<span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">//通过PropertyAccessorFactory将user对象封装成BeanWrapper</span></span><br><span class="line">        BeanWrapper bw=PropertyAccessorFactory.forBeanPropertyAccess(user);</span><br><span class="line">        <span class="comment">//方式一：直接对属性值进行设置</span></span><br><span class="line">        bw.setPropertyValue(<span class="string">"userName"</span>, <span class="string">"张三"</span>);</span><br><span class="line">        <span class="comment">//方式二：通过PropertyValue进行设置</span></span><br><span class="line">        PropertyValue pv=<span class="keyword">new</span> PropertyValue(<span class="string">"userName"</span>,<span class="string">"李四"</span>);</span><br><span class="line">        bw.setPropertyValue(pv);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        System.out.println(user.getUserName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个User类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Spring中，有很多Bean属性的操作都是通过BeanWrapper来完成的，比如常见的HttpServletBean的属性设置就是。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;BeanWrapper 是Spring提供的一个用来操作javaBean属性的工具，使用它可以直接修改一个对象的属性。&lt;/p&gt;
&lt;p&gt;对于bean属性的操作，大家熟知的主要有下面这些工具类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.Apache的BeanUtils和PropertyU
      
    
    </summary>
    
      <category term="spring" scheme="http://www.glmapper.com/categories/spring/"/>
    
    
      <category term="spring" scheme="http://www.glmapper.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码系列：依赖注入（四）-总结</title>
    <link href="http://www.glmapper.com/2018/11/10/springbase11/"/>
    <id>http://www.glmapper.com/2018/11/10/springbase11/</id>
    <published>2018-11-10T06:14:46.000Z</published>
    <updated>2018-11-10T06:15:03.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://juejin.im/post/5a7532746fb9a0633a70d57f" target="_blank" rel="noopener">Spring源码系列：依赖注入（一）getBean</a></li><li><a href="https://juejin.im/post/5a77d6256fb9a063606eb538" target="_blank" rel="noopener">Spring源码系列：依赖注入（二）createBean</a></li><li><a href="https://juejin.im/post/5a7a655d5188257a5d2b1a35" target="_blank" rel="noopener">Spring源码系列：依赖注入（三）-属性注入</a></li></ul><p>在上面三篇文章中对依赖注入做了一个大致的梳理；里面都是大量代码的分析，本文在此基础上进行一个总结归纳。</p><h2 id="依赖注入调用过程"><a href="#依赖注入调用过程" class="headerlink" title="依赖注入调用过程"></a>依赖注入调用过程</h2><p><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616f3c6ef426da7?w=771&amp;h=470&amp;f=png&amp;s=181652" alt=""></p><p>如前几篇文章所述，依赖注入是由getBean来触发的；然后涉及到bean实例的创建、依赖关系的建立、属性注入等子过程。</p><ul><li>getBean 方法触发依赖注入</li><li>doGetBean 从容器中查找Bean（BeanFactory链，当前容器-&gt;双亲容器-双亲容器…）</li></ul><p>当然，在获取到某个Bean的时候也会通过递归的方式来依赖注入依赖的bean</p><ul><li><p>createBeanInstance 生成了Bean所包含的Java对象，Spring中用SimpleInstantiationStrategy类来生成Bean对象的实例，实例化Java对象的方法有两种（CGlib是默认方式）：</p><ul><li>通过BeanUtils，它使用了JVM的反射功能来生成Java对象实例</li><li>用CGLIB来生成，CGLIB是一种常用的字节码生成器的类库</li></ul></li><li><p>populateBean 设置Bean对象的依赖关系</p></li><li>resolveValueIfNecessary 注入类型的处理；解析不同类型的属性</li><li>setPropertyValues 属性注入</li></ul><h2 id="关于lazy-init"><a href="#关于lazy-init" class="headerlink" title="关于lazy-init"></a>关于lazy-init</h2><p>Ioc容器的初始化过程中，主要的工作就是对BeanDefinition的定位、载入、解析和注册；但是就像之前说过的，此时依赖注入还没有发生。在<a href="https://juejin.im/post/5a7532746fb9a0633a70d57f" target="_blank" rel="noopener">Spring源码系列：依赖注入（一）getBean</a>文中提到，依赖注入发生在应用第一次向容器获取Bean的时候；也就是上面说到的通过getBean来触发。</p><p>当然，依赖注入也可以在容器初始化的过程中就完成。这个就是lazy-init属性的存在意义了。就是说我们可以通过设置Bean的lazy-init属性来控制预实例化的过程。</p><p><code>预实例化：在初始化容器时完成Bean的依赖注入</code></p><p>这种做法的好处在于提高了我们第一次获取Bean的的效率，但是它也降低了容器初始化的速度。（这个其实很好理解的，因为第一次获取Bean的时候，依赖注入已经完成了，直接拿过来用就行）</p><p>关于lazy-init属性的处理也是在wac.refresh这个方法中完成的，具体是在finishBeanFactoryInitialization方法中。如果继续追溯的话，最终是交给DefaultListableBeanFactory容器中的preInstantiateSingletons方法中完成。</p><p>lazy-init这种实例化方式就是通过将依赖注入委托给容器来处理，而不是在用户第一向容器申请的Bean的时候完成依赖注入，不同的阶段，也有不同的优劣。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5a7532746fb9a0633a70d57f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring源码系列：依赖注入（一）getBean&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a 
      
    
    </summary>
    
      <category term="spring" scheme="http://www.glmapper.com/categories/spring/"/>
    
    
      <category term="spring" scheme="http://www.glmapper.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码系列：依赖注入（三）-属性注入</title>
    <link href="http://www.glmapper.com/2018/11/10/springbase10/"/>
    <id>http://www.glmapper.com/2018/11/10/springbase10/</id>
    <published>2018-11-10T06:14:10.000Z</published>
    <updated>2018-11-10T06:14:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面文章中对依赖注入的触发和bean的创建做了学习记录，本文将来记录一下bean的属性注入过程。Bean的属性注入发生在<code>BeanDefinitionValueResolver</code>这个类中，<code>BeanDefinitionValueResolver</code>这类是用于bean工厂实现的Helper类，职责就是将bean定义对象中包含的值解析为应用于目标bean实例的实际值。</p><p><code>BeanDefinitionValueResolver</code>类中的<code>resolveValueIfNecessary()</code>方法包含了对所有注入类型的处理。所以本文主要围绕这个方法展开来说。</p><h2 id="resolveValueIfNecessary方法"><a href="#resolveValueIfNecessary方法" class="headerlink" title="resolveValueIfNecessary方法"></a>resolveValueIfNecessary方法</h2><p><code>resolveValueIfNecessary()</code>:给定一个PropertyValue，返回一个value，解析对工厂中其他bean的引用。 value可能是：</p><ul><li>RuntimeBeanReference : 在解析到依赖的Bean的时侯，解析器会依据依赖bean的name创建一个RuntimeBeanReference对像，将这个对像放入BeanDefinition的MutablePropertyValues中。</li><li>ManagedList：用来保存它所管理的List元素，它可以包含运行时期的bean引用(将被解析为bean对象). </li><li>ManagedSet ：用来保存它所管理的set值，它可以包含运行时期的bean引用(将被解析为bean对象) </li><li>ManagedMap ：用来保存它所管理的map值，它可以包含运行时期的bean引用(将被解析为bean对象) </li></ul><p><strong>1、方法申明</strong></p><p>argName ：为其定义的参数的名称</p><p>value   ：要解析的值对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveValueIfNecessary</span><span class="params">(Object argName, Object value)</span></span></span><br></pre></td></tr></table></figure></p><p><strong>2、RuntimeBeanReference</strong></p><p>当在beanfactory中作为另外一个<strong>bean的引用时</strong>，作为属性值对象，将在运行时进行解析。 RuntimeBeanReference是在对BeanDefinition进行解析时生成的数据对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> RuntimeBeanReference) &#123;</span><br><span class="line">    RuntimeBeanReference ref = (RuntimeBeanReference) value;</span><br><span class="line">    <span class="keyword">return</span> resolveReference(argName, ref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>3、RuntimeBeanNameReference</strong></p><p>当在beanfactory中作为另外一个<strong>bean名称的引用时</strong>，作为属性值对象，将在运行时进行解析。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> RuntimeBeanNameReference) &#123;</span><br><span class="line">    String refName = ((RuntimeBeanNameReference) value).getBeanName();</span><br><span class="line">    refName = String.valueOf(doEvaluate(refName));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.beanFactory.containsBean(refName)) &#123;</span><br><span class="line">        <span class="comment">//异常：Invalid bean name '" + refName + "' in bean reference for " + argName</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> refName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>4、BeanDefinitionHolder</strong></p><p>解析BeanDefinitionHolder：包含具有名称和别名的BeanDefinition。BeanDefinitionHolder就是使用名称或者别名来保存BeanDefinition的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> BeanDefinitionHolder) &#123;</span><br><span class="line">    BeanDefinitionHolder bdHolder = (BeanDefinitionHolder) value;</span><br><span class="line">    <span class="keyword">return</span> resolveInnerBean(argName, bdHolder.getBeanName(), bdHolder.getBeanDefinition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>5、BeanDefinition</strong></p><p>解析纯粹的BeanDefinition<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> BeanDefinition) &#123;</span><br><span class="line">    <span class="comment">// Resolve plain BeanDefinition, without contained name: use dummy name.</span></span><br><span class="line">    BeanDefinition bd = (BeanDefinition) value;</span><br><span class="line">    String innerBeanName = <span class="string">"(inner bean)"</span> + BeanFactoryUtils.GENERATED_BEAN_NAME_SEPARATOR +</span><br><span class="line">    ObjectUtils.getIdentityHexString(bd);</span><br><span class="line">    <span class="keyword">return</span> resolveInnerBean(argName, innerBeanName, bd);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>6、ManagedArray</strong></p><p>包含运行时期的bean引用(将被解析为bean对象)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedArray) &#123;</span><br><span class="line">    <span class="comment">// May need to resolve contained runtime references.</span></span><br><span class="line">    ManagedArray array = (ManagedArray) value;</span><br><span class="line">    Class&lt;?&gt; elementType = array.resolvedElementType;</span><br><span class="line">    <span class="keyword">if</span> (elementType == <span class="keyword">null</span>) &#123;</span><br><span class="line">    String elementTypeName = array.getElementTypeName();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(elementTypeName)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        elementType = ClassUtils.forName(elementTypeName,</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.getBeanClassLoader());</span><br><span class="line">        array.resolvedElementType = elementType;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// Improve the message by showing the context.</span></span><br><span class="line">        <span class="comment">//异常：Error resolving array type for " + argName</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    elementType = Object.class;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resolveManagedArray(argName, (List&lt;?&gt;) value, elementType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>7、ManagedList，ManagedSet，ManagedMap</strong></p><p>包含运行时期的bean引用(将被解析为bean对象)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对ManagedList进行解析</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedList) &#123;</span><br><span class="line">    <span class="keyword">return</span> resolveManagedList(argName, (List&lt;?&gt;) value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对ManagedSet进行解析</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedSet) &#123;</span><br><span class="line">    <span class="keyword">return</span> resolveManagedSet(argName, (Set&lt;?&gt;) value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对ManagedMap进行解析</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedMap) &#123;</span><br><span class="line">    <span class="keyword">return</span> resolveManagedMap(argName, (Map&lt;?, ?&gt;) value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>8、ManagedProperties</strong></p><p>ManagedProperties表示的是一个spring管理的属性实例，它支持父/子 definition的合并。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对ManagedProperties进行解析</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedProperties) &#123;</span><br><span class="line">    Properties original = (Properties) value;</span><br><span class="line">    Properties copy = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; propEntry : original.entrySet()) &#123;</span><br><span class="line">    Object propKey = propEntry.getKey();</span><br><span class="line">    Object propValue = propEntry.getValue();</span><br><span class="line">    <span class="keyword">if</span> (propKey <span class="keyword">instanceof</span> TypedStringValue) &#123;</span><br><span class="line">    propKey = evaluate((TypedStringValue) propKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (propValue <span class="keyword">instanceof</span> TypedStringValue) &#123;</span><br><span class="line">    propValue = evaluate((TypedStringValue) propValue);</span><br><span class="line">    &#125;</span><br><span class="line">    copy.put(propKey, propValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>9、TypedStringValue</strong></p><p>TypedStringValue保存的是一个类型的属性值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对TypedStringValue进行解析</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> TypedStringValue) &#123;</span><br><span class="line">    <span class="comment">// Convert value to target type here.</span></span><br><span class="line">    TypedStringValue typedStringValue = (TypedStringValue) value;</span><br><span class="line">    Object valueObject = evaluate(typedStringValue);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; resolvedTargetType = resolveTargetType(typedStringValue);</span><br><span class="line">    <span class="keyword">if</span> (resolvedTargetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.typeConverter.convertIfNecessary(valueObject, resolvedTargetType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> valueObject;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">// Improve the message by showing the context.</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">    <span class="comment">//异常：Error converting typed String value for " + argName</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>10、作为表达式进行评估</strong></p><p>将给定的值作为表达式进行评估。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">    return evaluate(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在完成上述解析之后，已经为我们的依赖注入做好了准备。这是真正把Bean对象设置到它所依赖的另一个Bean的属性中去的地方，可以看到，处理的属性也是各式各样的。具体属性的注入是在之前提到的BeanWrapper接口的实现类BeanWrapperImpl的setPropertyValue方法来完成。</p><h2 id="setPropertyValue方法"><a href="#setPropertyValue方法" class="headerlink" title="setPropertyValue方法"></a>setPropertyValue方法</h2><h3 id="a、方法声明"><a href="#a、方法声明" class="headerlink" title="a、方法声明"></a>a、方法声明</h3><p>这个方法是私有的，是BeanWrapperImpl实际处理的方法，其对外也提供了setPropertyValue的其它重载方法来提供服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setPropertyValue</span><span class="params">(PropertyTokenHolder tokens, PropertyValue pv)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException</span></span><br></pre></td></tr></table></figure><h3 id="b、PropertyTokenHolder是BeanWrapperImpl的内部类"><a href="#b、PropertyTokenHolder是BeanWrapperImpl的内部类" class="headerlink" title="b、PropertyTokenHolder是BeanWrapperImpl的内部类"></a>b、PropertyTokenHolder是BeanWrapperImpl的内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static class PropertyTokenHolder &#123;</span><br><span class="line">    public String canonicalName;</span><br><span class="line">    public String actualName;</span><br><span class="line">    public String[] keys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在setPropertyValue方法中会根据tokens变量是否为null,有两个不同的分支。其中当tokens为null时，则会对属性名进行递归调用分析处理，返回分析处理后的BeanWrapImpl对象nestedBw。如果nestedBw==this,则会设置pv的resolvedTokens属性值，最后将调用nestedBw对象的设置属性值方法设置属性。来具体看看：</p><p><hr></p><h3 id="c、其中当tokens为null时，即对集合类的域进行注入"><a href="#c、其中当tokens为null时，即对集合类的域进行注入" class="headerlink" title="c、其中当tokens为null时，即对集合类的域进行注入"></a>c、其中当tokens为null时，即对集合类的域进行注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置tokens的索引和keys</span></span><br><span class="line">PropertyTokenHolder getterTokens = <span class="keyword">new</span> PropertyTokenHolder();</span><br><span class="line">getterTokens.canonicalName = tokens.canonicalName;</span><br><span class="line">getterTokens.actualName = tokens.actualName;</span><br><span class="line">getterTokens.keys = <span class="keyword">new</span> String[tokens.keys.length - <span class="number">1</span>];</span><br><span class="line">System.arraycopy(tokens.keys, <span class="number">0</span>, getterTokens.keys, <span class="number">0</span>, tokens.keys.length - <span class="number">1</span>);</span><br><span class="line">Object propValue;</span><br><span class="line"><span class="comment">//getPropertyValue用来获取Bean中对对象注入的引用；</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">propValue = getPropertyValue(getterTokens);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NotReadablePropertyException ex) &#123;</span><br><span class="line"><span class="comment">//异常：Cannot access indexed value in property referenced </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1、propValue为null</strong></p><p>propValue为null<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (propValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 空值映射的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.autoGrowNestedPaths) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> cleanup, this is pretty hacky</span></span><br><span class="line">    <span class="keyword">int</span> lastKeyIndex = tokens.canonicalName.lastIndexOf(<span class="string">'['</span>);</span><br><span class="line">    getterTokens.canonicalName = tokens.canonicalName.substring(<span class="number">0</span>, lastKeyIndex);</span><br><span class="line">    propValue = setDefaultValue(getterTokens);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//异常：Cannot access indexed value in property referenced " +</span></span><br><span class="line"><span class="string">"in indexed property path '"</span> + propertyName + <span class="string">"': returned null"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2、对array进行注入</strong></p><p>对array进行注入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (propValue.getClass().isArray()) &#123;</span><br><span class="line">    PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);</span><br><span class="line">    Class requiredType = propValue.getClass().getComponentType();</span><br><span class="line">    <span class="keyword">int</span> arrayIndex = Integer.parseInt(key);</span><br><span class="line">    Object oldValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isExtractOldValueForEditor() &amp;&amp; arrayIndex &lt; Array.getLength(propValue)) &#123;</span><br><span class="line">    oldValue = Array.get(propValue, arrayIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),</span><br><span class="line">    requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));</span><br><span class="line">    Array.set(propValue, arrayIndex, convertedValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">    <span class="comment">//异常：Invalid array index in property path '" + propertyName</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2、对list进行注入</strong></p><p>对list进行注入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (propValue <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">    PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);</span><br><span class="line">    Class requiredType = GenericCollectionTypeResolver.getCollectionReturnType(</span><br><span class="line">    pd.getReadMethod(), tokens.keys.length);</span><br><span class="line">    List list = (List) propValue;</span><br><span class="line">    <span class="keyword">int</span> index = Integer.parseInt(key);</span><br><span class="line">    Object oldValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isExtractOldValueForEditor() &amp;&amp; index &lt; list.size()) &#123;</span><br><span class="line">    oldValue = list.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">    Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),</span><br><span class="line">    requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));</span><br><span class="line">    <span class="keyword">int</span> size = list.size();</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size &amp;&amp; index &lt; <span class="keyword">this</span>.autoGrowCollectionLimit) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &lt; index; i++) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    list.add(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NullPointerException ex) &#123;</span><br><span class="line">        <span class="comment">//异常：InvalidPropertyException</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(convertedValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    list.set(index, convertedValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">    <span class="comment">//异常：Invalid list index in property path '" + propertyName + "'"</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2、对map进行注入</strong></p><p>对map进行注入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (propValue <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">    PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);</span><br><span class="line">    Class mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(</span><br><span class="line">    pd.getReadMethod(), tokens.keys.length);</span><br><span class="line">    Class mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(</span><br><span class="line">    pd.getReadMethod(), tokens.keys.length);</span><br><span class="line">    Map map = (Map) propValue;</span><br><span class="line">    <span class="comment">//重要提示：不要在这里传递完整的属性名称</span></span><br><span class="line">    TypeDescriptor typeDescriptor = (mapKeyType != <span class="keyword">null</span> ?</span><br><span class="line">    TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));</span><br><span class="line">    Object convertedMapKey = convertIfNecessary(<span class="keyword">null</span>, <span class="keyword">null</span>, key, mapKeyType, typeDescriptor);</span><br><span class="line">    Object oldValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isExtractOldValueForEditor()) &#123;</span><br><span class="line">    oldValue = map.get(convertedMapKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在这里传递完整的属性名称和旧值，因为希望对map值有完整的转换能力。</span></span><br><span class="line">    Object convertedMapValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),</span><br><span class="line">    mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));</span><br><span class="line">    map.put(convertedMapKey, convertedMapValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="其中当tokens不为null时，即对非集合类的域进行注入"><a href="#其中当tokens不为null时，即对非集合类的域进行注入" class="headerlink" title="其中当tokens不为null时，即对非集合类的域进行注入"></a>其中当tokens不为null时，即对非集合类的域进行注入</h3><p>这里是核心的地方，取得注入属性的set方法，通过反射机制，把对象注入进去。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Method writeMethod = (pd <span class="keyword">instanceof</span> GenericTypeAwarePropertyDescriptor ?</span><br><span class="line">    ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :</span><br><span class="line">    pd.getWriteMethod());</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的几篇分析我们大概的熟悉了Bean创建和对象依赖注入的一个过程，在这个过程中，spring需要根据Beandefinition中的信息来递归完成依赖注入。并且这些递归的入口都是getBean这个方法。</p><p>一个递归是在上下文体系中查找需要的Bean和创建Bean的递归调用；</p><p>另一个递归是在依赖注入时通过递归调用容器的getBean方法，得到当前Bean的依赖Bean，同时也触发对依赖Bean的创建和注入。</p><p>在对Bean的属性进行依赖注入时解析的过程也是一个递归的过程。这样就可以根据依赖关系，一层一层的完成Bean的创建和注入，直到最后完成当前Bean的创建。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p>《Spring技术内幕》</p></li><li><p><a href="https://www.cnblogs.com/davidwang456/p/4213652.html" target="_blank" rel="noopener">https://www.cnblogs.com/davidwang456/p/4213652.html</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面文章中对依赖注入的触发和bean的创建做了学习记录，本文将来记录一下bean的属性注入过程。Bean的属性注入发生在&lt;code&gt;BeanDefinitionValueResolver&lt;/code&gt;这个类中，&lt;code&gt;BeanDefinitionValueResolve
      
    
    </summary>
    
      <category term="spring" scheme="http://www.glmapper.com/categories/spring/"/>
    
    
      <category term="spring" scheme="http://www.glmapper.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码系列：依赖注入（二）createBean</title>
    <link href="http://www.glmapper.com/2018/11/10/springbase9/"/>
    <id>http://www.glmapper.com/2018/11/10/springbase9/</id>
    <published>2018-11-10T06:13:30.000Z</published>
    <updated>2018-11-10T06:13:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://juejin.im/post/5a7532746fb9a0633a70d57f" target="_blank" rel="noopener">Spring源码系列：依赖注入（一）（AbstractBeanFactory-getBean）</a>最后说道getBean是依赖注入的起点，bean的创建都是通过createBean来完成具体的创建的。createBean的具体实现是在AbstractAutowireCapableBeanFactory中的。本篇就捋一捋这个方法看下bean的创建过程。</p><p>这个方法是AbstractAutowireCapableBeanFactory这个类的中心方法，其作用就是创建一个bean实例，填充bean实例，后置处理等。</p><p>在createBean中主要做了三件事：</p><ul><li>判断需要创建的Bean是否可以实例化，这个类是否可以通过类装载器来载入</li><li>是否配置了后置处理器相关处理（如果配置了则返回一个代理）</li><li>创建Bean</li></ul><p>具体来看方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"><span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line"><span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line"><span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line"><span class="comment">//判断需要创建的Bean是否可以实例化，这个类是否可以通过类装载器来载入</span></span><br><span class="line">Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"><span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare method overrides.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">mbdToUse.prepareMethodOverrides();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="comment">//异常：Validation of method overrides failed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target </span></span><br><span class="line"><span class="comment">//bean instance.</span></span><br><span class="line"><span class="comment">//是否配置了后置处理器相关处理（如果配置了则返回一个代理）</span></span><br><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">//异常:BeanPostProcessor before instantiation of bean failed</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//创建Bean</span></span><br><span class="line">Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中可以看到，创建bean是交给doCreateBean方法来创建的。继续看doCreateBean这个方法：<br>（这里面涉及到一个BeanWrapper这个接口，小伙伴可以移步了解一下《<a href="https://juejin.im/post/5a77f3eb6fb9a06361085451" target="_blank" rel="noopener">Spring源码系列：BeanWrapper</a>》）</p><p><strong>代码 1：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用BeanWrapper来持有创建出来的Bean对象</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//如果是单例的话，则先把缓存中的同名bean清除</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际创建的交给createBeanInstance来完成，</span></span><br><span class="line"><span class="comment">//bean的生成，这里会使用默认的类生成器，包装成BeanWrapperImpl类，</span></span><br><span class="line"><span class="comment">//为了下面的populateBean方法的属性注入做准备  </span></span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line">Class&lt;?&gt; beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br></pre></td></tr></table></figure></p><p><strong>代码 2：</strong> </p><p>允许后处理器修改合并的bean定义。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">//异常：Post-processing of merged bean definition failed</span></span><br><span class="line">    &#125;</span><br><span class="line">    mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>代码 3 ：</strong></p><p>即使被BeanFactoryAware等生命周期接口触发，也要尽快地缓存singletons 以便能够解析循环引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">if (earlySingletonExposure) &#123;</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(&quot;Eagerly caching bean &apos;&quot; + beanName +</span><br><span class="line">&quot;&apos; to allow for resolving potential circular references&quot;);</span><br><span class="line">&#125;</span><br><span class="line">addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public Object getObject() throws BeansException &#123;</span><br><span class="line">return getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>代码 4:</strong></p><p>这里是对bean的初始化的地方，一般情况下依赖注入就在这里发生；这个exposedObject变量保存的是在初始化处理完以后返回的作为依赖注入完成之后的bean。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">//抛出</span></span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException)</span><br><span class="line">    ex).getBeanName())) &#123;</span><br><span class="line"><span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//异常:Initialization of bean failed</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>代码 5:</strong></p><p>这里是注册bean<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line">catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">    //异常处理</span><br><span class="line">&#125;</span><br><span class="line">//返回结果</span><br><span class="line">return exposedObject;</span><br></pre></td></tr></table></figure></p><p>上面的5个代码段均是doCreateBean中的处理逻辑，有兴趣的小伙伴可以自行查阅源码。从上面的代码中我们依然没有得到具体创建的过程，因为在doCreateBean中又依赖：<code>createBeanInstance</code>和<code>populateBean</code>两个方法。</p><p>在<code>createBeanInstance</code>中生成了Bean所包含的java对象。来看是怎么生成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 确保bean类实际上已经解析过了，可以实例化</span></span><br><span class="line">Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line"><span class="comment">//异常：Bean class isn't public, and non-public access not allowed:beanName</span></span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">//1. 使用工厂方法来进行bean的实例化</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>)  &#123;</span><br><span class="line"><span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新创建相同的bean时快捷方式...</span></span><br><span class="line"><span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">resolved = <span class="keyword">true</span>;</span><br><span class="line">autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (resolved) &#123;</span><br><span class="line"><span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.需要确定构造函数...,使用构造函数进行bean实例化</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.没有特殊的处理：只需使用无参数构造函数。（默认构造函数）</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面这段代码可以看出，对象的生成有许多不同的方式，有通过工厂的，也有通过容器的autowire特性生成的。当然这些生成方式都是由相关的BeanDefinition来指定的。</p><p><strong>Spring中配置Bean的方式我们常用的一种是通过xml文件来配置，还有就是通过注解的方式来配置</strong>。</p><ul><li><strong>demo1</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.glmapper.test.User"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"glmapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>       </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式，通过class提供的权限定名，spring就可以利用反射机制创建这个bean。</p><ul><li><strong>demo2</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.glmapper.test.UserFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getUser"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"glmapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>           </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种是利用静态工厂方法来创建的，提供的class并非是类的权限定名， 而是静态工厂的全类名；除此之外还需要指定获取bean的方法（此处是getUser）和参数（参数是glmapper）。</p><ul><li><strong>demo3</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userFactory&quot; class=&quot;com.glmapper.test.UserInstanceFactory&quot;&gt;</span><br><span class="line">    &lt;!--用一个集合来保存我当前的对象实例--&gt;</span><br><span class="line">    &lt;property name=&quot;map&quot;&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=&quot;user1&quot;&gt;</span><br><span class="line">                &lt;bean class=&quot;com.glmapper.test.User&quot;&gt;</span><br><span class="line">                    &lt;property name=&quot;name&quot; value=&quot;glmapper1&quot;&gt;&lt;/property&gt;        </span><br><span class="line">                &lt;/bean&gt;</span><br><span class="line">            &lt;/entry&gt;    </span><br><span class="line"></span><br><span class="line">            &lt;entry key=&quot;user2&quot;&gt;</span><br><span class="line">                &lt;bean class=&quot;com.glmapper.test.User&quot;&gt;</span><br><span class="line">                    &lt;property name=&quot;name&quot; value=&quot;glmapper2&quot;&gt;&lt;/property&gt;   </span><br><span class="line">                &lt;/bean&gt;</span><br><span class="line">            &lt;/entry&gt;</span><br><span class="line">        &lt;/map&gt;  </span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"> &lt;/bean&gt;</span><br><span class="line"> </span><br><span class="line"> //实例1</span><br><span class="line"> &lt;bean id=&quot;user1&quot; factory-bean=&quot;userFactory&quot; factory-method=&quot;getUserInstance&quot;&gt;</span><br><span class="line">    &lt;constructor-arg value=&quot;user1&quot;&gt;&lt;/constructor-arg&gt;           </span><br><span class="line"> &lt;/bean&gt;</span><br><span class="line">//实例2</span><br><span class="line"> &lt;bean id=&quot;user2&quot; factory-bean=&quot;userFactory&quot; factory-method=&quot;getUserInstance&quot;&gt;</span><br><span class="line">    &lt;constructor-arg value=&quot;user2&quot;&gt;&lt;/constructor-arg&gt;           </span><br><span class="line"> &lt;/bean</span><br></pre></td></tr></table></figure><p>这种方式和静态工厂的区别在于我们需要先实例化一个工厂对象，然后才能使用这个工厂对象来创建我们的bean。getUserInstance通过key值来获取我们已经实例化好的对象（当然方式有很多，此处以map来举个例子）。<code>关于注解的和使用FactoryBean接口的这里就暂时不说，后期再聊</code></p><p>OK，继续来分钟，上面说到的是以工厂方法创建bean，具体的源码有点长，这里就不放了，大概思路就如上面所提到的那几种方式。接下来看下常见的使用instantiateBean方式（使用它的默认构造函数）来构建bean的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object beanInstance;</span><br><span class="line"><span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//获取系统安全接口。</span></span><br><span class="line">    <span class="comment">//如果已经为当前应用程序建立了安全管理器，则返回该安全管理器; </span></span><br><span class="line">    <span class="comment">//否则，返回null。</span></span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">beanInstance = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">&#125;</span><br><span class="line">BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line"><span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">//异常：Instantiation of bean failed</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，上面的创建都是通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br></pre></td></tr></table></figure><p>这样一段代码来完成的，是的，这里已经快接近真相了。从语义上来分析，先是获取了一种策略，然后利用当前获取的策略再去执行实例化。OK，我们看下getInstantiationStrategy()拿到的是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回实例化策略用于创建bean实例。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> InstantiationStrategy <span class="title">getInstantiationStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.instantiationStrategy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认的实例化测试是使用CGLIB代理</span></span><br><span class="line"><span class="keyword">private</span> InstantiationStrategy instantiationStrategy = <span class="keyword">new</span> CglibSubclassingInstantiationStrategy();</span><br></pre></td></tr></table></figure><p>看到这里我们清楚了，默认构造函数的情况下，在spring中会使用Cglib来进行bean的实例化（关于cglib此处不再赘述）。我们看下CglibSubclassingInstantiationStrategy这个类的申明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibSubclassingInstantiationStrategy</span> <span class="keyword">extends</span> <span class="title">SimpleInstantiationStrategy</span></span></span><br></pre></td></tr></table></figure><p>它继承自SimpleInstantiationStrategy ，这个又是什么鬼呢？</p><p><code>SimpleInstantiationStrategy是Spring用来生成Bean对象的默认类，在这个类中提供了两种实例化java对象的方法，一种是基于java自身反射机制的BeanUtils，还有一种就是基于Cglib</code>。</p><p>如何创建的就不说了；到这里createBeanInstance就说完了（Bean已经创建了）；但是仅仅是创建，spring还没有处理它们，比如说bean对象的属性，依赖关系等等。这些就是上面提到的另外一个方法populateBean；</p><p>这个方法其实就做了一件事：<strong>使用bean定义中的属性值在给定的BeanWrapper中填充bean实例。</strong>分段来看：<br>下面这段代码是先将BeanDefinition中设置的property值封装成PropertyValues，然后检测我们的BeanWrapper是否为Null，如果为null则抛出异常或者跳过当前空实例赋值阶段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取到BeanDefinition中设置的property值，封装成PropertyValues</span></span><br><span class="line">PropertyValues pvs = mbd.getPropertyValues();</span><br><span class="line"><span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line"><span class="comment">//异常：Cannot apply property values to null instance</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面这段代码的意思是给任何InstantiationAwareBeanPostProcessors提供在设置属性之前修改bean状态的机会。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">    <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">    continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面就是对具体注入方式的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理autowire的注入；可以根据bean的名称和类型来注入</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">    MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 则根据名称添加基于自动装配的属性值。</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">    autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据类型添加基于自动装配的属性值。</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">    autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pvs = newPvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个判断条件，在满足的情况下做的处理分别是：</p><ul><li>在工厂将给定属性值应用到给定的bean后，对其进行后处理。 允许检查所有的依赖关系是否被满足，例如基于bean属性设置器上的“Required”注解。还允许替换要应用的属性值，通常通过创建基于原始PropertyValues的新MutablePropertyValues实例，添加或删除特定值。</li><li>执行依赖性检查    </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回这个工厂是否拥有一个InstantiationAwareBeanPostProcessor</span></span><br><span class="line"><span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line"><span class="comment">//返回依赖检查代码。</span></span><br><span class="line"><span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line"><span class="comment">//从给定的BeanWrapper中提取一组已过滤的PropertyDescriptors，</span></span><br><span class="line"><span class="comment">//不包括在被忽略的依赖性接口上定义的被忽略的依赖类型或属性（译注）。</span></span><br><span class="line">PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">        InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">        pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是对属性进行注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applyPropertyValues(beanName, mbd, bw, pvs);</span><br></pre></td></tr></table></figure><p>这个方法描述的是对属性进行解析然后注入的过程；先来分析下applyPropertyValues的申明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(String beanName</span></span></span><br><span class="line"><span class="function"><span class="params">, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span></span></span><br></pre></td></tr></table></figure></p><ul><li>beanName bean名称</li><li>mbd 合并的bean definition</li><li>bw 包装目标对象的BeanWrapper</li><li>pvs 新的属性值</li></ul><p>代码分段来看：</p><ul><li><p>参数验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pvs == <span class="keyword">null</span> || pvs.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>pvs参数处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">    mpvs = (MutablePropertyValues) pvs;</span><br><span class="line">    <span class="keyword">if</span> (mpvs.isConverted()) &#123;</span><br><span class="line">    <span class="comment">// 使用预先转换后的值。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    bw.setPropertyValues(mpvs);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">    <span class="comment">//异常：Error setting property values</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    original = mpvs.getPropertyValueList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>valueResolver来解析BeanDefinition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionValueResolver valueResolver = </span><br><span class="line"><span class="keyword">new</span> BeanDefinitionValueResolver(<span class="keyword">this</span>, beanName, mbd, converter);</span><br></pre></td></tr></table></figure></li><li><p>为解析值创建一个副本，注入到bean中的是副本的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a deep copy, resolving any references for values.</span></span><br><span class="line">List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> ArrayList&lt;PropertyValue&gt;(original.size());</span><br></pre></td></tr></table></figure></li><li><p>遍历处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> resolveNecessary = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line">    <span class="comment">//返回此持有者是否已经包含转换后的值（true），还是需要转换值（false）。</span></span><br><span class="line">    <span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">    deepCopy.add(pv);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    String propertyName = pv.getName();</span><br><span class="line">    Object originalValue = pv.getValue();</span><br><span class="line">    <span class="comment">//看下面的注释resolveValueIfNecessary</span></span><br><span class="line">    Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">    Object convertedValue = resolvedValue;</span><br><span class="line">    <span class="keyword">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">    !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line">    <span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">    convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可能将转换的值存储在合并的bean定义中，以避免为每个创建的bean实例重新转换。</span></span><br><span class="line">    <span class="keyword">if</span> (resolvedValue == originalValue) &#123;</span><br><span class="line">    <span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">    pv.setConvertedValue(convertedValue);</span><br><span class="line">    &#125;</span><br><span class="line">    deepCopy.add(pv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue &amp;&amp;</span><br><span class="line">    !((TypedStringValue) originalValue).isDynamic() &amp;&amp;</span><br><span class="line">    !(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;</span><br><span class="line">    pv.setConvertedValue(convertedValue);</span><br><span class="line">    deepCopy.add(pv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    resolveNecessary = <span class="keyword">true</span>;</span><br><span class="line">    deepCopy.add(<span class="keyword">new</span> PropertyValue(pv, convertedValue));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>resolveValueIfNecessary</p><p>  给定一个PropertyValue，返回一个value，必要时解析对工厂中其他bean的引用。value可以是：</p><ul><li>一个BeanDefinition，它导致创建一个相应的新的bean实例。 Singleton标志和这样的”inner beans”的名字被忽略：内部beans是匿名原型。</li><li>RuntimeBeanReference(必须解析)</li><li>ManagedList</li><li>ManagedSet</li><li>ManagedMap</li><li>一个普通的对象或null，在这种情况下，它是孤立的。</li></ul></li></ul><p>下面这段代码时依赖注入发生的地方，其实际上是在BeanWrapperImpl中来完成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    bw.setPropertyValues(<span class="keyword">new</span> MutablePropertyValues(deepCopy));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">    <span class="comment">//异常：Error setting property values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面说到spring是通过BeanDefinitionValueResolver来解析BeanDefinition的，然后再注入到property中，关于这个过程在下一篇中来说。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;a href=&quot;https://juejin.im/post/5a7532746fb9a0633a70d57f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring源码系列：依赖注入（一）（AbstractBeanFactory-getBean）
      
    
    </summary>
    
      <category term="spring" scheme="http://www.glmapper.com/categories/spring/"/>
    
    
      <category term="spring" scheme="http://www.glmapper.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码系列：依赖注入（一）getBean</title>
    <link href="http://www.glmapper.com/2018/11/10/springbase8/"/>
    <id>http://www.glmapper.com/2018/11/10/springbase8/</id>
    <published>2018-11-10T06:12:44.000Z</published>
    <updated>2018-11-10T06:13:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://juejin.im/post/5a6eff066fb9a01cbb3963a9" target="_blank" rel="noopener">Spring源码系列：BeanFactory的创建</a>文章中我们谈到了BeanFactory这容器，这个里面提供了注入的实现接口。其具体的实现还需要从AbstractBeanFactory和DefaultListableBeanFactory中来看。今天就先撸一下AbstractBeanFactory这个类中的getBean这个方法。</p><p><strong>1、getBean方法</strong></p><p>getBean提供了四个重载方法，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过name获取Bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过name和类型获取Bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> doGetBean(name, requiredType, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过name和对象参数获取Bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, args, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过name、类型和参数获取Bean</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> doGetBean(name, requiredType, args, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从这四个重载方法的方法体中可以看出，他们都是通过doGetBean来实现的。所以doGetBean其实才是真正获取Bean的地方，也是触发依赖注入发生的地方。（这个方法比较长，分段来说）</p><p><strong>2、doGetBean</strong></p><p>先来看下方法的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br></pre></td></tr></table></figure><ul><li>name 要检索的bean的名称</li><li>requiredType 要检索的bean所需的类型</li><li>args 使用显式参数创建bean实例时使用的参数（仅在创建新实例时应用，而不是在检索现有实例时应用）</li><li>typeCheckOnly 是否为类型检查而获得实例，而不是实际使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回bean名称，剥离工厂引用前缀，并将别名解析为规范名称。</span></span><br><span class="line"><span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line"><span class="comment">//声明当前需要返回的bean对象</span></span><br><span class="line">Object bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先从缓存中获取bean，处理已经被创建的单例模式的bean，</span></span><br><span class="line"><span class="comment">//对于此类bean的请求不需要重复的创建(singleton)</span></span><br><span class="line">Object sharedInstance = getSingleton(beanName);</span><br></pre></td></tr></table></figure><p>如果当前获取到的sharedInstance不为null并且参数为空，则进行FactoryBean的相关处理，并获取FactoryBean的处理结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    <span class="comment">//返回指定的singleton bean是否正在创建（在整个工厂内）。</span></span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">logger.debug(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> </span><br><span class="line">+ beanName +<span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完成FactoryBean的相关处理，并用来获取FactoryBean的处理结果</span></span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果当前获取到的sharedInstance为null，我们再来看下做了哪些处理（下面的都在一个大的else里面）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//分解到下面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在当前线程中，返回指定的prototype bean是否正在创建。</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这段的作用是对Ioc容器中的BeanDefinition是否存在进行检测，先是检测当前BeanFactory中是否能够获取到，如果取不到则继续到双亲容器中进行尝试获取，如果双亲还是取不到，则继续向上一级父容器中尝试获取。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查该工厂是否存在bean定义。</span></span><br><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line"><span class="comment">// 如果没有，则继续检查父类</span></span><br><span class="line">String nameToLookup = originalBeanName(name);</span><br><span class="line"><span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 用明确的参数代表父项。</span></span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果没有args - &gt;委托给标准的getBean方法。</span></span><br><span class="line"><span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将指定的bean标记为已经创建（或即将创建）；这里允许bean工厂优化其缓存以重复创建指定的bean。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先根据beanName来获取BeanDefinition，然后获取当前bean的所有依赖bean，这里是通过递归调用getBean来完成，直到没有任何依赖的bean为止。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="comment">//检查给定的合并bean定义，可能抛出验证异常。</span></span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"><span class="comment">// 保证当前bean依赖的bean的初始化。</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line"><span class="comment">//递归处理依赖bean</span></span><br><span class="line">getBean(dep);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面这段就是创建一个bean实例；这里通过调用getSingleton方法来创建一个单例bean实例；从代码中可以看到，getSingleton的调用是通过getObject这个回调函数来间接调用createBean完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line"><span class="comment">//回调函数getObject</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建bean</span></span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">//发生异常则销毁</span></span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//获取给定bean实例的对象，无论是bean实例本身，还是FactoryBean创建的对象。</span></span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是创建prototype bean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">    Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    beforePrototypeCreation(beanName);</span><br><span class="line">    <span class="comment">//创建prototype bean</span></span><br><span class="line">    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">    afterPrototypeCreation(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后是对创建的bean进行类型检查，没有问题就返回已经创建好的bean；此时这个bean是包含依赖关系的bean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">return getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">&#125;</span><br><span class="line">catch (TypeMismatchException ex) &#123;</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(&quot;Failed to convert bean &apos;&quot; + name + &quot;&apos; to required type &apos;&quot; +</span><br><span class="line">ClassUtils.getQualifiedName(requiredType) + &quot;&apos;&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//返回bean</span><br><span class="line">return (T) bean;</span><br></pre></td></tr></table></figure><p>getBean是依赖注入的起点，从上面的分析可以看出，bean的创建都是通过createBean来完成具体的创建的。createBean的具体实现是在AbstractAutowireCapableBeanFactory中的，这里createBean不仅仅负责创建bean，还需要完成对bean的初始化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;a href=&quot;https://juejin.im/post/5a6eff066fb9a01cbb3963a9&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring源码系列：BeanFactory的创建&lt;/a&gt;文章中我们谈到了BeanFactor
      
    
    </summary>
    
      <category term="spring" scheme="http://www.glmapper.com/categories/spring/"/>
    
    
      <category term="spring" scheme="http://www.glmapper.com/tags/spring/"/>
    
  </entry>
  
</feed>
