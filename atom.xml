<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>glmapper</title>
  
  <subtitle>大家都喊我磊叔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.glmapper.com/"/>
  <updated>2019-12-09T01:09:31.102Z</updated>
  <id>http://www.glmapper.com/</id>
  
  <author>
    <name>GuoLei Song</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot 系列-启动过程分析</title>
    <link href="http://www.glmapper.com/2019/12/07/springboot-series-started/"/>
    <id>http://www.glmapper.com/2019/12/07/springboot-series-started/</id>
    <published>2019-12-07T07:04:28.000Z</published>
    <updated>2019-12-09T01:09:31.102Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>微信公众号：<strong><a href="#jump_10">glmapper工作室</a></strong><br>掘金专栏：<a href="https://juejin.im/user/58fcc0768d6d810058965a06" target="_blank" rel="noopener">glmapper</a><br>微          博：<a href="https://weibo.com/u/2412872703" target="_blank" rel="noopener">疯狂的石头_henu</a><br>欢迎关注，一起学习、一起分享</p></blockquote><p>SpringBoot 作为目前非常流行的微服务框架，它使得构建独立的 Spring 生产级应用变得非常简单，因此受到很多互联网企业的青睐。</p><p>最近在写 <a href="https://github.com/sofastack/sofa-tracer" target="_blank" rel="noopener">SOFATracer</a> 集成 Spring Cloud Stream RocketMQ 的过程中，遇到了一些问题，比如：BeanPostProcessor 不生效，如何在 BeanPostProcessor 不生效的情况下去修改一个 Bean 等，这些问题其实都是和 Bean 的生命周期有关系的，当然也和容器启动的过程有关系。SpringBoot 的启动过程对于我来说其实不算陌生，也可以说是比较熟悉，但是之前没有完整的梳理过这一款的东西，再实际的应用过程成难免再去踩一些坑。另外想到之前也写过一篇 <a href="http://www.glmapper.com/2019/12/08/springboot-series-fatjar/">SpringBoot系列- FatJar 启动原理</a>，刚好承接上篇，继续来探索 SpringBoot 中的一些知识点。</p><blockquote><p>注：本篇基于 SpringBoot 2.1.0.RELEASE 版本，SpringBoot 各个版本之间可能存在差异，不过大体流程基本差不多，所以各位看官在实际的工作过程中也</p></blockquote><h2 id="启动入口"><a href="#启动入口" class="headerlink" title="启动入口"></a>启动入口</h2><p>在这篇<a href="http://www.glmapper.com/2019/12/08/springboot-series-fatjar/">SpringBoot系列- FatJar 启动原理</a> 文章中介绍得到，JarLaunch 最后是构建了一个 MainMethodRunner 实例对象，然后通过反射的方式调用了 BootStrap 类中的 main 方法，这里的 ’BootStrap 类中的 main 方法‘ 实际上就是 SpringBoot 的业务入口，也就是常见的下面的代码片段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(GlmapperApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从代码可以非常直观的了解到，启动是通过调用 SpringApplication 的静态方法 run；这个 run 方法内部其实是会构造一个 SpringApplication 的实例，然后再调用这里实例的 run 方法来启动 SpringBoot的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Static helper that can be used to run a &#123;<span class="doctag">@link</span> SpringApplication&#125; from the</span></span><br><span class="line"><span class="comment">* specified sources using default settings and user supplied arguments.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> primarySources the primary sources to load</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args the application arguments (usually passed from a Java main method)</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the running &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources,</span></span></span><br><span class="line"><span class="function"><span class="params">    String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，如果要分析 SpringBoot 的启动过程，我们需要熟悉 SpringApplication 的构造过程以及 SpringApplication 的 run 方法执行过程即可。</p><h2 id="SpringApplication-实例的构建"><a href="#SpringApplication-实例的构建" class="headerlink" title="SpringApplication 实例的构建"></a>SpringApplication 实例的构建</h2><p>篇幅原因，我们只分析核心的构建流程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 资源加载器，默认是 null</span></span><br><span class="line">    <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    <span class="comment">// 启动类 bean </span></span><br><span class="line">    Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    <span class="comment">// 是否是 web 应用</span></span><br><span class="line">    <span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="comment">// 设置了 ApplicationContextInitializer</span></span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">            ApplicationContextInitializer.class));</span><br><span class="line">    <span class="comment">// 设置 ApplicationListener</span></span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    <span class="comment">// 启动类</span></span><br><span class="line">    <span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码段中，需要关注两个点：</p><ul><li>1、初始化 ApplicationContextInitializer；</li><li>2、初始化 ApplicationListener</li></ul><p>要注意的是这里的实例化，并非是通过注解和扫包完成，而是通过一种不依赖 Spring 上下文的加载方法；这种做法是为了能够使得在 Spring 完成启动前做各种配置。Spring 的解决方法是以接口的全限定名作为 key，实现类的全限定名作为 value 记录在项目的 META-INF/spring.factories 文件中，然后通过SpringFactoriesLoader 工具类提供静态方法进行类加载并缓存下来，spring.factories 是Spring Boot 的核心配置文件。SpringFactoriesLoader 可以理解为 Spring 自己提供的一种 spi 扩展实现。SpringBoot 中提供的默认的 spring.factories 配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># PropertySource Loaders</span><br><span class="line">org.springframework.boot.env.PropertySourceLoader=\</span><br><span class="line">// ..省略</span><br><span class="line"></span><br><span class="line"># Run Listeners</span><br><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">// ..省略</span><br><span class="line"></span><br><span class="line"># Error Reporters</span><br><span class="line">org.springframework.boot.SpringBootExceptionReporter=\</span><br><span class="line">// ..省略</span><br><span class="line"></span><br><span class="line"># Application Context Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\/</span><br><span class="line">// ..省略</span><br><span class="line"></span><br><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">// ..省略</span><br><span class="line"></span><br><span class="line"># Environment Post Processors</span><br><span class="line">org.springframework.boot.env.EnvironmentPostProcessor=\</span><br><span class="line">// ..省略</span><br><span class="line"></span><br><span class="line"># Failure Analyzers</span><br><span class="line">org.springframework.boot.diagnostics.FailureAnalyzer=\</span><br><span class="line">// ..省略</span><br><span class="line"></span><br><span class="line"># FailureAnalysisReporters</span><br><span class="line">org.springframework.boot.diagnostics.FailureAnalysisReporter=\</span><br><span class="line">// ..省略</span><br></pre></td></tr></table></figure></p><p>关于 SpringFactoriesLoader  如何加载这些资源这里就不过多分析，有兴趣的读者可以自行查看相关源码。<a href="">org.springframework.core.io.support.SpringFactoriesLoader#loadSpringFactories</a></p><h2 id="run-方法主流程"><a href="#run-方法主流程" class="headerlink" title="run 方法主流程"></a>run 方法主流程</h2><p>这里先直观的看下代码，然后再逐个分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开启容器启动计时</span></span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// SpringBootExceptionReporter 列表，SpringBoot 允许自定义 Reporter</span></span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 设置java.awt.headless属性为true还是false</span></span><br><span class="line">    <span class="comment">// 可详见解释：https://blog.csdn.net/michaelgo/article/details/81634017</span></span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    <span class="comment">// 获取所有 SpringApplicationRunListener ，也是通过 SpringFactoriesLoader 来获取的</span></span><br><span class="line">    SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">    <span class="comment">// 发布 starting 事件，在首次启动 run方法时立即调用，可用于非常早的初始化，注意此时容器上下文还没有刷新</span></span><br><span class="line">    listeners.starting();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 构建 ApplicationArguments 对象</span></span><br><span class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">                args);</span><br><span class="line">        <span class="comment">// 准备上下文刷新需要的环境属性 -- 详见 prepareEnvironment 过程分析</span></span><br><span class="line">        ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">                applicationArguments);</span><br><span class="line">        <span class="comment">// spring.beaninfo.ignore，如果为空设置为true</span></span><br><span class="line">        configureIgnoreBeanInfo(environment);</span><br><span class="line">        <span class="comment">// 打印 SpringBoot 启动 Banner</span></span><br><span class="line">        Banner printedBanner = printBanner(environment);</span><br><span class="line">        <span class="comment">// 创建上下文，这里会根据 webApplicationType 类型来创建不同的 ApplicationContext</span></span><br><span class="line">        context = createApplicationContext();</span><br><span class="line">        <span class="comment">// 加载获取 exceptionReporters</span></span><br><span class="line">        exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">                SpringBootExceptionReporter.class,</span><br><span class="line">                <span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">        <span class="comment">// 上下文刷新之前的准备工作 -- 详见 prepareContext 过程分析</span></span><br><span class="line">        prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">                printedBanner);</span><br><span class="line">        <span class="comment">// 刷新上下文 -- 详见 refreshContext 过程分析</span></span><br><span class="line">        refreshContext(context);</span><br><span class="line">        <span class="comment">// 刷新之后回调，SpringBoot 中这个方法是空实现，可以自行扩展</span></span><br><span class="line">        afterRefresh(context, applicationArguments);</span><br><span class="line">        <span class="comment">// 停止计时</span></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">                    .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发布 started 事件 </span></span><br><span class="line">        listeners.started(context);</span><br><span class="line">        <span class="comment">// ApplicationRunner 和 CommandLineRunner 调用</span></span><br><span class="line">        callRunners(context, applicationArguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 发布 running 事件 </span></span><br><span class="line">        listeners.running(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面对代码基本都做了一些简单的注释，有几个需要关注的点：</p><ul><li>1、prepareEnvironment 的处理过程</li><li>2、prepareContext 的处理过程</li><li>3、refreshContext 的处理过程</li><li>4、listeners 执行时机及顺序</li><li>5、异常处理逻辑</li></ul><p>关于 Listeners 执行时机及顺序在之前的文章中有做过非常详细的分析，详见：<a href="http://www.glmapper.com/2019/04/13/springboot-series-event/">SpringBoot 系列-事件机制详解</a>。下面就对其他的 4 个点做下详细的分析。</p><blockquote><p>分析启动过程，本质上是对其整个容器生命周期有个了解，包括 listeners 执行各个事件的时机、PostProcessor 执行的时机，Enviroment Ready 的时机等等。掌握这些扩展和时机，可以在实际的业务开发中来做很多事情。</p></blockquote><h3 id="prepareEnvironment-的处理过程"><a href="#prepareEnvironment-的处理过程" class="headerlink" title="prepareEnvironment 的处理过程"></a>prepareEnvironment 的处理过程</h3><p>prepareEnvironment 过程相对来说是比较早的，这里主要就是为上下文刷新提供 Environment。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableEnvironment <span class="title">prepareEnvironment</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">ApplicationArguments applicationArguments)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create and configure the environment</span></span><br><span class="line">    ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">    <span class="comment">// 配置 PropertySources 和 Profiles</span></span><br><span class="line">    <span class="comment">// 1、将参数和一些默认的属性配置到 environment</span></span><br><span class="line">    <span class="comment">// 2、激活 profiles </span></span><br><span class="line">    configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">    <span class="comment">// 发布 ApplicationEnvironmentPreparedEvent 事件</span></span><br><span class="line">    listeners.environmentPrepared(environment);</span><br><span class="line">    <span class="comment">// 绑定 SpringApplication 环境</span></span><br><span class="line">    bindToSpringApplication(environment);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isCustomEnvironment) &#123;</span><br><span class="line">        environment = <span class="keyword">new</span> EnvironmentConverter(getClassLoader())</span><br><span class="line">                .convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 附加的解析器将动态跟踪底层 Environment 属性源的任何添加或删除</span></span><br><span class="line">    ConfigurationPropertySources.attach(environment);</span><br><span class="line">    <span class="keyword">return</span> environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面做的事情就是将我们的配置，包括系统配置、application.properties、-D 参数等等统统打包给 environment。在 Spring 中，我们最常见的 xml 中使用的 ${xxx} 或者代码中使用的 @Value(“${xxxx}”) 等，最后都是从 environment 中拿值的。</p><p>这里需要关注的一个比较重要的点是<strong>发布 ApplicationEnvironmentPreparedEvent 事件</strong>，我们可以通过监听这个事件来<strong>修改 environment</strong>。这里可以参考下 SOFATracer 中 <a href="https://github.com/sofastack/sofa-tracer/blob/master/tracer-sofa-boot-starter/src/main/java/com/alipay/sofa/tracer/boot/listener/SofaTracerConfigurationListener.java" target="_blank" rel="noopener">SofaTracerConfigurationListener</a> 是如何利用这个事件来做环境配置处理的。</p><h3 id="prepareContext-的处理过程"><a href="#prepareContext-的处理过程" class="headerlink" title="prepareContext 的处理过程"></a>prepareContext 的处理过程</h3><p>prepareContext 的处理过程中可以利用的点是非常多的，比如 ApplicationContextInitializer 的执行、ApplicationContextInitializedEvent 和 ApplicationPreparedEvent 事件发布。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置 environment 给 context，所以需要注意的是，在此之前拿到的 context 中，environment 是没有的。</span></span><br><span class="line">    context.setEnvironment(environment);</span><br><span class="line">    <span class="comment">// 对 ApplicationContext 的后置处理，比如注册 BeanNameGenerator 和 ResourceLoader</span></span><br><span class="line">    postProcessApplicationContext(context);</span><br><span class="line">    <span class="comment">// 这里开始执行所有的 ApplicationContextInitializer</span></span><br><span class="line">    applyInitializers(context);</span><br><span class="line">    <span class="comment">// 发布 ApplicationContextInitializedEvent 事件</span></span><br><span class="line">    listeners.contextPrepared(context);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">        logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line">        logStartupProfileInfo(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add boot specific singleton beans</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">    beanFactory.registerSingleton(<span class="string">"springApplicationArguments"</span>, applicationArguments);</span><br><span class="line">    <span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">"springBootBanner"</span>, printedBanner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">        <span class="comment">// 是否允许 bean 覆盖，这里如果是 false ,则可能会导致 BeanDefinitionOverrideException 异常</span></span><br><span class="line">        ((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">                .setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Load the sources</span></span><br><span class="line">    Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">    Assert.notEmpty(sources, <span class="string">"Sources must not be empty"</span>);</span><br><span class="line">    <span class="comment">// 加载 beans 到 application context. （BeanDefinition）</span></span><br><span class="line">    load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">    <span class="comment">// 发布 ApplicationPreparedEvent 事件</span></span><br><span class="line">    listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationContextInitializer 是 spring 容器刷新之前初始化 Spring ConfigurableApplicationContext 的回调接口，ApplicationContextInitializer 的 initialize 方法执行之前，context 是还没有刷新的。可以看到在 applyInitializers 之后紧接着发布了 ApplicationContextInitializedEvent 事件。其实这两个点都可以对 context 搞一些事情，ApplicationContextInitializer 更纯粹些，它只关注 context；而 ApplicationContextInitializedEvent 事件源中除了 context 之外，还有 springApplication 对象和参数 args。</p><p>prepareContext 最后阶段是发布了 ApplicationPreparedEvent 事件，表示上下文已经准备好了，可以随时执行 refresh 了。</p><h3 id="refreshContext-的处理过程"><a href="#refreshContext-的处理过程" class="headerlink" title="refreshContext 的处理过程"></a>refreshContext 的处理过程</h3><h3 id="异常处理逻辑"><a href="#异常处理逻辑" class="headerlink" title="异常处理逻辑"></a>异常处理逻辑</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;&lt;a href=&quot;#jump_10&quot;&gt;glmapper工作室&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;掘金专栏：&lt;a href=&quot;https://juejin.im/user/58fcc0768d6d810058965a06&quot; 
      
    
    </summary>
    
      <category term="springboot" scheme="http://www.glmapper.com/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://www.glmapper.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 系列-FatJar 启动原理</title>
    <link href="http://www.glmapper.com/2019/10/13/springboot-series-fatjar/"/>
    <id>http://www.glmapper.com/2019/10/13/springboot-series-fatjar/</id>
    <published>2019-10-13T14:55:41.000Z</published>
    <updated>2019-12-09T01:09:46.304Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>微信公众号：<strong><a href="#jump_10">glmapper工作室</a></strong><br>掘金专栏：<a href="https://juejin.im/user/58fcc0768d6d810058965a06" target="_blank" rel="noopener">glmapper</a><br>微          博：<a href="https://weibo.com/u/2412872703" target="_blank" rel="noopener">疯狂的石头_henu</a><br>欢迎关注，一起学习、一起分享</p></blockquote><p>之前有写过一篇文章来介绍 JAR 文件和 MENIFEST.MF 文件，详见：<a href="https://juejin.im/post/5d16cc8cf265da1b8d163237" target="_blank" rel="noopener">聊一聊 JAR 文件和 MANIFEST.MF</a>，在这篇文章中介绍了 JAR 文件的内部结构。本篇将继续延续前面的节奏，来介绍下，在 SpringBoot 中，是如何将一个 FatJar 运行起来的。</p><h2 id="FatJar-解压之后的文件目录"><a href="#FatJar-解压之后的文件目录" class="headerlink" title="FatJar 解压之后的文件目录"></a>FatJar 解压之后的文件目录</h2><p>从 <a href="https://start.spring.io/" target="_blank" rel="noopener">Spring 官网</a> 或者通过 Idea 创建一个新的 SpringBoot 工程，方便起见，建议什么依赖都不加，默认带入的空的 SpringBoot 工程即可。</p><p>通过 maven 命令进行打包，打包成功之后得到的构建产物截图如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/11/11/16e5a74d591ef623?w=519&amp;h=232&amp;f=png&amp;s=74986" alt=""></p><p>在前面的文章中有提到，jar 包是zip 包的一种变种，因此也可以通过 unzip 来解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -q guides-for-jarlaunch-0.0.1-SNAPSHOT.jar -d mock</span><br></pre></td></tr></table></figure><p>解压的 mock 目录，使用 tree 指令，看到整个解压之后的 FatJar 的目录结构如下（部分省略）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── BOOT-INF</span><br><span class="line">│   ├── classes</span><br><span class="line">│   │   ├── application.properties  # 用户-配置文件</span><br><span class="line">│   │   └── com</span><br><span class="line">│   │       └── glmapper</span><br><span class="line">│   │           └── bridge</span><br><span class="line">│   │               └── boot</span><br><span class="line">│   │                   └── BootStrap.class  # 用户-启动类</span><br><span class="line">│   └── lib</span><br><span class="line">│       ├── jakarta.annotation-api-1.3.5.jar</span><br><span class="line">│       ├── jul-to-slf4j-1.7.28.jar</span><br><span class="line">│       ├── log4j-xxx.jar # 表示 log4j 相关的依赖简写</span><br><span class="line">│       ├── logback-xxx.jar # 表示 logback 相关的依赖简写</span><br><span class="line">│       ├── slf4j-api-1.7.28.jar</span><br><span class="line">│       ├── snakeyaml-1.25.jar</span><br><span class="line">│       ├── spring-xxx.jar   # 表示 spring 相关的依赖简写</span><br><span class="line">├── META-INF</span><br><span class="line">│   ├── MANIFEST.MF</span><br><span class="line">│   └── maven</span><br><span class="line">│       └── com.glmapper.bridge.boot</span><br><span class="line">│           └── guides-for-jarlaunch</span><br><span class="line">│               ├── pom.properties</span><br><span class="line">│               └── pom.xml</span><br><span class="line">└── org</span><br><span class="line">    └── springframework</span><br><span class="line">        └── boot</span><br><span class="line">            └── loader</span><br><span class="line">                ├── ExecutableArchiveLauncher.class</span><br><span class="line">                ├── JarLauncher.class</span><br><span class="line">                ├── LaunchedURLClassLoader$UseFastConnectionExceptionsEnumeration.class</span><br><span class="line">                ├── LaunchedURLClassLoader.class</span><br><span class="line">                ├── Launcher.class</span><br><span class="line">                ├── MainMethodRunner.class</span><br><span class="line">                ├── PropertiesLauncher$1.class</span><br><span class="line">                ├── PropertiesLauncher$ArchiveEntryFilter.class</span><br><span class="line">                ├── PropertiesLauncher$PrefixMatchingArchiveFilter.class</span><br><span class="line">                ├── PropertiesLauncher.class</span><br><span class="line">                ├── WarLauncher.class</span><br><span class="line">                ├── archive</span><br><span class="line">                │   ├── # 省略</span><br><span class="line">                ├── data</span><br><span class="line">                │   ├── # 省略</span><br><span class="line">                ├── jar</span><br><span class="line">                │   ├── # 省略</span><br><span class="line">                └── util</span><br><span class="line">                    └── SystemPropertyUtils.class</span><br></pre></td></tr></table></figure><p>简单来看，FatJar 解压之后包括三个文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── BOOT-INF # 存放的是业务相关的，包括业务开发的类和配置文件，以及依赖的jar</span><br><span class="line">│   ├── classes</span><br><span class="line">│   └── lib</span><br><span class="line">├── META-INF # 包括 MANIFEST.MF 描述文件和 maven 的构建信息</span><br><span class="line">│   ├── MANIFEST.MF</span><br><span class="line">│   └── maven</span><br><span class="line">└── org # SpringBoot 相关的类</span><br><span class="line">    └── springframework</span><br></pre></td></tr></table></figure><p>我们平时在 debug SpringBoot 工程的启动流程时，一般都是从 SpringApplication#run 方法开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootStrap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 入口</span></span><br><span class="line">        SpringApplication.run(BootStrap.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 java 程序来说，我们知道启动入口必须有 main 函数，这里看起来是符合条件的，但是有一点就是，通过 java 指令执行一个带有 main 函数的类时，是不需要有 -jar 参数的，比如新建一个 BootStrap.java 文件，内容为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootStrap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过 javac 编译此文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac BootStrap.java</span><br></pre></td></tr></table></figure></p><p>然后就可以得到编译之后的 .class 文件 BootStrap.class ，此时可以通过 java 指令直接执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java BootStrap  <span class="comment"># 输出 Hello World</span></span><br></pre></td></tr></table></figure></p><p>那么对于 java -jar 呢？这个其实在 <a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html" target="_blank" rel="noopener">java 的官方文档</a> 中是有明确描述的：</p><ul><li>-jar filename</li></ul><blockquote><p>Executes a program encapsulated in a JAR file. The filename argument is the name of a JAR file with a manifest that contains a line in the form Main-Class:classname that defines the class with the public static void main(String[] args) method that serves as your application’s starting point.</p></blockquote><blockquote><p>When you use the -jar option, the specified JAR file is the source of all user classes, and other class path settings are ignored.</p></blockquote><p>简单说就是，java -jar 命令引导的具体启动类必须配置在 MANIFEST.MF 资源的 Main-Class 属性中。</p><p>那回过头再去看下之前打包好、解压之后的文件目录，找到 /META-INF/MANIFEST.MF 文件，看下元数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Implementation-Title: guides-for-jarlaunch</span><br><span class="line">Implementation-Version: 0.0.1-SNAPSHOT</span><br><span class="line">Start-Class: com.glmapper.bridge.boot.BootStrap</span><br><span class="line">Spring-Boot-Classes: BOOT-INF/classes/</span><br><span class="line">Spring-Boot-Lib: BOOT-INF/lib/</span><br><span class="line">Build-Jdk-Spec: 1.8</span><br><span class="line">Spring-Boot-Version: 2.2.0.RELEASE</span><br><span class="line">Created-By: Maven Archiver 3.4.0</span><br><span class="line"># Main-Class 在这里，指向的是 JarLauncher</span><br><span class="line">Main-Class: org.springframework.boot.loader.JarLauncher</span><br></pre></td></tr></table></figure><p>org.springframework.boot.loader.JarLauncher 类存放在 org/springframework/boot/loader 下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">└── boot</span><br><span class="line">    └── loader</span><br><span class="line">        ├── ExecutableArchiveLauncher.class</span><br><span class="line">        ├── JarLauncher.class  # JarLauncher</span><br><span class="line">        ├── # 省略</span><br></pre></td></tr></table></figure><p>这样就基本理清楚了， FatJar 中，org.springframework.boot.loader 下面的类负责引导启动 SpringBoot 工程，作为入口，BOOT-INF 中存放业务代码和依赖，META-INF 下存在元数据描述。</p><h2 id="JarLaunch-FatJar-的启动器"><a href="#JarLaunch-FatJar-的启动器" class="headerlink" title="JarLaunch - FatJar 的启动器"></a>JarLaunch - FatJar 的启动器</h2><p>在分析 JarLaunch 之前，这里插一下，org.springframework.boot.loader 下的这些类是如何被打包在 FatJar 里面的</p><h3 id="spring-boot-maven-plugin-打包-spring-boot-loader-过程"><a href="#spring-boot-maven-plugin-打包-spring-boot-loader-过程" class="headerlink" title="spring-boot-maven-plugin 打包 spring-boot-loader 过程"></a>spring-boot-maven-plugin 打包 spring-boot-loader 过程</h3><p>因为在新建的空的 SpringBoot 工程中并没有任何地方显示的引入或者编写相关的类。实际上，对于每个新建的 SpringBoot 工程，可以在其 pom.xml 文件中看到如下插件：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这个是 SpringBoot 官方提供的用于打包 FatJar 的插件，org.springframework.boot.loader 下的类其实就是通过这个插件打进去的；</p><p>下面是此插件将 loader 相关类打入 FatJar 的一个执行流程：</p><blockquote><p>org.springframework.boot.maven#execute-&gt;<br>org.springframework.boot.maven#repackage -&gt; org.springframework.boot.loader.tools.Repackager#repackage-&gt;<br>org.springframework.boot.loader.tools.Repackager#writeLoaderClasses-&gt;<br>org.springframework.boot.loader.tools.JarWriter#writeLoaderClasses</p></blockquote><p>最终的执行方法就是下面这个方法，通过注释可以看出，该方法的作用就是将 spring-boot-loader 的classes 写入到 FatJar 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Write the required spring-boot-loader classes to the JAR.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException if the classes cannot be written</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLoaderClasses</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">writeLoaderClasses(NESTED_LOADER_JAR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JarLaunch-基本原理"><a href="#JarLaunch-基本原理" class="headerlink" title="JarLaunch 基本原理"></a>JarLaunch 基本原理</h3><p>基于前面的分析，这里考虑一个问题，能否直接通过 java BootStrap 来直接运行 SpringBoot 工程呢？这样在不需要 -jar 参数和 JarLaunch 引导的情况下，直接使用最原始的 java 指令理论上是不是也可以，因为有 main 方法。</p><h4 id="通过-java-BootStrap-方式启动"><a href="#通过-java-BootStrap-方式启动" class="headerlink" title="通过 java BootStrap 方式启动"></a>通过 <code>java BootStrap</code> 方式启动</h4><p>BootStrap 类的如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootStrap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(BootStrap.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后，执行 <code>java com.glmapper.bridge.boot.BootStrap</code>，然后抛出异常了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: org/springframework/boot/SpringApplication</span><br><span class="line">        at com.glmapper.bridge.boot.BootStrap.main(BootStrap.java:13)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: org.springframework.boot.SpringApplication</span><br><span class="line">        at java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class="line">        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338)</span><br><span class="line">        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">        ... 1 more</span><br></pre></td></tr></table></figure><p>从异常堆栈来看，是因为找不到 SpringApplication 这个类；这里其实还是比较好理解的，BootStrap 类中引入了 SpringApplication，但是这个类是在 BOOT-INF/lib 下的，而 java 指令在启动时也没有指定 class path 。</p><blockquote><p>这里不再赘述，通过 -classpath + -Xbootclasspath 的方式尝试了下，貌似也不行，如果有通过 java 指令直接运行成功的，欢迎留言沟通。</p></blockquote><h4 id="通过-java-JarLaunch-启动"><a href="#通过-java-JarLaunch-启动" class="headerlink" title="通过 java JarLaunch 启动"></a>通过 <code>java JarLaunch 启动</code></h4><p>再通过 <code>java org.springframework.boot.loader.JarLauncher</code> 方式启动，可以看到是可以的。</p><p><img src="https://user-gold-cdn.xitu.io/2019/11/11/16e5b0890224d5f5?w=2718&amp;h=594&amp;f=png&amp;s=457239" alt=""></p><p>那这里基本可以猜到，JarLauncher 方式启动时，一定会通过某种方式将所需要依赖的 JAR 文件作为 BootStrap 的依赖引入进来。下面就来简单分析下 JarLauncher 启动时，作为启动引导类，它做了哪些事情。</p><h4 id="基本原理分析"><a href="#基本原理分析" class="headerlink" title="基本原理分析"></a>基本原理分析</h4><p>JarLaunch 类的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JarLauncher</span> <span class="keyword">extends</span> <span class="title">ExecutableArchiveLauncher</span> </span>&#123;</span><br><span class="line">    <span class="comment">// BOOT-INF/classes/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String BOOT_INF_CLASSES = <span class="string">"BOOT-INF/classes/"</span>;</span><br><span class="line">    <span class="comment">// BOOT-INF/lib/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String BOOT_INF_LIB = <span class="string">"BOOT-INF/lib/"</span>;</span><br><span class="line">    <span class="comment">// 空构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JarLauncher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 带有指定 Archive 的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">JarLauncher</span><span class="params">(Archive archive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(archive);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否是可嵌套的对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isNestedArchive</span><span class="params">(Archive.Entry entry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.isDirectory()) &#123;</span><br><span class="line">    <span class="keyword">return</span> entry.getName().equals(BOOT_INF_CLASSES);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> entry.getName().startsWith(BOOT_INF_LIB);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// main 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> JarLauncher().launch(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过代码，我们很明显可以看到几个关键的信息点：</p><ul><li><code>BOOT_INF_CLASSES</code> 和 <code>BOOT_INF_LIB</code>  两个常量对应的是前面解压之后的两个文件目录</li><li>JarLaunch 中包含一个 main 函数，作为启动入口</li></ul><p>但是单从 main 来看，只是构造了一个 JarLaunch 对象，然后执行其 launch 方法，并没有我们期望看到的构建所需依赖的地方。实际上这部分是在 JarLaunch 的父类 ExecutableArchiveLauncher 的构造函数中来完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutableArchiveLauncher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 构建 archive </span></span><br><span class="line">    <span class="keyword">this</span>.archive = createArchive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建 Archive</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Archive <span class="title">createArchive</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ProtectionDomain protectionDomain = getClass().getProtectionDomain();</span><br><span class="line">    CodeSource codeSource = protectionDomain.getCodeSource();</span><br><span class="line">    URI location = (codeSource != <span class="keyword">null</span>) ? codeSource.getLocation().toURI() : <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 这里就是拿到当前的 classpath </span></span><br><span class="line">    <span class="comment">// /Users/xxx/Documents/test/glmapper-springboot-study-guides/guides-for-jarlaunch/target/mock/</span></span><br><span class="line">    String path = (location != <span class="keyword">null</span>) ? location.getSchemeSpecificPart() : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable to determine code source archive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    File root = <span class="keyword">new</span> File(path);</span><br><span class="line">    <span class="keyword">if</span> (!root.exists()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable to determine code source archive from "</span> + root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建 Archive </span></span><br><span class="line">    <span class="keyword">return</span> (root.isDirectory() ? <span class="keyword">new</span> ExplodedArchive(root) : <span class="keyword">new</span> JarFileArchive(root));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PS: 关于 Archive 的概念这里由于篇幅有限，不再展开说明。</p></blockquote><p>通过上面构建了一个 Archive ，然后继续执行 launch 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 注册协议，利用了 java.net.URLStreamHandler 的扩展机制，SpringBoot</span></span><br><span class="line">    <span class="comment">// 扩展出了一种可以解析 jar in jar 的协议</span></span><br><span class="line">    JarFile.registerUrlProtocolHandler();</span><br><span class="line">    <span class="comment">// 通过 classpath 来构建一个 ClassLoader</span></span><br><span class="line">    ClassLoader classLoader = createClassLoader(getClassPathArchives());</span><br><span class="line">    <span class="comment">// launch </span></span><br><span class="line">    launch(args, getMainClass(), classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面值需要关注下 getMainClass() 方法即可，这里就是获取 MENIFEST.MF 中指定的 Start-Class ，实际上就是我们的工程里面的 BootStrap 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getMainClass</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 从 archive 中拿到 Manifest</span></span><br><span class="line">    Manifest manifest = <span class="keyword">this</span>.archive.getManifest();</span><br><span class="line">    String mainClass = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (manifest != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取 Start-Class</span></span><br><span class="line">    mainClass = manifest.getMainAttributes().getValue(<span class="string">"Start-Class"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mainClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">    <span class="string">"No 'Start-Class' manifest entry specified in "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 mainClass</span></span><br><span class="line">    <span class="keyword">return</span> mainClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终是通过构建了一个 MainMethodRunner 实例对象，然后通过反射的方式调用了 BootStrap 类中的 main 方法：</p><p><img src="https://user-gold-cdn.xitu.io/2019/11/11/16e5b26a4615f6c9?w=1754&amp;h=356&amp;f=png&amp;s=460314" alt=""></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要从 JarLaunch 的角度分析了下 SpringBoot 的启动方式，对常规 java 方式和 java -jar 等启动方式进行了简单的演示；同时简单阐述了下 JarLaunch 启动的基本工作原理。对于其中 构建 Archive 、自定义协议 Handler 等未做深入探究，后面也会针对相关点再做单独分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;&lt;a href=&quot;#jump_10&quot;&gt;glmapper工作室&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;掘金专栏：&lt;a href=&quot;https://juejin.im/user/58fcc0768d6d810058965a06&quot; 
      
    
    </summary>
    
      <category term="springboot" scheme="http://www.glmapper.com/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://www.glmapper.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 系列-内嵌 Tomcat 的实现原理解析</title>
    <link href="http://www.glmapper.com/2019/10/06/springboot-series-server-tomcat/"/>
    <id>http://www.glmapper.com/2019/10/06/springboot-series-server-tomcat/</id>
    <published>2019-10-06T07:57:26.000Z</published>
    <updated>2019-12-08T16:00:51.530Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个 SpringBoot web 工程来说，一个主要的依赖标志就是有 spring-boot-starter-web 这个 starter ，spring-boot-starter-web 模块在 spring boot 中其实并没有代码存在，只是在 pom.xml 中携带了一些依赖，包括 web、webmvc、tomcat 等：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Spring Boot 默认的 web 服务容器是 tomcat ，如果想使用 Jetty 等来替换 Tomcat ，可以自行参考官方文档来解决。</p></blockquote><p>web、webmvc、tomcat 等提供了 web 应用的运行环境，那 spring-boot-starter 则是让这些运行环境工作的开关（因为 spring-boot-starter 中会间接引入 spring-boot-autoconfigure ）。</p><h2 id="WebServer-自动配置"><a href="#WebServer-自动配置" class="headerlink" title="WebServer 自动配置"></a>WebServer 自动配置</h2><p>在 spring-boot-autoconfigure 模块中，有处理关于 WebServer 的自动配置类 ServletWebServerFactoryAutoConfiguration 。</p><h3 id="ServletWebServerFactoryAutoConfiguration"><a href="#ServletWebServerFactoryAutoConfiguration" class="headerlink" title="ServletWebServerFactoryAutoConfiguration"></a>ServletWebServerFactoryAutoConfiguration</h3><p>代码片段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(ServletRequest.class)</span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span>(type = Type.SERVLET)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(ServerProperties.class)</span><br><span class="line"><span class="meta">@Import</span>(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,</span><br><span class="line">ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,</span><br><span class="line">ServletWebServerFactoryConfiguration.EmbeddedJetty.class,</span><br><span class="line">ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletWebServerFactoryAutoConfiguration</span></span></span><br></pre></td></tr></table></figure><p><br></p><p>两个 Condition 表示当前运行环境是基于 servlet 标准规范的 web 服务：</p><ul><li>ConditionalOnClass(ServletRequest.class) ： 表示当前必须有 servlet-api 依赖存在</li><li>ConditionalOnWebApplication(type = Type.SERVLET) ：仅基于servlet的Web应用程序</li></ul><p>@EnableConfigurationProperties(ServerProperties.class)：ServerProperties 配置中包括了常见的 server.port 等配置属性。</p><p>通过 <a href="#">@Import</a> 导入嵌入式容器相关的自动配置类，有 EmbeddedTomcat、EmbeddedJetty 和EmbeddedUndertow。</p><p><strong>综合来看，ServletWebServerFactoryAutoConfiguration 自动配置类中主要做了以下几件事情：</strong></p><ul><li>导入了内部类 BeanPostProcessorsRegistrar，它实现了 ImportBeanDefinitionRegistrar，可以实现ImportBeanDefinitionRegistrar 来注册额外的 BeanDefinition。</li><li>导入了 ServletWebServerFactoryConfiguration.EmbeddedTomcat 等嵌入容器先关配置（我们主要关注tomcat 相关的配置）。</li><li>注册了ServletWebServerFactoryCustomizer、TomcatServletWebServerFactoryCustomizer 两个WebServerFactoryCustomizer 类型的 bean。</li></ul><p>下面就针对这几个点，做下详细的分析。</p><h3 id="BeanPostProcessorsRegistrar"><a href="#BeanPostProcessorsRegistrar" class="headerlink" title="BeanPostProcessorsRegistrar"></a>BeanPostProcessorsRegistrar</h3><p>BeanPostProcessorsRegistrar 这个内部类的代码如下(省略了部分代码)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanPostProcessorsRegistrar</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略代码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注册 WebServerFactoryCustomizerBeanPostProcessor</span></span><br><span class="line">        registerSyntheticBeanIfMissing(registry,</span><br><span class="line">                                       <span class="string">"webServerFactoryCustomizerBeanPostProcessor"</span>,</span><br><span class="line">                                       WebServerFactoryCustomizerBeanPostProcessor.class);</span><br><span class="line">        <span class="comment">// 注册 errorPageRegistrarBeanPostProcessor</span></span><br><span class="line">        registerSyntheticBeanIfMissing(registry,</span><br><span class="line">                                       <span class="string">"errorPageRegistrarBeanPostProcessor"</span>,</span><br><span class="line">                                       ErrorPageRegistrarBeanPostProcessor.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码中，注册了两个 bean，一个 WebServerFactoryCustomizerBeanPostProcessor，一个 errorPageRegistrarBeanPostProcessor；这两个都实现类 BeanPostProcessor 接口，属于 bean 的后置处理器，作用是在 bean 初始化前后加一些自己的逻辑处理。</p><ul><li>WebServerFactoryCustomizerBeanPostProcessor：作用是在 WebServerFactory 初始化时调用上面自动配置类注入的那些 WebServerFactoryCustomizer ，然后调用 WebServerFactoryCustomizer 中的 customize 方法来 处理 WebServerFactory。</li><li>errorPageRegistrarBeanPostProcessor：和上面的作用差不多，不过这个是处理 ErrorPageRegistrar 的。</li></ul><p>下面简单看下 WebServerFactoryCustomizerBeanPostProcessor 中的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebServerFactoryCustomizerBeanPostProcessor</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">BeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在 postProcessBeforeInitialization 方法中，如果当前 bean 是 WebServerFactory，则进行</span></span><br><span class="line">    <span class="comment">// 一些后置处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> WebServerFactory) &#123;</span><br><span class="line">postProcessBeforeInitialization((WebServerFactory) bean);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 这段代码就是拿到所有的 Customizers ，然后遍历调用这些 Customizers 的 customize 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postProcessBeforeInitialization</span><span class="params">(WebServerFactory webServerFactory)</span> </span>&#123;</span><br><span class="line">LambdaSafe</span><br><span class="line">.callbacks(WebServerFactoryCustomizer.class, getCustomizers(),</span><br><span class="line">webServerFactory)</span><br><span class="line">.withLogger(WebServerFactoryCustomizerBeanPostProcessor.class)</span><br><span class="line">.invoke((customizer) -&gt; customizer.customize(webServerFactory));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动配置类中注册的两个-Customizer-Bean"><a href="#自动配置类中注册的两个-Customizer-Bean" class="headerlink" title="自动配置类中注册的两个 Customizer Bean"></a>自动配置类中注册的两个 Customizer Bean</h2><p>这两个 Customizer 实际上就是去处理一些配置值，然后绑定到 各自的工厂类的。</p><h3 id="WebServerFactoryCustomizer"><a href="#WebServerFactoryCustomizer" class="headerlink" title="WebServerFactoryCustomizer"></a>WebServerFactoryCustomizer</h3><p>将 serverProperties 配置值绑定给 ConfigurableServletWebServerFactory 对象实例上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableServletWebServerFactory factory)</span> </span>&#123;</span><br><span class="line">    PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();</span><br><span class="line">    <span class="comment">// 端口</span></span><br><span class="line">    map.from(<span class="keyword">this</span>.serverProperties::getPort).to(factory::setPort);</span><br><span class="line">    <span class="comment">// address</span></span><br><span class="line">    map.from(<span class="keyword">this</span>.serverProperties::getAddress).to(factory::setAddress);</span><br><span class="line">    <span class="comment">// contextPath</span></span><br><span class="line">    map.from(<span class="keyword">this</span>.serverProperties.getServlet()::getContextPath)</span><br><span class="line">        .to(factory::setContextPath);</span><br><span class="line">    <span class="comment">// displayName</span></span><br><span class="line">    map.from(<span class="keyword">this</span>.serverProperties.getServlet()::getApplicationDisplayName)</span><br><span class="line">        .to(factory::setDisplayName);</span><br><span class="line">    <span class="comment">// session 配置</span></span><br><span class="line">    map.from(<span class="keyword">this</span>.serverProperties.getServlet()::getSession).to(factory::setSession);</span><br><span class="line">    <span class="comment">// ssl</span></span><br><span class="line">    map.from(<span class="keyword">this</span>.serverProperties::getSsl).to(factory::setSsl);</span><br><span class="line">    <span class="comment">// jsp</span></span><br><span class="line">    map.from(<span class="keyword">this</span>.serverProperties.getServlet()::getJsp).to(factory::setJsp);</span><br><span class="line">    <span class="comment">// 压缩配置策略实现</span></span><br><span class="line">    map.from(<span class="keyword">this</span>.serverProperties::getCompression).to(factory::setCompression);</span><br><span class="line">    <span class="comment">// http2 </span></span><br><span class="line">    map.from(<span class="keyword">this</span>.serverProperties::getHttp2).to(factory::setHttp2);</span><br><span class="line">    <span class="comment">// serverHeader</span></span><br><span class="line">    map.from(<span class="keyword">this</span>.serverProperties::getServerHeader).to(factory::setServerHeader);</span><br><span class="line">    <span class="comment">// contextParameters</span></span><br><span class="line">    map.from(<span class="keyword">this</span>.serverProperties.getServlet()::getContextParameters)</span><br><span class="line">        .to(factory::setInitParameters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TomcatServletWebServerFactoryCustomizer"><a href="#TomcatServletWebServerFactoryCustomizer" class="headerlink" title="TomcatServletWebServerFactoryCustomizer"></a>TomcatServletWebServerFactoryCustomizer</h3><p>相比于上面那个，这个 customizer 主要处理 Tomcat 相关的配置值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(TomcatServletWebServerFactory factory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拿到 tomcat 相关的配置</span></span><br><span class="line">    ServerProperties.Tomcat tomcatProperties = <span class="keyword">this</span>.serverProperties.getTomcat();</span><br><span class="line">    <span class="comment">// server.tomcat.additional-tld-skip-patterns</span></span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(tomcatProperties.getAdditionalTldSkipPatterns())) &#123;</span><br><span class="line">        factory.getTldSkipPatterns()</span><br><span class="line">            .addAll(tomcatProperties.getAdditionalTldSkipPatterns());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// server.redirectContextRoot</span></span><br><span class="line">    <span class="keyword">if</span> (tomcatProperties.getRedirectContextRoot() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        customizeRedirectContextRoot(factory,</span><br><span class="line">                                     tomcatProperties.getRedirectContextRoot());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// server.useRelativeRedirects</span></span><br><span class="line">    <span class="keyword">if</span> (tomcatProperties.getUseRelativeRedirects() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        customizeUseRelativeRedirects(factory,</span><br><span class="line">                                      tomcatProperties.getUseRelativeRedirects());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebServerFactory"><a href="#WebServerFactory" class="headerlink" title="WebServerFactory"></a>WebServerFactory</h2><p>用于创建 WebServer 的工厂的标记接口。</p><h3 id="类体系结构"><a href="#类体系结构" class="headerlink" title="类体系结构"></a>类体系结构</h3><p><img src="https://user-gold-cdn.xitu.io/2019/10/6/16da00f895344262?w=1492&amp;h=606&amp;f=png&amp;s=218086" alt=""></p><p>上图为 WebServerFactory -&gt; TomcatServletWebServerFactory 的整个类结构关系。</p><h3 id="TomcatServletWebServerFactory"><a href="#TomcatServletWebServerFactory" class="headerlink" title="TomcatServletWebServerFactory"></a>TomcatServletWebServerFactory</h3><p>TomcatServletWebServerFactory 是用于获取 Tomcat 作为 WebServer 的工厂类实现，其中最核心的方法就是 getWebServer，获取一个 WebServer 对象实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebServer <span class="title">getWebServer</span><span class="params">(ServletContextInitializer... initializers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 Tomcat 实例</span></span><br><span class="line">    Tomcat tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line">    <span class="comment">// 创建一个 Tomcat 实例工作空间目录</span></span><br><span class="line">    File baseDir = (<span class="keyword">this</span>.baseDirectory != <span class="keyword">null</span>) ? <span class="keyword">this</span>.baseDirectory</span><br><span class="line">        : createTempDir(<span class="string">"tomcat"</span>);</span><br><span class="line">    tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">    <span class="comment">// 创建连接对象</span></span><br><span class="line">    Connector connector = <span class="keyword">new</span> Connector(<span class="keyword">this</span>.protocol);</span><br><span class="line">    tomcat.getService().addConnector(connector);</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    customizeConnector(connector);</span><br><span class="line">    tomcat.setConnector(connector);</span><br><span class="line">    tomcat.getHost().setAutoDeploy(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 配置 Engine，没有什么实质性的操作，可忽略</span></span><br><span class="line">    configureEngine(tomcat.getEngine());</span><br><span class="line">    <span class="comment">// 一些附加链接，默认是 0 个</span></span><br><span class="line">    <span class="keyword">for</span> (Connector additionalConnector : <span class="keyword">this</span>.additionalTomcatConnectors) &#123;</span><br><span class="line">        tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    prepareContext(tomcat.getHost(), initializers);</span><br><span class="line">    <span class="comment">// 返回 webServer</span></span><br><span class="line">    <span class="keyword">return</span> getTomcatWebServer(tomcat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1、customizeConnector ： 给 Connector 设置 port、protocolHandler、uriEncoding 等。Connector 构造的逻辑主要是在NIO和APR选择中选择一个协议，然后反射创建实例并强转为 ProtocolHandler</li><li>2、prepareContext 这里并不是说准备当前 Tomcat 运行环境的上下文信息，而是准备一个 StandardContext ，也就是准备一个 web app。</li></ul><h3 id="准备-Web-App-Context-容器"><a href="#准备-Web-App-Context-容器" class="headerlink" title="准备 Web App Context 容器"></a>准备 Web App Context 容器</h3><p>对于 Tomcat 来说，每个 context 就是映射到 一个 web app 的，所以 prepareContext 做的事情就是将 web 应用映射到一个 TomcatEmbeddedContext ，然后加入到 Host 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(Host host, ServletContextInitializer[] initializers)</span> </span>&#123;</span><br><span class="line">    File documentRoot = getValidDocumentRoot();</span><br><span class="line">    <span class="comment">// 创建一个 TomcatEmbeddedContext 对象</span></span><br><span class="line">    TomcatEmbeddedContext context = <span class="keyword">new</span> TomcatEmbeddedContext();</span><br><span class="line">    <span class="keyword">if</span> (documentRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">        context.setResources(<span class="keyword">new</span> LoaderHidingResourceRoot(context));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置描述此容器的名称字符串。在属于特定父项的子容器集内，容器名称必须唯一。</span></span><br><span class="line">    context.setName(getContextPath());</span><br><span class="line">    <span class="comment">// 设置此Web应用程序的显示名称。</span></span><br><span class="line">    context.setDisplayName(getDisplayName());</span><br><span class="line">    <span class="comment">// 设置 webContextPath  默认是   /</span></span><br><span class="line">    context.setPath(getContextPath());</span><br><span class="line">    File docBase = (documentRoot != <span class="keyword">null</span>) ? documentRoot</span><br><span class="line">        : createTempDir(<span class="string">"tomcat-docbase"</span>);</span><br><span class="line">    context.setDocBase(docBase.getAbsolutePath());</span><br><span class="line">    <span class="comment">// 注册一个FixContextListener监听，这个监听用于设置context的配置状态以及是否加入登录验证的逻辑</span></span><br><span class="line">    context.addLifecycleListener(<span class="keyword">new</span> FixContextListener());</span><br><span class="line">    <span class="comment">// 设置 父 ClassLoader</span></span><br><span class="line">    context.setParentClassLoader(</span><br><span class="line">        (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span>) ? <span class="keyword">this</span>.resourceLoader.getClassLoader()</span><br><span class="line">        : ClassUtils.getDefaultClassLoader());</span><br><span class="line">    <span class="comment">// 覆盖Tomcat的默认语言环境映射以与其他服务器对齐。</span></span><br><span class="line">    resetDefaultLocaleMapping(context);</span><br><span class="line">    <span class="comment">// 添加区域设置编码映射（请参阅Servlet规范2.4的5.4节）</span></span><br><span class="line">    addLocaleMappings(context);</span><br><span class="line">    <span class="comment">// 设置是否使用相对地址重定向</span></span><br><span class="line">    context.setUseRelativeRedirects(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        context.setCreateUploadTargets(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchMethodError ex) &#123;</span><br><span class="line">        <span class="comment">// Tomcat is &lt; 8.5.39. Continue.</span></span><br><span class="line">    &#125;</span><br><span class="line">    configureTldSkipPatterns(context);</span><br><span class="line">    <span class="comment">// 设置 WebappLoader ，并且将 父 classLoader 作为构建参数</span></span><br><span class="line">    WebappLoader loader = <span class="keyword">new</span> WebappLoader(context.getParentClassLoader());</span><br><span class="line">    <span class="comment">// 设置 WebappLoader 的 loaderClass 值</span></span><br><span class="line">    loader.setLoaderClass(TomcatEmbeddedWebappClassLoader.class.getName());</span><br><span class="line">    <span class="comment">// 会将加载类向上委托</span></span><br><span class="line">    loader.setDelegate(<span class="keyword">true</span>);</span><br><span class="line">    context.setLoader(loader);</span><br><span class="line">    <span class="keyword">if</span> (isRegisterDefaultServlet()) &#123;</span><br><span class="line">        addDefaultServlet(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否注册 jspServlet</span></span><br><span class="line">    <span class="keyword">if</span> (shouldRegisterJspServlet()) &#123;</span><br><span class="line">        addJspServlet(context);</span><br><span class="line">        addJasperInitializer(context);</span><br><span class="line">    &#125;</span><br><span class="line">    context.addLifecycleListener(<span class="keyword">new</span> StaticResourceConfigurer(context));</span><br><span class="line">    ServletContextInitializer[] initializersToUse = mergeInitializers(initializers);</span><br><span class="line">    <span class="comment">// 在 host 中 加入一个 context 容器</span></span><br><span class="line">    <span class="comment">// add时给context注册了个内存泄漏跟踪的监听MemoryLeakTrackingListener,详见 addChild 方法</span></span><br><span class="line">    host.addChild(context);</span><br><span class="line">    <span class="comment">//对context做了些设置工作，包括TomcatStarter(实例化并set给context),</span></span><br><span class="line">    <span class="comment">// LifecycleListener,contextValue,errorpage,Mime,session超时持久化等以及一些自定义工作</span></span><br><span class="line">    configureContext(context, initializersToUse);</span><br><span class="line">    <span class="comment">// postProcessContext 方法是空的，留给子类重写用的</span></span><br><span class="line">    postProcessContext(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看下，WebappLoader 可以通过 setLoaderClass 和 getLoaderClass 这两个方法可以更改loaderClass 的值。所以也就意味着，我们可以自己定义一个继承 webappClassLoader 的类，来更换系统自带的默认实现。</p><h3 id="初始化-TomcatWebServer"><a href="#初始化-TomcatWebServer" class="headerlink" title="初始化 TomcatWebServer"></a>初始化 TomcatWebServer</h3><p>在 getWebServer 方法的最后就是构建一个 TomcatWebServer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TomcatWebServer <span class="title">getTomcatWebServer</span><span class="params">(Tomcat tomcat)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// new 一个 TomcatWebServer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TomcatWebServer(tomcat, getPort() &gt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.springframework.boot.web.embedded.tomcat.TomcatWebServer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TomcatWebServer</span><span class="params">(Tomcat tomcat, <span class="keyword">boolean</span> autoStart)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(tomcat, <span class="string">"Tomcat Server must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.tomcat = tomcat;</span><br><span class="line">    <span class="keyword">this</span>.autoStart = autoStart;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    initialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是 initialize 这个方法，这个方法中将会启动 tomcat 服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> WebServerException </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"Tomcat initialized with port(s): "</span> + getPortsDescription(<span class="keyword">false</span>));</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.monitor) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 对全局原子变量 containerCounter+1，由于初始值是-1，</span></span><br><span class="line">    <span class="comment">// 所以 addInstanceIdToEngineName 方法内后续的获取引擎并设置名字的逻辑不会执行</span></span><br><span class="line">            addInstanceIdToEngineName();</span><br><span class="line"><span class="comment">// 获取 Context </span></span><br><span class="line">            Context context = findContext();</span><br><span class="line">            <span class="comment">// 给 Context 对象实例生命周期监听器</span></span><br><span class="line">            context.addLifecycleListener((event) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (context.equals(event.getSource())</span><br><span class="line">                    &amp;&amp; Lifecycle.START_EVENT.equals(event.getType())) &#123;</span><br><span class="line">                    <span class="comment">// 将上面new的connection以service（这里是StandardService[Tomcat]）做key保存到</span></span><br><span class="line">                    <span class="comment">// serviceConnectors中，并将 StandardService 中的connectors 与 service 解绑(connector.setService((Service)null);)，</span></span><br><span class="line">                    <span class="comment">// 解绑后下面利用LifecycleBase启动容器就不会启动到Connector了</span></span><br><span class="line">                    removeServiceConnectors();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 启动服务器以触发初始化监听器</span></span><br><span class="line">            <span class="keyword">this</span>.tomcat.start();</span><br><span class="line">            <span class="comment">// 这个方法检查初始化过程中的异常，如果有直接在主线程抛出，</span></span><br><span class="line">            <span class="comment">// 检查方法是TomcatStarter中的 startUpException，这个值是在 Context 启动过程中记录的</span></span><br><span class="line">            rethrowDeferredStartupExceptions();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 绑定命名的上下文和classloader，</span></span><br><span class="line">                ContextBindings.bindClassLoader(context, context.getNamingToken(),</span><br><span class="line">                                                getClass().getClassLoader());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (NamingException ex) &#123;</span><br><span class="line">                <span class="comment">// 设置失败不需要关心</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ：与Jetty不同，Tomcat所有的线程都是守护线程，所以创建一个非守护线程</span></span><br><span class="line">            <span class="comment">// （例：Thread[container-0,5,main]）来避免服务到这就shutdown了</span></span><br><span class="line">            startDaemonAwaitThread();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            stopSilently();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> WebServerException(<span class="string">"Unable to start embedded Tomcat"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找 Context ，实际上就是查找一个Tomcat 中的一个 web 应用，SpringBoot 中默认启动一个 Tomcat ，并且一个 Tomcat 中只有一个 Web 应用（FATJAR 模式下，应用与 Tomcat 是 1：1 关系），所有在遍历 Host 下的 Container 时，如果 Container 类型是 Context ，就直接返回了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Context <span class="title">findContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Container child : <span class="keyword">this</span>.tomcat.getHost().findChildren()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child <span class="keyword">instanceof</span> Context) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Context) child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The host does not contain a Context"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Tomcat-启动过程"><a href="#Tomcat-启动过程" class="headerlink" title="Tomcat 启动过程"></a>Tomcat 启动过程</h2><p>在 TomcatWebServer 的 initialize 方法中会执行 tomcat 的启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start the server to trigger initialization listeners</span></span><br><span class="line"><span class="keyword">this</span>.tomcat.start();</span><br></pre></td></tr></table></figure><p>org.apache.catalina.startup.Tomcat 的 start 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 server</span></span><br><span class="line">    getServer();</span><br><span class="line">    <span class="comment">// 启动 server</span></span><br><span class="line">    server.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化-Server"><a href="#初始化-Server" class="headerlink" title="初始化 Server"></a>初始化 Server</h3><p>初始化 server 实际上就是构建一个 StandardServer 对象实例，关于 Tomcat 中的 Server 可以参考附件中的说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">getServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果已经存在的话就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 设置系统属性 catalina.useNaming</span></span><br><span class="line">    System.setProperty(<span class="string">"catalina.useNaming"</span>, <span class="string">"false"</span>);</span><br><span class="line"><span class="comment">// 直接 new 一个 StandardServer</span></span><br><span class="line">    server = <span class="keyword">new</span> StandardServer();</span><br><span class="line"><span class="comment">// 初始化 baseDir （catalina.base、catalina.home、 ~/tomcat.&#123;port&#125;）</span></span><br><span class="line">    initBaseDir();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set configuration source</span></span><br><span class="line">    ConfigFileLoader.setSource(<span class="keyword">new</span> CatalinaBaseConfigurationSource(<span class="keyword">new</span> File(basedir), <span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line">    server.setPort( -<span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    Service service = <span class="keyword">new</span> StandardService();</span><br><span class="line">    service.setName(<span class="string">"Tomcat"</span>);</span><br><span class="line">    server.addService(service);</span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面对 SpringBoot 中内嵌 Tomcat 的过程做了分析，这个过程实际上并不复杂，就是在刷新 Spring 上下文的过程中将 Tomcat 容器启动起来，并且将当前应用绑定到一个 Context ，然后添加了 Host。下图是程序的执行堆栈和执行内嵌 Tomcat 初始化和启动的时机。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/6/16da010f828a2c70?w=1492&amp;h=942&amp;f=png&amp;s=839411" alt=""></p><p>下面总结下整个过程：</p><ul><li>通过自定配置注册相关的 Bean ，包括一些 Factory 和 后置处理器等</li><li>上下文刷新阶段，执行创建 WebServer，这里需要用到前一个阶段所注册的 Bean <ul><li>包括创建 ServletContext</li><li>实例化 webServer</li></ul></li><li>创建 Tomcat 实例、创建 Connector 连接器</li><li>绑定 应用到 ServletContext，并添加相关的生命周期范畴内的监听器，然后将 Context 添加到 host 中</li><li>实例化 webServer 并且启动 Tomcat 服务</li></ul><p>SpringBoot 的 Fatjar 方式没有提供共享 Tomcat 的实现逻辑，就是两个 FATJAT 启动可以只实例化一个 Tomcat 实例（包括 Connector 和 Host ），从前面的分析知道，每个 web 应用（一个 FATJAT 对应的应用）实例上就是映射到一个 Context ；而对于 war 方式，一个 Host 下面是可以挂载多个 Context 的。</p><h1 id="附：Tomcat-组件说明"><a href="#附：Tomcat-组件说明" class="headerlink" title="附：Tomcat 组件说明"></a>附：Tomcat 组件说明</h1><table><thead><tr><th>组件名称</th><th>说明</th></tr></thead><tbody><tr><td>Server</td><td>表示整个Servlet 容器，因此 Tomcat 运行环境中只有唯一一个 Server 实例</td></tr><tr><td>Service</td><td>Service 表示一个或者多个 Connector 的集合，这些 Connector 共享同一个 Container 来处理其请求。在同一个 Tomcat 实例内可以包含任意多个 Service 实例，他们彼此独立。</td></tr><tr><td>Connector</td><td>Tomcat 连接器，用于监听和转化 Socket 请求，同时将读取的 Socket 请求交由 Container 处理，支持不同协议以及不同的 I/O 方式。</td></tr><tr><td>Container</td><td>Container 表示能够执行客户端请求并返回响应的一类对象，在 Tomcat 中存在不同级别的容器：Engine、Host、Context、Wrapper</td></tr><tr><td>Engine</td><td>Engine 表示整个 Servlet 引擎。在 Tomcat 中，Engine 为最高层级的容器对象，虽然 Engine 不是直接处理请求的容器，确是获取目标容器的入口</td></tr><tr><td>Host</td><td>Host 作为一类容器，表示 Servlet 引擎（即Engine）中的虚拟机，与一个服务器的网络名有关，如域名等。客户端可以使用这个网络名连接服务器，这个名称必须要在 DNS 服务器上注册</td></tr><tr><td>Context</td><td>Context 作为一类容器，用于表示 ServletContext，在 Servlet 规范中，一个 ServletContext 即表示一个独立的 web 应用</td></tr><tr><td>Wrapper</td><td>Wrapper 作为一类容器，用于表示 Web 应用中定义的 Servlet</td></tr><tr><td>Executor</td><td>表示 Tomcat 组件间可以共享的线程池</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于一个 SpringBoot web 工程来说，一个主要的依赖标志就是有 spring-boot-starter-web 这个 starter ，spring-boot-starter-web 模块在 spring boot 中其实并没有代码存在，只是在 pom.xml 
      
    
    </summary>
    
      <category term="springboot" scheme="http://www.glmapper.com/categories/springboot/"/>
    
    
      <category term="Tomcat" scheme="http://www.glmapper.com/tags/Tomcat/"/>
    
      <category term="springboot" scheme="http://www.glmapper.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>ARK 插件基本规则及注意事项</title>
    <link href="http://www.glmapper.com/2019/08/28/sofa-ark-plugin-rule/"/>
    <id>http://www.glmapper.com/2019/08/28/sofa-ark-plugin-rule/</id>
    <published>2019-08-28T12:20:46.000Z</published>
    <updated>2019-08-28T12:23:53.612Z</updated>
    
    <content type="html"><![CDATA[<p>SOFAARK 是一个轻量级的类隔离框架，其有两个基本的能力：解决依赖包冲突和多应用(模块)合并部署。本篇将从解决依赖角度来说明下 SOFARK 插件的基本使用规则。</p><p>下图是官方文档中提供的用于描述依赖包冲突的一个场景：</p><p><img src="https://oscimg.oschina.net/oscnet/3d88c00093b96901187532a351c69ab8a91.jpg" alt=""></p><p>这里通过一个工程来模拟这种场景，然后通过将其中一个打包成插件的方式来解决。</p><h2 id="案例工程"><a href="#案例工程" class="headerlink" title="案例工程"></a>案例工程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── ark-main-project</span><br><span class="line">├── dependency-one</span><br><span class="line">├── dependency-two</span><br><span class="line">├── dependency-two-plugin</span><br></pre></td></tr></table></figure><ul><li>ark-main-project 为一个 简单的springboot 工程</li><li>dependency-one 依赖1，可以对应到图中的 dependency A</li><li>dependency-two 依赖2，可以对应到图中的 dependency B</li><li>dependency-two-plugin ，dependency-two 的插件包</li></ul><p>另外还有一个 dependency-incompatible 工程，用于描述冲突的依赖。</p><h3 id="dependency-incompatible"><a href="#dependency-incompatible" class="headerlink" title="dependency-incompatible"></a>dependency-incompatible</h3><p>dependency-incompatible 有两个版本 1.0 和 2.0 ，1.0 和 2.0 是不兼容的。</p><p><strong>1.0 版本中提供了两个方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IncompatibleUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test2"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.0 版本中提供了两个方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IncompatibleUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Incompatible.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Incompatible</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dependency-one"><a href="#dependency-one" class="headerlink" title="dependency-one"></a>dependency-one</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOneUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> IncompatibleUtil.test1()+IncompatibleUtil.test2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dependency-two"><a href="#dependency-two" class="headerlink" title="dependency-two"></a>dependency-two</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import org.springframework.util.StringUtils;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTwoUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testTwo</span><span class="params">(String param)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(param))&#123;</span><br><span class="line">            <span class="keyword">return</span> IncompatibleUtil.test1() + IncompatibleUtil.test3();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> IncompatibleUtil.test1() + IncompatibleUtil.test3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里引入 spring 的依赖查看是否会引入异常</p></blockquote><h3 id="ark-main-project"><a href="#ark-main-project" class="headerlink" title="ark-main-project"></a>ark-main-project</h3><p>ark-main-project 引入了 dependency-one 和 dependency-two 两个依赖，然后在启动类中分别调用 dependency-one 和 dependency-two  中提供的 api 。 <br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">        test(<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(param))&#123;</span><br><span class="line">            TestOneUtil testOneUtil = <span class="keyword">new</span> TestOneUtil();</span><br><span class="line">            System.out.println(testOneUtil.testOne());</span><br><span class="line">            TestTwoUtil testTwoUtil = <span class="keyword">new</span> TestTwoUtil();</span><br><span class="line">            System.out.println(testTwoUtil.testTwo(param));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no params"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 dependency-one 和 dependency-two 底层都都依赖了 dependency-incompatible ，且 dependency-incompatible 的两个版本不兼容，所以在启动时会报错。</p><p><img src="https://oscimg.oschina.net/oscnet/46005bbbf37f7063b90ff6a0bb4c46671bd.jpg" alt=""></p><h3 id="dependency-two-插件改造"><a href="#dependency-two-插件改造" class="headerlink" title="dependency-two 插件改造"></a>dependency-two 插件改造</h3><p>根据文档前面那张图的描述，这里需要将其中一个改造成插件的方式，使用独立的 classloader 来加载，从而达到版本兼容。这里改造 dependency-two 。</p><p>新建一个 dependency-two-plugin 模块，然后引入 dependency-two 依赖，并且将 冲突的 api 包导出</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dependency-two<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.glmapper.bridge.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-ark-plugin-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>default-cli<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>ark-plugin<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">exported</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">packages</span>&gt;</span></span><br><span class="line">                                <span class="comment">&lt;!--导出冲突的 api --&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">package</span>&gt;</span>com.glmapper.bridge.boot.two<span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">packages</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">exported</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <br><strong>关于插件的导出，对于 dependency-two 中，ark-main-projet 中使用到的是 TestTwoUtil 这里类，因此仅需要将这个类导出即可。</strong></p><p>mvn clean install 安装到本地仓库，然后在 ark-main-project 中引用。</p><p>将 ark-main-project 中的 dependency-two 依赖修改为 dependency-two-plugin 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.glmapper.bridge.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dependency-two-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为插件是运行在容器上的，所以也需要将 ark-main-project 改造成 ark 工程，具体可以参考官方文档。改造完成之后，打包 ark-main-project 工程，然后通过 java -jar 启动，运行结果如下，实现了类隔离。</p><p><img src="https://oscimg.oschina.net/oscnet/eb97a874c46677d31478c55b0dfde41e636.jpg" alt=""></p><h2 id="NoClassDefFoundError-异常的发生"><a href="#NoClassDefFoundError-异常的发生" class="headerlink" title="NoClassDefFoundError 异常的发生"></a>NoClassDefFoundError 异常的发生</h2><p>关于上面 SpringUtils 工具类在插件中和 BIZ 中均加载并且不会报错的解释是，SpringUtils 虽然在插件中和 BIZ 中都被加载了，但是没有报错，是因为没有触发 java 的 type check 机制。</p><p>那么还有一种情况会导致出现 java.lang.NoClassDefFoundError 异常，这种情况是在插件中将 spring 相关的包指定不打入插件了，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exported</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">packages</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">package</span>&gt;</span>com.glmapper.bridge.boot.two.*<span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">packages</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exported</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--不将 spring 的包打进去--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">excludeGroupIds</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludeGroupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">excludeGroupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludeGroupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">excludeGroupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludeGroupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">excludeGroupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">excludeGroupIds</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么这样打出的包实际上包的大小会非常小，但是问题在于运行时，插件从当前 /iib 目录下找不到 spring 相关的依赖，就会报  java.lang.NoClassDefFoundError 。</p><p><img src="https://oscimg.oschina.net/oscnet/0c05a61d784d74023cde395c1e098bc5282.jpg" alt=""></p><h2 id="LinkageError-异常的发生"><a href="#LinkageError-异常的发生" class="headerlink" title="LinkageError 异常的发生"></a><strong>LinkageError 异常的发生</strong></h2><p>ark-main-project 中</p><p><img src="https://oscimg.oschina.net/oscnet/f95211cb4c5e0051cc5ef4b314ae0e240e3.jpg" alt=""></p><p>dependency-two 中</p><p><img src="https://oscimg.oschina.net/oscnet/ae46e12edbee7e3a23a1504b7aa4cdbe1aa.jpg" alt=""></p><p>重新打包，然后执行</p><p><img src="https://oscimg.oschina.net/oscnet/2ef11727076f1b3e502ef59507bc820e040.jpg" alt=""></p><p>没有报错。此时插件中的类和 biz 中的类完全都是独立的。但是会存在一种情况，比如插件中有一个日志工具类，然后在 Biz 使用了这个工具类，则会报错。</p><p>在 dependency-two 中增加一个 LoggerUtil 的类，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(LoggerUtil.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        LOGGER.info(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getLogger</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LOGGER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 ark-main-project 中这样使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line"><span class="comment">// 使用 LoggerUtil 获取日志对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerUtil.getLogger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">        test(<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 记录日志</span></span><br><span class="line">        LOGGER.info(<span class="string">"test in biz."</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(param))&#123;</span><br><span class="line">            TestOneUtil testOneUtil = <span class="keyword">new</span> TestOneUtil();</span><br><span class="line">            System.out.println(testOneUtil.testOne());</span><br><span class="line">            TestTwoUtil testTwoUtil = <span class="keyword">new</span> TestTwoUtil();</span><br><span class="line">            System.out.println(testTwoUtil.testTwo(param));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no params"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下就会导致报错</p><p><strong>Caused by: java.lang.LinkageError: loader constraint violation: loader (instance of com/alipay/sofa/ark/container/service/classloader/BizClassLoader) previously initiated loading for a different type with name “org/slf4j/Logger”</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerUtil.getLogger();</span><br></pre></td></tr></table></figure><p>单从这段代码来看，报错的原因在于，Logger LOGGER 的对象加载是被 BizClassLoader 加载的，但是 LoggerUtil.getLogger() 返回的对象是由 PluginClassLoader 加载的。</p><p>所以在构建插件时，需要尽可能的去规避可能出现引起类型检查的地方：</p><ul><li>方法参数检验</li><li>变量赋值</li><li>方法返回值</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SOFAARK 是一个轻量级的类隔离框架，其有两个基本的能力：解决依赖包冲突和多应用(模块)合并部署。本篇将从解决依赖角度来说明下 SOFARK 插件的基本使用规则。&lt;/p&gt;
&lt;p&gt;下图是官方文档中提供的用于描述依赖包冲突的一个场景：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;ht
      
    
    </summary>
    
    
      <category term="sofa-ark" scheme="http://www.glmapper.com/tags/sofa-ark/"/>
    
  </entry>
  
  <entry>
    <title>响应式编程 Reactor 小记</title>
    <link href="http://www.glmapper.com/2019/08/24/base-java-reacotr/"/>
    <id>http://www.glmapper.com/2019/08/24/base-java-reacotr/</id>
    <published>2019-08-24T00:59:26.000Z</published>
    <updated>2019-08-24T01:00:26.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从响应式编程说起"><a href="#从响应式编程说起" class="headerlink" title="从响应式编程说起"></a>从响应式编程说起</h2><p>响应式编程是一种关注于数据流（data streams）和变化传递（propagation of change）的异步编程方式。 这意味着它可以用既有的编程语言表达静态（如数组）或动态（如事件源）的数据流。</p><p>在响应式编程方面，微软跨出了第一步，它在 .NET 生态中创建了响应式扩展库（Reactive Extensions library, Rx）。接着 RxJava 在 JVM 上实现了响应式编程。后来，在 JVM 平台出现了一套标准的响应式 编程规范，它定义了一系列标准接口和交互规范。并整合到 Java 9 中（Flow 类）。</p><p>响应式编程通常作为面向对象编程中的“观察者模式”（Observer design pattern）的一种扩展。 响应式流（reactive streams）与“迭代子模式”（Iterator design pattern）也有相通之处， 因为其中也有 Iterable-Iterator 这样的对应关系。主要的区别在于，Iterator 是基于 “拉取”（pull）方式的，而响应式流是基于“推送”（push）方式的。</p><ul><li>iterator 是一种“命令式”（imperative）编程范式，即使访问元素的方法是 Iterable 的唯一职责。关键在于，什么时候执行 next() 获取元素取决于开发者。</li><li>响应式流中，相对应的角色是 Publisher-Subscriber，但是当有新的值到来的时候 ，却反过来由发布者（Publisher） 通知订阅者（Subscriber），这种“推送”模式是响应式的关键</li></ul><p>此外，对推送来的数据的操作是通过一种声明式（declaratively）而不是命令式（imperatively）的方式表达的：开发者通过描述“控制流程”来定义对数据流的处理逻辑。</p><p>除了数据推送，对错误处理（error handling）和完成（completion）信号的定义也很完善。一个 Publisher 可以推送新的值到它的 Subscriber（调用 onNext 方法）， 同样也可以推送错误（调用 onError 方法）和完成（调用 onComplete 方法）信号。 错误和完成信号都可以终止响应式流。可以用下边的表达式描述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onNext x <span class="number">0</span>..N [onError | onComplete]</span><br></pre></td></tr></table></figure><p>这种方式非常灵活，无论是有/没有值，还是 n 个值（包括有无限个值的流，比如时钟的持续读秒），都可处理。</p><blockquote><p>以上来自 <a href="https://projectreactor.io/docs/core/release/reference/" target="_blank" rel="noopener">https://projectreactor.io/docs/core/release/reference/</a> 翻译</p></blockquote><h2 id="Reactive-Streams"><a href="#Reactive-Streams" class="headerlink" title="Reactive Streams"></a>Reactive Streams</h2><p>Reactive Streams 是上面提到的一套标准的响应式编程规范。它由四个核心概念构成：</p><ul><li><p>消息发布者：只有一个 subscribe 接口，是订阅者调用的，用来订阅发布者的消息。发布者在订阅者调用 request 之后把消息 push 给订阅者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Publisher</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>订阅者：订阅者包括四个接口，这些接口都由 Publisher 触发调用的。onSubscribe 告诉订阅者订阅成功，并返回了一个 Subscription ；通过 Subscription 订阅者可以告诉发布者发送指定数量的消息（request 完成） ；onNext 是发布者有消息时，调用订阅者这个接口来达到发布消息的目的；onError 通知订阅者，发布者出现了错误；onComplete 通知订阅者消息发送完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>订阅：包括两个接口，请求 n 个消息和取消此次订阅。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subscription</span> </span>&#123;</span><br><span class="line">    <span class="comment">// request(n)用来发起请求数据,其中n表示请求数据的数量,它必须大于0,</span></span><br><span class="line">    <span class="comment">// 否则会抛出IllegalArgumentException,并触发onError,request的调用会</span></span><br><span class="line">    <span class="comment">// 累加,如果没有终止,最后会触发相应次数的onNext方法.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span><br><span class="line">    <span class="comment">// cancel相当于取消订阅,调用之后,后续不会再收到订阅,onError 和 </span></span><br><span class="line">    <span class="comment">// onComplete也不会被触发</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>处理器：Processor 同时继承了 Subscriber 和 Publisher；其代表一个处理阶段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt;, <span class="title">Publisher</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Reactive Streams 通过上面的四个核心概念和相关的函数，对响应式流进行了一个框架性的约定，它没有具体实现。简单来说，它只提供通用的、合适的解决方案，大家都按照这个规约来实现就好了。</p><p>Java 的 Reactive Programming 类库主要有三个，分别是 Akka-Streams ，RxJava 和 Project Reactor。Spring 5 开始支持 Reactive Programming，其底层使用的是 Project Reactor。本篇主要是对 Project Reactor 中的一些点进行学习总结。</p><h2 id="Project-Reactor"><a href="#Project-Reactor" class="headerlink" title="Project Reactor"></a>Project Reactor</h2><p>Project Reactor 是一个基于 Java 8 的实现了响应式流规范 （Reactive Streams specification）的响应式库。</p><p>Reactor 引入了实现 Publisher 的响应式类 Flux 和 Mono，以及丰富的操作方式。 一个 Flux 对象代表一个包含 0..N 个元素的响应式序列，而一个 Mono 对象代表一个包含零或者一个（0..1）元素的结果。</p><h3 id="Flux-和-Mono"><a href="#Flux-和-Mono" class="headerlink" title="Flux 和 Mono"></a>Flux 和 Mono</h3><p>Flux 是生产者，即我们上面提到的 Publisher，它代表的是一个包含 0-N 个元素的异步序列，Mono可以看做 Flux 的有一个特例，代表 0-1 个元素，如果不需要生产任何元素，只是需要一个完成任务的信号，可以使用 Mono。</p><h4 id="Flux-包含-0-N-个元素的异步序列"><a href="#Flux-包含-0-N-个元素的异步序列" class="headerlink" title="Flux-包含 0-N 个元素的异步序列"></a>Flux-包含 0-N 个元素的异步序列</h4><p><img src="https://user-gold-cdn.xitu.io/2019/6/2/16b15a03f9385f59?w=640&amp;h=227&amp;f=png&amp;s=77358" alt="Flux"></p><p>先来看这张图，这里是直接从官方文档上贴过来的。就这张图做下说明，先来关注几个点：</p><ul><li>从左到右的时间序列轴</li><li>1-6 为 Flux enitted（发射）的元素</li><li>上面 6 后面的竖线标识已经成功完成了</li><li>下面的 1-3 表示转换的结果</li><li>❌  表示出现了error，对应的是执行了onError</li><li>operator : 操作符，声明式的可组装的响应式方法，其组装成的链称为“操作链”</li></ul><p>那整体来看就是 Flux 产生元数据，通过一系列 operator 操作得到转换结果，正常成功就是 onCompleted，出现错误就是 onError。看下面的一个小例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">"glmapper"</span>,<span class="string">"leishu"</span>).subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// subscription 表示订阅关系</span></span><br><span class="line">        System.out.println(<span class="string">"onSubscribe,"</span>+ subscription.getClass());</span><br><span class="line">        <span class="comment">// subscription 通过 request 来触发 onNext</span></span><br><span class="line">        subscription.request(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"currrent value is = "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"it's error."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"it's completed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>执行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onSubscribe,class reactor.core.publisher.StrictSubscriber</span><br><span class="line">currrent value is = glmapper</span><br><span class="line">currrent value is = leishu</span><br><span class="line">it&apos;s completed.</span><br></pre></td></tr></table></figure><p>如果在 onSubscribe 方法中我们不执行 request，则不会有后续任何操作。关于 request 下面看。</p><blockquote><p>Flux<t> 是一个能够发出 0 到 N 个元素的标准的 Publisher<t>，它会被一个 “error”  或 “completion” 信号终止。因此，一个 Flux 的结果可能是一个 value、completion 或 error。 就像在响应式流规范中规定的那样，这三种类型的信号被翻译为面向下游的 <code>onNext</code>，<code>onComplete</code>和<code>onError</code>方法。</t></t></p></blockquote><h4 id="Mono-异步的-0-1-结果"><a href="#Mono-异步的-0-1-结果" class="headerlink" title="Mono-异步的 0-1 结果"></a>Mono-异步的 0-1 结果</h4><p><img src="https://user-gold-cdn.xitu.io/2019/6/2/16b15c30fed69197?w=640&amp;h=227&amp;f=png&amp;s=60634" alt="Mono"></p><p>这张图也来自官方文档，和上面 Flux 的区别就是，Mono 最多只能 emitted 一个元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono.just(<span class="string">"glmapper"</span>).subscribe(System.out::println);</span><br></pre></td></tr></table></figure></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通过上面两段小的代码来看，最直观的感受是，Flux 相当于一个 List，Mono 相当于 Optional。其实在编程中所有的结果我们都可以用 List 来 表示，但是当只返回一个或者没有结果时，用 Optional 可能会更精确些。</p><blockquote><p>Optional 相关概念可自行搜索 jdk Optional</p></blockquote><p>另外，Mono 和 Flux 都提供了一些工厂方法，用于创建相关的实例，这里简单罗列一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以指定序列中包含的全部元素。创建出来的 Flux </span></span><br><span class="line"><span class="comment">// 序列在发布这些元素之后会自动结束。</span></span><br><span class="line">Flux.just(<span class="string">"glmapper"</span>, <span class="string">"leishu"</span>);</span><br><span class="line"><span class="comment">// 从一个Iterable 对象中创建 Flux 对象,当然还可以是数组、Stream对象等</span></span><br><span class="line">Flux.fromIterable(Arrays.asList(<span class="string">"glmapper"</span>,<span class="string">"leishu"</span>));</span><br><span class="line"><span class="comment">// 创建一个只包含错误消息的序列。</span></span><br><span class="line">Flux.error(<span class="keyword">new</span> IllegalStateException());</span><br><span class="line"><span class="comment">// 创建一个包含了从 0 开始递增的 Long 对象的序列。其中包含的元素按照指定的间</span></span><br><span class="line"><span class="comment">// 隔来发布。除了间隔时间之外，还可以指定起始元素发布之前的延迟时间。</span></span><br><span class="line">Flux.interval(Duration.ofMillis(<span class="number">100</span>)).take(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 创建一个不包含任何消息通知的序列。</span></span><br><span class="line">Flux.never();</span><br><span class="line"><span class="comment">// 创建一个不包含任何元素，只发布结束消息的序列。</span></span><br><span class="line">Flux.empty(); </span><br><span class="line"><span class="comment">// 创建包含从 start 起始的 count 个数量的 Integer 对象的序列</span></span><br><span class="line">Flux.range(<span class="keyword">int</span> start, <span class="keyword">int</span> count);</span><br><span class="line"><span class="comment">// Mono 同上</span></span><br><span class="line">Mono.empty();</span><br><span class="line">Mono.never();</span><br><span class="line">Mono.just(<span class="string">"glmapper"</span>);</span><br><span class="line">Mono.error(<span class="keyword">new</span> IllegalStateException());</span><br></pre></td></tr></table></figure></p><p>上面的这些静态方法适合于简单的序列生成，当序列的生成需要复杂的逻辑时，则应该使用 generate() 或 create() 方法。</p><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><ul><li>Operator：Operator 是一系列函数式的便捷操作，可以链式调用。所有函数调用基本都 是 Reactor 的 Operator ，比如 just，map，flatMap，filter 等。</li><li>Processor：上面从 Processor 的接口定义可以看出，它既是一个 Subscriber，又是一个 Publisher；Processor 夹在第一个 Publisher 和最后一个 Subscriber 中间，对数据进行处理。有点类似 stream 里的 map，filter 等方法。具体在数据流转中， Processor 以 Subscriber 的身份订阅 Publisher 接受数据，又以 Publisher 的方式接受其它 Subscriber 的订阅，它从自己订阅的 Publisher 收到数据后，做一些处理，然后转发给订阅它的 Subscriber。</li><li>back pressure：背压。对 MQ 有了解的应该清楚，消息积压一般是在消费端，也就是说生产端只负责生产，并不会关心消费端的消费能力，这样就到导致 pressure 积压在消费端，这个是正向的。从上面对 Reactor 中的一些了解，Subscriber 是主动向 Publisher 请求的，这样当消费端消费的速度没有生产者快时，这些消息还是积压在生产端；这种好处就是生产者可以根据实际情况适当的调整生产消息的速度。</li><li>Hot VS Cold ：参考 <a href="https://htmlpreview.github.io/?https://github.com/get-set/reactor-core/blob/master-zh/src/docs/index.html#reactor.hotCold" target="_blank" rel="noopener">Hot VS Cold</a></li></ul><h3 id="核心调用过程"><a href="#核心调用过程" class="headerlink" title="核心调用过程"></a>核心调用过程</h3><p>Reactor 的核心调用过程大致可以分为图中的几个阶段<br><img src="https://user-gold-cdn.xitu.io/2019/6/2/16b18a9947994dc3?w=921&amp;h=224&amp;f=png&amp;s=9932" alt=""></p><ul><li>声明：无论是使用 just 或者其他什么方式创建反应式流，这个过程都可以称之为声明，因为此时这些代码不会被实际的执行。</li><li>subscribe：当调用 subscribe 时，整个执行过程便进入 subscribe 阶段，经过一系列的调用之后，subscribe 动作会代理给具体的 Flux 来实现。</li><li>onSubscribe：onSubscribe 阶段指的是 Subscriber#onSubscribe 方法被依次调用的阶段。这个阶段会让各 Subscriber 知道 subscribe 方法已被触发，真正的处理流程马上就要开始。</li><li>request：onSubscribe 阶段是表示订阅动作的方式，让各 Subscriber 知悉，准备开始处理数据。当最终的 Subscriber 做好处理数据的准备之后，它便会调用 Subscription 的 request 方法请求数据。</li><li>onNext：通过调用 Subscriber 的 onNext 方法，进行真正的响应式的数据处理。</li><li>onComplete：成功的终端状态，没有进一步的事件将被发送。</li><li>onError：错误的终端状态（和 onComplete 一样，当发生时，后面的将不会在继续执行）。</li></ul><h3 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h3><p>当需要处理 Flux 或 Mono 中的消息时，可以通过 subscribe 方法来添加相应的订阅逻辑。在调用 subscribe 方法时可以指定需要处理的消息类型。可以只处理其中包含的正常消息，也可以同时处理错误消息和完成消息。</p><h4 id="通过-subscribe-方法处理正常和错误消息"><a href="#通过-subscribe-方法处理正常和错误消息" class="headerlink" title="通过 subscribe() 方法处理正常和错误消息"></a>通过 subscribe() 方法处理正常和错误消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">   .concatWith(Mono.error(<span class="keyword">new</span> IllegalStateException()))</span><br><span class="line">   .subscribe(System.out::println, System.err::println);</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">java.lang.IllegalStateException</span><br></pre></td></tr></table></figure></p><p>正常的消息处理相对简单。当出现错误时，有多种不同的处理策略:</p><ul><li>通过 onErrorReturn() 方法返回一个默认值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    .concatWith(Mono.error(<span class="keyword">new</span> IllegalStateException()))</span><br><span class="line">    .onErrorReturn(<span class="number">0</span>)</span><br><span class="line">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure></li></ul><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><ul><li>通过 onErrorResume()方法来根据不同的异常类型来选择要使用的产生元素的流<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">       .concatWith(Mono.error(<span class="keyword">new</span> IllegalArgumentException()))</span><br><span class="line">       .onErrorResume(e -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (e <span class="keyword">instanceof</span> IllegalStateException) &#123;</span><br><span class="line">               <span class="keyword">return</span> Mono.just(<span class="number">0</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> IllegalArgumentException) &#123;</span><br><span class="line">               <span class="keyword">return</span> Mono.just(-<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> Mono.empty();</span><br><span class="line">           &#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure></li></ul><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure></p><ul><li>通过 retry 操作符来进行重试，重试的动作是通过重新订阅序列来实现的。在使用 retry 操作符时可以指定重试的次数。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    .concatWith(Mono.error(<span class="keyword">new</span> IllegalStateException()))</span><br><span class="line">    .retry(<span class="number">1</span>)</span><br><span class="line">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure></li></ul><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">Exception in thread &quot;main&quot; reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.IllegalStateException</span><br><span class="line">Caused by: java.lang.IllegalStateException</span><br><span class="line">at com.glmapper.bridge.boot.reactor.SimpleTest.testFluxSub(SimpleTest.java:75)</span><br><span class="line">at com.glmapper.bridge.boot.reactor.SimpleTest.main(SimpleTest.java:23)</span><br></pre></td></tr></table></figure></p><h3 id="调度器-Scheduler"><a href="#调度器-Scheduler" class="headerlink" title="调度器 Scheduler"></a>调度器 Scheduler</h3><p>在 Reactor 中，执行模式以及执行过程取决于所使用的 Scheduler，Scheduler 是一个拥有广泛实现类的抽象接口，Schedulers 类提供的静态方法用于达成如下的执行环境：</p><ul><li><p>当前线程（Schedulers.immediate()）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Schedulers.immediate().schedule(()-&gt;&#123;</span><br><span class="line">   System.out.println(Thread.currentThread().getName()+<span class="string">"-"</span>+<span class="number">11</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main-11</span></span><br></pre></td></tr></table></figure></li><li><p>可重用的单线程（Schedulers.single()）。注意，这个方法对所有调用者都提供同一个线程来使用， 直到该调度器（Scheduler）被废弃。如果你想使用专一的线程，就对每一个调用使用 Schedulers.newSingle()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Schedulers.single().schedule(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"-"</span>+<span class="number">11</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// single-1-11</span></span><br></pre></td></tr></table></figure></li><li><p>弹性线程池（Schedulers.elastic()。它根据需要创建一个线程池，重用空闲线程。线程池如果空闲时间过长 （默认为 60s）就会被废弃。对于 I/O 阻塞的场景比较适用。 Schedulers.elastic() 能够方便地给一个阻塞 的任务分配它自己的线程，从而不会妨碍其他任务和资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Schedulers.elastic().schedule(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"-"</span>+<span class="number">11</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// elastic-2-11</span></span><br></pre></td></tr></table></figure></li><li><p>固定大小线程池（Schedulers.parallel()）。所创建线程池的大小与 CPU 个数等同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Schedulers.parallel().schedule(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"-"</span>+<span class="number">11</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// parallel-1-11</span></span><br></pre></td></tr></table></figure></li><li><p>基于现有的 ExecutorService 创建 Scheduler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">Schedulers.fromExecutorService(executorService).schedule(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"-"</span>+<span class="number">11</span>);</span><br><span class="line">&#125;);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// pool-4-thread-1-11</span></span><br></pre></td></tr></table></figure></li><li><p>基于 newXXX 方法来创建调度器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Schedulers.newElastic(<span class="string">"test-elastic"</span>).schedule(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"-"</span>+<span class="number">11</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// test-elastic-4-11</span></span><br></pre></td></tr></table></figure></li></ul><p>一些操作符默认会使用一个指定的调度器（通常也允许开发者调整为其他调度器）例如， 通过工厂方法 Flux.interval(Duration.ofMillis(100)) 生成的每 100ms 打点一次的 Flux<long>， 默认情况下使用的是 Schedulers.parallel()，下边的代码演示了如何将其装换为 Schedulers.single()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; intervalResult = Flux.interval(Duration.ofMillis(<span class="number">100</span>),</span><br><span class="line">        Schedulers.newSingle(<span class="string">"test"</span>))</span><br><span class="line">        .map(i -&gt; Thread.currentThread().getName() +<span class="string">"@"</span>+i);</span><br><span class="line">        intervalResult.subscribe(System.out::println);</span><br></pre></td></tr></table></figure></long></p><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test-1@0</span><br><span class="line">test-1@1</span><br><span class="line">test-1@2</span><br><span class="line">test-1@3</span><br><span class="line">test-1@4</span><br><span class="line">// 省略</span><br></pre></td></tr></table></figure></p><h3 id="publishOn-和-subscribeOn"><a href="#publishOn-和-subscribeOn" class="headerlink" title="publishOn 和 subscribeOn"></a>publishOn 和 subscribeOn</h3><p>Reactor 提供了两种在响应式链中调整调度器 Scheduler 的方法：publishOn 和 subscribeOn。 它们都接受一个 Scheduler 作为参数，从而可以改变调度器。但是 publishOn 在链中出现的位置是有讲究的，而 subscribeOn 则无所谓。</p><ul><li>publishOn 的用法和处于订阅链（subscriber chain）中的其他操作符一样。它将上游 信号传给下游，同时执行指定的调度器 Scheduler 的某个工作线程上的回调。 它会 改变后续的操作符的执行所在线程 （直到下一个 publishOn 出现在这个链上）</li><li>subscribeOn 用于订阅（subscription）过程，作用于那个向上的订阅链（发布者在被订阅 时才激活，订阅的传递方向是向上游的）。所以，无论你把 subscribeOn 至于操作链的什么位置， 它都会影响到源头的线程执行环境（context）。 但是，它不会影响到后续的 publishOn，后者仍能够切换其后操作符的线程执行环境。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Flux.create(sink -&gt; &#123;</span><br><span class="line">        sink.next(Thread.currentThread().getName());</span><br><span class="line">        sink.complete();</span><br><span class="line">    &#125;)</span><br><span class="line">    .publishOn(Schedulers.single())</span><br><span class="line">    .map(x -&gt; String.format(<span class="string">"[%s] %s"</span>, Thread.currentThread().getName(), x))</span><br><span class="line">    .publishOn(Schedulers.elastic())</span><br><span class="line">    .map(x -&gt; String.format(<span class="string">"[%s] %s"</span>, Thread.currentThread().getName(), x))</span><br><span class="line">    .subscribeOn(Schedulers.parallel())</span><br><span class="line">    .toStream()</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[elastic-<span class="number">2</span>] [single-<span class="number">1</span>] parallel-<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>上面这段代码使用 create() 方法创建一个新的 Flux 对象，其中包含唯一的元素是当前线程的名称。</p><p>接着是两对 publishOn() 和 map()方法，其作用是先切换执行时的调度器，再把当前的线程名称作为前缀添加。</p><p>最后通过 subscribeOn()方法来改变流产生时的执行方式。</p><p>最内层的线程名字 parallel-1 来自产生流中元素时使用的 Schedulers.parallel()调度器，中间的线程名称 single-1 来自第一个 map 操作之前的 Schedulers.single() 调度器，最外层的线程名字 elastic-2 来自第二个 map 操作之前的 Schedulers.elastic()调度器。</p><blockquote><p>先到这里，剩下的想到再补充…</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://projectreactor.io/docs/core/release/reference/" target="_blank" rel="noopener">https://projectreactor.io/docs/core/release/reference/</a></li><li><a href="https://htmlpreview.github.io/?https://github.com/get-set/reactor-core/blob/master-zh/src/docs/index.html#about-doc" target="_blank" rel="noopener">https://htmlpreview.github.io/?https://github.com/get-set/reactor-core/blob/master-zh/src/docs/index.html#about-doc</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-cn-with-reactor-response-encode/index.html?lnk=hmhm" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-cn-with-reactor-response-encode/index.html?lnk=hmhm</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;从响应式编程说起&quot;&gt;&lt;a href=&quot;#从响应式编程说起&quot; class=&quot;headerlink&quot; title=&quot;从响应式编程说起&quot;&gt;&lt;/a&gt;从响应式编程说起&lt;/h2&gt;&lt;p&gt;响应式编程是一种关注于数据流（data streams）和变化传递（propagation 
      
    
    </summary>
    
      <category term="java" scheme="http://www.glmapper.com/categories/java/"/>
    
    
      <category term="java" scheme="http://www.glmapper.com/tags/java/"/>
    
      <category term="Reactor" scheme="http://www.glmapper.com/tags/Reactor/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊-JAVA 泛型中的通配符 T，E，K，V，？</title>
    <link href="http://www.glmapper.com/2019/08/19/base-java-generics/"/>
    <id>http://www.glmapper.com/2019/08/19/base-java-generics/</id>
    <published>2019-08-19T07:20:35.000Z</published>
    <updated>2019-08-19T07:22:32.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许开发者在编译时检测到非法的类型。</p><p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><h2 id="泛型带来的好处"><a href="#泛型带来的好处" class="headerlink" title="泛型带来的好处"></a>泛型带来的好处</h2><p>在没有泛型的情况的下，通过对类型 Object 的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是本身就是一个安全隐患。</p><p>那么泛型的好处就是在编译的时候能够检查类型安全，并且所有的强制转换都是自动和隐式的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperGeneric</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">this</span>.t = t; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 不指定类型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noSpecifyType</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GlmapperGeneric glmapperGeneric = <span class="keyword">new</span> GlmapperGeneric();</span><br><span class="line">    glmapperGeneric.set(<span class="string">"test"</span>);</span><br><span class="line">    <span class="comment">// 需要强制类型转换</span></span><br><span class="line">    String test = (String) glmapperGeneric.get();</span><br><span class="line">    System.out.println(test);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 指定类型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specifyType</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GlmapperGeneric&lt;String&gt; glmapperGeneric = <span class="keyword">new</span> GlmapperGeneric();</span><br><span class="line">    glmapperGeneric.set(<span class="string">"test"</span>);</span><br><span class="line">    <span class="comment">// 不需要强制类型转换</span></span><br><span class="line">    String test = glmapperGeneric.get();</span><br><span class="line">    System.out.println(test);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码中的 specifyType 方法中 省去了强制转换，可以在编译时候检查类型安全，可以用在类，方法，接口上。</p><h2 id="泛型中通配符"><a href="#泛型中通配符" class="headerlink" title="泛型中通配符"></a>泛型中通配符</h2><p>我们在定义泛型类，泛型方法，泛型接口的时候经常会碰见很多不同的通配符，比如 T，E，K，V 等等，这些通配符又都是什么意思呢？</p><h3 id="常用的-T，E，K，V，？"><a href="#常用的-T，E，K，V，？" class="headerlink" title="常用的 T，E，K，V，？"></a>常用的 T，E，K，V，？</h3><p>本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。<strong>通常情况下，T，E，K，V，？ 是这样约定的：</strong></p><ul><li>？ 表示不确定的 java 类型</li><li>T (type) 表示具体的一个java类型</li><li>K V (key value) 分别代表java键值中的Key Value</li><li>E (element) 代表Element</li></ul><h3 id="？-无界通配符"><a href="#？-无界通配符" class="headerlink" title="？ 无界通配符"></a>？ <strong>无界通配符</strong></h3><p>先从一个小例子看起，原文在 <a href="https://codeday.me/bug/20180113/116421.html" target="_blank" rel="noopener">这里</a> 。</p><p>我有一个父类 Animal 和几个子类，如狗、猫等，现在我需要一个动物的列表，我的第一个想法是像这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Animal&gt; listAnimals</span><br></pre></td></tr></table></figure><p>但是老板的想法确实这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Animal&gt; listAnimals</span><br></pre></td></tr></table></figure><p>为什么要使用通配符而不是简单的泛型呢？通配符其实在声明局部变量时是没有什么意义的，但是当你为一个方法声明一个参数时，它是非常重要的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countLegs</span> <span class="params">(List&lt;? extends Animal &gt; animals )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( Animal animal : animals )</span><br><span class="line">    &#123;</span><br><span class="line">        retVal += animal.countLegs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countLegs1</span> <span class="params">(List&lt; Animal &gt; animals )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( Animal animal : animals )</span><br><span class="line">    &#123;</span><br><span class="line">        retVal += animal.countLegs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Dog&gt; dogs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> <span class="comment">// 不会报错</span></span><br><span class="line">    countLegs( dogs );</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line">    countLegs1(dogs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 countLegs1 时，就会飘红，提示的错误信息如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/8/17/16c9df5681ee06f4?w=673&amp;h=52&amp;f=png&amp;s=38254" alt=""></p><p>所以，对于不确定或者不关心实际要操作的类型，可以使用无限制通配符（尖括号里一个问号，即 &lt;?&gt; ），表示可以持有任何类型。像 countLegs 方法中，限定了上届，但是不关心具体类型是什么，所以对于传入的 Animal 的所有子类都可以支持，并且不会报错。而 countLegs1 就不行。</p><h3 id="上界通配符-lt-extends-E-gt"><a href="#上界通配符-lt-extends-E-gt" class="headerlink" title="上界通配符 &lt; ? extends E&gt;"></a>上界通配符 &lt; ? extends E&gt;</h3><blockquote><p>上届：用 extends 关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。</p></blockquote><p>在类型参数中使用 extends 表示这个泛型中的参数必须是 E 或者 E 的子类，这样有两个好处：</p><ul><li>如果传入的类型不是 E 或者 E 的子类，编译不成功</li><li>泛型中可以使用 E 的方法，要不然还得强转成 E 才能使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;K extends A, E extends B&gt; <span class="function">E <span class="title">test</span><span class="params">(K arg1, E arg2)</span></span>&#123;</span><br><span class="line">    E result = arg2;</span><br><span class="line">    arg2.compareTo(arg1);</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类型参数列表中如果有多个类型参数上限，用逗号分开</p></blockquote><h3 id="下界通配符-lt-super-E-gt"><a href="#下界通配符-lt-super-E-gt" class="headerlink" title="下界通配符 &lt; ? super E&gt;"></a>下界通配符 &lt; ? super E&gt;</h3><blockquote><p>下界: 用 super 进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object</p></blockquote><p>在类型参数中使用 super 表示这个泛型中的参数必须是 E 或者 E 的父类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dst, List&lt;T&gt; src)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T t : src) &#123;</span><br><span class="line">        dst.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Dog&gt; dogs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Animal&gt; animals = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> Test3().test(animals,dogs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Dog 是 Animal 的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dst 类型 “大于等于” src 的类型，这里的“大于等于”是指 dst 表示的范围比 src 要大，因此装得下 dst 的容器也就能装 src 。</p><h3 id="？-和-T-的区别"><a href="#？-和-T-的区别" class="headerlink" title="？ 和 T 的区别"></a>？ 和 T 的区别</h3><p><img src="https://user-gold-cdn.xitu.io/2019/8/17/16c9df5bd67315e6?w=1080&amp;h=294&amp;f=png&amp;s=57812" alt=""></p><p>？和 T 都表示不确定的类型，区别在于我们可以对 T 进行操作，但是对 ？ 不行，比如如下这种 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以</span></span><br><span class="line">T t = operate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以</span></span><br><span class="line">？ car = operate();</span><br></pre></td></tr></table></figure><p>简单总结下：</p><p>T 是一个 确定的 类型，通常用于泛型类和泛型方法的定义，？是一个 不确定 的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。</p><h4 id="区别1：通过-T-来-确保-泛型参数的一致性"><a href="#区别1：通过-T-来-确保-泛型参数的一致性" class="headerlink" title="区别1：通过 T 来 确保 泛型参数的一致性"></a>区别1：通过 T 来 确保 泛型参数的一致性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 T 来 确保 泛型参数的一致性</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="keyword">void</span></span><br><span class="line">test(List&lt;T&gt; dest, List&lt;T&gt; src)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span></span><br><span class="line">test(List&lt;? extends Number&gt; dest, List&lt;? extends Number&gt; src)</span><br></pre></td></tr></table></figure><p>像下面的代码中，约定的 T 是 Number 的子类才可以，但是申明时是用的 String ，所以就会飘红报错。</p><p><img src="https://user-gold-cdn.xitu.io/2019/8/17/16c9df6753170c5c?w=866&amp;h=332&amp;f=png&amp;s=213022" alt=""></p><p>不能保证两个 List 具有相同的元素类型的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GlmapperGeneric&lt;String&gt; glmapperGeneric = new GlmapperGeneric&lt;&gt;();</span><br><span class="line">List&lt;String&gt; dest = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Number&gt; src = new ArrayList&lt;&gt;();</span><br><span class="line">glmapperGeneric.testNon(dest,src);</span><br></pre></td></tr></table></figure><p>上面的代码在编译器并不会报错，但是当进入到 testNon 方法内部操作时（比如赋值），对于 dest 和 src 而言，就还是需要进行类型转换。</p><h4 id="区别2：类型参数可以多重限定而通配符不行"><a href="#区别2：类型参数可以多重限定而通配符不行" class="headerlink" title="区别2：类型参数可以多重限定而通配符不行"></a>区别2：类型参数可以多重限定而通配符不行</h4><p><img src="https://user-gold-cdn.xitu.io/2019/8/17/16c9df6a3d2ed69d?w=1492&amp;h=798&amp;f=png&amp;s=149900" alt=""></p><p>使用 &amp; 符号设定多重边界（Multi Bounds)，指定泛型类型 T 必须是 MultiLimitInterfaceA 和 MultiLimitInterfaceB 的共有子类型，此时变量 t 就具有了所有限定的方法和属性。对于通配符来说，因为它不是一个确定的类型，所以不能进行多重限定。</p><h4 id="区别3：通配符可以使用超类限定而类型参数不行"><a href="#区别3：通配符可以使用超类限定而类型参数不行" class="headerlink" title="区别3：通配符可以使用超类限定而类型参数不行"></a>区别3：通配符可以使用超类限定而类型参数不行</h4><p>类型参数 T 只具有 一种 类型限定方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T extends A</span><br></pre></td></tr></table></figure><p>但是通配符 ? 可以进行 两种限定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? extends A</span><br><span class="line">? <span class="keyword">super</span> A</span><br></pre></td></tr></table></figure><h2 id="Class-lt-T-gt-和-Class-lt-gt-区别"><a href="#Class-lt-T-gt-和-Class-lt-gt-区别" class="headerlink" title="Class&lt;T&gt; 和 Class&lt;?&gt; 区别"></a><code>Class&lt;T&gt;</code> 和 <code>Class&lt;?&gt;</code> 区别</h2><p>前面介绍了 ？ 和 T 的区别，那么对于，<code>Class&lt;T&gt;</code> 和 <code>&lt;Class&lt;?&gt;</code> 又有什么区别呢？<br><code>Class&lt;T&gt;</code> 和 <code>Class&lt;?&gt;</code></p><p>最常见的是在反射场景下的使用，这里以用一段发射的代码来说明下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过反射的方式生成  multiLimit </span></span><br><span class="line"><span class="comment">// 对象，这里比较明显的是，我们需要使用强制类型转换</span></span><br><span class="line">MultiLimit multiLimit = (MultiLimit)</span><br><span class="line">Class.forName(<span class="string">"com.glmapper.bridge.boot.generic.MultiLimit"</span>).newInstance();</span><br></pre></td></tr></table></figure><p>对于上述代码，在运行期，如果反射的类型不是 MultiLimit 类，那么一定会报 java.lang.ClassCastException 错误。</p><p>对于这种情况，则可以使用下面的代码来代替，使得在在编译期就能直接 检查到类型的问题：</p><p><img src="https://user-gold-cdn.xitu.io/2019/8/17/16c9df71ab6c3b2d?w=1492&amp;h=533&amp;f=png&amp;s=117676" alt=""></p><p><code>Class&lt;T&gt;</code> 在实例化的时候，T 要替换成具体类。<code>Class&lt;?&gt;</code> 它是个通配泛型，? 可以代表任何类型，所以主要用于声明时的限制情况。比如，我们可以这样做申明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; clazz;</span><br><span class="line"><span class="comment">// 不可以，因为 T 需要指定类型</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;T&gt; clazzT;</span><br></pre></td></tr></table></figure><p>所以当不知道定声明什么类型的 Class 的时候可以定义一 个Class&lt;?&gt;。</p><p><img src="https://user-gold-cdn.xitu.io/2019/8/17/16c9df74ded3221c?w=850&amp;h=91&amp;f=png&amp;s=24562" alt=""></p><p>那如果也想 <code>public Class&lt;T&gt; clazzT;</code> 这样的话，就必须让当前的类也指定 T ，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; clazz;</span><br><span class="line">    <span class="comment">// 不会报错</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;T&gt; clazzT;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文零碎整理了下 JAVA 泛型中的一些点，不是很全，仅供参考。如果文中有不当的地方，欢迎指正。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.toutiao.com/a6694132392728199683" target="_blank" rel="noopener">JAVA泛型通配符T，E，K，V区别，网友回复：一文秒懂</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许开发者在编译时检测到非法
      
    
    </summary>
    
      <category term="java" scheme="http://www.glmapper.com/categories/java/"/>
    
    
      <category term="java" scheme="http://www.glmapper.com/tags/java/"/>
    
      <category term="泛型" scheme="http://www.glmapper.com/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>shell 脚本简单归纳和实践</title>
    <link href="http://www.glmapper.com/2019/08/01/shell-record/"/>
    <id>http://www.glmapper.com/2019/08/01/shell-record/</id>
    <published>2019-08-01T14:14:25.000Z</published>
    <updated>2019-08-01T14:15:43.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="if-条件-OPTION"><a href="#if-条件-OPTION" class="headerlink" title="if 条件 OPTION"></a>if 条件 OPTION</h2><table><thead><tr><th>OPTION</th><th>解释</th></tr></thead><tbody><tr><td>[-a file]</td><td>如果file存在则为真 ，也可以表示为 and: 条件与<br>if [ -z “condition1” -a -z “condition2” ]</td></tr><tr><td>[-b file]</td><td>如果file存在且是一个<strong>块</strong>特殊文件则为真</td></tr><tr><td>[-c file]</td><td>如果file存在且是一个<strong>字</strong>特殊文件则为真</td></tr><tr><td>[-d file]</td><td>如果 file 文件存在且是一个目录则为真，d前的!是逻辑非 <br>#表示目录不存在，则执行后面的 then 操作 <br>if [ ! -d lcd_path/par_date ]</td></tr><tr><td>[-e file]</td><td>如果 file文件存在则为真</td></tr><tr><td>[-f file]</td><td>如果 file 存在且是一个普通文件则为真</td></tr><tr><td>[-g file]</td><td>如果 file 存在且已经设置了SGID则为真（SUID 是 Set User ID, SGID 是 Set Group ID的意思）</td></tr><tr><td>[-h file]</td><td>如果 file 存在且是一个符号连接则为真</td></tr><tr><td>[-k file]</td><td>如果 file 存在且已经设置粘制位则为真</td></tr><tr><td>[-p file]</td><td>如果file存在且是一个名字管道（F如果O）则为真。管道是linux里面进程间通信的一种方式，<br>其他的还有像信号（signal）、信号量、消息队列、共享内存、套接字（socket）等</td></tr><tr><td>[-r file]</td><td>如果file存在且是可读的则为真</td></tr><tr><td>[-s file]</td><td>如果file存在且大小不为0则为真</td></tr><tr><td>[-t FD]</td><td>如果文件描述符FD打开且指向一个终端则为真</td></tr><tr><td>[-u file]</td><td>如果file存在且设置了SUID（set userID）则为真</td></tr><tr><td>[-w file</td><td>如果file存在且是可写的则为真</td></tr><tr><td>[-x file]</td><td>如果file存在且是可执行的则为真</td></tr><tr><td>[-O file]</td><td>如果file存在且属有效用户ID则为真</td></tr><tr><td>[-G file]</td><td>如果file存在且属有效用户组则为真</td></tr><tr><td>[-L file]</td><td>如果file存在且是一个符号连接则为真</td></tr><tr><td>[-N file]</td><td>如果file存在and has been mod如果ied since it was last read则为真</td></tr><tr><td>[-S file]</td><td>如果file存在且是一个套接字则为真</td></tr><tr><td>[-o optionname]</td><td>如果shell选项“optionname”开启则为真</td></tr><tr><td>[-z string]</td><td>“string”的长度为零则为真</td></tr><tr><td>[-n string] or [string]</td><td>“string”的长度为非零non-zero则为真</td></tr></tbody></table><p><a name="hMvnK"></a></p><h2 id="if-基本判断"><a href="#if-基本判断" class="headerlink" title="if 基本判断"></a>if 基本判断</h2><ul><li>[file1 –nt file2] 如果file1 has been changed more recently than file2或者file1 exists and file2 does not则为真 </li><li>[file1 –ot file2] 如果file1比file2要老，或者file2存在且file1不存在则为真 </li><li>[file1 –ef file2] 如果file1和file2指向相同的设备和节点号则为真 </li><li>[sting1==string2] 如果2个字符串相同。“=”may be used instead of “==”for strict posix compliance则为真 </li><li>[string1!=string2] 如果字符串不相等则为真 </li><li>[string1&lt;string2] 如果“string1”sorts before“string2”lexicographically in the current locale则为真 </li><li>[arg1 OP arg2]  “OP”is one of –eq,-ne,-lt,-le,-gt or –ge</li></ul><h2 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h2><ul><li><strong># 号截取，删除左边字符，保留右边字符。 （非贪婪匹配）</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var=http://www.glmapper.com</span><br><span class="line"><span class="comment"># # 号是运算符，*/ 表示从左边开始删除第一个 / 号及左边的所有字符,即删除 http://</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var#*//&#125;</span></span><br><span class="line"><span class="comment">#结果 www.glmapper.com</span></span><br></pre></td></tr></table></figure><ul><li><strong>## 号截取，删除左边字符，保留右边字符。</strong>（贪婪匹配）<em>**</em></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var=http://www.glmapper.com</span><br><span class="line"><span class="comment"># ##*/ 表示从左边开始删除最后（最右边）一个 / 号及左边的所有字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var##*//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果 www.glmapper.com</span></span><br></pre></td></tr></table></figure><ul><li><strong>%号截取，删除右边字符，保留左边字符 </strong>（非贪婪匹配）<em>**</em></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var=http://www.glmapper.com</span><br><span class="line"><span class="comment"># %/* 表示从右边开始，删除第一个 / 号及右边的字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var%/*&#125;</span></span><br><span class="line"><span class="comment"># 结果是：http:/</span></span><br></pre></td></tr></table></figure><ul><li><strong>%% 号截取，删除右边字符，保留左边字符  </strong>（贪婪匹配）<em>**</em></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var=http://www.glmapper.com</span><br><span class="line"><span class="comment"># %%/* 表示从右边开始，删除最后（最左边）一个 / 号及右边的字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var%%/*&#125;</span></span><br><span class="line"><span class="comment"># 结果 ：http:</span></span><br></pre></td></tr></table></figure><ul><li><strong>从左边第几个字符开始，及字符的个数</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var=http://www.glmapper.com</span><br><span class="line"><span class="comment"># 其中的 0 表示左边第一个字符开始，5 表示字符的总个数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:0:5&#125;</span></span><br><span class="line"><span class="comment"># 结果 http:</span></span><br></pre></td></tr></table></figure><ul><li><strong>从左边第几个字符开始，一直到结束</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var=http://www.glmapper.com</span><br><span class="line"><span class="comment"># 其中的 7 表示左边第8个字符开始，一直到结束。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:7&#125;</span></span><br><span class="line"><span class="comment"># 结果 www.glmapper.com</span></span><br></pre></td></tr></table></figure><ul><li><strong>从右边第几个字符开始，及字符的个数</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var=http://www.glmapper.com</span><br><span class="line"><span class="comment"># 其中的 0-3 表示右边算起第3个字符开始，3 表示字符的个数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:0-3:3&#125;</span></span><br><span class="line"><span class="comment"># 结果 com</span></span><br></pre></td></tr></table></figure><ul><li><strong>从右边第几个字符开始，一直到结束</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var=http://www.glmapper.com</span><br><span class="line"><span class="comment"># 表示从右边第 3 个字符开始，一直到结束</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:0-3&#125;</span></span><br><span class="line"><span class="comment"># 结果 com</span></span><br></pre></td></tr></table></figure><blockquote><p>左边的第一个字符是用 0 表示，右边的第一个字符用 0-1 表示</p></blockquote><p><a name="j4jqy"></a></p><h2 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h2><p><a name="N5taV"></a></p><h3 id="basename-命令简介"><a href="#basename-命令简介" class="headerlink" title="basename 命令简介"></a>basename 命令简介</h3><p>去除文件名的目录部分和后缀部分。basename 命令读取 String 参数，删除以 /(斜杠) 结尾的前缀以及任何指定的 Suffix 参数，并将剩余的基本文件名称写至标准输出。basename 和 dirname 命令通常用于 shell 脚本中的命令<strong>替换来指定和指定的输入文件名称有所差异的输出文件名称。</strong><br>**<br>基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">basename NAME [SUFFIX]</span><br><span class="line">basename OPTION</span><br></pre></td></tr></table></figure><p><a name="rCZMr"></a></p><h3 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">basename /usr/bin/sort</span><br><span class="line"><span class="comment"># 返回 sort</span></span><br><span class="line"></span><br><span class="line">basename /usr/bin/sort/glmapper.txt</span><br><span class="line"><span class="comment"># 返回 glmapper.txt</span></span><br></pre></td></tr></table></figure><p><a name="pjCcq"></a></p><h3 id="创建基本文件名称的规则"><a href="#创建基本文件名称的规则" class="headerlink" title="创建基本文件名称的规则"></a>创建基本文件名称的规则</h3><ul><li>如果 String 参数是 //(双斜杠) 或如果 String 参数包含的都是斜杠字符，则将字符串更改为单个 /(斜杠)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">basename //usr//bin//sort//glmapper.txt</span><br><span class="line"><span class="comment"># 返回 glmapper.txt</span></span><br><span class="line"></span><br><span class="line">basename ////</span><br><span class="line"><span class="comment"># 返回 /</span></span><br></pre></td></tr></table></figure><ul><li>从指定字符串除去任何拖尾的 / 字符。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">basename /usr/bin/sort/</span><br><span class="line"><span class="comment"># 返回 sort</span></span><br></pre></td></tr></table></figure><ul><li>如果在 String 参数中剩余任何 / 字符，则除去字符串的前缀直到（包含）最后一个 / 字符。</li><li>如果指定 Suffix 参数，且它和字符串中的剩余的字符相同，则不修改此字符串</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">basename /usr/bin/sort/glmapper.txt glmapper.txt </span><br><span class="line"><span class="comment"># 返回glmapper.txt </span></span><br><span class="line"></span><br><span class="line">basename /usr/bin/sort/glmapper.txt .txt </span><br><span class="line"><span class="comment"># 返回 glmapper</span></span><br></pre></td></tr></table></figure><p><a name="EBlrQ"></a></p><h2 id="shell-查看当前目录下文件的个数"><a href="#shell-查看当前目录下文件的个数" class="headerlink" title="shell 查看当前目录下文件的个数"></a>shell 查看当前目录下文件的个数</h2><p>测试准备，test 目录下有 test1、test2 两个文件夹和一个 1.txt 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="built_in">test</span></span><br><span class="line">├── 1.txt</span><br><span class="line">├── test1</span><br><span class="line">│   └── test1_1.txt</span><br><span class="line">└── test2</span><br></pre></td></tr></table></figure><ul><li>查看当前目录下文件的个数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">test</span> ls -l | grep <span class="string">"^-"</span> | wc -l</span><br><span class="line">   1 <span class="comment"># 1.txt</span></span><br></pre></td></tr></table></figure><ul><li>查看当前目录下文件的个数，包括子目录里的</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">test</span> ls -lR| grep <span class="string">"^-"</span> | wc -l</span><br><span class="line">   2 <span class="comment"># 1.txt  test1_1.txt</span></span><br></pre></td></tr></table></figure><ul><li>查看某目录下文件夹（目录）的个数，包括子目录里的</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">test</span> ls -lR| grep <span class="string">"^d"</span> | wc -l</span><br><span class="line"> 2 <span class="comment"># test1 test2</span></span><br></pre></td></tr></table></figure><ul><li>说明：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、ls -l ：长列表输出该目录下文件信息(注意这里的文件,不同于一般的文件,可能是目录、链接、设备文件等)</span><br><span class="line">2、grep <span class="string">"^-"</span> ：这里将长列表输出信息过滤一部分,只保留一般文件,如果只保留目录就是 ^d</span><br><span class="line">3、wc -l ： 统计输出信息的行数,已经过滤得只剩一般文件了,统计结果就是一般文件信息的行数,</span><br><span class="line">又一行信息对应一个文件,也就是文件的个数</span><br></pre></td></tr></table></figure><p><a name="cOjDe"></a></p><h2 id="利用简单的命令组合实现配置文件的获取"><a href="#利用简单的命令组合实现配置文件的获取" class="headerlink" title="利用简单的命令组合实现配置文件的获取"></a>利用简单的命令组合实现配置文件的获取</h2><p>测试准备，在 1.txt 中 增加两个属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name=glmapper</span><br><span class="line">age=26</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /Users/guolei/logs/<span class="built_in">test</span>/1.txt | sed <span class="string">'s|[[:blank:]]||g'</span> | grep <span class="string">"^name="</span> | cut -d= -f2</span><br><span class="line"><span class="comment"># 返回 glmapper </span></span><br><span class="line"></span><br><span class="line">cat /Users/guolei/logs/<span class="built_in">test</span>/1.txt | sed <span class="string">'s|[[:blank:]]||g'</span> | grep <span class="string">"^age="</span> | cut -d= -f2</span><br><span class="line"><span class="comment"># 返回 26</span></span><br></pre></td></tr></table></figure><p><a name="ok2lo"></a></p><h2 id="函数封装与返回"><a href="#函数封装与返回" class="headerlink" title="函数封装与返回"></a>函数封装与返回</h2><p>以上面的解析配置文件为例，将其封装成一个函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> load_param()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"># 接受的第一个参数是文件地址</span></span><br><span class="line">    <span class="built_in">local</span> properties_file=<span class="variable">$1</span></span><br><span class="line">    <span class="comment"># 接受的第二个参数是属性名</span></span><br><span class="line">    <span class="built_in">local</span> param=<span class="variable">$2</span></span><br><span class="line">    RESULT=`cat <span class="variable">$properties_file</span> | sed <span class="string">'s|[[:blank:]]||g'</span> | grep <span class="string">"^<span class="variable">$param</span>="</span> | cut -d= -f2`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用函数并且获取返回值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">load_param 1.txt name</span><br><span class="line">PROP_VAL=<span class="variable">$RESULT</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PROP_VAL</span></span><br><span class="line"><span class="comment"># 返回 glmapper</span></span><br></pre></td></tr></table></figure><p><a name="QhWTo"></a></p><h2 id="shell-实现日志文件的归档处理"><a href="#shell-实现日志文件的归档处理" class="headerlink" title="shell 实现日志文件的归档处理"></a>shell 实现日志文件的归档处理</h2><p>日志归档简单来说就是，每次希望启动，会将前一次程序运行产生的日志和本地运行产生的日志隔离开来，归档结果就是产生类似于如下的日志文件：</p><ul><li>stdout.log.20170909</li><li>stdout.log.20170709</li><li>stdout</li></ul><p>所以日志文件的归档在生产脚本中是必须要考虑的，否则就到导致每次产生的文件都会被写入同一份日志文件中。下面是实践过程中归纳的一个日志归档函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># archive log</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">archive_log</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> FILE_STDOUT_LOG=<span class="variable">$LOG_ROOT</span>/stdout.log</span><br><span class="line">    <span class="built_in">local</span> FILE_STDERR_LOG=<span class="variable">$LOG_ROOT</span>/stderr.log</span><br><span class="line">    <span class="keyword">if</span> [ ! -e <span class="variable">$LOG_ROOT</span> ] ; <span class="keyword">then</span></span><br><span class="line">        mkdir -p <span class="variable">$LOG_ROOT</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    NOW=`date +%Y%m%d.%H%M%S`</span><br><span class="line">    <span class="comment"># scroll SOFABoot STDOUT log</span></span><br><span class="line">    <span class="keyword">if</span> [ -e <span class="variable">$FILE_STDOUT_LOG</span> ] ; <span class="keyword">then</span></span><br><span class="line">        mv <span class="variable">$FILE_STDOUT_LOG</span> <span class="variable">$FILE_STDOUT_LOG</span>.<span class="variable">$NOW</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># scroll SOFABoot STDERR log</span></span><br><span class="line">    <span class="keyword">if</span> [ -e <span class="variable">$FILE_STDERR_LOG</span> ] ; <span class="keyword">then</span></span><br><span class="line">        mv <span class="variable">$FILE_STDERR_LOG</span> <span class="variable">$FILE_STDERR_LOG</span>.<span class="variable">$NOW</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    FILE_STDOUT_LOG_GLOBAL=<span class="variable">$FILE_STDOUT_LOG</span>;</span><br><span class="line">    FILE_STDERR_LOG_GLOBAL=<span class="variable">$FILE_STDERR_LOG</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="ctqA0"></a></p><h2 id="一个简单的-SOFABoot-启动脚本"><a href="#一个简单的-SOFABoot-启动脚本" class="headerlink" title="一个简单的 SOFABoot 启动脚本"></a>一个简单的 SOFABoot 启动脚本</h2><p>deploy.sh  简单的启动脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LOG_ROOT= <span class="variable">$1</span>;</span><br><span class="line">APP_PATH= <span class="variable">$2</span>;</span><br><span class="line"><span class="comment"># 检查 JAVA_HOME</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$JAVA_HOME</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"JAVA_HOME not set, exit"</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 使用前面的那个日志归档函数</span></span><br><span class="line">archive_log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 java 程序</span></span><br><span class="line">java -jar <span class="variable">$APP_PATH</span> &gt;&gt; <span class="variable">$FILE_STDOUT_LOG_GLOBAL</span> 2&gt;&gt; <span class="variable">$FILE_STDOUT_LOG_GLOBAL</span> &amp;</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh deploy.sh ./logs app.jar</span><br></pre></td></tr></table></figure><p><a name="B97pL"></a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文记录日常中常遇到的 shell 命令，基础知识部分零碎的参考了网上一些同学的博客，在此做了归纳。也欢迎大家指正。如果你有比较骚气的操作，也欢迎评论席留言，我会验证后更新到文章中来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;if-条件-OPTION&quot;&gt;&lt;a href=&quot;#if-条件-OPTION&quot; class=&quot;headerlink&quot; title=&quot;if 条件 OPTION&quot;&gt;&lt;/a&gt;if 条件 OPTION&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;OPTION&lt;/
      
    
    </summary>
    
      <category term="运维" scheme="http://www.glmapper.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="linux" scheme="http://www.glmapper.com/tags/linux/"/>
    
      <category term="shell" scheme="http://www.glmapper.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>一个 maven 插件打包问题的排查</title>
    <link href="http://www.glmapper.com/2019/07/23/maven-debug/"/>
    <id>http://www.glmapper.com/2019/07/23/maven-debug/</id>
    <published>2019-07-23T11:12:48.000Z</published>
    <updated>2019-08-24T00:49:09.800Z</updated>
    
    <content type="html"><![CDATA[<p>最近研究 <a href="https://github.com/sofastack/sofa-ark" target="_blank" rel="noopener">sofa-ark</a> 的插件机制时，发现当执行完 <code>maven clean install -DskipTests</code> 时，打在 target 目录下的 <code>xxx.jar</code> 与安装到本地仓库的 <code>xxx.jar</code> 大小不一致。</p><ul><li><p>target 目录下的插件大小<br>  <img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1c9bc8cf80411?w=1328&amp;h=210&amp;f=png&amp;s=161012" alt=""></p></li><li><p>.m2 下的插件大小</p><p>  <img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1c9d0f3dd11d9?w=1354&amp;h=162&amp;f=png&amp;s=255003" alt=""></p></li></ul><p>其实一开始看到这种现象也是懵逼，同一个工程，同一次命令执行，但是得到的两个 jar 包大小差距巨大。那么对于这种问题，我想到的有两点：</p><ul><li>debug 打包插件执行过程</li><li>了解 maven 插件的生命周期</li></ul><h2 id="debug-打包插件执行过程"><a href="#debug-打包插件执行过程" class="headerlink" title="debug 打包插件执行过程"></a>debug 打包插件执行过程</h2><p>这里需要借助 IDEA 中的远程 debug 能力来完成。目前有两个工程，一个是我们的主工程，工程名为上面截图中的 mq-client-ark-plugin ，另一个是打包插件的源码工程，如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1ca642c08e658?w=2816&amp;h=1480&amp;f=png&amp;s=743986" alt=""></p><p>那么下面就一步一步来完成远程 <code>debug</code> 的配置。</p><h3 id="1、使用-mvnDebug-命令开启-debug-模式"><a href="#1、使用-mvnDebug-命令开启-debug-模式" class="headerlink" title="1、使用 mvnDebug 命令开启 debug 模式"></a>1、使用 mvnDebug 命令开启 debug 模式</h3><p>在主工程 <code>mq-client-ark-plugin</code> 的根目录下执行  <code>mvnDebug install</code>（当然除了 <code>install</code> 之外，也可以是 <code>compile</code>、<code>package</code>、<code>test</code>、<code>deploy</code> 等）。</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1caa278bf23ee?w=1700&amp;h=230&amp;f=png&amp;s=99653" alt=""></p><p>当执行完 <code>mvnDebug install</code> 后，可以看到这个阻塞监听 8000 端口了。</p><h3 id="2、源码工程配置远程-debug"><a href="#2、源码工程配置远程-debug" class="headerlink" title="2、源码工程配置远程 debug"></a>2、源码工程配置远程 debug</h3><p>在 <code>idea</code> 主界面找下下图的工具菜单，选择 <code>Edit Configurations...</code><br><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1cad637854e1d?w=2108&amp;h=254&amp;f=png&amp;s=174555" alt=""><br>打开配置面板之后，左上角 <code>+</code> 选择 <code>Remote</code><br><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1cac7605211e1?w=504&amp;h=132&amp;f=png&amp;s=384137" alt=""><br>填写相关远程 debug 参数</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1cabf223e56be?w=2398&amp;h=802&amp;f=png&amp;s=326272" alt=""></p><ul><li><code>Host</code> : 远程目标主机地址，因为之前 主工程也是本地启动的，所以这里就是 <code>localhost</code></li><li><code>Port</code> : 远程目标主机开启的远程 <code>debug</code> 端口</li><li>开启远程 <code>debug</code> 参数：<code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000</code></li></ul><p>配置完成之后，执行 <code>debug</code> ，可以看下已经连接到了目标机器：</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1cb38a0b44364?w=2500&amp;h=786&amp;f=png&amp;s=312933" alt=""></p><p>在来看主工程这里，在源码工程没有执行上面的 <code>debug</code> 按钮之前，一直都是阻塞的，执行之后 <code>maven</code> 执行的生命周期开始了:<br><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1cb5176a3b954?w=2308&amp;h=1544&amp;f=png&amp;s=1361618" alt=""></p><p>如上图，因为在源码工程中打了断点，所以当执行到 <code>sofa-ark-maven-plugin</code> 插件时阻塞了。</p><h2 id="从-maven-执行的生命周期找出问题根源"><a href="#从-maven-执行的生命周期找出问题根源" class="headerlink" title="从 maven 执行的生命周期找出问题根源"></a>从 maven 执行的生命周期找出问题根源</h2><p>上面已经搞定了对目标插件源码的 <code>debug</code> 模式的开启，那么下面就是对插件代码进行 <code>debug</code> 操作。节省篇幅，这里直接将断点放在目标代码行位置：</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1cb8be741a276?w=2716&amp;h=978&amp;f=png&amp;s=1301147" alt=""></p><p>分析这段代码</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1cbc509cac37a?w=2290&amp;h=256&amp;f=png&amp;s=447587" alt=""></p><ul><li>1、获取到项目的 <code>Artifact</code> ,此时 <code>Artifact</code> 的 <code>file</code> 为：<br><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1cbdc73f415dc?w=1696&amp;h=58&amp;f=png&amp;s=113162" alt=""></li><li>2、重新设置的 <code>File</code></li><li>3、重新设置了 <code>artifact</code></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1cbfc1921d886?w=1520&amp;h=620&amp;f=png&amp;s=512735" alt=""></p><p>如果单从上面 <code>debug</code> 来看，其实很难解释开篇的那个问题。那么这里在回过头来看下 主工程的 <code>maven</code> 执行日志：</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1cc26a8c654a2?w=2440&amp;h=1546&amp;f=png&amp;s=1432324" alt=""></p><p>如上图中圈红的部分，代表 <code>maven install</code> 所经历的所有阶段。可以看到 <code>sofa-ark-plugin-maven-plugin</code> 是在  <code>maven-install-plugin</code> 后面，那这意味着什么呢？</p><p><strong>我们知道在 target 目录下得到的 xxx.jar 是打包阶段的产物，而 .m2 下面的是 install 的产物。</strong></p><blockquote><p>当然这里没有涉及到 <code>deploy</code> ，<code>deploy</code> 是 <code>install</code> 之后的操作，比如发布到远程仓库。</p></blockquote><p>现在再来看，因为 <code>sofa-ark-plugin-maven-plugin</code> 在执行 <code>install</code> 插件之前将 目标文件给替换了，所以导致打包生成的 <code>target</code> 目录下的 <code>xxx.jar</code> 和 安装到本地仓库的 <code>xxx.jar</code> 不一致。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文记录了日常的一个问题排查过程，包括两个小点，一个是如何去 debug maven 的插件，另外一个是简单了解下 maven 打包的生命周期。</p><blockquote><p>关于 maven 打包的生命周期的代码没有具体研究过，不过这里可以大概猜测下，就是 maven 在执行命令时，有个类似于中央控制器的东西，通过解析 maven 命令得到一个 LifeCycle 或者 一个 Pipeline （LifeCycle 或者 Pipeline 实际上就是组装了一系列的插件）。然后 LifeCycle 或者 Pipeline 启动执行，遍历插件，依次执行插件的 execute 方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近研究 &lt;a href=&quot;https://github.com/sofastack/sofa-ark&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sofa-ark&lt;/a&gt; 的插件机制时，发现当执行完 &lt;code&gt;maven clean install 
      
    
    </summary>
    
      <category term="maven" scheme="http://www.glmapper.com/categories/maven/"/>
    
    
      <category term="java" scheme="http://www.glmapper.com/tags/java/"/>
    
      <category term="maven" scheme="http://www.glmapper.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊 JAR 文件和 MANIFEST.MF</title>
    <link href="http://www.glmapper.com/2019/06/30/jar-manifest-intro/"/>
    <id>http://www.glmapper.com/2019/06/30/jar-manifest-intro/</id>
    <published>2019-06-30T01:54:03.000Z</published>
    <updated>2019-06-30T01:58:10.481Z</updated>
    
    <content type="html"><![CDATA[<p>在 JAVA 语言这个圈子里面摸爬滚打，除了对于语言层面和框架层面的学习之外，有一些东西它一直存在，但是确没有对它们有足够的重视，因为都觉得它是理所当然，比如 JAR 是个什么？</p><p>提到 JAR，最先可能想到的就是依赖，比如 fastjson.jar ，它可以作为依赖在项目中来引用，但是不能通过 java -jar 来执行，这种就是非可执行的 JAR。另外一种，比如我们项目打包之后生成的 JAR （当然也可能是 war），我们可以通过 java -jar 来运行程序，我们把它称之为可执行的 JAR。</p><p>JAR 作用大体可以分为以下几种：</p><ul><li>用于发布和使用类库</li><li>作为应用程序和扩展的构建单元</li><li>作为组件、applet 或者插件程序的部署单位</li><li>用于打包与组件相关联的辅助资源</li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>JAR 文件是一种归档文件，以 ZIP 格式构建，以 .jar 为文件扩展名。用户可以使用 JDK 自带的 jar 命令创建或提取 JAR 文件。也可以使用其他 zip 压缩工具，不过压缩时 zip 文件头里的条目顺序很重要，因为 MANIFEST 文件常需放在首位。JAR 文件内的文件名是 Unicode 文本。</p><p>JAR 文件（Java 归档，英语：Java Archive）是一种软件包文件格式，通常用于聚合大量的 Java 类文件、相关的元数据和资源（文本、图片等）文件到一个文件，以便分发 Java 平台应用软件或库。</p><blockquote><p>以上来自维基百科 </p></blockquote><p>JAR 文件格式提供了许多优势和功能，其中很多是传统的压缩格式如 ZIP 或者 TAR 所没有提供的。它们包括：</p><ul><li>安全性：可以对 JAR 文件内容加上数字化签名。这样，能够识别签名的工具就可以有选择地为您授予软件安全特权，这是其他文件做不到的，它还可以检测代码是否被篡改过。</li><li>减少下载时间：如果一个 applet 捆绑到一个 JAR 文件中，那么浏览器就可以在一个 HTTP 事务中下载这个 applet 的类文件和相关的资源，而不是对每一个文件打开一个新连接。</li><li>压缩：JAR 格式允许您压缩文件以提高存储效率。</li><li>传输平台扩展。Java 扩展框架 (Java Extensions Framework) 提供了向 Java 核心平台添加功能的方法，这些扩展是用 JAR 文件打包的 (Java 3D 和 JavaMail 就是由 Sun 开发的扩展例子 )。</li><li>包密封：存储在 JAR 文件中的包可以选择进行 密封，以增强版本一致性和安全性。密封一个包意味着包中的所有类都必须在同一 JAR 文件中找到。</li><li>包版本控制：一个 JAR 文件可以包含有关它所包含的文件的数据，如厂商和版本信息。</li><li>可移植性：处理 JAR 文件的机制是 Java 平台核心 API 的标准部分。</li></ul><h2 id="JAR-文件格式"><a href="#JAR-文件格式" class="headerlink" title="JAR 文件格式"></a>JAR 文件格式</h2><p>这里分别给出两个 JAR 的解压之后的示例</p><h3 id="普通的-JAR-解压之后的文件目录"><a href="#普通的-JAR-解压之后的文件目录" class="headerlink" title="普通的 JAR 解压之后的文件目录"></a>普通的 JAR 解压之后的文件目录</h3><p>以 fastjson 为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── META-INF</span><br><span class="line">│   ├── LICENSE.txt</span><br><span class="line">│   ├── MANIFEST.MF</span><br><span class="line">│   ├── NOTICE.txt</span><br><span class="line">│   ├── maven</span><br><span class="line">│   │   └── com.alibaba</span><br><span class="line">│   │       └── fastjson</span><br><span class="line">│   │           ├── pom.properties</span><br><span class="line">│   │           └── pom.xml</span><br><span class="line">│   └── services</span><br><span class="line">│       ├── javax.ws.rs.ext.MessageBodyReader</span><br><span class="line">│       ├── javax.ws.rs.ext.MessageBodyWriter</span><br><span class="line">│       ├── javax.ws.rs.ext.Providers</span><br><span class="line">│       └── org.glassfish.jersey.internal.spi.AutoDiscoverable</span><br><span class="line">└── com</span><br><span class="line">    └── alibaba</span><br><span class="line">        └── fastjson</span><br><span class="line">            ├── JSON.class</span><br><span class="line">            ├── JSONArray.class</span><br><span class="line">            ├── JSONAware.class</span><br><span class="line">            ├── JSONException.class</span><br><span class="line">            ├── JSONObject.class</span><br><span class="line">            ....省略</span><br></pre></td></tr></table></figure></p><h3 id="可执行的-jar-以-SpringBoot-的-FAT-JAR-为例）"><a href="#可执行的-jar-以-SpringBoot-的-FAT-JAR-为例）" class="headerlink" title="可执行的 jar (以 SpringBoot 的 FAT JAR 为例）"></a>可执行的 jar (以 SpringBoot 的 FAT JAR 为例）</h3><p>这个 jar 是从 start.spring.io 上下载下来的一个最简单的 demo 打包来的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">├── BOOT-INF</span><br><span class="line">│   ├── classes</span><br><span class="line">│   │   ├── application.properties</span><br><span class="line">│   │   └── com</span><br><span class="line">│   │       └── example   # 应用的.class 文件目录</span><br><span class="line">│   │           └── demo</span><br><span class="line">│   │               └── DemoApplication.class</span><br><span class="line">│   └── lib # 这里存放的是应用的 Maven 依赖的jar包文件</span><br><span class="line">│       ├── javax.annotation-api-1.3.2.jar</span><br><span class="line">│       ├── jul-to-slf4j-1.7.26.jar</span><br><span class="line">│       ├── log4j-api-2.11.2.jar</span><br><span class="line">│       ├── log4j-to-slf4j-2.11.2.jar</span><br><span class="line">│       ├── logback-classic-1.2.3.jar</span><br><span class="line">│       ├── logback-core-1.2.3.jar</span><br><span class="line">│       ├── slf4j-api-1.7.26.jar</span><br><span class="line">│       ├── snakeyaml-1.23.jar</span><br><span class="line">│       ├── spring-aop-5.1.8.RELEASE.jar</span><br><span class="line">│       ├── spring-beans-5.1.8.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-2.1.6.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-autoconfigure-2.1.6.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-2.1.6.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-logging-2.1.6.RELEASE.jar</span><br><span class="line">│       ├── spring-context-5.1.8.RELEASE.jar</span><br><span class="line">│       ├── spring-core-5.1.8.RELEASE.jar</span><br><span class="line">│       ├── spring-expression-5.1.8.RELEASE.jar</span><br><span class="line">│       └── spring-jcl-5.1.8.RELEASE.jar</span><br><span class="line">├── META-INF</span><br><span class="line">│   ├── MANIFEST.MF</span><br><span class="line">│   └── maven</span><br><span class="line">│       └── com.example</span><br><span class="line">│           └── demo</span><br><span class="line">│               ├── pom.properties</span><br><span class="line">│               └── pom.xml</span><br><span class="line">└── org</span><br><span class="line">    └── springframework</span><br><span class="line">        └── boot</span><br><span class="line">            └── loader #存放的是 Spring boot loader 的 class 文件</span><br><span class="line">                ├── ExecutableArchiveLauncher.class</span><br><span class="line">                ├── JarLauncher.class</span><br><span class="line">                ├── LaunchedURLClassLoader$UseFastConnectionExceptionsEnumeration.class</span><br><span class="line">                ├── LaunchedURLClassLoader.class</span><br><span class="line">                ├── Launcher.class</span><br><span class="line">                ├── MainMethodRunner.class</span><br><span class="line">                ├── PropertiesLauncher$1.class</span><br><span class="line">                ├── PropertiesLauncher$ArchiveEntryFilter.class</span><br><span class="line">                ├── PropertiesLauncher$PrefixMatchingArchiveFilter.class</span><br><span class="line">                ├── PropertiesLauncher.class</span><br><span class="line">                ├── WarLauncher.class</span><br><span class="line">                ├── archive</span><br><span class="line">                │   ├── Archive$Entry.class</span><br><span class="line">                │   ├── ...</span><br><span class="line">                ├── data</span><br><span class="line">                │   ├── RandomAccessData.class</span><br><span class="line">                │   ├── ...</span><br><span class="line">                ├── jar</span><br><span class="line">                │   ├── AsciiBytes.class</span><br><span class="line">                │   ├── ...</span><br><span class="line">                └── util</span><br><span class="line">                    └── SystemPropertyUtils.class</span><br></pre></td></tr></table></figure><h2 id="META-INF"><a href="#META-INF" class="headerlink" title="META-INF"></a>META-INF</h2><p>大多数 JAR 文件包含一个 META-INF 目录，它用于存储包和扩展的配置数据，如安全性和版本信息。Java 2 平台（标准版【J2SE】）识别并解释 META-INF 目录中的下述文件和目录，以便配置应用程序、扩展和类装载器：</p><ul><li>MANIFEST.MF：这个 manifest 文件定义了与扩展和包相关的数据。</li><li>通过 MAVEN 插件打包进来的文件比如：<ul><li>maven</li><li>services ： 存储所有服务提供程序配置文件</li></ul></li><li>其他的还有一些不常看到的：<ul><li>INDEX.LIST ：这个文件由 jar工具的新选项 -i生成，它包含在应用程序或者扩展中定义的包的位置信息。它是 JarIndex 实现的一部分，并由类装载器用于加速类装载过程。 </li><li>.SF：这是 JAR 文件的签名文件</li><li>.DSA：与签名文件相关联的签名程序块文件，它存储了用于签名 JAR 文件的公共签名。</li><li>LICENSE.txt ：证书信息</li><li>NOTICE.txt ： 公告信息</li></ul></li></ul><h2 id="可执行的-JAR"><a href="#可执行的-JAR" class="headerlink" title="可执行的 JAR"></a>可执行的 JAR</h2><p> 可以执行的 JAR 与 普通的 JAR 最直接的区别就是能否通过 java -jar 来执行。</p><blockquote><p>一个 可执行的 jar文件是一个自包含的 Java 应用程序，它存储在特别配置的 JAR 文件中，可以由 JVM 直接执行它而无需事先提取文件或者设置类路径。要运行存储在非可执行的 JAR 中的应用程序，必须将它加入到您的类路径中，并用名字调用应用程序的主类。但是使用可执行的 JAR 文件，我们可以不用提取它或者知道主要入口点就可以运行一个应用程序。可执行 JAR 有助于方便发布和执行 Java 应用程序</p></blockquote><p> 一个可执行的 JAR 必须通过 menifest 文件的头引用它所需要的所有其他从属 JAR。如果使用了 -jar选项，那么环境变量 CLASSPATH 和在命令行中指定的所有类路径都被 JVM 所忽略。</p><h3 id="MANIFEST-MF-文件"><a href="#MANIFEST-MF-文件" class="headerlink" title="MANIFEST.MF 文件"></a>MANIFEST.MF 文件</h3><p>当我们用 JAR 命令打完包后，会在根目录下面创建 META-INF 目录，该目录下面会有一些对该 JAR 包信息的描述，其中肯定会有一个 MANIFEST.MF 文件，该文件包含了该 JAR 包的版本、创建人和类搜索路径等信息。</p><ul><li><p>FASTJSON jar 中的 MANIFEST.MF 文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0              # 用来定义manifest文件的版本</span><br><span class="line">Archiver-Version: Plexus Archiver  # 详见 http://codehaus-plexus.github.io/plexus-archiver/</span><br><span class="line">Built-By: wenshao                  # 构建者</span><br><span class="line">Created-By: Apache Maven 3.5.0  #  # 声明该文件的生成者，一般该属性是由 jar 命令行工具生成的</span><br><span class="line">Build-Jdk: 1.8.0_162               # 基于构建的 JDK 版本</span><br></pre></td></tr></table></figure></li><li><p>SpringBoot demo 的 MANIFEST.MF 文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Implementation-Title: demo                     # 定义了扩展实现的标题</span><br><span class="line">Implementation-Version: 0.0.1-SNAPSHOT         # 定义扩展实现的版本</span><br><span class="line">Start-Class: com.example.demo.DemoApplication  # 启动类</span><br><span class="line">Spring-Boot-Classes: BOOT-INF/classes/         # 编译之后的 class 文件目录</span><br><span class="line">Spring-Boot-Lib: BOOT-INF/lib/                 # 当前工程依赖的 jar 包目录</span><br><span class="line">Build-Jdk-Spec: 1.8                            # 指定的 JDK 版本</span><br><span class="line">Spring-Boot-Version: 2.1.6.RELEASE             # SpringBoot 版本</span><br><span class="line">Created-By: Maven Archiver 3.4.0             </span><br><span class="line">Main-Class: org.springframework.boot.loader.JarLauncher  # Main 函数</span><br></pre></td></tr></table></figure></li></ul><p>在 Java 平台中， MANIFEST 文件是 JAR 归档中所包含的特殊文件，MANIFEST 文件被用来定义扩展或文件打包相关数据。</p><p>MANIFEST 文件作为一个元数据文件，它包含了不同部分中的 k-v 对数据。</p><p>如果一个 JAR 文件被当作可执行文件，则其中的 MANIFEST 文件需要指出该程序的主类文件，如上面案例中的 SpringBoot demo 的那个 jar 中的MANIFEST 文件所示 </p><h3 id="MANIFEST-作用"><a href="#MANIFEST-作用" class="headerlink" title="MANIFEST 作用"></a>MANIFEST 作用</h3><p>从 MANIFEST 文件中提供的信息大概可以了解到其基本作用</p><ul><li>JAR 包基本信息描述</li><li>Main-Class 指定程序的入口，这样可以直接用java -jar xxx.jar来运行程序</li><li>Class-Path 指定jar包的依赖关系，class loader会依据这个路径来搜索class</li></ul><h3 id="获取-MANIFEST-MF"><a href="#获取-MANIFEST-MF" class="headerlink" title="获取 MANIFEST.MF"></a>获取 MANIFEST.MF</h3><p>JDK 中提供了可以获取 jar 包中 MANIFEST.MF 文件信息的工具，可以通过 java.util.jar 这个类库来获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JarFile jar = <span class="keyword">new</span> JarFile(<span class="keyword">new</span> File(<span class="string">"/Users/glmapper/Documents/test/demo/target/demo-0.0.1-SNAPSHOT.jar"</span>));</span><br><span class="line">Manifest manifest = jar.getManifest();</span><br><span class="line">Attributes mainAttributes = manifest.getMainAttributes();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Object, Object&gt; attrEntry : mainAttributes.entrySet())&#123;</span><br><span class="line">    System.out.println(<span class="string">"main\t"</span>+attrEntry.getKey()+<span class="string">":"</span>+attrEntry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;String, Attributes&gt; entries = manifest.getEntries();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, Attributes&gt; entry : entries.entrySet()) &#123;</span><br><span class="line">    Attributes values = entry.getValue();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; attrEntry : values.entrySet()) &#123;</span><br><span class="line">        System.out.println(attrEntry.getKey() + <span class="string">":"</span> + attrEntry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mainImplementation-Title:demo</span><br><span class="line">mainImplementation-Version:0.0.1-SNAPSHOT</span><br><span class="line">mainStart-Class:com.example.demo.DemoApplication</span><br><span class="line">mainSpring-Boot-Classes:BOOT-INF/classes/</span><br><span class="line">mainSpring-Boot-Lib:BOOT-INF/lib/</span><br><span class="line">mainBuild-Jdk-Spec:1.8</span><br><span class="line">mainSpring-Boot-Version:2.1.6.RELEASE</span><br><span class="line">mainCreated-By:Maven Archiver 3.4.0</span><br><span class="line">mainManifest-Version:1.0</span><br><span class="line">mainMain-Class:org.springframework.boot.loader.JarLauncher</span><br></pre></td></tr></table></figure></p><h2 id="Jar-文件和-Manifest-在-java-中的定义"><a href="#Jar-文件和-Manifest-在-java-中的定义" class="headerlink" title="Jar 文件和 Manifest 在 java 中的定义"></a>Jar 文件和 Manifest 在 java 中的定义</h2><p>下面为 JarFile 的定义，从代码就可以看出，前面我们所介绍的 Jar 是以 ZIP 格式构建一种归档文件，因为它是 ZipFile 的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JarFile</span> <span class="keyword">extends</span> <span class="title">ZipFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SoftReference&lt;Manifest&gt; manRef;</span><br><span class="line">    <span class="keyword">private</span> JarEntry manEntry;</span><br><span class="line">    <span class="keyword">private</span> JarVerifier jv;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> jvInitialized;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> verify;</span><br><span class="line">    <span class="comment">//指示是否存在Class-Path属性（仅当hasCheckedSpecialAttributes为true时才有效）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasClassPathAttribute;</span><br><span class="line">    <span class="comment">// 如果清单检查特殊属性，则为 true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> hasCheckedSpecialAttributes;</span><br><span class="line">    <span class="comment">// 在SharedSecrets中设置JavaUtilJarAccess</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SharedSecrets.setJavaUtilJarAccess(<span class="keyword">new</span> JavaUtilJarAccessImpl());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The JAR manifest file name.（JAR清单文件名）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MANIFEST_NAME = <span class="string">"META-INF/MANIFEST.MF"</span>;</span><br><span class="line">    <span class="comment">// 省略其他</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 Manifest 类的定义，用来描述 JAR 的 清单文件。从其属性中也很好的观察到，其存储的就是 K-V 键值对数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manifest</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// manifest main attributes</span></span><br><span class="line">    <span class="keyword">private</span> Attributes attr = <span class="keyword">new</span> Attributes();</span><br><span class="line">    <span class="comment">// manifest entries</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Attributes&gt; entries = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 省略其他</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>JAR 格式远远超出了一种压缩格式，它有许多可以改进效率、安全性和组织 Java 应用程序的功能。因为这些功能已经建立在核心平台 – 包括编译器和类装载器 – 中了，所以开发人员可以利用 JAR 文件格式的能力简化和改进开发和部署过程。</p><h2 id="附：常见的-jar工具用法"><a href="#附：常见的-jar工具用法" class="headerlink" title="附：常见的 jar工具用法"></a>附：常见的 jar工具用法</h2><table><thead><tr><th style="text-align:left">功能</th><th style="text-align:left">命令</th></tr></thead><tbody><tr><td style="text-align:left">用一个单独的文件创建一个 JAR 文件</td><td style="text-align:left">jar cf jar-file input-file…</td></tr><tr><td style="text-align:left">用一个目录创建一个 JAR 文件</td><td style="text-align:left">jar cf jar-file dir-name</td></tr><tr><td style="text-align:left">创建一个未压缩的 JAR 文件</td><td style="text-align:left">jar cf0 jar-file dir-name</td></tr><tr><td style="text-align:left">更新一个 JAR 文件</td><td style="text-align:left">jar uf jar-file input-file…</td></tr><tr><td style="text-align:left">查看一个 JAR 文件的内容</td><td style="text-align:left">jar tf jar-file</td></tr><tr><td style="text-align:left">提取一个 JAR 文件的内容</td><td style="text-align:left">jar xf jar-file</td></tr><tr><td style="text-align:left">从一个 JAR 文件中提取特定的文件</td><td style="text-align:left">jar xf jar-file archived-file…</td></tr><tr><td style="text-align:left">运行一个打包为可执行 JAR 文件的应用程序</td><td style="text-align:left">java -jar app.jar</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-jar/index.html" target="_blank" rel="noopener">JAR 文件揭密</a></li><li><a href="https://zh.wikipedia.org/wiki/JAR_(%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F" target="_blank" rel="noopener">JAR</a>)</li><li><a href="https://docs.oracle.com/javase/6/docs/technotes/guides/jar/jar.html" target="_blank" rel="noopener">JAR File Specification</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 JAVA 语言这个圈子里面摸爬滚打，除了对于语言层面和框架层面的学习之外，有一些东西它一直存在，但是确没有对它们有足够的重视，因为都觉得它是理所当然，比如 JAR 是个什么？&lt;/p&gt;
&lt;p&gt;提到 JAR，最先可能想到的就是依赖，比如 fastjson.jar ，它可以作
      
    
    </summary>
    
      <category term="java 基础" scheme="http://www.glmapper.com/categories/java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://www.glmapper.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-关于 CAS 的几个问题</title>
    <link href="http://www.glmapper.com/2019/04/29/cas-several-qa/"/>
    <id>http://www.glmapper.com/2019/04/29/cas-several-qa/</id>
    <published>2019-04-29T02:25:57.000Z</published>
    <updated>2019-04-29T02:28:01.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CAS-相关基础知识"><a href="#CAS-相关基础知识" class="headerlink" title="CAS 相关基础知识"></a>CAS 相关基础知识</h2><p>CAS的全称是Compare And Swap ,即比较交换。CAS 中一般会设计到3个参数:</p><ul><li>内存值 V</li><li>旧的预期值A</li><li>要修改的新值B</li></ul><p>当且仅当预期值 A 和内存值 V 相同时，将内存值V修改为 B，否则什么都不做。</p><blockquote><p>这里关于 CPU 指令对于 CAS 的支持不深入研究,有兴趣的可以自行了解。</p></blockquote><h2 id="CAS-几个问题"><a href="#CAS-几个问题" class="headerlink" title="CAS 几个问题"></a>CAS 几个问题</h2><p>很多书籍和文章中都有提出它存在的几个问题：</p><ul><li>1、循环时间长开销很大</li><li>2、只能保证一个共享变量的原子操作</li><li>3、ABA 问题</li></ul><p>下面就这三个问题展开来聊一下。</p><h3 id="1、关于“循环时间长开销很大”的疑惑与验证"><a href="#1、关于“循环时间长开销很大”的疑惑与验证" class="headerlink" title="1、关于“循环时间长开销很大”的疑惑与验证"></a>1、关于“循环时间长开销很大”的疑惑与验证</h3><p>自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的开销。但是真的是这样吗？到底多大的并发量才造成 CAS 的自旋次数会增加呢？另外，对于当前的机器及JDK，在无锁，无CAS 的情况下，是否对于结果的影响是真的那么明显呢？对于这个问题，下面做了一个简单的测试，但是测试结果也只是针对在我本地环境下，各位看官可以拉一下代码，在自己电脑上 run 一下，把机器信息、JDK版本以及测试结果留言到评论区。</p><blockquote><p>本文案例可以这里获取：<a href="https://github.com/glmapper/glmapper-blog-samples/tree/master/glmapper-blog-sample-cas" target="_blank" rel="noopener">glmapper-blog-sample-cas</a></p></blockquote><p>这里我是用了一个很简单的案例，就是整数自增。使用了两种方式去测试的，一种是无锁，也不用 CAS 操作，另外一种是基于 CAS 的方式。（关于加锁的方式没有验证，有时间再补充吧~）</p><h4 id="计数器类"><a href="#计数器类" class="headerlink" title="计数器类"></a>计数器类</h4><p>计数器里面有两个方法，一种是CAS 自旋方式，一种是直接自增。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> AtomicInteger safeCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> unsafe = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 使用自旋的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">safeCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = safeCount.get();</span><br><span class="line">            <span class="keyword">boolean</span> success = safeCount.compareAndSet(i,++i);</span><br><span class="line">            <span class="keyword">if</span> (success)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 普通方式自增</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsafeCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        unsafe++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="模拟并发"><a href="#模拟并发" class="headerlink" title="模拟并发"></a>模拟并发</h4><p>这里我们模拟使用 1000 个线程，执行 30 次来看下结果，包括总耗时和结果的正确性。</p><ul><li><p>CAS 方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testSafe</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 实例化一个 Counter 计数器对象</span></span><br><span class="line">    Counter counter = <span class="keyword">new</span> Counter();</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(testCounts);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ;i &lt; testCounts;i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="comment">// 调用 safeCount 方法</span></span><br><span class="line">                counter. safeCount();</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    <span class="comment">// 结束时间</span></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    safeTotalCostTime += (end-start);</span><br><span class="line">    <span class="keyword">return</span> counter.safeCount.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>普通方式</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testUnSafe</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 实例化一个 Counter 计数器对象</span></span><br><span class="line">    Counter counter = <span class="keyword">new</span> Counter();</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(testCounts);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt; testCounts;i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">// 调用 unsafeCount 方法</span></span><br><span class="line">            counter.unsafeCount();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    <span class="comment">// 结束时间</span></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    unsafeTotalCostTime += (end-start);</span><br><span class="line">    <span class="keyword">return</span> counter.unsafe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>main 方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    // 执行 300 次</span><br><span class="line">    for (int i =0 ;i&lt; 300;i++)&#123;</span><br><span class="line">        // 普通方式</span><br><span class="line">        int unSafeResult = testUnSafe();</span><br><span class="line">        // cas 方式</span><br><span class="line">        int safeResult = testSafe();</span><br><span class="line">        // 结果验证，若果正确就将成功次数增加</span><br><span class="line">        if (unSafeResult == testCounts)&#123;</span><br><span class="line">            totalUnSafeCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 同上</span><br><span class="line">        if (safeResult == testCounts)&#123;</span><br><span class="line">            totalSafeCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;test count = &quot; + testCounts);</span><br><span class="line">    System.out.println(&quot;非安全计数器正确个数 = &quot; + totalUnSafeCount);</span><br><span class="line">    System.out.println(&quot;非安全计数器耗时 = &quot; + unsafeTotalCostTime);</span><br><span class="line">    System.out.println(&quot;安全计数器正确个数 = &quot; + totalSafeCount);</span><br><span class="line">    System.out.println(&quot;安全计数器耗时 = &quot; + safeTotalCostTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的机器信息如下：</p><ul><li>MacBook Pro (Retina, 15-inch, Mid 2015)</li><li>处理器：2.2 GHz Intel Core i7</li><li>内存：16 GB 1600 MHz DDR3</li></ul><p>下面是一些测试数据。</p><h4 id="1000-线程数-300-次数"><a href="#1000-线程数-300-次数" class="headerlink" title="1000(线程数) * 300(次数)"></a>1000(线程数) * 300(次数)</h4><p>测试结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test count = 1000</span><br><span class="line">非安全计数器正确个数 = 300</span><br><span class="line">非安全计数器耗时 = 27193</span><br><span class="line">安全计数器正确个数 = 300</span><br><span class="line">安全计数器耗时 = 26337</span><br></pre></td></tr></table></figure></p><p>居然发现不使用 CAS 的方式居然比使用自旋 CAS 的耗时要高出将近 1s。另外一个意外的点，我尝试了好几次，不使用 CAS 的情况得到的结果正确率基本也是 4 个 9  以上的比率，极少数会出现计算结果错误的情况。</p><h4 id="3000-线程数-30-次数"><a href="#3000-线程数-30-次数" class="headerlink" title="3000(线程数) * 30(次数)"></a>3000(线程数) * 30(次数)</h4><p>测试结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test count = 3000</span><br><span class="line">非安全计数器正确个数 = 30</span><br><span class="line">非安全计数器耗时 = 7816</span><br><span class="line">安全计数器正确个数 = 30</span><br><span class="line">安全计数器耗时 = 8073</span><br></pre></td></tr></table></figure></p><p>这里看到在耗时上已经很接近了。这里需要考虑另外一个可能影响的点是，因为 testUnSafe 是 testSafe 之前执行的，“JVM 和 机器本身热身” 影响耗时虽然很小，但是也存在一定的影响。</p><h4 id="5000-线程数-30-次数"><a href="#5000-线程数-30-次数" class="headerlink" title="5000(线程数) * 30(次数)"></a>5000(线程数) * 30(次数)</h4><p>测试结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test count = 5000</span><br><span class="line">非安全计数器正确个数 = 30</span><br><span class="line">非安全计数器耗时 = 23213</span><br><span class="line">安全计数器正确个数 = 30</span><br><span class="line">安全计数器耗时 = 14161</span><br></pre></td></tr></table></figure></p><p>随着并发量的增加，这里奇怪的是，普通自增方式所消耗的时间要高于CAS方式消耗的时间将近 8-9s 。</p><p>当尝试 10000 次时，是的你没猜错，抛出了 OOM 。但是从执行的结果来看，并没有说随着并发量的增大，普通方式错误的概率会增加，也没有出现预想的 CAS 方式的耗时要比 普通模式耗时多。</p><blockquote><p>由于测试样本数据比较单一，对于测试结果没法做结论，欢迎大家将各自机器的结果提供出来，以供参考。另外就是，最近看到很多面试的同学，如果有被问道这个问题，还是需要谨慎考虑下。关于是否“打脸”还是“被打脸”还需要更多的测试结果。</p></blockquote><h3 id="CAS-到底是怎么操作的"><a href="#CAS-到底是怎么操作的" class="headerlink" title="CAS 到底是怎么操作的"></a>CAS 到底是怎么操作的</h3><ul><li>CPU 指令</li><li>Unsafe 类 </li></ul><h3 id="2、ABA-问题的简单复现"><a href="#2、ABA-问题的简单复现" class="headerlink" title="2、ABA 问题的简单复现"></a>2、ABA 问题的简单复现</h3><p>网上关于 CAS 讨论另外一个点就是 CAS 中的 ABA 问题，相信大多数同学在面试时如果被问到 CAS ，那么 ABA 问题也会被问到，然后接着就是怎么避免这个问题，是的套路就是这么一环扣一环的。</p><p>我相信 90% 以上的开发人员在实际的工程中是没有遇到过这个问题的，即使遇到过，在特定的情况下也是不会影响到计算结果。但是既然这个问题会被反复提到，那就一定有它导致 bug 的场景，找了一个案例供大家参考：<a href="https://blog.csdn.net/wufaliang003/article/details/78797203" target="_blank" rel="noopener">CAS下ABA问题及优化方案</a> 。</p><p>这里先不去考虑怎么去规避这个问题，我们想怎么去通过简单的模拟先来复现这个 ABA 问题。其实这个也很简单，如果你对线程交叉、顺序执行了解的话。</p><h3 id="如何实现多线程的交叉执行"><a href="#如何实现多线程的交叉执行" class="headerlink" title="如何实现多线程的交叉执行"></a>如何实现多线程的交叉执行</h3><p>这个点实际上也是一个在面试过程中很常见的一个基础问题，我在提供的代码中给了三种实现方式，有兴趣的同学可以拉代码看下。</p><p>下面以 lock 的方式来模拟下这个场景，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionAlternateTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计数器</span></span><br><span class="line">    <span class="keyword">public</span> AtomicInteger safeCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// lock</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// condition 1/2/3 用于三个线程触发执行的条件</span></span><br><span class="line">    Condition c1 = lock.newCondition();</span><br><span class="line">    Condition c2 = lock.newCondition();</span><br><span class="line">    Condition c3 = lock.newCondition();</span><br><span class="line">    <span class="comment">// 模拟并发执行</span></span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 线程1 ，A </span></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (count % <span class="number">3</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            safeCount.compareAndSet(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"thread1:"</span>+safeCount.get());</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 唤醒条件2</span></span><br><span class="line">            c2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">     <span class="comment">// 线程2 ，B </span></span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (count % <span class="number">3</span> != <span class="number">1</span>)&#123;</span><br><span class="line">                c2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            safeCount.compareAndSet(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">"thread2:"</span>+safeCount.get());</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 唤醒条件3</span></span><br><span class="line">            c3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 线程2 ，A</span></span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (count % <span class="number">3</span> != <span class="number">2</span>)&#123;</span><br><span class="line">                c3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            safeCount.compareAndSet(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"thread3:"</span>+safeCount.get());</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 唤醒条件1</span></span><br><span class="line">            c1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 启动启动线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        t3.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ConditionAlternateTest test = <span class="keyword">new</span> ConditionAlternateTest();</span><br><span class="line">        test.threadStart();</span><br><span class="line">        test.countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread1:<span class="number">1</span></span><br><span class="line">thread2:<span class="number">0</span></span><br><span class="line">thread3:<span class="number">1</span></span><br></pre></td></tr></table></figure><p>上面线程交叉的案例实际上并不是严格意义上的 ABA 问题的复现，这里仅是模拟下产生的一个最简单的过程。如果大家有好的案例，也可以分享一下。</p><h3 id="ABA-问题解决"><a href="#ABA-问题解决" class="headerlink" title="ABA 问题解决"></a>ABA 问题解决</h3><p>常见实践：“版本号”的比对，一个数据一个版本，版本变化，即使值相同，也不应该修改成功。</p><p>java 中提供了 AtomicStampedReference 这个类来解决这个 ABA 问题。<br>AtomicStampedReference 原子类是一个带有时间戳的对象引用，在每次修改后，AtomicStampedReference 不仅会设置新值而且还会记录更改的时间。当 AtomicStampedReference 设置对象值时，对象值以及时间戳都必须满足期望值才能写入成功，这也就解决了反复读写时，无法预知值是否已被修改的窘境。</p><p>实现代码这里就不贴了，基于前面的代码改造，下面贴一下运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread1,第一次修改;值为=1</span><br><span class="line">thread2,已经改回为原始值;值为=0</span><br><span class="line">thread3,第二次修改;值为=1</span><br></pre></td></tr></table></figure></p><h3 id="3、只能保证一个共享变量的原子操作"><a href="#3、只能保证一个共享变量的原子操作" class="headerlink" title="3、只能保证一个共享变量的原子操作"></a>3、只能保证一个共享变量的原子操作</h3><p>当对一个共享变量执行操作时，我们可以使用 CAS 的方式来保证原子操作，但是对于对多个变量操作时，循环 CAS 就无法保证操作的原子性了，那么这种场景下，我们就需要使用加锁的方式来解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CAS-相关基础知识&quot;&gt;&lt;a href=&quot;#CAS-相关基础知识&quot; class=&quot;headerlink&quot; title=&quot;CAS 相关基础知识&quot;&gt;&lt;/a&gt;CAS 相关基础知识&lt;/h2&gt;&lt;p&gt;CAS的全称是Compare And Swap ,即比较交换。CAS 中一般
      
    
    </summary>
    
      <category term="java 基础" scheme="http://www.glmapper.com/categories/java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://www.glmapper.com/tags/java/"/>
    
      <category term="cas" scheme="http://www.glmapper.com/tags/cas/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 系列-事件机制详解</title>
    <link href="http://www.glmapper.com/2019/04/13/springboot-series-event/"/>
    <id>http://www.glmapper.com/2019/04/13/springboot-series-event/</id>
    <published>2019-04-13T14:55:41.000Z</published>
    <updated>2019-12-09T01:09:40.767Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>微信公众号：<strong><a href="#jump_10">glmapper工作室</a></strong><br>掘金专栏：<a href="https://juejin.im/user/58fcc0768d6d810058965a06" target="_blank" rel="noopener">glmapper</a><br>微          博：<a href="https://weibo.com/u/2412872703" target="_blank" rel="noopener">疯狂的石头_henu</a><br>欢迎关注，一起学习、一起分享</p></blockquote><p>在这篇文章中<a href="https://juejin.im/post/5b7964d6f265da43412866c7" target="_blank" rel="noopener">聊一聊 Spring 中的扩展机制（一）</a>中对<code>Spring</code>中的事件机制进行了分析。那么对于 <code>SpringBoot</code> 来说，它在 <code>Spring</code> 的基础上又做了哪些拓展呢？本篇将来聊一聊 <code>SpringBoot</code> 中的事件。</p><p>在 SpringBoot 的启动过程中，会通过 SPI 机制去加载 spring.factories 下面的一些类，这里面就包括了事件相关的类。</p><ul><li><p>SpringApplicationRunListener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Run Listeners</span><br><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">org.springframework.boot.context.event.EventPublishingRunListener</span><br></pre></td></tr></table></figure></li><li><p>ApplicationListener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.ClearCachesApplicationListener,\</span><br><span class="line">org.springframework.boot.builder.ParentContextCloserApplicationListener,\</span><br><span class="line">org.springframework.boot.context.FileEncodingApplicationListener,\</span><br><span class="line">org.springframework.boot.context.config.AnsiOutputApplicationListener,\</span><br><span class="line">org.springframework.boot.context.config.ConfigFileApplicationListener,\</span><br><span class="line">org.springframework.boot.context.config.DelegatingApplicationListener,\</span><br><span class="line">org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\</span><br><span class="line">org.springframework.boot.context.logging.LoggingApplicationListener,\</span><br><span class="line">org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener</span><br></pre></td></tr></table></figure><p><code>SpringApplicationRunListener</code> 类是 <code>SpringBoot</code> 中新增的类。<code>SpringApplication</code> 类 中使用它们来间接调用 <code>ApplicationListener</code>。另外还有一个新增的类是<code>SpringApplicationRunListeners</code>，<code>SpringApplicationRunListeners</code> 中包含了多个 <code>SpringApplicationRunListener</code>。</p><h2 id="SpringApplicationRunListener"><a href="#SpringApplicationRunListener" class="headerlink" title="SpringApplicationRunListener"></a>SpringApplicationRunListener</h2><p><code>SpringApplicationRunListener</code> 接口规定了 <code>SpringBoot</code> 的生命周期，在各个生命周期广播相应的事件，调用实际的 <code>ApplicationListener</code> 类。通过对 <code>SpringApplicationRunListener</code> 的分析，也可以对 <code>SpringBoot</code> 的整个启动过程的理解会有很大帮助。</p><p>先来看下<code>SpringApplicationRunListener</code> 接口的代码：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpringApplicationRunListener</span> </span>&#123;</span><br><span class="line"><span class="comment">//当run方法首次启动时立即调用。可用于非常早期的初始化。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//在准备好环境后，但在创建ApplicationContext之前调用。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span></span>;</span><br><span class="line"><span class="comment">//在创建和准备好ApplicationContext之后，但在加载源之前调用。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"><span class="comment">//在加载应用程序上下文后但刷新之前调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"><span class="comment">//上下文已刷新，应用程序已启动，但尚未调用commandlinerunner和applicationrunner。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">started</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"><span class="comment">//在运行方法完成之前立即调用，此时应用程序上下文已刷新，</span></span><br><span class="line"><span class="comment">//并且所有commandlinerunner和applicationrunner都已调用。</span></span><br><span class="line"><span class="comment">//2.0 才有</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">running</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"><span class="comment">//在运行应用程序时发生故障时调用。2.0 才有</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringApplicationRunListeners"><a href="#SpringApplicationRunListeners" class="headerlink" title="SpringApplicationRunListeners"></a>SpringApplicationRunListeners</h2><p>上面提到，<code>SpringApplicationRunListeners</code> 是<code>SpringApplicationRunListener</code>的集合，里面包括了很多<code>SpringApplicationRunListener</code>实例；<code>SpringApplication</code> 类实际上使用的是 <code>SpringApplicationRunListeners</code> 类，与 <code>SpringApplicationRunListener</code> 生命周期相同，调用各个周期的 <code>SpringApplicationRunListener</code> 。然后广播相应的事件到 <code>ApplicationListener</code>。</p><blockquote><p>代码详见：<a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/SpringApplicationRunListeners.java" target="_blank" rel="noopener">SpringApplicationRunListeners</a>.</p></blockquote><h3 id="EventPublishingRunListener"><a href="#EventPublishingRunListener" class="headerlink" title="EventPublishingRunListener"></a>EventPublishingRunListener</h3><p><code>EventPublishingRunListener</code> 类是 <code>SpringApplicationRunListener</code>接口的实现类 ，它具有广播事件的功能。其内部使用 <code>ApplicationEventMulticaster</code>在实际刷新上下文之前发布事件。下面来看下 <code>EventPublishingRunListener</code> 类生命周期对应的事件。</p><h3 id="ApplicationStartingEvent"><a href="#ApplicationStartingEvent" class="headerlink" title="ApplicationStartingEvent"></a>ApplicationStartingEvent</h3><p><code>ApplicationStartingEvent</code> 是 <code>SpringBoot</code> 启动开始的时候执行的事件，在该事件中可以获取到 <code>SpringApplication</code> 对象，可做一些执行前的设置，对应的调用方法是 <code>starting()</code>。</p><h3 id="ApplicationEnvironmentPreparedEvent"><a href="#ApplicationEnvironmentPreparedEvent" class="headerlink" title="ApplicationEnvironmentPreparedEvent"></a>ApplicationEnvironmentPreparedEvent</h3><p><code>ApplicationEnvironmentPreparedEvent</code> 是<code>SpringBoot</code> 对应 <code>Enviroment</code> 已经准备完毕时执行的事件，此时上下文 <code>context</code> 还没有创建。在该监听中获取到 <code>ConfigurableEnvironment</code> 后可以对配置信息做操作，例如：修改默认的配置信息，增加额外的配置信息等。对应的生命周期方法是 <code>environmentPrepared(environment)</code>；<code>SpringCloud</code> 中，引导上下文就是在这时初始化的。</p><h3 id="ApplicationContextInitializedEvent"><a href="#ApplicationContextInitializedEvent" class="headerlink" title="ApplicationContextInitializedEvent"></a>ApplicationContextInitializedEvent</h3><p>当 <code>SpringApplication</code> 启动并且准备好 <code>ApplicationContext</code>，并且在加载任何 <code>bean</code> 定义之前调用了 <code>ApplicationContextInitializers</code> 时发布的事件。对应的生命周期方法是<code>contextPrepared()</code></p><h3 id="ApplicationPreparedEvent"><a href="#ApplicationPreparedEvent" class="headerlink" title="ApplicationPreparedEvent"></a>ApplicationPreparedEvent</h3><p><code>ApplicationPreparedEvent</code> 是<code>SpringBoot</code>上下文 <code>context</code> 创建完成是发布的事件；但此时 <code>spring</code> 中的 <code>bean</code> 还没有完全加载完成。这里可以将上下文传递出去做一些额外的操作。但是在该监听器中是无法获取自定义 <code>bean</code> 并进行操作的。对应的生命周期方法是 <code>contextLoaded()</code>。</p><h3 id="ApplicationStartedEvent"><a href="#ApplicationStartedEvent" class="headerlink" title="ApplicationStartedEvent"></a>ApplicationStartedEvent</h3><p>这个事件是在 2.0 版本才引入的；具体发布是在应用程序上下文刷新之后，调用任何 <code>ApplicationRunner</code> 和 <code>CommandLineRunner</code> 运行程序之前。</p><h3 id="ApplicationReadyEvent"><a href="#ApplicationReadyEvent" class="headerlink" title="ApplicationReadyEvent"></a>ApplicationReadyEvent</h3><p>这个和 <code>ApplicationStartedEvent</code> 很类似，也是在应用程序上下文刷新之后之后调用，区别在于此时<code>ApplicationRunner</code> 和 <code>CommandLineRunner</code>已经完成调用了，也意味着 <code>SpringBoot</code> 加载已经完成。</p><h3 id="ApplicationFailedEvent"><a href="#ApplicationFailedEvent" class="headerlink" title="ApplicationFailedEvent"></a>ApplicationFailedEvent</h3><p><code>SpringBoot</code> 启动异常时执行的事件，在异常发生时，最好是添加虚拟机对应的钩子进行资源的回收与释放，能友善的处理异常信息。</p><h3 id="demo-及各个事件的执行顺序"><a href="#demo-及各个事件的执行顺序" class="headerlink" title="demo 及各个事件的执行顺序"></a>demo 及各个事件的执行顺序</h3><p>下面的各个事件对应的demo及打印出来的执行顺序。</p><ul><li><p>GlmapperApplicationStartingEventListener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperApplicationStartingEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationStartingEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationStartingEvent applicationStartingEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"execute ApplicationStartingEvent ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>GlmapperApplicationEnvironmentPreparedEvent</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperApplicationEnvironmentPreparedEvent</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEnvironmentPreparedEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEnvironmentPreparedEvent applicationEnvironmentPreparedEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"execute ApplicationEnvironmentPreparedEvent ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>GlmapperApplicationContextInitializedEvent</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperApplicationContextInitializedEvent</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationContextInitializedEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationContextInitializedEvent applicationContextInitializedEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"execute applicationContextInitializedEvent ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>GlmapperApplicationPreparedEvent</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class GlmapperApplicationPreparedEvent implements ApplicationListener&lt;ApplicationPreparedEvent&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(ApplicationPreparedEvent applicationPreparedEvent) &#123;</span><br><span class="line">        System.out.println(&quot;execute ApplicationPreparedEvent ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>GlmapperApplicationStartedEvent</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperApplicationStartedEvent</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationStartedEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationStartedEvent applicationStartedEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"execute ApplicationStartedEvent ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>GlmapperApplicationReadyEvent</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperApplicationReadyEvent</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationReadyEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationReadyEvent applicationReadyEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"execute ApplicationReadyEvent ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行结果</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/1/1680822d81776a67?w=2620&amp;h=806&amp;f=png&amp;s=354682" alt=""></p><h2 id="SpringBoot-中的事件体系"><a href="#SpringBoot-中的事件体系" class="headerlink" title="SpringBoot 中的事件体系"></a>SpringBoot 中的事件体系</h2><p>这里围绕 <code>SpringApplicationRunListener</code> 这个类来说。在实现类 <code>EventPublishingRunListener</code> 中，事件发布有两种模式：</p><ul><li>通过 <code>SimpleApplicationEventMulticaster</code> 进行事件广播</li><li>所有监听器交给相应的 <code>Context</code></li></ul><p>所以<code>EventPublishingRunListener</code> 不仅负责发布事件，而且在合适的时机将 <code>SpringApplication</code> 所获取的监听器和应用上下文作关联。</p><h3 id="SimpleApplicationEventMulticaster"><a href="#SimpleApplicationEventMulticaster" class="headerlink" title="SimpleApplicationEventMulticaster"></a>SimpleApplicationEventMulticaster</h3><p><code>SimpleApplicationEventMulticaster</code>是 <code>Spring</code> 默认的事件广播器。来看下它是怎么工作的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, @Nullable ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">        Executor executor = getTaskExecutor();</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 异步的</span></span><br><span class="line">            executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码段可以看出，它是通过遍历注册的每个监听器，并启动来调用每个监听器的 <code>onApplicationEvent</code> 方法。</p><p>下面再来看下 <code>SimpleApplicationEventMulticaster</code> 的类集成结构：<br><img src="https://user-gold-cdn.xitu.io/2019/1/1/1680830a7fd2c4b5?w=1434&amp;h=602&amp;f=png&amp;s=59215" alt=""><br>这里的 <code>AbstractApplicationContext</code> 下面来聊，这个类实际上就负责了事件体系的初始化工作。</p><h3 id="事件体系的初始化"><a href="#事件体系的初始化" class="headerlink" title="事件体系的初始化"></a>事件体系的初始化</h3><p>事件体系的初始化对应在 <code>SpringBoot</code>启动过程的 <code>refreshContext</code>这个方法；<code>refreshContext</code>具体调用 AbstractApplicationContext.refresh()方法，最后调用 initApplicationEventMulticaster() 来完成事件体系的初始化,代码如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/1/1680835fb264f84a?w=1618&amp;h=696&amp;f=png&amp;s=223928" alt=""></p><p>用户可以为容器定义一个自定义的事件广播器，只要实现 <code>ApplicationEventMulticaster</code> 就可以了，<code>Spring</code> 会通过 反射的机制将其注册成容器的事件广播器，如果没有找到配置的外部事件广播器，<code>Spring</code> 就是默认使用 <code>SimpleApplicationEventMulticaster</code> 作为事件广播器。</p><h3 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h3><p>事件注册是在事件体系初始化完成之后做的事情，也是在 <code>AbstractApplicationContext.refresh()</code> 方法中进行调用的。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/1/16808437ea8623d2?w=1760&amp;h=786&amp;f=png&amp;s=200511" alt=""><br>这里干了三件事：</p><ul><li>首先注册静态指定的 <code>listeners</code>；这里包括我们自定义的那些监听器。</li><li>调用 <code>DefaultListableBeanFactory</code> 中 <code>getBeanNamesForType</code> 得到自定义的 <code>ApplicationListener</code> <code>bean</code> 进行事件注册。</li><li>广播早期的事件。</li></ul><h3 id="事件广播"><a href="#事件广播" class="headerlink" title="事件广播"></a>事件广播</h3><p>事件发布伴随着 <code>SpringBoot</code> 启动的整个生命周期。不同阶段对应发布不同的事件，上面我们已经对各个事件进行了分析，下面就具体看下发布事件的实现：</p><blockquote><p>org.springframework.context.support.AbstractApplicationContext#publishEvent<br><img src="https://user-gold-cdn.xitu.io/2019/1/1/168084a716c01856?w=1344&amp;h=1002&amp;f=png&amp;s=210096" alt=""></p></blockquote><blockquote><p>earlyApplicationEvents 中的事件是广播器未建立的时候保存通知信息，一旦容器建立完成，以后都是直接通知。</p></blockquote><p>广播事件最终还是通过调用 <code>ApplicationEventMulticaster</code> 的 <code>multicastEvent</code> 来实现。而 <code>multicastEvent</code> 也就就是事件执行的方法。</p><h3 id="事件执行"><a href="#事件执行" class="headerlink" title="事件执行"></a>事件执行</h3><p>上面 <code>SimpleApplicationEventMulticaster</code> 小节已经初步介绍了 <code>multicastEvent</code> 这个方法。补充一点， 如果有可用的 <code>taskExecutor</code> 会使用并发的模式执行事件，但是实际上 <code>SimpleApplicationEventMulticaster</code> 并没有提供线程池实现，默认请况下是使用同步的方式执行事件（<code>org.springframework.core.task.SyncTaskExecutor</code>），所以如果需要异步配置的话，需要自己去实现线程池。</p><h2 id="SpringBoot-启动过程中的事件阶段"><a href="#SpringBoot-启动过程中的事件阶段" class="headerlink" title="SpringBoot 启动过程中的事件阶段"></a>SpringBoot 启动过程中的事件阶段</h2><p>这里回到 <code>SpringApplication</code>的<code>run</code>方法，看下 <code>SpringBoot</code> 在启动过程中，各个事件阶段做了哪些事情。</p><h3 id="starting-gt-ApplicationStartingEvent"><a href="#starting-gt-ApplicationStartingEvent" class="headerlink" title="starting -&gt; ApplicationStartingEvent"></a>starting -&gt; ApplicationStartingEvent</h3><p>这里 <code>debug</code> 到 <code>starting</code> 方法，追踪到 <code>multicastEvent</code>，这里 <code>type</code>为 <code>ApplicationStartingEvent</code>；对应的事件如下：<br><img src="https://user-gold-cdn.xitu.io/2019/1/1/16808657f6db440c?w=1206&amp;h=232&amp;f=png&amp;s=70540" alt=""></p><ul><li>LoggerApplicationListener：配置日志系统。使用<code>logging.config</code>环境变量指定的配置或者缺省配置</li><li>BackgroundPreinitializer：尽早触发一些耗时的初始化任务，使用一个后台线程</li><li>DelegatingApplicationListener：监听到事件后转发给环境变量<code>context.listener.classes</code>指定的那些事件监听器</li><li>LiquibaseServiceLocatorApplicationListener：使用一个可以和 <code>SpringBoot</code> 可执行<code>jar</code>包配合工作的版本替换 <code>liquibase ServiceLocator</code></li></ul><h3 id="listeners-environmentPrepared-gt-ApplicationEnvironmentPreparedEvent"><a href="#listeners-environmentPrepared-gt-ApplicationEnvironmentPreparedEvent" class="headerlink" title="listeners.environmentPrepared-&gt;ApplicationEnvironmentPreparedEvent"></a>listeners.environmentPrepared-&gt;ApplicationEnvironmentPreparedEvent</h3><p><img src="https://user-gold-cdn.xitu.io/2019/1/1/16808703538f4265?w=1336&amp;h=354&amp;f=png&amp;s=109143" alt=""></p><ul><li>AnsiOutputApplicationListener：根据<code>spring.output.ansi.enabled</code>参数配置<code>AnsiOutput</code></li><li><p>ConfigFileApplicationListener：<code>EnvironmentPostProcessor</code>，从常见的那些约定的位置读取配置文件，比如从以下目录读取<code>application.properties</code>,<code>application.yml</code>等配置文件：</p><ul><li>classpath:</li><li>file:.</li><li>classpath:config</li><li><p>file:./config/</p><p>也可以配置成从其他指定的位置读取配置文件。</p></li></ul></li><li>ClasspathLoggingApplicationListener：对环境就绪事件<code>ApplicationEnvironmentPreparedEvent</code>/应用失败事<code>件ApplicationFailedEvent</code>做出响应，往日志<code>DEBUG</code>级别输出<code>TCCL(thread context class loader)</code>的 <code>classpath</code>。</li><li>FileEncodingApplicationListener：如果系统文件编码和环境变量中指定的不同则终止应用启动。具体的方法是比较系统属性<code>file.encoding</code>和环境变量<code>spring.mandatory-file-encoding</code>是否相等(大小写不敏感)。</li></ul><h3 id="listeners-contextPrepared-gt-ApplicationContextInitializedEvent"><a href="#listeners-contextPrepared-gt-ApplicationContextInitializedEvent" class="headerlink" title="listeners.contextPrepared-&gt;ApplicationContextInitializedEvent"></a>listeners.contextPrepared-&gt;ApplicationContextInitializedEvent</h3><p><img src="https://user-gold-cdn.xitu.io/2019/1/1/1680877bed3cfbbd?w=1112&amp;h=148&amp;f=png&amp;s=49908" alt=""><br>相关监听器参考上面的描述。</p><h3 id="listeners-contextLoaded-gt-ApplicationPreparedEvent"><a href="#listeners-contextLoaded-gt-ApplicationPreparedEvent" class="headerlink" title="listeners.contextLoaded-&gt;ApplicationPreparedEvent"></a>listeners.contextLoaded-&gt;ApplicationPreparedEvent</h3><p><img src="https://user-gold-cdn.xitu.io/2019/1/1/168087a73a7666bd?w=1122&amp;h=232&amp;f=png&amp;s=71270" alt=""><br>相关监听器参考上面的描述。</p><h3 id="refresh-gt-ContextRefreshedEvent"><a href="#refresh-gt-ContextRefreshedEvent" class="headerlink" title="refresh-&gt;ContextRefreshedEvent"></a>refresh-&gt;ContextRefreshedEvent</h3><p><img src="https://user-gold-cdn.xitu.io/2019/1/1/168087bc9054d773?w=1324&amp;h=234&amp;f=png&amp;s=77283" alt=""></p><ul><li>ConditionEvaluationReportLoggingListener：实际上实现的是 <code>ApplicationContextInitializer</code>接口，其目的是将 <code>ConditionEvaluationReport</code> 写入到日志，使用<code>DEBUG</code>级别输出。程序崩溃报告会触发一个消息输出，建议用户使用调试模式显示报告。它是在应用初始化时绑定一个<code>ConditionEvaluationReportListener</code>事件监听器，然后相应的事件发生时输出<code>ConditionEvaluationReport</code>报告。</li><li>ClearCachesApplicationListener：应用上下文加载完成后对缓存做清除工作，响应事件<code>ContextRefreshedEvent</code>。</li><li>SharedMetadataReaderFactoryContextInitializer：　向<code>context</code>注册了一个<code>BeanFactoryPostProcessor</code>：<code>CachingMetadataReaderFactoryPostProcessor</code>实例。</li><li>ResourceUrlProvider：<code>handling mappings</code>处理</li></ul><h3 id="started-gt-ApplicationStartedEvent"><a href="#started-gt-ApplicationStartedEvent" class="headerlink" title="started-&gt;ApplicationStartedEvent"></a>started-&gt;ApplicationStartedEvent</h3><p><img src="https://user-gold-cdn.xitu.io/2019/1/1/168088a3a77dae6d?w=1142&amp;h=160&amp;f=png&amp;s=51171" alt=""><br>相关监听器参考上面的描述。</p><h3 id="running-gt-ApplicationReadyEvent"><a href="#running-gt-ApplicationReadyEvent" class="headerlink" title="running-&gt;ApplicationReadyEvent"></a>running-&gt;ApplicationReadyEvent</h3><p><img src="https://user-gold-cdn.xitu.io/2019/1/1/168088b04deff509?w=974&amp;h=194&amp;f=png&amp;s=62237" alt=""><br>相关监听器参考上面的描述。</p><h3 id="BackgroundPreinitializer-amp-DelegatingApplicationListener"><a href="#BackgroundPreinitializer-amp-DelegatingApplicationListener" class="headerlink" title="BackgroundPreinitializer&amp;DelegatingApplicationListener"></a>BackgroundPreinitializer&amp;DelegatingApplicationListener</h3><p>这两个贯穿了整个过程，这里拎出来单独解释下：</p><ul><li>BackgroundPreinitializer：对于一些耗时的任务使用一个后台线程尽早触发它们开始执行初始化，这是<code>SpringBoot</code>的缺省行为。这些初始化动作也可以叫做预初始化。可以通过设置系统属性<code>spring.backgroundpreinitializer.ignore</code>为<code>true</code>可以禁用该机制。该机制被禁用时，相应的初始化任务会发生在前台线程。</li><li>DelegatingApplicationListener：监听应用事件，并将这些应用事件广播给环境属性<code>context.listener.classes</code>指定的那些监听器。</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到此，<code>SpringBoot</code> 中的事件相关的东西就结束了。本文从<code>SpringApplicationRunListener</code>这个类说起，接着介绍 <code>SpringBoot</code> 启动过程的事件以及事件的生命周期。最后介绍了 <code>SpringBoot</code>中的内置的这些 监听器在启动过程中对应的各个阶段。</p><p>新年伊始，祝大家新年快乐！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/andy_zhang2007/article/details/84105284" target="_blank" rel="noopener">https://blog.csdn.net/andy_zhang2007/article/details/84105284</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;&lt;a href=&quot;#jump_10&quot;&gt;glmapper工作室&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;掘金专栏：&lt;a href=&quot;https://juejin.im/user/58fcc0768d6d810058965a06&quot; 
      
    
    </summary>
    
      <category term="springboot" scheme="http://www.glmapper.com/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://www.glmapper.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper 客户端之 Curator</title>
    <link href="http://www.glmapper.com/2019/04/13/zookeeper-client-curator/"/>
    <id>http://www.glmapper.com/2019/04/13/zookeeper-client-curator/</id>
    <published>2019-04-13T14:09:30.000Z</published>
    <updated>2019-08-24T00:50:59.747Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="http://www.glmapper.com/2019/04/13/zookeeper-client-curator/">ZooKeeper 客户端之 Curator</a></p></blockquote><p>ZooKeeper 是一个分布式的、开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现。它是集群的管理者，监视着集群中各个节点的状态，根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p><p>Curator 是 Netflix 公司开源的一套  Zookeeper 客户端框架，解决了很多 Zookeeper 客户端非常底层的细节开发工作，包括连接重连、反复注册 Watcher 和 NodeExistsException 异常等等。Curator 包含了几个包：</p><ul><li>curator-framework：对 Zookeeper 的底层 api 的一些封装</li><li>curator-client：提供一些客户端的操作，例如重试策略等</li><li>curator-recipes：封装了一些高级特性，如：Cache 事件监听、选举、分布式锁、分布式计数器、分布式Barrier 等</li></ul><h2 id="Curator-和-zookeeper-的版本问题"><a href="#Curator-和-zookeeper-的版本问题" class="headerlink" title="Curator 和 zookeeper 的版本问题"></a>Curator 和 zookeeper 的版本问题</h2><p>目前 Curator 有 2.x.x 和 3.x.x 两个系列的版本，支持不同版本的 Zookeeper。其中Curator 2.x.x 兼容 Zookeeper的 3.4.x 和 3.5.x。而 Curator 3.x.x 只兼容 Zookeeper 3.5.x，并且提供了一些诸如动态重新配置、watch删除等新特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Curator 2.x.x - compatible with both ZooKeeper 3.4.x and ZooKeeper 3.5.x</span><br><span class="line">Curator 3.x.x - compatible only with ZooKeeper 3.5.x and includes support for new</span><br></pre></td></tr></table></figure><p>如果跨版本会有兼容性问题，很有可能导致节点操作失败，当时在使用的时候就踩了这个坑，抛了如下的异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KeeperErrorCode = Unimplemented for /***</span><br></pre></td></tr></table></figure><h2 id="Curator-API"><a href="#Curator-API" class="headerlink" title="Curator   API"></a>Curator   API</h2><p>这里就不对比与原生 API 的区别了，Curator 的 API 直接通过 org.apache.curator.framework.CuratorFramework 接口来看，并结合相应的案例进行使用，以备后用。</p><blockquote><p>为了可以直观的看到 Zookeeper 的节点信息，可以考虑弄一个 zk 的管控界面，常见的有 zkui 和 zkweb。</p><p>zkui：<a href="https://github.com/DeemOpen/zkui" target="_blank" rel="noopener">https://github.com/DeemOpen/zkui</a></p><p>zkweb：<a href="https://github.com/zhitom/zkweb" target="_blank" rel="noopener">https://github.com/zhitom/zkweb</a></p><p>我用的 zkweb ，虽然界面上看起来没有 zkui 精简，但是在层次展示和一些细节上感觉比 zkui 好一点</p></blockquote><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>之前写的一个在 <a href="http://www.glmapper.com/2019/03/04/zk-on-linux">Linux 上安装部署 Zookeeper</a> 的笔记，其他操作系统请自行谷歌教程吧。</p><p>本文案例工程已经同步到了 github，<a href="https://github.com/glmapper/glmapper-blog-samples" target="_blank" rel="noopener">传送门</a>。</p><blockquote><p>PS : 目前还没有看过Curator的具体源码，所以不会涉及到任何源码解析、实现原理的东西；本篇主要是实际使用时的一些记录，以备后用。如果文中错误之处，希望各位指出。</p></blockquote><h2 id="Curator-客户端的初始化和初始化时机"><a href="#Curator-客户端的初始化和初始化时机" class="headerlink" title="Curator 客户端的初始化和初始化时机"></a>Curator 客户端的初始化和初始化时机</h2><p>在实际的工程中，Zookeeper 客户端的初始化会在程序启动期间完成。</p><h3 id="初始化时机"><a href="#初始化时机" class="headerlink" title="初始化时机"></a>初始化时机</h3><p>在 Spring 或者 SpringBoot 工程中最常见的就是绑定到容器启动的生命周期或者应用启动的生命周期中：</p><ul><li>监听 ContextRefreshedEvent 事件，在容器刷新完成之后初始化 Zookeeper</li><li>监听 ApplicationReadyEvent/ApplicationStartedEvent 事件，初始化 Zookeeper 客户端</li></ul><p>除了上面的方式之外，还有一种常见的是绑定到 bean 的生命周期中</p><ul><li>实现 InitializingBean 接口 ，在 afterPropertiesSet 中完成 Zookeeper 客户端初始化</li></ul><blockquote><p>关于 SpringBoot中的事件机制可以参考之前写过的一篇文章：<a href="https://juejin.im/post/5c2af8915188252a94130422#heading-8" target="_blank" rel="noopener">SpringBoot-SpringBoot中的事件机制</a>。</p></blockquote><h3 id="Curator-初始化"><a href="#Curator-初始化" class="headerlink" title="Curator 初始化"></a>Curator 初始化</h3><p>这里使用 InitializingBean 的这种方式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperCuratorClient</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CuratorFramework curatorClient;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;glmapper.zookeeper.address:localhost:2181&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String           connectString;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;glmapper.zookeeper.baseSleepTimeMs:1000&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>              baseSleepTimeMs;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;glmapper.zookeeper.maxRetries:3&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>              maxRetries;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;glmapper.zookeeper.sessionTimeoutMs:6000&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>              sessionTimeoutMs;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;glmapper.zookeeper.connectionTimeoutMs:6000&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>              connectionTimeoutMs;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// custom policy</span></span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(baseSleepTimeMs, maxRetries);</span><br><span class="line">        <span class="comment">// to build curatorClient</span></span><br><span class="line">        curatorClient = CuratorFrameworkFactory.builder().connectString(connectString)</span><br><span class="line">                .sessionTimeoutMs(sessionTimeoutMs).connectionTimeoutMs(connectionTimeoutMs)</span><br><span class="line">                .retryPolicy(retryPolicy).build();</span><br><span class="line">        curatorClient.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CuratorFramework <span class="title">getCuratorClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curatorClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>glmapper.zookeeper.xxx 是本例中需要在配置文件中配置的 zookeeper 的一些参数，参数解释如下：</p><ul><li>baseSleepTimeMs：重试之间等待的初始时间</li><li>maxRetries：最大重试次数</li><li>connectString：要连接的服务器列表</li><li>sessionTimeoutMs：session 超时时间</li><li>connectionTimeoutMs：连接超时时间</li></ul><p>另外，Curator 客户端初始化时还需要指定重试策略，RetryPolicy 接口是 Curator 中重试连接(当zookeeper失去连接时使用)策略的顶级接口，其类继承体系如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/13/16a17065aa98b194?w=1024&amp;h=302&amp;f=png&amp;s=73757" alt=""></p><ul><li>RetryOneTime：只重连一次</li><li>RetryNTime：指定重连的次数N</li><li>RetryUtilElapsed：指定最大重连超时时间和重连时间间隔，间歇性重连直到超时或者链接成功</li><li>ExponentialBackoffRetry：基于 “backoff”方式重连，和 RetryUtilElapsed 的区别是重连的时间间隔是动态的。</li><li>BoundedExponentialBackoffRetry： 同 ExponentialBackoffRetry的区别是增加了最大重试次数的控制</li></ul><p>除上述之外，在一些场景中，需要对不同的业务进行隔离，这种情况下，可以通过设置 namespace 来解决，namespace 实际上就是指定zookeeper的根路径，设置之后，后面的所有操作都会基于该根目录。</p><h2 id="Curator-基础-API-使用"><a href="#Curator-基础-API-使用" class="headerlink" title="Curator 基础 API 使用"></a>Curator 基础 API 使用</h2><h3 id="检查节点是否存在"><a href="#检查节点是否存在" class="headerlink" title="检查节点是否存在"></a>检查节点是否存在</h3><p>checkExists 方法返回的是一个 ExistsBuilder 构造器，这个构建器将返回一个 Stat 对象，就像调用了 org.apache.zookeeper.ZooKeeper.exists()一样。null 表示它不存在，而实际的 Stat 对象表示存在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkNodeExist</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Stat stat = curatorClient.checkExists().forPath(path);</span><br><span class="line">    <span class="keyword">if</span> (stat != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"path = "</span>+path +<span class="string">" has bean exist."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议在实际的应用中，操作节点时对所需操作的节点进行 checkExists。</p><h3 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h3><ul><li><p>非递归方式创建节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.create().forPath(&quot;/glmapper&quot;);</span><br><span class="line">curatorClient.create().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure><p>先创建/glmapper，然后再在/glmapper 下面创建 /test ，如果直接使用 /glmapper/test 没有先创建 /glmapper 时，会抛出异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.zookeeper.KeeperException$NoNodeException: KeeperErrorCode = NoNode for /glmapper/test</span><br></pre></td></tr></table></figure><p>如果需要在创建节点时指定节点中数据，则可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.create().forPath(&quot;/glmapper&quot;,&quot;data&quot;.getBytes());</span><br></pre></td></tr></table></figure><p>指定节点类型(EPHEMERAL 临时节点)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.create().withMode(CreateMode.EPHEMERAL).forPath(&quot;/glmapper&quot;,&quot;data&quot;.getBytes());</span><br></pre></td></tr></table></figure></li><li><p>递归方式创建节点</p><p>递归方式创建节点有两个方法，creatingParentsIfNeeded 和 creatingParentContainersIfNeeded。在新版本的 zookeeper 这两个递归创建方法会有区别； creatingParentContainersIfNeeded() 以容器模式递归创建节点，如果旧版本 zookeeper，此方法等于creatingParentsIfNeeded()。</p><p>在非递归方式情况下，如果直接创建 /glmapper/test 会报错，那么在递归的方式下则是可以的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.create().creatingParentContainersIfNeeded().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure><p>在递归调用中，如果不指定 CreateMode，则默认<code>PERSISTENT</code>，如果指定为临时节点，则最终节点会是临时节点，父节点仍旧是<code>PERSISTENT</code></p></li></ul><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><ul><li><p>非递归删除节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.delete().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure><p>指定具体版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.delete().withVersion(-1).forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure><p>使用 guaranteed 方式删除，guaranteed 会保证在session有效的情况下，后台持续进行该节点的删除操作，直到删除掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.delete().guaranteed().withVersion(-1).forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure></li><li><p>递归删除当前节点及其子节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.delete().deletingChildrenIfNeeded().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="获取节点数据"><a href="#获取节点数据" class="headerlink" title="获取节点数据"></a>获取节点数据</h3><p>获取节点数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte[] data = curatorClient.getData().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure><p>根据配置的压缩提供程序对数据进行解压缩处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte[] data = curatorClient.getData().decompressed().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure><p>读取数据并获得Stat信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stat stat = new Stat();</span><br><span class="line">byte[] data = curatorClient.getData().storingStatIn(stat).forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure><h3 id="更新节点数据"><a href="#更新节点数据" class="headerlink" title="更新节点数据"></a>更新节点数据</h3><p>设置指定值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.setData().forPath(&quot;/glmapper/test&quot;,&quot;newData&quot;.getBytes());</span><br></pre></td></tr></table></figure><p>设置数据并使用配置的压缩提供程序压缩数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.setData().compressed().forPath(&quot;/glmapper/test&quot;,&quot;newData&quot;.getBytes());</span><br></pre></td></tr></table></figure><p>设置数据，并指定版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.setData().withVersion(-1).forPath(&quot;/glmapper/test&quot;,&quot;newData&quot;.getBytes());</span><br></pre></td></tr></table></figure><h3 id="获取子列表"><a href="#获取子列表" class="headerlink" title="获取子列表"></a>获取子列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; childrenList = curatorClient.getChildren().forPath(&quot;/glmapper&quot;);</span><br></pre></td></tr></table></figure><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>Curator 也对 Zookeeper 典型场景之事件监听进行封装，这部分能力实在 curator-recipes 包下的。</p><h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><p>在使用不同的方法时会有不同的事件发生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CuratorEventType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Corresponds to &#123;@link CuratorFramework#create()&#125;</span></span><br><span class="line">    CREATE,</span><br><span class="line">    <span class="comment">//Corresponds to &#123;@link CuratorFramework#delete()&#125;</span></span><br><span class="line">    DELETE,</span><br><span class="line"><span class="comment">//Corresponds to &#123;@link CuratorFramework#checkExists()&#125;</span></span><br><span class="line">    EXISTS,</span><br><span class="line"><span class="comment">//Corresponds to &#123;@link CuratorFramework#getData()&#125;</span></span><br><span class="line">    GET_DATA,</span><br><span class="line"><span class="comment">//Corresponds to &#123;@link CuratorFramework#setData()&#125;</span></span><br><span class="line">    SET_DATA,</span><br><span class="line"><span class="comment">//Corresponds to &#123;@link CuratorFramework#getChildren()&#125;</span></span><br><span class="line">    CHILDREN,</span><br><span class="line"><span class="comment">//Corresponds to &#123;@link CuratorFramework#sync(String, Object)&#125;</span></span><br><span class="line">    SYNC,</span><br><span class="line"><span class="comment">//Corresponds to &#123;@link CuratorFramework#getACL()&#125;</span></span><br><span class="line">    GET_ACL,</span><br><span class="line"><span class="comment">//Corresponds to &#123;@link CuratorFramework#setACL()&#125;</span></span><br><span class="line">    SET_ACL,</span><br><span class="line"><span class="comment">//Corresponds to &#123;@link Watchable#usingWatcher(Watcher)&#125; or &#123;@link Watchable#watched()&#125;</span></span><br><span class="line">    WATCHED,</span><br><span class="line"><span class="comment">//Event sent when client is being closed</span></span><br><span class="line">    CLOSING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><h4 id="一次性监听方式：Watcher"><a href="#一次性监听方式：Watcher" class="headerlink" title="一次性监听方式：Watcher"></a>一次性监听方式：Watcher</h4><p>利用 Watcher 来对节点进行监听操作，可以典型业务场景需要使用可考虑，但一般情况不推荐使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">byte</span>[] data = curatorClient.getData().usingWatcher(<span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"监听器 watchedEvent："</span> + watchedEvent);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;).forPath(<span class="string">"/glmapper/test"</span>);</span><br><span class="line">System.out.println(<span class="string">"监听节点内容："</span> + <span class="keyword">new</span> String(data));</span><br><span class="line"><span class="comment">// 第一次变更节点数据</span></span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test"</span>,<span class="string">"newData"</span>.getBytes());</span><br><span class="line"><span class="comment">// 第二次变更节点数据</span></span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test"</span>,<span class="string">"newChangedData"</span>.getBytes());</span><br></pre></td></tr></table></figure><p>上面这段代码对 /glmapper/test 节点注册了一个 Watcher 监听事件，并且返回当前节点的内容。后面进行两次数据变更，实际上第二次变更时，监听已经失效，无法再次获得节点变动事件了。测试中控制台输出的信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">监听节点内容：data</span><br><span class="line">watchedEvent：WatchedEvent state:SyncConnected type:NodeDataChanged path:/glmapper/test</span><br></pre></td></tr></table></figure><h4 id="CuratorListener-方式"><a href="#CuratorListener-方式" class="headerlink" title="CuratorListener 方式"></a>CuratorListener 方式</h4><p>CuratorListener 监听，此监听主要针对 background 通知和错误通知。使用此监听器之后，调用inBackground 方法会异步获得监听，对于节点的创建或修改则不会触发监听事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CuratorListener listener = <span class="keyword">new</span> CuratorListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eventReceived</span><span class="params">(CuratorFramework client, CuratorEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"event : "</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="comment">// 绑定监听器</span></span><br><span class="line">curatorClient.getCuratorListenable().addListener(listener);</span><br><span class="line"><span class="comment">// 异步获取节点数据</span></span><br><span class="line">curatorClient.getData().inBackground().forPath(<span class="string">"/glmapper/test"</span>);</span><br><span class="line"><span class="comment">// 更新节点数据</span></span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test"</span>,<span class="string">"newData"</span>.getBytes());</span><br></pre></td></tr></table></figure><p>测试中控制台输出的信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">event : CuratorEventImpl&#123;type=GET_DATA, resultCode=0, path=&apos;/glmapper/test&apos;, name=&apos;null&apos;, children=null, context=null, stat=5867,5867,1555140974671,1555140974671,0,0,0,0,4,0,5867</span><br><span class="line">, data=[100, 97, 116, 97], watchedEvent=null, aclList=null&#125;</span><br></pre></td></tr></table></figure><p>这里只触发了一次监听回调，就是 getData 。</p><h4 id="Curator-引入的-Cache-事件监听机制"><a href="#Curator-引入的-Cache-事件监听机制" class="headerlink" title="Curator 引入的 Cache 事件监听机制"></a>Curator 引入的 Cache 事件监听机制</h4><p>Curator 引入了 Cache 来实现对 Zookeeper 服务端事件监听，Cache 事件监听可以理解为一个本地缓存视图与远程 Zookeeper 视图的对比过程。Cache 提供了反复注册的功能。Cache 分为两类注册类型：节点监听和子节点监听。</p><ul><li><p>NodeCache</p><p>监听数据节点本身的变化。对节点的监听需要配合回调函数来进行处理接收到监听事件之后的业务处理。NodeCache 通过 NodeCacheListener 来完成后续处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String path = <span class="string">"/glmapper/test"</span>;</span><br><span class="line"><span class="keyword">final</span> NodeCache nodeCache = <span class="keyword">new</span> NodeCache(curatorClient,path);</span><br><span class="line"><span class="comment">//如果设置为true则在首次启动时就会缓存节点内容到Cache中。 nodeCache.start(true);</span></span><br><span class="line">nodeCache.start();</span><br><span class="line">nodeCache.getListenable().addListener(<span class="keyword">new</span> NodeCacheListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"触发监听回调，当前节点数据为："</span> + <span class="keyword">new</span> String(nodeCache.getCurrentData().getData()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">curatorClient.setData().forPath(path,<span class="string">"1"</span>.getBytes());</span><br><span class="line">curatorClient.setData().forPath(path,<span class="string">"2"</span>.getBytes());</span><br><span class="line">curatorClient.setData().forPath(path,<span class="string">"3"</span>.getBytes());</span><br><span class="line">curatorClient.setData().forPath(path,<span class="string">"4"</span>.getBytes());</span><br><span class="line">curatorClient.setData().forPath(path,<span class="string">"5"</span>.getBytes());</span><br><span class="line">curatorClient.setData().forPath(path,<span class="string">"6"</span>.getBytes());</span><br></pre></td></tr></table></figure><p>注意：在测试过程中，nodeCache.start()，NodeCache 在先后多次修改监听节点的内容时，出现了丢失事件现象，在用例执行的5次中，仅一次监听到了全部事件；如果 nodeCache.start(true)，NodeCache 在先后多次修改监听节点的内容时，不会出现丢失现象。</p><blockquote><p>NodeCache不仅可以监听节点内容变化，还可以监听指定节点是否存在。如果原本节点不存在，那么Cache就会在节点被创建时触发监听事件，如果该节点被删除，就无法再触发监听事件。</p></blockquote></li><li><p>PathChildrenCache</p><p>PathChildrenCache 不会对二级子节点进行监听，只会对子节点进行监听。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">String path = <span class="string">"/glmapper"</span>;</span><br><span class="line">PathChildrenCache pathChildrenCache = <span class="keyword">new</span> PathChildrenCache(curatorClient,path,<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 如果设置为true则在首次启动时就会缓存节点内容到Cache中。 nodeCache.start(true);</span></span><br><span class="line">pathChildrenCache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);</span><br><span class="line">pathChildrenCache.getListenable().addListener(<span class="keyword">new</span> PathChildrenCacheListener() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework curatorFramework, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"-----------------------------"</span>);</span><br><span class="line">    System.out.println(<span class="string">"event:"</span>  + event.getType());</span><br><span class="line">    <span class="keyword">if</span> (event.getData()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      System.out.println(<span class="string">"path:"</span> + event.getData().getPath());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"-----------------------------"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">zookeeperCuratorClient.createNode(<span class="string">"/glmapper/test"</span>,<span class="string">"data"</span>.getBytes(),CreateMode.PERSISTENT);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test"</span>,<span class="string">"1"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test"</span>,<span class="string">"2"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">zookeeperCuratorClient.createNode(<span class="string">"/glmapper/test/second"</span>,<span class="string">"data"</span>.getBytes(),CreateMode.PERSISTENT);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test/second"</span>,<span class="string">"1"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test/second"</span>,<span class="string">"2"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>注意：在测试过程中发现，如果连续两个操作之间不进行一定时间的间隔，会导致无法监听到下一次事件。因此只会监听子节点，所以对二级子节点 /second 下面的操作是监听不到的。测试中控制台输出的信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------</span><br><span class="line">event:CHILD_ADDED</span><br><span class="line">path:/glmapper/test</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:INITIALIZED</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:CHILD_UPDATED</span><br><span class="line">path:/glmapper/test</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:CHILD_UPDATED</span><br><span class="line">path:/glmapper/test</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure></li><li><p>TreeCache</p><p>TreeCache 使用一个内部类<code>TreeNode</code>来维护这个一个树结构。并将这个树结构与ZK节点进行了映射。所以TreeCache 可以监听当前节点下所有节点的事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String path = <span class="string">"/glmapper"</span>;</span><br><span class="line">TreeCache treeCache = <span class="keyword">new</span> TreeCache(curatorClient,path);</span><br><span class="line">treeCache.getListenable().addListener((client,event)-&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"-----------------------------"</span>);</span><br><span class="line">    System.out.println(<span class="string">"event:"</span>  + event.getType());</span><br><span class="line">    <span class="keyword">if</span> (event.getData()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      System.out.println(<span class="string">"path:"</span> + event.getData().getPath());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"-----------------------------"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">treeCache.start();</span><br><span class="line">zookeeperCuratorClient.createNode(<span class="string">"/glmapper/test"</span>,<span class="string">"data"</span>.getBytes(),CreateMode.PERSISTENT);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test"</span>,<span class="string">"1"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test"</span>,<span class="string">"2"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">zookeeperCuratorClient.createNode(<span class="string">"/glmapper/test/second"</span>,<span class="string">"data"</span>.getBytes(),CreateMode.PERSISTENT);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test/second"</span>,<span class="string">"1"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test/second"</span>,<span class="string">"2"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>测试中控制台输出的信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------</span><br><span class="line">event:NODE_ADDED</span><br><span class="line">path:/glmapper</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:NODE_ADDED</span><br><span class="line">path:/glmapper/test</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:NODE_UPDATED</span><br><span class="line">path:/glmapper/test</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:NODE_UPDATED</span><br><span class="line">path:/glmapper/test</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:NODE_ADDED</span><br><span class="line">path:/glmapper/test/second</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:NODE_UPDATED</span><br><span class="line">path:/glmapper/test/second</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:NODE_UPDATED</span><br><span class="line">path:/glmapper/test/second</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure></li></ul><h2 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h2><p> CuratorFramework 的实例包含 inTransaction( ) 接口方法，调用此方法开启一个 ZooKeeper 事务。 可以复合create、 setData、 check、and/or delete 等操作然后调用 commit() 作为一个原子操作提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启事务  </span></span><br><span class="line">CuratorTransaction curatorTransaction = curatorClient.inTransaction();</span><br><span class="line">Collection&lt;CuratorTransactionResult&gt; commit = </span><br><span class="line">  <span class="comment">// 操作1 </span></span><br><span class="line">curatorTransaction.create().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">"/glmapper/transaction"</span>)</span><br><span class="line">  .and()</span><br><span class="line">  <span class="comment">// 操作2 </span></span><br><span class="line">  .delete().forPath(<span class="string">"/glmapper/test"</span>)</span><br><span class="line">  .and()</span><br><span class="line">  <span class="comment">// 操作3</span></span><br><span class="line">  .setData().forPath(<span class="string">"/glmapper/transaction"</span>, <span class="string">"data"</span>.getBytes())</span><br><span class="line">  .and()</span><br><span class="line">  <span class="comment">// 提交事务</span></span><br><span class="line">  .commit();</span><br><span class="line">Iterator&lt;CuratorTransactionResult&gt; iterator = commit.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">  CuratorTransactionResult next = iterator.next();</span><br><span class="line">  System.out.println(next.getForPath());</span><br><span class="line">  System.out.println(next.getResultPath());</span><br><span class="line">  System.out.println(next.getType());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里debug看了下Collection<curatortransactionresult>信息，面板如下：</curatortransactionresult></p><p><img src="https://user-gold-cdn.xitu.io/2019/4/13/16a1706f1bfb589c?w=2126&amp;h=890&amp;f=png&amp;s=558056" alt=""></p><h2 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h2><p>前面提到的增删改查都是同步的，但是 Curator 也提供了异步接口，引入了 BackgroundCallback 接口用于处理异步接口调用之后服务端返回的结果信息。BackgroundCallback 接口中一个重要的回调值为 CuratorEvent，里面包含事件类型、响应吗和节点的详细信息。</p><p>在使用上也是非常简单的，只需要带上 inBackground() 就行，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.getData().inBackground().forPath(<span class="string">"/glmapper/test"</span>);</span><br></pre></td></tr></table></figure><p>通过查看 inBackground 方法定义可以看到，inBackground 支持自定义线程池来处理返回结果之后的业务逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">inBackground</span><span class="params">(BackgroundCallback callback, Executor executor)</span></span>;</span><br></pre></td></tr></table></figure><p>这里就不贴代码了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要围绕 Curator 的基本 API 进行了学习记录，对于原理及源码部分没有涉及。这部分如果有时间在慢慢研究吧。另外像分布式锁、分布式自增序列等实现停留在理论阶段，没有实践，不敢妄论，用到再码吧。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.cnblogs.com/felixzh/p/5869212.html" target="_blank" rel="noopener">http://www.cnblogs.com/felixzh/p/5869212.html</a></li><li><a href="https://my.oschina.net/roccn/blog/918209" target="_blank" rel="noopener">https://my.oschina.net/roccn/blog/918209</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://www.glmapper.com/2019/04/13/zookeeper-client-curator/&quot;&gt;ZooKeeper 客户端之 Curator&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="zookeeper" scheme="http://www.glmapper.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 系列-Kafka简介&amp;集成SpringBoot</title>
    <link href="http://www.glmapper.com/2019/03/07/springboot-series-kafka-introduction/"/>
    <id>http://www.glmapper.com/2019/03/07/springboot-series-kafka-introduction/</id>
    <published>2019-03-06T16:08:19.000Z</published>
    <updated>2019-12-07T07:09:29.222Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 近期在做 SOFA 与 SpringCloud 的集成，希望通过一系列的 DEMO 工程去帮助大家更好的使用 SOFA 和 SpringCloud；同时也希望大家一起来参与共建和 star。</p><p>GitHub传送门：<a href="https://github.com/alipay/spring-cloud-sofastack-samples/issues/1" target="_blank" rel="noopener">spring-cloud-sofastack-samples</a></p></blockquote><h2 id="Kafka-简介"><a href="#Kafka-简介" class="headerlink" title="Kafka 简介"></a>Kafka 简介</h2><blockquote><p>官方网站：<a href="https://kafka.apache.org/" target="_blank" rel="noopener">https://kafka.apache.org/</a></p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/3/6/16953b2c0f37bd3f?w=500&amp;h=500&amp;f=png" alt="img"></p><h3 id="功能提供"><a href="#功能提供" class="headerlink" title="功能提供"></a>功能提供</h3><p>Apache Kafka™ 是 一个分布式数据流平台，从官方文档的解释来看，其职能大体如下：</p><ul><li>Publish and subscribe to streams of records, similar to a message queue or enterprise messaging system。发布和订阅数据流，与消息队列或企业级消息系统很像。</li><li>Store streams of records in a fault-tolerant durable way。具有很强容灾性的存储数据流</li><li>Process streams of records as they occur。及时的处理数据流。</li></ul><p>作为一个后端司机，大多数情况下都是把 Kafka 作为一个分布式消息队列来使用的，分布式消息队列可以提供应用解耦、流量消峰、消息分发等功能，已经是大型互联网服务架构不可缺少的基础设置了。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="topic-和-partition"><a href="#topic-和-partition" class="headerlink" title="topic 和 partition"></a>topic 和 partition</h4><p>Kafka 对数据提供的核心抽象，topic 是发布的数据流的类别或名称。topic 在 Kafka 中，支持多订阅者； 也就是说，topic 可以有零个、一个或多个消费者订阅写到相应 topic 的数据。对应每一个 topic，Kafka 集群会维护像一个如下这样的分区的日志：<br><img src="https://user-gold-cdn.xitu.io/2019/3/6/16953b447bde1972?w=416&amp;h=267&amp;f=png&amp;s=19579" alt="img"><br>每个 Partition 都是一个有序的、不可变的并且不断被附加的记录序列，也就是一个结构化提交日志（commit log）。为了保证唯一标性识 Partition 中的每个数据记录，Partition 中的记录每个都会被分配一个叫做偏移（offset）顺序的ID号。通过一个可配置的保留期，Kafka 集群会保留所有被发布的数据，不管它们是不是已经被消费者处理。例如，如果保留期设置为两天，则在发布记录后的两天内，数据都可以被消费，之后它将被丢弃以释放空间。 Kafka 的性能是不为因为数据量大小而受影响的，因此长时间存储数据并不成问题。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/6/16953b472c441053?w=2041&amp;h=1243&amp;f=png&amp;s=139658" alt="img"><br>事实上，在每个消费者上保留的唯一元数据是消费者在日志中的偏移位置，这个偏移由消费者控制：通常消费者会在读取记录时线性地提高其偏移值（offset++），但实际上，由于偏移位置由消费者控制，它可以以任何顺序来处理数据记录。 例如，消费者可以重置为较旧的偏移量以重新处理来自过去的数据，或者跳过之前的记录，并从“现在”开始消费。 这种特征的组合意味着 Kafka 消费者非常轻量级，随意的开启和关闭并不会对其他的消费者有大的影响。</p><p>日志中的 Partition 有几个目的：</p><ul><li>保证日志的扩展性，topic 的大小不受单个服务器大小的限制。每个单独的 Partition 大小必须小于托管它的服务器磁盘大小，但 topic 可能有很多 Partition，因此它可以处理任意数量的海量数据。</li><li>作为并行处理的单位 (<a href="https://www.zhihu.com/question/28925721/answer/139861200" target="_blank" rel="noopener">知乎-Partition</a>：Kafka可以将主题划分为多个分区（Partition），会根据分区规则选择把消息存储到哪个分区中，只要如果分区规则设置的合理，那么所有的消息将会被均匀的分布到不同的分区中，这样就实现了负载均衡和水平扩展。另外，多个订阅者可以从一个或者多个分区中同时消费数据，以支撑海量数据处理能力)</li></ul><h4 id="kafka中的topic为什么要进行分区"><a href="#kafka中的topic为什么要进行分区" class="headerlink" title="kafka中的topic为什么要进行分区"></a>kafka中的topic为什么要进行分区</h4><blockquote><p>原贴：<a href="https://www.zhihu.com/question/28925721" target="_blank" rel="noopener">kafka中的topic为什么要进行分区</a> ，由于不能转载，此处不摘抄原文~</p></blockquote><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>生产者将数据发布到他们选择的 topic ， 生产者负责选择要吧数据分配给 topic 中哪个 Partition。这可以通过循环方式（round-robin）简单地平衡负载，或者可以根据某些语义进行分区（例如基于数据中的某些关键字）来完成。</p><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>消费者们使用消费群组(<em>consumer group</em> )名称来标注自己，几个消费者共享一个 group，每一个发布到 topic 的数据会被传递到每个消费群组(<em>consumer group</em> )中的一个消费者实例。 消费者实例可以在不同的进程中或不同的机器上。</p><p>如果所有的消费者实例具有相同的 consumer group，则记录将在所有的消费者实例上有效地负载平衡</p><p>如果所有的消费者实例都有不同的 consumer group，那么每个记录将被广播给所有的消费者进程，每个数据都发到了所有的消费者。<br><img src="https://user-gold-cdn.xitu.io/2019/3/6/16953b5f8c6e51e8?w=474&amp;h=200&amp;f=png&amp;s=26820" alt="img"></p><blockquote><p>上图解释源自<a href="http://ifeve.com/kafka-introduction/" target="_blank" rel="noopener">《Kafka 官方文档》 介绍</a>：</p><p>如上图，一个两个服务器节点的Kafka集群， 托管着4个分区(P0-P3)，分为两个消费者群. 消费者群A有2个消费者实例，消费者群B有4个. 然而，更常见的是，我们发现主题具有少量的消费者群，每个消费者群代表一个“逻辑订户”。每个组由许多消费者实例组成，保证可扩展性和容错能力。这可以说是“发布-订阅”语义，但用户是一组消费者而不是单个进程。 在Kafka中实现消费的方式，是通过将日志中的分区均分到消费者实例上，以便每个实例在任何时间都是“相应大小的一块”分区的唯一消费者。维护消费者组成员资格的过程，由卡夫卡协议动态处理。 如果新的实例加入组，他们将从组中的其他成员接管一些分区; 如果一个实例消失，其分区将被分发到剩余的实例。 Kafka仅提供单个<em>分区内</em>的记录的顺序，而不是主题中的不同分区之间的总顺序。 每个分区排序结合按键分区，足以满足大多数应用程序的需求。 但是，如果您需要使用总顺序，则可以通过仅具有一个分区的主题来实现，尽管这仅意味着每个消费者组只有一个消费者进程。</p></blockquote><h3 id="Kafka-作为消息系统"><a href="#Kafka-作为消息系统" class="headerlink" title="Kafka 作为消息系统"></a>Kafka 作为消息系统</h3><p>消息系统传统上有两种模式: <a href="http://en.wikipedia.org/wiki/Message_queue" target="_blank" rel="noopener">队列</a>和<a href="http://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" target="_blank" rel="noopener">发布-订阅</a>。 </p><ul><li>队列模式中，消费者池可以从服务器读取，每条记录只会被某一个消费者消费<ul><li>允许在多个消费者实例上分配数据处理，但是一旦数据被消费之后，数据就没有了</li></ul></li><li>发布订阅模式中，记录将广播给所有消费者<ul><li>允许将数据广播到多个进程，但无法缩放和扩容，因为每个消息都发送给每个订阅用户</li></ul></li></ul><blockquote><p>本篇只介绍 Kafka 作为消息队列的一些基本概念，更多介绍请参考<a href="https://kafka.apache.org/intro" target="_blank" rel="noopener">官方文档</a>。</p></blockquote><h2 id="Kafka-安装"><a href="#Kafka-安装" class="headerlink" title="Kafka 安装"></a>Kafka 安装</h2><p>这里来看下如何安装 kafka，下载地址：<a href="https://kafka.apache.org/downloads。本篇使用的版本是" target="_blank" rel="noopener">https://kafka.apache.org/downloads。本篇使用的版本是</a> <strong>kafka_2.12-1.1.1</strong>。</p><ul><li><p>获取包文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; wget http://mirrors.shu.edu.cn/apache/kafka/1.1.1/kafka_2.12-1.1.1.tgz</span><br></pre></td></tr></table></figure></li><li><p>解压压缩包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; tar -zxvf kafka_2.12-1.1.1.tgz</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cd kafka_2.12-1.1.1/config</span><br><span class="line">&gt; vim server.properties</span><br></pre></td></tr></table></figure><p>我这里主要修改项包括以下几个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># The id of the broker. This must be set to a unique integer for each broker.</span><br><span class="line">broker.id=0</span><br><span class="line"></span><br><span class="line">listeners=PLAINTEXT://192.168.0.1:9092</span><br><span class="line"></span><br><span class="line">advertised.listeners=PLAINTEXT://192.168.0.1:9092</span><br><span class="line"># zookeeper 地址，可以多个</span><br><span class="line">zookeeper.connect=192.168.0.6:2181</span><br></pre></td></tr></table></figure><p>  Kafka 服务启动需要依赖 Zookeeper ，所以在配置文件中需要指定 Zookeeper 集群地址。Kafka 自己的安装包中解压之后是包括 Zookeeper 的，可以通过以下的方式来启动一个单节点 Zookeeper 实例：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; sh zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br></pre></td></tr></table></figure><blockquote><p>这里我是指定了之前部署的一台ZK机器，所以可以直接将ZK地址指到已部署好的地址。Zookeeper 安装可以参考： <a href="http://www.glmapper.com/2019/03/04/zk-on-linux/">Linux 下安装 Zookeeper</a> </p></blockquote><p>  通过上述操作，下面就可以直接来启动Kafka 服务了：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; sh kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure></li></ul><h2 id="SpringBoot-集成-Kafka"><a href="#SpringBoot-集成-Kafka" class="headerlink" title="SpringBoot 集成 Kafka"></a>SpringBoot 集成 Kafka</h2><h3 id="构建一个简单的-Kafka-Producer-工具依赖"><a href="#构建一个简单的-Kafka-Producer-工具依赖" class="headerlink" title="构建一个简单的 Kafka Producer 工具依赖"></a>构建一个简单的 Kafka Producer 工具依赖</h3><ul><li>依赖引入</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="comment">&lt;!--$NO-MVN-MAN-VER$--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>producer</li></ul><p>为了可以把 Kafka 封装已提供给其他模块使用，大家可以将 Kafka 的生产端工具类使用 SpringBoot 的自动配置机制进行包装，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaProducerAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KafkaSender <span class="title">kafkaSender</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KafkaSender(kafkaTemplate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>KafkaSender</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaSender</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KafkaSender</span><span class="params">(KafkaTemplate&lt;String, String&gt; kafkaTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kafkaTemplate = kafkaTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * send message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String topic, String message)</span> </span>&#123;</span><br><span class="line">        kafkaTemplate.send(topic, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自动配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">io.sofastack.cloud.core.kafka.configuration.KafkaProducerAutoConfiguration</span><br></pre></td></tr></table></figure><p>工程模块如下：<br>image-20190306151759441.png<br><img src="https://user-gold-cdn.xitu.io/2019/3/6/16953bb00a2a4276?w=1728&amp;h=610&amp;f=png&amp;s=205269" alt=""></p><h3 id="案例测试"><a href="#案例测试" class="headerlink" title="案例测试"></a>案例测试</h3><p>在测试工程中引入依赖，这个依赖就是上面工程打包来的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.sofastack.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofastack-cloud-core-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>在 resources 目录下新建 application.properties 配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#============== kafka ===================</span><br><span class="line"># 指定kafka 代理地址，可以多个,这里的192.168.0.1是上面Kafka 启动配置文件中对应的</span><br><span class="line"># 注：网上一些帖子中说 Kafka 这里的配置只能是主机名，不支持 ip，没有验证过，</span><br><span class="line"># 如果您在验证时出现问题，可以尝试本机绑定下 host</span><br><span class="line">spring.kafka.bootstrap-servers= 192.168.0.1:9092</span><br><span class="line">#=============== provider  =======================</span><br><span class="line">spring.kafka.producer.retries=0</span><br><span class="line"># 每次批量发送消息的数量</span><br><span class="line">spring.kafka.producer.batch-size=16384</span><br><span class="line">spring.kafka.producer.buffer-memory=33554432</span><br><span class="line"># 指定消息key和消息体的编解码方式</span><br><span class="line">spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line">spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line">#=============== consumer  =======================</span><br><span class="line"># 指定默认消费者group id</span><br><span class="line">spring.kafka.consumer.group-id=test-consumer-group</span><br><span class="line">spring.kafka.consumer.auto-offset-reset=earliest</span><br><span class="line">spring.kafka.consumer.enable-auto-commit=true</span><br><span class="line">spring.kafka.consumer.auto-commit-interval=100ms</span><br><span class="line"># 指定消息key和消息体的编解码方式</span><br><span class="line">spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line">spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line">spring.application.name=kafka-test</span><br><span class="line">logging.path=./logs</span><br></pre></td></tr></table></figure></li><li><p>启动类中模拟发送消息</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:application-kafka.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext run = SpringApplication.run(ProviderApplication.class, args);</span><br><span class="line">        <span class="comment">// 这里通过容器获取，正常使用情况下，可以直接使用 Autowired 注入</span></span><br><span class="line">        KafkaSender bean = run.getBean(KafkaSender.class);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//调用消息发送类中的消息发送方法</span></span><br><span class="line">            bean.sendMessage(KafkaContants.TRADE_TOPIC, <span class="string">"send a test message"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编写消费者，在 SpringBoot 工程中，消费者实现非常简单</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaReceiver</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 配置监听的主体，groupId 和配置文件中的保持一致</span></span><br><span class="line">    <span class="meta">@KafkaListener</span>(topics = &#123; KafkaContants.TRADE_TOPIC &#125;, groupId = <span class="string">"test-consumer-group"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(ConsumerRecord&lt;?, ?&gt; record)</span> </span>&#123;</span><br><span class="line">        Optional&lt;?&gt; kafkaMessage = Optional.ofNullable(record.value());</span><br><span class="line">        <span class="keyword">if</span> (kafkaMessage.isPresent()) &#123;</span><br><span class="line">            Object message = kafkaMessage.get();</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动工程后，可以在控制台看下消费者打印的信息：<br><img src="https://user-gold-cdn.xitu.io/2019/3/7/16953bcf93439fac?w=1890&amp;h=138&amp;f=png&amp;s=145531" alt=""><br>这里保持应用正常运行，再通过服务端来手动发送消息，看下是当前消费者能够正确监听到对应的 topic 并消费。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; sh kafka-console-producer.sh --broker-list 192.168.0.1:9092 --topic trading</span><br></pre></td></tr></table></figure></p><p>执行上述命令之后，命令行将会等待输入，这里输入先后输入 glmapper 和 sofa :<br><img src="https://user-gold-cdn.xitu.io/2019/3/7/16953bda46779241?w=902&amp;h=79&amp;f=png&amp;s=21656" alt=""><br>然后再看下应用程序控制台输入结果如下：<br>image-20190306153452565.png<br><img src="https://user-gold-cdn.xitu.io/2019/3/7/16953be13fac86d4?w=1906&amp;h=188&amp;f=png&amp;s=51083" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://kafka.apache.org/intro" target="_blank" rel="noopener">Introduction</a></li><li><a href="http://ifeve.com/kafka-introduction/#more-32041" target="_blank" rel="noopener">《Kafka 官方文档》介绍</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 近期在做 SOFA 与 SpringCloud 的集成，希望通过一系列的 DEMO 工程去帮助大家更好的使用 SOFA 和 SpringCloud；同时也希望大家一起来参与共建和 star。&lt;/p&gt;
&lt;p&gt;GitHub传送门：&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="springboot" scheme="http://www.glmapper.com/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://www.glmapper.com/tags/springboot/"/>
    
      <category term="kafka" scheme="http://www.glmapper.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下安装 Zookeeper</title>
    <link href="http://www.glmapper.com/2019/03/04/zk-on-linux/"/>
    <id>http://www.glmapper.com/2019/03/04/zk-on-linux/</id>
    <published>2019-03-04T12:29:18.000Z</published>
    <updated>2019-08-19T07:21:03.097Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装-Zookeeper"><a href="#安装-Zookeeper" class="headerlink" title="安装 Zookeeper"></a>安装 Zookeeper</h2><p>目前 Curator 有 2.x.x 和 3.x.x 两个系列的版本，支持不同版本的 Zookeeper。其中 Curator 2.x.x 兼容 Zookeeper的 3.4.x 和 3.5.x。而 Curator 3.x.x 只兼容 Zookeeper 3.5.x。</p><blockquote><p>Curator 2.x.x - compatible with both ZooKeeper 3.4.x and ZooKeeper 3.5.x<br>Curator 3.x.x - compatible only with ZooKeeper 3.5.x and includes support for new</p></blockquote><p>选择使用 3.4.x 版本 Zookeeper。</p><ul><li><p><a href="http://apache.fayea.com/zookeeper/" target="_blank" rel="noopener">下载 Zookeeper</a> ，选择相应的版本，这里以 3.4.13 版本为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> wget http://apache.fayea.com/zookeeper/zookeeper-3.4.13/zookeeper-3.4.13.tar.gz</span></span><br></pre></td></tr></table></figure><p>  执行上述命令进行下载，下载完成之后对文件进行解压。</p></li><li><p>解压文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> tar -zxvf zookeeper-3.4.13.tar.gz</span></span><br></pre></td></tr></table></figure></li><li><p>创建数据和日志目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> zookeeper-3.4.13</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mkdir data</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mkdir logs</span></span><br></pre></td></tr></table></figure></li><li><p>配置文件修改<br>首先将默认的 zoo_sample.cfg 命名为 zoo.cfg</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> conf</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cp zoo_sample.cfg zoo.cfg</span></span><br></pre></td></tr></table></figure><p>  编辑 zoo.cfg ， 将数据目录和日志目录路径修改为上述步骤中创建的两个文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置dataDir 和 dataLogDir</span></span><br><span class="line">dataDir=/home/admin/server/zookeeper-3.4.13/data</span><br><span class="line">dataLogDir=/home/admin/server/zookeeper-3.4.13/logs</span><br></pre></td></tr></table></figure></li><li><p>启动 zookeeper<br>到你安装的zookeeper的bin目录下，如：/home/admin/server/zookeeper-3.4.13/bin</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> /home/admin/server/zookeeper-3.4.13/bin</span></span><br></pre></td></tr></table></figure><p>  执行 start 启动</p><pre><code class="shell"><span class="meta">&gt;</span><span class="bash"> zkServer.sh start</span></code></pre><p>上述是简单的在 linux 环境下安装配置 Zookeeper 的过程，对于在实际的生成环境，请根据自己项目需求进行更加细化的配置。</p></li></ul><h2 id="安装-Zookeeper-可视化工具"><a href="#安装-Zookeeper-可视化工具" class="headerlink" title="安装 Zookeeper 可视化工具"></a>安装 Zookeeper 可视化工具</h2><p>为了可以直观的看到 zookeeper 的节点信息，可以考虑部署一个 zookeeper 的管控界面，常见的有 zkui 和 zkweb。</p><ul><li><a href="https://github.com/DeemOpen/zkui" target="_blank" rel="noopener">zkui</a></li><li><a href="https://github.com/zhitom/zkweb" target="_blank" rel="noopener">zkweb</a></li></ul><p>zkui 界面更加简单一点，zkweb 在一些细节展示上更加有优势，这里推荐使用  zkweb。具体部署方式见官方文档。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装-Zookeeper&quot;&gt;&lt;a href=&quot;#安装-Zookeeper&quot; class=&quot;headerlink&quot; title=&quot;安装 Zookeeper&quot;&gt;&lt;/a&gt;安装 Zookeeper&lt;/h2&gt;&lt;p&gt;目前 Curator 有 2.x.x 和 3.x.x 两个系
      
    
    </summary>
    
      <category term="运维" scheme="http://www.glmapper.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="linux" scheme="http://www.glmapper.com/tags/linux/"/>
    
      <category term="zookeeper" scheme="http://www.glmapper.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-网关 Gateway 入门体验</title>
    <link href="http://www.glmapper.com/2019/01/19/springcloud-gateway-predicate-project/"/>
    <id>http://www.glmapper.com/2019/01/19/springcloud-gateway-predicate-project/</id>
    <published>2019-01-18T16:21:33.000Z</published>
    <updated>2019-01-18T16:26:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>网关服务核心是将进入的请求正确合理的路由到下层具体的服务进行业务处理，从它的功能来看，网关服务的核心就是路由信息的构建。</p><p>Spring Cloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Netflix Zuul，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全、监控、埋点和限流等。下面是官方提供的一个工作原理图：</p><p><img src="https://oscimg.oschina.net/oscnet/e9d92479a1dbcdf618d33918468b30c2c8b.jpg" alt=""></p><p>客户端发送请求到 Spring Cloud Gateway，Gateway Handler Mapping 确定请求与路由匹配，则会将请求交给Gateway Web Handler 处理。在代理前后可以执行多个过滤器。最后代理到具体的服务。</p><h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><ul><li>Route：Gateway 中的基本元素，它有自己的 ID、URI 、 Predicate 集合和 Filter 集合</li><li>Predicate：判断请求的 Url 是否匹配当前的 Route</li><li>Filter ：匹配通过之后对请求和响应的处理及修饰</li></ul><p>Spring-Cloud-Gateway 构建路由的数据流向：</p><p><img src="https://oscimg.oschina.net/oscnet/2d7cd3c3fd3452d70112893a4c175943ae0.jpg" alt=""></p><p>RouteDefinition 模型是对 Route 模型中 route 的定义以及描述，Spring-Cloud-Gateway 最终会通过RouteDefinition 来构建起 Route 实例信息。其中 RouteDefinition 代码包含两个数组分别是PredicateDefinition，FilterDefinition。</p><h3 id="内置的-Predicate"><a href="#内置的-Predicate" class="headerlink" title="内置的 Predicate"></a>内置的 Predicate</h3><p>Spring Cloud Gateway 是通过 Spring WebFlux 的 <code>HandlerMapping</code> 做为底层支持来匹配到转发路由，Spring Cloud Gateway 内置了很多 Predicates 工厂，这些 Predicates 工厂通过不同的 HTTP 请求参数来匹配，多个 Predicates 工厂可以组合使用。下面是内置的Predicates：</p><table><thead><tr><th>组件</th><th>备注</th></tr></thead><tbody><tr><td>After Route Predicate Factory</td><td>此谓词匹配当前日期时间之后发生的请求。</td></tr><tr><td>Before Route Predicate Factory</td><td>此谓词匹配在当前日期时间之前发生的请求。</td></tr><tr><td>Between Route Predicate Factory</td><td>此谓词匹配datetime1之后和datetime2之前发生的请求。 datetime2参数必须在datetime1之后。</td></tr><tr><td>Cookie Route Predicate Factory</td><td>Cookie Route Predicate Factory有两个参数，cookie名称和正则表达式。此谓词匹配具有给定名称且值与正则表达式匹配的cookie。</td></tr><tr><td>Header Route Predicate Factory</td><td>Header Route Predicate Factory有两个参数，标题名称和正则表达式。与具有给定名称且值与正则表达式匹配的标头匹配。</td></tr><tr><td>Host Route Predicate Factory</td><td>Host Route Predicate Factory采用一个参数：主机名模式。该模式是一种Ant样式模式“.”作为分隔符。此谓词匹配与模式匹配的Host标头。</td></tr><tr><td>Method Route Predicate Factory</td><td>Method Route Predicate Factory采用一个参数：要匹配的HTTP方法。</td></tr><tr><td>Path Route Predicate Factory</td><td>匹配请求的path</td></tr><tr><td>Query Route Predicate Factory</td><td>Query Route Predicate Factory有两个参数：一个必需的参数和一个可选的正则表达式。</td></tr><tr><td>RemoteAddr Route Predicate Factory</td><td>RemoteAddr Route Predicate Factory采用CIDR符号（IPv4或IPv6）字符串的列表（最小值为1），例如， 192.168.0.1/16（其中192.168.0.1是IP地址，16是子网掩码）。</td></tr></tbody></table><h2 id="工程代码"><a href="#工程代码" class="headerlink" title="工程代码"></a>工程代码</h2><p>本篇将通过一个简单的 gateway 工程来演示如何使用上面的 Predicate 来实现路由。</p><h3 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h3><p>这里新建一个 <a href="https://github.com/glmapper/glmapper-cloud-parent" target="_blank" rel="noopener">glmapper-cloud-gateway</a> 工程，具体细节如下</p><h3 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h3><p>首先在当前工程的pom文件中引入spring cloud gateway 的依赖：spring-cloud-starter-gateway</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件部分，除了常规的端口，应用名之外；关于spring cloud 的路由规则也可以通过配置文件进行配置，下面先以最简单的 path的方式来演示，最终达到的目标是，当输入：<a href="http://localhost:8866/gateway" target="_blank" rel="noopener">http://localhost:8866/gateway</a> 时，请求信息将会被路由到 <a href="http://localhost:8086/hello" target="_blank" rel="noopener">http://localhost:8086/hello</a>(这个是一个eureka client，对外提供rest服务，工程详见<a href="https://github.com/glmapper/glmapper-cloud-parent/tree/master/glmapper-eureka-provider" target="_blank" rel="noopener">glmapper-eureka-provider</a>)。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span>   <span class="comment">#eureka server 的地址</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8866</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">glmapper-cloud-gateway</span>  <span class="comment">#应用名</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://localhost:8086/hello</span>   <span class="comment">#目标地址</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Path=/gateway</span>   <span class="comment">#路由规则</span></span><br></pre></td></tr></table></figure><h3 id="启动应用-amp-验证"><a href="#启动应用-amp-验证" class="headerlink" title="启动应用&amp;验证"></a>启动应用&amp;验证</h3><p>这里直接启动这个工程，SpringCloud Gateway 不需要额外的注解来开启网关服务，所以这里省略启动类的代码。先后启动 glmapper-eureka-server 、glmapper-eureka-provider、glmapper-cloud-gateway。</p><p>在浏览器中输入：<a href="http://localhost:8866/gateway" target="_blank" rel="noopener">http://localhost:8866/gateway</a> ，输出的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Glmapper! Now Port is 8086 And hostname is HelloGlmapperService</span><br></pre></td></tr></table></figure><p>这里输出的实际上是  <a href="http://localhost:8086/hello" target="_blank" rel="noopener">http://localhost:8086/hello</a> 提供的资源，说明我们的路由规则已经生效。</p><h2 id="内置-Predicate-规则配置"><a href="#内置-Predicate-规则配置" class="headerlink" title="内置 Predicate 规则配置"></a>内置 Predicate 规则配置</h2><p>上面已经罗列了所有的 spring cloud gateway 一些内置的 Predicate  ，下面将来使用这些规则来演示下。</p><h3 id="时间匹配"><a href="#时间匹配" class="headerlink" title="时间匹配"></a>时间匹配</h3><p>Predicate 支持设置一个时间，在请求进行转发的时候，可以通过判断在这个时间之前或者之后进行转发。在上面的列表中可以看出，基于时间的匹配支持某时间节点之前、之后，还支持介于两个时间之间的某个时间段内的匹配。基于某个时间段内的匹配规则常见的场景是限时抢购。</p><ul><li>After Route Predicate</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span>     <span class="comment">#自定义的路由ID</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://www.glmapper.com</span> <span class="comment">#目标服务地址</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">After=2019-01-10T00:00:00+08:00[Asia/Shanghai]</span> <span class="comment">#通过时间匹配 2019年1月10日</span></span><br></pre></td></tr></table></figure><p>After Route Predicate 是指在这个时间之后的请求都转发到目标地址。请求时间在 2019年1月10日日00点00分00秒之后的所有请求都转发到地址 <a href="http://www.glmapper.com。+08:00是指时间和UTC时间相差八个小时，时间地区为" target="_blank" rel="noopener">http://www.glmapper.com。+08:00是指时间和UTC时间相差八个小时，时间地区为</a> Asia/Shanghai。</p><ul><li>Before Route Predicate</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span>     <span class="comment">#自定义的路由ID</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://www.glmapper.com</span> <span class="comment">#目标服务地址</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Before=2019-01-10T00:00:00+08:00[Asia/Shanghai]</span> <span class="comment">#通过时间匹配 2019年1月10日</span></span><br></pre></td></tr></table></figure><p>Before Route Predicate 与 After Route Predicate 刚好相反，在某个时间之前的请求的请求都进行转发。</p><ul><li>Between Route Predicate</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">       - id:</span> <span class="string">glmapper</span><span class="comment">#自定义的路由ID</span></span><br><span class="line">       <span class="attr">uri:</span> <span class="attr">http://www.glmapper.com</span><span class="comment">#目标服务地址</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">         -</span> <span class="string">Between=2019-01-10T00:00:00+08:00[Asia/Shanghai],</span> <span class="number">2019</span><span class="bullet">-01</span><span class="bullet">-10</span><span class="attr">T06:00:00+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure><p>在2019年1月10 零点至6点之间的请求将会被路由到 <a href="http://www.glmapper.com">http://www.glmapper.com</a> ，其他的请求将不会被路由。</p><h3 id="Cookie-或者-Header"><a href="#Cookie-或者-Header" class="headerlink" title="Cookie 或者 Header"></a>Cookie 或者 Header</h3><ul><li>Cookie Route Predicate</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://localhost:8086/hello</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Cookie=name,glmapper</span></span><br></pre></td></tr></table></figure><p>这里，如果我的请求信息中存在 cookie name 为 glmapper，值匹配到 glmapper 的串，那么请求将会被路由。</p><p><img src="https://oscimg.oschina.net/oscnet/05fc182cf12e602fa1e7e467c83d7b31da3.jpg" alt="cookie"></p><blockquote><p>PS：这里在配置的时候要注意下 routes 后面格式缩进，否则会抛出一些异常，如：</p><pre><code>Property: spring.cloud.gateway.routes[0].uriValue: nullReason: 不能为nullProperty: spring.cloud.gateway.routes[0].predicatesValue: []Reason: 不能为空</code></pre></blockquote><p>当cookie的值不满足时，访问时404</p><p><img src="https://oscimg.oschina.net/oscnet/680e41ff99bcc15910217ba1ec40812d9a6.jpg" alt="cookie404"></p><ul><li>Header Route Predicate</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">glmapper-cloud-gateway</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://localhost:8086/hello</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br></pre></td></tr></table></figure><p>上面这段配置用于配置 Header 中 X-Request-Id值数字的请求：</p><p><img src="https://oscimg.oschina.net/oscnet/2a88bdad6acd7902f2415089e943b3390f0.jpg" alt="header"></p><p>同样，如果是非数字的话将会返回 404。</p><h3 id="域名匹配"><a href="#域名匹配" class="headerlink" title="域名匹配"></a>域名匹配</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">glmapper-cloud-gateway</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://localhost:8086/hello</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Host=**.glmapper.com</span></span><br></pre></td></tr></table></figure><p>上面这段配置用于匹配 host 为 xxx.glmapper.com 域名的请求：</p><p><img src="https://oscimg.oschina.net/oscnet/b2b68159505c906007107ecd2195bcb7326.jpg" alt="host"></p><p>关于其他的内置 Predicate 均可在官方文档中有实例参考，这里就不一一罗列了。</p><h3 id="组合匹配"><a href="#组合匹配" class="headerlink" title="组合匹配"></a>组合匹配</h3><p>最后我们来将上面的一些进行组合，假设我需要在 <code>2019.1.10 0点至2019.1.10 6点之间，cookie中带有name=glmapper，header 的 X-Request-Id 为数字，域名是 xx.glmapper.com ，path为 /gateway ，请求方式为GET，参数名为queryParam</code> 的请求路由到 <a href="http://localhost:8086/hello。那么具体配置如下" target="_blank" rel="noopener">http://localhost:8086/hello。那么具体配置如下</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">glmapper-cloud-gateway</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://localhost:8086/hello</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Host=**.glmapper.com</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Path=/gateway</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Method=GET</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Header=X-Request-Id,\d+</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Query=queryParam</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Cookie=name,glmapper</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Between=2019-01-10T00:00:00+08:00[Asia/Shanghai],</span> <span class="number">2019</span><span class="bullet">-01</span><span class="bullet">-10</span><span class="attr">T06:00:00+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure><p>还是通过curl 命令来执行以下：</p><p><img src="https://oscimg.oschina.net/oscnet/d78beeac5d4959ba1ade7577c0e54ba9489.jpg" alt="composite"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.0.2.RELEASE/single/spring-cloud-gateway.html#gateway-starter" target="_blank" rel="noopener">Spring Cloud Gateway</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网关服务核心是将进入的请求正确合理的路由到下层具体的服务进行业务处理，从它的功能来看，网关服务的核心就是路由信息的构建。&lt;/p&gt;
&lt;p&gt;Spring Cloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Netflix Zuul，其不仅提
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="Gateway" scheme="http://www.glmapper.com/tags/Gateway/"/>
    
      <category term="网关" scheme="http://www.glmapper.com/tags/%E7%BD%91%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-断路器 Hystrix</title>
    <link href="http://www.glmapper.com/2019/01/09/springcloud-hystrix-project/"/>
    <id>http://www.glmapper.com/2019/01/09/springcloud-hystrix-project/</id>
    <published>2019-01-09T11:28:18.000Z</published>
    <updated>2019-01-09T14:46:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Hystrix 是 Netflix 的一个开源项目，它能够在服务失效的情况下，通过隔离系统依赖服务的方式，防止服务级联失败，造成服务雪崩。同时Hystrix 还提供了失败回滚机制，使得系统能够更快的从异常中恢复。Hystrix 为服务间调用提供了保护和控制。</p><p>Hystrix 具有的功能如下：</p><ul><li>当通过客户端调用服务出现高延迟或者调用失败时，能够为系统提供保护机制</li><li>在复杂的分布式场景下，可以防止服务雪崩效应</li><li>提供快速失败（Fail Fast） 同时能够快速恢复</li><li>提供失败回滚和优雅的服务降级机制</li><li>提供近实时的监控、报警和运维控制手段</li></ul><p>Hystrix 在实际应用过程中的使用方式很丰富，可以通过注解，也可以通过集成 HystrixCommand 和HystrixObservableCommand 。本篇将通过案例简单说明下说用方式。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK</td><td>1.8.0_162</td></tr><tr><td>SOFABoot/SpringBoot</td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE</td></tr><tr><td>SpringCloud</td><td>Finchley.RC1</td></tr><tr><td>IDE</td><td>IDEA</td></tr></tbody></table><h2 id="工程背景"><a href="#工程背景" class="headerlink" title="工程背景"></a>工程背景</h2><p>本节将会创建一个 sofa-hystrix-client 工程，通过 Spring Cloud 提供的负载均衡器 hystrix 实现服务的熔断降级。</p><h2 id="新建-sofa-hystrix-client"><a href="#新建-sofa-hystrix-client" class="headerlink" title="新建 sofa-hystrix-client"></a>新建 sofa-hystrix-client</h2><p>本工程继续使用《SpringCloud-Eureka 服务注册》中的父工程来构建。</p><p>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p><ul><li>artifactId：sofa-hystrix-client</li></ul><h3 id="修改pom文件"><a href="#修改pom文件" class="headerlink" title="修改pom文件"></a>修改pom文件</h3><p>pom文件中加入 hysterix 的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">hystrix-client</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8787</span></span><br></pre></td></tr></table></figure><p>没有什么特殊的配置，还是作为一个 eureka-client 存在。</p><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>启动类上增加开启断路器的注解@EnableCircuitBreaker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaHystrixApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaHystrixApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="资源类"><a href="#资源类" class="headerlink" title="资源类"></a>资源类</h3><ul><li>NormalService </li></ul><p>中通过@HystrixCommand标准一个受保护的资源方法 getByServiceId()。getByServiceId 中通过restTemplate 来调用远程服务。@HystrixCommand注解的 fallbackMethod 属性指定当服务不可用时需要执行的 fallback 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"fallBack"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getByServiceId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://HELLOSOFABOOTSERVICE/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">fallBack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Filed to get data"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>HystrixRibbonController：通过instanceService调用上面的NormalService资源类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixRibbonController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> NormalService instanceService;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hystrix"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instanceService.getByServiceId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动-amp-验证"><a href="#启动-amp-验证" class="headerlink" title="启动&amp;验证"></a>启动&amp;验证</h3><p>先后启动sofa-eureka-server-center 、sofa-eureka-provider、sofa-hystrix-client 三个工程。浏览器中输入：</p><p><a href="http://localhost:8787/hystrix" target="_blank" rel="noopener">http://localhost:8787/hystrix</a> ，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello SOFA! Now Port is 8086 And hostname is HelloSOFABootService</span><br></pre></td></tr></table></figure><p>关闭 sofa-eureka-provider ，刷新浏览器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Filed to get data</span><br></pre></td></tr></table></figure><p>执行了 NormalService 中的 fallback 方法了。</p><h2 id="资源隔离"><a href="#资源隔离" class="headerlink" title="资源隔离"></a>资源隔离</h2><p>hystrix 中提供了两中隔离策略，一种是基于线程池的隔离、另外一种是基于信号量的隔离。本篇只演示案例，具体原理请参看 hystrix 原理分析 相关文章。</p><h3 id="基于线程池的隔离实现"><a href="#基于线程池的隔离实现" class="headerlink" title="基于线程池的隔离实现"></a>基于线程池的隔离实现</h3><p>新建一个 SofaThreadPoolHystrixCommand 类，继承 HystrixCommand。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaThreadPoolHystrixCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SofaThreadPoolHystrixCommand</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initailize());</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HystrixCommand.<span class="function">Setter <span class="title">initailize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 线程池配置</span></span><br><span class="line">        HystrixThreadPoolProperties.Setter hystrixThreadPoolProperties = </span><br><span class="line">            HystrixThreadPoolProperties.Setter()</span><br><span class="line">                .withCoreSize(<span class="number">5</span>)</span><br><span class="line">                .withKeepAliveTimeMinutes(<span class="number">5</span>)</span><br><span class="line">                <span class="comment">// 线程等待队列最大长度,默认值:-1 表示不等待直接拒绝,测试表明线程池使用直接决绝策略+ 合适大小的非回缩线程池效率最高.所以不建议修改此值。</span></span><br><span class="line">                .withMaxQueueSize(<span class="number">10</span>)</span><br><span class="line">                .withQueueSizeRejectionThreshold(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 命令属性配置,这里指定隔离策略是 THREAD</span></span><br><span class="line">        HystrixCommandProperties.Setter hystrixCommand = </span><br><span class="line">            HystrixCommandProperties.Setter() .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD)</span><br><span class="line">                <span class="comment">//意味着线程最多允许执行fallback的并发数为10,超过10 报fallback execution rejected</span></span><br><span class="line">                .withFallbackIsolationSemaphoreMaxConcurrentRequests(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        HystrixCommand.Setter setter = HystrixCommand.Setter</span><br><span class="line">            .withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"SofaThreadPoolHystrixCommand"</span>))</span><br><span class="line">                .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">"sofaBootService"</span>))</span><br><span class="line">                .andCommandPropertiesDefaults(hystrixCommand)</span><br><span class="line">                .andThreadPoolPropertiesDefaults(hystrixThreadPoolProperties)</span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">"sofa-hystrix-thread"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> setter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 受保护的资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://HELLOSOFABOOTSERVICE/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 失败执行的保护方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"this is fail back policy"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关参数说明：</p><ul><li>HystrixCommandGroupKey：配置全局唯一标识服务分组的名称，比如账户系统就是一个服务分组，监控时，相同分组的服务会聚合在一起，必填选项。</li><li>HystrixCommandKey：配置全局唯一标识服务的名称，比如账户系统有一个获取账号名的服务，那么就可以为这个服务起一个名字来唯一识别该服务，如果不配置，则默认是简单类名。</li><li>HystrixThreadPoolKey：配置全局唯一标识线程池的名称，相同线程池名称的线程池是同一个，如果不配置，则默认是分组名，此名字也是线程池中线程名字的前缀。</li><li>HystrixThreadPoolProperties：配置线程池参数</li><li>HystrixCommandProperties：配置该命令的一些参数，如 executionIsolationStrategy 配置执行隔离策略，默认是使用线程隔离。配置为 THREAD，线程池隔离；配置为 SEMAPHORE ，信号量隔离</li></ul><p>这里为了模拟并发，使用 CountDownLatch 类来控制，在 HystrixRibbonController 中添加 testThread 资源方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testThread"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUM; i ++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ConsumerThread(countDownLatch)).start();</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.countDown();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"data"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部定义一个内部类，模拟调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startLatch;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConsumerThread</span><span class="params">(CountDownLatch startLatch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.startLatch = startLatch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 线程等待</span></span><br><span class="line">                startLatch.await();</span><br><span class="line">                <span class="comment">// 执行操作</span></span><br><span class="line">                SofaThreadPoolHystrixCommand sofaThreadPoolHystrixCommand = <span class="keyword">new</span> SofaThreadPoolHystrixCommand(restTemplate);</span><br><span class="line">                System.out.println(sofaThreadPoolHystrixCommand.execute().toString());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重启当前工程，浏览器执行 <a href="http://localhost:8787/testThread" target="_blank" rel="noopener">http://localhost:8787/testThread</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this is fail back policy</span><br><span class="line">this is fail back policy</span><br><span class="line">this is fail back policy</span><br><span class="line">this is fail back policy</span><br><span class="line">this is fail back policy</span><br><span class="line">// ... 省略</span><br><span class="line">Hello SOFA! Now Port is 8086 And hostname is HelloSOFABootService</span><br><span class="line">// ... 省略</span><br></pre></td></tr></table></figure><h3 id="基于信号量隔离"><a href="#基于信号量隔离" class="headerlink" title="基于信号量隔离"></a>基于信号量隔离</h3><p>新建一个 SofaSemaphoreHystrixCommand 类，继承 HystrixCommand。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaSemaphoreHystrixCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SofaSemaphoreHystrixCommand</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initailize());</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HystrixCommand.<span class="function">Setter <span class="title">initailize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 命令属性配置,这里指定隔离策略是 THREAD</span></span><br><span class="line">        HystrixCommandProperties.Setter hystrixCommand = HystrixCommandProperties.Setter()</span><br><span class="line">                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.SEMAPHORE)</span><br><span class="line">                 <span class="comment">//至少有10个请求，熔断器才进行错误率的计算</span></span><br><span class="line">                .withCircuitBreakerRequestVolumeThreshold(<span class="number">0</span>)</span><br><span class="line">                <span class="comment">//熔断器中断请求5秒后会进入半打开状态,放部分流量过去重试</span></span><br><span class="line">                .withCircuitBreakerSleepWindowInMilliseconds(<span class="number">5000</span>)</span><br><span class="line">                <span class="comment">//错误率达到50开启熔断保护</span></span><br><span class="line">                .withCircuitBreakerErrorThresholdPercentage(<span class="number">50</span>)</span><br><span class="line">                <span class="comment">//最大并发请求量</span></span><br><span class="line">                .withExecutionIsolationSemaphoreMaxConcurrentRequests(<span class="number">10</span>)</span><br><span class="line">                <span class="comment">//意味着信号量最多允许执行fallback的并发数为10,超过10 报fallback execution rejected</span></span><br><span class="line">                .withFallbackIsolationSemaphoreMaxConcurrentRequests(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        HystrixCommand.Setter setter = HystrixCommand.Setter.</span><br><span class="line">                withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"SofaSemaphoreHystrixCommand"</span>))</span><br><span class="line">                .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">"sofaBootService"</span>))</span><br><span class="line">                .andCommandPropertiesDefaults(hystrixCommand)</span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">"sofa-hystrix-thread"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> setter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 受保护的资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://HELLOSOFABOOTSERVICE/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 失败执行的保护方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"this is fail back policy"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样使用 CountDownLatch  来模拟并发。在 HystrixRibbonController 中添加 testSemaphore 资源方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testSemaphore"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testSemaphore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUM; i ++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ConsumerSemaphore(countDownLatch)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"data"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>内部定义一个内部类 ConsumerSemaphore ，模拟调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerSemaphore</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startLatch;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConsumerSemaphore</span><span class="params">(CountDownLatch startLatch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.startLatch = startLatch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 线程等待</span></span><br><span class="line">                startLatch.await();</span><br><span class="line">                <span class="comment">// 执行操作</span></span><br><span class="line">                SofaSemaphoreHystrixCommand sofaThreadPoolHystrixCommand = <span class="keyword">new</span> SofaSemaphoreHystrixCommand(restTemplate);</span><br><span class="line">                System.out.println(sofaThreadPoolHystrixCommand.execute().toString());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果和线程隔离的差不多。不贴结果了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Hystrix 是 Netflix 的一个开源项目，它能够在服务失效的情况下，通过隔离系统依赖服务的方式，防止服务级联失败，造成服务雪崩。同
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="spring cloud" scheme="http://www.glmapper.com/tags/spring-cloud/"/>
    
      <category term="Hystrix" scheme="http://www.glmapper.com/tags/Hystrix/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-配置中心 Apollo</title>
    <link href="http://www.glmapper.com/2019/01/09/springcloud-config-apollo/"/>
    <id>http://www.glmapper.com/2019/01/09/springcloud-config-apollo/</id>
    <published>2019-01-09T11:18:42.000Z</published>
    <updated>2019-01-09T15:40:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Apollo（阿波罗）是携程框架部门研发的开源配置管理中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性。</p><p>本篇将搭建一套 Apollo 配置中心环境，并通过一个 demo 案例来演示如何在 SpringCloud 体系中使用 Apollo。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK</td><td>1.8.0_162</td></tr><tr><td>SOFABoot/SpringBoot</td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE</td></tr><tr><td>SpringCloud</td><td>Finchley.RC1</td></tr><tr><td>IDE</td><td>IDEA</td></tr><tr><td>Mysql</td><td>5.7.24</td></tr><tr><td>CentOS</td><td>7</td></tr></tbody></table><p> Apollo 自身需要依赖 Mysql，在部署 Apollo 时需要提前安装 Mysql 数据库。关于 Mysql 的安装可以参考：<a href="http://www.glmapper.com/2019/01/05/mysql-on-linux/">Linux 下安装Mysql数据库</a>。</p><p>根据官方文档，Apollo 服务端需运行在 jdk 1.8 以上，客户端需运行在1.7 以上，Mysql 版本需在 5.6.5 版本以上。具体信息可参考：<a href="https://github.com/ctripcorp/apollo/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">分布式部署指南</a>。</p><h2 id="部署-Apollo"><a href="#部署-Apollo" class="headerlink" title="部署 Apollo"></a>部署 Apollo</h2><p>部署步骤共三步：</p><ul><li><p>创建数据库</p><ul><li>Apollo 服务端依赖于 MySQL 数据库，所以需要事先创建并完成初始化</li></ul></li><li><p>获取安装包</p><ul><li>Apollo 服务端安装包共有3个：apollo-configservice, apollo-adminservice, apollo-portal</li><li>可以直接下载事先打好的安装包，也可以自己通过源码构建</li></ul></li><li><p>部署 Apollo 服务端</p><ul><li>获取安装包后就可以部署到公司的测试和生产环境了</li></ul></li></ul><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>Apollo 服务端共需要两个数据库：<code>ApolloPortalDB</code>和<code>ApolloConfigDB</code>，我们把数据库、表的创建和样例数据都分别准备了 sql 文件，只需要导入数据库即可。</p><blockquote><p>需要注意的是 ApolloPortalDB 只需要在生产环境部署一个即可，而 ApolloConfigDB 需要在每个环境部署一套，如 fat、uat 和 pro 分别部署 3 套 ApolloConfigDB。</p></blockquote><blockquote><p>注意：如果本地已经创建过 Apollo 数据库，请注意备份数据；sql 文件会清空 Apollo 相关的表。</p></blockquote><p>两份 SQL 文件：</p><ul><li><a href="https://github.com/ctripcorp/apollo/blob/master/scripts/db/migration/portaldb/V1.0.0__initialization.sql" target="_blank" rel="noopener">apolloportaldb.sql</a></li><li><a href="https://github.com/ctripcorp/apollo/blob/master/scripts/db/migration/configdb/V1.0.0__initialization.sql" target="_blank" rel="noopener">apolloconfigdb.sql</a></li></ul><p>下载下来之后可通过 Mysql 图形界面工具(如 Navicat )等进行导入。导入完成之后，可以进行如下验证。</p><h4 id="portalDB-验证"><a href="#portalDB-验证" class="headerlink" title="portalDB 验证"></a>portalDB 验证</h4><p>执行 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">`Id`</span>, <span class="string">`Key`</span>, <span class="string">`Value`</span>, <span class="string">`Comment`</span> <span class="keyword">from</span> <span class="string">`ApolloPortalDB`</span>.<span class="string">`ServerConfig`</span> <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>查询结果：</p><table><thead><tr><th>Id</th><th>Key</th><th>Value</th><th>Comment</th></tr></thead><tbody><tr><td>1</td><td>apollo.portal.envs</td><td>dev</td><td>可支持的环境列表</td></tr></tbody></table><h4 id="configDB-验证"><a href="#configDB-验证" class="headerlink" title="configDB 验证"></a>configDB 验证</h4><p>执行 SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">`Id`</span>, <span class="string">`Key`</span>, <span class="string">`Value`</span>, <span class="string">`Comment`</span> <span class="keyword">from</span> <span class="string">`ApolloConfigDB`</span>.<span class="string">`ServerConfig`</span> <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>执行结果：</p><table><thead><tr><th>Id</th><th>Key</th><th>Value</th><th>Comment</th></tr></thead><tbody><tr><td>1</td><td>eureka.service.url</td><td><a href="http://127.0.0.1:8080/eureka/" target="_blank" rel="noopener">http://127.0.0.1:8080/eureka/</a></td><td>Eureka服务Url</td></tr></tbody></table><blockquote><p>本过程只针对新建工程，如果涉及到数据迁移，请参考 Apollo 官方文档</p></blockquote><p>数据库部分完成之后，接下来就是部署 Apollo 的三个工程。</p><h3 id="工程配置修改"><a href="#工程配置修改" class="headerlink" title="工程配置修改"></a>工程配置修改</h3><p>Apollo 配置中心 使用需要启动三个工程：apollo-configservice、apollo-adminservice、apollo-portal。</p><p>在自己的服务器上新建一个目录 /thirdserver/apollo/ 将官方提供的安装包直接下载到这个目录下，然后解压得到如下列表：</p><p><img src="https://oscimg.oschina.net/oscnet/20886e6df68aa3e20bc026e77811ae9bf5b.jpg" alt="image-20190107114836135"></p><h4 id="apollo-configservice-部署"><a href="#apollo-configservice-部署" class="headerlink" title="apollo-configservice 部署"></a>apollo-configservice 部署</h4><p>Apollo 服务端需要知道如何连接到你前面创建的数据库，数据库连接串信息位于上一步下载的压缩包中的<code>apollo-configservice-1.2.0-github/config/application-github.properties</code>中，这里把里面默认的数据库连接地址和账密信息替换成我们自己的就可以。这里使用的是 ApolloConfigDB 库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># DataSource</span><br><span class="line">spring.datasource.url = jdbc:mysql://$&#123;serverhost&#125;:3306/ApolloConfigDB?characterEncoding=utf8</span><br><span class="line">spring.datasource.username = $&#123;yourusername&#125;</span><br><span class="line">spring.datasource.password = $&#123;yourpassword&#125;</span><br></pre></td></tr></table></figure><h4 id="apollo-adminservice-配置文件修改"><a href="#apollo-adminservice-配置文件修改" class="headerlink" title="apollo-adminservice 配置文件修改"></a>apollo-adminservice 配置文件修改</h4><p>这里同样是修改  config/application-github.properties 下面的数据库连接信息。这里也使用的是 ApolloConfigDB 库。配置信息和上面一样。</p><h4 id="apollo-portal-配置文件修改"><a href="#apollo-portal-配置文件修改" class="headerlink" title="apollo-portal 配置文件修改"></a>apollo-portal 配置文件修改</h4><ul><li><p>portal 使用的是 ApolloPortalDB，修改数据库配置信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># DataSource</span><br><span class="line">spring.datasource.url = jdbc:mysql://$&#123;serverhost&#125;:3306/ApolloPortalDB?characterEncoding=utf8</span><br><span class="line">spring.datasource.username = $&#123;yourusername&#125;</span><br><span class="line">spring.datasource.password = $&#123;yourpassword&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改 meta service 信息，Apollo Portal 需要在不同的环境访问不同的 meta service(apollo-configservice) 地址，所以我们需要在配置中提供这些信息。默认情况下，meta service 和 config service 是部署在同一个 JVM进程，所以 meta service 的地址就是 config service 的地址。配置文件  /config/apollo-env.properties </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># $&#123;serverhost&#125; 是你当前机器的主机地址</span><br><span class="line">local.meta=http://localhost:8080</span><br><span class="line">dev.meta=http://$&#123;serverhost&#125;:8080</span><br><span class="line">fat.meta=http://$&#123;serverhost&#125;:8080</span><br><span class="line">uat.meta=http://$&#123;serverhost&#125;:8080</span><br><span class="line">lpt.meta=http://$&#123;serverhost&#125;:8080</span><br><span class="line">pro.meta=http://$&#123;serverhost&#125;:8080</span><br></pre></td></tr></table></figure><p>这里是把所有环境配置成一样的了，如果没有不需要这些环境，可以删除掉。</p></li></ul><h3 id="工程部署"><a href="#工程部署" class="headerlink" title="工程部署"></a>工程部署</h3><p>在每一个工程的解压包中，都有一个 scripts 文件夹，这里面是 Apollo 工程的启动脚本。三个工程分别先后启动：apollo-configservice、apollo-adminservice、apollo-portal，就是分别执行这三个工程下面的 /scripts/startup.sh 脚本即可，关闭执行的是 /scripts/shutdown.sh 脚本。</p><p>访问：http://${serverhost}:8070/</p><p><img src="https://oscimg.oschina.net/oscnet/2e9128be00850d0a34e9a437c37250f5757.jpg" alt="image-20190107133404554"></p><p>可以看到配置中心管控端的界面。</p><h3 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h3><ul><li>点击 创建项目，填写一些基本信息，然后提交</li></ul><p><img src="https://oscimg.oschina.net/oscnet/9829aa94cc189b32e6b8ed1958aa2ba7646.jpg" alt="image-20190107133541629"></p><ul><li>新增一个配置项，填写基本信息，然后提交</li></ul><p><img src="https://oscimg.oschina.net/oscnet/3004cbe4c0af7a9e376a4ab34d4d5d7e90b.jpg" alt="image-20190107133835832"></p><ul><li>当前工程界面</li></ul><p><img src="https://oscimg.oschina.net/oscnet/cce2da4dec2286f502863b33337d9110845.jpg" alt="image-20190107133936932"></p><ul><li>发布配置</li></ul><p><img src="https://oscimg.oschina.net/oscnet/3c0448a87c7124bb7e3ac170a269537a8e4.jpg" alt="image-20190107134958570"></p><h2 id="SpringCloud-工程案例"><a href="#SpringCloud-工程案例" class="headerlink" title="SpringCloud 工程案例"></a>SpringCloud 工程案例</h2><p>新建 sofa-config-apollo 工程。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>引入 apollo 客户端依赖及其他相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ctrip.framework.apollo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>apollo-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 需要与前面 Apollo 中创建项目的appId保持一致</span><br><span class="line">app.id=sofa-config-apollo</span><br><span class="line"># 设置 apollo meta service 的地址，因为前面meta和config是部署在一起的，所以就是configService的地址</span><br><span class="line">apollo.meta=http://$&#123;serverhost&#125;:8080</span><br><span class="line"># 配置项</span><br><span class="line">sofa.alipay.glmapper.name=glmapper</span><br></pre></td></tr></table></figure><h3 id="资源类-amp-启动类"><a href="#资源类-amp-启动类" class="headerlink" title="资源类&amp;启动类"></a>资源类&amp;启动类</h3><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><p>启动类上需要开启对 apollo 的支持，使用 @EnableApolloConfig 注解标注</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableApolloConfig</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaConfigApolloApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaConfigApolloApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="资源类"><a href="#资源类" class="headerlink" title="资源类"></a>资源类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApolloConfigController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApolloConfig</span></span><br><span class="line">    <span class="keyword">private</span> Config config;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;sofa.alipay.glmapper.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/apollo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，我在配置文件中指定的是 sofa.alipay.glmapper.name 值是 glmapper，而在配置中心配置的值是glmapper@leishu。同时这里也把 apollo 自己的这个 Config 配置类也注入进来，稍后看下这的对象的信息。</p><h3 id="运行程序-amp-验证"><a href="#运行程序-amp-验证" class="headerlink" title="运行程序&amp;验证"></a>运行程序&amp;验证</h3><p>启动当前工程之前需要确保 Apollo 的相关服务已经起来了，然后运行当前应用。在浏览器中输入：</p><p><a href="http://localhost:8080/config" target="_blank" rel="noopener">http://localhost:8080/config</a> ，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glmapper@leishu</span><br></pre></td></tr></table></figure><p>可以看到这里拿到的是配置中心的配置值，覆盖了我们本地配置文件中的配置。断点看到 config 的信息：</p><p><img src="https://oscimg.oschina.net/oscnet/617181dcfdd599e4fe37c85a7a5f9889049.jpg" alt="image-20190107140226085"></p><p>Config 对象就是当前集群环境下，指定 appId 的所有配置信息的集合。</p><h4 id="更改配置-amp-及时刷新"><a href="#更改配置-amp-及时刷新" class="headerlink" title="更改配置&amp;及时刷新"></a>更改配置&amp;及时刷新</h4><ul><li>更改配置</li></ul><p><img src="https://oscimg.oschina.net/oscnet/8cbe27b1b8334b0d866a0cd7af8fbe938b5.jpg" alt="image-20190107142508567"></p><ul><li>发布配置</li></ul><p><img src="https://oscimg.oschina.net/oscnet/277990a3c311039e4b3ac14593a19ffe32d.jpg" alt="image-20190107142537478"></p><ul><li>刷新 <a href="http://localhost:8080/apollo" target="_blank" rel="noopener">http://localhost:8080/apollo</a> 地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glmapper@leishu-update</span><br></pre></td></tr></table></figure><p>这里没有重启服务，配置动态更新了</p><h4 id="ApolloConfigChangeListener-来监听配置变更"><a href="#ApolloConfigChangeListener-来监听配置变更" class="headerlink" title="@ApolloConfigChangeListener 来监听配置变更"></a>@ApolloConfigChangeListener 来监听配置变更</h4><p>资源类 ApolloConfigController 中增加一个监听方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApolloConfigChangeListener</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(ConfigChangeEvent changeEvent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"发生变更了..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后重新在配置中心的界面上修改配置值：glmapper@leishu-update -&gt; glmapper@leishu-update-event，然后发布。然后可以在控制台看到日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发生变更了...</span><br><span class="line">2019-01-07 14:36:08.939  INFO 39072 --- [Apollo-Config-1] c.f.a.s.p.AutoUpdateConfigChangeListener : Auto update apollo changed value successfully, new value: glmapper@leishu-update-event, key: sofa.alipay.glmapper.name, beanName: apolloConfigController, field: com.alipay.sofa.cloud.controller.ApolloConfigController.name</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Apollo（阿波罗）是携程框架部门研发的开源配置管理中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="Config" scheme="http://www.glmapper.com/tags/Config/"/>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/tags/spring-cloud/"/>
    
      <category term="Apollo" scheme="http://www.glmapper.com/tags/Apollo/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-Config 配置中心原理</title>
    <link href="http://www.glmapper.com/2019/01/05/springcloud-config-analysis/"/>
    <id>http://www.glmapper.com/2019/01/05/springcloud-config-analysis/</id>
    <published>2019-01-05T13:03:20.000Z</published>
    <updated>2019-01-05T13:10:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇可以配合《<a href="http://www.glmapper.com/2018/12/31/springcoud-config-project/">SpringCloud-配置中心 Config</a>》来看，《<a href="http://www.glmapper.com/2018/12/31/springcoud-config-project/">SpringCloud-配置中心 Config</a>》中是基于SOFABoot 来集成 Spring Cloud Config 的一个 demo 案例。</p><p>在demo中，涉及到三个角色：</p><ul><li>配置中心服务端：为配置客户端提供对应的配置信息，配置信息的来源是配置仓库。应用启动时，会从配置仓库拉取配置信息缓存到本地仓库中。</li><li>配置中心客户端：应用启动时从配置服务端拉取配置信息。</li><li>配置仓库：为配置中心服务端提供配置信息存储，Spring Cloud Config 默认是使用git作为仓库的。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/3586089d566730b5fc6f5df08e96e5bb0b1.jpg" alt="image.png"></p><p>整体过程：</p><ul><li>环境部署之前，将所需的配置信息推送到配置仓库</li><li>启动配置中心服务端，将配置仓库的配置信息拉取到服务端，配置服务端对外提供REST接口</li><li>启动配置客户端，客户端根据 spring.cloud.config 配置的信息去服务器拉取相应的配置</li></ul><h2 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h2><p>配置中心服务端主要做了几件事情：连接配置仓库、拉取远程配置&amp;本地缓存、对外提供API接口服务。</p><h3 id="EnableConfigServer-及配置类"><a href="#EnableConfigServer-及配置类" class="headerlink" title="@EnableConfigServer 及配置类"></a>@EnableConfigServer 及配置类</h3><p>注解 EnableConfigServer 可以开启应用服务对配置中心的支持。当开启之后，配置服务器就会在启动时进行自动配置。具体对应的配置类是 ConfigServerAutoConfiguration，然后又在 ConfigServerAutoConfiguration 这个配置类中引入了其他很多配置类。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(&#123;Marker.class&#125;)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;ConfigServerProperties.class&#125;)</span><br><span class="line"><span class="meta">@Import</span>(&#123;EnvironmentRepositoryConfiguration.class, CompositeConfiguration.class, ResourceRepositoryConfiguration.class, ConfigServerEncryptionConfiguration.class, ConfigServerMvcConfiguration.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConfigServerAutoConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>EnvironmentRepositoryConfiguration： 环境变量存储相关的配置类</li><li>CompositeConfiguration：组合方式的环境仓库配置类</li><li>ResourceRepositoryConfiguration：资源仓库相关的配置类</li><li>ConfigServerEncryptionConfiguration：加密断点相关的配置类</li><li>ConfigServerMvcConfiguration：对外暴露的MVC端点控制器的配置类</li></ul><p>无论是 Spring Cloud 自身提供的默认实现 git ，还是 zk，或者 apollo ；基本思路都是在程序启动时将远端配置拉取到本地作为环境变量来使用，但这些是针对客户端角度来说的。Spring Cloud Config Server 因为其本身是以服务端存在，所以 Config Server 本身的实现思路也值得后面开发借鉴。</p><p>对于服务端来说，其基本职责就是能够将具体存储中的配置信息先拿到，然后提供出 API 供客户端来调用。下面从ConfigServerAutoConfiguration 中 import的这些配置类来具体看下实现。</p><h3 id="EnvironmentRepositoryConfiguration"><a href="#EnvironmentRepositoryConfiguration" class="headerlink" title="EnvironmentRepositoryConfiguration"></a>EnvironmentRepositoryConfiguration</h3><p>EnvironmentRepositoryConfiguration 是环境变量存储相关的配置类，它本身也提供了很多实现：</p><p><img src="https://oscimg.oschina.net/oscnet/3b93eff5aa7978c04010c2b0bb75f7bae17.jpg" alt="image.png"></p><p>上图中可以看到，环境配置仓库支持的有JDBC、SVN、本地文件系统、Git等等。这些对不同环境仓库的支持，在实现上基本都差不多，下面以默认提供的方式git来分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"git"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitRepositoryConfiguration</span> <span class="keyword">extends</span> <span class="title">DefaultRepositoryConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GitRepositoryConfiguration 集成了 DefaultRepositoryConfiguration，这也说明了 Spring Cloud Config 默认使用的是Git。不同的配置类实现都会被标注一个@Profile，可以通过这个来激活相应的配置类；具体做法是在配置服务端的 application.properties(application.yml) 中来指定：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.profile.active=git</span><br></pre></td></tr></table></figure><p>没有设置就是默认使用 GIt。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = EnvironmentRepository.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultRepositoryConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ConfigurableEnvironment environment;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ConfigServerProperties server;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> TransportConfigCallback customTransportConfigCallback;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MultipleJGitEnvironmentRepository <span class="title">defaultEnvironmentRepository</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        MultipleJGitEnvironmentRepositoryFactory gitEnvironmentRepositoryFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">MultipleJGitEnvironmentProperties environmentProperties)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> gitEnvironmentRepositoryFactory.build(environmentProperties);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultRepositoryConfiguration 的 ConditionalOnMissingBean 可以知道，如果上下文中没有 EnvironmentRepository，那么就使用 DefaultRepositoryConfiguration。</p><h3 id="MultipleJGitEnvironmentRepository"><a href="#MultipleJGitEnvironmentRepository" class="headerlink" title="MultipleJGitEnvironmentRepository"></a>MultipleJGitEnvironmentRepository</h3><p>MultipleJGitEnvironmentRepository 是 Git 存储的具体实现类，下面是类图结构：<br><img src="https://oscimg.oschina.net/oscnet/00a410c73f4e93c55f8ce2e386e5254718e.jpg" alt="image.png"></p><p>MultipleJGitEnvironmentRepository 的顶层接口是 EnvironmentRepository ，当然其他的实现也都是实现了这个接口的。另外一个需要关注的是 SearchPathLocator。</p><ul><li>EnvironmentRepository：定义了获取指定应用服务环境信息的方法，返回一个Enviroment</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EnvironmentRepository</span> </span>&#123;</span><br><span class="line"><span class="function">Environment <span class="title">findOne</span><span class="params">(String application, String profile, String label)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个参数，application、profile、label；《<a href="http://www.glmapper.com/2018/12/31/springcoud-config-project/">SpringCloud-配置中心 Config</a>》 中客户端部分有对这三个的参数的说明及使用方式，通过这三个参数可以具体定位到配置信息。</p><ul><li>SearchPathLocator ： 根据传入客户端应用信息，获取对应的配置环境文件的位置。代码见：<a href="[https://github.com/spring-cloud/spring-cloud-config/blob/master/spring-cloud-config-server/src/main/java/org/springframework/cloud/config/server/environment/SearchPathLocator.java](https://github.com/spring-cloud/spring-cloud-config/blob/master/spring-cloud-config-server/src/main/java/org/springframework/cloud/config/server/environment/SearchPathLocator.java">SearchPathLocator</a>)。</li></ul><p>SearchPathLocator 中有一个内部类 Locations ，Locdations中定义了应用服务配置存储信息。</p><p>除了这两个之外，还有一个 AbstractScmAccessor，这个抽象类里面定义了一些列与git存储相关的属性和方法。包括远程仓库的地址、账户、密码、ssh 私钥、本地仓库的地址等等。</p><blockquote><p>SCM : 软件配置管理</p></blockquote><h3 id="AbstractScmEnvironmentRepository"><a href="#AbstractScmEnvironmentRepository" class="headerlink" title="AbstractScmEnvironmentRepository"></a>AbstractScmEnvironmentRepository</h3><p>AbstractScmEnvironmentRepository 实现了 AbstractScmAccessor 和 EnvironmentRepository ，主要就是EnvironmentRepository 中 findOne 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Environment <span class="title">findOne</span><span class="params">(String application, String profile, String label)</span> </span>&#123;</span><br><span class="line"><span class="comment">//新建了一个本地仓库作为代理仓库来使用</span></span><br><span class="line">  NativeEnvironmentRepository delegate = <span class="keyword">new</span> NativeEnvironmentRepository(getEnvironment(),</span><br><span class="line"><span class="keyword">new</span> NativeEnvironmentProperties());</span><br><span class="line">    <span class="comment">//获取本地仓库中指定应用的位置</span></span><br><span class="line">Locations locations = getLocations(application, profile, label);</span><br><span class="line">delegate.setSearchLocations(locations.getLocations());</span><br><span class="line">  <span class="comment">//根据这个路径搜索应用服务的配置信息</span></span><br><span class="line">Environment result = delegate.findOne(application, profile, <span class="string">""</span>);</span><br><span class="line">result.setVersion(locations.getVersion());</span><br><span class="line">result.setLabel(label);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.cleaner.clean(result, getWorkingDirectory().toURI().toString(),</span><br><span class="line">getUri());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getLocations 是一个模板方法，Config Server中提供了三种实现：</p><p><img src="https://oscimg.oschina.net/oscnet/5c29f16cdb3057306c9eb7d95a19188ef36.jpg" alt="image.png"></p><p>分别是单 Git 仓库，多 Git 仓库和 Svn 仓库实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Locations <span class="title">getLocations</span><span class="params">(String application, String profile,</span></span></span><br><span class="line"><span class="function"><span class="params">String label)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (label == <span class="keyword">null</span>) &#123;</span><br><span class="line">label = <span class="keyword">this</span>.defaultLabel;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 获取最新的版本号</span></span><br><span class="line">String version = refresh(label);</span><br><span class="line">    <span class="comment">// 根据最新的版本号返回 Locations 定位到资源的搜索路径</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Locations(application, profile, label, version,</span><br><span class="line">getSearchLocations(getWorkingDirectory(), application, profile, label));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>refresh 方法做的作用就是刷新本地仓库的配置状态，这样就能保证每次都能拉取到最新的配置信息。下面来分析这个方法。</p><h3 id="JGitEnvironmentRepository-refresh"><a href="#JGitEnvironmentRepository-refresh" class="headerlink" title="JGitEnvironmentRepository#refresh"></a>JGitEnvironmentRepository#refresh</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">refresh</span><span class="params">(String label)</span> </span>&#123;</span><br><span class="line">Git git = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建一个git客户端</span></span><br><span class="line">git = createGitClient();</span><br><span class="line">      <span class="comment">// 是否需要执行 git pull</span></span><br><span class="line"><span class="keyword">if</span> (shouldPull(git)) &#123;</span><br><span class="line">FetchResult fetchStatus = fetch(git, label);</span><br><span class="line"><span class="keyword">if</span> (deleteUntrackedBranches &amp;&amp; fetchStatus != <span class="keyword">null</span>) &#123;</span><br><span class="line">deleteUntrackedLocalBranches(fetchStatus.getTrackingRefUpdates(), git);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取后checkout，这样我们就可以获得任何新的分支、tag等。</span></span><br><span class="line">checkout(git, label);</span><br><span class="line">tryMerge(git, label);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 没有什么要更新，所以只是checkout和merge。</span></span><br><span class="line"><span class="comment">// 合并是因为远程分支以前可能已经更新过</span></span><br><span class="line">checkout(git, label);</span><br><span class="line">tryMerge(git, label);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回当前的版本</span></span><br><span class="line"><span class="keyword">return</span> git.getRepository().findRef(<span class="string">"HEAD"</span>).getObjectId().getName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// 异常处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 关闭git</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个里面基本就是通过git客户端的一些操作。先是检查远程仓库的状态，然后判断本地仓库是否要执行刷新操作。如果有状态更新，比如新的提交时，Git客户端就会执行fetch，然后再进行merge，更新到本地仓库。</p><blockquote><p>MultipleJGitEnvironmentRepository 多仓库的支持，实际上就是遍历了所有的仓库。其他仓库和单仓库是一样的。</p></blockquote><h2 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h2><p>Spring Cloud Config Client 没有像其他组件一样提供@EnableConfigClient注解，这里没有必要去标注是一个配置客户端，只要引入了spring-cloud-config-client 依赖即可。</p><p>思路也很清楚，就是在启动时从服务端把配置信息拉取到本地，然后设置到 Enviroment 中。Spring Cloud Config中有两种形式，一种是指定 url，另外一种是通过服务发现，默认是通过指定URI的方式。这里还是先从客户端的自动配置来分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServiceBootstrapConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ConfigurableEnvironment environment;</span><br><span class="line">  <span class="comment">// 客户端配置属性</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigClientProperties <span class="title">configClientProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ConfigClientProperties client = <span class="keyword">new</span> ConfigClientProperties(<span class="keyword">this</span>.environment);</span><br><span class="line"><span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 从远程服务器上请求对应的配置信息</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(ConfigServicePropertySourceLocator.class)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"spring.cloud.config.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigServicePropertySourceLocator <span class="title">configServicePropertySource</span><span class="params">(ConfigClientProperties properties)</span> </span>&#123;</span><br><span class="line">ConfigServicePropertySourceLocator locator = <span class="keyword">new</span> ConfigServicePropertySourceLocator(</span><br><span class="line">properties);</span><br><span class="line"><span class="keyword">return</span> locator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重试机制</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"spring.cloud.config.fail-fast"</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Retryable.class, Aspect.class, AopAutoConfiguration.class &#125;)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRetry</span>(proxyTargetClass = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@Import</span>(AopAutoConfiguration.class)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(RetryProperties.class)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(name = <span class="string">"configServerRetryInterceptor"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RetryOperationsInterceptor <span class="title">configServerRetryInterceptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">RetryProperties properties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> RetryInterceptorBuilder</span><br><span class="line">.stateless()</span><br><span class="line">.backOffOptions(properties.getInitialInterval(),</span><br><span class="line">properties.getMultiplier(), properties.getMaxInterval())</span><br><span class="line">.maxAttempts(properties.getMaxAttempts()).build();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置类中初始化了两个bean:</p><ul><li>ConfigClientProperties : 对客户端的属性进行配置。</li><li>ConfigServicePropertySourceLocator：从远程服务器上请求对应的配置信息，然后注册到容器的Enviroment 对象中去。</li></ul><p>ConfigClientProperties 中就是客户端的一些属性，如：profile、应用名、标签、远端服务地址等。没有什么特殊的逻辑。主要来看下 ConfigServicePropertySourceLocator 。</p><h3 id="ConfigServicePropertySourceLocator"><a href="#ConfigServicePropertySourceLocator" class="headerlink" title="ConfigServicePropertySourceLocator"></a>ConfigServicePropertySourceLocator</h3><p>ConfigServicePropertySourceLocator 实现了 PropertySourceLocator 接口，PropertySourceLocator 接口的作用就是用来定位 PropertySource 的。直接看locate方法的实现(删除了无关代码)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Retryable</span>(interceptor = <span class="string">"configServerRetryInterceptor"</span>)</span><br><span class="line"><span class="keyword">public</span> PropertySource&lt;?&gt; locate(Environment environment) &#123;</span><br><span class="line">ConfigClientProperties properties = <span class="keyword">this</span>.defaultProperties.override(environment);</span><br><span class="line">CompositePropertySource composite = <span class="keyword">new</span> CompositePropertySource(<span class="string">"configService"</span>);</span><br><span class="line">   <span class="comment">// 实例化一个 restTemplate，用来调用服务端的 API</span></span><br><span class="line">RestTemplate restTemplate = <span class="keyword">this</span>.restTemplate == <span class="keyword">null</span></span><br><span class="line">? getSecureRestTemplate(properties)</span><br><span class="line">: <span class="keyword">this</span>.restTemplate;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// labels ，对对应于profile 如，dev,pre,test这些</span></span><br><span class="line">String[] labels = <span class="keyword">new</span> String[] &#123; <span class="string">""</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(properties.getLabel())) &#123;</span><br><span class="line">labels = StringUtils.commaDelimitedListToStringArray(properties.getLabel());</span><br><span class="line">&#125;</span><br><span class="line">String state = ConfigClientStateHolder.getState();</span><br><span class="line"><span class="comment">// 遍历所有的标签，循环调用获取远程配置信息</span></span><br><span class="line"><span class="keyword">for</span> (String label : labels) &#123;</span><br><span class="line">       <span class="comment">// h获取远端环境配置信息</span></span><br><span class="line">Environment result = getRemoteEnvironment(restTemplate, properties,</span><br><span class="line">label.trim(), state);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">log(result);</span><br><span class="line">         <span class="comment">// result.getPropertySources() can be null if using xml</span></span><br><span class="line">         <span class="comment">//使用 xml，可能会为 null</span></span><br><span class="line"><span class="keyword">if</span> (result.getPropertySources() != <span class="keyword">null</span>) &#123; </span><br><span class="line"><span class="keyword">for</span> (PropertySource source : result.getPropertySources()) &#123;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) source</span><br><span class="line">.getSource();</span><br><span class="line">composite.addPropertySource(</span><br><span class="line"><span class="keyword">new</span> MapPropertySource(source.getName(), map));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">         <span class="comment">// 设置客户端状态和版本号信息</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(result.getState())</span><br><span class="line">|| StringUtils.hasText(result.getVersion())) &#123;</span><br><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">putValue(map, <span class="string">"config.client.state"</span>, result.getState());</span><br><span class="line">putValue(map, <span class="string">"config.client.version"</span>, result.getVersion());</span><br><span class="line">composite.addFirstPropertySource(</span><br><span class="line"><span class="keyword">new</span> MapPropertySource(<span class="string">"configClient"</span>, map));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> composite;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// 如果设置了fial fast ，失败时抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (properties.isFailFast()) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码片段中实际从远端获取配置信息是在 getRemoteEnvironment 这个方法中，以Http 请求的方式获取。获取到配置信息之后是放在 CompositePropertySource 对象中，代码较长，逻辑也比较简单，建议直接阅读源码。源于这部分 <a href="http://www.glmapper.com/2018/12/31/springcoud-context-analysis/">自定义属性源</a>也有说明。</p><h3 id="注入到-Enviroment-中"><a href="#注入到-Enviroment-中" class="headerlink" title="注入到 Enviroment 中"></a>注入到 Enviroment 中</h3><p>这部分操作是在 Spring Cloud Context 中的入口来完成的。具体参考<a href="http://www.glmapper.com/2018/12/31/springcoud-context-analysis/"> bootstrapServiceContext 创建&amp;启动</a> 。<br>这里会通过 Spring Cloud Context 中的 PropertySourceBootstrapConfiguration 配置类将PropertySourceLocator 自定义属性值添加到引导上下文的环境当中。</p><h3 id="基于服务发现的方式获取配置"><a href="#基于服务发现的方式获取配置" class="headerlink" title="基于服务发现的方式获取配置"></a>基于服务发现的方式获取配置</h3><p>前面两个小节均是基于指定 http url 的方式获取配置文件的。Spring Cloud Config 中还有一种方式就是基于服务发现的方式。其实这种方式说到底还是基于指定 http url的方式调用，只是通过服务发现找到服务端地址；当然既然有服务的发现与注册，也就会涉及到客户端与服务端之间的会话保证，及时更新可用服务列表这些功能。</p><ul><li>获取服务地址</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retryable</span>(interceptor = <span class="string">"configServerRetryInterceptor"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ServiceInstance&gt; <span class="title">getConfigServerInstances</span><span class="params">(String serviceId)</span> </span>&#123;</span><br><span class="line">logger.debug(<span class="string">"Locating configserver ("</span> + serviceId + <span class="string">") via discovery"</span>);</span><br><span class="line">List&lt;ServiceInstance&gt; instances = <span class="keyword">this</span>.client.getInstances(serviceId);</span><br><span class="line"><span class="keyword">if</span> (instances.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">"No instances found of configserver ("</span> + serviceId + <span class="string">")"</span>);</span><br><span class="line">&#125;</span><br><span class="line">logger.debug(<span class="string">"Located configserver ("</span> + serviceId</span><br><span class="line">+ <span class="string">") via discovery. No of instances found: "</span> + instances.size());</span><br><span class="line"><span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 DiscoveryClient 客户端，以指定serviceId的方式拿到服务地址。</p><p>DiscoveryClientConfigServiceBootstrapConfiguration 这个自动配置类实现了 ApplicationListener，用于监听上下文刷新事件；DiscoveryClient 在具体的实现中会将上下文刷新事件进行广播，然后执行刷新操作。心跳里面也是执行的刷新操作。对应的方法是DiscoveryClientConfigServiceBootstrapConfiguration#refresh。也就是 refresh方法会根据上下文环境和心跳事件，刷新服务实例。</p><h2 id="以-ZK-作为配置中心"><a href="#以-ZK-作为配置中心" class="headerlink" title="以 ZK 作为配置中心"></a>以 ZK 作为配置中心</h2><p>《<a href="http://www.glmapper.com/2019/01/05/springcloud-config-zk-project/">SpringCloud-配置中心 spring-cloud-zk</a>》demo 中介绍了如何使用 zk 作为配置中心。以zk作为配置中心也就是配置信息将从zk中来获取；具体实现也就是实现 PropertySourceLocator 接口，在locate方法中通过zk客户端从zk服务端拉取配置信息。具体实现在ZookeeperPropertySourceLocator#locate中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PropertySource&lt;?&gt; locate(Environment environment) &#123;</span><br><span class="line"><span class="keyword">if</span> (environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">      <span class="comment">//省略 ...</span></span><br><span class="line"><span class="comment">// 获取外部配置源</span></span><br><span class="line">PropertySource propertySource = create(propertySourceContext);</span><br><span class="line">      <span class="comment">//省略 ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他代码片段都省略了，获取 PropertySource 是在 create 方法中，create 方法返回一个 ZookeeperPropertySource 实例对象。在构造函数中，有通过zk客户端去拉取配置信息，具体逻辑在findProperties 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findProperties</span><span class="params">(String path, List&lt;String&gt; children)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 省略 ... </span></span><br><span class="line"><span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">String childPath = path + <span class="string">"/"</span> + child;</span><br><span class="line">List&lt;String&gt; childPathChildren = getChildren(childPath);</span><br><span class="line">        <span class="comment">// 获取节点信息</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = getPropertyBytes(childPath);</span><br><span class="line"><span class="keyword">if</span> (bytes == <span class="keyword">null</span> || bytes.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (childPathChildren == <span class="keyword">null</span> || childPathChildren.isEmpty()) &#123;</span><br><span class="line">registerKeyValue(childPath, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">registerKeyValue(childPath, <span class="keyword">new</span> String(bytes, Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查子节点，即使我们已经找到当前znode的值</span></span><br><span class="line">findProperties(childPath, childPathChildren);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line"><span class="comment">// 省略 ... </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动刷新机制"><a href="#自动刷新机制" class="headerlink" title="自动刷新机制"></a>自动刷新机制</h3><p>当修改配置信息之后，通过zk自身的监听机制，通知客户端。这个机制是在ZookeeperConfigAutoConfiguration自动配置类中提供。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(RefreshEndpoint.class)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkRefreshConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(name = <span class="string">"spring.cloud.zookeeper.config.watcher.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigWatcher <span class="title">configWatcher</span><span class="params">(ZookeeperPropertySourceLocator locator,</span></span></span><br><span class="line"><span class="function"><span class="params">CuratorFramework curator)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConfigWatcher(locator.getContexts(), curator);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConfigWatcher 实现了 Closeable、TreeCacheListener 和 ApplicationEventPublisherAware 三个接口。Tree Cache 用于观察所有节点的所有数据状态，ApplicationEventPublisherAware用户提供一个publiser，用来发布RefreshEvent 事件。Closeable 用于实现优雅关闭。</p><p>所有当我们改变zk数据节点时，就是触发例如 NODE_ADDED 、NODE_REMOVED、NODE_UPDATED 等事件类型，然后publiser就会发布一个 RefreshEvent 事件，通知客户端进行配置更新操作。从而实现配置的自动刷新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇可以配合《&lt;a href=&quot;http://www.glmapper.com/2018/12/31/springcoud-config-project/&quot;&gt;SpringCloud-配置中心 Config&lt;/a&gt;》来看，《&lt;a href=&quot;http://www.glmapp
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="zookeeper" scheme="http://www.glmapper.com/tags/zookeeper/"/>
    
      <category term="Config" scheme="http://www.glmapper.com/tags/Config/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-配置中心 spring-cloud-config-zookeeper</title>
    <link href="http://www.glmapper.com/2019/01/05/springcloud-config-zk-project/"/>
    <id>http://www.glmapper.com/2019/01/05/springcloud-config-zk-project/</id>
    <published>2019-01-05T09:12:07.000Z</published>
    <updated>2019-01-05T12:39:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>SpringCloud 除了config自己的client/server 这套配置中心之外，还可以集成使用 zookeeper 。本篇将演示如何使用 spring-cloud-confg-zookeeper。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK<br></td><td>1.8.0_162<br></td></tr><tr><td>SOFABoot/SpringBoot<br></td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE<br></td></tr><tr><td>SpringCloud<br></td><td>Finchley.RC1<br></td></tr><tr><td>IDE<br></td><td>IDEA<br></td></tr></tbody></table><h2 id="zk-amp-zkui"><a href="#zk-amp-zkui" class="headerlink" title="zk &amp; zkui"></a>zk &amp; zkui</h2><p>这里我是把 zk 和 zkui 部署在一台 linux 服务器上的。</p><h3 id="zk"><a href="#zk" class="headerlink" title="zk"></a>zk</h3><p>从 ZooKeeper官网 下载 zookeeper-3.4.13.tar.gz。</p><ul><li><p>解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf zookeeper-3.4.13.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>目录重命名(可选)</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv zookeeper-3.4.13 zookeeper</span><br></pre></td></tr></table></figure><ul><li>在 zookeeper 下加一个data目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">cd</span> zookeeper</span><br><span class="line">&gt; mkdir data</span><br></pre></td></tr></table></figure><ul><li>修改 zoo.cfg</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim zoo.cfg</span><br></pre></td></tr></table></figure><ul><li>修改 dataDir 地址：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/$&#123;your path&#125;/zookeeper/data</span><br></pre></td></tr></table></figure><ul><li>其他随意，启动 zk</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure><h3 id="zkui"><a href="#zkui" class="headerlink" title="zkui"></a>zkui</h3><p>下载zkui代码，然后本地安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://gitee.com/ilanni/zkui.git</span><br><span class="line">$ <span class="built_in">cd</span> zkui/ </span><br><span class="line">$ mvn clean install <span class="comment"># 进行maven打包，执行成功后会生成target文件夹，其中有jar文件。</span></span><br></pre></td></tr></table></figure><p>执行结束后在zkui文件夹下生成一个target文件夹。</p><ul><li>将config.cfg文件复制到target文件夹下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp config.cfg target/</span><br></pre></td></tr></table></figure><p>target文件夹中有两个jar包，我们只需要启动<code>zkui-2.0-SNAPSHOT-jar-with-dependencies.jar</code>就可以了。</p><ul><li>修改 config.cfg文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">cd</span> target</span><br><span class="line">&gt; vim config.cfg</span><br></pre></td></tr></table></figure><p>按需修改serverPort、zkServer、userSet 等。</p><ul><li>启动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar zkui-2.0-SNAPSHOT-jar-with-dependencies.jar</span><br><span class="line"><span class="comment"># nohup java -jar zkui-2.0-SNAPSHOT-jar-with-dependencies.jar &amp;   #退出窗口不退出进程</span></span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>既然是以 zk 作为配置中，那么就需要将测试用的配置数据先在zk上进行初始化。有两种方式（均基于zkui）：</p><ul><li>zkui 界面通过 import 进行导入，这里新建一个 config.txt ，内容如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/config/sofa/sofa-config-zk,dev=server.port=8085</span><br></pre></td></tr></table></figure><p>设置当前应用启动的端口，这里的 root 为 /config/sofa，应用名是 sofa-config-zk，dev是环境 ，server.port=8085 是具体的配置kv。</p><ul><li>手动 add node</li></ul><p>这里为了方便，采用import的方式，结果如下：<br><img src="https://oscimg.oschina.net/oscnet/afaf490914a21de6eb087ec02582cc7f1d2.jpg" alt="image.png"></p><h2 id="新建-sofa-config-zookeeper"><a href="#新建-sofa-config-zookeeper" class="headerlink" title="新建 sofa-config-zookeeper"></a>新建 sofa-config-zookeeper</h2><p>新建一个 SOFABoot 工程，项目为 sofa-config-zookeeper。</p><h3 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring-cloud-config zk 的依赖，必选--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- spring-cloud-config zk 的依赖，为了自动刷新监听等--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sofa-config-zk</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">  cloud:</span><br><span class="line">    zookeeper:</span><br><span class="line">      enabled: true  # true:开启zookeeper外部化配置, false:读取本地配置;</span><br><span class="line">      connect-string: sofa.cloud.alipay.net:2181</span><br><span class="line">      config:</span><br><span class="line">        root: /config/sofa   #指定zookeeper中属性的根目录</span><br><span class="line">        enabled: true</span><br><span class="line">        watcher:</span><br><span class="line">          enabled: true    #默认值是true, 监控配置变更后是否自动更新，需配合Spring Boot Actuators 使用</span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaConfigZookeeperApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaConfigZookeeperApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有任何特殊，不需要加额外的注解。</p><h3 id="资源类"><a href="#资源类" class="headerlink" title="资源类"></a>资源类</h3><p>其实这里可以完全不用通过rest来打印这个属性值，但是为了方便看，还是写一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperConfigController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/config"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serverPort;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动-amp-验证"><a href="#启动-amp-验证" class="headerlink" title="启动&amp;验证"></a>启动&amp;验证</h3><p>启动应用，如果成功的话，会有如下的日志：State change: CONNECTED</p><p><img src="https://oscimg.oschina.net/oscnet/42dfc087c51e1b5e1044b0d87900b3003ca.jpg" alt="image.png"></p><p>tomcat 启动端口:</p><p><img src="https://oscimg.oschina.net/oscnet/b506f78b41460610be7057b8be7b421d9d5.jpg" alt="image.png"></p><p>因为在上面配置文件部分是没有指定 server.port 的，通常情况下默认是 8080 ，所以可以确定，已经拿到了配置中心的数据了。</p><h2 id="动态刷新"><a href="#动态刷新" class="headerlink" title="动态刷新"></a>动态刷新</h2><p>这里还是需要依赖 actuator 的 /refresh 。上面依赖中已经加入了 actuator的相关依赖，所以只需要在资源类上加一个 <a href="#">@RefreshScope</a> 注解即可。</p><ul><li>在 ZookeeperConfigController 类上加 <a href="#">@RefreshScope</a>  注解，然后重启应用</li><li>通过 zkui 修改 server.port 为 8086</li><li>访问 <a href="http://localhost:8065/config" target="_blank" rel="noopener">http://localhost:8085/config</a> ，返回8086</li></ul><blockquote><p>需要注意，这里因为我们启动时应用时拿到的配置是8085，所以当前服务对外提供服务暴露的端口就是8085 ，当我们修改了zk上的值之后，他会改变 当前运行环境中 Enviroment 的值，但是不会使得服务的端口发生变化，除非重启。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SpringCloud 除了config自己的client/server 这套配置中心之外，还可以集成使用 zookeeper 。本篇将演示如何使用 spring-cloud-confg-zookeeper。&lt;/p&gt;
&lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="zookeeper" scheme="http://www.glmapper.com/tags/zookeeper/"/>
    
      <category term="Config" scheme="http://www.glmapper.com/tags/Config/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下安装 Mysql 数据库</title>
    <link href="http://www.glmapper.com/2019/01/05/mysql-on-linux/"/>
    <id>http://www.glmapper.com/2019/01/05/mysql-on-linux/</id>
    <published>2019-01-05T09:09:15.000Z</published>
    <updated>2019-08-01T14:16:03.081Z</updated>
    
    <content type="html"><![CDATA[<p>最近在搞 Apollo ，熟悉的同学应该知道，Apollo 需要依赖 Mysql。本以为很容易搞定，但是却踩了一路坑，眼高手低，也参考了网上很多博客，果然是残缺就是美！本篇就简单记录一下这个过程，以便后面参考。</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li><p>linux：centOS 7</p></li><li><p>jdk：8</p></li><li><p>Mysql：5.7.24</p></li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>安装前，我们可以检测系统是否自带安装 MySQL:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep mysql</span><br></pre></td></tr></table></figure><p>如果你系统有安装，那可以选择进行卸载，有两种模式：</p><ul><li><p>普通删除模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e mysql</span><br></pre></td></tr></table></figure></li><li><p>强力删除模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps mysql</span><br></pre></td></tr></table></figure><p>如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除</p></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>下载mysql安装包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm</span><br><span class="line"></span><br><span class="line">-2018-06-06 16:41:46--  https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm</span><br><span class="line">正在解析主机 dev.mysql.com (dev.mysql.com)... xxxx</span><br><span class="line">正在连接 dev.mysql.com (dev.mysql.com)|xxxxx|:443... 已连接。</span><br><span class="line">已发出 HTTP 请求，正在等待回应... 302 Found</span><br><span class="line">位置：https://repo.mysql.com//mysql57-community-release-el7-9.noarch.rpm [跟随至新的 URL]</span><br><span class="line">--2018-06-06 16:41:48--  https://repo.mysql.com//mysql57-community-release-el7-9.noarch.rpm</span><br><span class="line">正在解析主机 repo.mysql.com (repo.mysql.com)... xxxxx</span><br><span class="line">正在连接 repo.mysql.com (repo.mysql.com)|xxxx|:443... 已连接。</span><br><span class="line">已发出 HTTP 请求，正在等待回应... 200 OK</span><br><span class="line">长度：9224 (9.0K) [application/x-redhat-package-manager]</span><br><span class="line">正在保存至: “mysql57-community-release-el7-9.noarch.rpm”</span><br><span class="line"></span><br><span class="line">100%[==========================================================&gt;] 9,224       --.-K/s 用时 0s      </span><br><span class="line"></span><br><span class="line">2018-06-06 16:41:48 (169 MB/s) - 已保存 “mysql57-community-release-el7-9.noarch.rpm” [9224/9224])</span><br></pre></td></tr></table></figure><ul><li>安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql57-community-release-el7-9.noarch.rpm</span><br><span class="line"></span><br><span class="line">准备中...                          ################################# [100%]</span><br><span class="line">正在升级/安装...</span><br><span class="line">   1:mysql57-community-release-el7-9  ################################# [100%]</span><br></pre></td></tr></table></figure><ul><li>下载安装依赖包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql-server</span><br><span class="line"></span><br><span class="line">已加载插件：fastestmirror, langpacks</span><br><span class="line">mysql-connectors-community                                                   | 2.5 kB  00:00:00     </span><br><span class="line">mysql-tools-community                                                        | 2.5 kB  00:00:00     </span><br><span class="line">mysql57-community                                                            | 2.5 kB  00:00:00     </span><br><span class="line">(1/3): mysql-connectors-community/x86_64/primary_db                          |  20 kB  00:00:00     </span><br><span class="line">(2/3): mysql-tools-community/x86_64/primary_db                               |  41 kB  00:00:00     </span><br><span class="line">(3/3): mysql57-community/x86_64/primary_db                                   | 144 kB  00:00:00     </span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.cn99.com</span><br><span class="line"> * extras: mirrors.cn99.com</span><br><span class="line"> * updates: mirrors.cn99.com</span><br><span class="line">正在解决依赖关系 </span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>第一次下载这里会比较慢</p><ul><li><p>验证是否安装成功</p><ul><li>mysqladmin –version</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin  Ver 8.42 Distrib 5.7.22, for Linux on x86_64</span><br></pre></td></tr></table></figure><ul><li>mysql -V</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql  Ver 14.14 Distrib 5.7.24, for Linux (x86_64) using  EditLine wrapper</span><br></pre></td></tr></table></figure></li><li><p>启动MySQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start mysqld</span><br></pre></td></tr></table></figure></li><li><p>查看 MySQL 运行状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status mysqld</span><br></pre></td></tr></table></figure></li><li><p>停止 MySQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop mysqld</span><br></pre></td></tr></table></figure></li><li><p>重启 MySQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart mysqld</span><br></pre></td></tr></table></figure></li></ul><h3 id="关于密码"><a href="#关于密码" class="headerlink" title="关于密码"></a>关于密码</h3><p>Mysql 5.7 默认安装之后 root 是有密码的，获取 MySQL 的临时密码 为了加强安全性，MySQL 5.7 为 root 用户随机生成了一个密码，在 error log 中，关于 error log 的位置，如果安装的是 RPM 包，则默认是 /var/log/mysqld.log 。 只有启动过一次 mysql 才可以查看临时密码。</p><p>在利用 YUM 安装 mysql 数据库过程中，系统会自动生成一个临时密码，获取方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &apos;temporary password&apos; /var/log/mysqld.log</span><br></pre></td></tr></table></figure><ul><li><p>没有密码</p><p>如果以前安装过 mysql，这时的 mysqld.log 中就不会有 temporary password<br>这时就需要删除 mysql 残留的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /var/lib/mysql</span><br></pre></td></tr></table></figure><p>执行完毕后需要重新启动MySQL服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart mysqld</span><br></pre></td></tr></table></figure><p>这时就可以通过上面的命令去查找数据库生成的临时密码了</p></li></ul><h3 id="mysql-1130-错误"><a href="#mysql-1130-错误" class="headerlink" title="mysql 1130 错误"></a>mysql 1130 错误</h3><p>可能是你的帐号不允许从远程登陆，只能在 localhost。这个时候只要在 localhost 的那台电脑，登入 mysql 后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称”%”</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -pvmwaremysql&gt;use mysql;</span><br><span class="line">mysql&gt; update user set host = '%' where user = 'root';</span><br><span class="line">mysql&gt; select host, user from user;</span><br></pre></td></tr></table></figure><p>使得我们当前的账户和密码能够应用的所有的远程主机连接：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; GRANT ALL PRIVILEGES ON . TO 'myuser'@'%' IDENTIFIED BY 'mypassword' WITH GRANT OPTION;</span><br><span class="line">&gt; FLUSH   PRIVILEGES;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在搞 Apollo ，熟悉的同学应该知道，Apollo 需要依赖 Mysql。本以为很容易搞定，但是却踩了一路坑，眼高手低，也参考了网上很多博客，果然是残缺就是美！本篇就简单记录一下这个过程，以便后面参考。&lt;/p&gt;
&lt;h3 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; c
      
    
    </summary>
    
      <category term="运维" scheme="http://www.glmapper.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="mysql" scheme="http://www.glmapper.com/tags/mysql/"/>
    
      <category term="linux" scheme="http://www.glmapper.com/tags/linux/"/>
    
  </entry>
  
</feed>
