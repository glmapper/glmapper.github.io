<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>glmapper</title>
  
  <subtitle>大家都喊我磊叔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.glmapper.com/"/>
  <updated>2019-01-18T16:26:12.000Z</updated>
  <id>http://www.glmapper.com/</id>
  
  <author>
    <name>GuoLei Song</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringCloud-网关 Gateway 入门体验</title>
    <link href="http://www.glmapper.com/2019/01/19/springcloud-gateway-predicate-project/"/>
    <id>http://www.glmapper.com/2019/01/19/springcloud-gateway-predicate-project/</id>
    <published>2019-01-19T00:21:33.000Z</published>
    <updated>2019-01-18T16:26:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>网关服务核心是将进入的请求正确合理的路由到下层具体的服务进行业务处理，从它的功能来看，网关服务的核心就是路由信息的构建。</p><p>Spring Cloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Netflix Zuul，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全、监控、埋点和限流等。下面是官方提供的一个工作原理图：</p><p><img src="https://oscimg.oschina.net/oscnet/e9d92479a1dbcdf618d33918468b30c2c8b.jpg" alt=""></p><p>客户端发送请求到 Spring Cloud Gateway，Gateway Handler Mapping 确定请求与路由匹配，则会将请求交给Gateway Web Handler 处理。在代理前后可以执行多个过滤器。最后代理到具体的服务。</p><h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><ul><li>Route：Gateway 中的基本元素，它有自己的 ID、URI 、 Predicate 集合和 Filter 集合</li><li>Predicate：判断请求的 Url 是否匹配当前的 Route</li><li>Filter ：匹配通过之后对请求和响应的处理及修饰</li></ul><p>Spring-Cloud-Gateway 构建路由的数据流向：</p><p><img src="https://oscimg.oschina.net/oscnet/2d7cd3c3fd3452d70112893a4c175943ae0.jpg" alt=""></p><p>RouteDefinition 模型是对 Route 模型中 route 的定义以及描述，Spring-Cloud-Gateway 最终会通过RouteDefinition 来构建起 Route 实例信息。其中 RouteDefinition 代码包含两个数组分别是PredicateDefinition，FilterDefinition。</p><h3 id="内置的-Predicate"><a href="#内置的-Predicate" class="headerlink" title="内置的 Predicate"></a>内置的 Predicate</h3><p>Spring Cloud Gateway 是通过 Spring WebFlux 的 <code>HandlerMapping</code> 做为底层支持来匹配到转发路由，Spring Cloud Gateway 内置了很多 Predicates 工厂，这些 Predicates 工厂通过不同的 HTTP 请求参数来匹配，多个 Predicates 工厂可以组合使用。下面是内置的Predicates：</p><table><thead><tr><th>组件</th><th>备注</th></tr></thead><tbody><tr><td>After Route Predicate Factory</td><td>此谓词匹配当前日期时间之后发生的请求。</td></tr><tr><td>Before Route Predicate Factory</td><td>此谓词匹配在当前日期时间之前发生的请求。</td></tr><tr><td>Between Route Predicate Factory</td><td>此谓词匹配datetime1之后和datetime2之前发生的请求。 datetime2参数必须在datetime1之后。</td></tr><tr><td>Cookie Route Predicate Factory</td><td>Cookie Route Predicate Factory有两个参数，cookie名称和正则表达式。此谓词匹配具有给定名称且值与正则表达式匹配的cookie。</td></tr><tr><td>Header Route Predicate Factory</td><td>Header Route Predicate Factory有两个参数，标题名称和正则表达式。与具有给定名称且值与正则表达式匹配的标头匹配。</td></tr><tr><td>Host Route Predicate Factory</td><td>Host Route Predicate Factory采用一个参数：主机名模式。该模式是一种Ant样式模式“.”作为分隔符。此谓词匹配与模式匹配的Host标头。</td></tr><tr><td>Method Route Predicate Factory</td><td>Method Route Predicate Factory采用一个参数：要匹配的HTTP方法。</td></tr><tr><td>Path Route Predicate Factory</td><td>匹配请求的path</td></tr><tr><td>Query Route Predicate Factory</td><td>Query Route Predicate Factory有两个参数：一个必需的参数和一个可选的正则表达式。</td></tr><tr><td>RemoteAddr Route Predicate Factory</td><td>RemoteAddr Route Predicate Factory采用CIDR符号（IPv4或IPv6）字符串的列表（最小值为1），例如， 192.168.0.1/16（其中192.168.0.1是IP地址，16是子网掩码）。</td></tr></tbody></table><h2 id="工程代码"><a href="#工程代码" class="headerlink" title="工程代码"></a>工程代码</h2><p>本篇将通过一个简单的 gateway 工程来演示如何使用上面的 Predicate 来实现路由。</p><h3 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h3><p>这里新建一个 <a href="https://github.com/glmapper/glmapper-cloud-parent" target="_blank" rel="noopener">glmapper-cloud-gateway</a> 工程，具体细节如下</p><h3 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h3><p>首先在当前工程的pom文件中引入spring cloud gateway 的依赖：spring-cloud-starter-gateway</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件部分，除了常规的端口，应用名之外；关于spring cloud 的路由规则也可以通过配置文件进行配置，下面先以最简单的 path的方式来演示，最终达到的目标是，当输入：<a href="http://localhost:8866/gateway" target="_blank" rel="noopener">http://localhost:8866/gateway</a> 时，请求信息将会被路由到 <a href="http://localhost:8086/hello" target="_blank" rel="noopener">http://localhost:8086/hello</a>(这个是一个eureka client，对外提供rest服务，工程详见<a href="https://github.com/glmapper/glmapper-cloud-parent/tree/master/glmapper-eureka-provider" target="_blank" rel="noopener">glmapper-eureka-provider</a>)。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span>   <span class="comment">#eureka server 的地址</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8866</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">glmapper-cloud-gateway</span>  <span class="comment">#应用名</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://localhost:8086/hello</span>   <span class="comment">#目标地址</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Path=/gateway</span>   <span class="comment">#路由规则</span></span><br></pre></td></tr></table></figure><h3 id="启动应用-amp-验证"><a href="#启动应用-amp-验证" class="headerlink" title="启动应用&amp;验证"></a>启动应用&amp;验证</h3><p>这里直接启动这个工程，SpringCloud Gateway 不需要额外的注解来开启网关服务，所以这里省略启动类的代码。先后启动 glmapper-eureka-server 、glmapper-eureka-provider、glmapper-cloud-gateway。</p><p>在浏览器中输入：<a href="http://localhost:8866/gateway" target="_blank" rel="noopener">http://localhost:8866/gateway</a> ，输出的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Glmapper! Now Port is 8086 And hostname is HelloGlmapperService</span><br></pre></td></tr></table></figure><p>这里输出的实际上是  <a href="http://localhost:8086/hello" target="_blank" rel="noopener">http://localhost:8086/hello</a> 提供的资源，说明我们的路由规则已经生效。</p><h2 id="内置-Predicate-规则配置"><a href="#内置-Predicate-规则配置" class="headerlink" title="内置 Predicate 规则配置"></a>内置 Predicate 规则配置</h2><p>上面已经罗列了所有的 spring cloud gateway 一些内置的 Predicate  ，下面将来使用这些规则来演示下。</p><h3 id="时间匹配"><a href="#时间匹配" class="headerlink" title="时间匹配"></a>时间匹配</h3><p>Predicate 支持设置一个时间，在请求进行转发的时候，可以通过判断在这个时间之前或者之后进行转发。在上面的列表中可以看出，基于时间的匹配支持某时间节点之前、之后，还支持介于两个时间之间的某个时间段内的匹配。基于某个时间段内的匹配规则常见的场景是限时抢购。</p><ul><li>After Route Predicate</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span>     <span class="comment">#自定义的路由ID</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://www.glmapper.com</span> <span class="comment">#目标服务地址</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">After=2019-01-10T00:00:00+08:00[Asia/Shanghai]</span> <span class="comment">#通过时间匹配 2019年1月10日</span></span><br></pre></td></tr></table></figure><p>After Route Predicate 是指在这个时间之后的请求都转发到目标地址。请求时间在 2019年1月10日日00点00分00秒之后的所有请求都转发到地址 <a href="http://www.glmapper.com。+08:00是指时间和UTC时间相差八个小时，时间地区为" target="_blank" rel="noopener">http://www.glmapper.com。+08:00是指时间和UTC时间相差八个小时，时间地区为</a> Asia/Shanghai。</p><ul><li>Before Route Predicate</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span>     <span class="comment">#自定义的路由ID</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://www.glmapper.com</span> <span class="comment">#目标服务地址</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Before=2019-01-10T00:00:00+08:00[Asia/Shanghai]</span> <span class="comment">#通过时间匹配 2019年1月10日</span></span><br></pre></td></tr></table></figure><p>Before Route Predicate 与 After Route Predicate 刚好相反，在某个时间之前的请求的请求都进行转发。</p><ul><li>Between Route Predicate</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">       - id:</span> <span class="string">glmapper</span><span class="comment">#自定义的路由ID</span></span><br><span class="line">       <span class="attr">uri:</span> <span class="attr">http://www.glmapper.com</span><span class="comment">#目标服务地址</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">         -</span> <span class="string">Between=2019-01-10T00:00:00+08:00[Asia/Shanghai],</span> <span class="number">2019</span><span class="bullet">-01</span><span class="bullet">-10</span><span class="attr">T06:00:00+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure><p>在2019年1月10 零点至6点之间的请求将会被路由到 <a href="http://www.glmapper.com">http://www.glmapper.com</a> ，其他的请求将不会被路由。</p><h3 id="Cookie-或者-Header"><a href="#Cookie-或者-Header" class="headerlink" title="Cookie 或者 Header"></a>Cookie 或者 Header</h3><ul><li>Cookie Route Predicate</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://localhost:8086/hello</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Cookie=name,glmapper</span></span><br></pre></td></tr></table></figure><p>这里，如果我的请求信息中存在 cookie name 为 glmapper，值匹配到 glmapper 的串，那么请求将会被路由。</p><p><img src="https://oscimg.oschina.net/oscnet/05fc182cf12e602fa1e7e467c83d7b31da3.jpg" alt="cookie"></p><blockquote><p>PS：这里在配置的时候要注意下 routes 后面格式缩进，否则会抛出一些异常，如：</p><pre><code>Property: spring.cloud.gateway.routes[0].uriValue: nullReason: 不能为nullProperty: spring.cloud.gateway.routes[0].predicatesValue: []Reason: 不能为空</code></pre></blockquote><p>当cookie的值不满足时，访问时404</p><p><img src="https://oscimg.oschina.net/oscnet/680e41ff99bcc15910217ba1ec40812d9a6.jpg" alt="cookie404"></p><ul><li>Header Route Predicate</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">glmapper-cloud-gateway</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://localhost:8086/hello</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br></pre></td></tr></table></figure><p>上面这段配置用于配置 Header 中 X-Request-Id值数字的请求：</p><p><img src="https://oscimg.oschina.net/oscnet/2a88bdad6acd7902f2415089e943b3390f0.jpg" alt="header"></p><p>同样，如果是非数字的话将会返回 404。</p><h3 id="域名匹配"><a href="#域名匹配" class="headerlink" title="域名匹配"></a>域名匹配</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">glmapper-cloud-gateway</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://localhost:8086/hello</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Host=**.glmapper.com</span></span><br></pre></td></tr></table></figure><p>上面这段配置用于匹配 host 为 xxx.glmapper.com 域名的请求：</p><p><img src="https://oscimg.oschina.net/oscnet/b2b68159505c906007107ecd2195bcb7326.jpg" alt="host"></p><p>关于其他的内置 Predicate 均可在官方文档中有实例参考，这里就不一一罗列了。</p><h3 id="组合匹配"><a href="#组合匹配" class="headerlink" title="组合匹配"></a>组合匹配</h3><p>最后我们来将上面的一些进行组合，假设我需要在 <code>2019.1.10 0点至2019.1.10 6点之间，cookie中带有name=glmapper，header 的 X-Request-Id 为数字，域名是 xx.glmapper.com ，path为 /gateway ，请求方式为GET，参数名为queryParam</code> 的请求路由到 <a href="http://localhost:8086/hello。那么具体配置如下" target="_blank" rel="noopener">http://localhost:8086/hello。那么具体配置如下</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">glmapper-cloud-gateway</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://localhost:8086/hello</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Host=**.glmapper.com</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Path=/gateway</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Method=GET</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Header=X-Request-Id,\d+</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Query=queryParam</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Cookie=name,glmapper</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Between=2019-01-10T00:00:00+08:00[Asia/Shanghai],</span> <span class="number">2019</span><span class="bullet">-01</span><span class="bullet">-10</span><span class="attr">T06:00:00+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure><p>还是通过curl 命令来执行以下：</p><p><img src="https://oscimg.oschina.net/oscnet/d78beeac5d4959ba1ade7577c0e54ba9489.jpg" alt="composite"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.0.2.RELEASE/single/spring-cloud-gateway.html#gateway-starter" target="_blank" rel="noopener">Spring Cloud Gateway</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网关服务核心是将进入的请求正确合理的路由到下层具体的服务进行业务处理，从它的功能来看，网关服务的核心就是路由信息的构建。&lt;/p&gt;
&lt;p&gt;Spring Cloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Netflix Zuul，其不仅提
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="Gateway" scheme="http://www.glmapper.com/tags/Gateway/"/>
    
      <category term="网关" scheme="http://www.glmapper.com/tags/%E7%BD%91%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-断路器 Hystrix</title>
    <link href="http://www.glmapper.com/2019/01/09/springcloud-hystrix-project/"/>
    <id>http://www.glmapper.com/2019/01/09/springcloud-hystrix-project/</id>
    <published>2019-01-09T11:28:18.000Z</published>
    <updated>2019-01-09T14:46:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Hystrix 是 Netflix 的一个开源项目，它能够在服务失效的情况下，通过隔离系统依赖服务的方式，防止服务级联失败，造成服务雪崩。同时Hystrix 还提供了失败回滚机制，使得系统能够更快的从异常中恢复。Hystrix 为服务间调用提供了保护和控制。</p><p>Hystrix 具有的功能如下：</p><ul><li>当通过客户端调用服务出现高延迟或者调用失败时，能够为系统提供保护机制</li><li>在复杂的分布式场景下，可以防止服务雪崩效应</li><li>提供快速失败（Fail Fast） 同时能够快速恢复</li><li>提供失败回滚和优雅的服务降级机制</li><li>提供近实时的监控、报警和运维控制手段</li></ul><p>Hystrix 在实际应用过程中的使用方式很丰富，可以通过注解，也可以通过集成 HystrixCommand 和HystrixObservableCommand 。本篇将通过案例简单说明下说用方式。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK</td><td>1.8.0_162</td></tr><tr><td>SOFABoot/SpringBoot</td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE</td></tr><tr><td>SpringCloud</td><td>Finchley.RC1</td></tr><tr><td>IDE</td><td>IDEA</td></tr></tbody></table><h2 id="工程背景"><a href="#工程背景" class="headerlink" title="工程背景"></a>工程背景</h2><p>本节将会创建一个 sofa-hystrix-client 工程，通过 Spring Cloud 提供的负载均衡器 hystrix 实现服务的熔断降级。</p><h2 id="新建-sofa-hystrix-client"><a href="#新建-sofa-hystrix-client" class="headerlink" title="新建 sofa-hystrix-client"></a>新建 sofa-hystrix-client</h2><p>本工程继续使用《SpringCloud-Eureka 服务注册》中的父工程来构建。</p><p>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p><ul><li>artifactId：sofa-hystrix-client</li></ul><h3 id="修改pom文件"><a href="#修改pom文件" class="headerlink" title="修改pom文件"></a>修改pom文件</h3><p>pom文件中加入 hysterix 的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">hystrix-client</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8787</span></span><br></pre></td></tr></table></figure><p>没有什么特殊的配置，还是作为一个 eureka-client 存在。</p><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>启动类上增加开启断路器的注解@EnableCircuitBreaker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaHystrixApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaHystrixApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="资源类"><a href="#资源类" class="headerlink" title="资源类"></a>资源类</h3><ul><li>NormalService </li></ul><p>中通过@HystrixCommand标准一个受保护的资源方法 getByServiceId()。getByServiceId 中通过restTemplate 来调用远程服务。@HystrixCommand注解的 fallbackMethod 属性指定当服务不可用时需要执行的 fallback 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"fallBack"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getByServiceId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://HELLOSOFABOOTSERVICE/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">fallBack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Filed to get data"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>HystrixRibbonController：通过instanceService调用上面的NormalService资源类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixRibbonController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> NormalService instanceService;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hystrix"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instanceService.getByServiceId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动-amp-验证"><a href="#启动-amp-验证" class="headerlink" title="启动&amp;验证"></a>启动&amp;验证</h3><p>先后启动sofa-eureka-server-center 、sofa-eureka-provider、sofa-hystrix-client 三个工程。浏览器中输入：</p><p><a href="http://localhost:8787/hystrix" target="_blank" rel="noopener">http://localhost:8787/hystrix</a> ，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello SOFA! Now Port is 8086 And hostname is HelloSOFABootService</span><br></pre></td></tr></table></figure><p>关闭 sofa-eureka-provider ，刷新浏览器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Filed to get data</span><br></pre></td></tr></table></figure><p>执行了 NormalService 中的 fallback 方法了。</p><h2 id="资源隔离"><a href="#资源隔离" class="headerlink" title="资源隔离"></a>资源隔离</h2><p>hystrix 中提供了两中隔离策略，一种是基于线程池的隔离、另外一种是基于信号量的隔离。本篇只演示案例，具体原理请参看 hystrix 原理分析 相关文章。</p><h3 id="基于线程池的隔离实现"><a href="#基于线程池的隔离实现" class="headerlink" title="基于线程池的隔离实现"></a>基于线程池的隔离实现</h3><p>新建一个 SofaThreadPoolHystrixCommand 类，继承 HystrixCommand。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaThreadPoolHystrixCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SofaThreadPoolHystrixCommand</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initailize());</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HystrixCommand.<span class="function">Setter <span class="title">initailize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 线程池配置</span></span><br><span class="line">        HystrixThreadPoolProperties.Setter hystrixThreadPoolProperties = </span><br><span class="line">            HystrixThreadPoolProperties.Setter()</span><br><span class="line">                .withCoreSize(<span class="number">5</span>)</span><br><span class="line">                .withKeepAliveTimeMinutes(<span class="number">5</span>)</span><br><span class="line">                <span class="comment">// 线程等待队列最大长度,默认值:-1 表示不等待直接拒绝,测试表明线程池使用直接决绝策略+ 合适大小的非回缩线程池效率最高.所以不建议修改此值。</span></span><br><span class="line">                .withMaxQueueSize(<span class="number">10</span>)</span><br><span class="line">                .withQueueSizeRejectionThreshold(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 命令属性配置,这里指定隔离策略是 THREAD</span></span><br><span class="line">        HystrixCommandProperties.Setter hystrixCommand = </span><br><span class="line">            HystrixCommandProperties.Setter() .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD)</span><br><span class="line">                <span class="comment">//意味着线程最多允许执行fallback的并发数为10,超过10 报fallback execution rejected</span></span><br><span class="line">                .withFallbackIsolationSemaphoreMaxConcurrentRequests(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        HystrixCommand.Setter setter = HystrixCommand.Setter</span><br><span class="line">            .withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"SofaThreadPoolHystrixCommand"</span>))</span><br><span class="line">                .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">"sofaBootService"</span>))</span><br><span class="line">                .andCommandPropertiesDefaults(hystrixCommand)</span><br><span class="line">                .andThreadPoolPropertiesDefaults(hystrixThreadPoolProperties)</span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">"sofa-hystrix-thread"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> setter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 受保护的资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://HELLOSOFABOOTSERVICE/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 失败执行的保护方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"this is fail back policy"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关参数说明：</p><ul><li>HystrixCommandGroupKey：配置全局唯一标识服务分组的名称，比如账户系统就是一个服务分组，监控时，相同分组的服务会聚合在一起，必填选项。</li><li>HystrixCommandKey：配置全局唯一标识服务的名称，比如账户系统有一个获取账号名的服务，那么就可以为这个服务起一个名字来唯一识别该服务，如果不配置，则默认是简单类名。</li><li>HystrixThreadPoolKey：配置全局唯一标识线程池的名称，相同线程池名称的线程池是同一个，如果不配置，则默认是分组名，此名字也是线程池中线程名字的前缀。</li><li>HystrixThreadPoolProperties：配置线程池参数</li><li>HystrixCommandProperties：配置该命令的一些参数，如 executionIsolationStrategy 配置执行隔离策略，默认是使用线程隔离。配置为 THREAD，线程池隔离；配置为 SEMAPHORE ，信号量隔离</li></ul><p>这里为了模拟并发，使用 CountDownLatch 类来控制，在 HystrixRibbonController 中添加 testThread 资源方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testThread"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUM; i ++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ConsumerThread(countDownLatch)).start();</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.countDown();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"data"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部定义一个内部类，模拟调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startLatch;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConsumerThread</span><span class="params">(CountDownLatch startLatch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.startLatch = startLatch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 线程等待</span></span><br><span class="line">                startLatch.await();</span><br><span class="line">                <span class="comment">// 执行操作</span></span><br><span class="line">                SofaThreadPoolHystrixCommand sofaThreadPoolHystrixCommand = <span class="keyword">new</span> SofaThreadPoolHystrixCommand(restTemplate);</span><br><span class="line">                System.out.println(sofaThreadPoolHystrixCommand.execute().toString());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重启当前工程，浏览器执行 <a href="http://localhost:8787/testThread" target="_blank" rel="noopener">http://localhost:8787/testThread</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this is fail back policy</span><br><span class="line">this is fail back policy</span><br><span class="line">this is fail back policy</span><br><span class="line">this is fail back policy</span><br><span class="line">this is fail back policy</span><br><span class="line">// ... 省略</span><br><span class="line">Hello SOFA! Now Port is 8086 And hostname is HelloSOFABootService</span><br><span class="line">// ... 省略</span><br></pre></td></tr></table></figure><h3 id="基于信号量隔离"><a href="#基于信号量隔离" class="headerlink" title="基于信号量隔离"></a>基于信号量隔离</h3><p>新建一个 SofaSemaphoreHystrixCommand 类，继承 HystrixCommand。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaSemaphoreHystrixCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SofaSemaphoreHystrixCommand</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initailize());</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HystrixCommand.<span class="function">Setter <span class="title">initailize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 命令属性配置,这里指定隔离策略是 THREAD</span></span><br><span class="line">        HystrixCommandProperties.Setter hystrixCommand = HystrixCommandProperties.Setter()</span><br><span class="line">                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.SEMAPHORE)</span><br><span class="line">                 <span class="comment">//至少有10个请求，熔断器才进行错误率的计算</span></span><br><span class="line">                .withCircuitBreakerRequestVolumeThreshold(<span class="number">0</span>)</span><br><span class="line">                <span class="comment">//熔断器中断请求5秒后会进入半打开状态,放部分流量过去重试</span></span><br><span class="line">                .withCircuitBreakerSleepWindowInMilliseconds(<span class="number">5000</span>)</span><br><span class="line">                <span class="comment">//错误率达到50开启熔断保护</span></span><br><span class="line">                .withCircuitBreakerErrorThresholdPercentage(<span class="number">50</span>)</span><br><span class="line">                <span class="comment">//最大并发请求量</span></span><br><span class="line">                .withExecutionIsolationSemaphoreMaxConcurrentRequests(<span class="number">10</span>)</span><br><span class="line">                <span class="comment">//意味着信号量最多允许执行fallback的并发数为10,超过10 报fallback execution rejected</span></span><br><span class="line">                .withFallbackIsolationSemaphoreMaxConcurrentRequests(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        HystrixCommand.Setter setter = HystrixCommand.Setter.</span><br><span class="line">                withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"SofaSemaphoreHystrixCommand"</span>))</span><br><span class="line">                .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">"sofaBootService"</span>))</span><br><span class="line">                .andCommandPropertiesDefaults(hystrixCommand)</span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">"sofa-hystrix-thread"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> setter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 受保护的资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://HELLOSOFABOOTSERVICE/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 失败执行的保护方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"this is fail back policy"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样使用 CountDownLatch  来模拟并发。在 HystrixRibbonController 中添加 testSemaphore 资源方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testSemaphore"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testSemaphore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUM; i ++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ConsumerSemaphore(countDownLatch)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"data"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>内部定义一个内部类 ConsumerSemaphore ，模拟调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerSemaphore</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startLatch;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConsumerSemaphore</span><span class="params">(CountDownLatch startLatch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.startLatch = startLatch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 线程等待</span></span><br><span class="line">                startLatch.await();</span><br><span class="line">                <span class="comment">// 执行操作</span></span><br><span class="line">                SofaSemaphoreHystrixCommand sofaThreadPoolHystrixCommand = <span class="keyword">new</span> SofaSemaphoreHystrixCommand(restTemplate);</span><br><span class="line">                System.out.println(sofaThreadPoolHystrixCommand.execute().toString());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果和线程隔离的差不多。不贴结果了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Hystrix 是 Netflix 的一个开源项目，它能够在服务失效的情况下，通过隔离系统依赖服务的方式，防止服务级联失败，造成服务雪崩。同
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="spring cloud" scheme="http://www.glmapper.com/tags/spring-cloud/"/>
    
      <category term="Hystrix" scheme="http://www.glmapper.com/tags/Hystrix/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-配置中心 Apollo</title>
    <link href="http://www.glmapper.com/2019/01/09/springcloud-config-apollo/"/>
    <id>http://www.glmapper.com/2019/01/09/springcloud-config-apollo/</id>
    <published>2019-01-09T11:18:42.000Z</published>
    <updated>2019-01-09T15:40:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Apollo（阿波罗）是携程框架部门研发的开源配置管理中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性。</p><p>本篇将搭建一套 Apollo 配置中心环境，并通过一个 demo 案例来演示如何在 SpringCloud 体系中使用 Apollo。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK</td><td>1.8.0_162</td></tr><tr><td>SOFABoot/SpringBoot</td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE</td></tr><tr><td>SpringCloud</td><td>Finchley.RC1</td></tr><tr><td>IDE</td><td>IDEA</td></tr><tr><td>Mysql</td><td>5.7.24</td></tr><tr><td>CentOS</td><td>7</td></tr></tbody></table><p> Apollo 自身需要依赖 Mysql，在部署 Apollo 时需要提前安装 Mysql 数据库。关于 Mysql 的安装可以参考：<a href="http://www.glmapper.com/2019/01/05/mysql-on-linux/">Linux 下安装Mysql数据库</a>。</p><p>根据官方文档，Apollo 服务端需运行在 jdk 1.8 以上，客户端需运行在1.7 以上，Mysql 版本需在 5.6.5 版本以上。具体信息可参考：<a href="https://github.com/ctripcorp/apollo/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">分布式部署指南</a>。</p><h2 id="部署-Apollo"><a href="#部署-Apollo" class="headerlink" title="部署 Apollo"></a>部署 Apollo</h2><p>部署步骤共三步：</p><ul><li><p>创建数据库</p><ul><li>Apollo 服务端依赖于 MySQL 数据库，所以需要事先创建并完成初始化</li></ul></li><li><p>获取安装包</p><ul><li>Apollo 服务端安装包共有3个：apollo-configservice, apollo-adminservice, apollo-portal</li><li>可以直接下载事先打好的安装包，也可以自己通过源码构建</li></ul></li><li><p>部署 Apollo 服务端</p><ul><li>获取安装包后就可以部署到公司的测试和生产环境了</li></ul></li></ul><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>Apollo 服务端共需要两个数据库：<code>ApolloPortalDB</code>和<code>ApolloConfigDB</code>，我们把数据库、表的创建和样例数据都分别准备了 sql 文件，只需要导入数据库即可。</p><blockquote><p>需要注意的是 ApolloPortalDB 只需要在生产环境部署一个即可，而 ApolloConfigDB 需要在每个环境部署一套，如 fat、uat 和 pro 分别部署 3 套 ApolloConfigDB。</p></blockquote><blockquote><p>注意：如果本地已经创建过 Apollo 数据库，请注意备份数据；sql 文件会清空 Apollo 相关的表。</p></blockquote><p>两份 SQL 文件：</p><ul><li><a href="https://github.com/ctripcorp/apollo/blob/master/scripts/db/migration/portaldb/V1.0.0__initialization.sql" target="_blank" rel="noopener">apolloportaldb.sql</a></li><li><a href="https://github.com/ctripcorp/apollo/blob/master/scripts/db/migration/configdb/V1.0.0__initialization.sql" target="_blank" rel="noopener">apolloconfigdb.sql</a></li></ul><p>下载下来之后可通过 Mysql 图形界面工具(如 Navicat )等进行导入。导入完成之后，可以进行如下验证。</p><h4 id="portalDB-验证"><a href="#portalDB-验证" class="headerlink" title="portalDB 验证"></a>portalDB 验证</h4><p>执行 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">`Id`</span>, <span class="string">`Key`</span>, <span class="string">`Value`</span>, <span class="string">`Comment`</span> <span class="keyword">from</span> <span class="string">`ApolloPortalDB`</span>.<span class="string">`ServerConfig`</span> <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>查询结果：</p><table><thead><tr><th>Id</th><th>Key</th><th>Value</th><th>Comment</th></tr></thead><tbody><tr><td>1</td><td>apollo.portal.envs</td><td>dev</td><td>可支持的环境列表</td></tr></tbody></table><h4 id="configDB-验证"><a href="#configDB-验证" class="headerlink" title="configDB 验证"></a>configDB 验证</h4><p>执行 SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">`Id`</span>, <span class="string">`Key`</span>, <span class="string">`Value`</span>, <span class="string">`Comment`</span> <span class="keyword">from</span> <span class="string">`ApolloConfigDB`</span>.<span class="string">`ServerConfig`</span> <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>执行结果：</p><table><thead><tr><th>Id</th><th>Key</th><th>Value</th><th>Comment</th></tr></thead><tbody><tr><td>1</td><td>eureka.service.url</td><td><a href="http://127.0.0.1:8080/eureka/" target="_blank" rel="noopener">http://127.0.0.1:8080/eureka/</a></td><td>Eureka服务Url</td></tr></tbody></table><blockquote><p>本过程只针对新建工程，如果涉及到数据迁移，请参考 Apollo 官方文档</p></blockquote><p>数据库部分完成之后，接下来就是部署 Apollo 的三个工程。</p><h3 id="工程配置修改"><a href="#工程配置修改" class="headerlink" title="工程配置修改"></a>工程配置修改</h3><p>Apollo 配置中心 使用需要启动三个工程：apollo-configservice、apollo-adminservice、apollo-portal。</p><p>在自己的服务器上新建一个目录 /thirdserver/apollo/ 将官方提供的安装包直接下载到这个目录下，然后解压得到如下列表：</p><p><img src="https://oscimg.oschina.net/oscnet/20886e6df68aa3e20bc026e77811ae9bf5b.jpg" alt="image-20190107114836135"></p><h4 id="apollo-configservice-部署"><a href="#apollo-configservice-部署" class="headerlink" title="apollo-configservice 部署"></a>apollo-configservice 部署</h4><p>Apollo 服务端需要知道如何连接到你前面创建的数据库，数据库连接串信息位于上一步下载的压缩包中的<code>apollo-configservice-1.2.0-github/config/application-github.properties</code>中，这里把里面默认的数据库连接地址和账密信息替换成我们自己的就可以。这里使用的是 ApolloConfigDB 库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># DataSource</span><br><span class="line">spring.datasource.url = jdbc:mysql://$&#123;serverhost&#125;:3306/ApolloConfigDB?characterEncoding=utf8</span><br><span class="line">spring.datasource.username = $&#123;yourusername&#125;</span><br><span class="line">spring.datasource.password = $&#123;yourpassword&#125;</span><br></pre></td></tr></table></figure><h4 id="apollo-adminservice-配置文件修改"><a href="#apollo-adminservice-配置文件修改" class="headerlink" title="apollo-adminservice 配置文件修改"></a>apollo-adminservice 配置文件修改</h4><p>这里同样是修改  config/application-github.properties 下面的数据库连接信息。这里也使用的是 ApolloConfigDB 库。配置信息和上面一样。</p><h4 id="apollo-portal-配置文件修改"><a href="#apollo-portal-配置文件修改" class="headerlink" title="apollo-portal 配置文件修改"></a>apollo-portal 配置文件修改</h4><ul><li><p>portal 使用的是 ApolloPortalDB，修改数据库配置信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># DataSource</span><br><span class="line">spring.datasource.url = jdbc:mysql://$&#123;serverhost&#125;:3306/ApolloPortalDB?characterEncoding=utf8</span><br><span class="line">spring.datasource.username = $&#123;yourusername&#125;</span><br><span class="line">spring.datasource.password = $&#123;yourpassword&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改 meta service 信息，Apollo Portal 需要在不同的环境访问不同的 meta service(apollo-configservice) 地址，所以我们需要在配置中提供这些信息。默认情况下，meta service 和 config service 是部署在同一个 JVM进程，所以 meta service 的地址就是 config service 的地址。配置文件  /config/apollo-env.properties </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># $&#123;serverhost&#125; 是你当前机器的主机地址</span><br><span class="line">local.meta=http://localhost:8080</span><br><span class="line">dev.meta=http://$&#123;serverhost&#125;:8080</span><br><span class="line">fat.meta=http://$&#123;serverhost&#125;:8080</span><br><span class="line">uat.meta=http://$&#123;serverhost&#125;:8080</span><br><span class="line">lpt.meta=http://$&#123;serverhost&#125;:8080</span><br><span class="line">pro.meta=http://$&#123;serverhost&#125;:8080</span><br></pre></td></tr></table></figure><p>这里是把所有环境配置成一样的了，如果没有不需要这些环境，可以删除掉。</p></li></ul><h3 id="工程部署"><a href="#工程部署" class="headerlink" title="工程部署"></a>工程部署</h3><p>在每一个工程的解压包中，都有一个 scripts 文件夹，这里面是 Apollo 工程的启动脚本。三个工程分别先后启动：apollo-configservice、apollo-adminservice、apollo-portal，就是分别执行这三个工程下面的 /scripts/startup.sh 脚本即可，关闭执行的是 /scripts/shutdown.sh 脚本。</p><p>访问：http://${serverhost}:8070/</p><p><img src="https://oscimg.oschina.net/oscnet/2e9128be00850d0a34e9a437c37250f5757.jpg" alt="image-20190107133404554"></p><p>可以看到配置中心管控端的界面。</p><h3 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h3><ul><li>点击 创建项目，填写一些基本信息，然后提交</li></ul><p><img src="https://oscimg.oschina.net/oscnet/9829aa94cc189b32e6b8ed1958aa2ba7646.jpg" alt="image-20190107133541629"></p><ul><li>新增一个配置项，填写基本信息，然后提交</li></ul><p><img src="https://oscimg.oschina.net/oscnet/3004cbe4c0af7a9e376a4ab34d4d5d7e90b.jpg" alt="image-20190107133835832"></p><ul><li>当前工程界面</li></ul><p><img src="https://oscimg.oschina.net/oscnet/cce2da4dec2286f502863b33337d9110845.jpg" alt="image-20190107133936932"></p><ul><li>发布配置</li></ul><p><img src="https://oscimg.oschina.net/oscnet/3c0448a87c7124bb7e3ac170a269537a8e4.jpg" alt="image-20190107134958570"></p><h2 id="SpringCloud-工程案例"><a href="#SpringCloud-工程案例" class="headerlink" title="SpringCloud 工程案例"></a>SpringCloud 工程案例</h2><p>新建 sofa-config-apollo 工程。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>引入 apollo 客户端依赖及其他相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ctrip.framework.apollo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>apollo-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 需要与前面 Apollo 中创建项目的appId保持一致</span><br><span class="line">app.id=sofa-config-apollo</span><br><span class="line"># 设置 apollo meta service 的地址，因为前面meta和config是部署在一起的，所以就是configService的地址</span><br><span class="line">apollo.meta=http://$&#123;serverhost&#125;:8080</span><br><span class="line"># 配置项</span><br><span class="line">sofa.alipay.glmapper.name=glmapper</span><br></pre></td></tr></table></figure><h3 id="资源类-amp-启动类"><a href="#资源类-amp-启动类" class="headerlink" title="资源类&amp;启动类"></a>资源类&amp;启动类</h3><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><p>启动类上需要开启对 apollo 的支持，使用 @EnableApolloConfig 注解标注</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableApolloConfig</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaConfigApolloApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaConfigApolloApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="资源类"><a href="#资源类" class="headerlink" title="资源类"></a>资源类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApolloConfigController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApolloConfig</span></span><br><span class="line">    <span class="keyword">private</span> Config config;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;sofa.alipay.glmapper.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/apollo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，我在配置文件中指定的是 sofa.alipay.glmapper.name 值是 glmapper，而在配置中心配置的值是glmapper@leishu。同时这里也把 apollo 自己的这个 Config 配置类也注入进来，稍后看下这的对象的信息。</p><h3 id="运行程序-amp-验证"><a href="#运行程序-amp-验证" class="headerlink" title="运行程序&amp;验证"></a>运行程序&amp;验证</h3><p>启动当前工程之前需要确保 Apollo 的相关服务已经起来了，然后运行当前应用。在浏览器中输入：</p><p><a href="http://localhost:8080/config" target="_blank" rel="noopener">http://localhost:8080/config</a> ，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glmapper@leishu</span><br></pre></td></tr></table></figure><p>可以看到这里拿到的是配置中心的配置值，覆盖了我们本地配置文件中的配置。断点看到 config 的信息：</p><p><img src="https://oscimg.oschina.net/oscnet/617181dcfdd599e4fe37c85a7a5f9889049.jpg" alt="image-20190107140226085"></p><p>Config 对象就是当前集群环境下，指定 appId 的所有配置信息的集合。</p><h4 id="更改配置-amp-及时刷新"><a href="#更改配置-amp-及时刷新" class="headerlink" title="更改配置&amp;及时刷新"></a>更改配置&amp;及时刷新</h4><ul><li>更改配置</li></ul><p><img src="https://oscimg.oschina.net/oscnet/8cbe27b1b8334b0d866a0cd7af8fbe938b5.jpg" alt="image-20190107142508567"></p><ul><li>发布配置</li></ul><p><img src="https://oscimg.oschina.net/oscnet/277990a3c311039e4b3ac14593a19ffe32d.jpg" alt="image-20190107142537478"></p><ul><li>刷新 <a href="http://localhost:8080/apollo" target="_blank" rel="noopener">http://localhost:8080/apollo</a> 地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glmapper@leishu-update</span><br></pre></td></tr></table></figure><p>这里没有重启服务，配置动态更新了</p><h4 id="ApolloConfigChangeListener-来监听配置变更"><a href="#ApolloConfigChangeListener-来监听配置变更" class="headerlink" title="@ApolloConfigChangeListener 来监听配置变更"></a>@ApolloConfigChangeListener 来监听配置变更</h4><p>资源类 ApolloConfigController 中增加一个监听方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApolloConfigChangeListener</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(ConfigChangeEvent changeEvent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"发生变更了..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后重新在配置中心的界面上修改配置值：glmapper@leishu-update -&gt; glmapper@leishu-update-event，然后发布。然后可以在控制台看到日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发生变更了...</span><br><span class="line">2019-01-07 14:36:08.939  INFO 39072 --- [Apollo-Config-1] c.f.a.s.p.AutoUpdateConfigChangeListener : Auto update apollo changed value successfully, new value: glmapper@leishu-update-event, key: sofa.alipay.glmapper.name, beanName: apolloConfigController, field: com.alipay.sofa.cloud.controller.ApolloConfigController.name</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Apollo（阿波罗）是携程框架部门研发的开源配置管理中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="Config" scheme="http://www.glmapper.com/tags/Config/"/>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/tags/spring-cloud/"/>
    
      <category term="Apollo" scheme="http://www.glmapper.com/tags/Apollo/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-Config 配置中心原理</title>
    <link href="http://www.glmapper.com/2019/01/05/springcloud-config-analysis/"/>
    <id>http://www.glmapper.com/2019/01/05/springcloud-config-analysis/</id>
    <published>2019-01-05T13:03:20.000Z</published>
    <updated>2019-01-05T13:10:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇可以配合《<a href="http://www.glmapper.com/2018/12/31/springcoud-config-project/">SpringCloud-配置中心 Config</a>》来看，《<a href="http://www.glmapper.com/2018/12/31/springcoud-config-project/">SpringCloud-配置中心 Config</a>》中是基于SOFABoot 来集成 Spring Cloud Config 的一个 demo 案例。</p><p>在demo中，涉及到三个角色：</p><ul><li>配置中心服务端：为配置客户端提供对应的配置信息，配置信息的来源是配置仓库。应用启动时，会从配置仓库拉取配置信息缓存到本地仓库中。</li><li>配置中心客户端：应用启动时从配置服务端拉取配置信息。</li><li>配置仓库：为配置中心服务端提供配置信息存储，Spring Cloud Config 默认是使用git作为仓库的。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/3586089d566730b5fc6f5df08e96e5bb0b1.jpg" alt="image.png"></p><p>整体过程：</p><ul><li>环境部署之前，将所需的配置信息推送到配置仓库</li><li>启动配置中心服务端，将配置仓库的配置信息拉取到服务端，配置服务端对外提供REST接口</li><li>启动配置客户端，客户端根据 spring.cloud.config 配置的信息去服务器拉取相应的配置</li></ul><h2 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h2><p>配置中心服务端主要做了几件事情：连接配置仓库、拉取远程配置&amp;本地缓存、对外提供API接口服务。</p><h3 id="EnableConfigServer-及配置类"><a href="#EnableConfigServer-及配置类" class="headerlink" title="@EnableConfigServer 及配置类"></a>@EnableConfigServer 及配置类</h3><p>注解 EnableConfigServer 可以开启应用服务对配置中心的支持。当开启之后，配置服务器就会在启动时进行自动配置。具体对应的配置类是 ConfigServerAutoConfiguration，然后又在 ConfigServerAutoConfiguration 这个配置类中引入了其他很多配置类。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(&#123;Marker.class&#125;)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;ConfigServerProperties.class&#125;)</span><br><span class="line"><span class="meta">@Import</span>(&#123;EnvironmentRepositoryConfiguration.class, CompositeConfiguration.class, ResourceRepositoryConfiguration.class, ConfigServerEncryptionConfiguration.class, ConfigServerMvcConfiguration.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConfigServerAutoConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>EnvironmentRepositoryConfiguration： 环境变量存储相关的配置类</li><li>CompositeConfiguration：组合方式的环境仓库配置类</li><li>ResourceRepositoryConfiguration：资源仓库相关的配置类</li><li>ConfigServerEncryptionConfiguration：加密断点相关的配置类</li><li>ConfigServerMvcConfiguration：对外暴露的MVC端点控制器的配置类</li></ul><p>无论是 Spring Cloud 自身提供的默认实现 git ，还是 zk，或者 apollo ；基本思路都是在程序启动时将远端配置拉取到本地作为环境变量来使用，但这些是针对客户端角度来说的。Spring Cloud Config Server 因为其本身是以服务端存在，所以 Config Server 本身的实现思路也值得后面开发借鉴。</p><p>对于服务端来说，其基本职责就是能够将具体存储中的配置信息先拿到，然后提供出 API 供客户端来调用。下面从ConfigServerAutoConfiguration 中 import的这些配置类来具体看下实现。</p><h3 id="EnvironmentRepositoryConfiguration"><a href="#EnvironmentRepositoryConfiguration" class="headerlink" title="EnvironmentRepositoryConfiguration"></a>EnvironmentRepositoryConfiguration</h3><p>EnvironmentRepositoryConfiguration 是环境变量存储相关的配置类，它本身也提供了很多实现：</p><p><img src="https://oscimg.oschina.net/oscnet/3b93eff5aa7978c04010c2b0bb75f7bae17.jpg" alt="image.png"></p><p>上图中可以看到，环境配置仓库支持的有JDBC、SVN、本地文件系统、Git等等。这些对不同环境仓库的支持，在实现上基本都差不多，下面以默认提供的方式git来分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"git"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitRepositoryConfiguration</span> <span class="keyword">extends</span> <span class="title">DefaultRepositoryConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GitRepositoryConfiguration 集成了 DefaultRepositoryConfiguration，这也说明了 Spring Cloud Config 默认使用的是Git。不同的配置类实现都会被标注一个@Profile，可以通过这个来激活相应的配置类；具体做法是在配置服务端的 application.properties(application.yml) 中来指定：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.profile.active=git</span><br></pre></td></tr></table></figure><p>没有设置就是默认使用 GIt。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = EnvironmentRepository.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultRepositoryConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ConfigurableEnvironment environment;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ConfigServerProperties server;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> TransportConfigCallback customTransportConfigCallback;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MultipleJGitEnvironmentRepository <span class="title">defaultEnvironmentRepository</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        MultipleJGitEnvironmentRepositoryFactory gitEnvironmentRepositoryFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">MultipleJGitEnvironmentProperties environmentProperties)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> gitEnvironmentRepositoryFactory.build(environmentProperties);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultRepositoryConfiguration 的 ConditionalOnMissingBean 可以知道，如果上下文中没有 EnvironmentRepository，那么就使用 DefaultRepositoryConfiguration。</p><h3 id="MultipleJGitEnvironmentRepository"><a href="#MultipleJGitEnvironmentRepository" class="headerlink" title="MultipleJGitEnvironmentRepository"></a>MultipleJGitEnvironmentRepository</h3><p>MultipleJGitEnvironmentRepository 是 Git 存储的具体实现类，下面是类图结构：<br><img src="https://oscimg.oschina.net/oscnet/00a410c73f4e93c55f8ce2e386e5254718e.jpg" alt="image.png"></p><p>MultipleJGitEnvironmentRepository 的顶层接口是 EnvironmentRepository ，当然其他的实现也都是实现了这个接口的。另外一个需要关注的是 SearchPathLocator。</p><ul><li>EnvironmentRepository：定义了获取指定应用服务环境信息的方法，返回一个Enviroment</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EnvironmentRepository</span> </span>&#123;</span><br><span class="line"><span class="function">Environment <span class="title">findOne</span><span class="params">(String application, String profile, String label)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个参数，application、profile、label；《<a href="http://www.glmapper.com/2018/12/31/springcoud-config-project/">SpringCloud-配置中心 Config</a>》 中客户端部分有对这三个的参数的说明及使用方式，通过这三个参数可以具体定位到配置信息。</p><ul><li>SearchPathLocator ： 根据传入客户端应用信息，获取对应的配置环境文件的位置。代码见：<a href="[https://github.com/spring-cloud/spring-cloud-config/blob/master/spring-cloud-config-server/src/main/java/org/springframework/cloud/config/server/environment/SearchPathLocator.java](https://github.com/spring-cloud/spring-cloud-config/blob/master/spring-cloud-config-server/src/main/java/org/springframework/cloud/config/server/environment/SearchPathLocator.java">SearchPathLocator</a>)。</li></ul><p>SearchPathLocator 中有一个内部类 Locations ，Locdations中定义了应用服务配置存储信息。</p><p>除了这两个之外，还有一个 AbstractScmAccessor，这个抽象类里面定义了一些列与git存储相关的属性和方法。包括远程仓库的地址、账户、密码、ssh 私钥、本地仓库的地址等等。</p><blockquote><p>SCM : 软件配置管理</p></blockquote><h3 id="AbstractScmEnvironmentRepository"><a href="#AbstractScmEnvironmentRepository" class="headerlink" title="AbstractScmEnvironmentRepository"></a>AbstractScmEnvironmentRepository</h3><p>AbstractScmEnvironmentRepository 实现了 AbstractScmAccessor 和 EnvironmentRepository ，主要就是EnvironmentRepository 中 findOne 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Environment <span class="title">findOne</span><span class="params">(String application, String profile, String label)</span> </span>&#123;</span><br><span class="line"><span class="comment">//新建了一个本地仓库作为代理仓库来使用</span></span><br><span class="line">  NativeEnvironmentRepository delegate = <span class="keyword">new</span> NativeEnvironmentRepository(getEnvironment(),</span><br><span class="line"><span class="keyword">new</span> NativeEnvironmentProperties());</span><br><span class="line">    <span class="comment">//获取本地仓库中指定应用的位置</span></span><br><span class="line">Locations locations = getLocations(application, profile, label);</span><br><span class="line">delegate.setSearchLocations(locations.getLocations());</span><br><span class="line">  <span class="comment">//根据这个路径搜索应用服务的配置信息</span></span><br><span class="line">Environment result = delegate.findOne(application, profile, <span class="string">""</span>);</span><br><span class="line">result.setVersion(locations.getVersion());</span><br><span class="line">result.setLabel(label);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.cleaner.clean(result, getWorkingDirectory().toURI().toString(),</span><br><span class="line">getUri());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getLocations 是一个模板方法，Config Server中提供了三种实现：</p><p><img src="https://oscimg.oschina.net/oscnet/5c29f16cdb3057306c9eb7d95a19188ef36.jpg" alt="image.png"></p><p>分别是单 Git 仓库，多 Git 仓库和 Svn 仓库实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Locations <span class="title">getLocations</span><span class="params">(String application, String profile,</span></span></span><br><span class="line"><span class="function"><span class="params">String label)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (label == <span class="keyword">null</span>) &#123;</span><br><span class="line">label = <span class="keyword">this</span>.defaultLabel;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 获取最新的版本号</span></span><br><span class="line">String version = refresh(label);</span><br><span class="line">    <span class="comment">// 根据最新的版本号返回 Locations 定位到资源的搜索路径</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Locations(application, profile, label, version,</span><br><span class="line">getSearchLocations(getWorkingDirectory(), application, profile, label));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>refresh 方法做的作用就是刷新本地仓库的配置状态，这样就能保证每次都能拉取到最新的配置信息。下面来分析这个方法。</p><h3 id="JGitEnvironmentRepository-refresh"><a href="#JGitEnvironmentRepository-refresh" class="headerlink" title="JGitEnvironmentRepository#refresh"></a>JGitEnvironmentRepository#refresh</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">refresh</span><span class="params">(String label)</span> </span>&#123;</span><br><span class="line">Git git = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建一个git客户端</span></span><br><span class="line">git = createGitClient();</span><br><span class="line">      <span class="comment">// 是否需要执行 git pull</span></span><br><span class="line"><span class="keyword">if</span> (shouldPull(git)) &#123;</span><br><span class="line">FetchResult fetchStatus = fetch(git, label);</span><br><span class="line"><span class="keyword">if</span> (deleteUntrackedBranches &amp;&amp; fetchStatus != <span class="keyword">null</span>) &#123;</span><br><span class="line">deleteUntrackedLocalBranches(fetchStatus.getTrackingRefUpdates(), git);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取后checkout，这样我们就可以获得任何新的分支、tag等。</span></span><br><span class="line">checkout(git, label);</span><br><span class="line">tryMerge(git, label);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 没有什么要更新，所以只是checkout和merge。</span></span><br><span class="line"><span class="comment">// 合并是因为远程分支以前可能已经更新过</span></span><br><span class="line">checkout(git, label);</span><br><span class="line">tryMerge(git, label);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回当前的版本</span></span><br><span class="line"><span class="keyword">return</span> git.getRepository().findRef(<span class="string">"HEAD"</span>).getObjectId().getName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// 异常处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 关闭git</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个里面基本就是通过git客户端的一些操作。先是检查远程仓库的状态，然后判断本地仓库是否要执行刷新操作。如果有状态更新，比如新的提交时，Git客户端就会执行fetch，然后再进行merge，更新到本地仓库。</p><blockquote><p>MultipleJGitEnvironmentRepository 多仓库的支持，实际上就是遍历了所有的仓库。其他仓库和单仓库是一样的。</p></blockquote><h2 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h2><p>Spring Cloud Config Client 没有像其他组件一样提供@EnableConfigClient注解，这里没有必要去标注是一个配置客户端，只要引入了spring-cloud-config-client 依赖即可。</p><p>思路也很清楚，就是在启动时从服务端把配置信息拉取到本地，然后设置到 Enviroment 中。Spring Cloud Config中有两种形式，一种是指定 url，另外一种是通过服务发现，默认是通过指定URI的方式。这里还是先从客户端的自动配置来分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServiceBootstrapConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ConfigurableEnvironment environment;</span><br><span class="line">  <span class="comment">// 客户端配置属性</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigClientProperties <span class="title">configClientProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ConfigClientProperties client = <span class="keyword">new</span> ConfigClientProperties(<span class="keyword">this</span>.environment);</span><br><span class="line"><span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 从远程服务器上请求对应的配置信息</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(ConfigServicePropertySourceLocator.class)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"spring.cloud.config.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigServicePropertySourceLocator <span class="title">configServicePropertySource</span><span class="params">(ConfigClientProperties properties)</span> </span>&#123;</span><br><span class="line">ConfigServicePropertySourceLocator locator = <span class="keyword">new</span> ConfigServicePropertySourceLocator(</span><br><span class="line">properties);</span><br><span class="line"><span class="keyword">return</span> locator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重试机制</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"spring.cloud.config.fail-fast"</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Retryable.class, Aspect.class, AopAutoConfiguration.class &#125;)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRetry</span>(proxyTargetClass = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@Import</span>(AopAutoConfiguration.class)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(RetryProperties.class)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(name = <span class="string">"configServerRetryInterceptor"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RetryOperationsInterceptor <span class="title">configServerRetryInterceptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">RetryProperties properties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> RetryInterceptorBuilder</span><br><span class="line">.stateless()</span><br><span class="line">.backOffOptions(properties.getInitialInterval(),</span><br><span class="line">properties.getMultiplier(), properties.getMaxInterval())</span><br><span class="line">.maxAttempts(properties.getMaxAttempts()).build();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置类中初始化了两个bean:</p><ul><li>ConfigClientProperties : 对客户端的属性进行配置。</li><li>ConfigServicePropertySourceLocator：从远程服务器上请求对应的配置信息，然后注册到容器的Enviroment 对象中去。</li></ul><p>ConfigClientProperties 中就是客户端的一些属性，如：profile、应用名、标签、远端服务地址等。没有什么特殊的逻辑。主要来看下 ConfigServicePropertySourceLocator 。</p><h3 id="ConfigServicePropertySourceLocator"><a href="#ConfigServicePropertySourceLocator" class="headerlink" title="ConfigServicePropertySourceLocator"></a>ConfigServicePropertySourceLocator</h3><p>ConfigServicePropertySourceLocator 实现了 PropertySourceLocator 接口，PropertySourceLocator 接口的作用就是用来定位 PropertySource 的。直接看locate方法的实现(删除了无关代码)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Retryable</span>(interceptor = <span class="string">"configServerRetryInterceptor"</span>)</span><br><span class="line"><span class="keyword">public</span> PropertySource&lt;?&gt; locate(Environment environment) &#123;</span><br><span class="line">ConfigClientProperties properties = <span class="keyword">this</span>.defaultProperties.override(environment);</span><br><span class="line">CompositePropertySource composite = <span class="keyword">new</span> CompositePropertySource(<span class="string">"configService"</span>);</span><br><span class="line">   <span class="comment">// 实例化一个 restTemplate，用来调用服务端的 API</span></span><br><span class="line">RestTemplate restTemplate = <span class="keyword">this</span>.restTemplate == <span class="keyword">null</span></span><br><span class="line">? getSecureRestTemplate(properties)</span><br><span class="line">: <span class="keyword">this</span>.restTemplate;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// labels ，对对应于profile 如，dev,pre,test这些</span></span><br><span class="line">String[] labels = <span class="keyword">new</span> String[] &#123; <span class="string">""</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(properties.getLabel())) &#123;</span><br><span class="line">labels = StringUtils.commaDelimitedListToStringArray(properties.getLabel());</span><br><span class="line">&#125;</span><br><span class="line">String state = ConfigClientStateHolder.getState();</span><br><span class="line"><span class="comment">// 遍历所有的标签，循环调用获取远程配置信息</span></span><br><span class="line"><span class="keyword">for</span> (String label : labels) &#123;</span><br><span class="line">       <span class="comment">// h获取远端环境配置信息</span></span><br><span class="line">Environment result = getRemoteEnvironment(restTemplate, properties,</span><br><span class="line">label.trim(), state);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">log(result);</span><br><span class="line">         <span class="comment">// result.getPropertySources() can be null if using xml</span></span><br><span class="line">         <span class="comment">//使用 xml，可能会为 null</span></span><br><span class="line"><span class="keyword">if</span> (result.getPropertySources() != <span class="keyword">null</span>) &#123; </span><br><span class="line"><span class="keyword">for</span> (PropertySource source : result.getPropertySources()) &#123;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) source</span><br><span class="line">.getSource();</span><br><span class="line">composite.addPropertySource(</span><br><span class="line"><span class="keyword">new</span> MapPropertySource(source.getName(), map));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">         <span class="comment">// 设置客户端状态和版本号信息</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(result.getState())</span><br><span class="line">|| StringUtils.hasText(result.getVersion())) &#123;</span><br><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">putValue(map, <span class="string">"config.client.state"</span>, result.getState());</span><br><span class="line">putValue(map, <span class="string">"config.client.version"</span>, result.getVersion());</span><br><span class="line">composite.addFirstPropertySource(</span><br><span class="line"><span class="keyword">new</span> MapPropertySource(<span class="string">"configClient"</span>, map));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> composite;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// 如果设置了fial fast ，失败时抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (properties.isFailFast()) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码片段中实际从远端获取配置信息是在 getRemoteEnvironment 这个方法中，以Http 请求的方式获取。获取到配置信息之后是放在 CompositePropertySource 对象中，代码较长，逻辑也比较简单，建议直接阅读源码。源于这部分 <a href="http://www.glmapper.com/2018/12/31/springcoud-context-analysis/">自定义属性源</a>也有说明。</p><h3 id="注入到-Enviroment-中"><a href="#注入到-Enviroment-中" class="headerlink" title="注入到 Enviroment 中"></a>注入到 Enviroment 中</h3><p>这部分操作是在 Spring Cloud Context 中的入口来完成的。具体参考<a href="http://www.glmapper.com/2018/12/31/springcoud-context-analysis/"> bootstrapServiceContext 创建&amp;启动</a> 。<br>这里会通过 Spring Cloud Context 中的 PropertySourceBootstrapConfiguration 配置类将PropertySourceLocator 自定义属性值添加到引导上下文的环境当中。</p><h3 id="基于服务发现的方式获取配置"><a href="#基于服务发现的方式获取配置" class="headerlink" title="基于服务发现的方式获取配置"></a>基于服务发现的方式获取配置</h3><p>前面两个小节均是基于指定 http url 的方式获取配置文件的。Spring Cloud Config 中还有一种方式就是基于服务发现的方式。其实这种方式说到底还是基于指定 http url的方式调用，只是通过服务发现找到服务端地址；当然既然有服务的发现与注册，也就会涉及到客户端与服务端之间的会话保证，及时更新可用服务列表这些功能。</p><ul><li>获取服务地址</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retryable</span>(interceptor = <span class="string">"configServerRetryInterceptor"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ServiceInstance&gt; <span class="title">getConfigServerInstances</span><span class="params">(String serviceId)</span> </span>&#123;</span><br><span class="line">logger.debug(<span class="string">"Locating configserver ("</span> + serviceId + <span class="string">") via discovery"</span>);</span><br><span class="line">List&lt;ServiceInstance&gt; instances = <span class="keyword">this</span>.client.getInstances(serviceId);</span><br><span class="line"><span class="keyword">if</span> (instances.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">"No instances found of configserver ("</span> + serviceId + <span class="string">")"</span>);</span><br><span class="line">&#125;</span><br><span class="line">logger.debug(<span class="string">"Located configserver ("</span> + serviceId</span><br><span class="line">+ <span class="string">") via discovery. No of instances found: "</span> + instances.size());</span><br><span class="line"><span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 DiscoveryClient 客户端，以指定serviceId的方式拿到服务地址。</p><p>DiscoveryClientConfigServiceBootstrapConfiguration 这个自动配置类实现了 ApplicationListener，用于监听上下文刷新事件；DiscoveryClient 在具体的实现中会将上下文刷新事件进行广播，然后执行刷新操作。心跳里面也是执行的刷新操作。对应的方法是DiscoveryClientConfigServiceBootstrapConfiguration#refresh。也就是 refresh方法会根据上下文环境和心跳事件，刷新服务实例。</p><h2 id="以-ZK-作为配置中心"><a href="#以-ZK-作为配置中心" class="headerlink" title="以 ZK 作为配置中心"></a>以 ZK 作为配置中心</h2><p>《<a href="http://www.glmapper.com/2019/01/05/springcloud-config-zk-project/">SpringCloud-配置中心 spring-cloud-zk</a>》demo 中介绍了如何使用 zk 作为配置中心。以zk作为配置中心也就是配置信息将从zk中来获取；具体实现也就是实现 PropertySourceLocator 接口，在locate方法中通过zk客户端从zk服务端拉取配置信息。具体实现在ZookeeperPropertySourceLocator#locate中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PropertySource&lt;?&gt; locate(Environment environment) &#123;</span><br><span class="line"><span class="keyword">if</span> (environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">      <span class="comment">//省略 ...</span></span><br><span class="line"><span class="comment">// 获取外部配置源</span></span><br><span class="line">PropertySource propertySource = create(propertySourceContext);</span><br><span class="line">      <span class="comment">//省略 ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他代码片段都省略了，获取 PropertySource 是在 create 方法中，create 方法返回一个 ZookeeperPropertySource 实例对象。在构造函数中，有通过zk客户端去拉取配置信息，具体逻辑在findProperties 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findProperties</span><span class="params">(String path, List&lt;String&gt; children)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 省略 ... </span></span><br><span class="line"><span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">String childPath = path + <span class="string">"/"</span> + child;</span><br><span class="line">List&lt;String&gt; childPathChildren = getChildren(childPath);</span><br><span class="line">        <span class="comment">// 获取节点信息</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = getPropertyBytes(childPath);</span><br><span class="line"><span class="keyword">if</span> (bytes == <span class="keyword">null</span> || bytes.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (childPathChildren == <span class="keyword">null</span> || childPathChildren.isEmpty()) &#123;</span><br><span class="line">registerKeyValue(childPath, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">registerKeyValue(childPath, <span class="keyword">new</span> String(bytes, Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查子节点，即使我们已经找到当前znode的值</span></span><br><span class="line">findProperties(childPath, childPathChildren);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line"><span class="comment">// 省略 ... </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动刷新机制"><a href="#自动刷新机制" class="headerlink" title="自动刷新机制"></a>自动刷新机制</h3><p>当修改配置信息之后，通过zk自身的监听机制，通知客户端。这个机制是在ZookeeperConfigAutoConfiguration自动配置类中提供。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(RefreshEndpoint.class)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkRefreshConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(name = <span class="string">"spring.cloud.zookeeper.config.watcher.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigWatcher <span class="title">configWatcher</span><span class="params">(ZookeeperPropertySourceLocator locator,</span></span></span><br><span class="line"><span class="function"><span class="params">CuratorFramework curator)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConfigWatcher(locator.getContexts(), curator);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConfigWatcher 实现了 Closeable、TreeCacheListener 和 ApplicationEventPublisherAware 三个接口。Tree Cache 用于观察所有节点的所有数据状态，ApplicationEventPublisherAware用户提供一个publiser，用来发布RefreshEvent 事件。Closeable 用于实现优雅关闭。</p><p>所有当我们改变zk数据节点时，就是触发例如 NODE_ADDED 、NODE_REMOVED、NODE_UPDATED 等事件类型，然后publiser就会发布一个 RefreshEvent 事件，通知客户端进行配置更新操作。从而实现配置的自动刷新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇可以配合《&lt;a href=&quot;http://www.glmapper.com/2018/12/31/springcoud-config-project/&quot;&gt;SpringCloud-配置中心 Config&lt;/a&gt;》来看，《&lt;a href=&quot;http://www.glmapp
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="zookeeper" scheme="http://www.glmapper.com/tags/zookeeper/"/>
    
      <category term="Config" scheme="http://www.glmapper.com/tags/Config/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-配置中心 spring-cloud-config-zookeeper</title>
    <link href="http://www.glmapper.com/2019/01/05/springcloud-config-zk-project/"/>
    <id>http://www.glmapper.com/2019/01/05/springcloud-config-zk-project/</id>
    <published>2019-01-05T09:12:07.000Z</published>
    <updated>2019-01-05T12:39:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>SpringCloud 除了config自己的client/server 这套配置中心之外，还可以集成使用 zookeeper 。本篇将演示如何使用 spring-cloud-confg-zookeeper。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK<br></td><td>1.8.0_162<br></td></tr><tr><td>SOFABoot/SpringBoot<br></td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE<br></td></tr><tr><td>SpringCloud<br></td><td>Finchley.RC1<br></td></tr><tr><td>IDE<br></td><td>IDEA<br></td></tr></tbody></table><h2 id="zk-amp-zkui"><a href="#zk-amp-zkui" class="headerlink" title="zk &amp; zkui"></a>zk &amp; zkui</h2><p>这里我是把 zk 和 zkui 部署在一台 linux 服务器上的。</p><h3 id="zk"><a href="#zk" class="headerlink" title="zk"></a>zk</h3><p>从 ZooKeeper官网 下载 zookeeper-3.4.13.tar.gz。</p><ul><li><p>解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf zookeeper-3.4.13.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>目录重命名(可选)</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv zookeeper-3.4.13 zookeeper</span><br></pre></td></tr></table></figure><ul><li>在 zookeeper 下加一个data目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">cd</span> zookeeper</span><br><span class="line">&gt; mkdir data</span><br></pre></td></tr></table></figure><ul><li>修改 zoo.cfg</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim zoo.cfg</span><br></pre></td></tr></table></figure><ul><li>修改 dataDir 地址：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/$&#123;your path&#125;/zookeeper/data</span><br></pre></td></tr></table></figure><ul><li>其他随意，启动 zk</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure><h3 id="zkui"><a href="#zkui" class="headerlink" title="zkui"></a>zkui</h3><p>下载zkui代码，然后本地安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://gitee.com/ilanni/zkui.git</span><br><span class="line">$ <span class="built_in">cd</span> zkui/ </span><br><span class="line">$ mvn clean install <span class="comment"># 进行maven打包，执行成功后会生成target文件夹，其中有jar文件。</span></span><br></pre></td></tr></table></figure><p>执行结束后在zkui文件夹下生成一个target文件夹。</p><ul><li>将config.cfg文件复制到target文件夹下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp config.cfg target/</span><br></pre></td></tr></table></figure><p>target文件夹中有两个jar包，我们只需要启动<code>zkui-2.0-SNAPSHOT-jar-with-dependencies.jar</code>就可以了。</p><ul><li>修改 config.cfg文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">cd</span> target</span><br><span class="line">&gt; vim config.cfg</span><br></pre></td></tr></table></figure><p>按需修改serverPort、zkServer、userSet 等。</p><ul><li>启动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar zkui-2.0-SNAPSHOT-jar-with-dependencies.jar</span><br><span class="line"><span class="comment"># nohup java -jar zkui-2.0-SNAPSHOT-jar-with-dependencies.jar &amp;   #退出窗口不退出进程</span></span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>既然是以 zk 作为配置中，那么就需要将测试用的配置数据先在zk上进行初始化。有两种方式（均基于zkui）：</p><ul><li>zkui 界面通过 import 进行导入，这里新建一个 config.txt ，内容如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/config/sofa/sofa-config-zk,dev=server.port=8085</span><br></pre></td></tr></table></figure><p>设置当前应用启动的端口，这里的 root 为 /config/sofa，应用名是 sofa-config-zk，dev是环境 ，server.port=8085 是具体的配置kv。</p><ul><li>手动 add node</li></ul><p>这里为了方便，采用import的方式，结果如下：<br><img src="https://oscimg.oschina.net/oscnet/afaf490914a21de6eb087ec02582cc7f1d2.jpg" alt="image.png"></p><h2 id="新建-sofa-config-zookeeper"><a href="#新建-sofa-config-zookeeper" class="headerlink" title="新建 sofa-config-zookeeper"></a>新建 sofa-config-zookeeper</h2><p>新建一个 SOFABoot 工程，项目为 sofa-config-zookeeper。</p><h3 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring-cloud-config zk 的依赖，必选--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- spring-cloud-config zk 的依赖，为了自动刷新监听等--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sofa-config-zk</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">  cloud:</span><br><span class="line">    zookeeper:</span><br><span class="line">      enabled: true  # true:开启zookeeper外部化配置, false:读取本地配置;</span><br><span class="line">      connect-string: sofa.cloud.alipay.net:2181</span><br><span class="line">      config:</span><br><span class="line">        root: /config/sofa   #指定zookeeper中属性的根目录</span><br><span class="line">        enabled: true</span><br><span class="line">        watcher:</span><br><span class="line">          enabled: true    #默认值是true, 监控配置变更后是否自动更新，需配合Spring Boot Actuators 使用</span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaConfigZookeeperApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaConfigZookeeperApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有任何特殊，不需要加额外的注解。</p><h3 id="资源类"><a href="#资源类" class="headerlink" title="资源类"></a>资源类</h3><p>其实这里可以完全不用通过rest来打印这个属性值，但是为了方便看，还是写一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperConfigController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/config"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serverPort;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动-amp-验证"><a href="#启动-amp-验证" class="headerlink" title="启动&amp;验证"></a>启动&amp;验证</h3><p>启动应用，如果成功的话，会有如下的日志：State change: CONNECTED</p><p><img src="https://oscimg.oschina.net/oscnet/42dfc087c51e1b5e1044b0d87900b3003ca.jpg" alt="image.png"></p><p>tomcat 启动端口:</p><p><img src="https://oscimg.oschina.net/oscnet/b506f78b41460610be7057b8be7b421d9d5.jpg" alt="image.png"></p><p>因为在上面配置文件部分是没有指定 server.port 的，通常情况下默认是 8080 ，所以可以确定，已经拿到了配置中心的数据了。</p><h2 id="动态刷新"><a href="#动态刷新" class="headerlink" title="动态刷新"></a>动态刷新</h2><p>这里还是需要依赖 actuator 的 /refresh 。上面依赖中已经加入了 actuator的相关依赖，所以只需要在资源类上加一个 <a href="#">@RefreshScope</a> 注解即可。</p><ul><li>在 ZookeeperConfigController 类上加 <a href="#">@RefreshScope</a>  注解，然后重启应用</li><li>通过 zkui 修改 server.port 为 8086</li><li>访问 <a href="http://localhost:8065/config" target="_blank" rel="noopener">http://localhost:8085/config</a> ，返回8086</li></ul><blockquote><p>需要注意，这里因为我们启动时应用时拿到的配置是8085，所以当前服务对外提供服务暴露的端口就是8085 ，当我们修改了zk上的值之后，他会改变 当前运行环境中 Enviroment 的值，但是不会使得服务的端口发生变化，除非重启。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SpringCloud 除了config自己的client/server 这套配置中心之外，还可以集成使用 zookeeper 。本篇将演示如何使用 spring-cloud-confg-zookeeper。&lt;/p&gt;
&lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="zookeeper" scheme="http://www.glmapper.com/tags/zookeeper/"/>
    
      <category term="Config" scheme="http://www.glmapper.com/tags/Config/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下安装 Mysql 数据库</title>
    <link href="http://www.glmapper.com/2019/01/05/mysql-on-linux/"/>
    <id>http://www.glmapper.com/2019/01/05/mysql-on-linux/</id>
    <published>2019-01-05T09:09:15.000Z</published>
    <updated>2019-01-05T09:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在搞 Apollo ，熟悉的同学应该知道，Apollo 需要依赖 Mysql。本以为很容易搞定，但是却踩了一路坑，眼高手低，也参考了网上很多博客，果然是残缺就是美！本篇就简单记录一下这个过程，以便后面参考。</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li><p>linux：centOS 7</p></li><li><p>jdk：8</p></li><li><p>Mysql：5.7.24</p></li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>安装前，我们可以检测系统是否自带安装 MySQL:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep mysql</span><br></pre></td></tr></table></figure><p>如果你系统有安装，那可以选择进行卸载，有两种模式：</p><ul><li><p>普通删除模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e mysql</span><br></pre></td></tr></table></figure></li><li><p>强力删除模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps mysql</span><br></pre></td></tr></table></figure><p>如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除</p></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>下载mysql安装包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm</span><br><span class="line"></span><br><span class="line">-2018-06-06 16:41:46--  https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm</span><br><span class="line">正在解析主机 dev.mysql.com (dev.mysql.com)... xxxx</span><br><span class="line">正在连接 dev.mysql.com (dev.mysql.com)|xxxxx|:443... 已连接。</span><br><span class="line">已发出 HTTP 请求，正在等待回应... 302 Found</span><br><span class="line">位置：https://repo.mysql.com//mysql57-community-release-el7-9.noarch.rpm [跟随至新的 URL]</span><br><span class="line">--2018-06-06 16:41:48--  https://repo.mysql.com//mysql57-community-release-el7-9.noarch.rpm</span><br><span class="line">正在解析主机 repo.mysql.com (repo.mysql.com)... xxxxx</span><br><span class="line">正在连接 repo.mysql.com (repo.mysql.com)|xxxx|:443... 已连接。</span><br><span class="line">已发出 HTTP 请求，正在等待回应... 200 OK</span><br><span class="line">长度：9224 (9.0K) [application/x-redhat-package-manager]</span><br><span class="line">正在保存至: “mysql57-community-release-el7-9.noarch.rpm”</span><br><span class="line"></span><br><span class="line">100%[==========================================================&gt;] 9,224       --.-K/s 用时 0s      </span><br><span class="line"></span><br><span class="line">2018-06-06 16:41:48 (169 MB/s) - 已保存 “mysql57-community-release-el7-9.noarch.rpm” [9224/9224])</span><br></pre></td></tr></table></figure><ul><li>安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql57-community-release-el7-9.noarch.rpm</span><br><span class="line"></span><br><span class="line">准备中...                          ################################# [100%]</span><br><span class="line">正在升级/安装...</span><br><span class="line">   1:mysql57-community-release-el7-9  ################################# [100%]</span><br></pre></td></tr></table></figure><ul><li>下载安装依赖包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql-server</span><br><span class="line"></span><br><span class="line">已加载插件：fastestmirror, langpacks</span><br><span class="line">mysql-connectors-community                                                   | 2.5 kB  00:00:00     </span><br><span class="line">mysql-tools-community                                                        | 2.5 kB  00:00:00     </span><br><span class="line">mysql57-community                                                            | 2.5 kB  00:00:00     </span><br><span class="line">(1/3): mysql-connectors-community/x86_64/primary_db                          |  20 kB  00:00:00     </span><br><span class="line">(2/3): mysql-tools-community/x86_64/primary_db                               |  41 kB  00:00:00     </span><br><span class="line">(3/3): mysql57-community/x86_64/primary_db                                   | 144 kB  00:00:00     </span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.cn99.com</span><br><span class="line"> * extras: mirrors.cn99.com</span><br><span class="line"> * updates: mirrors.cn99.com</span><br><span class="line">正在解决依赖关系 </span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>第一次下载这里会比较慢</p><ul><li><p>验证是否安装成功</p><ul><li>mysqladmin –version</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin  Ver 8.42 Distrib 5.7.22, for Linux on x86_64</span><br></pre></td></tr></table></figure><ul><li>mysql -V</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql  Ver 14.14 Distrib 5.7.24, for Linux (x86_64) using  EditLine wrapper</span><br></pre></td></tr></table></figure></li><li><p>启动MySQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start mysqld</span><br></pre></td></tr></table></figure></li><li><p>查看 MySQL 运行状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status mysqld</span><br></pre></td></tr></table></figure></li><li><p>停止 MySQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop mysqld</span><br></pre></td></tr></table></figure></li><li><p>重启 MySQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart mysqld</span><br></pre></td></tr></table></figure></li></ul><h3 id="关于密码"><a href="#关于密码" class="headerlink" title="关于密码"></a>关于密码</h3><p>Mysql 5.7 默认安装之后 root 是有密码的，获取 MySQL 的临时密码 为了加强安全性，MySQL 5.7 为 root 用户随机生成了一个密码，在 error log 中，关于 error log 的位置，如果安装的是 RPM 包，则默认是 /var/log/mysqld.log 。 只有启动过一次 mysql 才可以查看临时密码。</p><p>在利用 YUM 安装 mysql 数据库过程中，系统会自动生成一个临时密码，获取方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &apos;temporary password&apos; /var/log/mysqld.log</span><br></pre></td></tr></table></figure><ul><li><p>没有密码</p><p>如果以前安装过 mysql，这时的 mysqld.log 中就不会有 temporary password<br>这时就需要删除 mysql 残留的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /var/lib/mysql</span><br></pre></td></tr></table></figure><p>执行完毕后需要重新启动MySQL服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart mysqld</span><br></pre></td></tr></table></figure><p>这时就可以通过上面的命令去查找数据库生成的临时密码了</p></li></ul><h3 id="mysql-1130-错误"><a href="#mysql-1130-错误" class="headerlink" title="mysql 1130 错误"></a>mysql 1130 错误</h3><p>可能是你的帐号不允许从远程登陆，只能在 localhost。这个时候只要在 localhost 的那台电脑，登入 mysql 后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称”%”</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -pvmwaremysql&gt;use mysql;</span><br><span class="line">mysql&gt; update user set host = '%' where user = 'root';</span><br><span class="line">mysql&gt; select host, user from user;</span><br></pre></td></tr></table></figure><p>使得我们当前的账户和密码能够应用的所有的远程主机连接：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; GRANT ALL PRIVILEGES ON . TO 'myuser'@'%' IDENTIFIED BY 'mypassword' WITH GRANT OPTION;</span><br><span class="line">&gt; FLUSH   PRIVILEGES;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在搞 Apollo ，熟悉的同学应该知道，Apollo 需要依赖 Mysql。本以为很容易搞定，但是却踩了一路坑，眼高手低，也参考了网上很多博客，果然是残缺就是美！本篇就简单记录一下这个过程，以便后面参考。&lt;/p&gt;
&lt;h3 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; c
      
    
    </summary>
    
      <category term="运维" scheme="http://www.glmapper.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="mysql" scheme="http://www.glmapper.com/tags/mysql/"/>
    
      <category term="linux" scheme="http://www.glmapper.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-Spring Cloud Context</title>
    <link href="http://www.glmapper.com/2018/12/30/springcoud-context-analysis/"/>
    <id>http://www.glmapper.com/2018/12/30/springcoud-context-analysis/</id>
    <published>2018-12-30T16:17:28.000Z</published>
    <updated>2018-12-30T16:18:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引导程序应用上下文"><a href="#引导程序应用上下文" class="headerlink" title="引导程序应用上下文"></a>引导程序应用上下文</h2><blockquote><p>A Spring Cloud application operates by creating a “bootstrap” context, which is a parent context for the main application. It is responsible for loading configuration properties from the external sources and for decrypting properties in the local external configuration files. The two contexts share an Environment, which is the source of external properties for any Spring application.</p><p>By default, bootstrap properties (not bootstrap.properties but properties that are loaded during the bootstrap phase) are added with high precedence, so they cannot be overridden by local configuration.</p><p>The bootstrap context uses a different convention for locating external configuration than the main application context. Instead of application.yml (or .properties), you can use bootstrap.yml, keeping the external configuration for bootstrap and main context nicely separate.</p></blockquote><blockquote><p>释文：Spring Cloud 应用程序通过创建“引导程序”上下文来运行，<strong>该上下文是主应用程序的父上下文</strong>共享一个 Environment**，它是任何Spring应用程序的外部属性的来源。</p><p>默认情况下，引导属性（不是bootstrap.properties，而是在引导阶段加载的属性）以<strong>高优先级添加</strong>，因此本地配置无法覆盖它们。</p><p>引导上下文使用与主应用程序上下文不同的外部配置约定。 因此使用 bootstrap.yml application.yml（或.properties）代替引导和主上下文的外部配置，保持引导程序和主上下文的外部配置很好地分开。</p></blockquote><p><br><br>上面是 SpringCloud 关于引导上下文的一个解释，详见 <a href="https://cloud.spring.io/spring-cloud-static/Finchley.SR2/single/spring-cloud.html#_the_bootstrap_application_context" target="_blank" rel="noopener">这里</a>。</p><p>spring cloud 有自己的一套配置初始化机制，所以它实际上是自己启动了一个Spring 上下文，也就是我们说的引导上文。在上面的描述中有提到，引导上下文会以应用上下文的父类存在；在Spring中，如果上下文存在父子关系，也就意味着子上下文会集成父上下文的属性源和配置文件。在SpringBoot的启动过程中，prepareContext 这个操作会进行父子上下文的关系设置，调用栈如下:</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2018/png/97619/1546070770372-d7a4ec62-f29b-477f-adc0-844709415a32.png#wh=561x165" alt="image.png"></p><p>setParent 方法代码片段如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParent</span><span class="params">(@Nullable ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.parent = parent;</span><br><span class="line">       <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Environment parentEnvironment = parent.getEnvironment();</span><br><span class="line">           <span class="keyword">if</span> (parentEnvironment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">               <span class="keyword">this</span>.getEnvironment().merge((ConfigurableEnvironment)parentEnvironment);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>这个可以看到，子上下文会合并掉父上下文的 Environment 。关于父子上下文是怎么关联起来的，下面来看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(context.getParent() != <span class="keyword">null</span> &amp;&amp; context.getParent() != context) &#123;</span><br><span class="line">  context = (ConfigurableApplicationContext)context.getParent();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.reorderSources(context.getEnvironment());</span><br><span class="line">  (<span class="keyword">new</span> ParentContextApplicationContextInitializer(<span class="keyword">this</span>.parent)).initialize(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="BootstrapApplicationListener"><a href="#BootstrapApplicationListener" class="headerlink" title="BootstrapApplicationListener"></a>BootstrapApplicationListener</h3><p>上面的代码片段定位在 org.springframework.cloud.bootstrap.BootstrapApplicationListener 这个类；这个监听器监听的事件是  ApplicationEnvironmentPreparedEvent ，对应在SpringBoot启动过程，就是在执行 prepareEnvironment 时触发事件调用。</p><p>BootstrapApplicationListener 的 onApplicationEvent 回调方法中实际上就是用够构建和启动 Spring Cloud  context 的。<br>spring cloud context 算是一个特殊的 spring boot context， 在分析代码的过程中（bootstrapServiceContext方法中）发现，它只扫描 BootstrapConfiguration 这个注解标注的组件。</p><p>这里就着重分析下 SpringCloud Context 的启动过程。</p><h3 id="SpringCloud-Context-启动过程"><a href="#SpringCloud-Context-启动过程" class="headerlink" title="SpringCloud Context 启动过程"></a>SpringCloud Context 启动过程</h3><p><br></p><h4 id="通过-spring-cloud-bootstrap-enabled-配置来禁用引导上下文"><a href="#通过-spring-cloud-bootstrap-enabled-配置来禁用引导上下文" class="headerlink" title="通过 spring.cloud.bootstrap.enabled 配置来禁用引导上下文"></a>通过 spring.cloud.bootstrap.enabled 配置来禁用引导上下文</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!environment.getProperty(<span class="string">"spring.cloud.bootstrap.enabled"</span>, Boolean.class,<span class="keyword">true</span>)) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调函数的开始就会对 spring.cloud.bootstrap.enabled 这个配置值进行校验，来决定是否需要禁止引导。这个在官方文档里面也有明确提到。</p><h4 id="获取-configName"><a href="#获取-configName" class="headerlink" title="获取 configName"></a>获取 configName</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String configName = environment</span><br><span class="line">.resolvePlaceholders(<span class="string">"$&#123;spring.cloud.bootstrap.name:bootstrap&#125;"</span>);</span><br></pre></td></tr></table></figure><p><br><br>可以使用 spring.cloud.bootstrap.name（默认“bootstrap”）或spring.cloud.bootstrap.location（默认为空）指定bootstrap.yml（或.properties）位置，例如在系统属性中。<br><br></p><h4 id="bootstrapServiceContext-创建-amp-启动"><a href="#bootstrapServiceContext-创建-amp-启动" class="headerlink" title="bootstrapServiceContext 创建&amp;启动"></a>bootstrapServiceContext 创建&amp;启动</h4><p>bootstrapServiceContext 是完成此过程的核心方法。</p><ul><li>加载 BootstrapConfiguration 自动配置类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Bootstrap components</span><br><span class="line">org.springframework.cloud.bootstrap.BootstrapConfiguration=\</span><br><span class="line">org.springframework.cloud.bootstrap.config.PropertySourceBootstrapConfiguration,\</span><br><span class="line">org.springframework.cloud.bootstrap.encrypt.EncryptionBootstrapConfiguration,\</span><br><span class="line">org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration</span><br></pre></td></tr></table></figure><p>PropertySourceBootstrapConfiguration 将会把 PropertySourceLocator 自定义属性值添加到引导上下文的环境当中，包括如何从远端仓库拉取配置等过程。</p><ul><li><p>构建 SpringApplicationBuilder 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SpringApplicationBuilder builder = <span class="keyword">new</span> SpringApplicationBuilder()</span><br><span class="line">.profiles(environment.getActiveProfiles()).bannerMode(Mode.OFF)</span><br><span class="line">.environment(bootstrapEnvironment)</span><br><span class="line"><span class="comment">// Don't use the default properties in this builder</span></span><br><span class="line">.registerShutdownHook(<span class="keyword">false</span>).logStartupInfo(<span class="keyword">false</span>)</span><br><span class="line">.web(WebApplicationType.NONE);</span><br></pre></td></tr></table></figure></li><li><p>构建 引导上下文并 run</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ConfigurableApplicationContext context = builder.run();</span><br></pre></td></tr></table></figure></li></ul><p>这个 build.run 实际执行的就是 SpringApplication.run 方法。</p><ul><li>为关联父子上下文准备<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addAncestorInitializer(application, context);</span><br></pre></td></tr></table></figure></li></ul><p>这里会把 ParentContextApplicationContextInitializer 加到应用的 spring context 里，来把自己设置为应用的context 的 parent，具体是在SpringBoot启动过程的 prepareContext 中完成 。</p><h2 id="重载远程属性"><a href="#重载远程属性" class="headerlink" title="重载远程属性"></a>重载远程属性</h2><p>通过Bootstrap 上下文添加到应用程序的属性源通常是远程的，比如说来自配置中心的，一般情况下本地的配置文件不能覆盖这些远程属性源。</p><p>那么如果想覆盖远程属性源怎么办呢？可以通过启动命令行参数方式设定（启动命令行参数的优先级高于远程配置的优先级）。</p><p>如果想使用应用程序的系统属性或者配置文件覆盖远程属性，那么远程属性源必须设置为 spring.cloud.config.allowOverride = true，这个配置在本地设置时不会生效的。在远程属性源中设定上述配置后，就可以通过更为细粒度的设置来控制远程属性是否能被重载，具体配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">overrideNone:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      overrideSystemProperties:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li>overrideNone true，本地属性覆盖所有的远程属性</li><li>overrideSystemProperties ，仅覆盖远程属性源中的系统属性和环境变量</li></ul><h2 id="自定义-Bootstrap-属性源"><a href="#自定义-Bootstrap-属性源" class="headerlink" title="自定义 Bootstrap 属性源"></a>自定义 Bootstrap 属性源</h2><p>默认情况下，Bootstrap 的外部配置属性源是 spring cloud config server ，也就是使用配置中心加载外部属性，但是Spring中也允许用户通过将 ProoertySourceLocator 类型的Bean实例添加到 Bootstrap 上下文，也就是在 spring.factories 中添加相应的配置类，来添加额外的属性源来源。这里可以通过SpringCloud里面提供的测试用例来看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertySourceConfiguration</span> <span class="keyword">implements</span> <span class="title">PropertySourceLocator</span> </span>&#123;</span><br><span class="line"><span class="comment">// 省略其他代码</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertySource&lt;?&gt; locate(Environment environment) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.name != <span class="keyword">null</span>) &#123;</span><br><span class="line">      assertEquals(<span class="keyword">this</span>.name,</span><br><span class="line">                   environment.getProperty(<span class="string">"spring.application.name"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fail) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Planned"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MapPropertySource(<span class="string">"testBootstrap"</span>, MAP);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码段中传入的Envirement 参数用于创建应用上下文，它具有 SpringBoot 提供的属性源，可以使用它们来加载指定的属性源。</p><p>最后将这个自定义的 PropertySourceLocator 配置到 spring.factories 中，这样应用程序就可以使用这个 PropertySourceConfiguration 作为其属性源了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.cloud.bootstrap.BootstrapConfiguration=\</span><br><span class="line">xx.xx.x.x.PropertySourceConfiguration</span><br></pre></td></tr></table></figure><h2 id="关于Enviroment-的变化"><a href="#关于Enviroment-的变化" class="headerlink" title="关于Enviroment 的变化"></a>关于Enviroment 的变化</h2><p>配置中心客户端（Spring Cloud Config Client） 应用会监听  EnviromentChangeEvent 事件，当监听到这个事件时，它将持有一个被改变的键值对列表，然后客户端应用会使用这些值来做一些事情：</p><ul><li>重新绑定所有的@ConfigurationProperties的Bean<a href="#">@ConfigurationProperties</a> 实例，更新本地的配置属性。</li><li>设置日志等级（logging.level.* 相关配置）</li></ul><p>Spring Cloud 中，配置中心服务端使用 Spring Cloud Bus 将EnviromentChangeEvent 事件广播到所有的客户端中，通过这种方式来通过它们 Enviroment 发生变化。<br><br></p><h2 id="RefreshScope"><a href="#RefreshScope" class="headerlink" title="RefreshScope"></a>RefreshScope</h2><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>RefreshScope 注解的作用是，当被这个注解标记的Bean实例在配置发生变化时可以重新进行初始化，可参考 <a href="https://yuque.antfin-inc.com/guolei.sgl/springcloud/krv1v3#43d58bbd" target="_blank" rel="noopener">动态刷新配置</a> 这个demo。这个注解很好的解决了状态Bean实例只能在初始化的时候才能进行属性注入的问题。</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>org.springframework.cloud.context.scope.refresh.RefreshScope 是上下文中的一个Bean实例，在它的 refreshAll 这个方法中，可以通过清除目标缓存来刷新作用域中的所有Bean实例。RefreshScope中也提供了一个 refresh方法，可以按照名字来刷新单个Bean。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引导程序应用上下文&quot;&gt;&lt;a href=&quot;#引导程序应用上下文&quot; class=&quot;headerlink&quot; title=&quot;引导程序应用上下文&quot;&gt;&lt;/a&gt;引导程序应用上下文&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;A Spring Cloud application op
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="spring cloud" scheme="http://www.glmapper.com/tags/spring-cloud/"/>
    
      <category term="commons" scheme="http://www.glmapper.com/tags/commons/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-配置中心 Config</title>
    <link href="http://www.glmapper.com/2018/12/30/springcoud-config-project/"/>
    <id>http://www.glmapper.com/2018/12/30/springcoud-config-project/</id>
    <published>2018-12-30T16:16:07.000Z</published>
    <updated>2019-01-09T15:38:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在分布式系统中，每一个功能模块都能拆分成一个独立的服务，一次请求的完成，可能会调用很多个服务协调来完成，为了方便服务配置文件统一管理，更易于部署、维护，所以就需要一个地方来管理这些配置信息。</p><p>在 spring cloud Config 就提供了这样的能力，通过集中化管理的方式，支持配置文件放在在配置服务的内存中远程 Git 仓库以及Subversion。</p><p>本篇将通过一个简单的 demo ，使用 spring cloud Config 原生提供的基于 Git 的方式来实现微服务体系下的配置管理功能。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK<br></td><td>1.8.0_162<br></td></tr><tr><td>SOFABoot/SpringBoot<br></td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE<br></td></tr><tr><td>SpringCloud<br></td><td>Finchley.RC1<br></td></tr><tr><td>IDE<br></td><td>IDEA<br></td></tr></tbody></table><h2 id="工程背景"><a href="#工程背景" class="headerlink" title="工程背景"></a>工程背景</h2><p>本节将通过 SOFABoot 来集成 Spring Cloud Config ，以 git 作为存储，来实现分布式环境下的配置管理。本工程的父工程仍然是《SpringCloud-Eureka 服务注册》中构建的父工程。 </p><p>由于我们是以 git 来存储配置文件的，因此我们需要在 github 上新建一个存储配置文件的空间，为了更方面的模拟，这里创建了两个配置文件：</p><ul><li>glmapper-dev.properties</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=leishu@glmapper_dev</span><br><span class="line">blog=http://www.glmapper.com</span><br><span class="line">version=dev</span><br></pre></td></tr></table></figure><ul><li>glmapper-pre.properties</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=leishu@glmapper_pre</span><br><span class="line">blog=http://www.glmapper.com</span><br><span class="line">version=pre</span><br></pre></td></tr></table></figure><blockquote><p>github 地址：<a href="https://github.com/glmapper/glmapper-config-repository" target="_blank" rel="noopener">https://github.com/glmapper/glmapper-config-repository</a></p></blockquote><h2 id="新建-sofa-config-server"><a href="#新建-sofa-config-server" class="headerlink" title="新建 sofa-config-server"></a>新建 sofa-config-server</h2><p>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p><ul><li>artifactId：sofa-config-server</li></ul><h3 id="修改-pom-文件"><a href="#修改-pom-文件" class="headerlink" title="修改 pom 文件"></a>修改 pom 文件</h3><p>这里直接引入 config 的依赖即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8091</span></span><br><span class="line">  <span class="comment">#服务名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">sofa-config-server</span></span><br><span class="line">  <span class="comment">#服务的git仓库地址</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      server:</span></span><br><span class="line"><span class="attr">        git:</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">https://github.com/glmapper/glmapper-config-repository</span></span><br><span class="line"><span class="attr">          search-paths:</span> <span class="string">/**</span></span><br><span class="line"><span class="attr">          username:</span> <span class="string">glmapper_2018@163.com</span></span><br><span class="line"><span class="attr">          password:</span> <span class="string">******</span></span><br><span class="line">      <span class="comment">#指定分支</span></span><br><span class="line"><span class="attr">      label:</span> <span class="string">master</span></span><br><span class="line"><span class="comment">#服务注册中心</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><blockquote><p>如果你的 github 仓库是公开的话，就不需要输入账户和密码就可以访问。</p></blockquote><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>在启动类上加 @EnableConfigServer 注解，激活对配置中心的支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaConfigServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaConfigServerApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动-amp-验证"><a href="#启动-amp-验证" class="headerlink" title="启动 &amp; 验证"></a>启动 &amp; 验证</h3><p>因为配置中心作为一个独立的服务，所以不需要依赖其他服务的先启动，直接运行当前程序即可。这里我们首先需要验证下 server 端是否已经成功拉取到了 github 上面的配置信息：</p><p>访问：<a href="http://localhost:8091/glmapper/pre/master" target="_blank" rel="noopener">http://localhost:8091/glmapper/pre/master</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"glmapper"</span>,</span><br><span class="line">    <span class="attr">"profiles"</span>: [</span><br><span class="line">        <span class="string">"pre"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"label"</span>: <span class="string">"master"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"f9e8c1f2825d23031cb13d40e396a23c0f975d2d"</span>,</span><br><span class="line">    <span class="attr">"state"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"propertySources"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"https://github.com/glmapper/glmapper-config-repository/glmapper-pre.properties"</span>,</span><br><span class="line">            <span class="attr">"source"</span>: &#123;</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"leishu@glmapper-pre"</span>,</span><br><span class="line">                <span class="attr">"blog"</span>: <span class="string">"http://www.glmapper.com"</span>,</span><br><span class="line">                <span class="attr">"version"</span>: <span class="string">"pre"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK ，说明服务端已经成功拉取到了github上的配置文件了。</p><blockquote><p>关于地址的说明：<a href="http://localhost:8091/glmapper/pre/master" target="_blank" rel="noopener">http://localhost:8091/glmapper/pre/master</a> 。前半部分是ip和端口，没什么好说的。<br>glmapper/pre/master，因为我在github上新建的配置文件名是 glmapper-dev.properties 和 glmapper-pre .properties ;所以这里地址的规则就是 /glmapper/pre ，后面的 master 可带可不带，区别在于返回的 JSON 数据 label 是 null 还是 master，label 指向分支。</p></blockquote><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>本节构建一个简单的客户端工程 sofa-config-client ，用于从 sofa-config-server 上获取配置文件并展示。sofa-config-client 同样基于《SpringCloud-Eureka 服务注册》中构建的父工程。 </p><h3 id="修改-pom-文件-1"><a href="#修改-pom-文件-1" class="headerlink" title="修改 pom 文件"></a>修改 pom 文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-config-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入 spring-cloud-starter-config 和  spring-boot-starter-web 依赖。</p><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件包括两个，一个是 application.yml ，另一个是 bootstrap.yml</p><ul><li>application.yml</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sofa-config-client</span><br><span class="line">server:</span><br><span class="line">  port: 8099</span><br></pre></td></tr></table></figure><ul><li>bootstrap.yml</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      name: glmapper</span><br><span class="line">      profile: pre</span><br><span class="line">      uri: http://localhost:8091/   #指向配置中心的地址</span><br><span class="line">      label: master</span><br></pre></td></tr></table></figure><h3 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h3><p>启动类不需要做什么修改，也不需要额外加什么注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaConfigClientApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaConfigClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="资源类"><a href="#资源类" class="headerlink" title="资源类"></a>资源类</h3><p>新建一个资源类，用于输出展示拉取到的配置信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;blog&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span>  String blog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;version&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span>  String version;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/config"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">config</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name:"</span>+name+<span class="string">" ,blog:"</span>+blog+<span class="string">" ,version:"</span>+version;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="启动和运行"><a href="#启动和运行" class="headerlink" title="启动和运行"></a>启动和运行</h3><p>先后启动配置中心服务端和客户端程序。在浏览器中输入：<a href="http://localhost:8099/config" target="_blank" rel="noopener">http://localhost:8099/config</a> ，返回如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name:leishu@glmapper-pre ,blog:http://www.glmapper.com ,version:pre</span><br></pre></td></tr></table></figure></p><p>我们尝试下将 github 中 glmapper-pre.properties 这个配置文件进行修改，看下是否在这能获取到最新的依赖，修改之后，如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=leishu@glmapper_pre_update</span><br><span class="line">blog=http://www.glmapper.com</span><br><span class="line">version=pre</span><br></pre></td></tr></table></figure></p><p>重新刷新浏览器地址，返回如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name:leishu@glmapper-pre ,blog:http://www.glmapper.com ,version:pre</span><br></pre></td></tr></table></figure></p><p>这里并没有发生任何变换，因为 SpringBoot 项目只会在项目启动时才会获取一次配置文件信息，当我们修改了 github 上的配置文件之后，当前的配置中心客户端并没有主动去获取配置值，所以不会有新的值，我们获取到的还是旧的值。那么下面通过修改和增加一些组件和配置来实现不停服动态更新配置。</p><h3 id="配置动态更新"><a href="#配置动态更新" class="headerlink" title="配置动态更新"></a>配置动态更新</h3><p>要实现配置的动态更新，需要借助于 springboot 的 actuator 监控模块。所有需要在客户端pom文件中引入 actuator 的依赖信息。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>配置文件 application.yml 中增加配置，将/actuator/refresh 断点暴露出来，注意不要配置在 boostrap.yml 中。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sofa-config-client</span><br><span class="line">server:</span><br><span class="line">  port: 8099</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: refresh</span><br></pre></td></tr></table></figure></p><p>资源类中开启更新机制，在 ConfigClientController 类中增加 @RefreshScope 注解，然后重启客户端。</p><p>首先执行：<a href="http://localhost:8099/config" target="_blank" rel="noopener">http://localhost:8099/config</a> ，得到结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name:leishu@glmapper-pre ,blog:http://www.glmapper.com ,version:pre&lt;br /&gt;</span><br></pre></td></tr></table></figure></p><p>更新 github 上配置文件的值，将 name 改为 name:leishu@glmapper-pre，通过 curl 或者 postman 执行下 刷新：</p><p><img src="https://oscimg.oschina.net/oscnet/64907646317fdc6038cb4ab46f713fbc231.jpg" alt="image.png"></p><p>再次刷新执行 <a href="http://localhost:8099/config" target="_blank" rel="noopener">http://localhost:8099/config</a> ，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name:leishu@glmapper-pre-update ,blog:http://www.glmapper.com ,version:pre</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;在分布式系统中，每一个功能模块都能拆分成一个独立的服务，一次请求的完成，可能会调用很多个服务协调来完成，为了方便服务配置文件统一管理，更易于
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="Config" scheme="http://www.glmapper.com/tags/Config/"/>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-负载均衡器 Ribbon</title>
    <link href="http://www.glmapper.com/2018/12/30/springcoud-ribbon-project/"/>
    <id>http://www.glmapper.com/2018/12/30/springcoud-ribbon-project/</id>
    <published>2018-12-30T16:15:01.000Z</published>
    <updated>2019-01-09T15:32:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇 <a href="http://www.glmapper.com/2018/12/31/springcoud-feign-project/">SpringCloud-声明式服务调用 Feign</a> 中介绍了如何使用 Feign 来完成服务调用。因为 Feign 本身已经集成了 Ribbon ，所以也具有负载均衡的能力。那么本篇将使用 RestTemplate + Ribbon 来实现服务调用和负载均衡策略。</p><h2 id="Ribbon-简介"><a href="#Ribbon-简介" class="headerlink" title="Ribbon 简介"></a>Ribbon 简介</h2><p>Ribbon 是管理HTTP和TCP服务客户端的负载均衡器。Ribbon 具有一些列带有名称的客户端，也就是带有名称的Ribbon 客户端。每个客户端由可配置的组件构成，负责一类服务的调用请求。Spring Cloud 通过RibbonClientConfiguration 为每个Ribbon 客户端创建一个ApplicationContext 上下文来进行组件装配。Ribbon 作为 Spring Cloud的负载均衡机制的实现，可以与OpenFeign 和 RestTemplate 进行无缝集成，让二者也具有负载均衡的能力。</p><h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><table><thead><tr><th><strong>策略类</strong><br></th><th><strong>命名</strong><br></th><th>备注<br></th></tr></thead><tbody><tr><td>RoundRobinRule<br></td><td>轮训策略<br></td><td>按顺序循环选择 Server<br></td></tr><tr><td>RandomRule<br></td><td>随机策略<br></td><td>随机选择 Server<br></td></tr><tr><td>RetryRule<br></td><td>重试策略<br></td><td>在一个配置时问段内当选择 Server 不成功，则一直尝试选择一个可用的 Server<br></td></tr><tr><td>BestAvailableRule<br></td><td>最低并发策略<br></td><td>逐个考察 Server，如果 Server 断路器打开，则忽略，再选择其中并发连接最低的 Server    <br></td></tr><tr><td>AvailabilityFilteringRule<br></td><td>可用过滤策略<br></td><td>过滤掉一直连接失败并被标记为 <code>circuit tripped</code> 的 Server，过滤掉那些高并发连接的 Server（active connections 超过配置的网值）<br></td></tr><tr><td>ResponseTimeWeightedRule<br></td><td>响应时间加权策略<br></td><td>根据 Server 的响应时间分配权重。响应时间越长，权重越低，被选择到的概率就越低；响应时间越短，权重越高，被选择到的概率就越高。这个策略很贴切，综合了各种因素，如：网络、磁盘、IO等，这些因素直接影响着响应时间<br></td></tr><tr><td>ZoneAvoidanceRule<br></td><td>区域权衡策略<br></td><td>综合判断 Server 所在区域的性能和 Server 的可用性轮询选择 Server，并且判定一个 AWS Zone 的运行性能是否可用，剔除不可用的 Zone 中的所有 Server<br></td></tr></tbody></table><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK<br></td><td>1.8.0_162<br></td></tr><tr><td>SOFABoot/SpringBoot<br></td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE<br></td></tr><tr><td>SpringCloud<br></td><td>Finchley.RC1<br></td></tr><tr><td>IDE<br></td><td>IDEA<br></td></tr></tbody></table><h2 id="工程背景"><a href="#工程背景" class="headerlink" title="工程背景"></a>工程背景</h2><p>本节将会创建一个 sofa-eureka-consumer-Ribbon 工程，通过 Spring Cloud 提供的负载均衡器 Ribbon 实现服务的负载均衡，并对 Ribbon 中的负载均衡策略进行验证。</p><h2 id="新建-sofa-eureka-consumer-ribbon"><a href="#新建-sofa-eureka-consumer-ribbon" class="headerlink" title="新建 sofa-eureka-consumer-ribbon"></a>新建 sofa-eureka-consumer-ribbon</h2><p>本工程继续使用《SpringCloud-Eureka 服务注册》中的父工程来构建。</p><p>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p><ul><li>artifactId：sofa-eureka-consumer-ribbon</li></ul><p>前面我们已经对feign进行的实际操作，因此本节使用 Ribbon + RestTemplate 组合实现具体的负载均衡实验。</p><h3 id="修改-pom-文件"><a href="#修改-pom-文件" class="headerlink" title="修改 pom 文件"></a>修改 pom 文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-consumer-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8889</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka-consumer-ribbon</span></span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>这里需要引入 @EnableEurekaClient 注解，表示当前是一个客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaEurekaConsumerRibbonApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaEurekaConsumerRibbonApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@LoadBalanced ： Spring Cloud 为客户端负载均衡创建了特定的注解，被该注解修饰的 RestTemplate Bean实例，Spring Cloud 就会让 RestTemplate 使用相关的负载均衡策略，默认情况下使用的就是 Ribbon。</p><h3 id="资源类"><a href="#资源类" class="headerlink" title="资源类"></a>资源类</h3><p>这里我们通过 restTemplate 去访问 Provider 提供的服务，需要注意，这里为了演示作用，直接将资源 Url 固定写成：<a href="http://HELLOSOFASERVICE/hello" target="_blank" rel="noopener">http://HELLOSOFASERVICE/hello</a> ，<a href="http://hellosofaservice/hello" target="_blank" rel="noopener">HELLOSOFASERVICE</a> 为 Provider 提供的服务的实例名称，也就是 Eureka 服务端界面上对应的 <strong>Application。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://HELLOSOFASERVICE/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>这里正常先后启动 服务注册中心 sofa-eureka-server-center ；服务提供方 sofa-eureka-provider ，服务提供方为了方便演示，这里启动4个实例，对应的端口分别为：8081，8082，8083，8084，如下：</p><p><img src="https://oscimg.oschina.net/oscnet/71ffa9b404d5727807a4cfbdc44cdfa8346.jpg" alt="image.png"></p><p>然后启动当前 sofa-eurek-consumer-ribbon 工程。默认情况下，不指定任何负载均衡策略，使用的是轮询策略。</p><p>浏览器输入 <a href="http://localhost:8889/hello" target="_blank" rel="noopener">http://localhost:8889/hello</a> ，调用10次：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8082</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8084</span> And hostname is HelloSOFAService</span><br><span class="line">  </span><br><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8082</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8084</span> And hostname is HelloSOFAService</span><br><span class="line">  </span><br><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8082</span> And hostname is HelloSOFAService</span><br></pre></td></tr></table></figure></p><p>从结果来看，默认策略应该是轮询（不用情况下，调用顺序不一定是1-2-3-4，但是以每4组为一组来看，存在周期性）。</p><h2 id="负载均衡策略设置"><a href="#负载均衡策略设置" class="headerlink" title="负载均衡策略设置"></a>负载均衡策略设置</h2><h3 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h3><p>全局设置就是自己定义一个配置类，然后在配置类中指定具体的负载均衡策略。在com.alipay.sofa.cloud.configuration 包下面新建一个配置类，这里使用的策略是随机策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonGlobalLoadBalancingConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器输入 <a href="http://localhost:8889/hello" target="_blank" rel="noopener">http://localhost:8889/hello</a> ，调用10次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8084</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8084</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">  </span><br><span class="line">Hello SOFA! Now Port is <span class="number">8082</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8082</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8084</span> And hostname is HelloSOFAService</span><br><span class="line">  </span><br><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br></pre></td></tr></table></figure><p>从结果来看，具有随机属性。</p><h3 id="针对单个服务的-Ribbon-负载均衡策略"><a href="#针对单个服务的-Ribbon-负载均衡策略" class="headerlink" title="针对单个服务的 Ribbon 负载均衡策略"></a>针对单个服务的 Ribbon 负载均衡策略</h3><p>新建一个 RibbonRandomLBConfiguration 配置类，这里有个前提是需要删除 全局配置类  。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonRandomLBConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>修改启动类，增加 @RibbonClient 注解，并且通过 configuration 指定负载均衡策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@RibbonClient</span>(name=<span class="string">"HELLOSOFASERVICE"</span>,configuration = RibbonRandomLBConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaEurekaConsumerRibbonApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaEurekaConsumerRibbonApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器输入 <a href="http://localhost:8889/hello" target="_blank" rel="noopener">http://localhost:8889/hello</a> ，调用10次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br><span class="line">  </span><br><span class="line">Hello SOFA! Now Port is <span class="number">8084</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8082</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8082</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br><span class="line">  </span><br><span class="line">Hello SOFA! Now Port is <span class="number">8081</span> And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is <span class="number">8083</span> And hostname is HelloSOFAService</span><br></pre></td></tr></table></figure><p>从结果来看，具有随机属性。</p><p>@RibbonClient 注解属性中，name 并非是一个数组，也就是说只能指定一个服务实例。那么基于上述情况，如果还存在另外一个服务，比如 SOFABOOTHELLOSERVICE ，那么对于此服务的调用会是什么情况呢？</p><p>先向注册中心注册两个服务：<strong>HELLOSOFABOOTSERVICE 和 </strong>HELLOSOFASERVICE<em>**</em></p><p><img src="https://oscimg.oschina.net/oscnet/4ec12075c7fca68bf15d4c6793a6294d760.jpg" alt="image.png"></p><p>修改 RibbonController ，增加一个 /helloBoot 资源地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://HELLOSOFASERVICE/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/helloBoot"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloBoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://HELLOSOFABOOTSERVICE/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启启动当前服务。</p><p>浏览器中输入：<a href="http://localhost:8889/hello" target="_blank" rel="noopener">http://localhost:8889/hello</a> ，验证结果满足随机调用。</p><p>浏览器中输入：<a href="http://localhost:8889/helloBoot" target="_blank" rel="noopener">http://localhost:8889/helloBoot</a> ，验证结果满足轮询调用。</p><h3 id="基于配置文件的负载均衡策略设置"><a href="#基于配置文件的负载均衡策略设置" class="headerlink" title="基于配置文件的负载均衡策略设置"></a>基于配置文件的负载均衡策略设置</h3><p>个人感觉基于配置文件配置方式更加直观，而且对于多个服务对应不同的负载策略设置也更加清晰，下面对HELLOSOFASERVICE 和  HELLOSOFABOOTSERVICE 均使用随机策略。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">HELLOSOFASERVICE:</span></span><br><span class="line"><span class="attr">  ribbon:</span></span><br><span class="line"><span class="attr">    NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br><span class="line"></span><br><span class="line"><span class="attr">HELLOSOFABOOTSERVICE:</span></span><br><span class="line"><span class="attr">  ribbon:</span></span><br><span class="line"><span class="attr">    NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure><p>启动类中删除以下注解配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"HELLOSOFASERVICE"</span>, configuration = RibbonRandomLBConfiguration.class)</span><br></pre></td></tr></table></figure><p>重启启动当前服务。</p><p>浏览器中输入：<a href="http://localhost:8889/hello" target="_blank" rel="noopener">http://localhost:8889/hello</a> ，验证结果满足随机调用。<br>浏览器中输入：<a href="http://localhost:8889/helloBoot" target="_blank" rel="noopener">http://localhost:8889/helloBoot</a> ，验证结果满足随机调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇 &lt;a href=&quot;http://www.glmapper.com/2018/12/31/springcoud-feign-project/&quot;&gt;SpringCloud-声明式服务调用 Feign&lt;/a&gt; 中介绍了如何使用 Feign 来完成服务调用。因为 Feign 
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="spring cloud" scheme="http://www.glmapper.com/tags/spring-cloud/"/>
    
      <category term="Ribbon" scheme="http://www.glmapper.com/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-声明式服务调用 Feign</title>
    <link href="http://www.glmapper.com/2018/12/30/springcoud-feign-project/"/>
    <id>http://www.glmapper.com/2018/12/30/springcoud-feign-project/</id>
    <published>2018-12-30T16:14:06.000Z</published>
    <updated>2019-01-09T15:23:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Fegin 是一个声明式的 web 服务客户端，它使得编写 web 服务客户端变得更加容易。使用 Fegin 创建一个接口并对它进行注解。它具有可插拔的注解支持包括 Feign 注解与 JAX-RS 注解，Feign 还支持可插拔的编码器与解码器，Spring Cloud 增加了对 Spring MVC 的注解，Spring Web 默认使用了 HttpMessageConverters。Fegin 还可以集成 Ribbon 和 Hystrix 来提供负载均衡和网络断路器的功能。</p><p>本篇将使用 Fegin + eureka client 来完成服务发现和调用。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK<br></td><td>1.8.0_162<br></td></tr><tr><td>SOFABoot/SpringBoot<br></td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE<br></td></tr><tr><td>SpringCloud<br></td><td>Finchley.RC1<br></td></tr><tr><td>IDE<br></td><td>IDEA<br></td></tr></tbody></table><h2 id="工程背景"><a href="#工程背景" class="headerlink" title="工程背景"></a>工程背景</h2><p>本节将会创建一个 sofa-eureka-consumer-feign 工程，使用 Feign 提供的 web 客户端来访问 sofa-eureka-provider 发布的服务。同时也基于此工程验证基于 Feign 实现的负载均衡。</p><h2 id="新建-sofa-eureka-consumer-feign"><a href="#新建-sofa-eureka-consumer-feign" class="headerlink" title="新建 sofa-eureka-consumer-feign"></a>新建 sofa-eureka-consumer-feign</h2><p>本工程继续使用《SpringCloud-Eureka 服务注册》中的父工程来构建。</p><p>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p><ul><li>artifactId：sofa-eureka-consumer-feign</li></ul><h3 id="修改pom文件"><a href="#修改pom文件" class="headerlink" title="修改pom文件"></a>修改pom文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-server-center<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencys</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencys</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.port=8888</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:8761/eureka/</span><br><span class="line">spring.application.name=eureka-consumer-feign</span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>这里需要添加 @EnableEurekaClient 和 @EnableFeignClients 两个注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaEurekaConsumerFeignApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaEurekaConsumerFeignApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="资源类"><a href="#资源类" class="headerlink" title="资源类"></a>资源类</h3><ul><li>com.alipay.sofa.cloud.service 包下新建  HelloSOFAService</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"helloSOFAService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloSOFAService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>com.alipay.sofa.cloud.controller 包下新建  FeignController</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloSOFAService helloSOFAService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloSOFAService.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动-amp-验证"><a href="#启动-amp-验证" class="headerlink" title="启动 &amp; 验证"></a>启动 &amp; 验证</h3><p>启动当前工程，在此之前请以此启动 注册中心 sofa-eureka-server-center 和 sofa-eureka-provider 两个工程。</p><blockquote><p>注：这里我启动了两个 provider 工程</p></blockquote><p>浏览器输入：http:localhost:8888/hello，观察到浏览器中依次展示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello SOFA! Now Port is 8081 And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is 8082 And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is 8081 And hostname is HelloSOFAService</span><br><span class="line">Hello SOFA! Now Port is 8082 And hostname is HelloSOFAService</span><br></pre></td></tr></table></figure></p><p>这里可以看待 通过 feign 提供的客户端能力已经访问到了远程服务，由于 feign 集成了 ribbon 因此也就默认实现了负载均衡的能力。从结果来看，默认的负载均衡策略是轮询。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Fegin 是一个声明式的 web 服务客户端，它使得编写 web 服务客户端变得更加容易。使用 Fegin 创建一个接口并对它进行注解。它
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="spring cloud" scheme="http://www.glmapper.com/tags/spring-cloud/"/>
    
      <category term="Feign" scheme="http://www.glmapper.com/tags/Feign/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud-Eureka Client 原理解析</title>
    <link href="http://www.glmapper.com/2018/12/30/springcoud-eureka-client-analysis/"/>
    <id>http://www.glmapper.com/2018/12/30/springcoud-eureka-client-analysis/</id>
    <published>2018-12-30T16:12:46.000Z</published>
    <updated>2019-01-11T15:20:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面一些 demo 中已经介绍了如何使用 SOFABoot 来集成 Spring Cloud Netflix Eureka 组件。本篇将来先解析下 Eureka Client 的工作原理。</p><h2 id="Netflix-和-SpringCloud"><a href="#Netflix-和-SpringCloud" class="headerlink" title="Netflix 和 SpringCloud"></a>Netflix 和 SpringCloud</h2><p>spring-cloud-commons 模块是 spring 在分布式领域上(服务发现，服务注册，断路器，负载均衡)的规范定义。spring-cloud-netflix 是基于此规范的具体实现，Netflix OSS 里的各种组件也都实现了这个 commons 规范。关系如下：<br><img src="https://oscimg.oschina.net/oscnet/955bbfee782856642563be3bbbdb8e32d4e.jpg" alt="image.png"></p><h2 id="Spring-Cloud-Netflix-Eureka-服务发现实现原理"><a href="#Spring-Cloud-Netflix-Eureka-服务发现实现原理" class="headerlink" title="Spring Cloud Netflix Eureka 服务发现实现原理"></a>Spring Cloud Netflix Eureka 服务发现实现原理</h2><p>基于上图，这里以 Eureka 中的服务发现为例，来具体讲下是如何实现的。Spring Cloud common 中提供了用于服务发现的两个关键类：DiscoveryClient 接口 和 EnableDiscoveryClient 注解。</p><h3 id="DiscoveryClient-接口"><a href="#DiscoveryClient-接口" class="headerlink" title="DiscoveryClient 接口"></a>DiscoveryClient 接口</h3><p>下面这张图描述的是在服务发现这个功能上，SpringCloud 是如何与 Netflix 整合的。<br>在 spring-cloud-netflix-eureka-client 中对 Spring Cloud Common 中的 DiscoveryClient 接口进行了实现，实现类是 EurekaDiscoveryClient 。<br><img src="https://oscimg.oschina.net/oscnet/a123885eae0d4c0ab198c02d5ad551475bd.jpg" alt="image.png"></p><p>DiscoveryClient 的接口定义与方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DiscoveryClient表示服务发现常用的读取操作，例如Netflix Eureka或consul.io</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spencer Gibb</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscoveryClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现描述</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the description</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">description</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取与特定serviceId关联的所有ServiceInstances</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> serviceId the serviceId to query</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a List of ServiceInstance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;ServiceInstance&gt; <span class="title">getInstances</span><span class="params">(String serviceId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回所有已知的服务ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getServices</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EurekaDiscoveryClient 中实现了这几个方法，但是 EurekaDiscoveryClient 自身没有实现如何与服务端交互的逻辑，而是通过 com.netflix.DiscoveryClient 类来完成。所以 spring-cloud-netflix-eureka-client 干的事情就是实现了 Spring Cloud Common 规范，然后在实现上包装了 netflix 。</p><h3 id="EnableDiscoveryClient-注解"><a href="#EnableDiscoveryClient-注解" class="headerlink" title="@EnableDiscoveryClient 注解"></a>@EnableDiscoveryClient 注解</h3><p><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import</span>(EnableDiscoveryClientImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableDiscoveryClient &#123;</span><br><span class="line">  <span class="comment">//是否自动注册，默认是true。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">autoRegister</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>EnableDiscoveryClientImportSelector 将会从 META-INF/spring.factories 里找出 key 为org.springframework.cloud.client.discovery.EnableDiscoveryClient 的类。</p><p>对于 autoRegister ：</p><ul><li>如果自动注册属性为true，会在找出的这些类里再加上一个类：AutoServiceRegistrationConfiguration， AutoServiceRegistrationConfiguration 内部会使用@EnableConfigurationProperties(AutoServiceRegistrationProperties.class) 触发构造AutoServiceRegistrationProperties 这个 bean。像eureka，nacos，它们的自动化配置类里都使用了@ConditionalOnBean(AutoServiceRegistrationProperties.class) 来确保存在AutoServiceRegistrationProperties 这个 bean 存在的时候才会构造 AutoServiceRegistration 进行注册。</li><li>如果自动注册属性为 false，在Environment 里加一个 PropertySource，内部的配置项是spring.cloud.service-registry.auto-registration.enabled，值是false(代表不构造AutoServiceRegistrationProperties.class)。这样 eureka 就不会注册。</li></ul><p>对应上面这段逻辑的代码如下：</p><p><img src="https://oscimg.oschina.net/oscnet/219321a0468aaa9abbd81af27292bc927d6.jpg" alt="image.png"></p><p>spring-cloud-netflix-eureka-client 自己也提供了一个注解 EnableEurekaClient，其作用于这个注解一样</p><h2 id="Eureka-架构图"><a href="#Eureka-架构图" class="headerlink" title="Eureka 架构图"></a>Eureka 架构图</h2><p><img src="https://oscimg.oschina.net/oscnet/a43e024e39d5d351b0e4961bd61e4bd71de.jpg" alt="image.png"></p><ul><li>consumer  : 服务消费方，eureka client 角色，可以从 eureka server 上拉取到其他已注册服务的信息，从而根据这些信息找到自己所需的服务，然后发起远程调用。</li><li>provider : 服务提供方，eureka client 角色，可以向 eureka server 上注册和更新自己的信息，当然作为 eureka client ，它也可以从server 上获取到其他服务的信息。</li><li>Eureka server : 服务注册中心，提供服务注册和服务发现功能；</li><li>同步复制 ： eureka server 之间进行注册服务信息的同步，这样可以保证集群中每个server 都能提供完整的服务信息。</li></ul><blockquote><p>关于 AWS 上 Regin 和 Availability Zone 的概念，请自行查阅相关资料</p></blockquote><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="配置信息读取"><a href="#配置信息读取" class="headerlink" title="配置信息读取"></a>配置信息读取</h3><p>Eureka Client的自动配置类是 org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration ，这里面主要就负责了一些配置信息的服务诸如 DiscoveryClient 、EurekaServiceRegistry等主要bean的初始化工作。</p><p>另外还有一个 EurekaDiscoveryClientConfiguration 类，负责配置自动注册和应用的健康检查器初始化。</p><h4 id="读取-eureka-client"><a href="#读取-eureka-client" class="headerlink" title="读取 eureka.client.*"></a>读取 eureka.client.*</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = EurekaClientConfig.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="function"><span class="keyword">public</span> EurekaClientConfigBean <span class="title">eurekaClientConfigBean</span><span class="params">(ConfigurableEnvironment env)</span> </span>&#123;</span><br><span class="line">EurekaClientConfigBean client = <span class="keyword">new</span> EurekaClientConfigBean();</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"bootstrap"</span>.equals(<span class="keyword">this</span>.env.getProperty(<span class="string">"spring.config.name"</span>))) &#123;</span><br><span class="line">    <span class="comment">// 默认情况下，我们不会在引导过程中注册，但是以后会有另一个机会。</span></span><br><span class="line">    client.setRegisterWithEureka(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EurekaClientConfigBean 封装的是 eureka client 和 eureka server 交互所需要的配置信息，比如前面demo工程中的 eureka.client.service-url.defaultZone 的配置。</p><h4 id="读取-eureka-instance"><a href="#读取-eureka-instance" class="headerlink" title="读取 eureka.instance.*"></a>读取 eureka.instance.*</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = EurekaInstanceConfig.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="function"><span class="keyword">public</span> EurekaInstanceConfigBean <span class="title">eurekaInstanceConfigBean</span><span class="params">(InetUtils inetUtils,</span></span></span><br><span class="line"><span class="function"><span class="params">ManagementMetadataProvider managementMetadataProvider)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 代码较长，此处省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EurekaInstanceConfigBean 封装的是 eureka client 自身实例的配置信息，提供服务注册的基本元数据信息。</p><h3 id="核心组件-bean-初始化"><a href="#核心组件-bean-初始化" class="headerlink" title="核心组件 bean 初始化"></a>核心组件 bean 初始化</h3><p>这里也实例化了一些核心的组件bean。</p><h4 id="ApplicationInfoManager"><a href="#ApplicationInfoManager" class="headerlink" title="ApplicationInfoManager"></a>ApplicationInfoManager</h4><ul><li>EurekaClientConfiguration#eurekaApplicationInfoManager</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = ApplicationInfoManager.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApplicationInfoManager <span class="title">eurekaApplicationInfoManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">EurekaInstanceConfig config)</span> </span>&#123;</span><br><span class="line">  InstanceInfo instanceInfo = <span class="keyword">new</span> InstanceInfoFactory().create(config);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ApplicationInfoManager(config, instanceInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>RefreshableEurekaClientConfiguration#eurekaApplicationInfoManager<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = ApplicationInfoManager.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="meta">@org</span>.springframework.cloud.context.config.annotation.RefreshScope</span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ApplicationInfoManager <span class="title">eurekaApplicationInfoManager</span><span class="params">(EurekaInstanceConfig config)</span> </span>&#123;</span><br><span class="line">  InstanceInfo instanceInfo = <span class="keyword">new</span> InstanceInfoFactory().create(config);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ApplicationInfoManager(config, instanceInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>RefreshScope ，被此注解标注的情况下，将会被动态刷新。包括属性信息等，注意，对于动态刷新，被RefreshScope标记的类不能是final的。</p></blockquote><p>ApplicationInfoManager 是应用信息管理器，用于管理服务实例的信息类 InstanceInfo 和服务实例的配置信息类 EurekaInstanceConfig 。</p><h4 id="DiscoveryClient"><a href="#DiscoveryClient" class="headerlink" title="DiscoveryClient"></a>DiscoveryClient</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DiscoveryClient <span class="title">discoveryClient</span><span class="params">(EurekaInstanceConfig config, EurekaClient client)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> EurekaDiscoveryClient(config, client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DiscoveryClient ，前面说到，这个类是Spring Cloud 中用于服务发现使用的客户端接口。注意这里是SpringCloud提供的接口，不是netflix中的类。</p><h4 id="EurekaServiceRegistry"><a href="#EurekaServiceRegistry" class="headerlink" title="EurekaServiceRegistry"></a>EurekaServiceRegistry</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EurekaServiceRegistry <span class="title">eurekaServiceRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> EurekaServiceRegistry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EurekaServiceRegistry 是 ServiceRegistry 的实现类。ServiceRegistry 是 SpringCloud 提供了注册和注销等方法，这些方法允许用户提供自定义注册服务。</p><h4 id="EurekaRegistration"><a href="#EurekaRegistration" class="headerlink" title="EurekaRegistration"></a>EurekaRegistration</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(AutoServiceRegistrationProperties.class)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"spring.cloud.service-registry.auto-registration.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> EurekaRegistration <span class="title">eurekaRegistration</span><span class="params">(EurekaClient eurekaClient, CloudEurekaInstanceConfig instanceConfig, ApplicationInfoManager applicationInfoManager, ObjectProvider&lt;HealthCheckHandler&gt; healthCheckHandler)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> EurekaRegistration.builder(instanceConfig)</span><br><span class="line">.with(applicationInfoManager)</span><br><span class="line">.with(eurekaClient)</span><br><span class="line">.with(healthCheckHandler)</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 ServiceRegistry 实现都有自己的 Registry 实现。</p><ul><li>ZookeeperRegistration -&gt; ZookeeperServiceRegistry</li><li>ZookeeperRegistration -&gt; EurekaServiceRegistry</li><li>ConsulRegistration       -&gt; ConsulServiceRegistry</li></ul><p>如果你需要自定义实现 ServiceRegistry ，则也不要提供一个 Registration  的实现。</p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>服务发现的基本情况在上面已经提到了，但是由于 SpingCloud 中并没有提供具体的交互操作而是由 com.netflix.discovery.DiscoveryClient 来完成具体工作。所以关于服务服务发现这里就直接围绕这个类来展开。</p><p><img src="https://oscimg.oschina.net/oscnet/a03127ebf5610a9684598a7b12faafd8582.jpg" alt="image.png"></p><h3 id="LookopService"><a href="#LookopService" class="headerlink" title="LookopService"></a>LookopService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LookupService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 根据服务实例注册的appName 来获取 Application</span></span><br><span class="line">    <span class="function">Application <span class="title">getApplication</span><span class="params">(String appName)</span></span>;</span><br><span class="line">    <span class="comment">// 返回当前注册表中所有的服务实例信息</span></span><br><span class="line">    <span class="function">Applications <span class="title">getApplications</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 根据服务实例Id获取服务实例信息</span></span><br><span class="line">    <span class="function">List&lt;InstanceInfo&gt; <span class="title">getInstancesById</span><span class="params">(String id)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个可能的服务器，以处理来自从eureka接收到的注册表信息的请求。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@virtualHostname</span> 与服务器关联的虚拟主机名。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@secure</span> 指示是HTTP还是HTTPS请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">InstanceInfo <span class="title">getNextServerFromEureka</span><span class="params">(String virtualHostname, <span class="keyword">boolean</span> secure)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LookupService 接口的作用就是用于查找活动服务实例；总共提供了四个方法，很好理解。每个方法的作用见注释。</p><h3 id="EurekaClient"><a href="#EurekaClient" class="headerlink" title="EurekaClient"></a>EurekaClient</h3><p>EurekaClient 也是一个接口，集成并且扩展了 LookupService。<br><br></p><blockquote><p>This interface does NOT try to clean up the current client interface for eureka 1.x. Rather it tries<br>to provide an easier transition path from eureka 1.x to eureka 2.x.<br>从这来看，EurekaClient 的存在是为了给 Eureka1.x 向 Eureka 2.x 升级提供容错能力。</p></blockquote><p>EurekaClient 在 LookupService 基础上扩展了很多方法，如下：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EurekaClient</span> <span class="keyword">extends</span> <span class="title">LookupService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 省去@Deprecated方法和获取服务实例信息的接口方法</span></span><br><span class="line"><span class="comment">// 注册健康检查处理器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerHealthCheck</span><span class="params">(HealthCheckHandler healthCheckHandler)</span></span>;</span><br><span class="line"><span class="comment">// 监听client服务信息的更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerEventListener</span><span class="params">(EurekaEventListener eventListener)</span></span>;</span><br><span class="line">   <span class="comment">// 取消监听</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unregisterEventListener</span><span class="params">(EurekaEventListener eventListener)</span></span>;</span><br><span class="line"> <span class="comment">// 获取当前健康检查处理器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HealthCheckHandler <span class="title">getHealthCheckHandler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 关闭 eureka 客户端。还向eureka服务器发送撤销注册请求。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// EurekaClientConfig</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EurekaClientConfig <span class="title">getEurekaClientConfig</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="comment">// ApplicationInfoManager</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationInfoManager <span class="title">getApplicationInfoManager</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>HealthCheckHandler 这个是用于检查当前客户端状态的，这个在后面心跳机制里面会说道。</p><h3 id="DiscoveryClient-1"><a href="#DiscoveryClient-1" class="headerlink" title="DiscoveryClient"></a>DiscoveryClient</h3><p>com.netflix.discovery.DiscoveryClient，这个类会在构造函数中完成一系列重要的操作，如：拉取注册表信息，服务注册，初始化心跳机制，缓存刷新，按需注册定时任务等等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DiscoveryClient(ApplicationInfoManager applicationInfoManager, </span><br><span class="line"> EurekaClientConfig config, </span><br><span class="line">                AbstractDiscoveryClientOptionalArgs args,</span><br><span class="line">                Provider&lt;BackupRegistry&gt; backupRegistryProvider) &#123;</span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>几个参数的释义如下：</p><ul><li>applicationInfoManager ：应用信息管理器</li><li>config ：client 与 server 交互的配置信息</li><li>args ：客户端提供的过滤器类型(支持jersey1和jersey2)，后面用来构建 EurekaTransport</li><li>backupRegistryProvider ： 备份注册中心</li></ul><h3 id="服务发现-1"><a href="#服务发现-1" class="headerlink" title="服务发现"></a>服务发现</h3><p>下面代码片段也是在 DiscoveryClient 的构造函数里面的，这里就是拉取注册服务信息的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(<span class="keyword">false</span>)) &#123;</span><br><span class="line">fetchRegistryFromBackup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clientConfig.shouldFetchRegistry() 这个方法拿到的就是配置文件中 eureka.client.fetch-registry 的值，默认为true，表示从 eureka server 拉取注册表信息。</p><p>fetchRegistry(boolean)是从 eureka server 拉取注册信息的方法，参数用于表示是否是强制拉取全量的注册信息；此方法除非在协调eureka服务器和客户端注册表信息方面存在问题，否则此方法只尝试在第一次进行全量获取，后面均是增量获取。</p><p>fetchRegistryFromBackup() 如果 eureka server 服务不可用，则采用的备用方案。</p><h4 id="底层通信实现-EurekaTransport"><a href="#底层通信实现-EurekaTransport" class="headerlink" title="底层通信实现 EurekaTransport"></a>底层通信实现 EurekaTransport</h4><p>EurekaTransport 是 DiscoveryClient 的内部类，EurekaTransport 封装了具体的基于 jersey 的底层通信实现。</p><h4 id="FetchRegistry"><a href="#FetchRegistry" class="headerlink" title="FetchRegistry"></a>FetchRegistry</h4><p><img src="https://oscimg.oschina.net/oscnet/9ade5582f8c167659c4d35702063518bec0.jpg" alt="image.png"><br>上图为拉取注册信息的整个过程。对于黄色贴条上的条件，如果满足其中一个，则都会进行全量拉取；否则进行增量拉取。计算 hash 值是为了后面可以与server端应用信息的进行对比，用于感知是否需要重新进行拉取操作。</p><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><p>服务注册逻辑也是在 DiscoveryClient 的构造函数中完成，代码片段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka() &amp;&amp; clientConfig.shouldEnforceRegistrationAtInit()) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!register() ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Registration error at startup. Invalid server response."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">    logger.error(<span class="string">"Registration error at startup: &#123;&#125;"</span>, th.getMessage());</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(th);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向server端注册需要满足的两个条件是：1、允许向server端注册  2、是否在客户端初始化期间强制注册<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">register</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  logger.info(PREFIX + <span class="string">"&#123;&#125;: registering service..."</span>, appPathIdentifier);</span><br><span class="line">  EurekaHttpResponse&lt;Void&gt; httpResponse;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  httpResponse = eurekaTransport.registrationClient.register(instanceInfo);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.warn(PREFIX + <span class="string">"&#123;&#125; - registration failed &#123;&#125;"</span>, appPathIdentifier, e.getMessage(), e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">  logger.info(PREFIX + <span class="string">"&#123;&#125; - registration status: &#123;&#125;"</span>, appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> httpResponse.getStatusCode() == <span class="number">204</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过 eurekaTransport 对象，基于 REST 调用向 eureka server 进行服务注册。</p><h2 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h2><p>心跳机制的初始化工作也是在 DiscoveryClient 构造函数中完成。在DiscoveryClient构造函数的最后，有一个初始化调度任务的方法，在这个方法里就包括心跳的初始化。</p><p>heartbeatExecutor 心跳线程池：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">heartbeatExecutor = new ThreadPoolExecutor(</span><br><span class="line">                    1, clientConfig.getHeartbeatExecutorThreadPoolSize(), 0, TimeUnit.SECONDS,</span><br><span class="line">                    new SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                    new ThreadFactoryBuilder()</span><br><span class="line">                            .setNameFormat(&quot;DiscoveryClient-HeartbeatExecutor-%d&quot;)</span><br><span class="line">                            .setDaemon(true)</span><br><span class="line">                            .build()</span><br></pre></td></tr></table></figure><p>scheduler 提交周期执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Heartbeat timer</span></span><br><span class="line">scheduler.schedule(</span><br><span class="line">                  <span class="keyword">new</span> TimedSupervisorTask(</span><br><span class="line">                  <span class="string">"heartbeat"</span>,</span><br><span class="line">                  scheduler,</span><br><span class="line">                  heartbeatExecutor,</span><br><span class="line">                  renewalIntervalInSecs,</span><br><span class="line">                  TimeUnit.SECONDS,</span><br><span class="line">                  expBackOffBound,</span><br><span class="line">                  <span class="keyword">new</span> HeartbeatThread()</span><br><span class="line">                  ),</span><br><span class="line">renewalIntervalInSecs, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></p><p>TimedSupervisorTask 是 eureka 中自动调节间隔的周期性任务类。HeartbeatThread 是具体执行任何的线程，run方法中执行的就是 renew() 续期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">renew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 eurekaTransport 来与 server 通信续期</span></span><br><span class="line">    httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, <span class="keyword">null</span>);</span><br><span class="line">    logger.debug(PREFIX + <span class="string">"&#123;&#125; - Heartbeat status: &#123;&#125;"</span>, appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">    <span class="comment">// 404 标识当前服务实例不存在</span></span><br><span class="line">    <span class="keyword">if</span> (httpResponse.getStatusCode() == <span class="number">404</span>) &#123;</span><br><span class="line">      <span class="comment">// 记录心跳次数</span></span><br><span class="line">      REREGISTER_COUNTER.increment();</span><br><span class="line">      logger.info(PREFIX + <span class="string">"&#123;&#125; - Re-registering apps/&#123;&#125;"</span>, appPathIdentifier, instanceInfo.getAppName());</span><br><span class="line">      <span class="keyword">long</span> timestamp = instanceInfo.setIsDirtyWithTime();</span><br><span class="line">      <span class="comment">// 重新注册</span></span><br><span class="line">      <span class="keyword">boolean</span> success = register();</span><br><span class="line">      <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      instanceInfo.unsetIsDirty(timestamp);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 200 状态正常</span></span><br><span class="line">    <span class="keyword">return</span> httpResponse.getStatusCode() == <span class="number">200</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    logger.error(PREFIX + <span class="string">"&#123;&#125; - was unable to send heartbeat!"</span>, appPathIdentifier, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务下线"><a href="#服务下线" class="headerlink" title="服务下线"></a>服务下线</h2><p>关闭 eureka client，还向 eureka server 发送撤销注册请求。该方法在DiscoveryClient#shutdown 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 保证原子操作</span></span><br><span class="line">        <span class="keyword">if</span> (isShutdown.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            logger.info(<span class="string">"Shutting down DiscoveryClient ..."</span>);</span><br><span class="line">            <span class="keyword">if</span> (statusChangeListener != <span class="keyword">null</span> &amp;&amp; applicationInfoManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 应用管理器取消状态监听</span></span><br><span class="line">                applicationInfoManager.unregisterStatusChangeListener(statusChangeListener.getId());</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 清理任务调度执行</span></span><br><span class="line">            cancelScheduledTasks();</span><br><span class="line">            <span class="comment">// If APPINFO was registered</span></span><br><span class="line">            <span class="keyword">if</span> (applicationInfoManager != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; clientConfig.shouldRegisterWithEureka()</span><br><span class="line">                    &amp;&amp; clientConfig.shouldUnregisterOnShutdown()) &#123;</span><br><span class="line">              <span class="comment">//设置服务实例状态为 DOWN</span></span><br><span class="line">                applicationInfoManager.setInstanceStatus(InstanceStatus.DOWN);</span><br><span class="line">              <span class="comment">//注销注册</span></span><br><span class="line">                unregister();</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 关闭 jersey 客户端</span></span><br><span class="line">            <span class="keyword">if</span> (eurekaTransport != <span class="keyword">null</span>) &#123;</span><br><span class="line">                eurekaTransport.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">            heartbeatStalenessMonitor.shutdown();</span><br><span class="line">            registryStalenessMonitor.shutdown();</span><br><span class="line">            logger.info(<span class="string">"Completed shut down of DiscoveryClient"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面一些 demo 中已经介绍了如何使用 SOFABoot 来集成 Spring Cloud Netflix Eureka 组件。本篇将来先解析下 Eureka Client 的工作原理。&lt;/p&gt;
&lt;h2 id=&quot;Netflix-和-SpringCloud&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="spring cloud" scheme="http://www.glmapper.com/tags/spring-cloud/"/>
    
      <category term="Eureka" scheme="http://www.glmapper.com/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-Eureka 服务发现</title>
    <link href="http://www.glmapper.com/2018/12/30/springcoud-eureka-discovery/"/>
    <id>http://www.glmapper.com/2018/12/30/springcoud-eureka-discovery/</id>
    <published>2018-12-30T16:06:53.000Z</published>
    <updated>2019-01-09T15:13:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇将继续接着上一篇 <a href="http://www.glmapper.com/2018/12/31/springcoud-eureka-register/">SpringCloud-服务注册</a> ，通过使用 DiscoveryClient 来实现服务发现，并且消费。</p><p>DiscoveryClient 源自于 spring-cloud-client-discovery ，是 spring cloud 中被定义用来服务发现的公共接口，在 spring cloud 的各类服务发现组件中，都有对应的实现，如 eureka、consul、zookeeper 。它提供从服务注册中心获取服务实例信息的能力。如果我们想自己实现一个服务发现组件，集成到spring cloud 中，就完全可以通过实现此接口来完成。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK<br></td><td>1.8.0_162<br></td></tr><tr><td>SOFABoot/SpringBoot<br></td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE<br></td></tr><tr><td>SpringCloud<br></td><td>Finchley.RC1<br></td></tr><tr><td>IDE<br></td><td>IDEA<br></td></tr></tbody></table><h2 id="工程背景"><a href="#工程背景" class="headerlink" title="工程背景"></a>工程背景</h2><p>本案例使用 SOFABoot 3.0.x 版本集成 SringCloud F版。工程如下：</p><ul><li>sofa-eureka-consumer-discovery     服务消费方</li></ul><p>本工程的父工程继续使用《SpringCloud-Eureka 服务注册》文中新建的父工程。</p><h2 id="新建-sofa-eureka-consumer-discovery"><a href="#新建-sofa-eureka-consumer-discovery" class="headerlink" title="新建 sofa-eureka-consumer-discovery"></a>新建 sofa-eureka-consumer-discovery</h2><p>这里我们通过 sofa-eureka-consumer-discovery 这个工程来手动发现服务。</p><p>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p><ul><li>artifactId：sofa-eureka-consumer-discovery。</li></ul><h3 id="修改-pom-文件"><a href="#修改-pom-文件" class="headerlink" title="修改 pom 文件"></a>修改 pom 文件</h3><p>引入 spring-cloud-starter-netflix-eureka-client 依赖。<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-consumer-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.port=8088</span><br><span class="line">spring.application.name=sofa-eureka-discovery</span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/</span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaEurekaConsumerDiscoveryApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaEurekaConsumerDiscoveryApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务获取"><a href="#服务获取" class="headerlink" title="服务获取"></a>服务获取</h3><p>这里通过 DiscoveryClient 对像手动获取到 HELLOSOFASERVICE 服务对应的所有实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscoveryController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/instance"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(<span class="string">"HELLOSOFASERVICE"</span>);</span><br><span class="line">        System.out.println(<span class="string">"current service size = "</span> + discoveryClient.getServices().size());</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>( String s :  discoveryClient.getServices())&#123;</span><br><span class="line">            stringBuilder.append(<span class="string">"services="</span> + s).append(<span class="string">"\n"</span>);</span><br><span class="line">            List&lt;ServiceInstance&gt; serviceInstances =  discoveryClient.getInstances(s);</span><br><span class="line">            <span class="keyword">for</span>(ServiceInstance si : serviceInstances)&#123;</span><br><span class="line">                stringBuilder.append(<span class="string">"url="</span>).append(si.getUri()).append(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuilder.append(<span class="string">"instance num"</span>).append(<span class="string">"="</span>).append(list.size());</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动-amp-验证"><a href="#启动-amp-验证" class="headerlink" title="启动 &amp; 验证"></a>启动 &amp; 验证</h3><p>启动当前工程，在此之前确保 注册中心和服务提供工程均已正常启动。然后在浏览器中输入：http:localhost:8088/instance</p><p><img src="https://oscimg.oschina.net/oscnet/1f7ea4c0b3f4e1eaccc37a5cc3baba5d47e.jpg" alt="image.png"></p><p>可以看到获取到的实例信息与注册中心上的实例信息是匹配的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇将继续接着上一篇 &lt;a href=&quot;http://www.glmapper.com/2018/12/31/springcoud-eureka-register/&quot;&gt;SpringCloud-服务注册&lt;/a&gt; ，通过使用 DiscoveryClient 来实现服务发现，并且
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="spring cloud" scheme="http://www.glmapper.com/tags/spring-cloud/"/>
    
      <category term="Eureka" scheme="http://www.glmapper.com/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-Eureka 服务注册</title>
    <link href="http://www.glmapper.com/2018/12/30/springcoud-eureka-register/"/>
    <id>http://www.glmapper.com/2018/12/30/springcoud-eureka-register/</id>
    <published>2018-12-30T16:05:40.000Z</published>
    <updated>2019-01-09T15:04:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spring Cloud Netflix Eureka 是 Spring Cloud 提供的用于服务注册和发现的基础组件，在 Spring Cloud 微服务体系中承担着相当重要的角色。Eureka 作为一个开箱即用的基础组件，其屏蔽了底层 Client 和 Server 交互的细节，使得开发者能够快速入手，将更多的精力投入到业务逻辑上去。</p><p>Eureka 是基于 Rest 实现的，及底层客户端和服务端之间的交互是通过 Rest 服务进行交互的。Eureka 包括两个部分，即服务端可客户端。</p><ul><li>服务端：Eureka Server ,提供服务注册和发现的功能</li><li>客户端：Eureka Client ,将自己的信息注册到 Eureka Server ，并从 Eureka Server 中发现其他服务。</li></ul><p>Eureka 本篇将先来搭建一个服务端，以作为后续篇幅的注册中心来使用。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>类别</th><th>值</th></tr></thead><tbody><tr><td>JDK<br></td><td>1.8.0_162<br></td></tr><tr><td>SOFABoot/SpringBoot<br></td><td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE<br></td></tr><tr><td>SpringCloud<br></td><td>Finchley.RC1<br></td></tr><tr><td>IDE<br></td><td>IDEA<br></td></tr></tbody></table><h2 id="工程背景"><a href="#工程背景" class="headerlink" title="工程背景"></a>工程背景</h2><p>本案例使用 SOFABoot 3.0.x 版本集成 SringCloud F版。工程如下：</p><ul><li>sofa-eureka-server         服务注册中心</li><li>sofa-eureka-provider      服务提供方</li><li>sofa-eureka-comsumer   服务消费方</li></ul><p>本工程都是在同一个父工程下面的，因此工程构建开始会新建一个 SOFABoot 工程作为父工程。</p><h2 id="新建父工程"><a href="#新建父工程" class="headerlink" title="新建父工程"></a>新建父工程</h2><p>这里父工程直接新建一个SpringBoot 工程。可以使用 IDEA 的生成，也可以通过 <a href="http://www.sofastack.tech/sofa-boot/docs/QuickStart" target="_blank" rel="noopener">SOFABoot 快速开始</a> 新建一个 SpringBoot 工程，删除 src 目录，然后修改 pom.xml 文件。</p><ul><li>gourpId : com.alipay.sofa</li><li>artifactId : sofa-eureka-parent</li></ul><h3 id="parent-依赖修改"><a href="#parent-依赖修改" class="headerlink" title="parent 依赖修改"></a><strong>parent 依赖修改</strong></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofaboot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="管控-SpringCloud-依赖"><a href="#管控-SpringCloud-依赖" class="headerlink" title="管控 SpringCloud 依赖"></a>管控 SpringCloud 依赖</h3><p>在主 pom 里面加入 SpringCloud 的依赖管控。版本为 Finchley.RC1<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.RC1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="配置-SpringCloud-仓库"><a href="#配置-SpringCloud-仓库" class="headerlink" title="配置 SpringCloud 仓库"></a>配置 SpringCloud 仓库</h3><p>在主pom.xml 中添加如下配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Milestones<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>OK，到这里，父工程创建完毕。</p><h2 id="新建-sofa-eureka-server-center"><a href="#新建-sofa-eureka-server-center" class="headerlink" title="新建 sofa-eureka-server-center"></a>新建 sofa-eureka-server-center</h2><p>sofa-eureka-server-center 作为注册中心的服务端。</p><p>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p><ul><li>artifactId：sofa-eureka-server-center。</li></ul><h3 id="pom-文件修改"><a href="#pom-文件修改" class="headerlink" title="pom 文件修改"></a>pom 文件修改</h3><p>引入 spring-cloud-starter-netflix-eureka-server 依赖，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-server-center<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="新建资源文件-application-yml"><a href="#新建资源文件-application-yml" class="headerlink" title="新建资源文件 application.yml"></a>新建资源文件 application.yml</h3><p>在 /src/main/resources 目录下新建 application.yml 或者 application.properties。这里以.yml文件为例：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span>    <span class="comment">#指定服务端口</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">sofa-eureka-server</span></span><br></pre></td></tr></table></figure></p><blockquote><p>配置文件后面统一说明</p></blockquote><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>在 /src/main/resources 目录下新建 com.alipay.sofa.cloud 包目录，并且在当前包路劲下新建 SofaEurekaServerApplication 类，并且类上加上 @EnableEurekaServer 注解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaEurekaServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaEurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="启动程序-amp-验证"><a href="#启动程序-amp-验证" class="headerlink" title="启动程序 &amp; 验证"></a>启动程序 &amp; 验证</h3><p>启动当前应用。并且浏览器中输入：<a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a></p><p><img src="https://oscimg.oschina.net/oscnet/e46c56c9b7d431b2dc113e479255fa3eff7.jpg" alt="image.png"></p><p>服务正常运行，界面如上图所示；此时还没有服务注册进来，因此红色框内显示 ：No instances available</p><h2 id="新建-sofa-eureka-provider"><a href="#新建-sofa-eureka-provider" class="headerlink" title="新建 sofa-eureka-provider"></a>新建 sofa-eureka-provider</h2><p>sofa-eureka-provider 作为服务提供方，将会向注册中心 sofa-eureka-server-center 上注册服务。</p><p>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p><ul><li>artifactId：sofa-eureka-provider。</li></ul><h3 id="pom-文件修改-1"><a href="#pom-文件修改-1" class="headerlink" title="pom 文件修改"></a>pom 文件修改</h3><p>引入 spring-cloud-starter-netflix-eureka-client 和 spring-boot-starter-web 依赖，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="新建资源文件"><a href="#新建资源文件" class="headerlink" title="新建资源文件"></a>新建资源文件</h3><p>在 /src/main/resources 目录下新建 application.yml 或者 application.properties。这里以.yml文件为例：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span>  <span class="comment">#指定注册中心地址</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">HelloSOFAService</span>   <span class="comment">#服务名称</span></span><br></pre></td></tr></table></figure></p><h3 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h3><p>在 /src/main/resources 目录下新建 com.alipay.sofa.cloud 包目录，并且在当前包路劲下新建 SofaEurekaProviderApplication 类，并且类上加上 @EnableEurekaClient 注解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaEurekaProviderApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaEurekaProviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="服务提供类"><a href="#服务提供类" class="headerlink" title="服务提供类"></a>服务提供类</h3><p>这里在  com.alipay.sofa.cloud.controller 包下新建 SofaController 类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.application.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String hostname;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello SOFA! Now Port is "</span>+port +<span class="string">" And hostname is "</span> +hostname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里在接口中返回 hostname 和 port ，方便后面验证负载均衡测试使用。</p><h3 id="启动程序-amp-验证-1"><a href="#启动程序-amp-验证-1" class="headerlink" title="启动程序 &amp; 验证"></a>启动程序 &amp; 验证</h3><p>在启动 sofa-eureka-provider 之前，需要先启动 sofa-wureka-server-center 。两个都启动成功之后，浏览器输入：<a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a> </p><p><img src="https://oscimg.oschina.net/oscnet/18b13b668adc275175ae8d6bacab52895e4.jpg" alt="image1.png"></p><p>此时我将 sofa-eureka-provider 中的配置文件的端口修改为 8081，再注册一个。</p><p><img src="https://oscimg.oschina.net/oscnet/d7a8333f1eabcb09b7a38f56aec860e56f4.jpg" alt="image2.png"></p><p>可以看到 服务为 HELLOSOFASERVICE 的有两个服务提供方。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Spring Cloud Netflix Eureka 是 Spring Cloud 提供的用于服务注册和发现的基础组件，在 Spring 
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="spring cloud" scheme="http://www.glmapper.com/tags/spring-cloud/"/>
    
      <category term="Eureka" scheme="http://www.glmapper.com/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud 总览</title>
    <link href="http://www.glmapper.com/2018/12/30/springcloud-overview/"/>
    <id>http://www.glmapper.com/2018/12/30/springcloud-overview/</id>
    <published>2018-12-30T16:00:15.000Z</published>
    <updated>2018-12-30T16:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列基于Spring Cloud <strong>Finchley SR2 &amp; SpringBoot 2.0.7.</strong>RELEASE</p></blockquote><p>Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性令牌、全局锁、leader选举、分布式session、集群状态）。分布式系统的协调导致了样板模式, 使用 Spring Cloud 开发人员可以快速地支持实现这些模式的服务和应用程序。它们可以在任何分布式环境中很好地工作，包括开发人员自己的笔记本电脑，裸机数据中心，以及Cloud Foundry等托管平台。</p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><hr><p>Spring Cloud专注于为典型用例提供良好的开箱即用体验，并为其他用户提供可扩展性机制。</p><ul><li>Distributed/versioned configuration       分布式/版本化配置</li><li>Service registration and discovery         服务注册和发现</li><li>Routing                                                  智能路由</li><li>Service-to-service calls                         service-to-service调用</li><li>Load balancing                                       负载均衡</li><li>Circuit Breakers                                      断路器</li><li>Global locks                                            全局锁</li><li>Leadership election and cluster state     leader选举和集群状态管理</li><li>Distributed messaging                            分布式消息</li></ul><h2 id="主要项目"><a href="#主要项目" class="headerlink" title="主要项目"></a>主要项目</h2><hr><table><thead><tr><th>项目名称<br></th><th>项目职能<br></th></tr></thead><tbody><tr><td>Spring Cloud Config<br></td><td>Spring Cloud 提供的分布式配置中心，为外部配置提供了客户端和服务端的支持。<br></td></tr><tr><td>Spring Cloud Netflix<br></td><td>与各种Netflix OSS组件集成（Eureka，Hystrix，Zuul，Archaius等）。<br></td></tr><tr><td>Spring Cloud Bus<br></td><td>用于将服务和服务实例与分布式消息传递连接在一起的事件总线。用于跨群集传播状态更改（例如，配置更改事件）。<br></td></tr><tr><td>Spring Cloud Cloudfoundry<br></td><td>提供应用程序与 Pivotal Cloud Foundry 集成。提供服务发现实现，还可以轻松实现受SSO和OAuth2保护的资源。<br></td></tr><tr><td>Spring Cloud Open Service Broker<br></td><td>为构建实现 Open service broker API 的服务代理提供了一个起点。    <br></td></tr><tr><td>Spring Cloud Cluster<br></td><td>提供Leadership选举，如：Zookeeper, Redis, Hazelcast, Consul等常见状态模式的抽象和实现。<br></td></tr><tr><td>Spring Cloud Consul<br></td><td>封装了Consul操作，consul 是一个服务发现与配置工具，与Docker容器可以无缝集成。<br></td></tr><tr><td>Spring Cloud Security<br></td><td>基于spring security的安全工具包，为你的应用程序添加安全控制。在Zuul代理中为负载平衡的OAuth2 rest客户端和身份验证头中继提供支持。<br></td></tr><tr><td>Spring Cloud Sleuth<br></td><td>Spring Cloud 提供的分布式链路跟踪组件，兼容zipkin、HTracer和基于日志的跟踪（ELK）<br></td></tr><tr><td>Spring Cloud Data Flow<br></td><td>大数据操作工具，作为Spring XD的替代产品，它是一个混合计算模型，结合了流数据与批量数据的处理方式。<br></td></tr><tr><td>Spring Cloud Stream<br></td><td>数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。<br></td></tr><tr><td>Spring Cloud CLI<br></td><td>基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。<br></td></tr><tr><td>Spring Cloud OpenFeign<br></td><td>一个http client客户端，致力于减少http client客户端构建的复杂性。<br></td></tr><tr><td>Spring Cloud Gateway<br></td><td>Spring Cloud 提供的网关服务组件<br></td></tr><tr><td>Spring Cloud Stream App Starters<br></td><td>Spring Cloud Stream App Starters是基于Spring Boot的Spring 集成应用程序，可提供与外部系统的集成。<br></td></tr><tr><td>Spring Cloud Task</td><td>提供云端计划任务管理、任务调度。<br></td></tr><tr><td>Spring Cloud Task App Starters<br></td><td>Spring Cloud任务应用程序启动器是SpringBoot应用程序，它可以是任何进程，包括不会永远运行的Spring批处理作业，并且在有限的数据处理周期后结束/停止。<br></td></tr><tr><td>Spring Cloud Zookeeper<br></td><td>操作Zookeeper的工具包，用于使用zookeeper方式的服务发现和配置管理。<br></td></tr><tr><td>Spring Cloud AWS<br></td><td>提供与托管的AWS集成<br></td></tr><tr><td>Spring Cloud Connectors<br></td><td>便于云端应用程序在各种PaaS平台连接到后端，如：数据库和消息代理服务。<br></td></tr><tr><td>Spring Cloud Starters<br></td><td>Spring Boot式的启动项目，为Spring Cloud提供开箱即用的依赖管理。<br></td></tr><tr><td>Spring Cloud Contract<br></td><td>Spring Cloud Contract是一个总体项目，其中包含帮助用户成功实施消费者驱动合同方法的解决方案。<br></td></tr><tr><td>Spring Cloud Pipelines<br></td><td>Spring Cloud Pipelines提供了一个固定意见的部署管道，其中包含确保您的应用程序可以零停机方式部署并轻松回滚出错的步骤。<br></td></tr><tr><td>Spring Cloud Function<br></td><td>Spring Cloud Function通过函数促进业务逻辑的实现。 它支持Serverless 提供商之间的统一编程模型，以及独立运行（本地或PaaS）的能力。<br></td></tr></tbody></table><h2 id="SpringCloud-与-SpringBoot-版本兼容关系"><a href="#SpringCloud-与-SpringBoot-版本兼容关系" class="headerlink" title="SpringCloud 与 SpringBoot 版本兼容关系"></a>SpringCloud 与 SpringBoot 版本兼容关系</h2><table><thead><tr><th>Release Train</th><th>Boot Version</th></tr></thead><tbody><tr><td>Greenwich<br></td><td>2.1.x<br></td></tr><tr><td>Finchley<br></td><td>2.0.x<br></td></tr><tr><td>Edgware<br></td><td>1.5.x<br></td></tr><tr><td>Dalston<br></td><td>1.5.x<br></td></tr></tbody></table><h2 id="SpringCloud-与子工程版本关系"><a href="#SpringCloud-与子工程版本关系" class="headerlink" title="SpringCloud 与子工程版本关系"></a>SpringCloud 与子工程版本关系</h2><table><thead><tr><th>Component</th><th>Edgware.SR5</th><th>Finchley.SR2</th><th>Finchley.BUILD-SNAPSHOT</th></tr></thead><tbody><tr><td>spring-cloud-aws<br></td><td>1.2.3.RELEASE<br></td><td>2.0.1.RELEASE<br></td><td>2.0.1.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-bus<br></td><td>1.3.3.RELEASE<br></td><td>2.0.0.RELEASE<br></td><td>2.0.1.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-cli<br></td><td>1.4.1.RELEASE<br></td><td>2.0.0.RELEASE<br></td><td>2.0.1.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-commons<br></td><td>1.3.5.RELEASE<br></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-contract<br></td><td>1.2.6.RELEASE<br></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-config<br></td><td>1.4.5.RELEASE<br></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-netflix<br></td><td>1.4.6.RELEASE<br></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-security<br></td><td>1.2.3.RELEASE<br></td><td>2.0.1.RELEASE<br></td><td>2.0.1.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-cloudfoundry<br></td><td>1.1.2.RELEASE<br></td><td>2.0.1.RELEASE<br></td><td>2.0.1.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-consul<br></td><td>1.3.5.RELEASE<br></td><td>2.0.1.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-sleuth<br></td><td>1.3.5.RELEASE<br></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-stream<br></td><td>Ditmars.SR4<br></td><td>Elmhurst.SR1<br></td><td>Elmhurst.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-zookeeper<br></td><td>1.2.2.RELEASE<br></td><td>2.0.0.RELEASE<br></td><td>2.0.1.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-boot<br></td><td>1.5.16.RELEASE<br></td><td>2.0.6.RELEASE<br></td><td>2.0.7.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-task<br></td><td>1.2.3.RELEASE<br></td><td>2.0.0.RELEASE<br></td><td>2.0.1.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-vault<br></td><td>1.1.2.RELEASE<br></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-gateway<br></td><td>1.0.2.RELEASE<br></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-openfeign<br></td><td></td><td>2.0.2.RELEASE<br></td><td>2.0.2.BUILD-SNAPSHOT<br></td></tr><tr><td>spring-cloud-function<br></td><td>1.0.1.RELEASE<br></td><td>1.0.0.RELEASE<br></td><td>1.0.1.BUILD-SNAPSHOT<br></td></tr></tbody></table><ul><li>Finchley 构建并使用Spring Boot 2.0.x，与 Spring Boot 1.5.x 不兼容。</li><li>Dalston 和 Edgware 基于 Spring Boot 1.5.x 构建，不兼容 SpringBoot 2.0.x </li><li>Camden 版本迭代正式结束，Dalston 将于2018年12月结束使用，Edgware 将遵循 Spring Boot 1.5.x 的生命周期结束。</li><li>Camden 基于SpringBoot 1.4.x 构建，但是也会支持 1.5.x 版本</li><li>Brixton 和 Angel 迭代结束时间是2017年7月，Brixton 基于SpringBoot 1.3.x ，同时也支持 1.4.x 版本</li><li>Angel 基于 SpringBoot 1.2.x ,在某些方式不兼容 SpringBoot 1.3.x 。</li><li>Brixton 构建在SpringBoot 1.3.x ，不兼容 SpringBoot 1.2.x 。一些基于Angel的库和大多数应用程序可以在Brixton上正常运行，但如果OAuth2具备spring-cloud-security 1.0的特性，则需要在任何地方进行更改。x被使用(它们大多在1.3.0中被移到Spring Boot中)。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列基于Spring Cloud &lt;strong&gt;Finchley SR2 &amp;amp; SpringBoot 2.0.7.&lt;/strong&gt;RELEASE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Spring Cloud 为开发人员提供了快速构
      
    
    </summary>
    
      <category term="spring cloud" scheme="http://www.glmapper.com/categories/spring-cloud/"/>
    
    
      <category term="spring cloud" scheme="http://www.glmapper.com/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringSession系列-sessionId解析和Cookie读写策略</title>
    <link href="http://www.glmapper.com/2018/12/22/springsession-id-resolver/"/>
    <id>http://www.glmapper.com/2018/12/22/springsession-id-resolver/</id>
    <published>2018-12-22T16:10:59.000Z</published>
    <updated>2018-12-22T17:18:53.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>首先需求在这里说明下，SpringSession的版本迭代的过程中肯定会伴随着一些类的移除和一些类的加入，目前本系列使用的版本是github上对象的master的代码流版本。如果有同学对其他版本中的一些类或者处理有疑惑，欢迎交流。</p></blockquote><p>本篇将来介绍下<code>SpringSession</code>中两种<code>sessionId</code>解析的策略，这个在之前的文章中其实是有提到过的，这里再拿出来和<code>SpringSession</code>中<code>Cookie</code>相关策略一起学习下。</p><h1 id="sessionId-解析策略"><a href="#sessionId-解析策略" class="headerlink" title="sessionId 解析策略"></a>sessionId 解析策略</h1><p><code>SpringSession</code>中对于<code>sessionId</code>的解析相关的策略是通过<code>HttpSessionIdResolver</code>这个接口来体现的。<code>HttpSessionIdResolver</code>有两个实现类：<br><img src="https://img-blog.csdnimg.cn/20181216224001789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzI1NTE4MzQ5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这两个类就分别对应<code>SpringSession</code>解析<code>sessionId</code>的两种不同的实现策略。再深入了解不同策略的实现细节之前，先来看下<code>HttpSessionIdResolver</code>接口定义的一些行为有哪些。</p><h2 id="HttpSessionIdResolver"><a href="#HttpSessionIdResolver" class="headerlink" title="HttpSessionIdResolver"></a>HttpSessionIdResolver</h2><p><code>HttpSessionIdResolver</code>定义了<code>sessionId</code>解析策略的契约（<code>Contract</code>）。允许通过请求解析sessionId，并通过响应发送sessionId或终止会话。接口定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpSessionIdResolver</span> </span>&#123;</span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">resolveSessionIds</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSessionId</span><span class="params">(HttpServletRequest request, HttpServletResponse response,String sessionId)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">expireSession</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>HttpSessionIdResolver</code>中有三个方法：</p><ul><li><code>resolveSessionIds</code>：解析与当前请求相关联的<code>sessionId</code>。<code>sessionId</code>可能来自<code>Cookie</code>或请求头。</li><li><code>setSessionId</code>：将给定的<code>sessionId</code>发送给客户端。这个方法是在创建一个新<code>session</code>时被调用，并告知客户端新<code>sessionId</code>是什么。</li><li><code>expireSession</code>：指示客户端结束当前<code>session</code>。当<code>session</code>无效时调用此方法，并应通知客户端<code>sessionId</code>不再有效。比如，它可能删除一个包含<code>sessionId</code>的<code>Cookie</code>，或者设置一个<code>HTTP</code>响应头，其值为空就表示客户端不再提交<code>sessionId</code>。</li></ul><p>下面就针对上面提到的两种策略来进行详细的分析。</p><h2 id="基于Cookie解析sessionId"><a href="#基于Cookie解析sessionId" class="headerlink" title="基于Cookie解析sessionId"></a>基于Cookie解析sessionId</h2><p>这种策略对应的实现类是<code>CookieHttpSessionIdResolver</code>，通过从<code>Cookie</code>中获取<code>session</code>；具体来说，这个实现将允许使用<code>CookieHttpSessionIdResolver#setCookieSerializer(CookieSerializer)</code>指定<code>Cookie</code>序列化策略。默认的<code>Cookie</code>名称是“<code>SESSION</code>”。创建一个<code>session</code>时，<code>HTTP</code>响应中将会携带一个指定 <code>Cookie name</code>且<code>value</code>是<code>sessionId</code>的<code>Cookie</code>。<code>Cookie</code> 将被标记为一个 <code>session cookie</code>，<code>Cookie</code> 的 <code>domain path</code> 使用 <code>context path</code>，且被标记为<code>HttpOnly</code>，如果<code>HttpServletRequest#isSecure()</code>返回<code>true</code>，那么<code>Cookie</code>将标记为安全的。如下：</p><blockquote><p>关于<code>Cookie</code>，可以参考：<a href="http://www.glmapper.com/2018/11/10/sessionone/">聊一聊session和cookie</a>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Set-Cookie: SESSION=f81d4fae-7dec-11d0-a765-00a0c91e6bf6; Path=/context-root; Secure; HttpOnly</span><br></pre></td></tr></table></figure><p>这个时候，客户端应该通过在每个请求中指定相同的<code>Cookie</code>来包含<code>session</code>信息。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /messages/ HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Cookie: SESSION=f81d4fae-7dec-11d0-a765-00a0c91e6bf6</span><br></pre></td></tr></table></figure></p><p>当会话无效时，服务器将发送过期的<code>HTTP</code>响应<code>Cookie</code>，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Set-Cookie: SESSION=f81d4fae-7dec-11d0-a765-00a0c91e6bf6; Expires=Thur, 1 Jan 1970 00:00:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure><p><code>CookieHttpSessionIdResolver</code> 类的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieHttpSessionIdResolver</span> <span class="keyword">implements</span> <span class="title">HttpSessionIdResolver</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WRITTEN_SESSION_ID_ATTR = CookieHttpSessionIdResolver.class</span><br><span class="line">.getName().concat(<span class="string">".WRITTEN_SESSION_ID_ATTR"</span>);</span><br><span class="line"><span class="comment">// Cookie序列化策略，默认是 DefaultCookieSerializer</span></span><br><span class="line"><span class="keyword">private</span> CookieSerializer cookieSerializer = <span class="keyword">new</span> DefaultCookieSerializer();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">resolveSessionIds</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据提供的cookieSerializer从请求中获取sessionId</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.cookieSerializer.readCookieValues(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSessionId</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">String sessionId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sessionId.equals(request.getAttribute(WRITTEN_SESSION_ID_ATTR))) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">request.setAttribute(WRITTEN_SESSION_ID_ATTR, sessionId);</span><br><span class="line"><span class="comment">// 根据提供的cookieSerializer将sessionId回写到cookie中</span></span><br><span class="line"><span class="keyword">this</span>.cookieSerializer</span><br><span class="line">.writeCookieValue(<span class="keyword">new</span> CookieValue(request, response, sessionId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireSession</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 这里因为是过期，所以回写的sessionId的值是“”，当请求下次进来时，就会取不到sessionId，也就意味着当前会话失效了</span></span><br><span class="line"><span class="keyword">this</span>.cookieSerializer.writeCookieValue(<span class="keyword">new</span> CookieValue(request, response, <span class="string">""</span>));</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 指定Cookie序列化的方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCookieSerializer</span><span class="params">(CookieSerializer cookieSerializer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cookieSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"cookieSerializer cannot be null"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.cookieSerializer = cookieSerializer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里可以看到<code>CookieHttpSessionIdResolver</code> 中的读取操作都是围绕<code>CookieSerializer</code>来完成的。<code>CookieSerializer</code> 是<code>SpringSession</code>中对于<code>Cookie</code>操作提供的一种机制。下面细说。</p><h2 id="基于请求头解析sessionId"><a href="#基于请求头解析sessionId" class="headerlink" title="基于请求头解析sessionId"></a>基于请求头解析sessionId</h2><p>这种策略对应的实现类是<code>HeaderHttpSessionIdResolver</code>，通过从请求头<code>header</code>中解析出<code>sessionId</code>。具体地说，这个实现将允许使用<code>HeaderHttpSessionIdResolver(String)</code>来指定头名称。还可以使用便利的工厂方法来创建使用公共头名称(例如<code>“X-Auth-Token”</code>和<code>“authenticing-info”</code>)的实例。创建会话时，<code>HTTP</code>响应将具有指定名称和<code>sessionId</code>值的响应头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用X-Auth-Token作为headerName</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeaderHttpSessionIdResolver <span class="title">xAuthToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HeaderHttpSessionIdResolver(HEADER_X_AUTH_TOKEN);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用Authentication-Info作为headerName</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeaderHttpSessionIdResolver <span class="title">authenticationInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HeaderHttpSessionIdResolver(HEADER_AUTHENTICATION_INFO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HeaderHttpSessionIdResolver</code>在处理<code>sessionId</code>上相比较于<code>CookieHttpSessionIdResolver</code>来说简单很多。就是围绕<code>request.getHeader(String)</code>和<code>request.setHeader(String,String)</code><br>两个方法来玩的。</p><p><code>HeaderHttpSessionIdResolver</code>这种策略通常会在无线端来使用，以弥补对于无<code>Cookie</code>场景的支持。</p><h1 id="Cookie-序列化策略"><a href="#Cookie-序列化策略" class="headerlink" title="Cookie 序列化策略"></a>Cookie 序列化策略</h1><p>基于<code>Cookie</code>解析<code>sessionId</code>的实现类<code>CookieHttpSessionIdResolver</code> 中实际对于<code>Cookie</code>的读写操作都是通过<code>CookieSerializer</code>来完成的。<code>SpringSession</code> 提供了<code>CookieSerializer</code>接口的默认实现<code>DefaultCookieSerializer</code>，当然在实际应用中，我们也可以自己实现这个接口，然后通过<code>CookieHttpSessionIdResolver#setCookieSerializer(CookieSerializer)</code>方法来指定我们自己的实现方式。</p><blockquote><p>PS：不得不说，强大的用户扩展能力真的是<code>Spring</code>家族的优良家风。</p></blockquote><p>篇幅有限，这里就只看下两个点：</p><ul><li><code>CookieValue</code> 存在的意义是什么</li><li><code>DefaultCookieSerializer</code>回写<code>Cookie</code>的的具体实现，读<code>Cookie</code>在 <a href="http://www.glmapper.com/2018/11/24/springsessiontwo/">SpringSession系列-请求与响应重写</a> 这篇文章中有介绍过，这里不再赘述。</li><li>jvm_router的处理</li></ul><h2 id="CookieValue"><a href="#CookieValue" class="headerlink" title="CookieValue"></a>CookieValue</h2><p><code>CookieValue</code>是<code>CookieSerializer</code>中的内部类，封装了向<code>HttpServletResponse</code>写入所需的所有信息。其实<code>CookieValue</code>的存在并没有什么特殊的意义，个人觉得作者一开始只是想通过<code>CookieValue</code>的封装来简化回写<code>cookie</code>链路中的参数传递的问题，但是实际上貌似并没有什么减少多少工作量。</p><h2 id="Cookie-回写"><a href="#Cookie-回写" class="headerlink" title="Cookie 回写"></a>Cookie 回写</h2><p><code>Cookie</code> 回写我觉得对于分布式<code>session</code>的实现来说是必不可少的；基于标准<code>servlet</code>实现的<code>HttpSession</code>，我们在使用时实际上是不用关心回写<code>cookie</code>这个事情的，因为<code>servlet</code>容器都已经做了。但是对于分布式<code>session</code>来说，由于重写了<code>response</code>，所以需要在返回<code>response</code>时需要将当前<code>session</code>信息通过<code>cookie</code>的方式塞到<code>response</code>中返回给客户端-这就是<code>Cookie</code>回写。下面是<code>DefaultCookieSerializer</code>中回写<code>Cookie</code>的逻辑，细节在代码中通过注释标注出来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeCookieValue</span><span class="params">(CookieValue cookieValue)</span> </span>&#123;</span><br><span class="line">HttpServletRequest request = cookieValue.getRequest();</span><br><span class="line">HttpServletResponse response = cookieValue.getResponse();</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.append(<span class="keyword">this</span>.cookieName).append(<span class="string">'='</span>);</span><br><span class="line">String value = getValue(cookieValue);</span><br><span class="line"><span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">validateValue(value);</span><br><span class="line">sb.append(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxAge = getMaxAge(cookieValue);</span><br><span class="line"><span class="keyword">if</span> (maxAge &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">sb.append(<span class="string">"; Max-Age="</span>).append(cookieValue.getCookieMaxAge());</span><br><span class="line">OffsetDateTime expires = (maxAge != <span class="number">0</span>)</span><br><span class="line">? OffsetDateTime.now().plusSeconds(maxAge)</span><br><span class="line">: Instant.EPOCH.atOffset(ZoneOffset.UTC);</span><br><span class="line">sb.append(<span class="string">"; Expires="</span>)</span><br><span class="line">.append(expires.format(DateTimeFormatter.RFC_1123_DATE_TIME));</span><br><span class="line">&#125;</span><br><span class="line">String domain = getDomainName(request);</span><br><span class="line"><span class="keyword">if</span> (domain != <span class="keyword">null</span> &amp;&amp; domain.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">validateDomain(domain);</span><br><span class="line">sb.append(<span class="string">"; Domain="</span>).append(domain);</span><br><span class="line">&#125;</span><br><span class="line">String path = getCookiePath(request);</span><br><span class="line"><span class="keyword">if</span> (path != <span class="keyword">null</span> &amp;&amp; path.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">validatePath(path);</span><br><span class="line">sb.append(<span class="string">"; Path="</span>).append(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isSecureCookie(request)) &#123;</span><br><span class="line">sb.append(<span class="string">"; Secure"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.useHttpOnlyCookie) &#123;</span><br><span class="line">sb.append(<span class="string">"; HttpOnly"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.sameSite != <span class="keyword">null</span>) &#123;</span><br><span class="line">sb.append(<span class="string">"; SameSite="</span>).append(<span class="keyword">this</span>.sameSite);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response.addHeader(<span class="string">"Set-Cookie"</span>, sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这上面就是拼凑字符串，然后塞到Header里面去，最终再浏览器中显示大体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: SESSION=f81d4fae-7dec-11d0-a765-00a0c91e6bf6; Path=/context-root; Secure; HttpOnly</span><br></pre></td></tr></table></figure><h2 id="jvm-router的处理"><a href="#jvm-router的处理" class="headerlink" title="jvm_router的处理"></a>jvm_router的处理</h2><p>在<code>Cookie</code>的读写代码中都涉及到对于<code>jvmRoute</code>这个属性的判断及对应的处理逻辑。</p><p>1、读取<code>Cookie</code>中的代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.jvmRoute != <span class="keyword">null</span> &amp;&amp; sessionId.endsWith(<span class="keyword">this</span>.jvmRoute)) &#123;</span><br><span class="line">sessionId = sessionId.substring(<span class="number">0</span>,</span><br><span class="line">sessionId.length() - <span class="keyword">this</span>.jvmRoute.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、回写<code>Cookie</code>中的代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.jvmRoute != <span class="keyword">null</span>) &#123;</span><br><span class="line">actualCookieValue = requestedCookieValue + <span class="keyword">this</span>.jvmRoute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>jvm_route</code>是<code>Nginx</code>中的一个模块，其作用是通过<code>session cookie</code>的方式来获取<code>session</code>粘性。如果在<code>cookie</code>和<code>url</code>中并没有<code>session</code>，则这只是个简单的 <code>round-robin</code> 负载均衡。其具体过程分为以下几步：</p><ul><li>1.第一个请求过来，没有带<code>session</code>信息，<code>jvm_route</code>就根据<code>round robin</code>策略发到一台<code>tomcat</code>上面。</li><li>2.<code>tomcat</code>添加上 <code>session</code> 信息，并返回给客户。</li><li>3.用户再次请求，<code>jvm_route</code>看到<code>session</code>中有后端服务器的名称，它就把请求转到对应的服务器上。</li></ul><p>从本质上来说，<code>jvm_route</code>也是解决<code>session</code>共享的一种解决方式。这种和 <a href="http://www.glmapper.com/2018/11/24/springsessionthree/">SpringSession系列-分布式Session实现方案</a> 中提到的基于<code>IP-HASH</code>的方式有点类似。那么同样，这里存在的问题是无法解决宕机后<code>session</code>数据转移的问题，既宕机就丢失。</p><p><code>DefaultCookieSerializer</code> 中除了<code>Cookie</code>的读写之后，还有一些细节也值得关注下，比如对<code>Cookie</code>中值的验证、<code>remember-me</code>的实现等。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://docs.spring.io/spring-session/docs/2.1.2.RELEASE/reference/html5/" target="_blank" rel="noopener">SpringSession官方文档</a></li><li><a href="https://blog.csdn.net/cao_j/article/details/51191764" target="_blank" rel="noopener">jvm_router原理</a></li><li><a href="https://github.com/glmapper/spring-session/tree/cn-spring-session" target="_blank" rel="noopener">SpringSession中文注释持续更新代码分支</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;首先需求在这里说明下，SpringSession的版本迭代的过程中肯定会伴随着一些类的移除和一些类的加入，目前本系列使用的版本是github上对象的master的代码流版本。如果有同学对其他版本中的一些类或者处理有疑惑，欢迎交流。&lt;/p&gt;
&lt;/bl
      
    
    </summary>
    
      <category term="spring" scheme="http://www.glmapper.com/categories/spring/"/>
    
      <category term="session" scheme="http://www.glmapper.com/categories/spring/session/"/>
    
    
      <category term="spring" scheme="http://www.glmapper.com/tags/spring/"/>
    
      <category term="session" scheme="http://www.glmapper.com/tags/session/"/>
    
  </entry>
  
  <entry>
    <title>20181216-书法练习</title>
    <link href="http://www.glmapper.com/2018/12/16/shufa-20181216/"/>
    <id>http://www.glmapper.com/2018/12/16/shufa-20181216/</id>
    <published>2018-12-16T07:30:58.000Z</published>
    <updated>2019-01-05T09:17:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>春江花月夜 -张若虚<br>春江潮水连海平，海上明月共潮生。<br>滟滟随波千万里，何处春江无月明！<br>江流宛转绕芳甸，月照花林皆似霰；<br>空里流霜不觉飞，汀上白沙看不见。<br>江天一色无纤尘，皎皎空中孤月轮。<br>江畔何人初见月？江月何年初照人？<br>人生代代无穷已，江月年年只相似。<br>不知江月待何人，但见长江送流水。<br>白云一片去悠悠，青枫浦上不胜愁。<br>谁家今夜扁舟子？何处相思明月楼？<br>可怜楼上月徘徊，应照离人妆镜台。<br>玉户帘中卷不去，捣衣砧上拂还来。<br>此时相望不相闻，愿逐月华流照君。<br>鸿雁长飞光不度，鱼龙潜跃水成文。<br>昨夜闲潭梦落花，可怜春半不还家。<br>江水流春去欲尽，江潭落月复西斜。<br>斜月沉沉藏海雾，碣石潇湘无限路。<br>不知乘月几人归，落月摇情满江树。</p></blockquote><p><img src="https://github.com/glmapper/glmapper.github.io/blob/master/images/self/shufa-yb-chunjianghuayueye.jpg?raw=true" alt=""></p><p><img src="https://github.com/glmapper/glmapper.github.io/blob/master/images/self/shufa-rb-chunjianghuayueye.jpg?raw=true" alt=""></p><blockquote><p>闻王昌龄左迁龙标遥有此寄 -李白<br>杨花落尽子规啼，闻道龙标过五溪。<br>我寄愁心与明月，随风直到夜郎西。</p></blockquote><p><img src="https://github.com/glmapper/glmapper.github.io/blob/master/images/self/shufa-yanghualuojinziguiti.jpg?raw=true" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;春江花月夜 -张若虚&lt;br&gt;春江潮水连海平，海上明月共潮生。&lt;br&gt;滟滟随波千万里，何处春江无月明！&lt;br&gt;江流宛转绕芳甸，月照花林皆似霰；&lt;br&gt;空里流霜不觉飞，汀上白沙看不见。&lt;br&gt;江天一色无纤尘，皎皎空中孤月轮。&lt;br&gt;江畔何人初见月？江月
      
    
    </summary>
    
      <category term="书法" scheme="http://www.glmapper.com/categories/%E4%B9%A6%E6%B3%95/"/>
    
    
      <category term="书法" scheme="http://www.glmapper.com/tags/%E4%B9%A6%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringSession系列-存储机制之Redis&amp;Map</title>
    <link href="http://www.glmapper.com/2018/12/15/spring-session-redis-map/"/>
    <id>http://www.glmapper.com/2018/12/15/spring-session-redis-map/</id>
    <published>2018-12-15T17:30:38.000Z</published>
    <updated>2018-12-22T16:10:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>@<a href="SpringSession：存储机制设计">TOC</a><br>在之前的文章中已经对<code>SpringSession</code>的功能结构，请求/响应重写等做了介绍。本文将继续来介绍下<code>SpringSession</code>中存储部分的设计。存储是分布式<code>session</code>中算是最核心的部分，通过引入三方的存储容器来实现<code>session</code>的存储，从而有效的解决<code>session</code>共享的问题。</p><h2 id="1、SpringSession存储的顶级抽象接口"><a href="#1、SpringSession存储的顶级抽象接口" class="headerlink" title="1、SpringSession存储的顶级抽象接口"></a>1、SpringSession存储的顶级抽象接口</h2><p><code>SpringSession</code>存储的顶级抽象接口是<code>org.springframework.session</code>包下的<code>SessionRepository</code>这个接口。<code>SessionRepository</code>的类图结构如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef7ce8c6b58?w=1662&amp;h=600&amp;f=png&amp;s=66844" alt=""></p><p>这里先来看下<code>SessionRepository</code>这个顶层接口中定义了哪些方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SessionRepository</span>&lt;<span class="title">S</span> <span class="keyword">extends</span> <span class="title">Session</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个session</span></span><br><span class="line"><span class="function">S <span class="title">createSession</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//保存session</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(S session)</span></span>;</span><br><span class="line"><span class="comment">//通过ID查找session</span></span><br><span class="line"><span class="function">S <span class="title">findById</span><span class="params">(String id)</span></span>;</span><br><span class="line"><span class="comment">//通过ID删除一个session</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码来看还是很简单的，就是增删查。下面看具体实现。在2.0版本开始<code>SpringSession</code>中也提供了一个和<code>SessionRepository</code>具体相同能力的<code>ReactiveSessionRepository</code>，用于支持响应式编程模式。</p><h2 id="2、MapSessionRepository"><a href="#2、MapSessionRepository" class="headerlink" title="2、MapSessionRepository"></a>2、MapSessionRepository</h2><p>基于HashMap实现的基于内存存储的存储器实现，这里就主要看下对于接口中几个方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapSessionRepository</span> <span class="keyword">implements</span> <span class="title">SessionRepository</span>&lt;<span class="title">MapSession</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer defaultMaxInactiveInterval;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Session&gt; sessions;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到就是一个<code>Map</code>，那后面关于增删查其实就是操作这个<code>Map</code>了。</p><h3 id="createSession"><a href="#createSession" class="headerlink" title="createSession"></a>createSession</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MapSession <span class="title">createSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MapSession result = <span class="keyword">new</span> MapSession();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.defaultMaxInactiveInterval != <span class="keyword">null</span>) &#123;</span><br><span class="line">result.setMaxInactiveInterval(</span><br><span class="line">Duration.ofSeconds(<span class="keyword">this</span>.defaultMaxInactiveInterval));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很直接，就是<code>new</code>了一个<code>MapSession</code>，然后设置了<code>session</code>的有效期。</p><h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(MapSession session)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!session.getId().equals(session.getOriginalId())) &#123;</span><br><span class="line"><span class="keyword">this</span>.sessions.remove(session.getOriginalId());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.sessions.put(session.getId(), <span class="keyword">new</span> MapSession(session));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面先判断了<code>session</code>中的两个<code>ID</code>，一个<code>originalId</code>，一个当前<code>id</code>。<code>originalId</code>是第一次生成<code>session</code>对象时创建的，后面都不会在变化。通过源码来看，对于<code>originalId</code>，只提供了<code>get</code>方法。对于<code>id</code>呢，其实是可以通过<code>changeSessionId</code>来改变的。</p><p>这里的这个操作实际上是一种优化行为，及时的清除掉老的<code>session</code>数据来释放内存空间。</p><h3 id="findById"><a href="#findById" class="headerlink" title="findById"></a>findById</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MapSession <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">Session saved = <span class="keyword">this</span>.sessions.get(id);</span><br><span class="line"><span class="keyword">if</span> (saved == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (saved.isExpired()) &#123;</span><br><span class="line">deleteById(saved.getId());</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MapSession(saved);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个逻辑也很简单，先从<code>Map</code>中根据<code>id</code>取出<code>session</code>数据，如果没有就返回<code>null</code>，如果有则再判断下是否过期了，如果过期了就删除掉，然后返回<code>null</code>。如果查到了，并且没有过期的话，则构建一个<code>MapSession</code>返回。</p><p>OK，基于内存存储的实现系列就是这些了，下面继续来看其他存储的实现。</p><h2 id="3、FindByIndexNameSessionRepository"><a href="#3、FindByIndexNameSessionRepository" class="headerlink" title="3、FindByIndexNameSessionRepository"></a>3、FindByIndexNameSessionRepository</h2><p><code>FindByIndexNameSessionRepository</code>继承了<code>SessionRepository</code>接口，用于扩展对第三方存储的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FindByIndexNameSessionRepository</span>&lt;<span class="title">S</span> <span class="keyword">extends</span> <span class="title">Session</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">SessionRepository</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">String PRINCIPAL_NAME_INDEX_NAME = FindByIndexNameSessionRepository.class.getName()</span><br><span class="line">.concat(<span class="string">".PRINCIPAL_NAME_INDEX_NAME"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">Map&lt;String, S&gt; <span class="title">findByIndexNameAndIndexValue</span><span class="params">(String indexName, String indexValue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> Map&lt;String, S&gt; <span class="title">findByPrincipalName</span><span class="params">(String principalName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> findByIndexNameAndIndexValue(PRINCIPAL_NAME_INDEX_NAME, principalName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FindByIndexNameSessionRepository</code>添加一个单独的方法为指定用户查询所有会话。这是通过设置名为<code>FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME</code>的<code>Session</code>的属性值为指定用户的<code>username</code>来完成的。开发人员有责任确保属性被赋值，因为<code>SpringSession</code>不会在意被使用的认证机制。官方文档中给出的例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String username = <span class="string">"username"</span>;</span><br><span class="line"><span class="keyword">this</span>.session.setAttribute(</span><br><span class="line">FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME, username);</span><br></pre></td></tr></table></figure><p><code>FindByIndexNameSessionRepository</code>的一些实现会提供一些钩子自动的索引其他的<code>session</code>属性。比如，很多实现都会自动的确保当前的<code>Spring Security</code>用户名称可通过索引名称<code>FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME</code>进行索引。一旦会话被索引，就可以通过下面的代码检索：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String username = <span class="string">"username"</span>;</span><br><span class="line">Map&lt;String, Session&gt; sessionIdToSession = </span><br><span class="line"><span class="keyword">this</span>.sessionRepository.findByIndexNameAndIndexValue(</span><br><span class="line">FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME,username);</span><br></pre></td></tr></table></figure><p>下图是<code>FindByIndexNameSessionRepository</code>接口的三个实现类：<br><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef0284d86a5?w=1624&amp;h=258&amp;f=png&amp;s=66960" alt="FindByIndexNameSessionRepository"></p><p>下面来分别分析下这三个存储的实现细节。</p><h3 id="3-1-RedisOperationsSessionRepository"><a href="#3-1-RedisOperationsSessionRepository" class="headerlink" title="3.1 RedisOperationsSessionRepository"></a>3.1 RedisOperationsSessionRepository</h3><p><code>RedisOperationsSessionRepository</code>的类图结构如下，<code>MessageListener</code>是<code>redis</code>消息订阅的监听接口。<br><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef029530952?w=1128&amp;h=596&amp;f=png&amp;s=67475" alt="在这里插入图片描述"></p><p>代码有点长，就不在这里面贴了，一些注释可以在这个 <a href="https://github.com/glmapper/spring-session/tree/cn-spring-session" target="_blank" rel="noopener">SpringSession中文分支</a> 来看。这里还是主要来看下对于那几个方法的实现。</p><h4 id="3-1-1-createSession"><a href="#3-1-1-createSession" class="headerlink" title="3.1.1 createSession"></a>3.1.1 createSession</h4><p>这里和<code>MapSessionRepository</code>的实现基本一样的，那区别就在于<code>Session</code>的封装模型不一样，这里是<code>RedisSession</code>，实际上<code>RedisSession</code>的实现是对<code>MapSession</code>又包了一层。下面会分析<code>RedisSession</code>这个类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisSession <span class="title">createSession</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// RedisSession,这里和MapSession区别开</span></span><br><span class="line">RedisSession redisSession = <span class="keyword">new</span> RedisSession();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.defaultMaxInactiveInterval != <span class="keyword">null</span>) &#123;</span><br><span class="line">redisSession.setMaxInactiveInterval(</span><br><span class="line">Duration.ofSeconds(<span class="keyword">this</span>.defaultMaxInactiveInterval));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> redisSession;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在看其他两个方法之前，先来看下<code>RedisSession</code>这个类。</p><h4 id="3-1-2-RedisSession"><a href="#3-1-2-RedisSession" class="headerlink" title="3.1.2 RedisSession"></a>3.1.2 RedisSession</h4><p>这个在模型上是对<code>MapSession</code>的扩展，增加了<code>delta</code>这个东西。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSession</span> <span class="keyword">implements</span> <span class="title">Session</span> </span>&#123;</span><br><span class="line">       <span class="comment">// MapSession 实例对象，主要存数据的地方</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MapSession cached;</span><br><span class="line"><span class="comment">// 原始最后访问时间</span></span><br><span class="line"><span class="keyword">private</span> Instant originalLastAccessTime;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; delta = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 是否是新的session对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isNew;</span><br><span class="line"><span class="comment">// 原始主名称</span></span><br><span class="line"><span class="keyword">private</span> String originalPrincipalName;</span><br><span class="line"><span class="comment">// 原始sessionId</span></span><br><span class="line"><span class="keyword">private</span> String originalSessionId;</span><br></pre></td></tr></table></figure></p><p><code>delta</code>是一个Map结构，那么这里面到底是放什么的呢？具体细节见 <a href="https://github.com/glmapper/spring-session/blob/cn-spring-session/spring-session-data-redis/src/main/java/org/springframework/session/data/redis/RedisOperationsSessionRepository.java" target="_blank" rel="noopener">saveDelta</a> 这个方法。<code>saveDelta</code> 这个方法会在两个地方被调用，一个是下面要说道的<code>save</code>方法，另外一个是 <code>flushImmediateIfNecessary</code> 这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushImmediateIfNecessary</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (RedisOperationsSessionRepository.<span class="keyword">this</span>.redisFlushMode == RedisFlushMode.IMMEDIATE) &#123;</span><br><span class="line">saveDelta();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>RedisFlushMode</code>提供了两种推送模式：</p><ul><li>ON_SAVE：只有在调用<code>save</code>方法时执行，在<code>web</code>环境中这样做通常是尽快提交HTTP响应</li><li>IMMEDIATE：只要有变更就会直接写到<code>redis</code>中，不会像<code>ON_SAVE</code>一样，在最后<code>commit</code>时一次性写入</li></ul><p>追踪<code>flushImmediateIfNecessary</code> 方法调用链如下：<br><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef032721690?w=1008&amp;h=258&amp;f=png&amp;s=89571" alt="在这里插入图片描述"><br>那么到这里基本就清楚了，首先<code>save</code>这个方法，当主动调用<code>save</code>时就是将数据推到<code>redis</code>中去的，也就是<code>ON_SAVE</code>这种情况。那么对于<code>IMMEDIATE</code>这种情况，只有调用了上面的四个方法，<code>SpringSession</code> 才会将数据推送到<code>redis</code>。</p><p>所以<code>delta</code>里面存的是当前一些变更的 <code>key-val</code> 键值对象，而这些变更是由<code>setAttribute</code>、<code>removeAttribute</code>、<code>setMaxInactiveIntervalInSeconds</code>、<code>setLastAccessedTime</code>这四个方法触发的；比如<code>setAttribute(k,v)</code>，那么这个<code>k-&gt;v</code>就会被保存到<code>delta</code>里面。</p><h4 id="3-1-3-save"><a href="#3-1-3-save" class="headerlink" title="3.1.3 save"></a>3.1.3 save</h4><p>在理解了<code>saveDelta</code>方法之后再来看<code>save</code>方法就简单多了。<code>save</code> 对应的就是<code>RedisFlushMode.ON_SAVE</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(RedisSession session)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 直接调用 saveDelta推数据到redis</span></span><br><span class="line">session.saveDelta();</span><br><span class="line"><span class="keyword">if</span> (session.isNew()) &#123;</span><br><span class="line">   <span class="comment">// sessionCreatedKey-&gt;channl</span></span><br><span class="line">String sessionCreatedKey = getSessionCreatedChannel(session.getId());</span><br><span class="line"><span class="comment">// 发布一个消息事件，新增 session，以供 MessageListener 回调处理。</span></span><br><span class="line"><span class="keyword">this</span>.sessionRedisOperations.convertAndSend(sessionCreatedKey, session.delta);</span><br><span class="line">session.setNew(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-4-findById"><a href="#3-1-4-findById" class="headerlink" title="3.1.4 findById"></a>3.1.4 findById</h4><p>查询这部分和基于<code>Map</code>的差别比较大，因为这里并不是直接操作<code>Map</code>，而是与<code>Redis</code> 进行一次交互。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisSession <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getSession(id, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用<code>getSession</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RedisSession <span class="title">getSession</span><span class="params">(String id, <span class="keyword">boolean</span> allowExpired)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据ID从redis中取出数据</span></span><br><span class="line">Map&lt;Object, Object&gt; entries = getSessionBoundHashOperations(id).entries();</span><br><span class="line"><span class="keyword">if</span> (entries.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转换成MapSession</span></span><br><span class="line">MapSession loaded = loadSession(id, entries);</span><br><span class="line"><span class="keyword">if</span> (!allowExpired &amp;&amp; loaded.isExpired()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转换成RedisSession</span></span><br><span class="line">RedisSession result = <span class="keyword">new</span> RedisSession(loaded);</span><br><span class="line">result.originalLastAccessTime = loaded.getLastAccessedTime();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>loadSession</code>中构建<code>MapSession</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MapSession <span class="title">loadSession</span><span class="params">(String id, Map&lt;Object, Object&gt; entries)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 生成MapSession实例</span></span><br><span class="line">MapSession loaded = <span class="keyword">new</span> MapSession(id);</span><br><span class="line"><span class="comment">//遍历数据</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entries.entrySet()) &#123;</span><br><span class="line">String key = (String) entry.getKey();</span><br><span class="line"><span class="keyword">if</span> (CREATION_TIME_ATTR.equals(key)) &#123;</span><br><span class="line">    <span class="comment">// 设置创建时间</span></span><br><span class="line">loaded.setCreationTime(Instant.ofEpochMilli((<span class="keyword">long</span>) entry.getValue()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (MAX_INACTIVE_ATTR.equals(key)) &#123;</span><br><span class="line"> <span class="comment">// 设置最大有效时间</span></span><br><span class="line">loaded.setMaxInactiveInterval(Duration.ofSeconds((<span class="keyword">int</span>) entry.getValue()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (LAST_ACCESSED_ATTR.equals(key)) &#123;</span><br><span class="line"><span class="comment">// 设置最后访问时间</span></span><br><span class="line">loaded.setLastAccessedTime(Instant.ofEpochMilli((<span class="keyword">long</span>) entry.getValue()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key.startsWith(SESSION_ATTR_PREFIX)) &#123;</span><br><span class="line"><span class="comment">// 设置属性</span></span><br><span class="line">loaded.setAttribute(key.substring(SESSION_ATTR_PREFIX.length()),</span><br><span class="line">entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> loaded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-5-deleteById"><a href="#3-1-5-deleteById" class="headerlink" title="3.1.5 deleteById"></a>3.1.5 deleteById</h4><p>根据<code>sessionId</code>删除<code>session</code>数据。具体过程看代码注释。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(String sessionId)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取 RedisSession</span></span><br><span class="line">RedisSession session = getSession(sessionId, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">if</span> (session == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// 清楚当前session数据的索引</span></span><br><span class="line">cleanupPrincipalIndex(session);</span><br><span class="line"><span class="comment">//执行删除操作</span></span><br><span class="line"><span class="keyword">this</span>.expirationPolicy.onDelete(session);</span><br><span class="line">String expireKey = getExpiredKey(session.getId());</span><br><span class="line"><span class="comment">//删除expireKey</span></span><br><span class="line"><span class="keyword">this</span>.sessionRedisOperations.delete(expireKey);</span><br><span class="line"><span class="comment">//session有效期设置为0</span></span><br><span class="line">session.setMaxInactiveInterval(Duration.ZERO);</span><br><span class="line">save(session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-1-6-onMessage"><a href="#3-1-6-onMessage" class="headerlink" title="3.1.6 onMessage"></a>3.1.6 onMessage</h4><p>最后来看下这个订阅回调处理。这里看下核心的一段逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isDeleted = channel.equals(<span class="keyword">this</span>.sessionDeletedChannel);</span><br><span class="line"><span class="comment">// Deleted 还是 Expired ？</span></span><br><span class="line"><span class="keyword">if</span> (isDeleted || channel.equals(<span class="keyword">this</span>.sessionExpiredChannel)) &#123;</span><br><span class="line"><span class="comment">// 此处省略无关代码</span></span><br><span class="line"><span class="comment">// Deleted</span></span><br><span class="line"><span class="keyword">if</span> (isDeleted) &#123;</span><br><span class="line">   <span class="comment">// 发布一个 SessionDeletedEvent 事件</span></span><br><span class="line">handleDeleted(session);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Expired</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 发布一个 SessionExpiredEvent 事件</span></span><br><span class="line">handleExpired(session);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-Redis-存储的一些思考"><a href="#3-2-Redis-存储的一些思考" class="headerlink" title="3.2 Redis 存储的一些思考"></a>3.2 Redis 存储的一些思考</h3><p>首先按照我们自己常规的思路来设计的话，我们会怎么来考虑这个事情。这里首先要声明下，我对 <code>Redis</code> 这个东西不是很熟，没有做过深入的研究；那如果是我来做，可能也就仅仅限于存储。</p><ul><li><code>findByIndexNameAndIndexValue</code>的设计，这个的作用是通过<code>indexName</code>和<code>indexValue</code>来返回当前用户的所有会话。但是这里需要考虑的一个事情是，通常情况下，一个用户只会关联到一个会话上面去，那这种设计很显然，我的理解是为了支持单用户多会话的场景。<ul><li>indexName：FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME</li><li>indexValue：username</li></ul></li><li><p>实现 <code>MessageListener</code> 接口，增加事件通知能力。通过监听这些事件，可以做一些<code>session</code>操作管控。但是实际上 <code>SpringSession</code> 中并没有做任何事情，从代码来看，<code>publishEvent</code>方法是空实现。等待回复中 <a href="https://github.com/spring-projects/spring-session/issues/1287" target="_blank" rel="noopener">#issue 1287</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ApplicationEventPublisher eventPublisher = <span class="keyword">new</span> ApplicationEventPublisher() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>RedisFlushMode</code> ，<code>SpringSession</code>中提供了两种模式的推送，一种是<code>ON_SAVE</code>，另外一种是<code>IMMEDIATE</code>。默认是<code>ON_SAVE</code>，也就是常规的在请求处理结束时进行一次<code>sessionCommit</code>操作。<code>RedisFlushMode</code> 的设计感觉是为<code>session</code>数据持久化的时机提供了另外一种思路。</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>存储机制设计部分就一基于内存和基于<code>Redis</code>两种来分析；另外基于<code>jdbc</code>和<code>hazelcast</code>有兴趣的同学可以自己查看源码。</p><p>最后也欢迎访问我的个人博客：<a href="http://www.glmapper.com">www.glmapper.com</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/zyhlwzy/article/details/78062646" target="_blank" rel="noopener">https://blog.csdn.net/zyhlwzy/article/details/78062646</a></li><li><a href="https://docs.spring.io/spring-session/docs/2.0.0.M4/reference/html5/#api" target="_blank" rel="noopener">https://docs.spring.io/spring-session/docs/2.0.0.M4/reference/html5/#api</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@&lt;a href=&quot;SpringSession：存储机制设计&quot;&gt;TOC&lt;/a&gt;&lt;br&gt;在之前的文章中已经对&lt;code&gt;SpringSession&lt;/code&gt;的功能结构，请求/响应重写等做了介绍。本文将继续来介绍下&lt;code&gt;SpringSession&lt;/code&gt;中存储部
      
    
    </summary>
    
      <category term="spring" scheme="http://www.glmapper.com/categories/spring/"/>
    
      <category term="session" scheme="http://www.glmapper.com/categories/spring/session/"/>
    
    
      <category term="spring" scheme="http://www.glmapper.com/tags/spring/"/>
    
      <category term="session" scheme="http://www.glmapper.com/tags/session/"/>
    
  </entry>
  
  <entry>
    <title>SOFATracer 插件埋点机制详解</title>
    <link href="http://www.glmapper.com/2018/12/07/sofatracer-mvc-plugin/"/>
    <id>http://www.glmapper.com/2018/12/07/sofatracer-mvc-plugin/</id>
    <published>2018-12-07T14:34:14.000Z</published>
    <updated>2018-12-07T14:37:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SOFATracer 是一个用于分布式系统调用跟踪的组件，通过统一的 <code>traceId</code> 将调用链路中的各种网络调用情况以日志的方式记录下来，以达到透视化网络调用的目的。这些日志可用于故障的快速发现，服务治理等。</p></blockquote><p>从 <a href="http://www.sofastack.tech/sofa-tracer/docs/roadmap" target="_blank" rel="noopener">RoadMap</a> 和 <a href="https://github.com/alipay/sofa-tracer/pulls" target="_blank" rel="noopener">PR</a> 来看，目前 SOFATracer 已经支持了丰富的组件插件埋点。</p><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543318400761-682a9d1a-b194-4a87-9fac-9e1a38a9247e.png" alt="img"></p><p>目前还未支持的主要是 Dubbo、MQ 以及 Redis 等。本文将从 SOFATracer 已提供的一个插件源码来分析下 SOFATracer 插件的埋点实现。</p><h2 id="1-SOFATracer-插件埋点机制"><a href="#1-SOFATracer-插件埋点机制" class="headerlink" title="1 SOFATracer 插件埋点机制"></a>1 SOFATracer 插件埋点机制</h2><p>SOFATracer 插件的作用实际上就是对于不同组件进行埋点，以便于收集这些组件的链路数据。SOFATracer 埋点方式一般是通过 Filter、Interceptor 机制实现的。</p><p>另一个是，SOFATracer 的埋点方式并不是基于 OT-api 进行埋点的，而是基于 SOFATracer 自己的 api 进行埋点的，详见 <a href="https://github.com/alipay/sofa-tracer/issues/126" target="_blank" rel="noopener">issue#126</a>。</p><h3 id="1-1-Filter-or-Interceptor"><a href="#1-1-Filter-or-Interceptor" class="headerlink" title="1.1 Filter or Interceptor"></a>1.1 Filter or Interceptor</h3><p>目前已实现的插件中，像 MVC 插件是基于 Filter 进行埋点的，httpclient、resttemplate 等是基于Interceptor进行埋点的。在实现插件时，要根据不同插件的特性来选择具体的埋点方式。</p><p> 当然除了这两种方式之外还可以通过静态代理的方式来实现埋点。比如 sofa-tracer-datasource-plugin 插件就是将不同的数据源进行统一代理给 SmartDatasource，从而实现埋点的。</p><h3 id="1-2-AbstractTracer-API"><a href="#1-2-AbstractTracer-API" class="headerlink" title="1.2 AbstractTracer API"></a>1.2 AbstractTracer API</h3><p>SOFATracer 中所有的插件均需要实现自己的 Tracer 实例，如 Mvc 的 SpringMvcTracer 、HttpClient的 HttpClientTracer 等，这一点与基于 Opentracing-api 接口埋点的实现有所区别。</p><ul><li>1、基于 SOFATracer api 埋点方式插件扩展</li></ul><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543324415543-aba1c5fe-7cb4-46ae-9aee-2fe5441a5f98.png" alt="img"></p><p>AbstractTracer 是 SOFATracer 用于插件扩展使用的一个抽象类，根据插件类型不同，又可以分为 clientTracer 和 serverTracer，分别对应于：AbstractClientTracer 和 AbstractServerTracer，再通过 AbstractClientTracer 和 AbstractServerTracer 衍生出具体的组件 Tracer 实现。这种方式的好处在于，所有的插件实现均由 SOFATracer 本身来管控，对于不同的组件可以轻松的实现差异化和定制化。缺点也源于此，每增加一个组件都需要做一些重复工作。</p><ul><li>2、基于 OpenTracing-api 埋点方式插件扩展</li></ul><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543324680485-cdb3793c-b830-490e-832f-b58e12091f7d.png" alt="img"></p><p>这种埋点方式不基于 SOFATracer  自身提供的 API，而是基于 OpenTracing-api 接口。因为均遵循 OpenTracing-api 规范，所以组件和 Tracer 实现可以独立分开来维护。这样就可以对接开源的一些基于 OpenTracing-api 规范实现的组件。例如：<a href="https://github.com/opentracing-contrib" target="_blank" rel="noopener">OpenTracing API Contributions</a>。</p><p>SOFATracer 在后面将会在 4.0 版本中支持基于 OT-api 的埋点方式，对外部组件接入扩展提供支持。</p><h3 id="1-3-AbstractTracer"><a href="#1-3-AbstractTracer" class="headerlink" title="1.3 AbstractTracer"></a>1.3 AbstractTracer</h3><p>这里先来看下 AbstractTracer  这个抽象类中具体提供了哪些抽象方法，也就是对于 AbstractClientTracer 和 AbstractServerTracer 需要分别扩展哪些能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取client端 摘要日志日志名</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getClientDigestReporterLogName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取client端 摘要日志滚动策略key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getClientDigestReporterRollingKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取client端 摘要日志日志名key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getClientDigestReporterLogNameKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取client端 摘要日志编码器</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getClientDigestEncoder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 创建client端 统计日志Reporter类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> AbstractSofaTracerStatisticReporter <span class="title">generateClientStatReporter</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志日志名</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getServerDigestReporterLogName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志滚动策略key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getServerDigestReporterRollingKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志日志名key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getServerDigestReporterLogNameKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志编码器</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getServerDigestEncoder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 创建server端 统计日志Reporter类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> AbstractSofaTracerStatisticReporter <span class="title">generateServerStatReporter</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>从  AbstractTracer 类提供的抽象方法来看，不管是 client 还是 server，在具体的 Tracer 组件实现中，都必须提供以下实现：</p><ul><li>DigestReporterLogName :当前组件摘要日志的日志名称</li><li>DigestReporterRollingKey : 当前组件摘要日志的滚动策略</li><li>SpanEncoder：对摘要日志进行编码的编码器实现</li><li>AbstractSofaTracerStatisticReporter : 统计日志 reporter 类的实现类。</li></ul><h2 id="2-SpringMVC-插件埋点分析"><a href="#2-SpringMVC-插件埋点分析" class="headerlink" title="2 SpringMVC 插件埋点分析"></a>2 SpringMVC 插件埋点分析</h2><p>这里我们以 SpringMVC 插件为例，来分析下如何实现一个埋点插件的。这里是官方给出的案例工程：基于 <a href="https://github.com/alipay/sofa-tracer/blob/master/tracer-samples/tracer-sample-with-springmvc" target="_blank" rel="noopener">Spring MVC 示例落地日志</a> 。</p><h3 id="2-1-实现-Tracer-实例"><a href="#2-1-实现-Tracer-实例" class="headerlink" title="2.1 实现 Tracer 实例"></a>2.1 实现 Tracer 实例</h3><p>SpringMvcTracer 继承了 AbstractServerTracer 类，是对 serverTracer 的扩展。</p><blockquote><p>PS：如何确定一个组件是client端还是server端呢？就是看当前组件是请求的发起方还是请求的接受方，如果是请求发起方则一般是client端，如果是请求接收方则是 server 端。那么对于 MVC 来说，是请求接受方，因此这里实现了 AbstractServerTracer 类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcTracer</span> <span class="keyword">extends</span> <span class="title">AbstractServerTracer</span></span></span><br></pre></td></tr></table></figure><h4 id="2-1-1-构造函数与单例对象"><a href="#2-1-1-构造函数与单例对象" class="headerlink" title="2.1.1 构造函数与单例对象"></a>2.1.1 构造函数与单例对象</h4><p>在构造函数中，需要传入当前 Tracer 的 traceType，SpringMvcTracer 的 traceType 为 “springmvc”。这里也可以看到，tracer 实例是一个单例对象，对于其他插件也是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SpringMvcTracer springMvcTracer = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * Spring MVC Tracer Singleton</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> singleton</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SpringMvcTracer <span class="title">getSpringMvcTracerSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (springMvcTracer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SpringMvcTracer.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (springMvcTracer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                springMvcTracer = <span class="keyword">new</span> SpringMvcTracer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> springMvcTracer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SpringMvcTracer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"springmvc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-AbstractServerTracer-抽象类"><a href="#2-1-2-AbstractServerTracer-抽象类" class="headerlink" title="2.1.2 AbstractServerTracer 抽象类"></a>2.1.2 AbstractServerTracer 抽象类</h4><p>在看 SpringMvcTracer 实现之前，先来看下 AbstractServerTracer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractServerTracer</span> <span class="keyword">extends</span> <span class="title">AbstractTracer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数，子类必须提供一个构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractServerTracer</span><span class="params">(String tracerType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(tracerType, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为是server端，所以Client先关的提供了默认实现，返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getClientDigestReporterLogName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getClientDigestReporterRollingKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getClientDigestReporterLogNameKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getClientDigestEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AbstractSofaTracerStatisticReporter <span class="title">generateClientStatReporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合上面  AbstractTracer 小节中抽象方法分析，这里在 AbstractServerTracer 中将 client 对应的抽象方法提供了默认实现，也就是说如果要继承 AbstractServerTracer 类，那么就必须实现 server 对应的所有抽象方法。</p><h4 id="2-1-3-SpringMVCTracer-实现"><a href="#2-1-3-SpringMVCTracer-实现" class="headerlink" title="2.1.3 SpringMVCTracer 实现"></a>2.1.3 SpringMVCTracer 实现</h4><p>下面是 SpringMvcTracer 部分对 server 部分抽象方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getServerDigestReporterLogName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SpringMvcLogEnum.SPRING_MVC_DIGEST.getDefaultLogName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getServerDigestReporterRollingKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SpringMvcLogEnum.SPRING_MVC_DIGEST.getRollingKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getServerDigestReporterLogNameKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SpringMvcLogEnum.SPRING_MVC_DIGEST.getLogNameKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getServerDigestEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Boolean.TRUE.toString().equalsIgnoreCase(</span><br><span class="line">        SofaTracerConfiguration.getProperty(SPRING_MVC_JSON_FORMAT_OUTPUT))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringMvcDigestJsonEncoder();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringMvcDigestEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AbstractSofaTracerStatisticReporter <span class="title">generateServerStatReporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> generateSofaMvcStatReporter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前 SOFATracer 日志名、滚动策略key等都是通过枚举类来定义的，也就是一个组件会对应这样一个枚举类，在枚举类里面定义这些常量。</p><h3 id="2-2-SpringMvcLogEnum-类实现"><a href="#2-2-SpringMvcLogEnum-类实现" class="headerlink" title="2.2 SpringMvcLogEnum 类实现"></a>2.2 SpringMvcLogEnum 类实现</h3><p>SpringMVC 插件中的枚举类是 SpringMvcLogEnum。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SpringMvcLogEnum &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 摘要日志相关</span></span><br><span class="line">    SPRING_MVC_DIGEST(<span class="string">"spring_mvc_digest_log_name"</span>, </span><br><span class="line">                      <span class="string">"spring-mvc-digest.log"</span>,</span><br><span class="line">                      <span class="string">"spring_mvc_digest_rolling"</span>), </span><br><span class="line">    <span class="comment">// 统计日志相关</span></span><br><span class="line">    SPRING_MVC_STAT(<span class="string">"spring_mvc_stat_log_name"</span>, </span><br><span class="line">                    <span class="string">"spring-mvc-stat.log"</span>, </span><br><span class="line">                    <span class="string">"spring_mvc_stat_rolling"</span>);</span><br><span class="line">    <span class="comment">// 省略部分代码....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 XXXLogEnum 枚举类中定义了当前组件对应的摘要日志和统计日志的日志名和滚动策略，因为 SOFATracer 目前还没有服务端的能力，链路数据不是直接上报给 server 的，因此 SOFATracer 提供了落到磁盘的能力。不同插件的链路日志也会通过 XXXLogEnum 指定的名称将链路日志输出到各个组件对应的日志目录下。</p><h3 id="2-3-统计日志-Reportor-实现"><a href="#2-3-统计日志-Reportor-实现" class="headerlink" title="2.3 统计日志 Reportor 实现"></a>2.3 统计日志 Reportor 实现</h3><p>SOFATracer 中统计日志打印的实现需要各个组件自己来完成，具体就是需要实现一个AbstractSofaTracerStatisticReporter 的子类，然后实现 doReportStat 这个方法。当然对于目前的实现来说，我们也会重写 print 方法。</p><h4 id="2-3-1-doReportStat"><a href="#2-3-1-doReportStat" class="headerlink" title="2.3.1 doReportStat"></a>2.3.1 doReportStat</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doReportStat</span><span class="params">(SofaTracerSpan sofaTracerSpan)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; tagsWithStr = sofaTracerSpan.getTagsWithStr();</span><br><span class="line">    <span class="comment">// 构建StatMapKey对象</span></span><br><span class="line">    StatMapKey statKey = <span class="keyword">new</span> StatMapKey();</span><br><span class="line">    <span class="comment">// 增加 key:当前应用名</span></span><br><span class="line">    statKey.addKey(CommonSpanTags.LOCAL_APP, tagsWithStr.get(CommonSpanTags.LOCAL_APP));</span><br><span class="line">    <span class="comment">// 增加 key:请求 url</span></span><br><span class="line">    statKey.addKey(CommonSpanTags.REQUEST_URL, tagsWithStr.get(CommonSpanTags.REQUEST_URL));</span><br><span class="line">    <span class="comment">// 增加 key:请求方法</span></span><br><span class="line">    statKey.addKey(CommonSpanTags.METHOD, tagsWithStr.get(CommonSpanTags.METHOD));</span><br><span class="line">    <span class="comment">// 压测标志</span></span><br><span class="line">    statKey.setLoadTest(TracerUtils.isLoadTest(sofaTracerSpan));</span><br><span class="line">    <span class="comment">// 请求响应码</span></span><br><span class="line">    String resultCode = tagsWithStr.get(CommonSpanTags.RESULT_CODE);</span><br><span class="line">    <span class="comment">// 请求成功标识</span></span><br><span class="line">    <span class="keyword">boolean</span> success = (resultCode != <span class="keyword">null</span> &amp;&amp; resultCode.length() &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span></span><br><span class="line">        .isHttpOrMvcSuccess(resultCode));</span><br><span class="line">    statKey.setResult(success ? <span class="string">"true"</span> : <span class="string">"false"</span>);</span><br><span class="line">    <span class="comment">//end</span></span><br><span class="line">    statKey.setEnd(TracerUtils.getLoadTestMark(sofaTracerSpan));</span><br><span class="line">    <span class="comment">//value the count and duration</span></span><br><span class="line">    <span class="keyword">long</span> duration = sofaTracerSpan.getEndTime() - sofaTracerSpan.getStartTime();</span><br><span class="line">    <span class="keyword">long</span> values[] = <span class="keyword">new</span> <span class="keyword">long</span>[] &#123; <span class="number">1</span>, duration &#125;;</span><br><span class="line">    <span class="comment">// reserve</span></span><br><span class="line">    <span class="keyword">this</span>.addStat(statKey, values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里就是就是将统计日志添加到日志槽里，等待被消费(输出到日志)。具体可以参考：SofaTracerStatisticReporterManager.StatReporterPrinter。</p><h4 id="2-3-2-print"><a href="#2-3-2-print" class="headerlink" title="2.3.2 print"></a>2.3.2 print</h4><p>print 方法是实际将数据写入到磁盘的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(StatKey statKey, <span class="keyword">long</span>[] values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isClosePrint.get()) &#123;</span><br><span class="line">        <span class="comment">//关闭统计日志输出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(statKey <span class="keyword">instanceof</span> StatMapKey)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StatMapKey statMapKey = (StatMapKey) statKey;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 构建需要打印的数据串</span></span><br><span class="line">        jsonBuffer.reset();</span><br><span class="line">        jsonBuffer.appendBegin();</span><br><span class="line">        jsonBuffer.append(<span class="string">"time"</span>, Timestamp.currentTime());</span><br><span class="line">        jsonBuffer.append(<span class="string">"stat.key"</span>, <span class="keyword">this</span>.statKeySplit(statMapKey));</span><br><span class="line">        jsonBuffer.append(<span class="string">"count"</span>, values[<span class="number">0</span>]);</span><br><span class="line">        jsonBuffer.append(<span class="string">"total.cost.milliseconds"</span>, values[<span class="number">1</span>]);</span><br><span class="line">        jsonBuffer.append(<span class="string">"success"</span>, statMapKey.getResult());</span><br><span class="line">        <span class="comment">//压测</span></span><br><span class="line">        jsonBuffer.appendEnd(<span class="string">"load.test"</span>, statMapKey.getEnd());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (appender <span class="keyword">instanceof</span> LoadTestAwareAppender) &#123;</span><br><span class="line">            ((LoadTestAwareAppender) appender).append(jsonBuffer.toString(),</span><br><span class="line">                statMapKey.isLoadTest());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            appender.append(jsonBuffer.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里强制刷一次</span></span><br><span class="line">        appender.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        SelfLog.error(<span class="string">"统计日志&lt;"</span> + statTracerName + <span class="string">"&gt;输出异常"</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>print 这个方法里面就是将 statMapKey 中，也就是 doReportStat 中塞进来的数据转换成  json 格式，然后刷到磁盘。需要注意的是这里是强制 flush 了一次。如果没有重写 print 这个方法的话，则是在SofaTracerStatisticReporterManager.StatReporterPrinter 里面调用 print 方法刷到磁盘。</p><h3 id="2-4-数据传播格式实现"><a href="#2-4-数据传播格式实现" class="headerlink" title="2.4 数据传播格式实现"></a>2.4 数据传播格式实现</h3><p>SOFATracer 支持使用 OpenTracing 的内建格式进行上下文传播。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcHeadersCarrier</span> <span class="keyword">implements</span> <span class="title">TextMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, String&gt; headers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpringMvcHeadersCarrier</span><span class="params">(HashMap&lt;String, String&gt; headers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.headers = headers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        headers.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> headers.entrySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-自定义编码格式实现"><a href="#2-5-自定义编码格式实现" class="headerlink" title="2.5 自定义编码格式实现"></a>2.5 自定义编码格式实现</h3><p>这个决定了摘要日志打印的格式，和在统计日志里面的实现要有所区分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcDigestJsonEncoder</span> <span class="keyword">extends</span> <span class="title">AbstractDigestSpanEncoder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重写encode,对span进行编码处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(SofaTracerSpan span)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        JsonStringBuilder jsonStringBuilder = <span class="keyword">new</span> JsonStringBuilder();</span><br><span class="line">        <span class="comment">//日志打印时间</span></span><br><span class="line">        jsonStringBuilder.appendBegin(<span class="string">"time"</span>, Timestamp.format(span.getEndTime()));</span><br><span class="line">        appendSlot(jsonStringBuilder, span);</span><br><span class="line">        <span class="keyword">return</span> jsonStringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具体字段处理</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendSlot</span><span class="params">(JsonStringBuilder jsonStringBuilder, SofaTracerSpan sofaTracerSpan)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        SofaTracerSpanContext context = sofaTracerSpan.getSofaTracerSpanContext();</span><br><span class="line">        Map&lt;String, String&gt; tagWithStr = sofaTracerSpan.getTagsWithStr();</span><br><span class="line">        Map&lt;String, Number&gt; tagWithNumber = sofaTracerSpan.getTagsWithNumber();</span><br><span class="line">        <span class="comment">//当前应用名</span></span><br><span class="line">        jsonStringBuilder</span><br><span class="line">            .append(CommonSpanTags.LOCAL_APP, tagWithStr.get(CommonSpanTags.LOCAL_APP));</span><br><span class="line">        <span class="comment">//TraceId</span></span><br><span class="line">        jsonStringBuilder.append(<span class="string">"traceId"</span>, context.getTraceId());</span><br><span class="line">        <span class="comment">//RpcId</span></span><br><span class="line">        jsonStringBuilder.append(<span class="string">"spanId"</span>, context.getSpanId());</span><br><span class="line">        <span class="comment">//请求 URL</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.REQUEST_URL,</span><br><span class="line">            tagWithStr.get(CommonSpanTags.REQUEST_URL));</span><br><span class="line">        <span class="comment">//请求方法</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.METHOD, tagWithStr.get(CommonSpanTags.METHOD));</span><br><span class="line">        <span class="comment">//Http 状态码</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.RESULT_CODE,</span><br><span class="line">            tagWithStr.get(CommonSpanTags.RESULT_CODE));</span><br><span class="line">        Number requestSize = tagWithNumber.get(CommonSpanTags.REQ_SIZE);</span><br><span class="line">        <span class="comment">//Request Body 大小 单位为byte</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.REQ_SIZE,</span><br><span class="line">            (requestSize == <span class="keyword">null</span> ? <span class="number">0L</span> : requestSize.longValue()));</span><br><span class="line">        Number responseSize = tagWithNumber.get(CommonSpanTags.RESP_SIZE);</span><br><span class="line">        <span class="comment">//Response Body 大小，单位为byte</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.RESP_SIZE, (responseSize == <span class="keyword">null</span> ? <span class="number">0L</span></span><br><span class="line">            : responseSize.longValue()));</span><br><span class="line">        <span class="comment">//请求耗时（MS）</span></span><br><span class="line">        jsonStringBuilder.append(<span class="string">"time.cost.milliseconds"</span>,</span><br><span class="line">            (sofaTracerSpan.getEndTime() - sofaTracerSpan.getStartTime()));</span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.CURRENT_THREAD_NAME,</span><br><span class="line">            tagWithStr.get(CommonSpanTags.CURRENT_THREAD_NAME));</span><br><span class="line">        <span class="comment">//穿透数据放在最后</span></span><br><span class="line">        jsonStringBuilder.appendEnd(<span class="string">"baggage"</span>, baggageSerialized(context));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里其实也可以看出，统计日志和摘要日志的不同点。统计日志里面核心的数据是 span 里面的 tags 数据，但是其主要作用是统计当前组件的次数。摘要日志里面除了 tags 里面的数据之外还会包括例如 traceId 和 spanId 等信息。</p><ul><li>统计日志</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"time"</span>:<span class="string">"2018-11-28 14:42:25.127"</span>,<span class="attr">"stat.key"</span>:&#123;<span class="attr">"method"</span>:<span class="string">"GET"</span>,<span class="attr">"local.app"</span>:<span class="string">"SOFATracerSpringMVC"</span>,<span class="attr">"request.url"</span>:<span class="string">"http://localhost:8080/springmvc"</span>&#125;,<span class="attr">"count"</span>:<span class="number">3</span>,<span class="attr">"total.cost.milliseconds"</span>:<span class="number">86</span>,<span class="attr">"success"</span>:<span class="string">"true"</span>,<span class="attr">"load.test"</span>:<span class="string">"F"</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>摘要日志</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"time"</span>:<span class="string">"2018-11-28 14:46:08.216"</span>,<span class="attr">"local.app"</span>:<span class="string">"SOFATracerSpringMVC"</span>,<span class="attr">"traceId"</span>:<span class="string">"0a0fe91b1543387568214100259231"</span>,<span class="attr">"spanId"</span>:<span class="string">"0.1"</span>,<span class="attr">"request.url"</span>:<span class="string">"http://localhost:8080/springmvc"</span>,<span class="attr">"method"</span>:<span class="string">"GET"</span>,<span class="attr">"result.code"</span>:<span class="string">"200"</span>,<span class="attr">"req.size.bytes"</span>:<span class="number">-1</span>,<span class="attr">"resp.size.bytes"</span>:<span class="number">0</span>,<span class="attr">"time.cost.milliseconds"</span>:<span class="number">2</span>,<span class="attr">"current.thread.name"</span>:<span class="string">"http-nio-8080-exec-2"</span>,<span class="attr">"baggage"</span>:<span class="string">""</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-请求拦截埋点"><a href="#2-6-请求拦截埋点" class="headerlink" title="2.6 请求拦截埋点"></a>2.6 请求拦截埋点</h3><p>对于基于标准 servlet 实现的组件，要实现对请求的拦截过滤，通常就是 Filter 了。sofa-tracer-springmvc-plugin 插件埋点的实现就是基于 Filter 机制完成的。</p><p>SpringMvcSofaTracerFilter 实现了 javax.servlet.Filter 接口，因此遵循标准的 servlet 规范的容器也可以通过此插件进行埋点。参考文档：<a href="https://github.com/alipay/sofa-tracer/tree/master/tracer-samples/tracer-sample-with-springmvc" target="_blank" rel="noopener">对于标准 servlet 容器的支持（ tomcat/jetty 等）</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcSofaTracerFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span></span><br></pre></td></tr></table></figure><h4 id="2-6-1-基本埋点思路"><a href="#2-6-1-基本埋点思路" class="headerlink" title="2.6.1 基本埋点思路"></a>2.6.1 基本埋点思路</h4><p>对于一个组件来说，一次处理过程一般是产生一个 span。这个span的生命周期是从接收到请求到返回响应这段过程。</p><p>但是这里需要考虑的问题是如何与上下游链路关联起来呢？在 Opentracing 规范中，可以在 Tracer 中 extract 出一个跨进程传递的 SpanContext 。然后通过这个 SpanContext 所携带的信息将当前节点关联到整个 tracer 链路中去。当然有提取(extract)就会有对应的注入(inject)。</p><p>链路的构建一般是 client-server-client-server 这种模式的，那这里就很清楚了，就是会在 client 端进行注入(inject)，然后再 server 端进行提取(extract)，反复进行，然后一直传递下去。</p><p> 在拿到 SpanContext 之后，此时当前的 span 就可以关联到这条链路中了，那么剩余的事情就是收集当前组件的一些数据。</p><p>整个过程大概分为以下几个阶段：</p><ul><li>从请求中提取 spanContext</li><li>构建 span，并将当前 span 存入当前 tracer上下文中（SofaTraceContext.push(span)） 。</li><li>设置一些信息到span中</li><li>返回响应</li><li>span结束&amp;上报</li></ul><p>下面逐一分析下这几个过程。</p><h4 id="2-6-2-从请求中提取-spanContext"><a href="#2-6-2-从请求中提取-spanContext" class="headerlink" title="2.6.2 从请求中提取 spanContext"></a>2.6.2 从请求中提取 spanContext</h4><p>这里的提取用到了上面我们提到的#数据传播格式实现#SpringMvcHeadersCarrier 这个类。上面分析到，因为mvc 做作为 server 端存在的，所以在 server 端就是从请求中 extract 出 SpanContext。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SofaTracerSpanContext <span class="title">getSpanContextFromRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="comment">// 获取请求头信息 </span></span><br><span class="line">    Enumeration headerNames = request.getHeaderNames();</span><br><span class="line">    <span class="keyword">while</span> (headerNames.hasMoreElements()) &#123;</span><br><span class="line">        String key = (String) headerNames.nextElement();</span><br><span class="line">        String value = request.getHeader(key);</span><br><span class="line">        headers.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿到 SofaTracer 实例对象</span></span><br><span class="line">    SofaTracer tracer = springMvcTracer.getSofaTracer();</span><br><span class="line">    <span class="comment">// 解析出 SofaTracerSpanContext（SpanContext的实现类）</span></span><br><span class="line">    SofaTracerSpanContext spanContext = (SofaTracerSpanContext) tracer.extract(</span><br><span class="line">        ExtendFormat.Builtin.B3_HTTP_HEADERS, <span class="keyword">new</span> SpringMvcHeadersCarrier(headers));</span><br><span class="line">    spanContext.setSpanId(spanContext.nextChildContextId());</span><br><span class="line">    <span class="keyword">return</span> spanContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-3-获取-span-amp-数据获取"><a href="#2-6-3-获取-span-amp-数据获取" class="headerlink" title="2.6.3 获取 span &amp; 数据获取"></a>2.6.3 获取 span &amp; 数据获取</h4><p>serverReceive 这个方法是在 AbstractTracer 类中提供了实现，子类不需要关注这个。在 SOFATracer 中将请求大致分为以下几个过程：</p><ul><li>客户端发送请求  clientSend      cs</li><li>服务端接受请求  serverReceive sr</li><li>服务端返回结果  serverSend     ss</li><li>客户端接受结果  clientReceive  cr</li></ul><p>无论是哪个插件，在请求处理周期内都可以从上述几个阶段中找到对应的处理方法。因此，SOFATracer 对这几个阶段处理进行了封装。这四个阶段实际上会产生两个 span，第一个 span 的起点是 cs，到 cr 结束；第二个 span是从 sr 开始，到 ss 结束。也就是说当执行 clientSend 和 serverReceive 时会返回一个 span 对象。来看下MVC中的实现：</p><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543395049905-22e60dd7-1b88-4d94-9b2d-39c94ce909c7.png" alt="img"></p><p>红色框内对应的服务端接受请求，也就是 sr 阶段，产生了一个 span 。红色框下面的这段代码是为当前这个 span 设置一些基本的信息，包括当前应用的应用名、当前请求的url、当前请求的请求方法以及请求大小。</p><h4 id="2-6-4-返回响应与结束-span"><a href="#2-6-4-返回响应与结束-span" class="headerlink" title="2.6.4 返回响应与结束 span"></a>2.6.4 返回响应与结束 span</h4><p>在 filter 链执行结束之后，在 finally 块中又补充了当前请求响应结果的一些信息到 span 中去。然后调用serverSend 结束当前 span。这里关于 serverSend 里面的逻辑就不展开说了，不过能够想到的是这里肯定是调用span.finish 这个方法( opentracing 规范中，span.finish 的执行标志着一个 span 的结束)，当前也会包括对于数据上报的一些逻辑处理等。</p><p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543395799817-68deb1fd-e481-4230-a338-3bbf8512a8f8.png" alt="img"></p><h2 id="3-思路总结与插件编写流程"><a href="#3-思路总结与插件编写流程" class="headerlink" title="3 思路总结与插件编写流程"></a>3 思路总结与插件编写流程</h2><p>在第2节中以 SpringMVC 插件为例，分析了下  SOFATracer 插件埋点实现的一些细节。那么本节则从整体思路上来总结下如何编写一个 SOFATracer 的插件。</p><ul><li>1、确定所要实现的插件，然后确定以哪种方式来埋点</li><li>2、实现当前插件的 Tracer 实例，这里需要明确当前插件是以 client 存在还是以 server 存在。</li><li>3、实现一个枚举类，用来描述当前组件的日志名称和滚动策略 key 值等</li><li>4、实现插件摘要日志的 encoder ，实现当前组件的定制化输出</li><li>5、实现插件的统计日志 Reporter 实现类，通过继承 AbstractSofaTracerStatisticReporter 类并重写doReportStat。</li><li><p>6、定义当前插件的传播格式</p><p>当然最重要的还是对于要实现插件的理解，要明确我们需要收集哪些数据。</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文先介绍了SOFATracer的埋点方式与标准OT-api 埋点方式的区别，然后对 SOFATracer 中 SpringMVC 插件的埋点实现进行了分析。希望通过本文能够让更多的同学理解埋点实现这样一个过程以及需要关注的一些点。如果有兴趣或者有什么实际的需求，欢迎来讨论。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;SOFATracer 是一个用于分布式系统调用跟踪的组件，通过统一的 &lt;code&gt;traceId&lt;/code&gt; 将调用链路中的各种网络调用情况以日志的方式记录下来，以达到透视化网络调用的目的。这些日志可用于故障的快速发现，服务治理等。&lt;/p&gt;
&lt;/
      
    
    </summary>
    
      <category term="SOFA" scheme="http://www.glmapper.com/categories/SOFA/"/>
    
    
      <category term="SOFATracer" scheme="http://www.glmapper.com/tags/SOFATracer/"/>
    
      <category term="Disruptor" scheme="http://www.glmapper.com/tags/Disruptor/"/>
    
      <category term="OpenTracing" scheme="http://www.glmapper.com/tags/OpenTracing/"/>
    
  </entry>
  
  <entry>
    <title>SpringSession系列-分布式Session实现方案</title>
    <link href="http://www.glmapper.com/2018/11/24/springsessionthree/"/>
    <id>http://www.glmapper.com/2018/11/24/springsessionthree/</id>
    <published>2018-11-24T08:55:33.000Z</published>
    <updated>2018-12-22T16:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章 <a href="https://juejin.im/post/5bdd449b6fb9a04a09557a40" target="_blank" rel="noopener">SpringSession：集成SpringBoot</a> 中介绍了如何在<code>SpringBoot</code>中来集成 <code>SpringSession</code>，整个过程非常简单，同时也简单分析了下<code>SpringSession</code>的作用原理。继上一篇实践之后，本文主要来分析 <code>SpringSession</code> 的原理。</p><h2 id="1、从-session-的一致性方案说起"><a href="#1、从-session-的一致性方案说起" class="headerlink" title="1、从 session 的一致性方案说起"></a>1、从 session 的一致性方案说起</h2><p>关于 <code>session</code> 和<code>cookie</code> 的一些知识，大家可以参考下我之前写的一篇文章：<a href="https://juejin.im/post/5aede266f265da0ba266e0ef" target="_blank" rel="noopener">聊一聊session和cookie</a>。</p><p><code>Session</code>作为服务器端使用的一种记录客户端状态的机制，其对客户端是透明的；但是<code>Session</code> 的正常运作仍然需要客户端浏览器的支持。我们都知道，<code>HTTP</code>协议是无状态的，<code>Session</code>不能依据<code>HTTP</code>连接来判断是否为同一客户，因此服务器需要向客户端浏览器发送一个识别标志（<code>sessionId</code>）,这个识别标志通过是通过<code>Cookie</code>机制来完成。</p><h3 id="1-1、session-一致性问题的由来"><a href="#1-1、session-一致性问题的由来" class="headerlink" title="1.1、session 一致性问题的由来"></a>1.1、session 一致性问题的由来</h3><p>当用户首次访问我们的<code>Servlet</code>时，应用服务器端会给用户创建一个独立的<code>Session</code>，并且存储在内存中。这种情况在单应用服务器场景下是可以满足的（这里不讨论其一个弊端，就是内存占用给服务器带来的压力的问题）。在集群场景下，这种机制就会到来问题：</p><h4 id="1-1-1、单机场景"><a href="#1-1-1、单机场景" class="headerlink" title="1.1.1、单机场景"></a>1.1.1、单机场景</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/4/166dee5cad0e35b8?w=968&amp;h=250&amp;f=png&amp;s=21829" alt=""></p><p>因为是一台应用服务器，用户的每次请求都是由这台机器来处理，所以不会有<code>session</code>共享问题。</p><h4 id="1-1-2、集群场景"><a href="#1-1-2、集群场景" class="headerlink" title="1.1.2、集群场景"></a>1.1.2、集群场景</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/4/166dee88ddb7d0ee?w=960&amp;h=608&amp;f=png&amp;s=42547" alt=""></p><p>假设现在集群中有三台机器，（从上到下：A-&gt;B-&gt;C）。当前用户首次发起访问时，请求被分配到 A 机器处理，<code>Session</code>数据被写入 A 机器的内存中；当再次发起访问 时，请求被分配的 B 处理，但此时 B 内存中并没有当前用户的任何数据，这样就出现了<code>session</code>不一致的情况了。</p><h3 id="1-2、Session-一致性问题的方案"><a href="#1-2、Session-一致性问题的方案" class="headerlink" title="1.2、Session 一致性问题的方案"></a>1.2、Session 一致性问题的方案</h3><p>对于当前服务化、单元化应用盛行的时代，简单的内存型的 <code>Session</code> 已经不能够满足我们的要求了。那么我们就需要寻求一种方案来替换目前单机内存存储实现的方案。</p><h4 id="1-2-1-基于-IP-HASH-的实现机制"><a href="#1-2-1-基于-IP-HASH-的实现机制" class="headerlink" title="1.2.1 基于 IP-HASH 的实现机制"></a>1.2.1 基于 IP-HASH 的实现机制</h4><p>在 1.1.2 中因为我们无法知道请求会被分配到哪台机器来处理，所以会导致<code>session</code>不一致的问题出现。如果我们可以解决让每个用户的请求能够固定的打到某一台机器上，那么上面提到的问题其实也就不存在了。<code>IP-HASH</code> 就是这样一种方案。通过对请求的客户端 <code>IP</code> 进行 <code>HASH</code> 计算，并将计算结果映射到具体一台机器，这样就可以将请求固定分配到某一台机器上，从而有效的避免<code>session</code>一致性问题的出现。</p><p>这种方案的好处在于:</p><ul><li>不需要修改任何应用代码，0 侵入。</li><li>安全性高，不依赖其他三方缓存框架带来的风险</li><li>成本低</li></ul><p>但是问题也很明显，这种方式实际上是规避了<code>session</code>一致性问题的出现，并非是针对<code>session</code>一致性问题给出的解决方案。主要问题：</p><ul><li>基于应用内存，会给应用服务器带来一定的压力</li><li>服务重启会导致<code>session</code>数据丢失</li><li>不利于水平扩展，水平扩展也可能丢失<code>session</code></li><li>存在单点负载高的情况，就是多数请求经过<code>HASH</code>计算之后打到同一台机器，而其他机器处于空闲状态。</li></ul><h4 id="1-2-2-session-复制"><a href="#1-2-2-session-复制" class="headerlink" title="1.2.2 session 复制"></a>1.2.2 session 复制</h4><p>这种方式的实现原理是应用服务器创建<code>session</code>之后通过组播的方式将<code>session</code>发送到组播地址内的其他应用服务器上。这种方式相较于<code>IP-HASH</code> 的方式要靠谱一点：</p><ul><li>同样不需要更改任何业务代码</li><li>能够适应多种负载策略</li><li>机器重启或者宕机之后不怕丢失，因为有冗余备份</li></ul><p>但是这种方式也有比较大的问题：</p><ul><li>首先就是服务器之间同步<code>session</code>会占用一定的网络资源，同时<code>session</code>在不同的机器之间进行同步存在延迟。</li><li>还是基于内存存储，局限于机器内存容量影响，水平扩展能力差</li><li>服务器内存因为需要存储其他机器上的<code>session</code>数据，对内存的消耗会随着集群的规模变大而变大，可能会导致机器频繁触发<code>GC</code>。</li></ul><h4 id="1-2-3-借助三方缓存框架实现-session-集中管理"><a href="#1-2-3-借助三方缓存框架实现-session-集中管理" class="headerlink" title="1.2.3 借助三方缓存框架实现 session 集中管理"></a>1.2.3 借助三方缓存框架实现 session 集中管理</h4><p>上面两种方式都是有服务器自己来管理<code>session</code>的，主要问题还是在于对于性能和内存的影响。而这种方式的原理是将<code>session</code>托管给三方软件（如<code>redis</code>）来统一管理。这种方式可以有效的解决性能、内存占用以及水平扩展等问题。但是因为引入了三方软件，在实现复杂度、运维成本等方面会有所增加。</p><p>目前所接触到的分布式<code>session</code>的实现方案，大多都是基于这种方式来实现的；<code>SpringSession</code> 也不例外。</p><h2 id="2、SpringSession-功能结构分析"><a href="#2、SpringSession-功能结构分析" class="headerlink" title="2、SpringSession 功能结构分析"></a>2、SpringSession 功能结构分析</h2><p>前面对分布式场景下的 <code>Session</code>一致性问题进行了说明，并对解决<code>Session</code>一致性的问题的几种策略进行的分析（有点糙，网上这些知识有很多）。在了解这些背景之后，我们来看下 <code>SpringSession</code> 的实现原理。</p><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p><code>Spring Session</code> 提供了用于管理用户会话信息的<code>API</code>和实现，在不依赖特定于应用程序容器的解决方案的情况下，使得支持群集会话变得更加简单。它还提供了透明的集成：</p><ul><li>允许以应用程序容器（<code>Tomcat</code>等）中立的方式替换 <code>HttpSesseion</code>，支持在 <code>headers</code>中提供 <code>session IDs</code>来使用 <code>RESTful API</code>。</li><li>提供在接收 <code>WebSocket</code> 消息时保持<code>HTTP</code> 会话存活的能力</li><li>允许以应用程序容器中立的方式替换 <code>Spring WebFlux</code> 的 <code>WebSession</code>。</li></ul><blockquote><p>以上来自官网文档翻译 <a href="https://github.com/spring-projects/spring-session" target="_blank" rel="noopener">Spring Session </a></p></blockquote><h3 id="2-2-模块"><a href="#2-2-模块" class="headerlink" title="2.2 模块"></a>2.2 模块</h3><p><code>Spring Session</code> 主要包括 4 个模块：</p><ul><li><code>spring-session-core</code> ：提供了 <code>Spring Session</code> 核心功能和<code>API</code></li><li><code>spring-session-data-redis</code>：以 <code>redis</code> 作为存储机制的 <code>SessionRepository</code> 实现</li><li><code>spring-session-hazelcast</code>：以 <code>Hazelcast</code> 作为存储机制的 <code>SessionRepository</code> 实现</li><li><code>spring-session-jdbc</code>：以关系型数据库作为存储机制的 <code>SessionRepository</code> 实现</li></ul><p>总体来说就是 核心<code>API</code>+存储实现；工程模块截图如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/4/166dec2555f6da9e?w=1070&amp;h=530&amp;f=png&amp;s=77929" alt=""></p><h3 id="2-3-功能结构"><a href="#2-3-功能结构" class="headerlink" title="2.3 功能结构"></a>2.3 功能结构</h3><p>SpringSession整体上可以分为三块：</p><ul><li>对于Web层的处理，这里包括对于请求的重写，自定义的filter加入到filter chain，cookie处理，http header处理等</li><li>公共基础封装，比如存储类的顶层抽象接口定义，自定配置，事件处理等。</li><li>存储部分，这部分实际上是对公共基础封装接口的实现，提供了丰富的存储实现，包括redis，内存存储，jdbc等。</li></ul><h3 id="2-4-多-session-支持"><a href="#2-4-多-session-支持" class="headerlink" title="2.4 多 session 支持"></a>2.4 多 session 支持</h3><p>对于常用的分布式session，在实现上一般会依赖于 cookie。但是在 springsession 中提供了基于header来传递jessionID的策略实现。同时在 2.0.4 版本之前，对于同一个浏览器同一个网站，springsession 支持多个<code>session</code>问题，但是在此版本之后抛弃了对于对 session 的支持。关于更多关于多session支持可以查看 SpringSession 的<a href="https://docs.spring.io/spring-session/docs/1.3.5.BUILD-SNAPSHOT/reference/html5/" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文对分布式 session 的几种实现策略进行了简单的介绍。对于分布式 session 而言，如何解决一致性问题是关键，目前我见过的绝大多数方案均是以 【借助三方缓存框架实现 session 集中管理】 这种来实现的，包括本系列文章中所要介绍的 SpringSession。</p><p>除分布式session一致性方式解决方案的介绍之外，作为SpringSession 的第二篇文章，在这里简单分析了下Springsession的功能模块，以便后续展开对源码的分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇文章 &lt;a href=&quot;https://juejin.im/post/5bdd449b6fb9a04a09557a40&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SpringSession：集成SpringBoot&lt;/a&gt; 中介绍了如何在&lt;cod
      
    
    </summary>
    
      <category term="spring" scheme="http://www.glmapper.com/categories/spring/"/>
    
      <category term="session" scheme="http://www.glmapper.com/categories/spring/session/"/>
    
    
      <category term="spring" scheme="http://www.glmapper.com/tags/spring/"/>
    
      <category term="session" scheme="http://www.glmapper.com/tags/session/"/>
    
  </entry>
  
  <entry>
    <title>SpringSession系列-请求与响应重写</title>
    <link href="http://www.glmapper.com/2018/11/24/springsessiontwo/"/>
    <id>http://www.glmapper.com/2018/11/24/springsessiontwo/</id>
    <published>2018-11-24T08:54:07.000Z</published>
    <updated>2018-12-22T16:56:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，<code>HttpServletRequset</code>和<code>HttpServletResponse</code>是<code>Servlet</code>标准所指定的<code>Java</code>语言与<code>Web</code>容器进行交互的接口。接口本身只规定<code>java</code>语言对<code>web</code>容器进行访问的行为方式，而具体的实现是由不同的<code>web</code>容器在其内部实现的。</p><p>那么在运行期，当我们需要对<code>HttpServletRequset</code>和<code>HttpServletResponse</code>的默认实例进行扩展时，我们就可以继承<code>HttpServletRequestWrapper</code>和<code>HttpServletResponseWrapper</code>来实现。<br>　　<br>在 <code>SpringSession</code>中因为我们要实现不依赖容器本身的<code>getSession</code> 实现，因此需要扩展 <code>HttpServletRequset</code>，通过重写<code>getSession</code>来实现分布式<code>session</code>的能力。下面就来看下<code>SpringSession</code>中对于<code>HttpServletRequset</code>的扩展。</p><h2 id="1、请求重写"><a href="#1、请求重写" class="headerlink" title="1、请求重写"></a>1、请求重写</h2><p><code>SpringSession</code> 中对于请求重写，在能力上主要体现在存储方面，也就是<code>getSession</code>方法上。在 <code>SessionRepositoryFilter</code> 这个类中，是通过内部类的方式实现了对<code>HttpServletRequset</code>和<code>HttpServletResponse</code>的扩展。</p><h3 id="1-1-HttpServletRequset-扩展实现"><a href="#1-1-HttpServletRequset-扩展实现" class="headerlink" title="1.1 HttpServletRequset 扩展实现"></a>1.1 HttpServletRequset 扩展实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionRepositoryRequestWrapper</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line"><span class="comment">// HttpServletResponse 实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HttpServletResponse response;</span><br><span class="line"><span class="comment">// ServletContext 实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServletContext servletContext;</span><br><span class="line">        <span class="comment">// requestedSession session对象</span></span><br><span class="line">        <span class="keyword">private</span> S requestedSession; </span><br><span class="line">        <span class="comment">// 是否缓存 session</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> requestedSessionCached;</span><br><span class="line"><span class="comment">// sessionId</span></span><br><span class="line"><span class="keyword">private</span> String requestedSessionId;</span><br><span class="line"><span class="comment">// sessionId 是否有效</span></span><br><span class="line"><span class="keyword">private</span> Boolean requestedSessionIdValid;</span><br><span class="line"><span class="comment">// sessionId 是否失效</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> requestedSessionInvalidated;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SessionRepositoryRequestWrapper</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response, ServletContext servletContext)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(request);</span><br><span class="line"><span class="keyword">this</span>.response = response;</span><br><span class="line"><span class="keyword">this</span>.servletContext = servletContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法里面将 <code>HttpServletRequest</code>、<code>HttpServletResponse</code> 以及 <code>ServletContext</code> 实例传递进来，以便于后续扩展使用。</p><h3 id="1-3-getSession-方法"><a href="#1-3-getSession-方法" class="headerlink" title="1.3 getSession 方法"></a>1.3 getSession 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpSessionWrapper <span class="title">getSession</span><span class="params">(<span class="keyword">boolean</span> create)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从当前请求线程中获取 session</span></span><br><span class="line">HttpSessionWrapper currentSession = getCurrentSession();</span><br><span class="line"><span class="comment">// 如果有直接返回</span></span><br><span class="line"><span class="keyword">if</span> (currentSession != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> currentSession;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从请求中获取 session，这里面会涉及到从缓存中拿session的过程</span></span><br><span class="line">S requestedSession = getRequestedSession();</span><br><span class="line"><span class="keyword">if</span> (requestedSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 无效的会话id(不支持的会话存储库)请求属性名称。</span></span><br><span class="line">    <span class="comment">// 这里看下当前的sessionId是否有效</span></span><br><span class="line"><span class="keyword">if</span> (getAttribute(INVALID_SESSION_ID_ATTR) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置当前session的最后访问时间，用于延迟session的有效期</span></span><br><span class="line">requestedSession.setLastAccessedTime(Instant.now());</span><br><span class="line"><span class="comment">// 将requestedSessionIdValid置为true</span></span><br><span class="line"><span class="keyword">this</span>.requestedSessionIdValid = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 包装session</span></span><br><span class="line">currentSession = <span class="keyword">new</span> HttpSessionWrapper(requestedSession, getServletContext());</span><br><span class="line"><span class="comment">// 不是新的session，如果是新的session则需要改变sessionId</span></span><br><span class="line">currentSession.setNew(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 将session设置到当前请求上下文</span></span><br><span class="line">setCurrentSession(currentSession);</span><br><span class="line"><span class="comment">// 返回session</span></span><br><span class="line"><span class="keyword">return</span> currentSession;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 这里处理的是无效的sessionId的情况，但是当前请求线程 session有效</span></span><br><span class="line"><span class="keyword">if</span> (SESSION_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">SESSION_LOGGER.debug(</span><br><span class="line"><span class="string">"No session found by id: Caching result for getSession(false) for this HttpServletRequest."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将invalidSessionId置为true</span></span><br><span class="line">setAttribute(INVALID_SESSION_ID_ATTR, <span class="string">"true"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 是否需要创建新的session</span></span><br><span class="line"><span class="keyword">if</span> (!create) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (SESSION_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">SESSION_LOGGER.debug(</span><br><span class="line"><span class="string">"A new session was created. To help you troubleshoot where the session was created we provided a StackTrace (this is not an error). You can prevent this from appearing by disabling DEBUG logging for "</span></span><br><span class="line">+ SESSION_LOGGER_NAME,</span><br><span class="line"><span class="keyword">new</span> RuntimeException(</span><br><span class="line"><span class="string">"For debugging purposes only (not an error)"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建新的session</span></span><br><span class="line">S session = SessionRepositoryFilter.<span class="keyword">this</span>.sessionRepository.createSession();</span><br><span class="line"><span class="comment">// 设置最后访问时间，也就是指定了当前session的有效期限</span></span><br><span class="line">session.setLastAccessedTime(Instant.now());</span><br><span class="line"><span class="comment">// 包装下当前session</span></span><br><span class="line">currentSession = <span class="keyword">new</span> HttpSessionWrapper(session, getServletContext());</span><br><span class="line"><span class="comment">//设置到当前请求线程</span></span><br><span class="line">setCurrentSession(currentSession);</span><br><span class="line"><span class="keyword">return</span> currentSession;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码有几个点，这里单独来解释下。</p><ul><li><code>getCurrentSession</code><ul><li>这是为了在同一个请求过程中不需要重复的去从存储中获取session，在一个新的进来时，将当前的 session 设置到当前请求中，在后续处理过程如果需要getSession就不需要再去存储介质中再拿一次。</li></ul></li><li><code>getRequestedSession</code><ul><li>这个是根据请求信息去取<code>session</code>，这里面就包括了<code>sessionId</code>解析，从存储获取<code>session</code>对象等过程。</li></ul></li><li>是否创建新的<code>session</code>对象   <ul><li>在当前请求中和存储中都没有获取到<code>session</code>信息的情况下，这里会根据<code>create</code>参数来判断是否创建新的<code>session</code>。这里一般用户首次登录时或者<code>session</code>失效时会走到。</li></ul></li></ul><h3 id="1-4-getRequestedSession"><a href="#1-4-getRequestedSession" class="headerlink" title="1.4 getRequestedSession"></a>1.4 getRequestedSession</h3><p>根据请求信息来获取<code>session</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> S <span class="title">getRequestedSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存的请求session是否存在</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.requestedSessionCached) &#123;</span><br><span class="line">            <span class="comment">// 获取 sessionId</span></span><br><span class="line">            List&lt;String&gt; sessionIds = SessionRepositoryFilter.<span class="keyword">this</span>.httpSessionIdResolver</span><br><span class="line">            .resolveSessionIds(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 通过sessionId来从存储中获取session</span></span><br><span class="line">            <span class="keyword">for</span> (String sessionId : sessionIds) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.requestedSessionId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.requestedSessionId = sessionId;</span><br><span class="line">            &#125;</span><br><span class="line">            S session = SessionRepositoryFilter.<span class="keyword">this</span>.sessionRepository</span><br><span class="line">            .findById(sessionId);</span><br><span class="line">            <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.requestedSession = session;</span><br><span class="line">            <span class="keyword">this</span>.requestedSessionId = sessionId;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.requestedSessionCached = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.requestedSession;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码还是很有意思的，这里获取<code>sessionId</code>返回的是个列表。当然这里是<code>SpringSession</code>的实现策略，因为支持<code>session</code>，所以这里以列表的形式返回的。OK，继续来看如何解析<code>sessionId</code>的：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744a467ce2ada6?w=1394&amp;h=200&amp;f=png&amp;s=80360" alt=""></p><p>这里可以看到<code>SpringSession</code>对于<code>sessionId</code>获取的两种策略，一种是基于<code>cookie</code>，一种是基于<code>header</code>；分别来看下具体实现。</p><h4 id="1-4-1-CookieHttpSessionIdResolver-获取-sessionId"><a href="#1-4-1-CookieHttpSessionIdResolver-获取-sessionId" class="headerlink" title="1.4.1 CookieHttpSessionIdResolver 获取 sessionId"></a>1.4.1 CookieHttpSessionIdResolver 获取 sessionId</h4><p><code>CookieHttpSessionIdResolver</code> 中获取<code>sessionId</code>的核心代码如下：<br><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744a7c7c05a32f?w=1360&amp;h=710&amp;f=png&amp;s=152689" alt=""><br>其实这里没啥好说的，就是读<code>cookie</code>。从<code>request</code>将<code>cookie</code>信息拿出来，然后遍历找当前<code>sessionId</code>对应的<code>cookie</code>,这里的判断也很简单， 如果是以<code>SESSION</code>开头，则表示是 <code>SessionId</code>，毕竟<code>cookie</code>是共享的，不只有<code>sessionId</code>，还有可能存储其他内容。</p><p>另外这里面有个 jvmRoute，这个东西实际上很少能够用到，因为大多数情况下这个值都是null。这个我们在分析<code>CookieSerializer</code>时再来解释。</p><h4 id="1-4-2-HeaderHttpSessionIdResolver-获取-sessionId"><a href="#1-4-2-HeaderHttpSessionIdResolver-获取-sessionId" class="headerlink" title="1.4.2 HeaderHttpSessionIdResolver 获取 sessionId"></a>1.4.2 HeaderHttpSessionIdResolver 获取 sessionId</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744b76477e1904?w=1144&amp;h=196&amp;f=png&amp;s=51550" alt=""><br>这个获取更直接粗暴，就是根据 <code>headerName</code> 从 <code>header</code> 中取值。</p><p>回到<code>getRequestedSession</code>，剩下的代码中核心的都是和<code>sessionRepository</code>这个有关系，这部分就会涉及到存储部分。不在本篇的分析范围之内，会在存储实现部分来分析。</p><h3 id="1-5-HttpSessionWrapper"><a href="#1-5-HttpSessionWrapper" class="headerlink" title="1.5 HttpSessionWrapper"></a>1.5 HttpSessionWrapper</h3><p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744bd83bd21c65?w=1436&amp;h=416&amp;f=png&amp;s=96267" alt=""></p><p>上面的代码中当我们拿到<code>session</code>实例是通常会包装下，那么用到的就是这个<code>HttpSessionWrapper</code>。</p><p><code>HttpSessionWrapper</code> 继承了 <code>HttpSessionAdapter</code>，这个<code>HttpSessionAdapter</code>就是将SpringSession 转换成一个标准<code>HttpSession</code>的适配类。<code>HttpSessionAdapter</code> 实现了标准<code>servlet</code>规范的<code>HttpSession</code>接口。</p><h4 id="1-5-1-HttpSessionWrapper"><a href="#1-5-1-HttpSessionWrapper" class="headerlink" title="1.5.1 HttpSessionWrapper"></a>1.5.1 HttpSessionWrapper</h4><p><code>HttpSessionWrapper</code> 重写了 <code>invalidate</code>方法。从代码来看，调用该方法产生的影响是：</p><ul><li><code>requestedSessionInvalidated</code> 置为<code>true</code>，标识当前 <code>session</code> 失效。</li><li>将当前请求中的<code>session</code>设置为<code>null</code>，那么在请求的后续调用中通过<code>getCurrentSession</code>将拿不到<code>session</code>信息。</li><li>当前缓存的 session 清楚，包括sessionId，session实例等。</li><li>删除存储介质中的session对象。</li></ul><h4 id="1-5-2-HttpSessionAdapter"><a href="#1-5-2-HttpSessionAdapter" class="headerlink" title="1.5.2 HttpSessionAdapter"></a>1.5.2 HttpSessionAdapter</h4><p><code>SpringSession</code>和标准<code>HttpSession</code>的配置器类。这个怎么理解呢，来看下一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getAttribute</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">checkState();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.session.getAttribute(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于基于容器本身实现的<code>HttpSession</code>来说，<code>getAttribute</code>的实现也是有容器本身决定。但是这里做了转换之后，<code>getAttribute</code>将会通过<code>SpringSession</code>中实现的方案来获取。其他的<code>API</code>适配也是基于此实现。</p><h3 id="SessionCommittingRequestDispatcher"><a href="#SessionCommittingRequestDispatcher" class="headerlink" title="SessionCommittingRequestDispatcher"></a>SessionCommittingRequestDispatcher</h3><p>实现了 <code>RequestDispatcher</code> 接口。关于<code>RequestDispatcher</code>可以参考这篇文章<a href="https://www.cnblogs.com/lulipro/p/7471987.html" target="_blank" rel="noopener">【Servlet】关于RequestDispatcher的原理</a>。<code>SessionCommittingRequestDispatcher</code>对<code>forward</code>的行为并没有改变。<br>对于<code>include</code>则是在<code>include</code>之前提交<code>session</code>。为什么这么做呢？</p><p> 因为<code>include</code>方法使原先的<code>Servlet</code>和转发到的<code>Servlet</code>都可以输出响应信息，即原先的<code>Servlet</code>还可以继续输出响应信息；即请求转发后，原先的<code>Servlet</code>还可以继续输出响应信息，转发到的<code>Servlet</code>对请求做出的响应将并入原先<code>Servlet</code>的响应对象中。 </p><p> 所以这个在<code>include</code>调用之前调用<code>commit</code>，这样可以确保被包含的<code>Servlet</code>程序不能改变响应消息的状态码和响应头。</p><h2 id="2-响应重写"><a href="#2-响应重写" class="headerlink" title="2 响应重写"></a>2 响应重写</h2><p>响应重写的目的是确保在请求提交时能够把session保存起来。来看下<code>SessionRepositoryResponseWrapper</code>类的实现：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744deabbf838ec?w=1140&amp;h=678&amp;f=png&amp;s=148489" alt=""><br>这里面实现还就是重写<code>onResponseCommitted</code>，也就是上面说的，在请求提交时能够通过这个回调函数将<code>session</code>保存到存储容器中。</p><h3 id="2-1-session-提交"><a href="#2-1-session-提交" class="headerlink" title="2.1 session 提交"></a>2.1 session 提交</h3><p>最后来看下 commitSession</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744e0fea8b3996?w=1374&amp;h=610&amp;f=png&amp;s=139692" alt=""></p><p>这个过程不会再去存储容器中拿<code>session</code>信息，而是直接从当前请求中拿。如果拿不到，则在回写<code>cookie</code>时会将当前<code>session</code>对应的<code>cookie</code>值设置为空，这样下次请求过来时携带的<code>sessionCookie</code>就是空，这样就会重新触发登陆。</p><p>如果拿到，则清空当前请求中的<code>session</code>信息，然后将<code>session</code>保存到存储容器中，并且将<code>sessionId</code>回写到<code>cookie</code>中。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇主要对<code>SpringSession</code>中重写<code>Request</code>和<code>Response</code>进行了分析。通过重写<code>Request</code>请求来将<code>session</code>的存储与存储容器关联起来，通过重写<code>Response</code>来处理<code>session</code>提交，将<code>session</code>保存到存储容器中。</p><p>后面我们会继续来分析<code>SpringSession</code>的源码。最近也在学习链路跟踪相关的技术，也准备写一写，有兴趣的同学可以一起讨论。</p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><ul><li><a href="https://github.com/alipay" target="_blank" rel="noopener">SOFA 开源社区</a></li><li><a href="https://github.com/alipay/sofa-tracer" target="_blank" rel="noopener">SOFATracer</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道，&lt;code&gt;HttpServletRequset&lt;/code&gt;和&lt;code&gt;HttpServletResponse&lt;/code&gt;是&lt;code&gt;Servlet&lt;/code&gt;标准所指定的&lt;code&gt;Java&lt;/code&gt;语言与&lt;code&gt;Web&lt;/code&gt;容器进行交
      
    
    </summary>
    
      <category term="spring" scheme="http://www.glmapper.com/categories/spring/"/>
    
      <category term="session" scheme="http://www.glmapper.com/categories/spring/session/"/>
    
    
      <category term="spring" scheme="http://www.glmapper.com/tags/spring/"/>
    
      <category term="session" scheme="http://www.glmapper.com/tags/session/"/>
    
  </entry>
  
</feed>
