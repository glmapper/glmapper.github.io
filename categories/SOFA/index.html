<!DOCTYPE html>
<!--[if IE 8]> <html lang="en" class="ie8 no-js"> <![endif]-->
<!--[if IE 9]> <html lang="en" class="ie9 no-js"> <![endif]-->
<!--[if !IE]><!-->
<html lang="en">
<!--<![endif]-->
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Category: SOFA | glmapper</title>

  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <meta name="description" content="从平凡的世界中全身而退">
<meta property="og:type" content="website">
<meta property="og:title" content="glmapper">
<meta property="og:url" content="http://www.glmapper.com/categories/SOFA/index.html">
<meta property="og:site_name" content="glmapper">
<meta property="og:description" content="从平凡的世界中全身而退">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="glmapper">
<meta name="twitter:description" content="从平凡的世界中全身而退">
  
    <link rel="alternative" href="/atom.xml" title="glmapper" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
    
  <meta content="{{ title }}" name="description">
  <meta content="{{ title }}" name="keywords">
  <meta content="{{ title }}" name="author">

  <link href="http://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700|PT+Sans+Narrow|Source+Sans+Pro:200,300,400,600,700,900&amp;subset=all" rel="stylesheet" type="text/css">

  <!-- Global styles START -->   
  <link rel="stylesheet" href="/metronic/assets/plugins/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/bootstrap/css/bootstrap.min.css">
  <!-- Global styles END --> 
   
  <!-- Page level plugin styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/animate.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/owl.carousel/assets/owl.carousel.css">
  <!-- Page level plugin styles END -->

  <!-- Theme styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/components.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/slider.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/portfolio.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style-responsive.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/themes/red.css">
  <link rel="stylesheet" href="/css/theme-styles.css">
  <!-- Theme styles END -->
</head>
</html>
<body class="corporate">
  <!-- BEGIN TOP BAR -->
<div class="pre-header">
  <div class="container">
    <div class="row">
      <!-- BEGIN TOP BAR LEFT PART -->
      <div class="col-md-6 col-sm-6 col-xs-9 additional-shop-info">
	<ul class="list-unstyled list-inline">
	  <li><i class="fa fa-phone"></i><span>716-472-4484</span></li>
	  <li><i class="fa fa-envelope-o"></i><span>ptsteadman@gmail.com</span></li>
	</ul>
      </div>
      <!-- END TOP BAR LEFT PART -->
      <!-- BEGIN TOP BAR MENU -->
      <div class="col-md-6 col-sm-6 col-xs-3 additional-nav">
	<ul class="list-unstyled list-inline pull-right">
	  <li><a href="/login">Log In</a></li>
	</ul>
      </div>
      <!-- END TOP BAR MENU -->
    </div>
  </div>        
</div>
<!-- END TOP BAR -->
<!-- BEGIN HEADER -->
<div class="header">
  <div class="container">
    <!--<a class="site-logo" href="/" id="logo">glmapper</a>-->

    <a class="site-logo" href="/">
      <img src="/metronic/assets/corporate/img/logos/logo-corp-red.png" alt="Metronic FrontEnd">
    </a>

    <a href="javascript:void(0);" class="mobi-toggler"><i class="fa fa-bars"></i></a>

    <!-- BEGIN NAVIGATION -->
    <div class="header-navigation pull-right font-transform-inherit">
      <ul>
	
	<li class="">
	  <a href="/">Home</a>
	</li>
	
	<li class="">
	  <a href="/projects/">Projects</a>
	</li>
	
	<li class="">
	  <a href="/archives/">Blog</a>
	</li>
	
	<li class="">
	  <a href="/contact/">Contact</a>
	</li>
	
	<li class="">
	  <a href="/about/">About</a>
	</li>
	
	<!-- BEGIN TOP SEARCH -->
	<li class="menu-search">
	  <span class="sep"></span>
	  <i class="fa fa-search search-btn"></i>
	  <div class="search-box">
	    <form action="#">
	      <div class="input-group">
		<input type="text" placeholder="Search" class="form-control st-default-search-input">
		<span class="input-group-btn">
		  <button class="btn btn-primary" type="submit">Search</button>
		</span>
	      </div>
	    </form>
	  </div> 
	</li>
	<!-- END TOP SEARCH -->
      </ul>
    </div>
    <!-- END NAVIGATION -->
  </div>
</div>
<!-- Header END -->

  <div class="container">
  <ul class="breadcrumb">
    <li><a href="/">Home</a></li>
    <li><a href="/blog">Blog</a></li>
    <li class="active">SOFA</li>
  </ul>
<section id="main">
 <h1>SOFA</h1>
 <div class="row">

<div class="col-xs-12 blog-posts">


  <section class="archives-wrap">
    <div class="archives">
      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2020/07/15/sofa-ark-container-mode/">SOFAArk 解析系列-容器模型</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2020-07-15T08:57:31.000Z" itemprop="datePublished">2020/07/15</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2020/07/15/sofa-ark-container-mode/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/sofa-ark/" title="sofa-ark">sofa-ark</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	
      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2020/07/15/sofa-ark-container-mode/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2020/01/20/sofa-tracer-integration-analysis/">一文详解蚂蚁金服分布式链路组件 SOFATracer 的埋点机制</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2020-01-20T03:43:56.000Z" itemprop="datePublished">2020/01/20</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2020/01/20/sofa-tracer-integration-analysis/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/SOFATracer/" title="SOFATracer">SOFATracer</a>,
  
    <a href="/tags/OpenTracing/" title="OpenTracing">OpenTracing</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>SOFATracer 是一个用于分布式系统调用跟踪的组件，通过统一的 TraceId 将调用链路中的各种网络调用情况以日志的方式记录下来，以达到透视化网络调用的目的，这些链路数据可用于故障的快速发现，服务治理等。</p>
<blockquote>
<p>GITHUB 地址：<a href="https://github.com/sofastack/sofa-tracer/pulls" target="_blank" rel="noopener">https://github.com/sofastack/sofa-tracer/pulls</a> （欢迎 star）<br>官方文件地址：<a href="https://www.sofastack.tech/projects/sofa-tracer/overview/" target="_blank" rel="noopener">https://www.sofastack.tech/projects/sofa-tracer/overview/</a></p>
</blockquote>
<p>2018 年末时至 2019 年初，SOFA 团队发起过 <a href="https://www.sofastack.tech/tags/%E5%89%96%E6%9E%90-sofatracer-%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">剖析-sofatracer-框架</a> 的源码解析系列文章。这个系列中，基本对 SOFATracer 所提供的能力及实现原理都做了比较全面的分析，有兴趣的同学可以看下。</p>
<p>从官方文档及 PR 来看，目前 SOFATracer 已经支持了对以下开源组件的埋点支持：</p>
<ul>
<li>Spring MVC</li>
<li>RestTemplate</li>
<li>HttpClient</li>
<li>OkHttp3</li>
<li>JDBC </li>
<li>Dubbo(2.6/2.7)</li>
<li>SOFARPC</li>
<li>Redis</li>
<li>MongoDB</li>
<li>Spring Message</li>
<li>Spring Cloud Stream (基于 Spring Message 的埋点)</li>
<li>RocketMQ</li>
<li>Spring Cloud FeignClient</li>
<li>Hystrix</li>
</ul>
<blockquote>
<p>大多数能力提供在 3.x 版本，2.x 版本从官方 issue 中可以看到后续将不在继续提供新的功能更新；这也是和 SpringBoot 宣布不在继续维护 1.x 版本有关系。</p>
</blockquote>
<p>本文将从插件的角度来分析，SOFATracer 是如何实现对上述组件进行埋点的；通过本文，除了了解 SOFATracer 的埋点机制之外，也可以对上述组件的基本扩展机制以及基本原理有一点学习。</p>
<h2 id="标准-Servlet-规范埋点原理"><a href="#标准-Servlet-规范埋点原理" class="headerlink" title="标准 Servlet 规范埋点原理"></a>标准 Servlet 规范埋点原理</h2><p>SOFATracer 支持对标准 Servlet 规范的 web mvc 埋点，包括普通的 servlet 和 Springmvc 等；基本原理就是基于 Servelt 规范所提供的 <code>javax.servlet.Filter</code> 过滤器接口扩展实现。</p>
<blockquote>
<p>过滤器位于 client 和 web 应用程序之间，用于检查和修改两者之间流过的请求和响应信息。在请求到达 Servlet 之前，过滤器截获请求。在响应送给客户端之前，过滤器截获响应。多个过滤器形成一个 FilterChain，FilterChain 中不同过滤器的先后顺序由部署文件 web.xml 中过滤器映射<filter-mapping>的顺序决定。最先截获客户端请求的过滤器将最后截获 Servlet 的响应信息。</filter-mapping></p>
</blockquote>
<p>web 应用程序一般作为请求的接收方，在 Tracer 中应用是作为 server 存在的，其在解析 SpanContext 时所对应的事件为 sr (server receive)。</p>
<p>SOFATracer 在 sofa-tracer-springmvc-plugin 插件中解析及产生 span 的过程大致如下：</p>
<ul>
<li>Servlet Filter 拦截到 request 请求</li>
<li>从请求中解析 SpanContext </li>
<li>通过 SpanContext 构建当前 MVC 的 span </li>
<li>给当前 span 设置 tag、log。</li>
<li>在 filter 处理的最后，结束 span。</li>
</ul>
<p>当然这里面还会设计到其他很多细节，比如给 span 设置哪些 tag 属性、如果处理异步线程透传等等。本篇不展开细节探讨，有兴趣的同学可以自行阅读代码或者和我交流。</p>
<h2 id="Dubbo-埋点原理"><a href="#Dubbo-埋点原理" class="headerlink" title="Dubbo 埋点原理"></a>Dubbo 埋点原理</h2><p>Dubbo 埋点在 SOFATracer 中实际上提供了两个插件，分别用于支持 Dubbo 2.6.x 和 Dubbo 2.7.x；Duddo 埋点也是基于 Filter ，此Filter 是 Dubbo 提供的 SPI 扩展-<a href="http://dubbo.apache.org/zh-cn/docs/dev/impls/filter.html" target="_blank" rel="noopener">调用拦截扩展</a> 机制实现。</p>
<p>像 Dubbo 或者 SOFARpc 等 rpc 框架的埋点，通常需要考虑的点比较多，首先是 rpc 框架分客户端和服务端，所以在埋点时 rpc 的客户端和服务端必须要有所区分；再者就是 rpc 的调用方式包括很多种，如常见的同步调用、异步调用、oneway 等等，调用方式不同，所对应的 span 的结束时机也不同，重要是的基本所有的 rpc 框架都会使用线程池用来发起和处理请求，那么如何保证 tracer 在多线程环境下不串也很重要。</p>
<p>另外 Dubbo 2.6.x 和 Dubbo 2.7.x 在异步回调处理上差异比较大，Dubbo 2.7.x 中提供了 onResponse 方法（后面又升级为 Listener，包括 onResponse 和 onError 两个方法）；而 Dubbo 2.6.x 中则并未提供相应的机制，只能通过对 future 的硬编码处理来完成埋点和上报。</p>
<blockquote>
<p>这个问题 zipkin brave 对 Dubbo 2.6.x 的埋点时其实也没有考虑到，在做 SOFATracer 支持 Dubbo 2.6.x 时发现了这个 bug，并做了修复。</p>
</blockquote>
<p>SOFATracer 中提供的 DubboSofaTracerFilter 类： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span>(group = &#123; CommonConstants.PROVIDER, CommonConstants.CONSUMER &#125;, value = <span class="string">"dubboSofaTracerFilter"</span>, order = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboSofaTracerFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// todo trace</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SOFATracer 中用于处理 Dubbo 2.6.x 版本中异步回调处理的核心代码：</p>
<blockquote>
<p>Dubbo 异步处理依赖 ResponseFuture 接口，但是 ResponseFuture 在核心链路上并非是以数据或者 list 的形式存在，所以在链路上只会存在一个 ResponseFuture，因此如果我自定义一个类来实现 ResponseFuture 接口是没法达到预期目的的，因为运行期会存在覆盖 ResponseFuture 的问题。所以在设计上，SOFATracer 会通过 ResponseFuture 构建一个新的 FutureAdapter出来用于传递。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">ensureSpanFinishes</span><span class="params">(Future&lt;Object&gt; future, Invocation invocation, Invoker&lt;?&gt; invoker)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> deferFinish = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (future <span class="keyword">instanceof</span> FutureAdapter) &#123;</span><br><span class="line">        deferFinish = <span class="keyword">true</span>;</span><br><span class="line">        ResponseFuture original = ((FutureAdapter&lt;Object&gt;) future).getFuture();</span><br><span class="line">        ResponseFuture wrapped = <span class="keyword">new</span> AsyncResponseFutureDelegate(invocation, invoker, original);</span><br><span class="line">        <span class="comment">// Ensures even if no callback added later, for example when a consumer, we finish the span</span></span><br><span class="line">        wrapped.setCallback(<span class="keyword">null</span>);</span><br><span class="line">        RpcContext.getContext().setFuture(<span class="keyword">new</span> FutureAdapter&lt;&gt;(wrapped));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deferFinish;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="http-客户端埋点原理"><a href="#http-客户端埋点原理" class="headerlink" title="http 客户端埋点原理"></a>http 客户端埋点原理</h2><p>http 客户端埋点包括 HttpClient、OkHttp、RestTemplate 等，此类埋点一般都是基于拦截器机制来实现的，如 HttpClient 使用的 HttpRequestInterceptor、HttpResponseInterceptor；OkHttp 使用的 okhttp3.Interceptor；RestTemplate 使用的 ClientHttpRequestInterceptor。</p>
<p>以 OkHttp 为例，简单分析下 http 客户端埋点的实现原理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取请求</span></span><br><span class="line">    Request request = chain.request();</span><br><span class="line">    <span class="comment">// 解析出 SpanContext ，然后构建 Span</span></span><br><span class="line">    SofaTracerSpan sofaTracerSpan = okHttpTracer.clientSend(request.method());</span><br><span class="line">    <span class="comment">// 发起具体的调用</span></span><br><span class="line">    Response response = chain.proceed(appendOkHttpRequestSpanTags(request, sofaTracerSpan));</span><br><span class="line">    <span class="comment">// 结束 span</span></span><br><span class="line">    okHttpTracer.clientReceive(String.valueOf(response.code()));</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Datasource-埋点原理"><a href="#Datasource-埋点原理" class="headerlink" title="Datasource 埋点原理"></a>Datasource 埋点原理</h2><p>和标准 servlet 规范实现一样，所有基于 <code>javax.sql.DataSource</code> 实现的 DataSource 均可以使用 SOFATracer 进行埋点。因为 DataSource 并没有提供像 Servlet 那样的过滤器或者拦截器，所以 SOFATracer 中没法直接通过常规的方式（Filter/SPI扩展拦截/拦截器等）进行埋点，而是使用了代理模式的方式来实现的。</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/tracers/datasource.jpg" alt=""></p>
<p>上图为 SOFATracer 中 DataSource 代理类实现的类继承结构体系；可以看出，SOFATracer 中自定义了一个 BaseDataSource 抽象类，该抽象类继承 <code>javax.sql.DataSource</code> 接口，SmartDataSource 作为 BaseDataSource 的唯一子类，也就是 SOFATracer 中所使用的 代理类。所以如果你使用了 <code>sofa-tracer-datasource-plugin</code> 插件的话，可以看到最终运行时的 Datasource 类型是 <code>com.alipay.sofa.tracer.plugins.datasource.SmartDataSource</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实际被代理的 datasource</span></span><br><span class="line">    <span class="keyword">protected</span> DataSource        delegate;</span><br><span class="line">    <span class="comment">//  sofatracer 中自定义的拦截器，用于对连接操作、db操作等进行拦截埋点</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;Interceptor&gt; interceptors;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Interceptor&gt; dataSourceInterceptors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Interceptor 主要包括以下三种类型：</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/tracers/datasourceinteceptor.jpg" alt=""></p>
<p>以 StatementTracerInterceptor 为例 StatementTracerInterceptor 将将会拦截到所有 PreparedStatement 接口的方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatementTracerInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tracer 类型为 client </span></span><br><span class="line">    <span class="keyword">private</span> DataSourceClientTracer clientTracer;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClientTracer</span><span class="params">(DataSourceClientTracer clientTracer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// tracer 对象实例</span></span><br><span class="line">        <span class="keyword">this</span>.clientTracer = clientTracer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 记录当前系统时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        String resultCode = SofaTracerConstant.RESULT_SUCCESS;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开始一个 span</span></span><br><span class="line">            clientTracer.startTrace(chain.getOriginalSql());</span><br><span class="line">            <span class="comment">// 执行</span></span><br><span class="line">            <span class="keyword">return</span> chain.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            resultCode = SofaTracerConstant.RESULT_FAILED;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 这里计算执行时间 System.currentTimeMillis() - start</span></span><br><span class="line">            <span class="comment">// 结束一个 span</span></span><br><span class="line">            clientTracer.endTrace(System.currentTimeMillis() - start, resultCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总体思路是，Datasource 通过组合的方式自定义一个代理类（实际上也可以理解为适配器模式中的对象适配模型方式），对所有目标对象的方式进行代理拦截，在执行具体的 sql 或者连接操作之前创建 datasource 的 span，在操作结束之后结束 span，并进行上报。</p>
<h2 id="消息埋点"><a href="#消息埋点" class="headerlink" title="消息埋点"></a>消息埋点</h2><p>消息框架组件包括很多，像常见的 RocketMQ、Kafka 等；处理各个组件自己提供的客户端之外，像 Spring 就提供了很多消息组件的封装，包括Spring Cloud Stream、Spring Integration、Spring Message 等等。SOFATracer 基于 Spring Message 标准实现了对常见消息组件和 Spring Cloud Stream 的埋点支持，同时也提供了基于 RocketMQ 客户端模式的埋点实现。</p>
<h3 id="Spring-Messaging-埋点实现原理"><a href="#Spring-Messaging-埋点实现原理" class="headerlink" title="Spring Messaging 埋点实现原理"></a>Spring Messaging 埋点实现原理</h3><p>spring-messaging 模块为集成 messaging api 和消息协议提供支持。这里我们先看一个 pipes-and-filters 架构模型：</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/mq/spring-messaging.jpg" alt=""></p>
<p>spring-messaging 的 support 模块中提供了各种不同的 MessageChannel 实现和 channel interceptor 支持，因此在对 spring-messaging 进行埋点时我们自然就会想到去使用 channel interceptor。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SOFATracer 实现的基于 spring-messaging 消息拦截器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaTracerChannelInterceptor</span> <span class="keyword">implements</span> <span class="title">ChannelInterceptor</span>, <span class="title">ExecutorChannelInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// todo trace</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// THIS IS ChannelInterceptor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 发送之前</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送后</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">postSend</span><span class="params">(Message&lt;?&gt; message, MessageChannel channel, <span class="keyword">boolean</span> sent)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成发送之后</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">afterSendCompletion</span><span class="params">(Message&lt;?&gt; message, MessageChannel channel, <span class="keyword">boolean</span> sent, @Nullable Exception ex)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收消息之前</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">preReceive</span><span class="params">(MessageChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收后</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Message&lt;?&gt; postReceive(Message&lt;?&gt; message, MessageChannel channel) &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成接收消息之后</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">afterReceiveCompletion</span><span class="params">(@Nullable Message&lt;?&gt; message, MessageChannel channel, @Nullable Exception ex)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 ChannelInterceptor 实现了消息传递全生命周期的管控，通过暴露出来的方法，可以轻松的实现各个阶段的扩展埋点。</p>
<h3 id="RocketMQ-埋点实现原理"><a href="#RocketMQ-埋点实现原理" class="headerlink" title="RocketMQ 埋点实现原理"></a>RocketMQ 埋点实现原理</h3><p>RocketMQ 本身是提供了对 Opentracing 规范支持的，由于其支持的版本较高，与 SOFATracer 所实现的 Opentracing 版本不一致，所以在一定程度上不兼容；因此 SOFATracer（opentracing 0.22.0 版本）自身又单独提供了 RocketMQ  的插件。</p>
<p>RocketMQ 埋点其实是通过两个 hook 接口来完成，实际上在 RocketMQ 的官方文档中貌似并没有提到这两个点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RocketMQ 消息消费端 hook 接口埋点实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaTracerConsumeMessageHook</span> <span class="keyword">implements</span> <span class="title">ConsumeMessageHook</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RocketMQ 消息发送端 hook 接口埋点实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaTracerSendMessageHook</span> <span class="keyword">implements</span> <span class="title">SendMessageHook</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>首先是 SendMessageHook 接口，SendMessageHook 接口提供了两个方法，sendMessageBefore 和 sendMessageAfter，SOFATracer 在实现埋点时，sendMessageBefore 中用来解析和构建 span，sendMessageAfter 中用于拿到结果然后结束 span。</p>
<p>同样的，ConsumeMessageHook 中也提供了两个方法（consumeMessageBefore和consumeMessageAfter），可以提供给 SOFATracer 来从消息中解析出透传的 tracer 信息然后再将 tracer 信息透传到下游链路中去。</p>
<h2 id="redis-埋点原理"><a href="#redis-埋点原理" class="headerlink" title="redis 埋点原理"></a>redis 埋点原理</h2><p>SOFATracer 中的 redis 埋点是基于 spring data redis 实现的，没有针对具体的 redis 客户端来埋点。另外 redis 埋点部分参考的是开源社区<a href="https://github.com/opentracing-contrib/java-spring-cloud/tree/master/instrument-starters/opentracing-spring-cloud-redis-starter" target="_blank" rel="noopener">opentracing-spring-cloud-redis-starter</a>中的实现逻辑。</p>
<p>redis 的埋点实现与 Datasource 的锚点实现基本思路是一致的，都是通过一层代理来是实现的拦截。<code>sofa-tracer-redis-plugin</code> 中对所有的 redis 操作都通过 RedisActionWrapperHelper 进行了一层包装，在执行具体的命令前后通过 SOFATracer 自己提供的 API 进行埋点操作。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">doInScope</span><span class="params">(String command, Supplier&lt;T&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建 span</span></span><br><span class="line">    Span span = buildSpan(command);</span><br><span class="line">    <span class="keyword">return</span> activateAndCloseSpan(span, supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 span 的生命周期内执行具体命令</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">activateAndCloseSpan</span><span class="params">(Span span, Supplier&lt;T&gt; supplier)</span> </span>&#123;</span><br><span class="line">    Throwable candidateThrowable = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行命令</span></span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        candidateThrowable = t;</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidateThrowable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过 tracer api 结束一个span</span></span><br><span class="line">        redisSofaTracer.clientReceiveTagFinish((SofaTracerSpan) span, <span class="string">"00"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之后 mongodb 的埋点也是基于 spring data 实现，埋点的实现思路和 redis 基本相同，这里就不在单独分析。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对蚂蚁金服分布式链路组件 SOFATracer 的埋点机制做了简要的介绍；从各个组件的埋点机制来看，整体思路就是对组件操作进行包装，在请求或者命令执行的前后进行 span 构建和上报。目前一些主流的链路跟踪组件像 brave 也是基于此思路，区别在于 brave 并非是直接基于 opentracing 规范进行编码，而是其自己封装了一整套 api ，然后通过面向 opentracing api 进行一层适配；另外一个非常流行的 skywalking 则是基于 java agent 实现，埋点实现的机制上与 SOFATracer 和 brave 不同。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.sofastack.tech/projects/sofa-tracer/overview/" target="_blank" rel="noopener">SOFATracer</a></li>
<li><a href="https://www.cnblogs.com/davidwang456/p/4446796.html" target="_blank" rel="noopener">spring源码分析之spring-messaging模块详解</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2020/01/20/sofa-tracer-integration-analysis/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2019/08/28/sofa-ark-plugin-rule/">ARK 插件基本规则及注意事项</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2019-08-28T12:20:46.000Z" itemprop="datePublished">2019/08/28</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2019/08/28/sofa-ark-plugin-rule/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/sofa-ark/" title="sofa-ark">sofa-ark</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>SOFAARK 是一个轻量级的类隔离框架，其有两个基本的能力：解决依赖包冲突和多应用(模块)合并部署。本篇将从解决依赖角度来说明下 SOFARK 插件的基本使用规则。</p>
<p>下图是官方文档中提供的用于描述依赖包冲突的一个场景：</p>
<p><img src="https://oscimg.oschina.net/oscnet/3d88c00093b96901187532a351c69ab8a91.jpg" alt=""></p>
<p>这里通过一个工程来模拟这种场景，然后通过将其中一个打包成插件的方式来解决。</p>
<h2 id="案例工程"><a href="#案例工程" class="headerlink" title="案例工程"></a>案例工程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── ark-main-project</span><br><span class="line">├── dependency-one</span><br><span class="line">├── dependency-two</span><br><span class="line">├── dependency-two-plugin</span><br></pre></td></tr></table></figure>
<ul>
<li>ark-main-project 为一个 简单的springboot 工程</li>
<li>dependency-one 依赖1，可以对应到图中的 dependency A</li>
<li>dependency-two 依赖2，可以对应到图中的 dependency B</li>
<li>dependency-two-plugin ，dependency-two 的插件包</li>
</ul>
<p>另外还有一个 dependency-incompatible 工程，用于描述冲突的依赖。</p>
<h3 id="dependency-incompatible"><a href="#dependency-incompatible" class="headerlink" title="dependency-incompatible"></a>dependency-incompatible</h3><p>dependency-incompatible 有两个版本 1.0 和 2.0 ，1.0 和 2.0 是不兼容的。</p>
<p><strong>1.0 版本中提供了两个方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IncompatibleUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test2"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.0 版本中提供了两个方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IncompatibleUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Incompatible.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Incompatible</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dependency-one"><a href="#dependency-one" class="headerlink" title="dependency-one"></a>dependency-one</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOneUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> IncompatibleUtil.test1()+IncompatibleUtil.test2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dependency-two"><a href="#dependency-two" class="headerlink" title="dependency-two"></a>dependency-two</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import org.springframework.util.StringUtils;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTwoUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testTwo</span><span class="params">(String param)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(param))&#123;</span><br><span class="line">            <span class="keyword">return</span> IncompatibleUtil.test1() + IncompatibleUtil.test3();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> IncompatibleUtil.test1() + IncompatibleUtil.test3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里引入 spring 的依赖查看是否会引入异常</p>
</blockquote>
<h3 id="ark-main-project"><a href="#ark-main-project" class="headerlink" title="ark-main-project"></a>ark-main-project</h3><p>ark-main-project 引入了 dependency-one 和 dependency-two 两个依赖，然后在启动类中分别调用 dependency-one 和 dependency-two  中提供的 api 。 <br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">        test(<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(param))&#123;</span><br><span class="line">            TestOneUtil testOneUtil = <span class="keyword">new</span> TestOneUtil();</span><br><span class="line">            System.out.println(testOneUtil.testOne());</span><br><span class="line">            TestTwoUtil testTwoUtil = <span class="keyword">new</span> TestTwoUtil();</span><br><span class="line">            System.out.println(testTwoUtil.testTwo(param));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no params"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 dependency-one 和 dependency-two 底层都都依赖了 dependency-incompatible ，且 dependency-incompatible 的两个版本不兼容，所以在启动时会报错。</p>
<p><img src="https://oscimg.oschina.net/oscnet/46005bbbf37f7063b90ff6a0bb4c46671bd.jpg" alt=""></p>
<h3 id="dependency-two-插件改造"><a href="#dependency-two-插件改造" class="headerlink" title="dependency-two 插件改造"></a>dependency-two 插件改造</h3><p>根据文档前面那张图的描述，这里需要将其中一个改造成插件的方式，使用独立的 classloader 来加载，从而达到版本兼容。这里改造 dependency-two 。</p>
<p>新建一个 dependency-two-plugin 模块，然后引入 dependency-two 依赖，并且将 冲突的 api 包导出</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dependency-two<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.glmapper.bridge.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-ark-plugin-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>default-cli<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>ark-plugin<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">exported</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">packages</span>&gt;</span></span><br><span class="line">                                	<span class="comment">&lt;!--导出冲突的 api --&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">package</span>&gt;</span>com.glmapper.bridge.boot.two<span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">packages</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">exported</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <br><strong>关于插件的导出，对于 dependency-two 中，ark-main-projet 中使用到的是 TestTwoUtil 这里类，因此仅需要将这个类导出即可。</strong></p>
<p>mvn clean install 安装到本地仓库，然后在 ark-main-project 中引用。</p>
<p>将 ark-main-project 中的 dependency-two 依赖修改为 dependency-two-plugin 。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.glmapper.bridge.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dependency-two-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为插件是运行在容器上的，所以也需要将 ark-main-project 改造成 ark 工程，具体可以参考官方文档。改造完成之后，打包 ark-main-project 工程，然后通过 java -jar 启动，运行结果如下，实现了类隔离。</p>
<p><img src="https://oscimg.oschina.net/oscnet/eb97a874c46677d31478c55b0dfde41e636.jpg" alt=""></p>
<h2 id="NoClassDefFoundError-异常的发生"><a href="#NoClassDefFoundError-异常的发生" class="headerlink" title="NoClassDefFoundError 异常的发生"></a>NoClassDefFoundError 异常的发生</h2><p>关于上面 SpringUtils 工具类在插件中和 BIZ 中均加载并且不会报错的解释是，SpringUtils 虽然在插件中和 BIZ 中都被加载了，但是没有报错，是因为没有触发 java 的 type check 机制。</p>
<p>那么还有一种情况会导致出现 java.lang.NoClassDefFoundError 异常，这种情况是在插件中将 spring 相关的包指定不打入插件了，配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exported</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">packages</span>&gt;</span></span><br><span class="line">       	<span class="tag">&lt;<span class="name">package</span>&gt;</span>com.glmapper.bridge.boot.two.*<span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">packages</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exported</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--不将 spring 的包打进去--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">excludeGroupIds</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludeGroupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">excludeGroupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludeGroupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">excludeGroupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludeGroupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">excludeGroupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">excludeGroupIds</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么这样打出的包实际上包的大小会非常小，但是问题在于运行时，插件从当前 /iib 目录下找不到 spring 相关的依赖，就会报  java.lang.NoClassDefFoundError 。</p>
<p><img src="https://oscimg.oschina.net/oscnet/0c05a61d784d74023cde395c1e098bc5282.jpg" alt=""></p>
<h2 id="LinkageError-异常的发生"><a href="#LinkageError-异常的发生" class="headerlink" title="LinkageError 异常的发生"></a><strong>LinkageError 异常的发生</strong></h2><p>ark-main-project 中</p>
<p><img src="https://oscimg.oschina.net/oscnet/f95211cb4c5e0051cc5ef4b314ae0e240e3.jpg" alt=""></p>
<p>dependency-two 中</p>
<p><img src="https://oscimg.oschina.net/oscnet/ae46e12edbee7e3a23a1504b7aa4cdbe1aa.jpg" alt=""></p>
<p>重新打包，然后执行</p>
<p><img src="https://oscimg.oschina.net/oscnet/2ef11727076f1b3e502ef59507bc820e040.jpg" alt=""></p>
<p>没有报错。此时插件中的类和 biz 中的类完全都是独立的。但是会存在一种情况，比如插件中有一个日志工具类，然后在 Biz 使用了这个工具类，则会报错。</p>
<p>在 dependency-two 中增加一个 LoggerUtil 的类，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(LoggerUtil.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        LOGGER.info(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getLogger</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LOGGER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 ark-main-project 中这样使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 使用 LoggerUtil 获取日志对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerUtil.getLogger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">        test(<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 记录日志</span></span><br><span class="line">        LOGGER.info(<span class="string">"test in biz."</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(param))&#123;</span><br><span class="line">            TestOneUtil testOneUtil = <span class="keyword">new</span> TestOneUtil();</span><br><span class="line">            System.out.println(testOneUtil.testOne());</span><br><span class="line">            TestTwoUtil testTwoUtil = <span class="keyword">new</span> TestTwoUtil();</span><br><span class="line">            System.out.println(testTwoUtil.testTwo(param));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no params"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况下就会导致报错</p>
<p><strong>Caused by: java.lang.LinkageError: loader constraint violation: loader (instance of com/alipay/sofa/ark/container/service/classloader/BizClassLoader) previously initiated loading for a different type with name “org/slf4j/Logger”</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerUtil.getLogger();</span><br></pre></td></tr></table></figure>
<p>单从这段代码来看，报错的原因在于，Logger LOGGER 的对象加载是被 BizClassLoader 加载的，但是 LoggerUtil.getLogger() 返回的对象是由 PluginClassLoader 加载的。</p>
<p>所以在构建插件时，需要尽可能的去规避可能出现引起类型检查的地方：</p>
<ul>
<li>方法参数检验</li>
<li>变量赋值</li>
<li>方法返回值</li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2019/08/28/sofa-ark-plugin-rule/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/12/07/sofa-tracer-mvc-plugin/">SOFATracer 插件埋点机制详解</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-12-07T14:34:14.000Z" itemprop="datePublished">2018/12/07</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/12/07/sofa-tracer-mvc-plugin/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/SOFATracer/" title="SOFATracer">SOFATracer</a>,
  
    <a href="/tags/Disruptor/" title="Disruptor">Disruptor</a>,
  
    <a href="/tags/OpenTracing/" title="OpenTracing">OpenTracing</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<blockquote>
<p>SOFATracer 是一个用于分布式系统调用跟踪的组件，通过统一的 <code>traceId</code> 将调用链路中的各种网络调用情况以日志的方式记录下来，以达到透视化网络调用的目的。这些日志可用于故障的快速发现，服务治理等。</p>
</blockquote>
<p>从 <a href="http://www.sofastack.tech/sofa-tracer/docs/roadmap" target="_blank" rel="noopener">RoadMap</a> 和 <a href="https://github.com/alipay/sofa-tracer/pulls" target="_blank" rel="noopener">PR</a> 来看，目前 SOFATracer 已经支持了丰富的组件插件埋点。</p>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543318400761-682a9d1a-b194-4a87-9fac-9e1a38a9247e.png" alt="img"></p>
<p>目前还未支持的主要是 Dubbo、MQ 以及 Redis 等。本文将从 SOFATracer 已提供的一个插件源码来分析下 SOFATracer 插件的埋点实现。</p>
<h2 id="1-SOFATracer-插件埋点机制"><a href="#1-SOFATracer-插件埋点机制" class="headerlink" title="1 SOFATracer 插件埋点机制"></a>1 SOFATracer 插件埋点机制</h2><p>SOFATracer 插件的作用实际上就是对于不同组件进行埋点，以便于收集这些组件的链路数据。SOFATracer 埋点方式一般是通过 Filter、Interceptor 机制实现的。</p>
<p>另一个是，SOFATracer 的埋点方式并不是基于 OT-api 进行埋点的，而是基于 SOFATracer 自己的 api 进行埋点的，详见 <a href="https://github.com/alipay/sofa-tracer/issues/126" target="_blank" rel="noopener">issue#126</a>。</p>
<h3 id="1-1-Filter-or-Interceptor"><a href="#1-1-Filter-or-Interceptor" class="headerlink" title="1.1 Filter or Interceptor"></a>1.1 Filter or Interceptor</h3><p>目前已实现的插件中，像 MVC 插件是基于 Filter 进行埋点的，httpclient、resttemplate 等是基于Interceptor进行埋点的。在实现插件时，要根据不同插件的特性来选择具体的埋点方式。</p>
<p> 当然除了这两种方式之外还可以通过静态代理的方式来实现埋点。比如 sofa-tracer-datasource-plugin 插件就是将不同的数据源进行统一代理给 SmartDatasource，从而实现埋点的。</p>
<h3 id="1-2-AbstractTracer-API"><a href="#1-2-AbstractTracer-API" class="headerlink" title="1.2 AbstractTracer API"></a>1.2 AbstractTracer API</h3><p>SOFATracer 中所有的插件均需要实现自己的 Tracer 实例，如 Mvc 的 SpringMvcTracer 、HttpClient的 HttpClientTracer 等，这一点与基于 Opentracing-api 接口埋点的实现有所区别。</p>
<ul>
<li>1、基于 SOFATracer api 埋点方式插件扩展</li>
</ul>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543324415543-aba1c5fe-7cb4-46ae-9aee-2fe5441a5f98.png" alt="img"></p>
<p>AbstractTracer 是 SOFATracer 用于插件扩展使用的一个抽象类，根据插件类型不同，又可以分为 clientTracer 和 serverTracer，分别对应于：AbstractClientTracer 和 AbstractServerTracer，再通过 AbstractClientTracer 和 AbstractServerTracer 衍生出具体的组件 Tracer 实现。这种方式的好处在于，所有的插件实现均由 SOFATracer 本身来管控，对于不同的组件可以轻松的实现差异化和定制化。缺点也源于此，每增加一个组件都需要做一些重复工作。</p>
<ul>
<li>2、基于 OpenTracing-api 埋点方式插件扩展</li>
</ul>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543324680485-cdb3793c-b830-490e-832f-b58e12091f7d.png" alt="img"></p>
<p>这种埋点方式不基于 SOFATracer  自身提供的 API，而是基于 OpenTracing-api 接口。因为均遵循 OpenTracing-api 规范，所以组件和 Tracer 实现可以独立分开来维护。这样就可以对接开源的一些基于 OpenTracing-api 规范实现的组件。例如：<a href="https://github.com/opentracing-contrib" target="_blank" rel="noopener">OpenTracing API Contributions</a>。</p>
<p>SOFATracer 在后面将会在 4.0 版本中支持基于 OT-api 的埋点方式，对外部组件接入扩展提供支持。</p>
<h3 id="1-3-AbstractTracer"><a href="#1-3-AbstractTracer" class="headerlink" title="1.3 AbstractTracer"></a>1.3 AbstractTracer</h3><p>这里先来看下 AbstractTracer  这个抽象类中具体提供了哪些抽象方法，也就是对于 AbstractClientTracer 和 AbstractServerTracer 需要分别扩展哪些能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取client端 摘要日志日志名</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getClientDigestReporterLogName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取client端 摘要日志滚动策略key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getClientDigestReporterRollingKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取client端 摘要日志日志名key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getClientDigestReporterLogNameKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取client端 摘要日志编码器</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getClientDigestEncoder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 创建client端 统计日志Reporter类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> AbstractSofaTracerStatisticReporter <span class="title">generateClientStatReporter</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志日志名</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getServerDigestReporterLogName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志滚动策略key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getServerDigestReporterRollingKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志日志名key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getServerDigestReporterLogNameKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志编码器</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getServerDigestEncoder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 创建server端 统计日志Reporter类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> AbstractSofaTracerStatisticReporter <span class="title">generateServerStatReporter</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>从  AbstractTracer 类提供的抽象方法来看，不管是 client 还是 server，在具体的 Tracer 组件实现中，都必须提供以下实现：</p>
<ul>
<li>DigestReporterLogName :当前组件摘要日志的日志名称</li>
<li>DigestReporterRollingKey : 当前组件摘要日志的滚动策略</li>
<li>SpanEncoder：对摘要日志进行编码的编码器实现</li>
<li>AbstractSofaTracerStatisticReporter : 统计日志 reporter 类的实现类。</li>
</ul>
<h2 id="2-SpringMVC-插件埋点分析"><a href="#2-SpringMVC-插件埋点分析" class="headerlink" title="2 SpringMVC 插件埋点分析"></a>2 SpringMVC 插件埋点分析</h2><p>这里我们以 SpringMVC 插件为例，来分析下如何实现一个埋点插件的。这里是官方给出的案例工程：基于 <a href="https://github.com/alipay/sofa-tracer/blob/master/tracer-samples/tracer-sample-with-springmvc" target="_blank" rel="noopener">Spring MVC 示例落地日志</a> 。</p>
<h3 id="2-1-实现-Tracer-实例"><a href="#2-1-实现-Tracer-实例" class="headerlink" title="2.1 实现 Tracer 实例"></a>2.1 实现 Tracer 实例</h3><p>SpringMvcTracer 继承了 AbstractServerTracer 类，是对 serverTracer 的扩展。</p>
<blockquote>
<p>PS：如何确定一个组件是client端还是server端呢？就是看当前组件是请求的发起方还是请求的接受方，如果是请求发起方则一般是client端，如果是请求接收方则是 server 端。那么对于 MVC 来说，是请求接受方，因此这里实现了 AbstractServerTracer 类。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcTracer</span> <span class="keyword">extends</span> <span class="title">AbstractServerTracer</span></span></span><br></pre></td></tr></table></figure>
<h4 id="2-1-1-构造函数与单例对象"><a href="#2-1-1-构造函数与单例对象" class="headerlink" title="2.1.1 构造函数与单例对象"></a>2.1.1 构造函数与单例对象</h4><p>在构造函数中，需要传入当前 Tracer 的 traceType，SpringMvcTracer 的 traceType 为 “springmvc”。这里也可以看到，tracer 实例是一个单例对象，对于其他插件也是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SpringMvcTracer springMvcTracer = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * Spring MVC Tracer Singleton</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> singleton</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SpringMvcTracer <span class="title">getSpringMvcTracerSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (springMvcTracer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SpringMvcTracer.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (springMvcTracer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                springMvcTracer = <span class="keyword">new</span> SpringMvcTracer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> springMvcTracer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SpringMvcTracer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"springmvc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-AbstractServerTracer-抽象类"><a href="#2-1-2-AbstractServerTracer-抽象类" class="headerlink" title="2.1.2 AbstractServerTracer 抽象类"></a>2.1.2 AbstractServerTracer 抽象类</h4><p>在看 SpringMvcTracer 实现之前，先来看下 AbstractServerTracer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractServerTracer</span> <span class="keyword">extends</span> <span class="title">AbstractTracer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数，子类必须提供一个构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractServerTracer</span><span class="params">(String tracerType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(tracerType, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为是server端，所以Client先关的提供了默认实现，返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getClientDigestReporterLogName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getClientDigestReporterRollingKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getClientDigestReporterLogNameKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getClientDigestEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AbstractSofaTracerStatisticReporter <span class="title">generateClientStatReporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合上面  AbstractTracer 小节中抽象方法分析，这里在 AbstractServerTracer 中将 client 对应的抽象方法提供了默认实现，也就是说如果要继承 AbstractServerTracer 类，那么就必须实现 server 对应的所有抽象方法。</p>
<h4 id="2-1-3-SpringMVCTracer-实现"><a href="#2-1-3-SpringMVCTracer-实现" class="headerlink" title="2.1.3 SpringMVCTracer 实现"></a>2.1.3 SpringMVCTracer 实现</h4><p>下面是 SpringMvcTracer 部分对 server 部分抽象方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getServerDigestReporterLogName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SpringMvcLogEnum.SPRING_MVC_DIGEST.getDefaultLogName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getServerDigestReporterRollingKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SpringMvcLogEnum.SPRING_MVC_DIGEST.getRollingKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getServerDigestReporterLogNameKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SpringMvcLogEnum.SPRING_MVC_DIGEST.getLogNameKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getServerDigestEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Boolean.TRUE.toString().equalsIgnoreCase(</span><br><span class="line">        SofaTracerConfiguration.getProperty(SPRING_MVC_JSON_FORMAT_OUTPUT))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringMvcDigestJsonEncoder();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringMvcDigestEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AbstractSofaTracerStatisticReporter <span class="title">generateServerStatReporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> generateSofaMvcStatReporter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前 SOFATracer 日志名、滚动策略key等都是通过枚举类来定义的，也就是一个组件会对应这样一个枚举类，在枚举类里面定义这些常量。</p>
<h3 id="2-2-SpringMvcLogEnum-类实现"><a href="#2-2-SpringMvcLogEnum-类实现" class="headerlink" title="2.2 SpringMvcLogEnum 类实现"></a>2.2 SpringMvcLogEnum 类实现</h3><p>SpringMVC 插件中的枚举类是 SpringMvcLogEnum。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SpringMvcLogEnum &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 摘要日志相关</span></span><br><span class="line">    SPRING_MVC_DIGEST(<span class="string">"spring_mvc_digest_log_name"</span>, </span><br><span class="line">                      <span class="string">"spring-mvc-digest.log"</span>,</span><br><span class="line">                      <span class="string">"spring_mvc_digest_rolling"</span>), </span><br><span class="line">    <span class="comment">// 统计日志相关</span></span><br><span class="line">    SPRING_MVC_STAT(<span class="string">"spring_mvc_stat_log_name"</span>, </span><br><span class="line">                    <span class="string">"spring-mvc-stat.log"</span>, </span><br><span class="line">                    <span class="string">"spring_mvc_stat_rolling"</span>);</span><br><span class="line">    <span class="comment">// 省略部分代码....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 XXXLogEnum 枚举类中定义了当前组件对应的摘要日志和统计日志的日志名和滚动策略，因为 SOFATracer 目前还没有服务端的能力，链路数据不是直接上报给 server 的，因此 SOFATracer 提供了落到磁盘的能力。不同插件的链路日志也会通过 XXXLogEnum 指定的名称将链路日志输出到各个组件对应的日志目录下。</p>
<h3 id="2-3-统计日志-Reportor-实现"><a href="#2-3-统计日志-Reportor-实现" class="headerlink" title="2.3 统计日志 Reportor 实现"></a>2.3 统计日志 Reportor 实现</h3><p>SOFATracer 中统计日志打印的实现需要各个组件自己来完成，具体就是需要实现一个AbstractSofaTracerStatisticReporter 的子类，然后实现 doReportStat 这个方法。当然对于目前的实现来说，我们也会重写 print 方法。</p>
<h4 id="2-3-1-doReportStat"><a href="#2-3-1-doReportStat" class="headerlink" title="2.3.1 doReportStat"></a>2.3.1 doReportStat</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doReportStat</span><span class="params">(SofaTracerSpan sofaTracerSpan)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; tagsWithStr = sofaTracerSpan.getTagsWithStr();</span><br><span class="line">    <span class="comment">// 构建StatMapKey对象</span></span><br><span class="line">    StatMapKey statKey = <span class="keyword">new</span> StatMapKey();</span><br><span class="line">    <span class="comment">// 增加 key:当前应用名</span></span><br><span class="line">    statKey.addKey(CommonSpanTags.LOCAL_APP, tagsWithStr.get(CommonSpanTags.LOCAL_APP));</span><br><span class="line">    <span class="comment">// 增加 key:请求 url</span></span><br><span class="line">    statKey.addKey(CommonSpanTags.REQUEST_URL, tagsWithStr.get(CommonSpanTags.REQUEST_URL));</span><br><span class="line">    <span class="comment">// 增加 key:请求方法</span></span><br><span class="line">    statKey.addKey(CommonSpanTags.METHOD, tagsWithStr.get(CommonSpanTags.METHOD));</span><br><span class="line">    <span class="comment">// 压测标志</span></span><br><span class="line">    statKey.setLoadTest(TracerUtils.isLoadTest(sofaTracerSpan));</span><br><span class="line">    <span class="comment">// 请求响应码</span></span><br><span class="line">    String resultCode = tagsWithStr.get(CommonSpanTags.RESULT_CODE);</span><br><span class="line">    <span class="comment">// 请求成功标识</span></span><br><span class="line">    <span class="keyword">boolean</span> success = (resultCode != <span class="keyword">null</span> &amp;&amp; resultCode.length() &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span></span><br><span class="line">        .isHttpOrMvcSuccess(resultCode));</span><br><span class="line">    statKey.setResult(success ? <span class="string">"true"</span> : <span class="string">"false"</span>);</span><br><span class="line">    <span class="comment">//end</span></span><br><span class="line">    statKey.setEnd(TracerUtils.getLoadTestMark(sofaTracerSpan));</span><br><span class="line">    <span class="comment">//value the count and duration</span></span><br><span class="line">    <span class="keyword">long</span> duration = sofaTracerSpan.getEndTime() - sofaTracerSpan.getStartTime();</span><br><span class="line">    <span class="keyword">long</span> values[] = <span class="keyword">new</span> <span class="keyword">long</span>[] &#123; <span class="number">1</span>, duration &#125;;</span><br><span class="line">    <span class="comment">// reserve</span></span><br><span class="line">    <span class="keyword">this</span>.addStat(statKey, values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这里就是就是将统计日志添加到日志槽里，等待被消费(输出到日志)。具体可以参考：SofaTracerStatisticReporterManager.StatReporterPrinter。</p>
<h4 id="2-3-2-print"><a href="#2-3-2-print" class="headerlink" title="2.3.2 print"></a>2.3.2 print</h4><p>print 方法是实际将数据写入到磁盘的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(StatKey statKey, <span class="keyword">long</span>[] values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isClosePrint.get()) &#123;</span><br><span class="line">        <span class="comment">//关闭统计日志输出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(statKey <span class="keyword">instanceof</span> StatMapKey)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StatMapKey statMapKey = (StatMapKey) statKey;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 构建需要打印的数据串</span></span><br><span class="line">        jsonBuffer.reset();</span><br><span class="line">        jsonBuffer.appendBegin();</span><br><span class="line">        jsonBuffer.append(<span class="string">"time"</span>, Timestamp.currentTime());</span><br><span class="line">        jsonBuffer.append(<span class="string">"stat.key"</span>, <span class="keyword">this</span>.statKeySplit(statMapKey));</span><br><span class="line">        jsonBuffer.append(<span class="string">"count"</span>, values[<span class="number">0</span>]);</span><br><span class="line">        jsonBuffer.append(<span class="string">"total.cost.milliseconds"</span>, values[<span class="number">1</span>]);</span><br><span class="line">        jsonBuffer.append(<span class="string">"success"</span>, statMapKey.getResult());</span><br><span class="line">        <span class="comment">//压测</span></span><br><span class="line">        jsonBuffer.appendEnd(<span class="string">"load.test"</span>, statMapKey.getEnd());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (appender <span class="keyword">instanceof</span> LoadTestAwareAppender) &#123;</span><br><span class="line">            ((LoadTestAwareAppender) appender).append(jsonBuffer.toString(),</span><br><span class="line">                statMapKey.isLoadTest());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            appender.append(jsonBuffer.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里强制刷一次</span></span><br><span class="line">        appender.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        SelfLog.error(<span class="string">"统计日志&lt;"</span> + statTracerName + <span class="string">"&gt;输出异常"</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>print 这个方法里面就是将 statMapKey 中，也就是 doReportStat 中塞进来的数据转换成  json 格式，然后刷到磁盘。需要注意的是这里是强制 flush 了一次。如果没有重写 print 这个方法的话，则是在SofaTracerStatisticReporterManager.StatReporterPrinter 里面调用 print 方法刷到磁盘。</p>
<h3 id="2-4-数据传播格式实现"><a href="#2-4-数据传播格式实现" class="headerlink" title="2.4 数据传播格式实现"></a>2.4 数据传播格式实现</h3><p>SOFATracer 支持使用 OpenTracing 的内建格式进行上下文传播。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcHeadersCarrier</span> <span class="keyword">implements</span> <span class="title">TextMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, String&gt; headers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpringMvcHeadersCarrier</span><span class="params">(HashMap&lt;String, String&gt; headers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.headers = headers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        headers.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> headers.entrySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-自定义编码格式实现"><a href="#2-5-自定义编码格式实现" class="headerlink" title="2.5 自定义编码格式实现"></a>2.5 自定义编码格式实现</h3><p>这个决定了摘要日志打印的格式，和在统计日志里面的实现要有所区分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcDigestJsonEncoder</span> <span class="keyword">extends</span> <span class="title">AbstractDigestSpanEncoder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重写encode,对span进行编码处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(SofaTracerSpan span)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        JsonStringBuilder jsonStringBuilder = <span class="keyword">new</span> JsonStringBuilder();</span><br><span class="line">        <span class="comment">//日志打印时间</span></span><br><span class="line">        jsonStringBuilder.appendBegin(<span class="string">"time"</span>, Timestamp.format(span.getEndTime()));</span><br><span class="line">        appendSlot(jsonStringBuilder, span);</span><br><span class="line">        <span class="keyword">return</span> jsonStringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具体字段处理</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendSlot</span><span class="params">(JsonStringBuilder jsonStringBuilder, SofaTracerSpan sofaTracerSpan)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        SofaTracerSpanContext context = sofaTracerSpan.getSofaTracerSpanContext();</span><br><span class="line">        Map&lt;String, String&gt; tagWithStr = sofaTracerSpan.getTagsWithStr();</span><br><span class="line">        Map&lt;String, Number&gt; tagWithNumber = sofaTracerSpan.getTagsWithNumber();</span><br><span class="line">        <span class="comment">//当前应用名</span></span><br><span class="line">        jsonStringBuilder</span><br><span class="line">            .append(CommonSpanTags.LOCAL_APP, tagWithStr.get(CommonSpanTags.LOCAL_APP));</span><br><span class="line">        <span class="comment">//TraceId</span></span><br><span class="line">        jsonStringBuilder.append(<span class="string">"traceId"</span>, context.getTraceId());</span><br><span class="line">        <span class="comment">//RpcId</span></span><br><span class="line">        jsonStringBuilder.append(<span class="string">"spanId"</span>, context.getSpanId());</span><br><span class="line">        <span class="comment">//请求 URL</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.REQUEST_URL,</span><br><span class="line">            tagWithStr.get(CommonSpanTags.REQUEST_URL));</span><br><span class="line">        <span class="comment">//请求方法</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.METHOD, tagWithStr.get(CommonSpanTags.METHOD));</span><br><span class="line">        <span class="comment">//Http 状态码</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.RESULT_CODE,</span><br><span class="line">            tagWithStr.get(CommonSpanTags.RESULT_CODE));</span><br><span class="line">        Number requestSize = tagWithNumber.get(CommonSpanTags.REQ_SIZE);</span><br><span class="line">        <span class="comment">//Request Body 大小 单位为byte</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.REQ_SIZE,</span><br><span class="line">            (requestSize == <span class="keyword">null</span> ? <span class="number">0L</span> : requestSize.longValue()));</span><br><span class="line">        Number responseSize = tagWithNumber.get(CommonSpanTags.RESP_SIZE);</span><br><span class="line">        <span class="comment">//Response Body 大小，单位为byte</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.RESP_SIZE, (responseSize == <span class="keyword">null</span> ? <span class="number">0L</span></span><br><span class="line">            : responseSize.longValue()));</span><br><span class="line">        <span class="comment">//请求耗时（MS）</span></span><br><span class="line">        jsonStringBuilder.append(<span class="string">"time.cost.milliseconds"</span>,</span><br><span class="line">            (sofaTracerSpan.getEndTime() - sofaTracerSpan.getStartTime()));</span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.CURRENT_THREAD_NAME,</span><br><span class="line">            tagWithStr.get(CommonSpanTags.CURRENT_THREAD_NAME));</span><br><span class="line">        <span class="comment">//穿透数据放在最后</span></span><br><span class="line">        jsonStringBuilder.appendEnd(<span class="string">"baggage"</span>, baggageSerialized(context));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里其实也可以看出，统计日志和摘要日志的不同点。统计日志里面核心的数据是 span 里面的 tags 数据，但是其主要作用是统计当前组件的次数。摘要日志里面除了 tags 里面的数据之外还会包括例如 traceId 和 spanId 等信息。</p>
<ul>
<li>统计日志</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"time"</span>:<span class="string">"2018-11-28 14:42:25.127"</span>,<span class="attr">"stat.key"</span>:&#123;<span class="attr">"method"</span>:<span class="string">"GET"</span>,<span class="attr">"local.app"</span>:<span class="string">"SOFATracerSpringMVC"</span>,<span class="attr">"request.url"</span>:<span class="string">"http://localhost:8080/springmvc"</span>&#125;,<span class="attr">"count"</span>:<span class="number">3</span>,<span class="attr">"total.cost.milliseconds"</span>:<span class="number">86</span>,<span class="attr">"success"</span>:<span class="string">"true"</span>,<span class="attr">"load.test"</span>:<span class="string">"F"</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>摘要日志</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"time"</span>:<span class="string">"2018-11-28 14:46:08.216"</span>,<span class="attr">"local.app"</span>:<span class="string">"SOFATracerSpringMVC"</span>,<span class="attr">"traceId"</span>:<span class="string">"0a0fe91b1543387568214100259231"</span>,<span class="attr">"spanId"</span>:<span class="string">"0.1"</span>,<span class="attr">"request.url"</span>:<span class="string">"http://localhost:8080/springmvc"</span>,<span class="attr">"method"</span>:<span class="string">"GET"</span>,<span class="attr">"result.code"</span>:<span class="string">"200"</span>,<span class="attr">"req.size.bytes"</span>:<span class="number">-1</span>,<span class="attr">"resp.size.bytes"</span>:<span class="number">0</span>,<span class="attr">"time.cost.milliseconds"</span>:<span class="number">2</span>,<span class="attr">"current.thread.name"</span>:<span class="string">"http-nio-8080-exec-2"</span>,<span class="attr">"baggage"</span>:<span class="string">""</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-请求拦截埋点"><a href="#2-6-请求拦截埋点" class="headerlink" title="2.6 请求拦截埋点"></a>2.6 请求拦截埋点</h3><p>对于基于标准 servlet 实现的组件，要实现对请求的拦截过滤，通常就是 Filter 了。sofa-tracer-springmvc-plugin 插件埋点的实现就是基于 Filter 机制完成的。</p>
<p>SpringMvcSofaTracerFilter 实现了 javax.servlet.Filter 接口，因此遵循标准的 servlet 规范的容器也可以通过此插件进行埋点。参考文档：<a href="https://github.com/alipay/sofa-tracer/tree/master/tracer-samples/tracer-sample-with-springmvc" target="_blank" rel="noopener">对于标准 servlet 容器的支持（ tomcat/jetty 等）</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcSofaTracerFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span></span><br></pre></td></tr></table></figure>
<h4 id="2-6-1-基本埋点思路"><a href="#2-6-1-基本埋点思路" class="headerlink" title="2.6.1 基本埋点思路"></a>2.6.1 基本埋点思路</h4><p>对于一个组件来说，一次处理过程一般是产生一个 span。这个span的生命周期是从接收到请求到返回响应这段过程。</p>
<p>但是这里需要考虑的问题是如何与上下游链路关联起来呢？在 Opentracing 规范中，可以在 Tracer 中 extract 出一个跨进程传递的 SpanContext 。然后通过这个 SpanContext 所携带的信息将当前节点关联到整个 tracer 链路中去。当然有提取(extract)就会有对应的注入(inject)。</p>
<p>链路的构建一般是 client-server-client-server 这种模式的，那这里就很清楚了，就是会在 client 端进行注入(inject)，然后再 server 端进行提取(extract)，反复进行，然后一直传递下去。</p>
<p> 在拿到 SpanContext 之后，此时当前的 span 就可以关联到这条链路中了，那么剩余的事情就是收集当前组件的一些数据。</p>
<p>整个过程大概分为以下几个阶段：</p>
<ul>
<li>从请求中提取 spanContext</li>
<li>构建 span，并将当前 span 存入当前 tracer上下文中（SofaTraceContext.push(span)） 。</li>
<li>设置一些信息到span中</li>
<li>返回响应</li>
<li>span结束&amp;上报</li>
</ul>
<p>下面逐一分析下这几个过程。</p>
<h4 id="2-6-2-从请求中提取-spanContext"><a href="#2-6-2-从请求中提取-spanContext" class="headerlink" title="2.6.2 从请求中提取 spanContext"></a>2.6.2 从请求中提取 spanContext</h4><p>这里的提取用到了上面我们提到的#数据传播格式实现#SpringMvcHeadersCarrier 这个类。上面分析到，因为mvc 做作为 server 端存在的，所以在 server 端就是从请求中 extract 出 SpanContext。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SofaTracerSpanContext <span class="title">getSpanContextFromRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="comment">// 获取请求头信息 </span></span><br><span class="line">    Enumeration headerNames = request.getHeaderNames();</span><br><span class="line">    <span class="keyword">while</span> (headerNames.hasMoreElements()) &#123;</span><br><span class="line">        String key = (String) headerNames.nextElement();</span><br><span class="line">        String value = request.getHeader(key);</span><br><span class="line">        headers.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿到 SofaTracer 实例对象</span></span><br><span class="line">    SofaTracer tracer = springMvcTracer.getSofaTracer();</span><br><span class="line">    <span class="comment">// 解析出 SofaTracerSpanContext（SpanContext的实现类）</span></span><br><span class="line">    SofaTracerSpanContext spanContext = (SofaTracerSpanContext) tracer.extract(</span><br><span class="line">        ExtendFormat.Builtin.B3_HTTP_HEADERS, <span class="keyword">new</span> SpringMvcHeadersCarrier(headers));</span><br><span class="line">    spanContext.setSpanId(spanContext.nextChildContextId());</span><br><span class="line">    <span class="keyword">return</span> spanContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-6-3-获取-span-amp-数据获取"><a href="#2-6-3-获取-span-amp-数据获取" class="headerlink" title="2.6.3 获取 span &amp; 数据获取"></a>2.6.3 获取 span &amp; 数据获取</h4><p>serverReceive 这个方法是在 AbstractTracer 类中提供了实现，子类不需要关注这个。在 SOFATracer 中将请求大致分为以下几个过程：</p>
<ul>
<li>客户端发送请求  clientSend      cs</li>
<li>服务端接受请求  serverReceive sr</li>
<li>服务端返回结果  serverSend     ss</li>
<li>客户端接受结果  clientReceive  cr</li>
</ul>
<p>无论是哪个插件，在请求处理周期内都可以从上述几个阶段中找到对应的处理方法。因此，SOFATracer 对这几个阶段处理进行了封装。这四个阶段实际上会产生两个 span，第一个 span 的起点是 cs，到 cr 结束；第二个 span是从 sr 开始，到 ss 结束。也就是说当执行 clientSend 和 serverReceive 时会返回一个 span 对象。来看下MVC中的实现：</p>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543395049905-22e60dd7-1b88-4d94-9b2d-39c94ce909c7.png" alt="img"></p>
<p>红色框内对应的服务端接受请求，也就是 sr 阶段，产生了一个 span 。红色框下面的这段代码是为当前这个 span 设置一些基本的信息，包括当前应用的应用名、当前请求的url、当前请求的请求方法以及请求大小。</p>
<h4 id="2-6-4-返回响应与结束-span"><a href="#2-6-4-返回响应与结束-span" class="headerlink" title="2.6.4 返回响应与结束 span"></a>2.6.4 返回响应与结束 span</h4><p>在 filter 链执行结束之后，在 finally 块中又补充了当前请求响应结果的一些信息到 span 中去。然后调用serverSend 结束当前 span。这里关于 serverSend 里面的逻辑就不展开说了，不过能够想到的是这里肯定是调用span.finish 这个方法( opentracing 规范中，span.finish 的执行标志着一个 span 的结束)，当前也会包括对于数据上报的一些逻辑处理等。</p>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543395799817-68deb1fd-e481-4230-a338-3bbf8512a8f8.png" alt="img"></p>
<h2 id="3-思路总结与插件编写流程"><a href="#3-思路总结与插件编写流程" class="headerlink" title="3 思路总结与插件编写流程"></a>3 思路总结与插件编写流程</h2><p>在第2节中以 SpringMVC 插件为例，分析了下  SOFATracer 插件埋点实现的一些细节。那么本节则从整体思路上来总结下如何编写一个 SOFATracer 的插件。</p>
<ul>
<li>1、确定所要实现的插件，然后确定以哪种方式来埋点</li>
<li>2、实现当前插件的 Tracer 实例，这里需要明确当前插件是以 client 存在还是以 server 存在。</li>
<li>3、实现一个枚举类，用来描述当前组件的日志名称和滚动策略 key 值等</li>
<li>4、实现插件摘要日志的 encoder ，实现当前组件的定制化输出</li>
<li>5、实现插件的统计日志 Reporter 实现类，通过继承 AbstractSofaTracerStatisticReporter 类并重写doReportStat。</li>
<li><p>6、定义当前插件的传播格式</p>
<p>当然最重要的还是对于要实现插件的理解，要明确我们需要收集哪些数据。</p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文先介绍了SOFATracer的埋点方式与标准OT-api 埋点方式的区别，然后对 SOFATracer 中 SpringMVC 插件的埋点实现进行了分析。希望通过本文能够让更多的同学理解埋点实现这样一个过程以及需要关注的一些点。如果有兴趣或者有什么实际的需求，欢迎来讨论。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/12/07/sofa-tracer-mvc-plugin/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/16/sofa-boot-health-analizy/">SOFABoot 健康检查能力分析</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-16T11:10:03.000Z" itemprop="datePublished">2018/11/16</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/16/sofa-boot-health-analizy/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/SOFABoot/" title="SOFABoot">SOFABoot</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<h2 id="Liveness-Check-amp-Readiness-Check"><a href="#Liveness-Check-amp-Readiness-Check" class="headerlink" title="Liveness Check &amp;  Readiness Check"></a>Liveness Check &amp;  Readiness Check</h2><p><code>Spring Boot</code> 提供了一个基础的健康检查的能力，中间件和应用都可以扩展来实现自己的健康检查逻辑。但是 Spring Boot 的健康检查只有 <code>Liveness Check</code> 的能力，缺少 <code>Readiness Check</code> 的能力，这样会有比较致命的问题。当一个微服务应用启动的时候，必须要先保证启动后应用是健康的，才可以将上游的流量放进来（来自于 RPC，网关，定时任务等等流量），否则就可能会导致一定时间内大量的错误发生。</p>
<p>针对 <code>Spring Boot</code> 缺少 <code>Readiness Check</code> 能力的情况，<code>SOFABoot</code> 增加了 <code>Spring Boot</code> 现有的健康检查的能力，提供了 <code>Readiness Check</code> 的能力。利用 <code>Readiness Check</code> 的能力，<code>SOFA</code> 中间件中的各个组件只有在 <code>Readiness Check</code> 通过之后，才将流量引入到应用的实例中，比如 <code>RPC</code>，只有在 <code>Readiness Check</code> 通过之后，才会向服务注册中心注册，后面来自上游应用的流量才会进入。</p>
<p>除了中间件可以利用 <code>Readiness Check</code> 的事件来控制流量的进入之外，<code>PAAS</code> 系统也可以通过访问 <code>http://localhost:8080/actuator/readiness</code> 来获取应用的 <code>Readiness Check</code> 的状况，用来控制例如负载均衡设备等等流量的进入。</p>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p><code>SOFABoot</code> 的健康检查能力需要引入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>healthcheck-sofa-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>区别于<code>SpringBoot</code>的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>详细工程科参考：<a href="https://github.com/alipay/" target="_blank" rel="noopener">sofa-boot</a></p>
</blockquote>
<h3 id="健康检查启动日志"><a href="#健康检查启动日志" class="headerlink" title="健康检查启动日志"></a>健康检查启动日志</h3><p><img src="https://user-gold-cdn.xitu.io/2018/11/16/1671b3e9d1e81110?w=1592&amp;h=322&amp;f=png&amp;s=360160" alt=""></p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>既然是个Starter，那么就先从 <strong>spring.factories</strong> 文件来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">com.alipay.sofa.healthcheck.initializer.SofaBootHealthCheckInitializer</span><br><span class="line"></span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.alipay.sofa.healthcheck.configuration.SofaBootHealthCheckAutoConfiguration</span><br></pre></td></tr></table></figure>
<h4 id="SofaBootHealthCheckInitializer"><a href="#SofaBootHealthCheckInitializer" class="headerlink" title="SofaBootHealthCheckInitializer"></a>SofaBootHealthCheckInitializer</h4><p><code>SofaBootHealthCheckInitializer</code> 实现了 <code>ApplicationContextInitializer</code> 接口。</p>
<p><code>ApplicationContextInitializer</code> 是 <code>Spring</code> 框架原有的概念，这个类的主要目的就是在            <code>ConfigurableApplicationContext</code> 类型（或者子类型）的 <code>ApplicationContext</code> 做 <code>refresh</code> 之前，允许我们                   对 <code>ConfigurableApplicationContext</code> 的实例做进一步的设置或者处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaBootHealthCheckInitializer</span> <span class="keyword">implements</span> <span class="title">ApplicationContextInitializer</span>&lt;<span class="title">ConfigurableApplicationContext</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        Environment environment = applicationContext.getEnvironment();</span><br><span class="line">        <span class="keyword">if</span> (SOFABootEnvUtils.isSpringCloudBootstrapEnvironment(environment)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// init logging.level.com.alipay.sofa.runtime argument</span></span><br><span class="line">        String healthCheckLogLevelKey = Constants.LOG_LEVEL_PREFIX</span><br><span class="line">                                        + HealthCheckConstants.SOFABOOT_HEALTH_LOG_SPACE;</span><br><span class="line">        SofaBootLogSpaceIsolationInit.initSofaBootLogger(environment, healthCheckLogLevelKey);</span><br><span class="line">      SofaBootHealthCheckLoggerFactory.getLogger(SofaBootHealthCheckInitializer.class).info(</span><br><span class="line">            <span class="string">"SOFABoot HealthCheck Starting!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SofaBootHealthCheckInitializer</code> 在 <code>initialize</code> 方法中主要做了两件事：</p>
<ul>
<li>验证当前 <code>environment</code> 是否是 <code>SpringCloud</code> 的（3.0.0 开始支持 <code>springCloud</code>，之前版本无此 <code>check</code>）</li>
<li>初始化 <code>logging.level</code> </li>
</ul>
<p>这两件事和健康检查没有什么关系，但是既然放在这个模块里面还是来看下。</p>
<h4 id="1、springCloud-环境验证"><a href="#1、springCloud-环境验证" class="headerlink" title="1、springCloud 环境验证"></a>1、springCloud 环境验证</h4><p>首先就是为什么会有这个验证。<code>SOFABoot</code> 在支持 <code>SpringcLoud</code> 时遇到一个问题，就是当在 <code>classpath</code> 中添加<code>spring-cloud-context</code> 依赖关系时,<code>org.springframework.context.ApplicationContextInitializer</code>会被调用两次。具体背景可参考 <a href="https://github.com/spring-cloud/spring-cloud-config/issues/1151" target="_blank" rel="noopener"># issue1151</a>  &amp;&amp; <a href="https://github.com/alipay/sofa-boot/issues/232" target="_blank" rel="noopener"># issue 232</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SPRING_CLOUD_MARK_NAME = <span class="string">"org.springframework.cloud.bootstrap.BootstrapConfiguration"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSpringCloudBootstrapEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">        <span class="keyword">return</span> !((ConfigurableEnvironment) environment).getPropertySources().contains(</span><br><span class="line">            SofaBootInfraConstants.SOFA_BOOTSTRAP)</span><br><span class="line">               &amp;&amp; isSpringCloud();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSpringCloud</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ClassUtils.isPresent(SPRING_CLOUD_MARK_NAME, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码是 <code>SOFABoot</code> 提供的一个用于区分 引导上下文  和 应用上下文 的方法：</p>
<ul>
<li>检验是否有<code>&quot;org.springframework.cloud.bootstrap.BootstrapConfiguration&quot;</code>这个类来判断当前是否引入了<code>spingCloud</code>的引导配置类</li>
<li>从<code>environment</code> 中获取 <code>MutablePropertySources</code> 实例，验证 <code>MutablePropertySources</code> 中是否包括 <code>sofaBootstrap</code> （ 如果当前环境是 <code>SOFA bootstrap environment</code>，则包含 <code>sofaBootstrap</code>；这个是在 <code>SofaBootstrapRunListener</code> 回调方法中设置进行的 ）</li>
</ul>
<h4 id="2、初始化-logging-level"><a href="#2、初始化-logging-level" class="headerlink" title="2、初始化 logging.level"></a>2、初始化 logging.level</h4><p>这里是处理 <code>SOFABoot</code> 日志空间隔离的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initSofaBootLogger</span><span class="params">(Environment environment, String runtimeLogLevelKey)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 logging.path 参数</span></span><br><span class="line">    String loggingPath = environment.getProperty(Constants.LOG_PATH);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(loggingPath)) &#123;</span><br><span class="line">        System.setProperty(Constants.LOG_PATH, environment.getProperty(Constants.LOG_PATH));</span><br><span class="line">        ReportUtil.report(<span class="string">"Actual "</span> + Constants.LOG_PATH + <span class="string">" is [ "</span> + loggingPath + <span class="string">" ]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for example : init logging.level.com.alipay.sofa.runtime argument</span></span><br><span class="line">    String runtimeLogLevelValue = environment.getProperty(runtimeLogLevelKey);</span><br><span class="line">    <span class="keyword">if</span> (runtimeLogLevelValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.setProperty(runtimeLogLevelKey, runtimeLogLevelValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init file.encoding</span></span><br><span class="line">    String fileEncoding = environment.getProperty(Constants.LOG_ENCODING_PROP_KEY);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(fileEncoding)) &#123;</span><br><span class="line">        System.setProperty(Constants.LOG_ENCODING_PROP_KEY, fileEncoding);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SofaBootHealthCheckAutoConfiguration"><a href="#SofaBootHealthCheckAutoConfiguration" class="headerlink" title="SofaBootHealthCheckAutoConfiguration"></a>SofaBootHealthCheckAutoConfiguration</h3><p>这个类是 <code>SOFABoot</code> 健康检查机制的自动化配置实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaBootHealthCheckAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** ReadinessCheckListener: 容器刷新之后回调 */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReadinessCheckListener <span class="title">readinessCheckListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReadinessCheckListener();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** HealthCheckerProcessor: HealthChecker处理器 */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HealthCheckerProcessor <span class="title">healthCheckerProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HealthCheckerProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** HealthCheckerProcessor: HealthIndicator处理器 */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HealthIndicatorProcessor <span class="title">healthIndicatorProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HealthIndicatorProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** AfterReadinessCheckCallbackProcessor: ReadinessCheck之后的回调处理器 */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AfterReadinessCheckCallbackProcessor <span class="title">afterReadinessCheckCallbackProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AfterReadinessCheckCallbackProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 返回 SofaBoot健康检查指标类 实例*/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SofaBootHealthIndicator <span class="title">sofaBootHealthIndicator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SofaBootHealthIndicator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(Endpoint.class)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionReadinessEndpointConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnEnabledEndpoint</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SofaBootReadinessCheckEndpoint <span class="title">sofaBootReadinessCheckEndpoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SofaBootReadinessCheckEndpoint();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(Endpoint.class)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadinessCheckExtensionConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="meta">@ConditionalOnEnabledEndpoint</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ReadinessEndpointWebExtension <span class="title">readinessEndpointWebExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReadinessEndpointWebExtension();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ReadinessCheckListener"><a href="#ReadinessCheckListener" class="headerlink" title="ReadinessCheckListener"></a>ReadinessCheckListener</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadinessCheckListener</span> <span class="keyword">implements</span> <span class="title">PriorityOrdered</span>,</span></span><br><span class="line"><span class="class">                                   <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从代码来看，<code>ReadinessCheckListener</code> 实现了 <code>ApplicationListener</code> 监听器接口，其所监听的事件对象是<code>ContextRefreshedEvent</code>，即当容器上下文刷新完成之后回调。 <code>SOFABoot</code> 中通过这个监听器来完成 <code>readniess check</code> 的处理。</p>
<p><code>onApplicationEvent</code> 回调方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// healthCheckerProcessor init</span></span><br><span class="line">    healthCheckerProcessor.init();</span><br><span class="line">    <span class="comment">// healthIndicatorProcessor init</span></span><br><span class="line">    healthIndicatorProcessor.init();</span><br><span class="line">    <span class="comment">// afterReadinessCheckCallbackProcessor init</span></span><br><span class="line">    afterReadinessCheckCallbackProcessor.init();</span><br><span class="line">    <span class="comment">// readiness health check execute</span></span><br><span class="line">    readinessHealthCheck();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化 <code>healthCheckerProcessor</code>，这个里面就是将当前所有的<code>HealthChecker</code>类型的<code>bean</code>找出来，然后放在一个<code>map</code>中，等待后面的 <code>readiness check</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否已经初始化了</span></span><br><span class="line">    <span class="keyword">if</span> (isInitiated.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// applicationContext 应用上下文不能为null</span></span><br><span class="line">        Assert.notNull(applicationContext, () -&gt; <span class="string">"Application must not be null"</span>);</span><br><span class="line">        <span class="comment">// 获取所有类型是 HealthChecker 的bean</span></span><br><span class="line">        Map&lt;String, HealthChecker&gt; beansOfType = applicationContext</span><br><span class="line">                .getBeansOfType(HealthChecker.class);</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        healthCheckers = HealthCheckUtils.sortMapAccordingToValue(beansOfType,</span><br><span class="line">                applicationContext.getAutowireCapableBeanFactory());</span><br><span class="line">        <span class="comment">// 构建日志信息，对应在健康检查日志里面打印出来的是：</span></span><br><span class="line">        <span class="comment">// ./logs/health-check/common-default.log:Found 0 HealthChecker implementation</span></span><br><span class="line">        StringBuilder healthCheckInfo = <span class="keyword">new</span> StringBuilder(<span class="number">512</span>).append(<span class="string">"Found "</span>)</span><br><span class="line">                .append(healthCheckers.size()).append(<span class="string">" HealthChecker implementation:"</span>)</span><br><span class="line">                .append(String.join(<span class="string">","</span>, healthCheckers.keySet()));</span><br><span class="line">        logger.info(healthCheckInfo.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化 <code>healthIndicatorProcessor</code>，将所有的<code>healthIndicator</code> 类型的<code>bean</code> 找出来，然后放在一个<code>map</code>中等待<code>readiness check</code>。如果想要在 <code>SOFABoot</code> 的 <code>Readiness Check</code> 里面增加一个检查项，那么可以直接扩展 <code>Spring Boot</code> 的<code>HealthIndicator</code>这个接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否已经初始化</span></span><br><span class="line">    <span class="keyword">if</span> (isInitiated.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// applicationContext 验证</span></span><br><span class="line">        Assert.notNull(applicationContext, () -&gt; <span class="string">"Application must not be null"</span>);</span><br><span class="line">        <span class="comment">// 获取所有HealthIndicator类型的bean</span></span><br><span class="line">        Map&lt;String, HealthIndicator&gt; beansOfType = applicationContext</span><br><span class="line">                .getBeansOfType(HealthIndicator.class);</span><br><span class="line">        <span class="comment">// 支持 Reactive 方式</span></span><br><span class="line">        <span class="keyword">if</span> (ClassUtils.isPresent(REACTOR_CLASS, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            applicationContext.getBeansOfType(ReactiveHealthIndicator.class).forEach(</span><br><span class="line">                    (name, indicator) -&gt; beansOfType.put(name, () -&gt; indicator.health().block()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        healthIndicators = HealthCheckUtils.sortMapAccordingToValue(beansOfType,</span><br><span class="line">                applicationContext.getAutowireCapableBeanFactory());</span><br><span class="line">        <span class="comment">// 构建日志信息</span></span><br><span class="line">        <span class="comment">// Found 2 HealthIndicator implementation:</span></span><br><span class="line">        <span class="comment">// sofaBootHealthIndicator, diskSpaceHealthIndicator</span></span><br><span class="line">        StringBuilder healthIndicatorInfo = <span class="keyword">new</span> StringBuilder(<span class="number">512</span>).append(<span class="string">"Found "</span>)</span><br><span class="line">                .append(healthIndicators.size()).append(<span class="string">" HealthIndicator implementation:"</span>)</span><br><span class="line">                .append(String.join(<span class="string">","</span>, healthIndicators.keySet()));</span><br><span class="line">        logger.info(healthIndicatorInfo.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化 <code>afterReadinessCheckCallbackProcessor</code>。如果想要在 <code>Readiness Check</code> 之后做一些事情，那么可以扩展 <code>SOFABoot</code> 的这个接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  是否已经初始化</span></span><br><span class="line">    <span class="keyword">if</span> (isInitiated.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// applicationContext 验证</span></span><br><span class="line">        Assert.notNull(applicationContext, () -&gt; <span class="string">"Application must not be null"</span>);</span><br><span class="line">        <span class="comment">// 找到所有 ReadinessCheckCallback 类型的 bean </span></span><br><span class="line">        Map&lt;String, ReadinessCheckCallback&gt; beansOfType = applicationContext</span><br><span class="line">                .getBeansOfType(ReadinessCheckCallback.class);</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        readinessCheckCallbacks = HealthCheckUtils.sortMapAccordingToValue(beansOfType,</span><br><span class="line">                applicationContext.getAutowireCapableBeanFactory());</span><br><span class="line">        <span class="comment">// 构建日志</span></span><br><span class="line">        StringBuilder applicationCallbackInfo = <span class="keyword">new</span> StringBuilder(<span class="number">512</span>).append(<span class="string">"Found "</span>)</span><br><span class="line">                .append(readinessCheckCallbacks.size())</span><br><span class="line">                .append(<span class="string">" ReadinessCheckCallback implementation: "</span>)</span><br><span class="line">                .append(String.join(<span class="string">","</span>, beansOfType.keySet()));</span><br><span class="line">        logger.info(applicationCallbackInfo.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>readinessHealthCheck</code>，前面的几个<code>init</code>方法中均是为<code>readinessHealthCheck</code>做准备的，到这里<code>SOFABoot</code>已经拿到了当前多有的<code>HealthChecker</code>、<code>HealthIndicator</code> 和 <code>ReadinessCheckCallback</code> 类型的 <code>bean</code> 信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readiness health check</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readinessHealthCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否跳过所有check,可以通过 com.alipay.sofa.healthcheck.skip.all 配置项配置决定</span></span><br><span class="line">    <span class="keyword">if</span> (skipAllCheck()) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Skip all readiness health check."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 是否跳过所有 HealthChecker 类型bean的 readinessHealthCheck,</span></span><br><span class="line">        <span class="comment">// 可以通过com.alipay.sofa.healthcheck.skip.component配置项配置</span></span><br><span class="line">        <span class="keyword">if</span> (skipComponent()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Skip HealthChecker health check."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//HealthChecker 的 readiness check</span></span><br><span class="line">            healthCheckerStatus = healthCheckerProcessor</span><br><span class="line">                .readinessHealthCheck(healthCheckerDetails);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否跳过所有HealthIndicator 类型bean的readinessHealthCheck</span></span><br><span class="line">        <span class="comment">// 可以通过 com.alipay.sofa.healthcheck.skip.indicator配置项配置</span></span><br><span class="line">        <span class="keyword">if</span> (skipIndicator()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Skip HealthIndicator health check."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//HealthIndicator 的 readiness check</span></span><br><span class="line">            healthIndicatorStatus = healthIndicatorProcessor</span><br><span class="line">                .readinessHealthCheck(healthIndicatorDetails);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ReadinessCheck 之后的回调函数，做一些后置处理</span></span><br><span class="line">    healthCallbackStatus = afterReadinessCheckCallbackProcessor</span><br><span class="line">        .afterReadinessCheckCallback(healthCallbackDetails);</span><br><span class="line">    <span class="keyword">if</span> (healthCheckerStatus &amp;&amp; healthIndicatorStatus &amp;&amp; healthCallbackStatus) &#123;</span><br><span class="line">        logger.info(<span class="string">"Readiness check result: success"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.error(<span class="string">"Readiness check result: fail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Readiness-Check-做了什么"><a href="#Readiness-Check-做了什么" class="headerlink" title="Readiness Check 做了什么"></a>Readiness Check 做了什么</h4><p>前面是 <code>SOFABoot</code> 健康检查组件处理健康检查逻辑的一个大体流程，了解到了 <code>Readiness</code> 包括检查 <code>HealthChecker</code> 类型的<code>bean</code>和<code>HealthIndicator</code> 类型的 <code>bean</code>。其中<code>HealthIndicator</code>是<code>SpringBoot</code>自己的接口 ，而 <code>HealthChecker</code> 是 <code>SOFABoot</code> 提供的接口。下面继续通过 <code>XXXProcess</code> 来看下 <code>Readiness Check</code> 到底做了什么？</p>
<h4 id="HealthCheckerProcessor"><a href="#HealthCheckerProcessor" class="headerlink" title="HealthCheckerProcessor"></a>HealthCheckerProcessor</h4><p><code>HealthChecker</code> 的健康检查处理器，<code>readinessHealthCheck</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readinessHealthCheck</span><span class="params">(Map&lt;String, Health&gt; healthMap)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(healthCheckers, <span class="string">"HealthCheckers must not be null."</span>);</span><br><span class="line">    logger.info(<span class="string">"Begin SOFABoot HealthChecker readiness check."</span>);</span><br><span class="line">    <span class="keyword">boolean</span> result = healthCheckers.entrySet().stream()</span><br><span class="line">            .map(entry -&gt; doHealthCheck(entry.getKey(), entry.getValue(), <span class="keyword">true</span>, healthMap, <span class="keyword">true</span>))</span><br><span class="line">            .reduce(<span class="keyword">true</span>, BinaryOperators.andBoolean());</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        logger.info(<span class="string">"SOFABoot HealthChecker readiness check result: success."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.error(<span class="string">"SOFABoot HealthChecker readiness check result: failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里每个<code>HealthChecker</code>又委托给<code>doHealthCheck</code>来检查</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doHealthCheck</span><span class="params">(String beanId, HealthChecker healthChecker, <span class="keyword">boolean</span> isRetry,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Map&lt;String, Health&gt; healthMap, <span class="keyword">boolean</span> isReadiness)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(healthMap, <span class="string">"HealthMap must not be null"</span>);</span><br><span class="line">    Health health;</span><br><span class="line">    <span class="keyword">boolean</span> result;</span><br><span class="line">    <span class="keyword">int</span> retryCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// check 类型  readiness ？ liveness</span></span><br><span class="line">    String checkType = isReadiness ? <span class="string">"readiness"</span> : <span class="string">"liveness"</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 Health 对象</span></span><br><span class="line">        health = healthChecker.isHealthy();</span><br><span class="line">        <span class="comment">// 获取 健康检查状态结果</span></span><br><span class="line">        result = health.getStatus().equals(Status.UP);</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            logger.info(<span class="string">"HealthChecker[&#123;&#125;] &#123;&#125; check success with &#123;&#125; retry."</span>, beanId, checkType,retryCount);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.info(<span class="string">"HealthChecker[&#123;&#125;] &#123;&#125; check fail with &#123;&#125; retry."</span>, beanId, checkType,retryCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重试 &amp;&amp; 等待</span></span><br><span class="line">        <span class="keyword">if</span> (isRetry &amp;&amp; retryCount &lt; healthChecker.getRetryCount()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                retryCount += <span class="number">1</span>;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(healthChecker.getRetryTimeInterval());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                logger</span><br><span class="line">                    .error(</span><br><span class="line">                        String</span><br><span class="line">                            .format(</span><br><span class="line">                                <span class="string">"Exception occurred while sleeping of %d retry HealthChecker[%s] %s check."</span>,</span><br><span class="line">                                retryCount, beanId, checkType), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (isRetry &amp;&amp; retryCount &lt; healthChecker.getRetryCount());</span><br><span class="line">    <span class="comment">// 将当前 实例 bean 的健康检查结果存到结果集healthMap中</span></span><br><span class="line">    healthMap.put(beanId, health);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            logger</span><br><span class="line">                .error(</span><br><span class="line">                    <span class="string">"HealthChecker[&#123;&#125;] &#123;&#125; check fail with &#123;&#125; retry; fail details:&#123;&#125;; strict mode:&#123;&#125;"</span>,</span><br><span class="line">                    beanId, checkType, retryCount,</span><br><span class="line">                    objectMapper.writeValueAsString(health.getDetails()),</span><br><span class="line">                    healthChecker.isStrictCheck());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException ex) &#123;</span><br><span class="line">        logger.error(</span><br><span class="line">            String.format(<span class="string">"Error occurred while doing HealthChecker %s check."</span>, checkType), ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回健康检查结果</span></span><br><span class="line">    <span class="keyword">return</span> !healthChecker.isStrictCheck() || result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>doHealthCheck</code> 结果需要依赖具体 <code>HealthChecker</code> 实现类的处理。通过这样一种方式可以<code>SOFABoot</code>可以很友好的实现对所以 <code>HealthChecker</code> 的健康检查。<code>HealthIndicatorProcessor</code> 的 <code>readinessHealthCheck</code> 和<code>HealthChecker</code>的基本差不多；有兴趣的可以自行阅读源码 <a href="https://github.com/alipay/sofa-boot" target="_blank" rel="noopener">Alipay-SOFABoot</a>。</p>
<h4 id="AfterReadinessCheckCallbackProcessor"><a href="#AfterReadinessCheckCallbackProcessor" class="headerlink" title="AfterReadinessCheckCallbackProcessor"></a>AfterReadinessCheckCallbackProcessor</h4><p>这个接口是 <code>SOFABoot</code> 提供的一个扩展接口， 用于在 <code>Readiness Check</code> 之后做一些事情。其实现思路和前面的<code>XXXXProcessor</code> 是一样的，对之前初始化时得到的所有的<code>ReadinessCheckCallbacks</code>实例<code>bean</code>逐一进行回调处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">afterReadinessCheckCallback</span><span class="params">(Map&lt;String, Health&gt; healthMap)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"Begin ReadinessCheckCallback readiness check"</span>);</span><br><span class="line">    Assert.notNull(readinessCheckCallbacks, <span class="string">"ReadinessCheckCallbacks must not be null."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = readinessCheckCallbacks.entrySet().stream()</span><br><span class="line">            .map(entry -&gt; doHealthCheckCallback(entry.getKey(), entry.getValue(), healthMap))</span><br><span class="line">            .reduce(<span class="keyword">true</span>, BinaryOperators.andBoolean());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        logger.info(<span class="string">"ReadinessCheckCallback readiness check result: success."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.error(<span class="string">"ReadinessCheckCallback readiness check result: failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样也是委托给了<code>doHealthCheckCallback</code>来处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doHealthCheckCallback</span><span class="params">(String beanId,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      ReadinessCheckCallback readinessCheckCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Map&lt;String, Health&gt; healthMap)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(healthMap, () -&gt; <span class="string">"HealthMap must not be null"</span>);</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    Health health = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        health = readinessCheckCallback.onHealthy(applicationContext);</span><br><span class="line">        result = health.getStatus().equals(Status.UP);</span><br><span class="line">        <span class="comment">// print log 省略</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 存入 healthMap</span></span><br><span class="line">        healthMap.put(beanId, health);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="扩展-Readiness-Check-能力"><a href="#扩展-Readiness-Check-能力" class="headerlink" title="扩展 Readiness Check 能力"></a>扩展 Readiness Check 能力</h4><p>按照上面的分析，我们可以自己来实现下这几个扩展。</p>
<h4 id="实现-HealthChecker-接口"><a href="#实现-HealthChecker-接口" class="headerlink" title="实现 HealthChecker 接口"></a>实现 HealthChecker 接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperHealthChecker</span> <span class="keyword">implements</span> <span class="title">HealthChecker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Health <span class="title">isHealthy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以检测数据库连接是否成功</span></span><br><span class="line">        <span class="comment">// 可以检测zookeeper是否启动成功</span></span><br><span class="line">        <span class="comment">// 可以检测redis客户端是否启动成功</span></span><br><span class="line">        <span class="comment">// everything you want ...</span></span><br><span class="line">        <span class="keyword">if</span>(OK)&#123;</span><br><span class="line">            <span class="keyword">return</span> Health.up().build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Health.down().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getComponentName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 组件名</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"GlmapperComponent"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRetryCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重试次数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getRetryTimeInterval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重试间隔</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStrictCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现-ReadinessCheckCallback-接口"><a href="#实现-ReadinessCheckCallback-接口" class="headerlink" title="实现 ReadinessCheckCallback 接口"></a>实现 ReadinessCheckCallback 接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperReadinessCheckCallback</span> <span class="keyword">implements</span> <span class="title">ReadinessCheckCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Health <span class="title">onHealthy</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        Object glmapperHealthChecker = applicationContext.getBean(<span class="string">"glmapperHealthChecker"</span>);</span><br><span class="line">        <span class="keyword">if</span> (glmapperHealthChecker <span class="keyword">instanceof</span> GlmapperHealthChecker)&#123;</span><br><span class="line">            <span class="keyword">return</span> Health.up().build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Health.down().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看下健康检查日志：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/16/1671b484144d1d65?w=1590&amp;h=386&amp;f=png&amp;s=475058" alt=""></p>
<p>可以看到我们自己定义的检查类型<code>ready</code>了。</p>
<p>从日志看到有一个 <code>sofaBootHealthIndicator</code>，实现了<code>HealthIndicator</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaBootHealthIndicator</span> <span class="keyword">implements</span> <span class="title">HealthIndicator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String    CHECK_RESULT_PREFIX = <span class="string">"Middleware"</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HealthCheckerProcessor healthCheckerProcessor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Health <span class="title">health</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Health&gt; healths = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 调用了 healthCheckerProcessor 的 livenessHealthCheck</span></span><br><span class="line">        <span class="keyword">boolean</span> checkSuccessful = healthCheckerProcessor.livenessHealthCheck(healths);</span><br><span class="line">        <span class="keyword">if</span> (checkSuccessful) &#123;</span><br><span class="line">            <span class="keyword">return</span> Health.up().withDetail(CHECK_RESULT_PREFIX, healths).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Health.down().withDetail(CHECK_RESULT_PREFIX, healths).build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>livenessHealthCheck</code> 和 <code>readinessHealthCheck</code> 两个方法都是交给 <code>doHealthCheck</code> 来处理的，没有看出来有什么区别。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文基于 <code>SOFABoot 3.0.0</code> 版本，与之前版本有一些区别。详细变更见：<a href="http://www.sofastack.tech/sofa-boot/docs/upgrade_3_x" target="_blank" rel="noopener">SOFABoot upgrade_3_x</a>。本篇文章简单介绍了 <code>SOFABoot</code> 对 <code>SpringBoot</code> 健康检查能力扩展的具体实现细节。</p>
<p>最后再来补充下 <code>liveness</code> 和 <code>readiness</code>，从字面意思来理解，<code>liveness</code>就是是否是活的，<code>readiness</code> 就是意思是否可访问的。</p>
<ul>
<li><code>readiness</code>：应用即便已经正在运行了，它仍然需要一定时间才能 提供 服务，这段时间可能用来加载数据，可能用来构建缓存，可能用来注册服务，可能用来选举 <code>Leader</code>等等。总之 <code>Readiness</code> 检查通过前是不会有流量发给应用的。目前 <code>SOFARPC</code> 就是在 <code>readiness check</code> 之后才会将所有的服务注册到注册中心去。</li>
<li><code>liveness</code>：检测应用程序是否正在运行</li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/16/sofa-boot-health-analizy/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/sofa-tracer-zipkin/">分布式链路跟踪组件 SOFATracer 和 Zipkin 模型转换原理</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T04:33:56.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/sofa-tracer-zipkin/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/OpenTracing/" title="OpenTracing">OpenTracing</a>,
  
    <a href="/tags/链路跟踪/" title="链路跟踪">链路跟踪</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>SOFATracer 是一个用于分布式系统调用跟踪的组件，通过统一的 traceId 将调用链路中的各种网络调用情况以日志的方式记录下来或者上报到 zipkin，以达到透视化网络调用的目的。这种以日志的方式记录下来或者上报到zipkin通常称为 Report，即数据上报 SOFATracer 的数据上报是在遵循 OpenTracing 规范基础上扩展出来的能力，OpenTracing 规范本身只是约定了数据模型和行为。本文主要目的在于分析 SOFATracer 的数据上报功能部分，主要内容如下：</p>
<ul>
<li>基于 OpenTracing 规范的分布式链路跟踪解决方案</li>
<li>SOFATracer Report 数据上报模型</li>
<li>SOFATracer 和  Zipkin 模型转换原理</li>
</ul>
<h2 id="基于-OpenTracing-规范的分布式链路跟踪解决方案"><a href="#基于-OpenTracing-规范的分布式链路跟踪解决方案" class="headerlink" title="基于 OpenTracing 规范的分布式链路跟踪解决方案"></a>基于 OpenTracing 规范的分布式链路跟踪解决方案</h2><p> OpenTracing 是一个轻量级的标准化层，它位于应用程序/类库和追踪或日志分析程序之间。为了解决不同的分布式追踪系统 API 不兼容的问题，OpenTracing 提供了一套平台无关、厂商无关的 API，同时也提供了统一的概念和数据标准。关于对 OpenTracing 标准的版本化描述可以参考 specification.md（<a href="https://github.com/opentracing/specification/blob/master/specification.md）。一些具体的概念下面将结合SOFATracer" target="_blank" rel="noopener">https://github.com/opentracing/specification/blob/master/specification.md）。一些具体的概念下面将结合SOFATracer</a> 的实现来一一说明。</p>
<p> 目前基于 OpenTracing 规范实现的链路跟踪组件有 Jaeger，Appdash，Apache SkyWalking ，Datadog 等。像谷歌的 StackDriver Tracer 实际上并不是遵循 OpenTracing 规范的，但是都源自于 Dapper 这篇论文。</p>
<p> 规范其实就是模型和行为的约束，在 OpenTracing 规范中有三种关键和相互关联的模型：Tracer、Span 和SpanContext；并且在规范中对于每个模型的行为也做了约定。</p>
<h3 id="Tracer"><a href="#Tracer" class="headerlink" title="Tracer"></a>Tracer</h3><p> Tracer 可以被认为是一个由多个 Span 组成的有向无环图。一个 Tracer 可以用来描述一个请求从发出到收到响应整个链路过程。前提是需要在适当的地方进行埋点。下图就是一条完整的链路的展示：</p>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1536236659627-31fa22c0-6cb0-4f8b-825c-5892aa266aac.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1536236727855-6c02f1a7-3e6c-4236-b2d4-37dc4c69d57f.png" alt="img"></p>
<p> 在 SOFATracer 中 ，SofaTracer 实现了 Tracer 接口，实现了构建 span，数据载入（Inject）和 数据提取（Extract ) 的能力。</p>
<ul>
<li>Start a new Span ：创建一个新的 Span 。通过指定的 operationName 来创建一个新的 Span。operationName 表示由 Span 完成的具体的工作 ( 例如，RPC 方法名称、函数名称或一个较大的计算任务中的阶段的名称)。</li>
<li>Inject a SpanContext：将 SpanContext 注入到给定类型的 “carrier” 中，用于进行跨进程的传输。</li>
<li>Extract a SpanContext ：从载体中提取中 spanContext 实例对象。这个过程是注入的逆过程。spanContext 中包括了贯穿整个链路的 traceId ，变化的 spanId ，父 spanId 以及透传数据等。</li>
</ul>
<h3 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h3><p> 一个 span 代表系统中具有开始时间和执行时长的逻辑运行单元。span 之间通过嵌套或者顺序排列建立逻辑因果关系，然后再通过这种关系来构建整个调用链路（Tracer）。</p>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1536238542375-0bd31368-4f84-4504-99ee-d02fdc00b99e.png" alt="img"> </p>
<p>OpenTracing 规范 API 约定 Span 的模型如下（实际上就是 Span 接口中对应的方法，需要由遵循该规范的实现者必须提供的最小能力的集合）：</p>
<ul>
<li>Get the Span’s SpanContext： 通过 Span 获取 SpanContext （即使 span 已经结束，或者即将结束）</li>
<li>Finish：结束一个 Span 。Finish 必须是 span 实例的最后一个被调用的方法。但是在主线程处理失败或者其他程序错误发生时，Finish 方法可能不会被调用。在这种情况下，实现者应该明确的记录 Span，保证数据的持久化（这一点 SOFATracer 其实是没有做的）。</li>
<li>Set a K:V tag on the Span：为 Span 设置 tag 。tag 的 key 必须是 string 类型；value 必须是 string、boolean 或数字类型。通常会使用 Tag 来记录跟踪系统感兴趣的一些指标数据。</li>
<li>Add a new log event：为 Span 增加一个 log 事件，用于记录 Span 生命周期中发生的事件。</li>
<li>Set a Baggage item： 设置一个 string:string 类型的键值对，一般是业务数据在全链路数据透明传输，存储在 SpanContext 中。</li>
<li>Get a Baggage item： 通过 key 获取 Baggage 中的元素。</li>
</ul>
<h3 id="SpanContext"><a href="#SpanContext" class="headerlink" title="SpanContext"></a>SpanContext</h3><p> Span 上下文，几乎包含了需要在链路中传递的全部信息。另外，Span 间 References 就是通过 SpanContext 来建立关系的。根据 OpenTracing 规范要求，SpanContext 是不可变的，目的是防止由于 Span 的结束和相互关系，造成的复杂生命周期问题。</p>
<p> SpanContext 表示必须传播到后代 Spans 和跨进程边界的 Span 状态。SpanContext 在逻辑上分为两部分：</p>
<ul>
<li>跨 Span 边界传播的用户级 “Baggage”</li>
<li>识别或以其他方式关联 Span 实例所需的任何 Tracer 实现特定字段（例如，trace_id，span_id，sampling，元组） </li>
</ul>
<p>Opentracing 中 SpanContext 接口中只有一个 baggageItems 方法，通过这个方法来遍历所有的 baggage 元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpanContext</span> </span>&#123;</span><br><span class="line">    Iterable&lt;Map.Entry&lt;String, String&gt;&gt; baggageItems();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SOFATracer-扩展的-Tracer-的能力"><a href="#SOFATracer-扩展的-Tracer-的能力" class="headerlink" title="SOFATracer 扩展的 Tracer 的能力"></a>SOFATracer 扩展的 Tracer 的能力</h3><p>上面简单介绍了 OpenTracing 规范  API  对于 Tracer、Span、SpanContext 三个核心模型的规范定义。下面来看下 SOFATracer 是如何遵循规范并做扩展的。</p>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1536241818520-0b112c9e-f785-4538-b507-e12a96854631.png" alt="img"></p>
<p>在 <a href="http://opentracing.io/documentation/pages/spec.html" target="_blank" rel="noopener">OpenTracing</a> 规范 基础上，SOFATracer 提供了实现，并在规范基础上提供了扩展功能。本文主要介绍上图中标绿色的部分，即数据上报功能。</p>
<p>SOFATracer 中提供了 Report 接口，然后基于此接口扩展了两个实现：</p>
<ul>
<li>第一种 Report 扩展是基于 Disruptor（<a href="https://github.com/LMAX-Exchange/disruptor）" target="_blank" rel="noopener">https://github.com/LMAX-Exchange/disruptor）</a> 高性能无锁循环队列的异步落地磁盘的日志打印。</li>
<li>第二种 Report 扩展是提供远程上报，能够将 SOFATracer 的链路数据模型汇报到 Zipkin 中做调用链路的展示。 </li>
</ul>
<p>当然，SOFATracer 也允许用户自定义上报功能，只需要在自己的工程代码中实现 Report 接口即可，下面是 Report 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Reporter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 上报到远程服务器的持久化类型</span></span><br><span class="line">    String REMOTE_REPORTER    = <span class="string">"REMOTE_REPORTER"</span>;</span><br><span class="line">    <span class="comment">// 组合类型</span></span><br><span class="line">    String COMPOSITE_REPORTER = <span class="string">"COMPOSITE_REPORTER"</span>;</span><br><span class="line">    <span class="comment">// 获取 Reporter 实例类型</span></span><br><span class="line">    <span class="function">String <span class="title">getReporterType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 上报 span</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">(SofaTracerSpan span)</span></span>;</span><br><span class="line">    <span class="comment">// 关闭上报 span 的能力</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SOFATracer-Report-数据上报模型"><a href="#SOFATracer-Report-数据上报模型" class="headerlink" title="SOFATracer Report 数据上报模型"></a>SOFATracer Report 数据上报模型</h2><p> 上面提到 SOFATracer 的 Report 有两种机制，一种是落到磁盘，另外一种是上报到 zipkin。SOFATracer 中这两种方案并不是二选一的，而是可以同时使用多个实现。例如，我们希望上报数据到 zipkin，先引入 tracer-sofa-boot-starter 这个依赖，并进行相关 zipkin 的配置之后就可以将链路数据上报到 zipkin，如果没有引入依赖则不会上报。本节来分析下 SOFATracer 上报数据过程的具体逻辑。</p>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1536201415524-19bc4895-dac4-4582-b17c-48e2b39126e2.png" alt="img"></p>
<p> 上面这张图描述了数据上报的几种方式：</p>
<ul>
<li>绿色部分，上报 zipkin：这里其实就是实现上报 zipkin 的一个回调，当进行 reportSpan 操作时，会执行一个invokeReportListeners ，这个方法就是通知所有实现了 SpanReportListener 接口的类执行回调方法，然后在这个回调方法中将 span 数据上报到 zipkin。</li>
<li><p>红色部分，输出到磁盘：SOFATracer 为了提供更好的扩展能力，将输出日志的 Report 细分为 client 和 server 两种；并在 Tracer 基类中提供 generateClientStatReporter 和 generateServerStatReporter 两个抽象方法，供不同的组件自己来实现一些特殊化的定制。</p>
<p>关于何时进行上报，其实这个在 Opentracing API 的规范中已经给出了明确的时机。在上面的介绍中提到，“Finish必须是 span 实例的最后一个被调用的方法”，当 finish 方法被调用时也就意味着一个 span 生命周期的结束，为了保证 span 数据的完整性和正确性，SOFATracer reportSpan 的逻辑就是在 finish 方法被调用时触发执行。</p>
</li>
</ul>
<h3 id="数据落地磁盘"><a href="#数据落地磁盘" class="headerlink" title="数据落地磁盘"></a>数据落地磁盘</h3><p> SOFATracer 日志落盘是基于<a href="https://github.com/LMAX-Exchange/disruptor" target="_blank" rel="noopener">Disruptor</a>高性能无锁循环队列实现的，提供了异步打印日志到本地磁盘的能力。</p>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1536205560373-b3b5b362-8041-4077-8b4f-38b76bde25d7.png" alt="img"> </p>
<p><strong>append</strong> : 追溯 Report，无论是 clientReport 还是 serverReport ，底层均依赖 DiskReporterImpl 的实现。DiskReporterImpl 是 SOFATracer 统筹处理日志落盘的类。clientReport 和 serverReport 的最终调用都会走到DiskReporterImpl 中的 digestReport 这个方法。digestReport 中会将当前 span append 到环形缓冲队列中，append 操作就是发布一个事件的过程。</p>
<p><strong>consume</strong>：consume 是 Disruptor 中的对应的消费模型；SOFATracer 中这个消费者就是将 SofaTracerSpan 中的数据写到日志文件中的。</p>
<p>事件发布过程：</p>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1536206792096-48737dab-09e4-4825-8829-5b9af6668a1f.png" alt="img"></p>
<h3 id="数据上报-zipkin"><a href="#数据上报-zipkin" class="headerlink" title="数据上报 zipkin"></a>数据上报 zipkin</h3><p> 前面提到，上报 zipkin 的是通过 onSpanReport 这个回调函数完成的。tracer-sofa-boot-starter 这个依赖中提供了 SpanReportListener 接口实现 ZipkinSofaTracerSpanRemoteReporter 。而在 onSpanReport 这个回调函数中，又将具体上报委托给了 AsyncReporter 来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSpanReport</span><span class="params">(SofaTracerSpan span)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (span == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//convert</span></span><br><span class="line">    Span zipkinSpan = convertToZipkinSpan(span);</span><br><span class="line">    <span class="keyword">this</span>.delegate.report(zipkinSpan);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构建 AsyncReporter 对象需要两个参数：</p>
<ul>
<li>sender： 数据发送器，SOFATracer 中，sender 的是通过 RestTemplate 以 http 方式 来与 zipkin 进行通信传输的。</li>
<li>url：Zipkin 默认的 Collector 使用 http 协议里收集 Trace 信息，客户端调用 /api/v1/spans 或 /api/v2/spans 来上报 tracer 信息。这里我们使用的是 Zipkin V2 的 API。</li>
</ul>
<p>AsyncReporter 中实际构建的是 BoundedAsyncReporter 对象 ， 并且在构建一个异步报告器是，会根据messageTimeoutNanos 是否大于 0 来决定是否起一个守护线程 flushThread；flushThread 作用是一直循环调用 BoundedAsyncReporter 的 flush 方法，将内存中的 Span 信息上报给 Zipkin。具体细节这里不展开分析。</p>
<h2 id="SOFATracer-和-Zipkin-模型转换原理"><a href="#SOFATracer-和-Zipkin-模型转换原理" class="headerlink" title="SOFATracer 和  Zipkin 模型转换原理"></a>SOFATracer 和  Zipkin 模型转换原理</h2><p> 在上小节中贴出的小段代码中，除了构建 delegate 对象用于执行上报外；另一个关键就是 SOFATracer 的 Span 模型转换成 Zipkin Span 模型。SOFATracer 从 2.2.0 版本之后支持 Zipkin v2 的模型 ，对于 Zipkin v1 的模型不在提供支持。</p>
<h4 id="Zipkin-v2的模型"><a href="#Zipkin-v2的模型" class="headerlink" title="Zipkin v2的模型"></a>Zipkin v2的模型</h4><p> 下面是 zipkin GitHub 上提供的 Zipkin v2 的模型的结构化数据 Demo。<a href="https://github.com/openzipkin/zipkin/issues/1499" target="_blank" rel="noopener">关于 Zipkin 的 Span 模型支持可以查看 Simplified span2 format #1499</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"kind"</span>: <span class="string">"CLIENT"</span>,</span><br><span class="line">  <span class="string">"traceId"</span>: <span class="string">"5af7183fb1d4cf5f"</span>,</span><br><span class="line">  <span class="string">"parentId"</span>: <span class="string">"6b221d5bc9e6496c"</span>,</span><br><span class="line">  <span class="string">"id"</span>: <span class="string">"352bff9a74ca9ad2"</span>,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"query"</span>,</span><br><span class="line">  <span class="string">"timestamp"</span>: <span class="number">1461750040359000</span>,</span><br><span class="line">  <span class="string">"duration"</span>: <span class="number">5000</span>,</span><br><span class="line">  <span class="string">"localEndpoint"</span>: &#123;</span><br><span class="line">    <span class="string">"serviceName"</span>: <span class="string">"zipkin-server"</span>,</span><br><span class="line">    <span class="string">"ipv4"</span>: <span class="string">"172.19.0.3"</span>,</span><br><span class="line">    <span class="string">"port"</span>: <span class="number">9411</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"remoteEndpoint"</span>: &#123;</span><br><span class="line">    <span class="string">"serviceName"</span>: <span class="string">"mysql"</span>,</span><br><span class="line">    <span class="string">"ipv4"</span>: <span class="string">"172.19.0.2"</span>,</span><br><span class="line">    <span class="string">"port"</span>: <span class="number">3306</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"tags"</span>: &#123;</span><br><span class="line">    <span class="string">"jdbc.query"</span>: <span class="string">"//....discard"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Zipkin v2 的模型结构较为简洁，整体看起来并没有什么繁重，这种对于使用者来说是很友好的，方便理解。其实在Zipkin v1 模型时，其整个模型也是比较复杂的，zipkin 社区对于 Zipkin 数据模型的变更也有讨论，见 <a href="https://github.com/openzipkin/zipkin/issues/939" target="_blank" rel="noopener">Zipkin v2 span model #939</a> ；像现在 v2 模型中的 tags，替换了原本 v1 中的 binaryAnnotations，binaryAnnotations 的存在是 v1 模型复杂的重要原因。详见 <a href="https://github.com/openzipkin/zipkin/releases/tag/2.10.1" target="_blank" rel="noopener">去除原因</a>。</p>
<h4 id="SofaTracerSpan-模型"><a href="#SofaTracerSpan-模型" class="headerlink" title="SofaTracerSpan 模型"></a>SofaTracerSpan 模型</h4><p>SofaTracerSpan 是基于 Opentracing 标准来的。但是 Opentracing 标准并没有规定一个 Span 模型必须有哪些属性。所以各个基于该标准的产品在于 Span 的模型上是不统一的，大多会基于其本身产生的场景带有一些特殊的属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"client"</span>:<span class="keyword">true</span>,</span><br><span class="line">    <span class="string">"server"</span>:<span class="keyword">false</span>,</span><br><span class="line">    <span class="string">"durationMicroseconds"</span>:<span class="number">775</span>,</span><br><span class="line">    <span class="string">"endTime"</span>:<span class="number">1536288243446</span>,</span><br><span class="line">    <span class="string">"logType"</span>:<span class="string">"httpclient-digest.log"</span>,</span><br><span class="line">    <span class="string">"operationName"</span>:<span class="string">"GET"</span>,</span><br><span class="line">    <span class="string">"logs"</span>:[</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">    ], </span><br><span class="line">    <span class="string">"sofaTracer"</span>:&#123;</span><br><span class="line">        <span class="string">"clientReporter"</span>:&#123;&#125;,</span><br><span class="line">        <span class="string">"tracerTags"</span>:&#123;&#125;,</span><br><span class="line">        <span class="string">"tracerType"</span>:<span class="string">"httpclient"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"sofaTracerSpanContext"</span>:&#123;</span><br><span class="line">        <span class="comment">// sofaTracerSpanContext info</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"spanReferences"</span>:[],</span><br><span class="line">    <span class="string">"startTime"</span>:<span class="number">1536288242671</span>,</span><br><span class="line">    <span class="string">"tagsWithBool"</span>:&#123;&#125;,</span><br><span class="line">    <span class="string">"tagsWithNumber"</span>:&#123;&#125;,</span><br><span class="line">    <span class="string">"tagsWithStr"</span>:&#123;&#125;,</span><br><span class="line">    <span class="string">"thisAsParentWhenExceedLayer"</span>:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SOFATracer 的 Span 模型相较于 Opentracing 规范模型和 Zipkin v2 的模型来说，记录的数据信息更加丰富，且在 Opentracing 规范的基础上扩展了一套自己的 API，可以让使用者能够更加方便的在自己的代码中来获取链路中的信息；在日志中展示更多的 span 信息，能够帮助我们去了解一些调用细节，在发生问题时，也提供了更多排查问题的依据信息。</p>
<h4 id="模型转换对照"><a href="#模型转换对照" class="headerlink" title="模型转换对照"></a>模型转换对照</h4><p>为了使得 SOFATracer 的数据能够被 zipkin 解析，需要将 SOFATracer 的 Span 模型转换成 zipkin v2 的数据模型。</p>
<table>
<thead>
<tr>
<th><strong>Zipkin v2 Span Model</strong></th>
<th><strong>SOFATracer Span Model</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>traceId</td>
<td>traceId</td>
<td>traceId</td>
</tr>
<tr>
<td>id</td>
<td>spanId</td>
<td>spanId</td>
</tr>
<tr>
<td>parentId</td>
<td>parentId</td>
<td>父spanId</td>
</tr>
<tr>
<td>name</td>
<td>operationName</td>
<td>span 名，用来描述当前span 的行为</td>
</tr>
<tr>
<td>duration</td>
<td>-</td>
<td>当前span的时间跨度;这里通过span的（结束时间-开始时间）获取</td>
</tr>
<tr>
<td>timestamp</td>
<td>timestamp</td>
<td>当前span的开始时间</td>
</tr>
<tr>
<td>localEndPoint</td>
<td>operationName&amp;host&amp;logData</td>
<td>标明这个span的来源</td>
</tr>
<tr>
<td>remoteEndPoint</td>
<td>-</td>
<td>被调用方的服务名和地址</td>
</tr>
<tr>
<td>tags</td>
<td>bizBaggage &amp; tags</td>
<td>额外的用于描述span的信息</td>
</tr>
</tbody>
</table>
<p>整体来看，Span 模型相似度是很高，但是实际上并不能直接将某些相同的字段直接进行值复制；这里有一个 案例：<a href="https://github.com/alipay/sofa-tracer/issues/57" target="_blank" rel="noopener">ISSUE#57</a> 。 </p>
<h4 id="traceId-和-spanId-处理"><a href="#traceId-和-spanId-处理" class="headerlink" title="traceId 和 spanId 处理"></a>traceId 和 spanId 处理</h4><p>zipkin 在自己的模型里做了很多特殊的处理。比如 traceId 需满足16 或者 32 位，长度不够的会高位补 0；所以在使用 SOFATracer 时，日志中的 traceId 和上报到 zipkin 的 traceId 长度不一致是合理的。</p>
<p>关于 spanId，我们期望在 zipkin 中展示是以（0.1,0.1.1,…）这种形式来描述，能够直观的看到 span 之间的依赖关系。但是目前使用的 zipkin 模型并不能满足我们的需求，主要原因在于虽然 zipkin 在 v2 模型中虽然支持 string 类型的 id ，但是其长度限制是16位，对于 SOFATracer 来说，如果存在较长的链路调用，会导致层次丢失。另外，如果上报 zipkin 的 span 的 parentId 为 0，那么 zipkin 将会不进行设置；而 SOFATracer 的第一个 span 的 id 就是从 0 开始的，所以会导致链路构建失败，如果我们尝试通过改变起始 id 来改变，会对整个模型产生影响。经过验证测试，我们最终采用的方案是使用冲突较小的 FNV64 Hash 算法将 String 类型转换成 long 型来描述我们的 spanId。</p>
<h4 id="SOFARPC-上报的数据处理"><a href="#SOFARPC-上报的数据处理" class="headerlink" title="SOFARPC 上报的数据处理"></a>SOFARPC 上报的数据处理</h4><p>在整个模型转换中，比较核心的就是如何兼容 SOFARPC 上报的数据。Zipkin 在构建链路数时，其基本的模型是 <code>client-server-client-server-..</code> 这种模式；不会出现 a server calling a server 这种情况，也就是带有kind = server 的 span 的 父span 应该是 kind = client。</p>
<p>SOFARPC 对于一个 rpc span 上报了两个 span 信息，这两个 span 除了 kind 类型不同之外，其他的信息是一样的。当数据上报给 zipkin 之后，zipkin 通过自己的算法来构建依赖树时，会对上报的 SOFARPC 数据处理有问题。下图是没有适配 SOFARPC 生成的链路: </p>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1536291774102-2ab76b17-f550-45b0-9d21-c3193f195e67.png" alt="img"></p>
<p>这里可以看出，从 mvc 到 rpc 之间的关系被‘切断’了。 </p>
<p>造成上述问题的原因在于，SOFATracer 上报数据到 zipkin 时，在 v2 模型中，zipkin 会通过广度优先遍历来构建依赖树，实际上在展示 services 或者 dependencies 时，zipkin ui 中的展示会依赖 endpiont 中的 serviceName ；两个条件：</p>
<ul>
<li>SOFARPC 的 span 有两个（client&amp;server），但是这两个 span 具有相同的 spanId 和 parentId，span.kind 不同。</li>
<li>zipkin 在构建依赖树时，依赖于 endpiont 中的 serviceName。该 servieName 依赖于 idToNode（Node.TreeBuilder 中的属性，Map 结构，映射关系为 spanId -&gt; span）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;V&gt; previous = idToNode.put(id, node);</span><br><span class="line"><span class="keyword">if</span> (previous != <span class="keyword">null</span>) </span><br><span class="line">node.setValue(mergeFunction.merge(previous.value, node.value));</span><br></pre></td></tr></table></figure>
<p>这里当前 node 为 rpc server 类型时，previous 返回结果不为 null，会执行 merge 操作，该 merge 操作的核心就是设置当前 rpc node 的 remoteEndpoint，值为 rpc client 的 localEndpoint。</p>
<p> 这样会有一个问题，就是 RPC 的 client 和 server Span 在 Zipkin 模型中的会被合并成一个 span；这样就会导致 server -&gt; server 的情况，与 zipkin 的 client -&gt; server 链路模型有冲突。如下图（绿色为SOFATracer span，黄色为 zipkin span）： </p>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1537974797330-7db6f317-7b42-4758-819d-ae106cb22b84.png" alt="img"></p>
<p> 通过分析 zipkin 的构建过程，适配 SOFARPC 上报数据时，SOFARPC server span 的 remoteEndpoint 不能依赖 SOFARPC client span 的 localEndpoint，而应该依赖 SOFARPC client parentSpan 的 localEndpoint。下图为 SOFARPC 适配之后的依赖关系图：</p>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1536298481412-5b52aedc-86f1-4dec-bae1-164dbd72e1d5.png" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 本文从 OpenTracing 规范说起，对 OpenTracing 规范中的模型和行为进行了简单的描述。结合 OpenTracing 规范，介绍了蚂蚁金服 SOFATracer 分布式链路跟踪的模型实现。在此基础上，对 SOFATracer 的数据上报功能进行了详细的分析，包括基于 disruptor 实现的异步日志落盘和上报数据到zipkin；最后对 SOFATracer 和  Zipkin 模型转换原理进行了说明，并对 SOFARPC 模型数据的上报处理进行了解析。</p>
<h2 id="相关文档链接"><a href="#相关文档链接" class="headerlink" title="相关文档链接"></a>相关文档链接</h2><ul>
<li><a href="https://github.com/alipay/sofa-tracer" target="_blank" rel="noopener">SOFATracer GitHub</a></li>
<li><a href="https://zipkin.io/" target="_blank" rel="noopener">Zipkin 官网</a></li>
<li><a href="https://github.com/openzipkin/zipkin" target="_blank" rel="noopener">Zipkin GitHub</a></li>
<li><a href="http://opentracing.io/documentation/pages/spec.html" target="_blank" rel="noopener">opentracing 规范</a></li>
<li><a href="http://opentracing.io/" target="_blank" rel="noopener">opentracing 官网</a></li>
<li><a href="https://github.com/LMAX-Exchange/disruptor" target="_blank" rel="noopener">disruptor</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/sofa-tracer-zipkin/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/sofa-tracer-disruptor/">SOFATracer 中 Disruptor 实践</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T04:26:20.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/sofa-tracer-disruptor/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/SOFATracer/" title="SOFATracer">SOFATracer</a>,
  
    <a href="/tags/Disruptor/" title="Disruptor">Disruptor</a>,
  
    <a href="/tags/OpenTracing/" title="OpenTracing">OpenTracing</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<h2 id="OpenTraceing-规范"><a href="#OpenTraceing-规范" class="headerlink" title="OpenTraceing 规范"></a>OpenTraceing 规范</h2><ul>
<li><a href="https://github.com/opentracing-contrib/opentracing-specification-zh/blob/master/specification.md" target="_blank" rel="noopener">OpenTracing语义标准</a></li>
<li><a href="https://github.com/opentracing-contrib/opentracing-specification-zh/blob/master/semantic_conventions.md" target="_blank" rel="noopener">语义惯例</a></li>
<li><a href="http://opentracing.io/documentation/pages/spec" target="_blank" rel="noopener">官方文档</a></li>
</ul>
<h2 id="SOFATracer-对-OpenTraceing-的实现"><a href="#SOFATracer-对-OpenTraceing-的实现" class="headerlink" title="SOFATracer 对 OpenTraceing 的实现"></a>SOFATracer 对 OpenTraceing 的实现</h2><blockquote>
<p>SOFATracer  就是根据 OpenTracing 规范 衍生出来的分布式 链路跟 踪的解决方案。</p>
</blockquote>
<ul>
<li><a href="https://github.com/alipay/sofa-tracer" target="_blank" rel="noopener">GitHub SOFATrcer</a></li>
</ul>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>OpenTracing</code> 标准中有三个重要的相互关联的类型，分别是<code>Tracer</code>, <code>Span</code>和 <code>SpanContext</code>。</p>
<blockquote>
<p>【下面的概念说明过程中，如不做说明，所使用的案例代码均以SOFATracer中的实现为例。】</p>
</blockquote>
<h3 id="Tracer"><a href="#Tracer" class="headerlink" title="Tracer"></a>Tracer</h3><p>一个 <code>trace</code> 代表一个潜在的，分布式的，存在并行数据或并行执行轨迹（潜在的分布式、并行）的系统。一个<code>trace</code>可以认为是多个<code>span</code>的有向无环图（<code>DAG</code>）。</p>
<p>Tracer接口用来创建Span，以及处理如何处理Inject(serialize) 和 Extract (deserialize)，用于跨进程边界传递。</p>
<p><code>SOFATracer</code> 中 <code>SofaTracer</code>这个类实现了 <code>opentracing</code> 的 <code>Tracer</code> 接口，并在此规范接口上做了一些扩展。看下<code>Tracer</code> 中声明的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tracer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//启动一个新的span</span></span><br><span class="line">    <span class="function">SpanBuilder <span class="title">buildSpan</span><span class="params">(String operationName)</span></span>;</span><br><span class="line">    <span class="comment">//将SpanContext上下文Inject（注入）到carrier</span></span><br><span class="line">    &lt;C&gt; <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(SpanContext spanContext, Format&lt;C&gt; format, C carrier)</span></span>;</span><br><span class="line">    <span class="comment">//将SpanContext上下文从carrier中Extract（提取）</span></span><br><span class="line">    &lt;C&gt; <span class="function">SpanContext <span class="title">extract</span><span class="params">(Format&lt;C&gt; format, C carrier)</span></span>;   </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">SpanBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以从接口定义来看，要实现一个Tracer，必须要实现其以下的几个能力：</p>
<h4 id="启动一个新的span"><a href="#启动一个新的span" class="headerlink" title="启动一个新的span"></a>启动一个新的span</h4><p><code>SOFATracer</code> 实现了 <code>Tracer</code> 中 <code>buildSpan</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpanBuilder <span class="title">buildSpan</span><span class="params">(String operationName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SofaTracerSpanBuilder(operationName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>operationName</code> :操作名称，字符串类型，表示由Span完成的工作 (例如，RPC方法名称、函数名称或一个较大的计算任务中的阶段的名称)。操作名称应该用泛化的字符串形式标识出一个Span实例。</p>
<p>何为泛化的字符串形式，比如现在有一个操作：获取用户 ；下面有几种标识方式：</p>
<ul>
<li>1、/get</li>
<li>2、/get/user</li>
<li>3、/get/user/123</li>
</ul>
<p>方式1过于抽象，方式3过于具体。方式2是正确的操作名。</p>
<h4 id="将SpanContext上下文Inject（注入）到carrier"><a href="#将SpanContext上下文Inject（注入）到carrier" class="headerlink" title="将SpanContext上下文Inject（注入）到carrier"></a>将SpanContext上下文Inject（注入）到carrier</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;C&gt; <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(SpanContext spanContext, Format&lt;C&gt; format, C carrier)</span> </span>&#123;</span><br><span class="line">    RegistryExtractorInjector&lt;C&gt; registryInjector = TracerFormatRegistry.getRegistry(format);</span><br><span class="line">    <span class="keyword">if</span> (registryInjector == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported injector format: "</span> + format);</span><br><span class="line">    &#125;</span><br><span class="line">    registryInjector.inject((SofaTracerSpanContext) spanContext, carrier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>SpanContext</code> :实例</li>
<li><code>format</code>（格式化）描述，一般会是一个字符串常量，但不做强制要求。通过此描述，通知Tracer实现，如何对SpanContext进行编码放入到carrier中。<br>carrier，根据format确定。Tracer实现根据format声明的格式，将SpanContext序列化到carrier对象中。</li>
</ul>
<blockquote>
<p>RegistryExtractorInjector 见后面</p>
</blockquote>
<h4 id="将SpanContext上下文从carrier中Extract（提取）"><a href="#将SpanContext上下文从carrier中Extract（提取）" class="headerlink" title="将SpanContext上下文从carrier中Extract（提取）"></a>将SpanContext上下文从carrier中Extract（提取）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;C&gt; <span class="function">SpanContext <span class="title">extract</span><span class="params">(Format&lt;C&gt; format, C carrier)</span> </span>&#123;</span><br><span class="line">    RegistryExtractorInjector&lt;C&gt; registryExtractor = TracerFormatRegistry.getRegistry(format);</span><br><span class="line">    <span class="keyword">if</span> (registryExtractor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported extractor format: "</span> + format);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> registryExtractor.extract(carrier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>格式描述符(<code>format descriptor</code>)(通常但不一定是字符串常量)，告诉<code>Tracer</code>的实现如何在载体对象中对<code>SpanContext</code>进行编码</li>
<li>载体(<code>carrier</code>)，其类型由格式描述符指定<code>。Tracer</code>的实现将根据格式描述对此载体对象中的<code>SpanContext</code>进行编码</li>
</ul>
<p>返回一个<code>SpanContext</code>实例，可以使用这个<code>SpanContext</code>实例，通过<code>Tracer</code>创建新的<code>Span</code>。</p>
<h4 id="Format"><a href="#Format" class="headerlink" title="Format"></a>Format</h4><p>从<code>Tracer</code>的注入和提取来看，<code>format</code>都是必须的。</p>
<p><code>Inject</code>（注入）和<code>Extract</code>（提取）依赖于可扩展的<code>format</code>参数。<code>forma</code>t参数规定了另一个参数<code>&quot;carrier&quot;</code>的类型，同时约束了<code>&quot;carrier&quot;</code>中<code>SpanContext</code>是如何编码的。所有的<code>Tracer</code>实现，都必须支持下面的<code>format</code>。</p>
<ul>
<li><code>Text Map</code>: 基于字符串：字符串的<code>map</code>,对于<code>key</code>和<code>value</code>不约束字符集。</li>
<li><code>HTTP Headers</code>: 适合作为<code>HTTP</code>头信息的，基于字符串：字符串的<code>map</code>。（<code>RFC 7230.</code>在工程实践中，如何处理<code>HTTP</code>头具有多样性，强烈建议<code>tracer</code>的使用者谨慎使用<code>HTTP</code>头的键值空间和转义符）</li>
<li><code>Binary</code>: 一个简单的二进制大对象，记录<code>SpanContext</code>的信息。</li>
</ul>
<p>在上面的注入和提取代码中，有如下代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注入</span></span><br><span class="line">RegistryExtractorInjector&lt;C&gt; registryInjector  = </span><br><span class="line">    TracerFormatRegistry.getRegistry(format);</span><br><span class="line"><span class="comment">//提取</span></span><br><span class="line">RegistryExtractorInjector&lt;C&gt; registryExtractor = </span><br><span class="line">    TracerFormatRegistry.getRegistry(format);</span><br></pre></td></tr></table></figure>
<p>来通过<code>TracerFormatRegistry</code>这个类来来看下 <code>SOFATracer</code> 中的 <code>Format</code> 的具体实现。</p>
<h4 id="X-B3"><a href="#X-B3" class="headerlink" title="X-B3"></a>X-B3</h4><p>在看<code>Format</code>之前，先了解下<code>X-B3</code>。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Expose-Headers</span>: </span><br><span class="line"><span class="attribute">X-B3-TraceId,X-B3-ParentSpanId,X-B3-SpanId</span></span><br></pre></td></tr></table></figure>
<p><code>HTTP</code>请求时其<code>span</code>参数通过<code>http headers</code>来传递追踪信息；<code>header</code>中对应的<code>key</code>分别是:</p>
<ul>
<li>X-B3-TraceId: 64 encoded bits（id被encode为hex Strings）</li>
<li>X-B3-SpanId : 64 encoded bits</li>
<li>X-B3-ParentSpanId: 64 encoded bits</li>
<li>X-B3-Sampled:(是否采样) Boolean (either “1” or “0”)（下面的调用是否进行采样）</li>
<li>X-B3-Flags:a Long</li>
</ul>
<h4 id="SOFATracer-中的-Format"><a href="#SOFATracer-中的-Format" class="headerlink" title="SOFATracer 中的 Format"></a>SOFATracer 中的 Format</h4><p>具体代码在 <code>tracer-core -&gt; com.alipay.common.tracer.core.registy</code> 包下:</p>
<ul>
<li>TextMapFormatter</li>
<li>TextMapB3Formatter</li>
<li>HttpHeadersFormatter</li>
<li>HttpHeadersB3Formatter</li>
<li>BinaryFormater</li>
</ul>
<p><strong>BinaryFormater</strong>：这个的注入和提取实现没有编解码一说；本身就是基于二进制流的操作。</p>
<p><strong>TextMapB3Formatter/TextMapFormatter</strong> 和 <strong>HttpHeadersB3Formatter/HttpHeadersFormatter</strong> 区别就在于编解码不同。<code>HttpHeadersB3Formatter</code>使用的是 <code>URLDecoder.decode</code> &amp;&amp; <code>URLDecoder.encode</code> ; <code>TextMapB3Formatter</code> 返回的是值本身（如果为空或者<code>null</code>则返回空字符串）。</p>
<p><strong>TextMapFormatter</strong>和<strong>TextMapB3Formatter</strong>区别在于注入或者提取是使用的<code>key</code>不用。<code>TextMapB3Formatter</code>中使用的是 <code>x-b3-{}</code> 的字符串作为<code>key</code>。</p>
<h3 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h3><p>一个<code>span</code>代表系统中具有开始时间和执行时长的逻辑运行单元。<code>span</code>之间通过嵌套或者顺序排列建立逻辑因果关系。当<code>Span</code>结束后(<code>span.finish()</code>)，除了通过<code>Span</code>获取<code>SpanContext</code>外，下列其他所有方法都不允许被调用。</p>
<p>同样先来看下<code>opentracing</code>规范<code>api</code> 定义的 <code>span</code> 的定义及方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Span</span> <span class="keyword">extends</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="function">SpanContext <span class="title">context</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(<span class="keyword">long</span> finishMicros)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">setTag</span><span class="params">(String key, String value)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">setTag</span><span class="params">(String key, <span class="keyword">boolean</span> value)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">setTag</span><span class="params">(String key, Number value)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">log</span><span class="params">(Map&lt;String, ?&gt; fields)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">log</span><span class="params">(<span class="keyword">long</span> timestampMicroseconds, Map&lt;String, ?&gt; fields)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">log</span><span class="params">(String event)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">log</span><span class="params">(<span class="keyword">long</span> timestampMicroseconds, String event)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">setBaggageItem</span><span class="params">(String key, String value)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getBaggageItem</span><span class="params">(String key)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">setOperationName</span><span class="params">(String operationName)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">log</span><span class="params">(String eventName, <span class="comment">/* @Nullable */</span> Object payload)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">log</span><span class="params">(<span class="keyword">long</span> timestampMicroseconds, String eventName, <span class="comment">/* @Nullable */</span> Object payload)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过Span获取SpanContext"><a href="#通过Span获取SpanContext" class="headerlink" title="通过Span获取SpanContext"></a>通过Span获取SpanContext</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SOFATracerSpan</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpanContext <span class="title">context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sofaTracerSpanContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回值，<code>Span</code>构建时传入的<code>SpanContext</code>。这个返回值在<code>Span</code>结束后(<code>span.finish()</code>)，依然可以使用。</p>
<h4 id="复写操作名"><a href="#复写操作名" class="headerlink" title="复写操作名"></a>复写操作名</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Span <span class="title">setOperationName</span><span class="params">(String operationName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.operationName = operationName;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>operationName</strong>:新的操作名，覆盖构建<code>Span</code>时，传入的操作名。</p>
<h4 id="结束Span"><a href="#结束Span" class="headerlink" title="结束Span"></a>结束Span</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.finish(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(<span class="keyword">long</span> endTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setEndTime(endTime);</span><br><span class="line">    <span class="comment">//关键记录:report span</span></span><br><span class="line">    <span class="keyword">this</span>.sofaTracer.reportSpan(<span class="keyword">this</span>);</span><br><span class="line">    SpanExtensionFactory.logStoppedSpan(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个可选参数，如果指定完成时间则使用当前指定的时间；如果省略此参数，使用当前时间作为完成时间。<code>finish</code>方法中会将当前<code>span</code>进行<code>report</code>操作。</p>
<h4 id="为Span设置tag"><a href="#为Span设置tag" class="headerlink" title="为Span设置tag"></a>为Span设置tag</h4><p><code>Tag</code>是一个<code>key:value</code>格式的数据。<code>key</code>必须是<code>String</code>类型，<code>value</code>可以是<strong>字符串、布尔或者数字</strong>。</p>
<ul>
<li>字符串类型的value 设置tag</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Span <span class="title">setTag</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(key) || StringUtils.isBlank(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.tagsWithStr.put(key, value);</span><br><span class="line">    <span class="comment">//注意:server 还是 client 在 OpenTracing 标准中是用 tags 标识的,所以在这里进行判断</span></span><br><span class="line">    <span class="keyword">if</span> (isServer()) &#123;</span><br><span class="line">        Reporter serverReporter = <span class="keyword">this</span>.sofaTracer.getServerReporter();</span><br><span class="line">        <span class="keyword">if</span> (serverReporter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.setLogType(serverReporter.getReporterType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isClient()) &#123;</span><br><span class="line">        Reporter clientReporter = <span class="keyword">this</span>.sofaTracer.getClientReporter();</span><br><span class="line">        <span class="keyword">if</span> (clientReporter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.setLogType(clientReporter.getReporterType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>布尔类型的value 设置tag</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Span <span class="title">setTag</span><span class="params">(String key, <span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.tagsWithBool.put(key, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>数字类型的value 设置tag</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Span <span class="title">setTag</span><span class="params">(String key, Number number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.tagsWithNumber.put(key, number);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Log结构化数据"><a href="#Log结构化数据" class="headerlink" title="Log结构化数据"></a>Log结构化数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Span <span class="title">log</span><span class="params">(<span class="keyword">long</span> currentTime, Map&lt;String, ?&gt; map)</span> </span>&#123;</span><br><span class="line">    AssertUtils.isTrue(currentTime &gt;= startTime, <span class="string">"current time must greater than start time"</span>);</span><br><span class="line">    <span class="keyword">this</span>.logs.add(<span class="keyword">new</span> LogData(currentTime, map));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Span <span class="title">log</span><span class="params">(Map&lt;String, ?&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.log(System.currentTimeMillis(), map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Map&lt;String, ?&gt; map</strong> : 键必须是字符串类型，值可以是任意类型</li>
<li><strong>currentTime</strong> : 时间戳。如果指定时间戳，那么它必须在<code>span</code>的开始和结束时间之内。</li>
</ul>
<h4 id="设置一个baggage（随行数据）元素"><a href="#设置一个baggage（随行数据）元素" class="headerlink" title="设置一个baggage（随行数据）元素"></a>设置一个baggage（随行数据）元素</h4><p><code>Baggage</code>元素是一个键值对集合，将这些值设置给给定的<code>Span</code>，<code>Span</code>的<code>SpanContext</code>，以及所有和此<code>Span</code>有直接或者间接关系的本地<code>Span</code>。 也就是说，<code>baggage</code>元素随<code>trace</code>一起保持在带内传递。（译者注：带内传递，在这里指，随应用程序调用过程一起传递）</p>
<p><code>Baggage</code>元素为<code>OpenTracing</code>的实现全栈集成，提供了强大的功能 （例如：任意的应用程序数据，可以在移动端创建它，显然的，它会一直传递了系统最底层的存储系统。由于它如此强大的功能，他也会产生巨大的开销，请小心使用此特性。</p>
<p>再次强调，请谨慎使用此特性。每一个键值都会被拷贝到每一个本地和远程的下级相关的<code>span</code>中，因此，总体上，他会有明显的网络和<code>CPU</code>开销。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Span <span class="title">setBaggageItem</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sofaTracerSpanContext.setBizBaggageItem(key, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SofaTracerSpan-中的属性"><a href="#SofaTracerSpan-中的属性" class="headerlink" title="SofaTracerSpan 中的属性"></a>SofaTracerSpan 中的属性</h4><ul>
<li>sofaTracer  : 当前 tracer</li>
<li>spanReferences : 当前span的关系，ChildOf(引用) or FollowsFrom（跟随）</li>
<li>tagsWithStr : String 类型的tag 集合</li>
<li>tagsWithBool : 布尔类型的tag集合</li>
<li>tagsWithNumber : 数值类型的tag集合</li>
<li>logs : log结构化数据列表，通过span.log（map）操作的map,均存储在logs中。</li>
<li>operationName：当前span的操作名</li>
<li>sofaTracerSpanContext：当前 spanContext</li>
<li>startTime : 当前span 开始时间</li>
<li>endTime  : 当前span 结束时间，在finish方法中传入。</li>
<li>logType : report时才有意义:摘要日志类型,日志能够正确打印的关键信息；当前 span 的日志类型,如:客户端为 rpc-client-digest.log,服务端为 rpc-server-digest.log</li>
<li>parentSofaTracerSpan：父亲 span,当作为客户端结束并弹出线程上下文时,需要将父亲 span 再放入</li>
</ul>
<h4 id="SpanContext"><a href="#SpanContext" class="headerlink" title="SpanContext"></a>SpanContext</h4><p><code>opentracing</code> 中 <code>SpanContext</code> 接口中只有一个<code>baggageItems</code>方法，通过这个方法来遍历所有的<code>baggage</code>元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpanContext</span> </span>&#123;</span><br><span class="line">    Iterable&lt;Map.Entry&lt;String, String&gt;&gt; baggageItems();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相对于<code>OpenTracing</code>中其他的功能，<code>SpanContext</code>更多的是一个“概念”。也就是说，<code>OpenTracing</code>实现中，需要重点考虑，并提供一套自己的<code>API</code>。</p>
<p><code>OpenTracing</code>的使用者仅仅需要，在创建<code>span</code>、向传输协议<code>Inject</code>（注入）和从传输协议中<code>Extract</code>（提取）时，使用<code>SpanContext</code>和<code>references</code>，</p>
<p><code>OpenTracing</code>要求，<code>SpanContext</code>是不可变的，目的是防止由于<code>Span</code>的结束和相互关系，造成的复杂生命周期问题。</p>
<h2 id="Disruptor-简介"><a href="#Disruptor-简介" class="headerlink" title="Disruptor 简介"></a>Disruptor 简介</h2><blockquote>
<p>A High Performance Inter-Thread Messaging Library 高性能的线程间消息传递库</p>
</blockquote>
<p>关于 Disruptor 的 一些原理分析可以参考：<a href="https://ifeve.com/disruptor/" target="_blank" rel="noopener">disruptor</a></p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>先通过 <code>Disruptor</code> 的一个小例子来有个直观的认识；先看下它的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Disruptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> EventFactory&lt;T&gt; eventFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">int</span> ringBufferSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ProducerType producerType,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> WaitStrategy waitStrategy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(</span><br><span class="line">        RingBuffer.create(producerType, eventFactory, ringBufferSize, waitStrategy),</span><br><span class="line">        <span class="keyword">new</span> BasicExecutor(threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>eventFactory : 在环形缓冲区中创建事件的 <code>factory</code></li>
<li>ringBufferSize:环形缓冲区的大小，必须是2的幂。</li>
<li>threadFactory：用于为处理器创建线程。</li>
<li>producerType：生成器类型以支持使用正确的<code>sequencer</code>和<code>publisher</code>创建<code>RingBuffer</code>；枚举类型，<code>SINGLE</code>、<code>MULTI</code>两个项。对应于 <code>SingleProducerSequencer</code>和<code>MultiProducerSequencer</code>两种<code>Sequencer</code>。</li>
<li>waitStrategy : 等待策略；</li>
</ul>
<p>如果我们想构造一个<code>disruptor</code>,那么我们就需要上面的这些组件。从<code>eventFactory</code>来看，还需要一个具体的<code>Event</code>来作为消息事件的载体。【下面按照官方给的案例进行简单的修改作为示例】</p>
<h3 id="消息事件-LongEvent-，能够被消费的数据载体"><a href="#消息事件-LongEvent-，能够被消费的数据载体" class="headerlink" title="消息事件 LongEvent ，能够被消费的数据载体"></a>消息事件 LongEvent ，能够被消费的数据载体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建消息事件的factory"><a href="#创建消息事件的factory" class="headerlink" title="创建消息事件的factory"></a>创建消息事件的factory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventFactory</span> <span class="keyword">implements</span> <span class="title">EventFactory</span>&lt;<span class="title">LongEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LongEvent <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LongEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ConsumerThreadFactory"><a href="#ConsumerThreadFactory" class="headerlink" title="ConsumerThreadFactory"></a>ConsumerThreadFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger index = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"disruptor-thread-"</span> + index.getAndIncrement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK ，上面的这些可以满足创建一个<code>disruptor</code>了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ringBufferCapacity = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//消息事件生产Factory</span></span><br><span class="line">LongEventFactory longEventFactory = <span class="keyword">new</span> LongEventFactory();</span><br><span class="line"><span class="comment">//执行事件处理器线程Factory</span></span><br><span class="line">ConsumerThreadFactory consumerThreadFactory = <span class="keyword">new</span> ConsumerThreadFactory();</span><br><span class="line"><span class="comment">//用于环形缓冲区的等待策略。</span></span><br><span class="line">WaitStrategy waitStrategy = <span class="keyword">new</span> BlockingWaitStrategy();</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建disruptor</span></span><br><span class="line">Disruptor&lt;LongEvent&gt; disruptor = <span class="keyword">new</span> Disruptor&lt;&gt;(</span><br><span class="line">    longEventFactory,</span><br><span class="line">    ringBufferCapacity,</span><br><span class="line">    longEventThreadFactory,</span><br><span class="line">    ProducerType.SINGLE,</span><br><span class="line">    waitStrategy);</span><br></pre></td></tr></table></figure>
<p>现在是已经有了 <code>disruptor</code> 了，然后通过：<code>start</code> 来启动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动 disruptor</span></span><br><span class="line"> disruptor.start();</span><br></pre></td></tr></table></figure>
<p>到这里，已经构建了一个<code>disruptor</code>；但是目前怎么使用它来发布消息和消费消息呢？</p>
<h3 id="发布消息"><a href="#发布消息" class="headerlink" title="发布消息"></a>发布消息</h3><p>下面在 <code>for</code> 循环中 发布 5 条数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> l = <span class="number">0</span>; l &lt; <span class="number">5</span>; l++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> sequence = ringBuffer.next();</span><br><span class="line">    LongEvent event = ringBuffer.get(sequence);</span><br><span class="line">    event.set(<span class="number">100</span>+l);</span><br><span class="line">    System.out.println(<span class="string">"publish event :"</span> + l);</span><br><span class="line">    ringBuffer.publish(sequence);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息已经发布，下面需要设定当前<code>disruptor</code>的消费处理器。前面已经有个<code>LongEvent</code> 和 <code>EventFactory</code> ; 在<code>disruptor</code>中是通过 <code>EventHandler</code> 来进行消息消费的。</p>
<h3 id="编写消费者代码"><a href="#编写消费者代码" class="headerlink" title="编写消费者代码"></a>编写消费者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventHandler</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">LongEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(LongEvent event, <span class="keyword">long</span> sequence, <span class="keyword">boolean</span> endOfBatch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Event: "</span> + event.getValue()+<span class="string">" -&gt; "</span> + Thread.currentThread().getName());</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 <code>eventHandler</code> 设置到 <code>disruptor</code> 的处理链上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将处理事件的事件处理程序 -&gt; 消费事件的处理程序</span></span><br><span class="line">LongEventHandler longEventHandler = <span class="keyword">new</span> LongEventHandler();</span><br><span class="line">disruptor.handleEventsWith(longEventHandler);</span><br></pre></td></tr></table></figure>
<h3 id="运行结果（这里）："><a href="#运行结果（这里）：" class="headerlink" title="运行结果（这里）："></a>运行结果（这里）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">publish event :0</span><br><span class="line">Event: 0 -&gt; disruptor-thread-1</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :1</span><br><span class="line">Event: 1 -&gt; disruptor-thread-1</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :2</span><br><span class="line">Event: 2 -&gt; disruptor-thread-1</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :3</span><br><span class="line">Event: 3 -&gt; disruptor-thread-1</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :4</span><br><span class="line">Event: 4 -&gt; disruptor-thread-1</span><br><span class="line">--------------------------------&gt;</span><br></pre></td></tr></table></figure>
<h2 id="基本概念和原理"><a href="#基本概念和原理" class="headerlink" title="基本概念和原理"></a>基本概念和原理</h2><h3 id="Disruptor"><a href="#Disruptor" class="headerlink" title="Disruptor"></a>Disruptor</h3><p>整个基于<code>ringBuffer</code>实现的生产者消费者模式的容器。主要属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RingBuffer&lt;T&gt; ringBuffer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConsumerRepository&lt;T&gt; consumerRepository = <span class="keyword">new</span> ConsumerRepository&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean started = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">private</span> ExceptionHandler&lt;? <span class="keyword">super</span> T&gt; exceptionHandler = <span class="keyword">new</span> ExceptionHandlerWrapper&lt;&gt;();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ringBuffer</code>：内部持有一个 <code>RingBuffer</code> 对象，<code>Disruptor</code> 内部的事件发布都是依赖这个<code>RingBuffer</code>对象完成的。</li>
<li><code>executor</code>：消费事件的线程池</li>
<li><code>consumerRepository</code>：提供存储库机制，用于将<code>EventHandler</code>与<code>EventProcessor</code>关联起来</li>
<li><code>started</code> : 用于标志当前<code>Disruptor</code>是否已经启动</li>
<li><code>exceptionHandler</code> : 异常处理器，用于处理<code>BatchEventProcessor</code>事件周期中 <code>uncaught exceptions</code> 。</li>
</ul>
<h3 id="RingBuffer"><a href="#RingBuffer" class="headerlink" title="RingBuffer"></a>RingBuffer</h3><p>环形队列[实现上是一个数组]，可以类比为<code>BlockingQueue</code>之类的队列，<code>ringBuffer</code>的使用，使得内存被循环使用，减少了某些场景的内存分配回收扩容等耗时操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RingBuffer</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">RingBufferFields</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Cursored</span>, <span class="title">EventSequencer</span>&lt;<span class="title">E</span>&gt;, <span class="title">EventSink</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>E：在事件的交换或并行协调期间存储用于共享的数据的实现 -&gt; 消息事件</li>
</ul>
<h3 id="Sequencer"><a href="#Sequencer" class="headerlink" title="Sequencer"></a>Sequencer</h3><p> <code>RingBuffer</code> 中 生产者的顶级父接口，其直接实现有<code>SingleProducerSequencer</code>和<code>MultiProducerSequencer</code>；对应 <code>SINGLE</code>、<code>MULTI</code> 两个枚举值。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16504080427c32c5?w=1046&amp;h=768&amp;f=png&amp;s=52527" alt=""></p>
<h3 id="EventHandler"><a href="#EventHandler" class="headerlink" title="EventHandler"></a>EventHandler</h3><p>事件处置器，改接口用于对外扩展来实现具体的消费逻辑。如上面 <code>demo</code> 中的 <code>LongEventHandler</code> ;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回调接口，用于处理&#123;@link RingBuffer&#125;中可用的事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(T event, <span class="keyword">long</span> sequence, <span class="keyword">boolean</span> endOfBatch)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>event</code> : <code>RingBuffer</code> 已经发布的事件</li>
<li><code>sequence</code> : 正在处理的事件 的序列号</li>
<li><code>endOfBatch</code> : 用来标识否是来自 <code>RingBuffer</code> 的批次中的最后一个事件</li>
</ul>
<h3 id="SequenceBarrier"><a href="#SequenceBarrier" class="headerlink" title="SequenceBarrier"></a>SequenceBarrier</h3><p>消费者路障。规定了消费者如何向下走。事实上，该路障算是变向的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessingSequenceBarrier</span> <span class="keyword">implements</span> <span class="title">SequenceBarrier</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当等待（探测）的需要不可用时，等待的策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WaitStrategy waitStrategy;</span><br><span class="line">    <span class="comment">//依赖的其它Consumer的序号，这个用于依赖的消费的情况，</span></span><br><span class="line">    <span class="comment">//比如A、B两个消费者，只有A消费完，B才能消费。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sequence     dependentSequence;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span>   alerted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//Ringbuffer的写入指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sequence     cursorSequence;</span><br><span class="line">    <span class="comment">//RingBuffer对应的Sequencer</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sequencer    sequencer;</span><br><span class="line">    <span class="comment">//exclude method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>waitStrategy</code> 决定了消费者采用何种等待策略。</p>
<h3 id="WaitStrategy"><a href="#WaitStrategy" class="headerlink" title="WaitStrategy"></a>WaitStrategy</h3><blockquote>
<p>Strategy employed for making {@link EventProcessor}s wait on a cursor {@link Sequence}.</p>
</blockquote>
<p><code>EventProcessor</code> 的等待策略；具体实现在 <code>disruptor</code> 中有8种，</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/4/165040897c8cd0fd?w=429&amp;h=184&amp;f=png&amp;s=70264" alt=""></p>
<p>这些等待策略不同的核心体现是在如何实现 <code>waitFor</code> 这个方法上。</p>
<h3 id="EventProcessor"><a href="#EventProcessor" class="headerlink" title="EventProcessor"></a>EventProcessor</h3><p>事件处理器，实际上可以理解为消费者模型的框架，实现了线程<code>Runnable</code>的<code>run</code>方法，将循环判断等操作封在了里面。该接口有三个实现类:</p>
<p><strong>1、BatchEventProcessor</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchEventProcessor</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">EventProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean           running          = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">private</span> ExceptionHandler&lt;? <span class="keyword">super</span> T&gt;   exceptionHandler = <span class="keyword">new</span> FatalExceptionHandler();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataProvider&lt;T&gt;         dataProvider;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SequenceBarrier         sequenceBarrier;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventHandler&lt;? <span class="keyword">super</span> T&gt; eventHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sequence                sequence         = <span class="keyword">new</span> Sequence(                                      Sequencer.INITIAL_CURSOR_VALUE);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimeoutHandler          timeoutHandler;</span><br><span class="line">    <span class="comment">//exclude method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ExceptionHandler：异常处理器</li>
<li>DataProvider：数据来源，对应 <code>RingBuffer</code></li>
<li>EventHandler：处理 <code>Event</code> 的回调对象</li>
<li>SequenceBarrier：对应的序号屏障</li>
<li>TimeoutHandler：超时处理器，默认情况为空，如果要设置，只需要要将关联的<code>EventHandler</code>实现<code>TimeOutHandler</code>即可。</li>
</ul>
<p>如果我们选择使用 <code>EventHandler</code> 的时候，默认使用的就是 <code>BatchEventProcessor</code>，它与<code>EventHandler</code>是一一对应，并且是单线程执行。</p>
<p>如果某个<code>RingBuffer</code>有多个<code>BatchEventProcessor</code>，那么就会每个<code>BatchEventProcessor</code>对应一个线程。</p>
<p><strong>2、WorkProcessor</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkProcessor</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">EventProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean running = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sequence sequence = <span class="keyword">new</span> Sequence(Sequencer.INITIAL_CURSOR_VALUE);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RingBuffer&lt;T&gt; ringBuffer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SequenceBarrier  sequenceBarrier;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WorkHandler&lt;? <span class="keyword">super</span> T&gt; workHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExceptionHandler&lt;? <span class="keyword">super</span> T&gt; exceptionHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sequence workSequence;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventReleaser eventReleaser = <span class="keyword">new</span> EventReleaser() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                sequence.set(Long.MAX_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimeoutHandler timeoutHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本和 <code>BatchEventProcessor</code> 类似，不同在于，用于处理<code>Event</code>的回调对象是<code>WorkHandler</code>。</p>
<h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/165040ee8a2eae73?w=1240&amp;h=750&amp;f=png&amp;s=312558" alt=""></p>
<h2 id="无消费者情况下，生产者保持生产，但是-remainingCapacity-保持不变"><a href="#无消费者情况下，生产者保持生产，但是-remainingCapacity-保持不变" class="headerlink" title="无消费者情况下，生产者保持生产，但是 remainingCapacity 保持不变"></a>无消费者情况下，生产者保持生产，但是 <code>remainingCapacity</code> 保持不变</h2><p>在写<code>demo</code>的过程中，本来想通过不设定 消费者 来观察 <code>RingBuffer</code> 可用容量变化的。但是验证过程中，一直得不到预期的结果，(注：没有设置消费者，只有生产者)，先看结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">publish event :0</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:0</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :1</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:1</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :2</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:2</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :3</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:3</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :4</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:4</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :5</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:5</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :6</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:6</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :7</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:7</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :8</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:8</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :9</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:9</span><br><span class="line">--------------------------------&gt;</span><br></pre></td></tr></table></figure>
<p>从结果来看，<code>remainingCapacity</code> 的值应该随着 发布的数量 递减的；但是实际上它并没有发生任何变化。</p>
<p>来看下<code>ringBuffer.remainingCapacity()</code> 这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the remaining capacity for this ringBuffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The number of slots remaining.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">remainingCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sequencer.remainingCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面又使用 <code>sequencer.remainingCapacity()</code>这个方法来计算的。上面的例子中使用的是<code>ProducerType.SINGLE</code>，那来看<code>SingleProducerSequencer</code> 这个里面<code>remainingCapacity</code>的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">remainingCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//上次申请完毕的序列值</span></span><br><span class="line">    <span class="keyword">long</span> nextValue = <span class="keyword">this</span>.nextValue;</span><br><span class="line">    <span class="comment">//计算当前已经消费到的序列值</span></span><br><span class="line">    <span class="keyword">long</span> consumed = Util.getMinimumSequence(gatingSequences, nextValue);</span><br><span class="line">    <span class="comment">//当前生产到的序列值</span></span><br><span class="line">    <span class="keyword">long</span> produced = nextValue;</span><br><span class="line">    <span class="keyword">return</span> getBufferSize() - (produced - consumed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来解释下这段代码的含义：</p>
<p>假设当前 <code>ringBuffer</code> 的 <code>bufferSize</code> 是 8 ；上次申请到的序列号是 5，其实也就是说已经生产过占用的序列号是5；假设当前已经消费到的序列号是 3，那么剩余的容量为： 8-（5-2） = 5；</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/4/1650414723061ce7?w=992&amp;h=744&amp;f=png&amp;s=310780" alt=""></p>
<p>因为这里我们可以确定 <code>bufferSize</code> 和 <code>produced</code> 的值了，那么 <code>remainingCapacity</code> 的结果就取决于<code>getMinimumSequence</code>的计算结果了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getMinimumSequence</span><span class="params">(<span class="keyword">final</span> Sequence[] sequences, <span class="keyword">long</span> minimum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = sequences.length; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> value = sequences[i].get();</span><br><span class="line">        minimum = Math.min(minimum, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是从 <code>Sequence</code> 数组中获取最小序列 。如果<code>sequences</code> 为空，则返回 <code>minimum</code>。回到上一步，看下<code>sequences</code>这个数组是从哪里过来的，它的值在哪里设置的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> consumed = Util.getMinimumSequence(gatingSequences, nextValue);</span><br></pre></td></tr></table></figure>
<p><code>gatingSequences</code>是 <code>SingleProducerSequencer</code>父类  <code>AbstractSequencer</code> 中的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> Sequence[] gatingSequences = <span class="keyword">new</span> Sequence[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p><code>gatingSequences</code> 是在下面这个方法里面来管理的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Sequencer#addGatingSequences(Sequence...)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addGatingSequences</span><span class="params">(Sequence... gatingSequences)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SequenceGroups.addSequences(<span class="keyword">this</span>, SEQUENCE_UPDATER, <span class="keyword">this</span>, gatingSequences);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的调用栈向前追溯有这几个地方调用了：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/4/1650415d0682db8f?w=1934&amp;h=560&amp;f=png&amp;s=203628" alt=""></p>
<p><code>WorkerPool</code>来管理多个消费者；<code>hangdlerEventsWith</code> 这个方法也是用来设置消费者的。但是在上面的测试案例中我们是想通过不设定消费者 只设定生成者 来观察 环形队列的占用情况，所以<code>gatingSequences</code> 会一直是空的，因此在计算时会把 <code>produced</code> 的值作为 <code>minimum</code> 返回。这样每次计算就相当于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> getBufferSize() - (produced - produced) === getBufferSize();</span><br></pre></td></tr></table></figure>
<p>也就验证了为何在不设定消费者的情况下，<code>remainingCapacity</code> 的值会一直保持不变。</p>
<h2 id="SOFATracer-中-Disruptor-实践"><a href="#SOFATracer-中-Disruptor-实践" class="headerlink" title="SOFATracer 中 Disruptor 实践"></a>SOFATracer 中 Disruptor 实践</h2><p><code>SOFATracer</code>中，<code>AsyncCommonDigestAppenderManager</code> 对 <code>disruptor</code> 进行了封装，用于处理外部组件的<code>Tracer</code>摘要日志。该部分借助 <code>AsyncCommonDigestAppenderManager</code> 的源码来分析下<code>SOFATracer</code>如何使用<code>disruptor</code>的。</p>
<p><code>SOFATracer</code>中使用了两种不同的事件模型，一种是<code>SOFATracer</code>内部使用的 <code>StringEvent</code> , 一种是 外部扩展使用的 <code>SofaTacerSpanEvent</code>。这里以 <code>SofaTacerSpanEvent</code> 这种事件模型来分析。<code>StringEvent</code> 消息事件模型对应的是 <code>AsyncCommonAppenderManager</code> 类封装的<code>disruptor</code>。</p>
<h3 id="SofaTracerSpanEvent-gt-LongEvent"><a href="#SofaTracerSpanEvent-gt-LongEvent" class="headerlink" title="SofaTracerSpanEvent ( -&gt; LongEvent)"></a>SofaTracerSpanEvent ( -&gt; LongEvent)</h3><p>定义消息事件模型，<code>SofaTacerSpanEvent</code> 和 前面 <code>demo</code> 中的 <code>LongEvent</code> 基本结构是一样的，主要是内部持有的消息数据不同，<code>LongEvent</code> 中是一个<code>long</code>类型的数据，<code>SofaTacerSpanEvent</code>中持有的是 <code>SofaTracerSpan</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaTracerSpanEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> SofaTracerSpan sofaTracerSpan;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SofaTracerSpan <span class="title">getSofaTracerSpan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sofaTracerSpan;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSofaTracerSpan</span><span class="params">(SofaTracerSpan sofaTracerSpan)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sofaTracerSpan = sofaTracerSpan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Consumer-gt-LongEventHandler"><a href="#Consumer-gt-LongEventHandler" class="headerlink" title="Consumer ( -&gt; LongEventHandler)"></a>Consumer ( -&gt; LongEventHandler)</h3><p><code>Consumer</code> 是 <code>AsyncCommonDigestAppenderManager</code> 的内部类;实现了 <code>EventHandler</code> 接口，这个<code>consumer</code>就是作为消费者存在的。</p>
<p>在<code>AsyncCommonAppenderManager</code>中也有一个，这个地方个人觉得可以抽出去，这样可以使得<code>AsyncCommonDigestAppenderManager/AsyncCommonAppenderManager</code>的代码看起来更干净；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">SofaTracerSpanEvent</span>&gt; </span>&#123;</span><br><span class="line">       <span class="comment">//日志类型集合，非该集合内的日志类型将不会被处理</span></span><br><span class="line">        <span class="keyword">protected</span> Set&lt;String&gt; logTypes = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;String&gt;());</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(SofaTracerSpanEvent event, <span class="keyword">long</span> sequence, <span class="keyword">boolean</span> endOfBatch)</span></span></span><br><span class="line"><span class="function">                                <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 拿到具体的消息数据 sofaTracerSpan</span></span><br><span class="line">            SofaTracerSpan sofaTracerSpan = event.getSofaTracerSpan();</span><br><span class="line">            <span class="comment">// 如果没有数据，则不做任何处理</span></span><br><span class="line">            <span class="keyword">if</span> (sofaTracerSpan != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String logType = sofaTracerSpan.getLogType();</span><br><span class="line">                    <span class="comment">// 验证当前日志类型是否可以被当前consumer消费</span></span><br><span class="line">                    <span class="keyword">if</span> (logTypes.contains(logType)) &#123;</span><br><span class="line">                        <span class="comment">// 获取编码类型</span></span><br><span class="line">                        SpanEncoder encoder = contextEncoders.get(logType);</span><br><span class="line">                        <span class="comment">//获取 appender</span></span><br><span class="line">                        TraceAppender appender = appenders.get(logType);</span><br><span class="line">                        <span class="comment">// 对数据进行编码处理</span></span><br><span class="line">                        String encodedStr = encoder.encode(sofaTracerSpan);</span><br><span class="line">                        <span class="keyword">if</span> (appender <span class="keyword">instanceof</span> LoadTestAwareAppender) &#123;</span><br><span class="line">                            ((LoadTestAwareAppender) appender).append(encodedStr,</span><br><span class="line">                                TracerUtils.isLoadTest(sofaTracerSpan));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            appender.append(encodedStr);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 刷新缓冲区，日志输出</span></span><br><span class="line">                        appender.flush();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   <span class="comment">// 异常省略</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLogType</span><span class="params">(String logType)</span> </span>&#123;</span><br><span class="line">            logTypes.add(logType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="SofaTracerSpanEventFactory-（-gt-LongEventFactory）"><a href="#SofaTracerSpanEventFactory-（-gt-LongEventFactory）" class="headerlink" title="SofaTracerSpanEventFactory （-&gt; LongEventFactory）"></a>SofaTracerSpanEventFactory （-&gt; LongEventFactory）</h3><p>用于产生消息事件的 <code>Factory</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaTracerSpanEventFactory</span> <span class="keyword">implements</span> <span class="title">EventFactory</span>&lt;<span class="title">SofaTracerSpanEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SofaTracerSpanEvent <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SofaTracerSpanEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ConsumerThreadFactory-gt-LongEventThreadFactory"><a href="#ConsumerThreadFactory-gt-LongEventThreadFactory" class="headerlink" title="ConsumerThreadFactory (-&gt; LongEventThreadFactory )"></a>ConsumerThreadFactory (-&gt; LongEventThreadFactory )</h3><p>用来产生消费线程的 <code>Factory</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String workName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWorkName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> workName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWorkName</span><span class="params">(String workName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workName = workName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        Thread worker = <span class="keyword">new</span> Thread(runnable, <span class="string">"Tracer-AsyncConsumer-Thread-"</span> + workName);</span><br><span class="line">        worker.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> worker;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建disruptor"><a href="#构建disruptor" class="headerlink" title="构建disruptor"></a>构建disruptor</h3><p><code>disruptor</code> 的构建是在 <code>AsyncCommonDigestAppenderManager</code> 的构造函数中完成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncCommonDigestAppenderManager</span><span class="params">(<span class="keyword">int</span> queueSize, <span class="keyword">int</span> consumerNumber)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用这个计算来保证realQueueSize是2的次幂（返回当前 大于等于queueSize的最小的2的次幂数 ）</span></span><br><span class="line">    <span class="keyword">int</span> realQueueSize = <span class="number">1</span> &lt;&lt; (<span class="number">32</span> - Integer.numberOfLeadingZeros(queueSize - <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//构建disruptor，使用的是 ProducerType.MULTI</span></span><br><span class="line">    <span class="comment">//等待策略是 BlockingWaitStrategy</span></span><br><span class="line">    disruptor = <span class="keyword">new</span> Disruptor&lt;SofaTracerSpanEvent&gt;(<span class="keyword">new</span> SofaTracerSpanEventFactory(),</span><br><span class="line">        realQueueSize, threadFactory, ProducerType.MULTI, <span class="keyword">new</span> BlockingWaitStrategy());</span><br><span class="line">    <span class="comment">//消费者列表</span></span><br><span class="line">    <span class="keyword">this</span>.consumers = <span class="keyword">new</span> ArrayList&lt;Consumer&gt;(consumerNumber);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; consumerNumber; i++) &#123;</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer();</span><br><span class="line">        consumers.add(consumer);</span><br><span class="line">        <span class="comment">//设置异常处理程序</span></span><br><span class="line">        disruptor.setDefaultExceptionHandler(<span class="keyword">new</span> ConsumerExceptionHandler());</span><br><span class="line">        <span class="comment">//绑定消费者</span></span><br><span class="line">        disruptor.handleEventsWith(consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否允许丢弃，从配置文件获取</span></span><br><span class="line">    <span class="keyword">this</span>.allowDiscard = Boolean.parseBoolean(SofaTracerConfiguration.getProperty(</span><br><span class="line">        SofaTracerConfiguration.TRACER_ASYNC_APPENDER_ALLOW_DISCARD, DEFAULT_ALLOW_DISCARD));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (allowDiscard) &#123;</span><br><span class="line">        <span class="comment">//是否记录丢失日志的数量</span></span><br><span class="line">        <span class="keyword">this</span>.isOutDiscardNumber = Boolean.parseBoolean(SofaTracerConfiguration.getProperty(</span><br><span class="line">            SofaTracerConfiguration.TRACER_ASYNC_APPENDER_IS_OUT_DISCARD_NUMBER,</span><br><span class="line">            DEFAULT_IS_OUT_DISCARD_NUMBER));</span><br><span class="line">        <span class="comment">//是否记录丢失日志的TraceId和RpcId</span></span><br><span class="line">        <span class="keyword">this</span>.isOutDiscardId = Boolean.parseBoolean(SofaTracerConfiguration.getProperty(</span><br><span class="line">            SofaTracerConfiguration.TRACER_ASYNC_APPENDER_IS_OUT_DISCARD_ID,</span><br><span class="line">            DEFAULT_IS_OUT_DISCARD_ID));</span><br><span class="line">        <span class="comment">//丢失日志的数量达到该阈值进行一次日志输出</span></span><br><span class="line">        <span class="keyword">this</span>.discardOutThreshold = Long.parseLong(SofaTracerConfiguration.getProperty(</span><br><span class="line">            SofaTracerConfiguration.TRACER_ASYNC_APPENDER_DISCARD_OUT_THRESHOLD,</span><br><span class="line">            DEFAULT_DISCARD_OUT_THRESHOLD));</span><br><span class="line">        <span class="keyword">if</span> (isOutDiscardNumber) &#123;</span><br><span class="line">            <span class="keyword">this</span>.discardCount = <span class="keyword">new</span> PaddedAtomicLong(<span class="number">0L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动-disruptor"><a href="#启动-disruptor" class="headerlink" title="启动 disruptor"></a>启动 disruptor</h3><p><code>disruptor</code>的启动委托给了<code>AsyncCommonDigestAppenderManager</code> 的<code>start</code>方法来执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">final</span> String workerName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.threadFactory.setWorkName(workerName);</span><br><span class="line">    <span class="keyword">this</span>.ringBuffer = <span class="keyword">this</span>.disruptor.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看下，<code>SOFATracer</code> 中 具体是在哪里调用这个<code>start</code> 的：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/4/165041aeac0dc066?w=576&amp;h=158&amp;f=png&amp;s=40516" alt=""></p>
<ul>
<li><code>CommonTracerManager</code> : 这个里面持有了<code>AsyncCommonDigestAppenderManager</code> 类的一个单例对象，并且是<code>static</code> 静态代码块中调用了<code>start</code>方法；这个用来输出普通日志。</li>
<li><code>SofaTracerDigestReporterAsyncManager</code>：这里类里面也是持有了<code>AsyncCommonDigestAppenderManager</code> 类的一个单例对像，并且提供了<code>getSofaTracerDigestReporterAsyncManager</code>方法来获取该单例，在这个方法中调用了<code>start</code>方法；该对象用来输出摘要日志。</li>
</ul>
<h3 id="发布事件"><a href="#发布事件" class="headerlink" title="发布事件"></a>发布事件</h3><p>前面的<code>demo</code>中是通过一个<code>for</code>循环来发布事件的，在 <code>SOFATracer</code> 中 的事件发布无非就是当有<code>Tracer</code>日志需要输出时会触发发布，那么对应的就是日志的 <code>append</code> 操作，将日志 <code>append</code> 到环形缓冲区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">append</span><span class="params">(SofaTracerSpan sofaTracerSpan)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">//是否允许丢弃</span></span><br><span class="line">    <span class="keyword">if</span> (allowDiscard) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//允许丢弃就使用tryNext尝试申请序列，申请不到抛出异常</span></span><br><span class="line">            sequence = ringBuffer.tryNext();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InsufficientCapacityException e) &#123;</span><br><span class="line">            <span class="comment">//是否输出丢失日志的TraceId和RpcId</span></span><br><span class="line">            <span class="keyword">if</span> (isOutDiscardId) &#123;</span><br><span class="line">                SofaTracerSpanContext sofaTracerSpanContext = sofaTracerSpan</span><br><span class="line">                    .getSofaTracerSpanContext();</span><br><span class="line">                <span class="keyword">if</span> (sofaTracerSpanContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    SynchronizingSelfLog.warn(<span class="string">"discarded tracer: traceId["</span></span><br><span class="line">                                              + sofaTracerSpanContext.getTraceId()</span><br><span class="line">                                              + <span class="string">"];spanId["</span> + sofaTracerSpanContext.getSpanId()</span><br><span class="line">                                              + <span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">//是否输出丢失日志的数量</span></span><br><span class="line">            <span class="keyword">if</span> ((isOutDiscardNumber) &amp;&amp; discardCount.incrementAndGet() == discardOutThreshold) &#123;</span><br><span class="line">                discardCount.set(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (isOutDiscardNumber) &#123;</span><br><span class="line">                    SynchronizingSelfLog.warn(<span class="string">"discarded "</span> + discardOutThreshold + <span class="string">" logs"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不允许丢弃则使用next方法</span></span><br><span class="line">        sequence = ringBuffer.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SofaTracerSpanEvent event = ringBuffer.get(sequence);</span><br><span class="line">        event.setSofaTracerSpan(sofaTracerSpan);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        SynchronizingSelfLog.error(<span class="string">"fail to add event"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发布</span></span><br><span class="line">    ringBuffer.publish(sequence);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SOFATracer 事件发布的调用逻辑：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/4/165041c4514a3102?w=1060&amp;h=1012&amp;f=png&amp;s=80785" alt=""></p>
<p>追溯调用的流程，可以知道当前 <code>span</code> 调用 <code>finish</code>时或者 <code>SOFATracer</code>中调用<code>reportSpan</code>时 就相当于发布了一个消息事件。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文对 <code>SOFATracer</code> 中使用 <code>Disruptor</code> 来进行日志输出的代码进行了简单的分析，更多内部细节原理可以自行看下<code>SOFATracer</code>的代码。<code>SOFATracer</code> 作为一种比较底层的中间件组件，在实际的业务开发中基本是无法感知的。但是作为技术来学习，还是有很多点可以挖一挖。</p>
<p><a href="https://github.com/alipay/sofa-tracer" target="_blank" rel="noopener">SOFATracer GitHub 传送门</a>。</p>
<blockquote>
<p>如果有小伙伴对中间件感兴趣，欢迎加入我们团队，欢迎来撩；对 SOFA 技术体系有兴趣的可以关注我们 <a href="https://github.com/alipay" target="_blank" rel="noopener">ALIPAY SOFA 社区</a>；附团队镇楼图。</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/4/1650426cfb443c99?w=1088&amp;h=708&amp;f=png&amp;s=1217313" alt=""></p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/sofa-tracer-disruptor/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
    </div>
    
      <div id="page-nav" class="pagination">
	<span class="page-number current">1</span>
      </div>
    
  </section>

</div>

</div>

</section>
</div>

    <!-- BEGIN PRE-FOOTER -->
    <div class="pre-footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN BOTTOM ABOUT BLOCK -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>About Us</h2>
            <p>Computer Lab is a software development and marketing company based in Brooklyn, New York. <br><br> Computer Lab was founded in 2015, and is focused on so on and so forth.</p>
          </div>
          <!-- END BOTTOM ABOUT BLOCK -->

          <!-- BEGIN BOTTOM CONTACTS -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>Contact</h2>
            <address class="margin-bottom-40">
              140 Metropolitan Avenue<br>
              5th Floor<br>
              Brooklyn, NY 11249<br>
              Phone: 716-472-4484<br>
              Email: <a href="mailto:ptsteadman@gmail.com">ptsteadman@gmail.com</a><br>
            </address>
          </div>
          <!-- END BOTTOM CONTACTS -->

	
          <!-- BEGIN TWITTER BLOCK --> 
          <div class="col-md-4 col-sm-6 pre-footer-col">

	  <a data-tweet-limit="1" class="twitter-timeline" href="https://twitter.com/computerlab_" data-widget-id="678830341331820544">Tweets by @computerlab_</a>

	  <script>!function(d,s,id){var
	  js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

          </div>
          <!-- END TWITTER BLOCK -->
	
        </div>
      </div>
    </div>
    <!-- END PRE-FOOTER -->

    <!-- BEGIN FOOTER -->
    <div class="footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN COPYRIGHT -->
          <div class="col-md-6 col-sm-6 padding-top-10">
                  &copy; 2020 glmapper<br>
 <a href="javascript:;">Privacy Policy</a> | <a href="javascript:;">Terms of Service</a>
          </div>
          <!-- END COPYRIGHT -->
	  <!-- BEGIN SOCIAL -->
<div class="col-md-6 col-sm-6">
  <ul class="social-footer list-unstyled list-inline pull-right">
    
      <li><a href="https://github.com/ptsteadman"><i class="fa fa-github"></i></a></li>
    
      <li><a href="https://twitter.com/ptsteadman"><i class="fa fa-twitter"></i></a></li>
    
      <li><a href="https://www.facebook.com/ptsteadman"><i class="fa fa-facebook"></i></a></li>
    
      <li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li>
    
      <li><a href="https://linkedin.com/in/ptsteadman"><i class="fa fa-linkedin"></i></a></li>
    
      <li><a href="http://stackoverflow.com/users/2480493/patrick-steadman"><i class="fa fa-stackoverflow"></i></a></li>
    
  </ul>  
</div>
<!-- END SOCIAL -->

        </div>
      </div>
    </div>
    <!-- END FOOTER -->

  <!-- BEGIN CORE PLUGINS (REQUIRED FOR ALL PAGES) -->
<!--[if lt IE 9]>
<script src="/metronic/assets/plugins/respond.min.js"></script>
<![endif]--> 
<script src="/metronic/assets/plugins/jquery.min.js"></script>
<script src="/metronic/assets/plugins/jquery-migrate.min.js"></script>
<script src="/metronic/assets/plugins/bootstrap/js/bootstrap.min.js"></script>
<script src="/metronic/assets/corporate/scripts/back-to-top.js"></script>
<script src="/metronic/assets/plugins/owl.carousel/owl.carousel.min.js"></script>
<script src="/metronic/assets/corporate/scripts/layout.js"></script>
<script src="/js/wow.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script type="text/javascript">
    jQuery(document).ready(function() {
        Layout.init();    
        Layout.initOWL();
        Layout.initTwitter();
        Layout.initFixHeaderWithPreHeader(); /* Switch On Header Fixing (only if you have pre-header) */
        Layout.initNavScrolling(); 
	new WOW().init();
    });
</script>
<!-- END CORE PLUGINS -->

<!-- BEGIN PAGE-SPECIFIC PLUGINS --> 







<!-- END PAGE-SPECIFIC PLUGINS --> 

<!-- BEGIN INTEGRATIONS -->





<!-- END INTEGRATIONS -->

</body>
</html>
