<!DOCTYPE html>
<!--[if IE 8]> <html lang="en" class="ie8 no-js"> <![endif]-->
<!--[if IE 9]> <html lang="en" class="ie9 no-js"> <![endif]-->
<!--[if !IE]><!-->
<html lang="en">
<!--<![endif]-->
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Category: spring | glmapper</title>

  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <meta name="description" content="从平凡的世界中全身而退">
<meta property="og:type" content="website">
<meta property="og:title" content="glmapper">
<meta property="og:url" content="http://www.glmapper.com/categories/spring/index.html">
<meta property="og:site_name" content="glmapper">
<meta property="og:description" content="从平凡的世界中全身而退">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="glmapper">
<meta name="twitter:description" content="从平凡的世界中全身而退">
  
    <link rel="alternative" href="/atom.xml" title="glmapper" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
    
  <meta content="{{ title }}" name="description">
  <meta content="{{ title }}" name="keywords">
  <meta content="{{ title }}" name="author">

  <link href="http://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700|PT+Sans+Narrow|Source+Sans+Pro:200,300,400,600,700,900&amp;subset=all" rel="stylesheet" type="text/css">

  <!-- Global styles START -->   
  <link rel="stylesheet" href="/metronic/assets/plugins/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/bootstrap/css/bootstrap.min.css">
  <!-- Global styles END --> 
   
  <!-- Page level plugin styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/animate.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/owl.carousel/assets/owl.carousel.css">
  <!-- Page level plugin styles END -->

  <!-- Theme styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/components.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/slider.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/portfolio.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style-responsive.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/themes/red.css">
  <link rel="stylesheet" href="/css/theme-styles.css">
  <!-- Theme styles END -->
</head>
</html>
<body class="corporate">
  <!-- BEGIN TOP BAR -->
<div class="pre-header">
  <div class="container">
    <div class="row">
      <!-- BEGIN TOP BAR LEFT PART -->
      <div class="col-md-6 col-sm-6 col-xs-9 additional-shop-info">
	<ul class="list-unstyled list-inline">
	  <li><i class="fa fa-phone"></i><span>716-472-4484</span></li>
	  <li><i class="fa fa-envelope-o"></i><span>ptsteadman@gmail.com</span></li>
	</ul>
      </div>
      <!-- END TOP BAR LEFT PART -->
      <!-- BEGIN TOP BAR MENU -->
      <div class="col-md-6 col-sm-6 col-xs-3 additional-nav">
	<ul class="list-unstyled list-inline pull-right">
	  <li><a href="/login">Log In</a></li>
	</ul>
      </div>
      <!-- END TOP BAR MENU -->
    </div>
  </div>        
</div>
<!-- END TOP BAR -->
<!-- BEGIN HEADER -->
<div class="header">
  <div class="container">
    <!--<a class="site-logo" href="/" id="logo">glmapper</a>-->

    <a class="site-logo" href="/">
      <img src="/metronic/assets/corporate/img/logos/logo-corp-red.png" alt="Metronic FrontEnd">
    </a>

    <a href="javascript:void(0);" class="mobi-toggler"><i class="fa fa-bars"></i></a>

    <!-- BEGIN NAVIGATION -->
    <div class="header-navigation pull-right font-transform-inherit">
      <ul>
	
	<li class="">
	  <a href="/">Home</a>
	</li>
	
	<li class="">
	  <a href="/projects/">Projects</a>
	</li>
	
	<li class="">
	  <a href="/archives/">Blog</a>
	</li>
	
	<li class="">
	  <a href="/contact/">Contact</a>
	</li>
	
	<li class="">
	  <a href="/about/">About</a>
	</li>
	
	<!-- BEGIN TOP SEARCH -->
	<li class="menu-search">
	  <span class="sep"></span>
	  <i class="fa fa-search search-btn"></i>
	  <div class="search-box">
	    <form action="#">
	      <div class="input-group">
		<input type="text" placeholder="Search" class="form-control st-default-search-input">
		<span class="input-group-btn">
		  <button class="btn btn-primary" type="submit">Search</button>
		</span>
	      </div>
	    </form>
	  </div> 
	</li>
	<!-- END TOP SEARCH -->
      </ul>
    </div>
    <!-- END NAVIGATION -->
  </div>
</div>
<!-- Header END -->

  <div class="container">
  <ul class="breadcrumb">
    <li><a href="/">Home</a></li>
    <li><a href="/blog">Blog</a></li>
    <li class="active">spring</li>
  </ul>
<section id="main">
 <h1>spring</h1>
 <div class="row">

<div class="col-xs-12 blog-posts">


  <section class="archives-wrap">
    <div class="archives">
      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2020/06/21/spring-series-factory-bean-and-post-processor/">聊一聊 BeanPostProcessor 不生效</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2020-06-21T13:12:14.000Z" itemprop="datePublished">2020/06/21</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2020/06/21/spring-series-factory-bean-and-post-processor/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>关于 BeanPostProcessor 各位一定不陌生，在 <a href="http://www.glmapper.com/2019/12/14/springboot-series-bean-life/">SpringBoot 源码系列-Bean 的生命周期与扩展</a> 这篇文章中，我有介绍过 bean 的创建流程及相关扩展，就有提到 BeanPostProcessor，包括它的作用时机及如何使用，这篇文章提到的这种属于比较常规的流程，因此在绝大多数场景下，都是符合我们认知的。但是最近在排查一个问题时，发现在某些场景下，BeanPostProcessor 不生效了…</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote>
<p>代码详见：<a href="https://github.com/glmapper/glmapper-spring-extention/tree/master/extention-FactoryBean" target="_blank" rel="noopener">extention-FactoryBean</a>; clone 之后可以直接运行 DemoApplication 即可，可以观察到 控制台不输出 GlmapperBeanPostProcessor 里面 print out 的字符串。</p>
</blockquote>
<p>运行代码，即可观察到具体的执行现场；代码里除了 BeanPostProcessor 之外，另外一个是 FactoryBean，也就是本篇所要聊的重点：<strong>FactoryBean getObjectType 为 null 时导致 bean 提前初始化，从而使得作用与目标 bean 的 BeanPostProcessors 都失效了。</strong></p>
<p>下面将基于这个问题，展开进行分析。</p>
<h2 id="bean-生命周期"><a href="#bean-生命周期" class="headerlink" title="bean 生命周期"></a>bean 生命周期</h2><p>先来看下 ApplicationContext 和 bean 生命周期(仅列出部分关键流程)：</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/beanlife/bean%20init.png" alt=""></p>
<p>从流程中可以看到：BeanPostProcessor 的注册是在 ApplicationContext 生命周期中完成的，故而当 bean 创建时，如果相应拦截器 BeanPostProcessor 还没有注册，那么其就不会起作用，这个可能有以下两种原因：</p>
<ul>
<li>1、bean 本身是一个 BeanPostProcessor ，且实现了 PriorityOrdered 或者 Ordered 接口</li>
<li>2、bean 由于某种原因，被提前初始化了，初始化的时候相应拦截器 BeanPostProcessor 还没有注册</li>
</ul>
<p>关于第一个其实很好理解，不再赘述，本篇主要基于第二个原因进行说明。</p>
<h2 id="bean-由于某种原因，被提前初始化了，初始化的时候相应拦截器-BeanPostProcessor-还没有注册"><a href="#bean-由于某种原因，被提前初始化了，初始化的时候相应拦截器-BeanPostProcessor-还没有注册" class="headerlink" title="bean 由于某种原因，被提前初始化了，初始化的时候相应拦截器 BeanPostProcessor 还没有注册"></a>bean 由于某种原因，被提前初始化了，初始化的时候相应拦截器 BeanPostProcessor 还没有注册</h2><p>bean 被提前初始化的情况就比较多了，归纳下来都能符合同一个规律：在 创建所有 non-lazy-init bean 这一步之前，也即在创建 BeanFactoryPostProcessor 或者 BeanPostProcessor 的过程中，引发了 bean 的创建，导致其被提前初始化，大体可以分为两种情形：</p>
<ul>
<li>用户自定义的 BeanFactoryPostProcessor 或者 BeanPostProcessor 中会通过构造函数、属性注入等方式引用到目标 bean 导致其被提前创建</li>
<li>在上述过程中由于 Spring 自身对 FactoryBean 的 typeCheck(类型检测) 机制导致目标 bean 被提前创建</li>
</ul>
<p>对于第一种情形，比较简单，这个通常是用户的配置导致的，比如我的 TestBeanFactoryPostProcessor 中通过属性注入了目标 bean 导致了其被提前创建，最终拦截器失效(如果去掉相应 TestBeanFactoryPostProcessor 配置，可以看到拦截器是能够成功的 )。</p>
<blockquote>
<p>简单代码如下，作用在 TestFacade 上的 BeanFactoryPostProcessor 可能会由于 TestFacade 的提前被创建而失效</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @<span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestFacade testFacade;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如何找到 bean 被提前初始化的时机呢？可以在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[]) 打一个条件断点，通过 beanName 进行匹配，然后顺着 debug 堆栈往回找，就能够看到是在哪里导致了 bean 被提前创建。</p>
</blockquote>
<p>对于第二种情形，其实也是通过上述方法先找到被提前创建的源头，只不过这种情形更加隐晦，也更加复杂，这里我们单独在下面的部分中来分析。</p>
<h2 id="关于-isTypeMatch"><a href="#关于-isTypeMatch" class="headerlink" title="关于 isTypeMatch"></a>关于 isTypeMatch</h2><p>从 Spring 2.x 版本开始，BeanFactory 中就已经有 isTypeMatch 这个方法了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Check whether the bean with the given name matches the specified type.</span></span><br><span class="line"><span class="comment">* More specifically, check whether a &#123;<span class="doctag">@link</span> #getBean&#125; call for the given name</span></span><br><span class="line"><span class="comment">* would return an object that is assignable to the specified target type.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">* Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> typeToMatch the type to match against (as a &#123;<span class="doctag">@code</span> Class&#125;)</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the bean type matches,</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> false&#125; if it doesn't match or cannot be determined yet</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 2.0.1</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> #getType</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, @Nullable Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br></pre></td></tr></table></figure>
<p>从方法注释可以简单了解到，isTypeMatch 的作用就是：判断 JavaBean 是否匹配指定的类型。他包括两个参数：</p>
<ul>
<li>name：容器中定义的 JavaBean 的名称。</li>
<li>typeToMatch：要匹配的目标类型。</li>
</ul>
<p>回到案例，我们需要关注的是 isTypeMatch 和我们前面提到的<strong>FactoryBean getObjectType 为 null 时导致 bean 提前初始化，从而使得作用与目标 bean 的 BeanPostProcessors 都失效了。</strong>有什么关系呢？这里有两个比较关键的信息：</p>
<ul>
<li>1、FactoryBean getObjectType 为 null</li>
<li>2、目标 bean 的 BeanPostProcessors 都失效了</li>
</ul>
<p>其实大概能够猜到的是，<strong>actoryBean getObjectType 为 null 时，导致了 当前 bean 被提前初始化，而此时 bean 的 BeanPostProcessors 还没有被注册到当前 bean ，从而导致了目标 bean 的 BeanPostProcessors 都失效。</strong> 这个也是本篇的结论，但是还是需要来看看具体原因的细节是什么样的。</p>
<p><strong>我们知道，在 Spring 中，当进行 byType (除了用户主动配置 byType 注入以外，使用 @autowired 以及 @Bean 中的方法参数时等都使用的是 byType  注入) 注入时，会通过 org.springframework.beans.factory.ListableBeanFactory#getBeanNamesForType(java.lang.Class&lt;?&gt;, boolean, boolean) 来寻找相应类型的 bean 。</strong></p>
<p><strong>针对 FactoryBean 而言，当判断其类型时，会先创建一个简单的(非完整的，仅仅是调用构造函数) bean ，调用其 getObjectType() ，如果发现返回为 null，那么就会再创造完整的 bean ，然后再通过 getObjectType() 获取类型进行匹配。</strong></p>
<h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><p>基于上面提到的点，结合本案例，来 debug 看下 <strong>FactoryBean typeCheck(类型检测) 机制导致的 BeanPostProcessor 不生效</strong>的原因。</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/beanlife/exe-stack.jpg" alt="执行堆栈"></p>
<p>这里主要还是看下 isTypeMatch 方法执行是如何触发 bean 提前初始化的。</p>
<h3 id="isTypeMatch-方法"><a href="#isTypeMatch-方法" class="headerlink" title="isTypeMatch 方法"></a>isTypeMatch 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">    String beanName = transformedBeanName(name);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Check manually registered singletons.</span></span><br><span class="line">    Object beanInstance = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 常规情况下，这里 beanInstance 是不为 null 的，但是对于提前加载的 beanInstance == null</span></span><br><span class="line">    <span class="keyword">if</span> (beanInstance != <span class="keyword">null</span> &amp;&amp; beanInstance.getClass() != NullBean.class) &#123;</span><br><span class="line">        <span class="comment">// 判断类型是不是 FactoryBean</span></span><br><span class="line">        <span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">            <span class="comment">// 返回给定名称是否为工厂解除引用(以工厂解除引用前缀开始)。 &amp;xxxx </span></span><br><span class="line">            <span class="keyword">if</span> (!BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">                <span class="comment">// 这里拿 FactoryBean#getObjectType</span></span><br><span class="line">                Class&lt;?&gt; type = getTypeForFactoryBean((FactoryBean&lt;?&gt;) beanInstance);</span><br><span class="line">                <span class="keyword">return</span> (type != <span class="keyword">null</span> &amp;&amp; typeToMatch.isAssignableFrom(type));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 实例类型是否匹配</span></span><br><span class="line">                <span class="keyword">return</span> typeToMatch.isInstance(beanInstance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理泛型和代理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (typeToMatch.isInstance(beanInstance)) &#123;</span><br><span class="line">                <span class="comment">// 直接匹配暴露实例?</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (typeToMatch.hasGenerics() &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">                <span class="comment">// 泛型可能只匹配目标类，而不匹配代理…</span></span><br><span class="line">                RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">                Class&lt;?&gt; targetType = mbd.getTargetType();</span><br><span class="line">                <span class="keyword">if</span> (targetType != <span class="keyword">null</span> &amp;&amp; targetType != ClassUtils.getUserClass(beanInstance) &amp;&amp;</span><br><span class="line">                        typeToMatch.isAssignableFrom(targetType)) &#123;</span><br><span class="line">                    <span class="comment">// 还要检查原始类匹配，确保它在代理上暴露。</span></span><br><span class="line">                    Class&lt;?&gt; classToMatch = typeToMatch.resolve();</span><br><span class="line">                    <span class="keyword">return</span> (classToMatch == <span class="keyword">null</span> || classToMatch.isInstance(beanInstance));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 beanName 的 bean 没有被注册过</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (containsSingleton(beanName) &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">        <span class="comment">// null instance registered</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有找到单例实例-&gt;检查bean定义。</span></span><br><span class="line">    BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">        <span class="comment">// 在这个 factory 中没有找到 bean definition -&gt; 委托 parent。</span></span><br><span class="line">        <span class="keyword">return</span> parentBeanFactory.isTypeMatch(originalBeanName(name), typeToMatch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检索相应的 bean 定义。</span></span><br><span class="line">    RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; classToMatch = typeToMatch.resolve();</span><br><span class="line">    <span class="keyword">if</span> (classToMatch == <span class="keyword">null</span>) &#123;</span><br><span class="line">        classToMatch = FactoryBean.class;</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt;[] typesToMatch = (FactoryBean.class == classToMatch ?</span><br><span class="line">            <span class="keyword">new</span> Class&lt;?&gt;[] &#123;classToMatch&#125; : <span class="keyword">new</span> Class&lt;?&gt;[] &#123;FactoryBean.class, classToMatch&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check decorated bean definition, if any: We assume it'll be easier</span></span><br><span class="line">    <span class="comment">// to determine the decorated bean's type than the proxy's type.</span></span><br><span class="line">    <span class="comment">// 检查修饰 bean definition(如果有的话):我们假设确定修饰 bean 的类型比确定代理的类型更容易。</span></span><br><span class="line">    BeanDefinitionHolder dbd = mbd.getDecoratedDefinition();</span><br><span class="line">    <span class="keyword">if</span> (dbd != <span class="keyword">null</span> &amp;&amp; !BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">        RootBeanDefinition tbd = getMergedBeanDefinition(dbd.getBeanName(), dbd.getBeanDefinition(), mbd);</span><br><span class="line">        <span class="comment">// 预测指定bean的最终bean类型(已处理bean实例的)。由&#123;@link #getType&#125;和&#123;@link #isTypeMatch&#125;调用。不需要专门处理factorybean，因为它只应该操作原始bean类型。</span></span><br><span class="line">        <span class="comment">// 这个实现过于简单，因为它不能处理工厂方法和实例化 awarebeanpostprocessors。对于标准bean，它只能正确地预测bean类型。要在子类中重写，应用更复杂的类型检测。</span></span><br><span class="line">        Class&lt;?&gt; targetClass = predictBeanType(dbd.getBeanName(), tbd, typesToMatch);</span><br><span class="line">        <span class="keyword">if</span> (targetClass != <span class="keyword">null</span> &amp;&amp; !FactoryBean.class.isAssignableFrom(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> typeToMatch.isAssignableFrom(targetClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 推断出 beanType</span></span><br><span class="line">    Class&lt;?&gt; beanType = predictBeanType(beanName, mbd, typesToMatch);</span><br><span class="line">    <span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查 bean class 是否是 FactoryBean 类型。本案例就是在这被处理到 返回 false 的</span></span><br><span class="line">    <span class="keyword">if</span> (FactoryBean.class.isAssignableFrom(beanType)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; beanInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果它是FactoryBean，我们希望看到它创建了什么（getObject），而不是工厂类。</span></span><br><span class="line">            beanType = getTypeForFactoryBean(beanName, mbd);</span><br><span class="line">            <span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 ........</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getTypeForFactoryBean-方法"><a href="#getTypeForFactoryBean-方法" class="headerlink" title="getTypeForFactoryBean 方法"></a>getTypeForFactoryBean 方法</h3><p>这个步骤会向尝试从 FactoryBean 的 getObjectType 方法去获取类型，如果拿不到，则调用父类的进行初始化 bean 操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略 其他...</span></span><br><span class="line"><span class="keyword">if</span> (fb != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 尝试从实例的这个早期阶段获取 FactoryBean 的对象类型。这里调用的就是 FactoryBean#getObjectType 方法</span></span><br><span class="line">    Class&lt;?&gt; result = getTypeForFactoryBean(fb);</span><br><span class="line">    <span class="comment">// 本案例中这里返回的是 null, 所以会走到 else</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的意思就是没有通过 FactoryBean#getObjectType 快速获取到类型</span></span><br><span class="line">        <span class="comment">// 将执行实例当前实例，然后再获取</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getTypeForFactoryBean(beanName, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略 其他...</span></span><br></pre></td></tr></table></figure>
<h3 id="AbstractBeanFactory-getTypeForFactoryBean"><a href="#AbstractBeanFactory-getTypeForFactoryBean" class="headerlink" title="AbstractBeanFactory#getTypeForFactoryBean"></a>AbstractBeanFactory#getTypeForFactoryBean</h3><p>调用父类的 getTypeForFactoryBean 方法，执行 bean 的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getTypeForFactoryBean(String beanName, RootBeanDefinition mbd) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSingleton()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里开始执行 doGetBean，之前的文章里面有提到，bean 实例化的入口就是 getBean 的时候</span></span><br><span class="line">        FactoryBean&lt;?&gt; factoryBean = doGetBean(FACTORY_BEAN_PREFIX + beanName, FactoryBean.class, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> getTypeForFactoryBean(factoryBean);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">        <span class="comment">// 省略日志打印部分</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 doGetBean 中执行链路中，会在 initializeBean 时给当前 bean 注册 BeanPostProcessor，（applyBeanPostProcessorsBeforeInitialization 方法中) ，这里可以比较清晰的看到 BeanPostProcessor 没有作用于 目标 bean 的。</p>
<blockquote>
<p>doGetBean -&gt; createBean -&gt; initializeBean -&gt; applyBeanPostProcessorsBeforeInitialization</p>
</blockquote>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/beanlife/no-processors.jpg" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在本篇的案例中，其实比较明显的可以看到测试工程中 GlmapperFactoryBean 的 getObjectType 返回是为 null 的，也正是因为这个原因导致了 BeanPostProcessor 失效。那么如何在实际的开发过程中来规避呢？</p>
<ul>
<li>1、FactoryBean 的 getObjectType() 不要返回 null </li>
<li>2、定义 BeanPostProcessor 时，需要特别注意 order</li>
<li>3、在 创建所有 non-lazy-init bean 之前的  getBeanNamesForType 调用，尽量将 eagerInit 传为 false。</li>
</ul>
<p>关于第三点，前面提到过 getBeanNamesForType 的调用会触发类型检查，但其实这个方法还有些参数，参考如下：</p>
<p>String[] getBeanNamesForType(Class&lt;?&gt; type, boolean includeNonSingletons, boolean allowEagerInit);<br>这里有个很重要的参数 allowEagerInit ，可以看到 spring 的注释中对其有非常详细的解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@param allowEagerInit whether to initialize lazy-init singletons and</span><br><span class="line"></span><br><span class="line">* objects created by FactoryBeans (or by factory methods with a</span><br><span class="line">* &quot;factory-bean&quot; reference) for the type check. Note that FactoryBeans need to be</span><br><span class="line">* eagerly initialized to determine their type: So be aware that passing in &quot;true&quot;</span><br><span class="line">* for this flag will initialize FactoryBeans and &quot;factory-bean&quot; references.</span><br></pre></td></tr></table></figure>
<p>简单来说这个参数能够控制是否允许 FactoryBean 的提前创建，如果是 false，那么也不会引发上述的 类型检测 。可以看到在 Spring 中在获取 BeanFactoryPostProcessor 以及 BeanPostProcessor 时，也都是传入 false 的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tring[] postProcessorNames =</span><br><span class="line">        beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">String[] postProcessorNames = </span><br><span class="line">    beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p>当然在一些 @Bean 的方法参数注入、@Autowire 注入等场景下，这个默认都是 true 的，无法改变；但针对平时编码过程中，如果是在比较早期的调用中，可根据情况，尽量传入 false。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2020/06/21/spring-series-factory-bean-and-post-processor/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/12/23/spring-session-idresolver/">SpringSession系列-sessionId解析和Cookie读写策略</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-12-22T16:10:59.000Z" itemprop="datePublished">2018/12/23</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/12/23/spring-session-idresolver/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/session/" title="session">session</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<blockquote>
<p>首先需求在这里说明下，SpringSession的版本迭代的过程中肯定会伴随着一些类的移除和一些类的加入，目前本系列使用的版本是github上对象的master的代码流版本。如果有同学对其他版本中的一些类或者处理有疑惑，欢迎交流。</p>
</blockquote>
<p>本篇将来介绍下<code>SpringSession</code>中两种<code>sessionId</code>解析的策略，这个在之前的文章中其实是有提到过的，这里再拿出来和<code>SpringSession</code>中<code>Cookie</code>相关策略一起学习下。</p>
<h1 id="sessionId-解析策略"><a href="#sessionId-解析策略" class="headerlink" title="sessionId 解析策略"></a>sessionId 解析策略</h1><p><code>SpringSession</code>中对于<code>sessionId</code>的解析相关的策略是通过<code>HttpSessionIdResolver</code>这个接口来体现的。<code>HttpSessionIdResolver</code>有两个实现类：<br><img src="https://img-blog.csdnimg.cn/20181216224001789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzI1NTE4MzQ5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>这两个类就分别对应<code>SpringSession</code>解析<code>sessionId</code>的两种不同的实现策略。再深入了解不同策略的实现细节之前，先来看下<code>HttpSessionIdResolver</code>接口定义的一些行为有哪些。</p>
<h2 id="HttpSessionIdResolver"><a href="#HttpSessionIdResolver" class="headerlink" title="HttpSessionIdResolver"></a>HttpSessionIdResolver</h2><p><code>HttpSessionIdResolver</code>定义了<code>sessionId</code>解析策略的契约（<code>Contract</code>）。允许通过请求解析sessionId，并通过响应发送sessionId或终止会话。接口定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpSessionIdResolver</span> </span>&#123;</span><br><span class="line">	<span class="function">List&lt;String&gt; <span class="title">resolveSessionIds</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setSessionId</span><span class="params">(HttpServletRequest request, HttpServletResponse response,String sessionId)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">expireSession</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>HttpSessionIdResolver</code>中有三个方法：</p>
<ul>
<li><code>resolveSessionIds</code>：解析与当前请求相关联的<code>sessionId</code>。<code>sessionId</code>可能来自<code>Cookie</code>或请求头。</li>
<li><code>setSessionId</code>：将给定的<code>sessionId</code>发送给客户端。这个方法是在创建一个新<code>session</code>时被调用，并告知客户端新<code>sessionId</code>是什么。</li>
<li><code>expireSession</code>：指示客户端结束当前<code>session</code>。当<code>session</code>无效时调用此方法，并应通知客户端<code>sessionId</code>不再有效。比如，它可能删除一个包含<code>sessionId</code>的<code>Cookie</code>，或者设置一个<code>HTTP</code>响应头，其值为空就表示客户端不再提交<code>sessionId</code>。</li>
</ul>
<p>下面就针对上面提到的两种策略来进行详细的分析。</p>
<h2 id="基于Cookie解析sessionId"><a href="#基于Cookie解析sessionId" class="headerlink" title="基于Cookie解析sessionId"></a>基于Cookie解析sessionId</h2><p>这种策略对应的实现类是<code>CookieHttpSessionIdResolver</code>，通过从<code>Cookie</code>中获取<code>session</code>；具体来说，这个实现将允许使用<code>CookieHttpSessionIdResolver#setCookieSerializer(CookieSerializer)</code>指定<code>Cookie</code>序列化策略。默认的<code>Cookie</code>名称是“<code>SESSION</code>”。创建一个<code>session</code>时，<code>HTTP</code>响应中将会携带一个指定 <code>Cookie name</code>且<code>value</code>是<code>sessionId</code>的<code>Cookie</code>。<code>Cookie</code> 将被标记为一个 <code>session cookie</code>，<code>Cookie</code> 的 <code>domain path</code> 使用 <code>context path</code>，且被标记为<code>HttpOnly</code>，如果<code>HttpServletRequest#isSecure()</code>返回<code>true</code>，那么<code>Cookie</code>将标记为安全的。如下：</p>
<blockquote>
<p>关于<code>Cookie</code>，可以参考：<a href="http://www.glmapper.com/2018/11/10/sessionone/">聊一聊session和cookie</a>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Set-Cookie: SESSION=f81d4fae-7dec-11d0-a765-00a0c91e6bf6; Path=/context-root; Secure; HttpOnly</span><br></pre></td></tr></table></figure>
<p>这个时候，客户端应该通过在每个请求中指定相同的<code>Cookie</code>来包含<code>session</code>信息。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /messages/ HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Cookie: SESSION=f81d4fae-7dec-11d0-a765-00a0c91e6bf6</span><br></pre></td></tr></table></figure></p>
<p>当会话无效时，服务器将发送过期的<code>HTTP</code>响应<code>Cookie</code>，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Set-Cookie: SESSION=f81d4fae-7dec-11d0-a765-00a0c91e6bf6; Expires=Thur, 1 Jan 1970 00:00:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure>
<p><code>CookieHttpSessionIdResolver</code> 类的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieHttpSessionIdResolver</span> <span class="keyword">implements</span> <span class="title">HttpSessionIdResolver</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WRITTEN_SESSION_ID_ATTR = CookieHttpSessionIdResolver.class</span><br><span class="line">			.getName().concat(<span class="string">".WRITTEN_SESSION_ID_ATTR"</span>);</span><br><span class="line">	<span class="comment">// Cookie序列化策略，默认是 DefaultCookieSerializer</span></span><br><span class="line">	<span class="keyword">private</span> CookieSerializer cookieSerializer = <span class="keyword">new</span> DefaultCookieSerializer();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">resolveSessionIds</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 根据提供的cookieSerializer从请求中获取sessionId</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.cookieSerializer.readCookieValues(request);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSessionId</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">			String sessionId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (sessionId.equals(request.getAttribute(WRITTEN_SESSION_ID_ATTR))) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		request.setAttribute(WRITTEN_SESSION_ID_ATTR, sessionId);</span><br><span class="line">		<span class="comment">// 根据提供的cookieSerializer将sessionId回写到cookie中</span></span><br><span class="line">		<span class="keyword">this</span>.cookieSerializer</span><br><span class="line">				.writeCookieValue(<span class="keyword">new</span> CookieValue(request, response, sessionId));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireSession</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 这里因为是过期，所以回写的sessionId的值是“”，当请求下次进来时，就会取不到sessionId，也就意味着当前会话失效了</span></span><br><span class="line">		<span class="keyword">this</span>.cookieSerializer.writeCookieValue(<span class="keyword">new</span> CookieValue(request, response, <span class="string">""</span>));</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 指定Cookie序列化的方式</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCookieSerializer</span><span class="params">(CookieSerializer cookieSerializer)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (cookieSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"cookieSerializer cannot be null"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.cookieSerializer = cookieSerializer;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里可以看到<code>CookieHttpSessionIdResolver</code> 中的读取操作都是围绕<code>CookieSerializer</code>来完成的。<code>CookieSerializer</code> 是<code>SpringSession</code>中对于<code>Cookie</code>操作提供的一种机制。下面细说。</p>
<h2 id="基于请求头解析sessionId"><a href="#基于请求头解析sessionId" class="headerlink" title="基于请求头解析sessionId"></a>基于请求头解析sessionId</h2><p>这种策略对应的实现类是<code>HeaderHttpSessionIdResolver</code>，通过从请求头<code>header</code>中解析出<code>sessionId</code>。具体地说，这个实现将允许使用<code>HeaderHttpSessionIdResolver(String)</code>来指定头名称。还可以使用便利的工厂方法来创建使用公共头名称(例如<code>“X-Auth-Token”</code>和<code>“authenticing-info”</code>)的实例。创建会话时，<code>HTTP</code>响应将具有指定名称和<code>sessionId</code>值的响应头。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用X-Auth-Token作为headerName</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeaderHttpSessionIdResolver <span class="title">xAuthToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> HeaderHttpSessionIdResolver(HEADER_X_AUTH_TOKEN);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用Authentication-Info作为headerName</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeaderHttpSessionIdResolver <span class="title">authenticationInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> HeaderHttpSessionIdResolver(HEADER_AUTHENTICATION_INFO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HeaderHttpSessionIdResolver</code>在处理<code>sessionId</code>上相比较于<code>CookieHttpSessionIdResolver</code>来说简单很多。就是围绕<code>request.getHeader(String)</code>和<code>request.setHeader(String,String)</code><br>两个方法来玩的。</p>
<p><code>HeaderHttpSessionIdResolver</code>这种策略通常会在无线端来使用，以弥补对于无<code>Cookie</code>场景的支持。</p>
<h1 id="Cookie-序列化策略"><a href="#Cookie-序列化策略" class="headerlink" title="Cookie 序列化策略"></a>Cookie 序列化策略</h1><p>基于<code>Cookie</code>解析<code>sessionId</code>的实现类<code>CookieHttpSessionIdResolver</code> 中实际对于<code>Cookie</code>的读写操作都是通过<code>CookieSerializer</code>来完成的。<code>SpringSession</code> 提供了<code>CookieSerializer</code>接口的默认实现<code>DefaultCookieSerializer</code>，当然在实际应用中，我们也可以自己实现这个接口，然后通过<code>CookieHttpSessionIdResolver#setCookieSerializer(CookieSerializer)</code>方法来指定我们自己的实现方式。</p>
<blockquote>
<p>PS：不得不说，强大的用户扩展能力真的是<code>Spring</code>家族的优良家风。</p>
</blockquote>
<p>篇幅有限，这里就只看下两个点：</p>
<ul>
<li><code>CookieValue</code> 存在的意义是什么</li>
<li><code>DefaultCookieSerializer</code>回写<code>Cookie</code>的的具体实现，读<code>Cookie</code>在 <a href="http://www.glmapper.com/2018/11/24/springsessiontwo/">SpringSession系列-请求与响应重写</a> 这篇文章中有介绍过，这里不再赘述。</li>
<li>jvm_router的处理</li>
</ul>
<h2 id="CookieValue"><a href="#CookieValue" class="headerlink" title="CookieValue"></a>CookieValue</h2><p><code>CookieValue</code>是<code>CookieSerializer</code>中的内部类，封装了向<code>HttpServletResponse</code>写入所需的所有信息。其实<code>CookieValue</code>的存在并没有什么特殊的意义，个人觉得作者一开始只是想通过<code>CookieValue</code>的封装来简化回写<code>cookie</code>链路中的参数传递的问题，但是实际上貌似并没有什么减少多少工作量。</p>
<h2 id="Cookie-回写"><a href="#Cookie-回写" class="headerlink" title="Cookie 回写"></a>Cookie 回写</h2><p><code>Cookie</code> 回写我觉得对于分布式<code>session</code>的实现来说是必不可少的；基于标准<code>servlet</code>实现的<code>HttpSession</code>，我们在使用时实际上是不用关心回写<code>cookie</code>这个事情的，因为<code>servlet</code>容器都已经做了。但是对于分布式<code>session</code>来说，由于重写了<code>response</code>，所以需要在返回<code>response</code>时需要将当前<code>session</code>信息通过<code>cookie</code>的方式塞到<code>response</code>中返回给客户端-这就是<code>Cookie</code>回写。下面是<code>DefaultCookieSerializer</code>中回写<code>Cookie</code>的逻辑，细节在代码中通过注释标注出来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeCookieValue</span><span class="params">(CookieValue cookieValue)</span> </span>&#123;</span><br><span class="line">	HttpServletRequest request = cookieValue.getRequest();</span><br><span class="line">	HttpServletResponse response = cookieValue.getResponse();</span><br><span class="line">	StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	sb.append(<span class="keyword">this</span>.cookieName).append(<span class="string">'='</span>);</span><br><span class="line">	String value = getValue(cookieValue);</span><br><span class="line">	<span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		validateValue(value);</span><br><span class="line">		sb.append(value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> maxAge = getMaxAge(cookieValue);</span><br><span class="line">	<span class="keyword">if</span> (maxAge &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">		sb.append(<span class="string">"; Max-Age="</span>).append(cookieValue.getCookieMaxAge());</span><br><span class="line">		OffsetDateTime expires = (maxAge != <span class="number">0</span>)</span><br><span class="line">				? OffsetDateTime.now().plusSeconds(maxAge)</span><br><span class="line">				: Instant.EPOCH.atOffset(ZoneOffset.UTC);</span><br><span class="line">		sb.append(<span class="string">"; Expires="</span>)</span><br><span class="line">				.append(expires.format(DateTimeFormatter.RFC_1123_DATE_TIME));</span><br><span class="line">	&#125;</span><br><span class="line">	String domain = getDomainName(request);</span><br><span class="line">	<span class="keyword">if</span> (domain != <span class="keyword">null</span> &amp;&amp; domain.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		validateDomain(domain);</span><br><span class="line">		sb.append(<span class="string">"; Domain="</span>).append(domain);</span><br><span class="line">	&#125;</span><br><span class="line">	String path = getCookiePath(request);</span><br><span class="line">	<span class="keyword">if</span> (path != <span class="keyword">null</span> &amp;&amp; path.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		validatePath(path);</span><br><span class="line">		sb.append(<span class="string">"; Path="</span>).append(path);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (isSecureCookie(request)) &#123;</span><br><span class="line">		sb.append(<span class="string">"; Secure"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.useHttpOnlyCookie) &#123;</span><br><span class="line">		sb.append(<span class="string">"; HttpOnly"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.sameSite != <span class="keyword">null</span>) &#123;</span><br><span class="line">		sb.append(<span class="string">"; SameSite="</span>).append(<span class="keyword">this</span>.sameSite);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	response.addHeader(<span class="string">"Set-Cookie"</span>, sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这上面就是拼凑字符串，然后塞到Header里面去，最终再浏览器中显示大体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: SESSION=f81d4fae-7dec-11d0-a765-00a0c91e6bf6; Path=/context-root; Secure; HttpOnly</span><br></pre></td></tr></table></figure>
<h2 id="jvm-router的处理"><a href="#jvm-router的处理" class="headerlink" title="jvm_router的处理"></a>jvm_router的处理</h2><p>在<code>Cookie</code>的读写代码中都涉及到对于<code>jvmRoute</code>这个属性的判断及对应的处理逻辑。</p>
<p>1、读取<code>Cookie</code>中的代码片段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.jvmRoute != <span class="keyword">null</span> &amp;&amp; sessionId.endsWith(<span class="keyword">this</span>.jvmRoute)) &#123;</span><br><span class="line">	sessionId = sessionId.substring(<span class="number">0</span>,</span><br><span class="line">			sessionId.length() - <span class="keyword">this</span>.jvmRoute.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、回写<code>Cookie</code>中的代码片段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.jvmRoute != <span class="keyword">null</span>) &#123;</span><br><span class="line">	actualCookieValue = requestedCookieValue + <span class="keyword">this</span>.jvmRoute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>jvm_route</code>是<code>Nginx</code>中的一个模块，其作用是通过<code>session cookie</code>的方式来获取<code>session</code>粘性。如果在<code>cookie</code>和<code>url</code>中并没有<code>session</code>，则这只是个简单的 <code>round-robin</code> 负载均衡。其具体过程分为以下几步：</p>
<ul>
<li>1.第一个请求过来，没有带<code>session</code>信息，<code>jvm_route</code>就根据<code>round robin</code>策略发到一台<code>tomcat</code>上面。</li>
<li>2.<code>tomcat</code>添加上 <code>session</code> 信息，并返回给客户。</li>
<li>3.用户再次请求，<code>jvm_route</code>看到<code>session</code>中有后端服务器的名称，它就把请求转到对应的服务器上。</li>
</ul>
<p>从本质上来说，<code>jvm_route</code>也是解决<code>session</code>共享的一种解决方式。这种和 <a href="http://www.glmapper.com/2018/11/24/springsessionthree/">SpringSession系列-分布式Session实现方案</a> 中提到的基于<code>IP-HASH</code>的方式有点类似。那么同样，这里存在的问题是无法解决宕机后<code>session</code>数据转移的问题，既宕机就丢失。</p>
<p><code>DefaultCookieSerializer</code> 中除了<code>Cookie</code>的读写之后，还有一些细节也值得关注下，比如对<code>Cookie</code>中值的验证、<code>remember-me</code>的实现等。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://docs.spring.io/spring-session/docs/2.1.2.RELEASE/reference/html5/" target="_blank" rel="noopener">SpringSession官方文档</a></li>
<li><a href="https://blog.csdn.net/cao_j/article/details/51191764" target="_blank" rel="noopener">jvm_router原理</a></li>
<li><a href="https://github.com/glmapper/spring-session/tree/cn-spring-session" target="_blank" rel="noopener">SpringSession中文注释持续更新代码分支</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/12/23/spring-session-idresolver/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/12/16/spring-session-redis-map/">SpringSession系列-存储机制之Redis&amp;Map</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-12-15T17:30:38.000Z" itemprop="datePublished">2018/12/16</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/12/16/spring-session-redis-map/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/session/" title="session">session</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>在之前的文章中已经对<code>SpringSession</code>的功能结构，请求/响应重写等做了介绍。本文将继续来介绍下<code>SpringSession</code>中存储部分的设计。存储是分布式<code>session</code>中算是最核心的部分，通过引入三方的存储容器来实现<code>session</code>的存储，从而有效的解决<code>session</code>共享的问题。</p>
<h2 id="1、SpringSession存储的顶级抽象接口"><a href="#1、SpringSession存储的顶级抽象接口" class="headerlink" title="1、SpringSession存储的顶级抽象接口"></a>1、SpringSession存储的顶级抽象接口</h2><p><code>SpringSession</code>存储的顶级抽象接口是<code>org.springframework.session</code>包下的<code>SessionRepository</code>这个接口。<code>SessionRepository</code>的类图结构如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef7ce8c6b58?w=1662&amp;h=600&amp;f=png&amp;s=66844" alt=""></p>
<p>这里先来看下<code>SessionRepository</code>这个顶层接口中定义了哪些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SessionRepository</span>&lt;<span class="title">S</span> <span class="keyword">extends</span> <span class="title">Session</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个session</span></span><br><span class="line">	<span class="function">S <span class="title">createSession</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//保存session</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(S session)</span></span>;</span><br><span class="line">	<span class="comment">//通过ID查找session</span></span><br><span class="line">	<span class="function">S <span class="title">findById</span><span class="params">(String id)</span></span>;</span><br><span class="line">	<span class="comment">//通过ID删除一个session</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码来看还是很简单的，就是增删查。下面看具体实现。在2.0版本开始<code>SpringSession</code>中也提供了一个和<code>SessionRepository</code>具体相同能力的<code>ReactiveSessionRepository</code>，用于支持响应式编程模式。</p>
<h2 id="2、MapSessionRepository"><a href="#2、MapSessionRepository" class="headerlink" title="2、MapSessionRepository"></a>2、MapSessionRepository</h2><p>基于HashMap实现的基于内存存储的存储器实现，这里就主要看下对于接口中几个方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapSessionRepository</span> <span class="keyword">implements</span> <span class="title">SessionRepository</span>&lt;<span class="title">MapSession</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Integer defaultMaxInactiveInterval;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Session&gt; sessions;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到就是一个<code>Map</code>，那后面关于增删查其实就是操作这个<code>Map</code>了。</p>
<h3 id="createSession"><a href="#createSession" class="headerlink" title="createSession"></a>createSession</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MapSession <span class="title">createSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MapSession result = <span class="keyword">new</span> MapSession();</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.defaultMaxInactiveInterval != <span class="keyword">null</span>) &#123;</span><br><span class="line">		result.setMaxInactiveInterval(</span><br><span class="line">			Duration.ofSeconds(<span class="keyword">this</span>.defaultMaxInactiveInterval));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里很直接，就是<code>new</code>了一个<code>MapSession</code>，然后设置了<code>session</code>的有效期。</p>
<h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(MapSession session)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!session.getId().equals(session.getOriginalId())) &#123;</span><br><span class="line">		<span class="keyword">this</span>.sessions.remove(session.getOriginalId());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">this</span>.sessions.put(session.getId(), <span class="keyword">new</span> MapSession(session));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面先判断了<code>session</code>中的两个<code>ID</code>，一个<code>originalId</code>，一个当前<code>id</code>。<code>originalId</code>是第一次生成<code>session</code>对象时创建的，后面都不会在变化。通过源码来看，对于<code>originalId</code>，只提供了<code>get</code>方法。对于<code>id</code>呢，其实是可以通过<code>changeSessionId</code>来改变的。</p>
<p>这里的这个操作实际上是一种优化行为，及时的清除掉老的<code>session</code>数据来释放内存空间。</p>
<h3 id="findById"><a href="#findById" class="headerlink" title="findById"></a>findById</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MapSession <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">	Session saved = <span class="keyword">this</span>.sessions.get(id);</span><br><span class="line">	<span class="keyword">if</span> (saved == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (saved.isExpired()) &#123;</span><br><span class="line">		deleteById(saved.getId());</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> MapSession(saved);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个逻辑也很简单，先从<code>Map</code>中根据<code>id</code>取出<code>session</code>数据，如果没有就返回<code>null</code>，如果有则再判断下是否过期了，如果过期了就删除掉，然后返回<code>null</code>。如果查到了，并且没有过期的话，则构建一个<code>MapSession</code>返回。</p>
<p>OK，基于内存存储的实现系列就是这些了，下面继续来看其他存储的实现。</p>
<h2 id="3、FindByIndexNameSessionRepository"><a href="#3、FindByIndexNameSessionRepository" class="headerlink" title="3、FindByIndexNameSessionRepository"></a>3、FindByIndexNameSessionRepository</h2><p><code>FindByIndexNameSessionRepository</code>继承了<code>SessionRepository</code>接口，用于扩展对第三方存储的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FindByIndexNameSessionRepository</span>&lt;<span class="title">S</span> <span class="keyword">extends</span> <span class="title">Session</span>&gt;</span></span><br><span class="line"><span class="class">		<span class="keyword">extends</span> <span class="title">SessionRepository</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">		</span><br><span class="line">	String PRINCIPAL_NAME_INDEX_NAME = FindByIndexNameSessionRepository.class.getName()</span><br><span class="line">			.concat(<span class="string">".PRINCIPAL_NAME_INDEX_NAME"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function">Map&lt;String, S&gt; <span class="title">findByIndexNameAndIndexValue</span><span class="params">(String indexName, String indexValue)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Map&lt;String, S&gt; <span class="title">findByPrincipalName</span><span class="params">(String principalName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> findByIndexNameAndIndexValue(PRINCIPAL_NAME_INDEX_NAME, principalName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FindByIndexNameSessionRepository</code>添加一个单独的方法为指定用户查询所有会话。这是通过设置名为<code>FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME</code>的<code>Session</code>的属性值为指定用户的<code>username</code>来完成的。开发人员有责任确保属性被赋值，因为<code>SpringSession</code>不会在意被使用的认证机制。官方文档中给出的例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String username = <span class="string">"username"</span>;</span><br><span class="line"><span class="keyword">this</span>.session.setAttribute(</span><br><span class="line">	FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME, username);</span><br></pre></td></tr></table></figure>
<p><code>FindByIndexNameSessionRepository</code>的一些实现会提供一些钩子自动的索引其他的<code>session</code>属性。比如，很多实现都会自动的确保当前的<code>Spring Security</code>用户名称可通过索引名称<code>FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME</code>进行索引。一旦会话被索引，就可以通过下面的代码检索：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String username = <span class="string">"username"</span>;</span><br><span class="line">Map&lt;String, Session&gt; sessionIdToSession = </span><br><span class="line">	<span class="keyword">this</span>.sessionRepository.findByIndexNameAndIndexValue(</span><br><span class="line">	FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME,username);</span><br></pre></td></tr></table></figure>
<p>下图是<code>FindByIndexNameSessionRepository</code>接口的三个实现类：<br><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef0284d86a5?w=1624&amp;h=258&amp;f=png&amp;s=66960" alt="FindByIndexNameSessionRepository"></p>
<p>下面来分别分析下这三个存储的实现细节。</p>
<h3 id="3-1-RedisOperationsSessionRepository"><a href="#3-1-RedisOperationsSessionRepository" class="headerlink" title="3.1 RedisOperationsSessionRepository"></a>3.1 RedisOperationsSessionRepository</h3><p><code>RedisOperationsSessionRepository</code>的类图结构如下，<code>MessageListener</code>是<code>redis</code>消息订阅的监听接口。<br><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef029530952?w=1128&amp;h=596&amp;f=png&amp;s=67475" alt="在这里插入图片描述"></p>
<p>代码有点长，就不在这里面贴了，一些注释可以在这个 <a href="https://github.com/glmapper/spring-session/tree/cn-spring-session" target="_blank" rel="noopener">SpringSession中文分支</a> 来看。这里还是主要来看下对于那几个方法的实现。</p>
<h4 id="3-1-1-createSession"><a href="#3-1-1-createSession" class="headerlink" title="3.1.1 createSession"></a>3.1.1 createSession</h4><p>这里和<code>MapSessionRepository</code>的实现基本一样的，那区别就在于<code>Session</code>的封装模型不一样，这里是<code>RedisSession</code>，实际上<code>RedisSession</code>的实现是对<code>MapSession</code>又包了一层。下面会分析<code>RedisSession</code>这个类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisSession <span class="title">createSession</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// RedisSession,这里和MapSession区别开</span></span><br><span class="line">	RedisSession redisSession = <span class="keyword">new</span> RedisSession();</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.defaultMaxInactiveInterval != <span class="keyword">null</span>) &#123;</span><br><span class="line">		redisSession.setMaxInactiveInterval(</span><br><span class="line">				Duration.ofSeconds(<span class="keyword">this</span>.defaultMaxInactiveInterval));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> redisSession;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在看其他两个方法之前，先来看下<code>RedisSession</code>这个类。</p>
<h4 id="3-1-2-RedisSession"><a href="#3-1-2-RedisSession" class="headerlink" title="3.1.2 RedisSession"></a>3.1.2 RedisSession</h4><p>这个在模型上是对<code>MapSession</code>的扩展，增加了<code>delta</code>这个东西。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSession</span> <span class="keyword">implements</span> <span class="title">Session</span> </span>&#123;</span><br><span class="line">       <span class="comment">// MapSession 实例对象，主要存数据的地方</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> MapSession cached;</span><br><span class="line">		<span class="comment">// 原始最后访问时间</span></span><br><span class="line">		<span class="keyword">private</span> Instant originalLastAccessTime;</span><br><span class="line">		<span class="keyword">private</span> Map&lt;String, Object&gt; delta = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="comment">// 是否是新的session对象</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">boolean</span> isNew;</span><br><span class="line">		<span class="comment">// 原始主名称</span></span><br><span class="line">		<span class="keyword">private</span> String originalPrincipalName;</span><br><span class="line">		<span class="comment">// 原始sessionId</span></span><br><span class="line">		<span class="keyword">private</span> String originalSessionId;</span><br></pre></td></tr></table></figure></p>
<p><code>delta</code>是一个Map结构，那么这里面到底是放什么的呢？具体细节见 <a href="https://github.com/glmapper/spring-session/blob/cn-spring-session/spring-session-data-redis/src/main/java/org/springframework/session/data/redis/RedisOperationsSessionRepository.java" target="_blank" rel="noopener">saveDelta</a> 这个方法。<code>saveDelta</code> 这个方法会在两个地方被调用，一个是下面要说道的<code>save</code>方法，另外一个是 <code>flushImmediateIfNecessary</code> 这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushImmediateIfNecessary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (RedisOperationsSessionRepository.<span class="keyword">this</span>.redisFlushMode == RedisFlushMode.IMMEDIATE) &#123;</span><br><span class="line">		saveDelta();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>RedisFlushMode</code>提供了两种推送模式：</p>
<ul>
<li>ON_SAVE：只有在调用<code>save</code>方法时执行，在<code>web</code>环境中这样做通常是尽快提交HTTP响应</li>
<li>IMMEDIATE：只要有变更就会直接写到<code>redis</code>中，不会像<code>ON_SAVE</code>一样，在最后<code>commit</code>时一次性写入</li>
</ul>
<p>追踪<code>flushImmediateIfNecessary</code> 方法调用链如下：<br><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef032721690?w=1008&amp;h=258&amp;f=png&amp;s=89571" alt="在这里插入图片描述"><br>那么到这里基本就清楚了，首先<code>save</code>这个方法，当主动调用<code>save</code>时就是将数据推到<code>redis</code>中去的，也就是<code>ON_SAVE</code>这种情况。那么对于<code>IMMEDIATE</code>这种情况，只有调用了上面的四个方法，<code>SpringSession</code> 才会将数据推送到<code>redis</code>。</p>
<p>所以<code>delta</code>里面存的是当前一些变更的 <code>key-val</code> 键值对象，而这些变更是由<code>setAttribute</code>、<code>removeAttribute</code>、<code>setMaxInactiveIntervalInSeconds</code>、<code>setLastAccessedTime</code>这四个方法触发的；比如<code>setAttribute(k,v)</code>，那么这个<code>k-&gt;v</code>就会被保存到<code>delta</code>里面。</p>
<h4 id="3-1-3-save"><a href="#3-1-3-save" class="headerlink" title="3.1.3 save"></a>3.1.3 save</h4><p>在理解了<code>saveDelta</code>方法之后再来看<code>save</code>方法就简单多了。<code>save</code> 对应的就是<code>RedisFlushMode.ON_SAVE</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(RedisSession session)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 直接调用 saveDelta推数据到redis</span></span><br><span class="line">	session.saveDelta();</span><br><span class="line">	<span class="keyword">if</span> (session.isNew()) &#123;</span><br><span class="line">	   <span class="comment">// sessionCreatedKey-&gt;channl</span></span><br><span class="line">		String sessionCreatedKey = getSessionCreatedChannel(session.getId());</span><br><span class="line">		<span class="comment">// 发布一个消息事件，新增 session，以供 MessageListener 回调处理。</span></span><br><span class="line">		<span class="keyword">this</span>.sessionRedisOperations.convertAndSend(sessionCreatedKey, session.delta);</span><br><span class="line">		session.setNew(<span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-4-findById"><a href="#3-1-4-findById" class="headerlink" title="3.1.4 findById"></a>3.1.4 findById</h4><p>查询这部分和基于<code>Map</code>的差别比较大，因为这里并不是直接操作<code>Map</code>，而是与<code>Redis</code> 进行一次交互。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisSession <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> getSession(id, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用<code>getSession</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RedisSession <span class="title">getSession</span><span class="params">(String id, <span class="keyword">boolean</span> allowExpired)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 根据ID从redis中取出数据</span></span><br><span class="line">	Map&lt;Object, Object&gt; entries = getSessionBoundHashOperations(id).entries();</span><br><span class="line">	<span class="keyword">if</span> (entries.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//转换成MapSession</span></span><br><span class="line">	MapSession loaded = loadSession(id, entries);</span><br><span class="line">	<span class="keyword">if</span> (!allowExpired &amp;&amp; loaded.isExpired()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//转换成RedisSession</span></span><br><span class="line">	RedisSession result = <span class="keyword">new</span> RedisSession(loaded);</span><br><span class="line">	result.originalLastAccessTime = loaded.getLastAccessedTime();</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>loadSession</code>中构建<code>MapSession</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MapSession <span class="title">loadSession</span><span class="params">(String id, Map&lt;Object, Object&gt; entries)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 生成MapSession实例</span></span><br><span class="line">	MapSession loaded = <span class="keyword">new</span> MapSession(id);</span><br><span class="line">	<span class="comment">//遍历数据</span></span><br><span class="line">	<span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entries.entrySet()) &#123;</span><br><span class="line">		String key = (String) entry.getKey();</span><br><span class="line">		<span class="keyword">if</span> (CREATION_TIME_ATTR.equals(key)) &#123;</span><br><span class="line">		    <span class="comment">// 设置创建时间</span></span><br><span class="line">			loaded.setCreationTime(Instant.ofEpochMilli((<span class="keyword">long</span>) entry.getValue()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (MAX_INACTIVE_ATTR.equals(key)) &#123;</span><br><span class="line">			 <span class="comment">// 设置最大有效时间</span></span><br><span class="line">			loaded.setMaxInactiveInterval(Duration.ofSeconds((<span class="keyword">int</span>) entry.getValue()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (LAST_ACCESSED_ATTR.equals(key)) &#123;</span><br><span class="line">			<span class="comment">// 设置最后访问时间</span></span><br><span class="line">			loaded.setLastAccessedTime(Instant.ofEpochMilli((<span class="keyword">long</span>) entry.getValue()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key.startsWith(SESSION_ATTR_PREFIX)) &#123;</span><br><span class="line">		<span class="comment">// 设置属性</span></span><br><span class="line">			loaded.setAttribute(key.substring(SESSION_ATTR_PREFIX.length()),</span><br><span class="line">					entry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> loaded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-5-deleteById"><a href="#3-1-5-deleteById" class="headerlink" title="3.1.5 deleteById"></a>3.1.5 deleteById</h4><p>根据<code>sessionId</code>删除<code>session</code>数据。具体过程看代码注释。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(String sessionId)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取 RedisSession</span></span><br><span class="line">	RedisSession session = getSession(sessionId, <span class="keyword">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (session == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">   <span class="comment">// 清楚当前session数据的索引</span></span><br><span class="line">	cleanupPrincipalIndex(session);</span><br><span class="line">	<span class="comment">//执行删除操作</span></span><br><span class="line">	<span class="keyword">this</span>.expirationPolicy.onDelete(session);</span><br><span class="line">	String expireKey = getExpiredKey(session.getId());</span><br><span class="line">	<span class="comment">//删除expireKey</span></span><br><span class="line">	<span class="keyword">this</span>.sessionRedisOperations.delete(expireKey);</span><br><span class="line">	<span class="comment">//session有效期设置为0</span></span><br><span class="line">	session.setMaxInactiveInterval(Duration.ZERO);</span><br><span class="line">	save(session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-1-6-onMessage"><a href="#3-1-6-onMessage" class="headerlink" title="3.1.6 onMessage"></a>3.1.6 onMessage</h4><p>最后来看下这个订阅回调处理。这里看下核心的一段逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isDeleted = channel.equals(<span class="keyword">this</span>.sessionDeletedChannel);</span><br><span class="line"><span class="comment">// Deleted 还是 Expired ？</span></span><br><span class="line"><span class="keyword">if</span> (isDeleted || channel.equals(<span class="keyword">this</span>.sessionExpiredChannel)) &#123;</span><br><span class="line">	<span class="comment">// 此处省略无关代码</span></span><br><span class="line">	<span class="comment">// Deleted</span></span><br><span class="line">	<span class="keyword">if</span> (isDeleted) &#123;</span><br><span class="line">	   <span class="comment">// 发布一个 SessionDeletedEvent 事件</span></span><br><span class="line">		handleDeleted(session);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Expired</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 发布一个 SessionExpiredEvent 事件</span></span><br><span class="line">		handleExpired(session);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-Redis-存储的一些思考"><a href="#3-2-Redis-存储的一些思考" class="headerlink" title="3.2 Redis 存储的一些思考"></a>3.2 Redis 存储的一些思考</h3><p>首先按照我们自己常规的思路来设计的话，我们会怎么来考虑这个事情。这里首先要声明下，我对 <code>Redis</code> 这个东西不是很熟，没有做过深入的研究；那如果是我来做，可能也就仅仅限于存储。</p>
<ul>
<li><code>findByIndexNameAndIndexValue</code>的设计，这个的作用是通过<code>indexName</code>和<code>indexValue</code>来返回当前用户的所有会话。但是这里需要考虑的一个事情是，通常情况下，一个用户只会关联到一个会话上面去，那这种设计很显然，我的理解是为了支持单用户多会话的场景。<ul>
<li>indexName：FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME</li>
<li>indexValue：username</li>
</ul>
</li>
<li><p>实现 <code>MessageListener</code> 接口，增加事件通知能力。通过监听这些事件，可以做一些<code>session</code>操作管控。但是实际上 <code>SpringSession</code> 中并没有做任何事情，从代码来看，<code>publishEvent</code>方法是空实现。等待回复中 <a href="https://github.com/spring-projects/spring-session/issues/1287" target="_blank" rel="noopener">#issue 1287</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ApplicationEventPublisher eventPublisher = <span class="keyword">new</span> ApplicationEventPublisher() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>RedisFlushMode</code> ，<code>SpringSession</code>中提供了两种模式的推送，一种是<code>ON_SAVE</code>，另外一种是<code>IMMEDIATE</code>。默认是<code>ON_SAVE</code>，也就是常规的在请求处理结束时进行一次<code>sessionCommit</code>操作。<code>RedisFlushMode</code> 的设计感觉是为<code>session</code>数据持久化的时机提供了另外一种思路。</p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>存储机制设计部分就一基于内存和基于<code>Redis</code>两种来分析；另外基于<code>jdbc</code>和<code>hazelcast</code>有兴趣的同学可以自己查看源码。</p>
<p>最后也欢迎访问我的个人博客：<a href="http://www.glmapper.com">www.glmapper.com</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/zyhlwzy/article/details/78062646" target="_blank" rel="noopener">https://blog.csdn.net/zyhlwzy/article/details/78062646</a></li>
<li><a href="https://docs.spring.io/spring-session/docs/2.0.0.M4/reference/html5/#api" target="_blank" rel="noopener">https://docs.spring.io/spring-session/docs/2.0.0.M4/reference/html5/#api</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/12/16/spring-session-redis-map/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/24/spring-session-solutions/">SpringSession系列-分布式Session实现方案</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-24T08:55:33.000Z" itemprop="datePublished">2018/11/24</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/24/spring-session-solutions/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/session/" title="session">session</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>上一篇文章 <a href="https://juejin.im/post/5bdd449b6fb9a04a09557a40" target="_blank" rel="noopener">SpringSession：集成SpringBoot</a> 中介绍了如何在<code>SpringBoot</code>中来集成 <code>SpringSession</code>，整个过程非常简单，同时也简单分析了下<code>SpringSession</code>的作用原理。继上一篇实践之后，本文主要来分析 <code>SpringSession</code> 的原理。</p>
<h2 id="1、从-session-的一致性方案说起"><a href="#1、从-session-的一致性方案说起" class="headerlink" title="1、从 session 的一致性方案说起"></a>1、从 session 的一致性方案说起</h2><p>关于 <code>session</code> 和<code>cookie</code> 的一些知识，大家可以参考下我之前写的一篇文章：<a href="https://juejin.im/post/5aede266f265da0ba266e0ef" target="_blank" rel="noopener">聊一聊session和cookie</a>。</p>
<p><code>Session</code>作为服务器端使用的一种记录客户端状态的机制，其对客户端是透明的；但是<code>Session</code> 的正常运作仍然需要客户端浏览器的支持。我们都知道，<code>HTTP</code>协议是无状态的，<code>Session</code>不能依据<code>HTTP</code>连接来判断是否为同一客户，因此服务器需要向客户端浏览器发送一个识别标志（<code>sessionId</code>）,这个识别标志通过是通过<code>Cookie</code>机制来完成。</p>
<h3 id="1-1、session-一致性问题的由来"><a href="#1-1、session-一致性问题的由来" class="headerlink" title="1.1、session 一致性问题的由来"></a>1.1、session 一致性问题的由来</h3><p>当用户首次访问我们的<code>Servlet</code>时，应用服务器端会给用户创建一个独立的<code>Session</code>，并且存储在内存中。这种情况在单应用服务器场景下是可以满足的（这里不讨论其一个弊端，就是内存占用给服务器带来的压力的问题）。在集群场景下，这种机制就会到来问题：</p>
<h4 id="1-1-1、单机场景"><a href="#1-1-1、单机场景" class="headerlink" title="1.1.1、单机场景"></a>1.1.1、单机场景</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/4/166dee5cad0e35b8?w=968&amp;h=250&amp;f=png&amp;s=21829" alt=""></p>
<p>因为是一台应用服务器，用户的每次请求都是由这台机器来处理，所以不会有<code>session</code>共享问题。</p>
<h4 id="1-1-2、集群场景"><a href="#1-1-2、集群场景" class="headerlink" title="1.1.2、集群场景"></a>1.1.2、集群场景</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/4/166dee88ddb7d0ee?w=960&amp;h=608&amp;f=png&amp;s=42547" alt=""></p>
<p>假设现在集群中有三台机器，（从上到下：A-&gt;B-&gt;C）。当前用户首次发起访问时，请求被分配到 A 机器处理，<code>Session</code>数据被写入 A 机器的内存中；当再次发起访问 时，请求被分配的 B 处理，但此时 B 内存中并没有当前用户的任何数据，这样就出现了<code>session</code>不一致的情况了。</p>
<h3 id="1-2、Session-一致性问题的方案"><a href="#1-2、Session-一致性问题的方案" class="headerlink" title="1.2、Session 一致性问题的方案"></a>1.2、Session 一致性问题的方案</h3><p>对于当前服务化、单元化应用盛行的时代，简单的内存型的 <code>Session</code> 已经不能够满足我们的要求了。那么我们就需要寻求一种方案来替换目前单机内存存储实现的方案。</p>
<h4 id="1-2-1-基于-IP-HASH-的实现机制"><a href="#1-2-1-基于-IP-HASH-的实现机制" class="headerlink" title="1.2.1 基于 IP-HASH 的实现机制"></a>1.2.1 基于 IP-HASH 的实现机制</h4><p>在 1.1.2 中因为我们无法知道请求会被分配到哪台机器来处理，所以会导致<code>session</code>不一致的问题出现。如果我们可以解决让每个用户的请求能够固定的打到某一台机器上，那么上面提到的问题其实也就不存在了。<code>IP-HASH</code> 就是这样一种方案。通过对请求的客户端 <code>IP</code> 进行 <code>HASH</code> 计算，并将计算结果映射到具体一台机器，这样就可以将请求固定分配到某一台机器上，从而有效的避免<code>session</code>一致性问题的出现。</p>
<p>这种方案的好处在于:</p>
<ul>
<li>不需要修改任何应用代码，0 侵入。</li>
<li>安全性高，不依赖其他三方缓存框架带来的风险</li>
<li>成本低</li>
</ul>
<p>但是问题也很明显，这种方式实际上是规避了<code>session</code>一致性问题的出现，并非是针对<code>session</code>一致性问题给出的解决方案。主要问题：</p>
<ul>
<li>基于应用内存，会给应用服务器带来一定的压力</li>
<li>服务重启会导致<code>session</code>数据丢失</li>
<li>不利于水平扩展，水平扩展也可能丢失<code>session</code></li>
<li>存在单点负载高的情况，就是多数请求经过<code>HASH</code>计算之后打到同一台机器，而其他机器处于空闲状态。</li>
</ul>
<h4 id="1-2-2-session-复制"><a href="#1-2-2-session-复制" class="headerlink" title="1.2.2 session 复制"></a>1.2.2 session 复制</h4><p>这种方式的实现原理是应用服务器创建<code>session</code>之后通过组播的方式将<code>session</code>发送到组播地址内的其他应用服务器上。这种方式相较于<code>IP-HASH</code> 的方式要靠谱一点：</p>
<ul>
<li>同样不需要更改任何业务代码</li>
<li>能够适应多种负载策略</li>
<li>机器重启或者宕机之后不怕丢失，因为有冗余备份</li>
</ul>
<p>但是这种方式也有比较大的问题：</p>
<ul>
<li>首先就是服务器之间同步<code>session</code>会占用一定的网络资源，同时<code>session</code>在不同的机器之间进行同步存在延迟。</li>
<li>还是基于内存存储，局限于机器内存容量影响，水平扩展能力差</li>
<li>服务器内存因为需要存储其他机器上的<code>session</code>数据，对内存的消耗会随着集群的规模变大而变大，可能会导致机器频繁触发<code>GC</code>。</li>
</ul>
<h4 id="1-2-3-借助三方缓存框架实现-session-集中管理"><a href="#1-2-3-借助三方缓存框架实现-session-集中管理" class="headerlink" title="1.2.3 借助三方缓存框架实现 session 集中管理"></a>1.2.3 借助三方缓存框架实现 session 集中管理</h4><p>上面两种方式都是有服务器自己来管理<code>session</code>的，主要问题还是在于对于性能和内存的影响。而这种方式的原理是将<code>session</code>托管给三方软件（如<code>redis</code>）来统一管理。这种方式可以有效的解决性能、内存占用以及水平扩展等问题。但是因为引入了三方软件，在实现复杂度、运维成本等方面会有所增加。</p>
<p>目前所接触到的分布式<code>session</code>的实现方案，大多都是基于这种方式来实现的；<code>SpringSession</code> 也不例外。</p>
<h2 id="2、SpringSession-功能结构分析"><a href="#2、SpringSession-功能结构分析" class="headerlink" title="2、SpringSession 功能结构分析"></a>2、SpringSession 功能结构分析</h2><p>前面对分布式场景下的 <code>Session</code>一致性问题进行了说明，并对解决<code>Session</code>一致性的问题的几种策略进行的分析（有点糙，网上这些知识有很多）。在了解这些背景之后，我们来看下 <code>SpringSession</code> 的实现原理。</p>
<h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p><code>Spring Session</code> 提供了用于管理用户会话信息的<code>API</code>和实现，在不依赖特定于应用程序容器的解决方案的情况下，使得支持群集会话变得更加简单。它还提供了透明的集成：</p>
<ul>
<li>允许以应用程序容器（<code>Tomcat</code>等）中立的方式替换 <code>HttpSesseion</code>，支持在 <code>headers</code>中提供 <code>session IDs</code>来使用 <code>RESTful API</code>。</li>
<li>提供在接收 <code>WebSocket</code> 消息时保持<code>HTTP</code> 会话存活的能力</li>
<li>允许以应用程序容器中立的方式替换 <code>Spring WebFlux</code> 的 <code>WebSession</code>。</li>
</ul>
<blockquote>
<p>以上来自官网文档翻译 <a href="https://github.com/spring-projects/spring-session" target="_blank" rel="noopener">Spring Session </a></p>
</blockquote>
<h3 id="2-2-模块"><a href="#2-2-模块" class="headerlink" title="2.2 模块"></a>2.2 模块</h3><p><code>Spring Session</code> 主要包括 4 个模块：</p>
<ul>
<li><code>spring-session-core</code> ：提供了 <code>Spring Session</code> 核心功能和<code>API</code></li>
<li><code>spring-session-data-redis</code>：以 <code>redis</code> 作为存储机制的 <code>SessionRepository</code> 实现</li>
<li><code>spring-session-hazelcast</code>：以 <code>Hazelcast</code> 作为存储机制的 <code>SessionRepository</code> 实现</li>
<li><code>spring-session-jdbc</code>：以关系型数据库作为存储机制的 <code>SessionRepository</code> 实现</li>
</ul>
<p>总体来说就是 核心<code>API</code>+存储实现；工程模块截图如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/4/166dec2555f6da9e?w=1070&amp;h=530&amp;f=png&amp;s=77929" alt=""></p>
<h3 id="2-3-功能结构"><a href="#2-3-功能结构" class="headerlink" title="2.3 功能结构"></a>2.3 功能结构</h3><p>SpringSession整体上可以分为三块：</p>
<ul>
<li>对于Web层的处理，这里包括对于请求的重写，自定义的filter加入到filter chain，cookie处理，http header处理等</li>
<li>公共基础封装，比如存储类的顶层抽象接口定义，自定配置，事件处理等。</li>
<li>存储部分，这部分实际上是对公共基础封装接口的实现，提供了丰富的存储实现，包括redis，内存存储，jdbc等。</li>
</ul>
<h3 id="2-4-多-session-支持"><a href="#2-4-多-session-支持" class="headerlink" title="2.4 多 session 支持"></a>2.4 多 session 支持</h3><p>对于常用的分布式session，在实现上一般会依赖于 cookie。但是在 springsession 中提供了基于header来传递jessionID的策略实现。同时在 2.0.4 版本之前，对于同一个浏览器同一个网站，springsession 支持多个<code>session</code>问题，但是在此版本之后抛弃了对于对 session 的支持。关于更多关于多session支持可以查看 SpringSession 的<a href="https://docs.spring.io/spring-session/docs/1.3.5.BUILD-SNAPSHOT/reference/html5/" target="_blank" rel="noopener">官方文档</a>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文对分布式 session 的几种实现策略进行了简单的介绍。对于分布式 session 而言，如何解决一致性问题是关键，目前我见过的绝大多数方案均是以 【借助三方缓存框架实现 session 集中管理】 这种来实现的，包括本系列文章中所要介绍的 SpringSession。</p>
<p>除分布式session一致性方式解决方案的介绍之外，作为SpringSession 的第二篇文章，在这里简单分析了下Springsession的功能模块，以便后续展开对源码的分析。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/24/spring-session-solutions/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/24/spring-session-req-resp/">SpringSession系列-请求与响应重写</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-24T08:54:07.000Z" itemprop="datePublished">2018/11/24</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/24/spring-session-req-resp/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/session/" title="session">session</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>我们知道，<code>HttpServletRequset</code>和<code>HttpServletResponse</code>是<code>Servlet</code>标准所指定的<code>Java</code>语言与<code>Web</code>容器进行交互的接口。接口本身只规定<code>java</code>语言对<code>web</code>容器进行访问的行为方式，而具体的实现是由不同的<code>web</code>容器在其内部实现的。</p>
<p>那么在运行期，当我们需要对<code>HttpServletRequset</code>和<code>HttpServletResponse</code>的默认实例进行扩展时，我们就可以继承<code>HttpServletRequestWrapper</code>和<code>HttpServletResponseWrapper</code>来实现。<br>　　<br>在 <code>SpringSession</code>中因为我们要实现不依赖容器本身的<code>getSession</code> 实现，因此需要扩展 <code>HttpServletRequset</code>，通过重写<code>getSession</code>来实现分布式<code>session</code>的能力。下面就来看下<code>SpringSession</code>中对于<code>HttpServletRequset</code>的扩展。</p>
<h2 id="1、请求重写"><a href="#1、请求重写" class="headerlink" title="1、请求重写"></a>1、请求重写</h2><p><code>SpringSession</code> 中对于请求重写，在能力上主要体现在存储方面，也就是<code>getSession</code>方法上。在 <code>SessionRepositoryFilter</code> 这个类中，是通过内部类的方式实现了对<code>HttpServletRequset</code>和<code>HttpServletResponse</code>的扩展。</p>
<h3 id="1-1-HttpServletRequset-扩展实现"><a href="#1-1-HttpServletRequset-扩展实现" class="headerlink" title="1.1 HttpServletRequset 扩展实现"></a>1.1 HttpServletRequset 扩展实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionRepositoryRequestWrapper</span></span></span><br><span class="line"><span class="class">			<span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line">	<span class="comment">// HttpServletResponse 实例</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> HttpServletResponse response;</span><br><span class="line">	<span class="comment">// ServletContext 实例</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ServletContext servletContext;</span><br><span class="line">        <span class="comment">// requestedSession session对象</span></span><br><span class="line">        <span class="keyword">private</span> S requestedSession; </span><br><span class="line">        <span class="comment">// 是否缓存 session</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> requestedSessionCached;</span><br><span class="line">	<span class="comment">// sessionId</span></span><br><span class="line">	<span class="keyword">private</span> String requestedSessionId;</span><br><span class="line">	<span class="comment">// sessionId 是否有效</span></span><br><span class="line">	<span class="keyword">private</span> Boolean requestedSessionIdValid;</span><br><span class="line">	<span class="comment">// sessionId 是否失效</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> requestedSessionInvalidated;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 省略方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SessionRepositoryRequestWrapper</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">		HttpServletResponse response, ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>(request);</span><br><span class="line">	<span class="keyword">this</span>.response = response;</span><br><span class="line">	<span class="keyword">this</span>.servletContext = servletContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方法里面将 <code>HttpServletRequest</code>、<code>HttpServletResponse</code> 以及 <code>ServletContext</code> 实例传递进来，以便于后续扩展使用。</p>
<h3 id="1-3-getSession-方法"><a href="#1-3-getSession-方法" class="headerlink" title="1.3 getSession 方法"></a>1.3 getSession 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpSessionWrapper <span class="title">getSession</span><span class="params">(<span class="keyword">boolean</span> create)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从当前请求线程中获取 session</span></span><br><span class="line">	HttpSessionWrapper currentSession = getCurrentSession();</span><br><span class="line">	<span class="comment">// 如果有直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (currentSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> currentSession;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从请求中获取 session，这里面会涉及到从缓存中拿session的过程</span></span><br><span class="line">	S requestedSession = getRequestedSession();</span><br><span class="line">	<span class="keyword">if</span> (requestedSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">	    <span class="comment">// 无效的会话id(不支持的会话存储库)请求属性名称。</span></span><br><span class="line">	    <span class="comment">// 这里看下当前的sessionId是否有效</span></span><br><span class="line">		<span class="keyword">if</span> (getAttribute(INVALID_SESSION_ID_ATTR) == <span class="keyword">null</span>) &#123;</span><br><span class="line">		    <span class="comment">// 设置当前session的最后访问时间，用于延迟session的有效期</span></span><br><span class="line">			requestedSession.setLastAccessedTime(Instant.now());</span><br><span class="line">			<span class="comment">// 将requestedSessionIdValid置为true</span></span><br><span class="line">			<span class="keyword">this</span>.requestedSessionIdValid = <span class="keyword">true</span>;</span><br><span class="line">			<span class="comment">// 包装session</span></span><br><span class="line">			currentSession = <span class="keyword">new</span> HttpSessionWrapper(requestedSession, getServletContext());</span><br><span class="line">			<span class="comment">// 不是新的session，如果是新的session则需要改变sessionId</span></span><br><span class="line">			currentSession.setNew(<span class="keyword">false</span>);</span><br><span class="line">			<span class="comment">// 将session设置到当前请求上下文</span></span><br><span class="line">			setCurrentSession(currentSession);</span><br><span class="line">			<span class="comment">// 返回session</span></span><br><span class="line">			<span class="keyword">return</span> currentSession;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 这里处理的是无效的sessionId的情况，但是当前请求线程 session有效</span></span><br><span class="line">		<span class="keyword">if</span> (SESSION_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">			SESSION_LOGGER.debug(</span><br><span class="line">					<span class="string">"No session found by id: Caching result for getSession(false) for this HttpServletRequest."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将invalidSessionId置为true</span></span><br><span class="line">		setAttribute(INVALID_SESSION_ID_ATTR, <span class="string">"true"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 是否需要创建新的session</span></span><br><span class="line">	<span class="keyword">if</span> (!create) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (SESSION_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">		SESSION_LOGGER.debug(</span><br><span class="line">				<span class="string">"A new session was created. To help you troubleshoot where the session was created we provided a StackTrace (this is not an error). You can prevent this from appearing by disabling DEBUG logging for "</span></span><br><span class="line">						+ SESSION_LOGGER_NAME,</span><br><span class="line">				<span class="keyword">new</span> RuntimeException(</span><br><span class="line">						<span class="string">"For debugging purposes only (not an error)"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建新的session</span></span><br><span class="line">	S session = SessionRepositoryFilter.<span class="keyword">this</span>.sessionRepository.createSession();</span><br><span class="line">	<span class="comment">// 设置最后访问时间，也就是指定了当前session的有效期限</span></span><br><span class="line">	session.setLastAccessedTime(Instant.now());</span><br><span class="line">	<span class="comment">// 包装下当前session</span></span><br><span class="line">	currentSession = <span class="keyword">new</span> HttpSessionWrapper(session, getServletContext());</span><br><span class="line">	<span class="comment">//设置到当前请求线程</span></span><br><span class="line">	setCurrentSession(currentSession);</span><br><span class="line">	<span class="keyword">return</span> currentSession;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码有几个点，这里单独来解释下。</p>
<ul>
<li><code>getCurrentSession</code><ul>
<li>这是为了在同一个请求过程中不需要重复的去从存储中获取session，在一个新的进来时，将当前的 session 设置到当前请求中，在后续处理过程如果需要getSession就不需要再去存储介质中再拿一次。</li>
</ul>
</li>
<li><code>getRequestedSession</code><ul>
<li>这个是根据请求信息去取<code>session</code>，这里面就包括了<code>sessionId</code>解析，从存储获取<code>session</code>对象等过程。</li>
</ul>
</li>
<li>是否创建新的<code>session</code>对象   <ul>
<li>在当前请求中和存储中都没有获取到<code>session</code>信息的情况下，这里会根据<code>create</code>参数来判断是否创建新的<code>session</code>。这里一般用户首次登录时或者<code>session</code>失效时会走到。</li>
</ul>
</li>
</ul>
<h3 id="1-4-getRequestedSession"><a href="#1-4-getRequestedSession" class="headerlink" title="1.4 getRequestedSession"></a>1.4 getRequestedSession</h3><p>根据请求信息来获取<code>session</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> S <span class="title">getRequestedSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存的请求session是否存在</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.requestedSessionCached) &#123;</span><br><span class="line">            <span class="comment">// 获取 sessionId</span></span><br><span class="line">            List&lt;String&gt; sessionIds = SessionRepositoryFilter.<span class="keyword">this</span>.httpSessionIdResolver</span><br><span class="line">            		.resolveSessionIds(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 通过sessionId来从存储中获取session</span></span><br><span class="line">            <span class="keyword">for</span> (String sessionId : sessionIds) &#123;</span><br><span class="line">            	<span class="keyword">if</span> (<span class="keyword">this</span>.requestedSessionId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            		<span class="keyword">this</span>.requestedSessionId = sessionId;</span><br><span class="line">            	&#125;</span><br><span class="line">            	S session = SessionRepositoryFilter.<span class="keyword">this</span>.sessionRepository</span><br><span class="line">            			.findById(sessionId);</span><br><span class="line">            	<span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">            		<span class="keyword">this</span>.requestedSession = session;</span><br><span class="line">            		<span class="keyword">this</span>.requestedSessionId = sessionId;</span><br><span class="line">            		<span class="keyword">break</span>;</span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.requestedSessionCached = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.requestedSession;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码还是很有意思的，这里获取<code>sessionId</code>返回的是个列表。当然这里是<code>SpringSession</code>的实现策略，因为支持<code>session</code>，所以这里以列表的形式返回的。OK，继续来看如何解析<code>sessionId</code>的：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744a467ce2ada6?w=1394&amp;h=200&amp;f=png&amp;s=80360" alt=""></p>
<p>这里可以看到<code>SpringSession</code>对于<code>sessionId</code>获取的两种策略，一种是基于<code>cookie</code>，一种是基于<code>header</code>；分别来看下具体实现。</p>
<h4 id="1-4-1-CookieHttpSessionIdResolver-获取-sessionId"><a href="#1-4-1-CookieHttpSessionIdResolver-获取-sessionId" class="headerlink" title="1.4.1 CookieHttpSessionIdResolver 获取 sessionId"></a>1.4.1 CookieHttpSessionIdResolver 获取 sessionId</h4><p><code>CookieHttpSessionIdResolver</code> 中获取<code>sessionId</code>的核心代码如下：<br><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744a7c7c05a32f?w=1360&amp;h=710&amp;f=png&amp;s=152689" alt=""><br>其实这里没啥好说的，就是读<code>cookie</code>。从<code>request</code>将<code>cookie</code>信息拿出来，然后遍历找当前<code>sessionId</code>对应的<code>cookie</code>,这里的判断也很简单， 如果是以<code>SESSION</code>开头，则表示是 <code>SessionId</code>，毕竟<code>cookie</code>是共享的，不只有<code>sessionId</code>，还有可能存储其他内容。</p>
<p>另外这里面有个 jvmRoute，这个东西实际上很少能够用到，因为大多数情况下这个值都是null。这个我们在分析<code>CookieSerializer</code>时再来解释。</p>
<h4 id="1-4-2-HeaderHttpSessionIdResolver-获取-sessionId"><a href="#1-4-2-HeaderHttpSessionIdResolver-获取-sessionId" class="headerlink" title="1.4.2 HeaderHttpSessionIdResolver 获取 sessionId"></a>1.4.2 HeaderHttpSessionIdResolver 获取 sessionId</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744b76477e1904?w=1144&amp;h=196&amp;f=png&amp;s=51550" alt=""><br>这个获取更直接粗暴，就是根据 <code>headerName</code> 从 <code>header</code> 中取值。</p>
<p>回到<code>getRequestedSession</code>，剩下的代码中核心的都是和<code>sessionRepository</code>这个有关系，这部分就会涉及到存储部分。不在本篇的分析范围之内，会在存储实现部分来分析。</p>
<h3 id="1-5-HttpSessionWrapper"><a href="#1-5-HttpSessionWrapper" class="headerlink" title="1.5 HttpSessionWrapper"></a>1.5 HttpSessionWrapper</h3><p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744bd83bd21c65?w=1436&amp;h=416&amp;f=png&amp;s=96267" alt=""></p>
<p>上面的代码中当我们拿到<code>session</code>实例是通常会包装下，那么用到的就是这个<code>HttpSessionWrapper</code>。</p>
<p><code>HttpSessionWrapper</code> 继承了 <code>HttpSessionAdapter</code>，这个<code>HttpSessionAdapter</code>就是将SpringSession 转换成一个标准<code>HttpSession</code>的适配类。<code>HttpSessionAdapter</code> 实现了标准<code>servlet</code>规范的<code>HttpSession</code>接口。</p>
<h4 id="1-5-1-HttpSessionWrapper"><a href="#1-5-1-HttpSessionWrapper" class="headerlink" title="1.5.1 HttpSessionWrapper"></a>1.5.1 HttpSessionWrapper</h4><p><code>HttpSessionWrapper</code> 重写了 <code>invalidate</code>方法。从代码来看，调用该方法产生的影响是：</p>
<ul>
<li><code>requestedSessionInvalidated</code> 置为<code>true</code>，标识当前 <code>session</code> 失效。</li>
<li>将当前请求中的<code>session</code>设置为<code>null</code>，那么在请求的后续调用中通过<code>getCurrentSession</code>将拿不到<code>session</code>信息。</li>
<li>当前缓存的 session 清楚，包括sessionId，session实例等。</li>
<li>删除存储介质中的session对象。</li>
</ul>
<h4 id="1-5-2-HttpSessionAdapter"><a href="#1-5-2-HttpSessionAdapter" class="headerlink" title="1.5.2 HttpSessionAdapter"></a>1.5.2 HttpSessionAdapter</h4><p><code>SpringSession</code>和标准<code>HttpSession</code>的配置器类。这个怎么理解呢，来看下一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getAttribute</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">	checkState();</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.session.getAttribute(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于基于容器本身实现的<code>HttpSession</code>来说，<code>getAttribute</code>的实现也是有容器本身决定。但是这里做了转换之后，<code>getAttribute</code>将会通过<code>SpringSession</code>中实现的方案来获取。其他的<code>API</code>适配也是基于此实现。</p>
<h3 id="SessionCommittingRequestDispatcher"><a href="#SessionCommittingRequestDispatcher" class="headerlink" title="SessionCommittingRequestDispatcher"></a>SessionCommittingRequestDispatcher</h3><p>实现了 <code>RequestDispatcher</code> 接口。关于<code>RequestDispatcher</code>可以参考这篇文章<a href="https://www.cnblogs.com/lulipro/p/7471987.html" target="_blank" rel="noopener">【Servlet】关于RequestDispatcher的原理</a>。<code>SessionCommittingRequestDispatcher</code>对<code>forward</code>的行为并没有改变。<br>对于<code>include</code>则是在<code>include</code>之前提交<code>session</code>。为什么这么做呢？</p>
<p> 因为<code>include</code>方法使原先的<code>Servlet</code>和转发到的<code>Servlet</code>都可以输出响应信息，即原先的<code>Servlet</code>还可以继续输出响应信息；即请求转发后，原先的<code>Servlet</code>还可以继续输出响应信息，转发到的<code>Servlet</code>对请求做出的响应将并入原先<code>Servlet</code>的响应对象中。 </p>
<p> 所以这个在<code>include</code>调用之前调用<code>commit</code>，这样可以确保被包含的<code>Servlet</code>程序不能改变响应消息的状态码和响应头。</p>
<h2 id="2-响应重写"><a href="#2-响应重写" class="headerlink" title="2 响应重写"></a>2 响应重写</h2><p>响应重写的目的是确保在请求提交时能够把session保存起来。来看下<code>SessionRepositoryResponseWrapper</code>类的实现：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744deabbf838ec?w=1140&amp;h=678&amp;f=png&amp;s=148489" alt=""><br>这里面实现还就是重写<code>onResponseCommitted</code>，也就是上面说的，在请求提交时能够通过这个回调函数将<code>session</code>保存到存储容器中。</p>
<h3 id="2-1-session-提交"><a href="#2-1-session-提交" class="headerlink" title="2.1 session 提交"></a>2.1 session 提交</h3><p>最后来看下 commitSession</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744e0fea8b3996?w=1374&amp;h=610&amp;f=png&amp;s=139692" alt=""></p>
<p>这个过程不会再去存储容器中拿<code>session</code>信息，而是直接从当前请求中拿。如果拿不到，则在回写<code>cookie</code>时会将当前<code>session</code>对应的<code>cookie</code>值设置为空，这样下次请求过来时携带的<code>sessionCookie</code>就是空，这样就会重新触发登陆。</p>
<p>如果拿到，则清空当前请求中的<code>session</code>信息，然后将<code>session</code>保存到存储容器中，并且将<code>sessionId</code>回写到<code>cookie</code>中。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇主要对<code>SpringSession</code>中重写<code>Request</code>和<code>Response</code>进行了分析。通过重写<code>Request</code>请求来将<code>session</code>的存储与存储容器关联起来，通过重写<code>Response</code>来处理<code>session</code>提交，将<code>session</code>保存到存储容器中。</p>
<p>后面我们会继续来分析<code>SpringSession</code>的源码。最近也在学习链路跟踪相关的技术，也准备写一写，有兴趣的同学可以一起讨论。</p>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><ul>
<li><a href="https://github.com/alipay" target="_blank" rel="noopener">SOFA 开源社区</a></li>
<li><a href="https://github.com/alipay/sofa-tracer" target="_blank" rel="noopener">SOFATracer</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/24/spring-session-req-resp/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/spring-series-annotation/">Spring源码系列：注解说明</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T06:18:34.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/spring-series-annotation/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>因为要看Spring中注解的具体定义，所以在说之前，先来简单说下JAVA中注解的一些基本知识。</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>什么是元注解呢，就是注解的注解。java中提供了以下几种：</p>
<ul>
<li>@Target</li>
</ul>
<pre><code>注解的作用域描述
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</span><br><span class="line">    <span class="comment">/** 类, 接口 或者枚举 */</span></span><br><span class="line">    TYPE,</span><br><span class="line">    <span class="comment">/** 字段 */</span></span><br><span class="line">    FIELD,</span><br><span class="line">    <span class="comment">/** 方法 */</span></span><br><span class="line">    METHOD,</span><br><span class="line">    <span class="comment">/** 参数 */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line">    <span class="comment">/** 构造方法 */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line">    <span class="comment">/** 局部变量 */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line">    <span class="comment">/** 注解类型 */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line">    <span class="comment">/** 包 */</span></span><br><span class="line">    PACKAGE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>@Retention</p>
<p>  生命周期描述</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在原文件中有效，被编译器丢弃。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在class文件有效，可能会被虚拟机忽略。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在运行时有效。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@Inherited</p>
<p>  标识性的元注解，它允许子注解继承它。</p>
</li>
<li><p>@Documented</p>
<p>  用于标准生成javadoc时会包含的注解。</p>
</li>
</ul>
<h2 id="JAVA中注解的定义方式"><a href="#JAVA中注解的定义方式" class="headerlink" title="JAVA中注解的定义方式"></a>JAVA中注解的定义方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名 &#123;定义体&#125;</span><br></pre></td></tr></table></figure>
<hr>

<p>上面试一些基本概念点，关注注解其他的一些特性和用法就不细说了。直接看Spring中的注解吧。</p>
<h2 id="1、-Component"><a href="#1、-Component" class="headerlink" title="1、@Component"></a>1、@Component</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Component &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">     * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the suggested component name, if any</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指示注释类是“组件”。 当使用基于注释的配置和类路径扫描时，这些类被认为是自动检测的候选对象。</p>
<h2 id="2、-Controller"><a href="#2、-Controller" class="headerlink" title="2、@Controller"></a>2、@Controller</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用过Spring mvc的小伙伴对于这个注解肯定不陌生。@Controller表示注释的类是“控制器”（例如Web控制器）。这个注解作为@Component的一个特定方式存在，允许通过类路径扫描来自动检测实现类。通常情况下会结合RequestMapping注解使用。从它的定义层面来看，这个注解只能用于接口或者类上面，不能用于方法或者属性字段上面。</p>
<h2 id="3、-Service"><a href="#3、-Service" class="headerlink" title="3、@Service"></a>3、@Service</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表示注释类是一个“服务”，最初由Domain-Driven Design （Evans，2003）定义为“作为模型中独立的接口提供的操作，没有封装状态”。</p>
<p>在一般情况下，我们把他用在标准我们的service服务接口的实现类上面，实际上这相当于缩小它们的语义和适当的使用。</p>
<p>@Service这个注释作为 @Component的一个特例，允许通过类路径扫描来自动检测实现类。</p>
<h2 id="4、-Repository"><a href="#4、-Repository" class="headerlink" title="4、@Repository"></a>4、@Repository</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Repository &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">     * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the suggested component name, if any</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于标注数据访问组件，即DAO组件</p>
<h2 id="5、-RequestMapping"><a href="#5、-RequestMapping" class="headerlink" title="5、@RequestMapping"></a>5、@RequestMapping</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Mapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"path"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] path() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    RequestMethod[] method() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    String[] params() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    String[] headers() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    String[] consumes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    String[] produces() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@RequestMapping是一个用来处理地址映射请求的注解，从定义可以看出，可作用于方法或者类上。</p>
<ul>
<li>用于类上，大多数是为了进行区分controller</li>
<li>用于方法上则是对方法进行注解以产生访问的路径。</li>
</ul>
<p>它包括了几个属性：</p>
<ul>
<li>value 用于设置方法或者类的映射路径，可以直接写路径。我们通常都是直接写，例如：@RequestMapping(“/XXX”);</li>
<li>method 用于指定请求的方法，可以设置单个或多个，如果请求方法不满足条件则会请求失败。</li>
<li>params  指定request中必须包含某些参数值是，才让该方法处理。</li>
<li>name 此映射指定一个名称</li>
<li>path 仅在Servlet环境中：路径映射URI（例如“/myPath.do”）。也支持Ant风格的路径模式（例如“/myPath/*.do”）。在方法级别，在类型级别表示的主映射内支持相对路径（例如“edit.do”）。 路径映射URI可能包含占位符（例如“/ $ {connect}”）</li>
<li>consumes 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</li>
<li>produces 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</li>
<li>headers 指定request中必须包含某些指定的header值，才能让该方法处理请求。</li>
</ul>
<p>其他的几个没怎么用过，确实不了解，有知道的小伙伴，欢迎留言。</p>
<h2 id="6、-ResponseBody"><a href="#6、-ResponseBody" class="headerlink" title="6、@ResponseBody"></a>6、@ResponseBody</h2><p>@ResponseBody这个我一般是用在做异步请求调用的方法上来使用的。因为在使用@RequestMapping后，返回值通常解析为跳转路径。加上@responsebody后，返回结果直接写入HTTP response body中，不会被解析为跳转路径。</p>
<p>对于异步请求，我们不希望返回解析视图，二是希望响应的结果是json数据，那么加上@responsebody后，就会直接返回json数据。</p>
<h2 id="7、-Autowired"><a href="#7、-Autowired" class="headerlink" title="7、@Autowired"></a>7、@Autowired</h2><p>Autowired就是自动装配的意思，其作用是为了消除代码Java代码里面的getter/setter与bean属性中的property。当然，getter看个人需求，如果私有属性需要对外提供的话，就应该保留。</p>
<p>@Autowired默认按类型匹配的方式，在容器查找匹配的Bean，当有且仅有一个匹配的Bean时，Spring将其注入@Autowired标注的变量中。</p>
<p>但是当接口存在两个实现类的时候必须使用@Qualifier指定注入哪个实现类，否则可以省略，只写@Autowired。</p>
<h2 id="8、-Qualifier"><a href="#8、-Qualifier" class="headerlink" title="8、@Qualifier"></a>8、@Qualifier</h2><p>@Qualifier用于指定注入Bean的名称，就是上面说到的，如果容器中有一个以上匹配的Bean，则可以通过@Qualifier注解限定Bean的名称。</p>
<h2 id="9、-Resource"><a href="#9、-Resource" class="headerlink" title="9、@Resource"></a>9、@Resource</h2><p>这个注解不是Spring的，放在这里是为了和@Autowired做一个区别。<br>@Resource默认按名称装配，当找不到与名称匹配的bean才会按类型装配。</p>
<h2 id="10、-PathVariable"><a href="#10、-PathVariable" class="headerlink" title="10、@PathVariable"></a>10、@PathVariable</h2><p>当使用@RequestMapping URI template 样式映射时， 即 someUrl/{paramId}, 这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user/&#123;userId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">userCenter</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                            HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                            @PathVariable String userId)</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果方法参数名称和需要绑定的uri template中变量名称不一致，需要在@PathVariable(“name”)指定uri template中的名称。</p>
<h2 id="11、-RequestParam"><a href="#11、-RequestParam" class="headerlink" title="11、@RequestParam"></a>11、@RequestParam</h2><p>@RequestParam注解有两个属性： value、required；</p>
<ul>
<li>value用来指定要传入值的id名称</li>
<li>required用来指示参数是否必须绑定；</li>
</ul>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/t_rparam1"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">t_rparam1</span><span class="params">(@RequestParam  Long userId)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//do something   </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/t_rparam2"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">t_rparam2</span><span class="params">(Long userId)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//do something   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>t_rparam1 必须带有参数,也就是说你直接输入localhost:8080/t_rparam1 会报错只能输入localhost:8080/t_rparam1?userId=? 才能执行相应的方法</li>
<li>t_rparam2  可带参数也可不带参数;也就是说输入localhost:8080/t_rparam2和输入 localhost:8080/t_rparam2?userId=?都可以正常运行</li>
</ul>
<p>当然我们也可以设置 @RequestParam 里面的required为false(默认为true 代表必须带参数) 这样t_rparam1就跟t_rparam2是一样的了。</p>
<h2 id="12、-RequestHeader"><a href="#12、-RequestHeader" class="headerlink" title="12、@RequestHeader"></a>12、@RequestHeader</h2><p>利用@RequestHeader 注解可以把Request请求header部分的值绑定到方法的参数上。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/9/16179c7273eff4d0?w=636&amp;h=94&amp;f=png&amp;s=46122" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/t_heander"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getRequestHeaderTest</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                            HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                            @RequestHeader(<span class="string">"Accept-Encoding"</span>)</span>String encoding)  </span>&#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//do something </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13、-CookieValue"><a href="#13、-CookieValue" class="headerlink" title="13、@CookieValue"></a>13、@CookieValue</h2><p>@CookieValue就是把Request header中cookie的值绑定到方法的参数上。比如说我们的cookie如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie:JSESSIONID=ka8A5L5t7WTUPXbaLupBieqOdmc0ZpD5MyKvea6oQr7JJSIZzM;userId=001;sysFlag=glmapper</span><br></pre></td></tr></table></figure>
<p>获取如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/t_cookie"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCookieValueTest</span><span class="params">(@CookieValue(<span class="string">"JSESSIONID"</span>)</span> String cookie)  </span>&#123;  </span><br><span class="line">  <span class="comment">//do something </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="14、-RequestBody"><a href="#14、-RequestBody" class="headerlink" title="14、@RequestBody"></a>14、@RequestBody</h2><p>@RequestBody这个注解常用来处理Content-Type不是application/x-www-form-urlencoded编码的内容，比如说：application/json, application/xml等等；这个和ResonseBody可以反过来理解。</p>
<h2 id="15、-ModelAttribute"><a href="#15、-ModelAttribute" class="headerlink" title="15、@ModelAttribute"></a>15、@ModelAttribute</h2><ul>
<li><p>方法上</p>
<p>  通常用来在处理@RequestMapping之前，为请求绑定需要从后台查询的model；</p>
</li>
<li><p>参数上</p>
<p>  用来通过名称对应，把相应名称的值绑定到注解的参数bean上；</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Spring技术内幕》</li>
<li><a href="https://www.cnblogs.com/FrankLei/p/6579843.html" target="_blank" rel="noopener">https://www.cnblogs.com/FrankLei/p/6579843.html</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/spring-series-annotation/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/spring-series-beanwrapper/">Spring源码系列：BeanWrapper</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T06:15:19.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/spring-series-beanwrapper/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>BeanWrapper 是Spring提供的一个用来操作javaBean属性的工具，使用它可以直接修改一个对象的属性。</p>
<p>对于bean属性的操作，大家熟知的主要有下面这些工具类：</p>
<ul>
<li>1.Apache的BeanUtils和PropertyUtils</li>
<li>2.cglib的BeanMap和BeanCopier</li>
<li>3.spring的BeanUtils</li>
</ul>
<p>Spring中BeanWrapper 的主要功能在于：</p>
<ul>
<li>1.支持设置嵌套属性</li>
<li>2.支持属性值的类型转换（设置ConversionService）</li>
<li>3.提供分析和操作标准JavaBean的操作：获取和设置属性值（单独或批量），获取属性描述符以及查询属性的可读性/可写性的能力。</li>
</ul>
<p>BeanWrapper本身是一个接口，它提供了一整套处理Bean的方法。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanWrapper</span> <span class="keyword">extends</span> <span class="title">ConfigurablePropertyAccessor</span> </span>&#123;</span><br><span class="line">	 <span class="comment">//为数组和集合自动增长指定一个限制。在普通的BeanWrapper上默认是无限的。</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setAutoGrowCollectionLimit</span><span class="params">(<span class="keyword">int</span> autoGrowCollectionLimit)</span></span>;</span><br><span class="line">	<span class="comment">//返回数组和集合自动增长的限制。</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getAutoGrowCollectionLimit</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//如果有的话,返回由此对象包装的bean实例</span></span><br><span class="line">	<span class="function">Object <span class="title">getWrappedInstance</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//返回被包装的JavaBean对象的类型。</span></span><br><span class="line">	Class&lt;?&gt; getWrappedClass();</span><br><span class="line">	<span class="comment">//获取包装对象的PropertyDescriptors（由标准JavaBeans自省确定）。</span></span><br><span class="line">	PropertyDescriptor[] getPropertyDescriptors();</span><br><span class="line">	<span class="comment">//获取包装对象的特定属性的属性描述符。</span></span><br><span class="line">	<span class="function">PropertyDescriptor <span class="title">getPropertyDescriptor</span><span class="params">(String propertyName)</span> <span class="keyword">throws</span> InvalidPropertyException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的BeanWrapper是基于4.3.6版本的，这个接口在4.1版本之后略有改动。BeanWrapperImpl是BeanWrapper的实现类，BeanWrapperImpl的父类是AbstractNestablePropertyAccessor，通过这个使得BeanWrapper具有处理属性的能力。</p>
<p>下面是一个使用BeanWrapper 包装对象的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.spring.test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeanWrapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.PropertyAccessorFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.PropertyValue;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BeanWrapper 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanWrapperTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user=<span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">//通过PropertyAccessorFactory将user对象封装成BeanWrapper</span></span><br><span class="line">        BeanWrapper bw=PropertyAccessorFactory.forBeanPropertyAccess(user);</span><br><span class="line">        <span class="comment">//方式一：直接对属性值进行设置</span></span><br><span class="line">        bw.setPropertyValue(<span class="string">"userName"</span>, <span class="string">"张三"</span>);</span><br><span class="line">        <span class="comment">//方式二：通过PropertyValue进行设置</span></span><br><span class="line">        PropertyValue pv=<span class="keyword">new</span> PropertyValue(<span class="string">"userName"</span>,<span class="string">"李四"</span>);</span><br><span class="line">        bw.setPropertyValue(pv);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        System.out.println(user.getUserName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个User类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Spring中，有很多Bean属性的操作都是通过BeanWrapper来完成的，比如常见的HttpServletBean的属性设置就是。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/spring-series-beanwrapper/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/spring-series-inject-summary/">Spring源码系列：依赖注入（四）-总结</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T06:14:46.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/spring-series-inject-summary/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<ul>
<li><a href="https://juejin.im/post/5a7532746fb9a0633a70d57f" target="_blank" rel="noopener">Spring源码系列：依赖注入（一）getBean</a></li>
<li><a href="https://juejin.im/post/5a77d6256fb9a063606eb538" target="_blank" rel="noopener">Spring源码系列：依赖注入（二）createBean</a></li>
<li><a href="https://juejin.im/post/5a7a655d5188257a5d2b1a35" target="_blank" rel="noopener">Spring源码系列：依赖注入（三）-属性注入</a></li>
</ul>
<p>在上面三篇文章中对依赖注入做了一个大致的梳理；里面都是大量代码的分析，本文在此基础上进行一个总结归纳。</p>
<h2 id="依赖注入调用过程"><a href="#依赖注入调用过程" class="headerlink" title="依赖注入调用过程"></a>依赖注入调用过程</h2><p><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616f3c6ef426da7?w=771&amp;h=470&amp;f=png&amp;s=181652" alt=""></p>
<p>如前几篇文章所述，依赖注入是由getBean来触发的；然后涉及到bean实例的创建、依赖关系的建立、属性注入等子过程。</p>
<ul>
<li>getBean 方法触发依赖注入</li>
<li>doGetBean 从容器中查找Bean（BeanFactory链，当前容器-&gt;双亲容器-双亲容器…）</li>
</ul>
<p>当然，在获取到某个Bean的时候也会通过递归的方式来依赖注入依赖的bean</p>
<ul>
<li><p>createBeanInstance 生成了Bean所包含的Java对象，Spring中用SimpleInstantiationStrategy类来生成Bean对象的实例，实例化Java对象的方法有两种（CGlib是默认方式）：</p>
<ul>
<li>通过BeanUtils，它使用了JVM的反射功能来生成Java对象实例</li>
<li>用CGLIB来生成，CGLIB是一种常用的字节码生成器的类库</li>
</ul>
</li>
<li><p>populateBean 设置Bean对象的依赖关系</p>
</li>
<li>resolveValueIfNecessary 注入类型的处理；解析不同类型的属性</li>
<li>setPropertyValues 属性注入</li>
</ul>
<h2 id="关于lazy-init"><a href="#关于lazy-init" class="headerlink" title="关于lazy-init"></a>关于lazy-init</h2><p>Ioc容器的初始化过程中，主要的工作就是对BeanDefinition的定位、载入、解析和注册；但是就像之前说过的，此时依赖注入还没有发生。在<a href="https://juejin.im/post/5a7532746fb9a0633a70d57f" target="_blank" rel="noopener">Spring源码系列：依赖注入（一）getBean</a>文中提到，依赖注入发生在应用第一次向容器获取Bean的时候；也就是上面说到的通过getBean来触发。</p>
<p>当然，依赖注入也可以在容器初始化的过程中就完成。这个就是lazy-init属性的存在意义了。就是说我们可以通过设置Bean的lazy-init属性来控制预实例化的过程。</p>
<p><code>预实例化：在初始化容器时完成Bean的依赖注入</code></p>
<p>这种做法的好处在于提高了我们第一次获取Bean的的效率，但是它也降低了容器初始化的速度。（这个其实很好理解的，因为第一次获取Bean的时候，依赖注入已经完成了，直接拿过来用就行）</p>
<p>关于lazy-init属性的处理也是在wac.refresh这个方法中完成的，具体是在finishBeanFactoryInitialization方法中。如果继续追溯的话，最终是交给DefaultListableBeanFactory容器中的preInstantiateSingletons方法中完成。</p>
<p>lazy-init这种实例化方式就是通过将依赖注入委托给容器来处理，而不是在用户第一向容器申请的Bean的时候完成依赖注入，不同的阶段，也有不同的优劣。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/spring-series-inject-summary/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/spring-series-inject-props/">Spring源码系列：依赖注入（三）-属性注入</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T06:14:10.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/spring-series-inject-props/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>前面文章中对依赖注入的触发和bean的创建做了学习记录，本文将来记录一下bean的属性注入过程。Bean的属性注入发生在<code>BeanDefinitionValueResolver</code>这个类中，<code>BeanDefinitionValueResolver</code>这类是用于bean工厂实现的Helper类，职责就是将bean定义对象中包含的值解析为应用于目标bean实例的实际值。</p>
<p><code>BeanDefinitionValueResolver</code>类中的<code>resolveValueIfNecessary()</code>方法包含了对所有注入类型的处理。所以本文主要围绕这个方法展开来说。</p>
<h2 id="resolveValueIfNecessary方法"><a href="#resolveValueIfNecessary方法" class="headerlink" title="resolveValueIfNecessary方法"></a>resolveValueIfNecessary方法</h2><p><code>resolveValueIfNecessary()</code>:给定一个PropertyValue，返回一个value，解析对工厂中其他bean的引用。 value可能是：</p>
<ul>
<li>RuntimeBeanReference : 在解析到依赖的Bean的时侯，解析器会依据依赖bean的name创建一个RuntimeBeanReference对像，将这个对像放入BeanDefinition的MutablePropertyValues中。</li>
<li>ManagedList：用来保存它所管理的List元素，它可以包含运行时期的bean引用(将被解析为bean对象). </li>
<li>ManagedSet ：用来保存它所管理的set值，它可以包含运行时期的bean引用(将被解析为bean对象) </li>
<li>ManagedMap ：用来保存它所管理的map值，它可以包含运行时期的bean引用(将被解析为bean对象) </li>
</ul>
<p><strong>1、方法申明</strong></p>
<p>argName ：为其定义的参数的名称</p>
<p>value   ：要解析的值对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveValueIfNecessary</span><span class="params">(Object argName, Object value)</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>2、RuntimeBeanReference</strong></p>
<p>当在beanfactory中作为另外一个<strong>bean的引用时</strong>，作为属性值对象，将在运行时进行解析。 RuntimeBeanReference是在对BeanDefinition进行解析时生成的数据对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> RuntimeBeanReference) &#123;</span><br><span class="line">    RuntimeBeanReference ref = (RuntimeBeanReference) value;</span><br><span class="line">    <span class="keyword">return</span> resolveReference(argName, ref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3、RuntimeBeanNameReference</strong></p>
<p>当在beanfactory中作为另外一个<strong>bean名称的引用时</strong>，作为属性值对象，将在运行时进行解析。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> RuntimeBeanNameReference) &#123;</span><br><span class="line">    String refName = ((RuntimeBeanNameReference) value).getBeanName();</span><br><span class="line">    refName = String.valueOf(doEvaluate(refName));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.beanFactory.containsBean(refName)) &#123;</span><br><span class="line">        <span class="comment">//异常：Invalid bean name '" + refName + "' in bean reference for " + argName</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> refName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4、BeanDefinitionHolder</strong></p>
<p>解析BeanDefinitionHolder：包含具有名称和别名的BeanDefinition。BeanDefinitionHolder就是使用名称或者别名来保存BeanDefinition的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> BeanDefinitionHolder) &#123;</span><br><span class="line">    BeanDefinitionHolder bdHolder = (BeanDefinitionHolder) value;</span><br><span class="line">    <span class="keyword">return</span> resolveInnerBean(argName, bdHolder.getBeanName(), bdHolder.getBeanDefinition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>5、BeanDefinition</strong></p>
<p>解析纯粹的BeanDefinition<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> BeanDefinition) &#123;</span><br><span class="line">    <span class="comment">// Resolve plain BeanDefinition, without contained name: use dummy name.</span></span><br><span class="line">    BeanDefinition bd = (BeanDefinition) value;</span><br><span class="line">    String innerBeanName = <span class="string">"(inner bean)"</span> + BeanFactoryUtils.GENERATED_BEAN_NAME_SEPARATOR +</span><br><span class="line">    		ObjectUtils.getIdentityHexString(bd);</span><br><span class="line">    <span class="keyword">return</span> resolveInnerBean(argName, innerBeanName, bd);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>6、ManagedArray</strong></p>
<p>包含运行时期的bean引用(将被解析为bean对象)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedArray) &#123;</span><br><span class="line">    <span class="comment">// May need to resolve contained runtime references.</span></span><br><span class="line">    ManagedArray array = (ManagedArray) value;</span><br><span class="line">    Class&lt;?&gt; elementType = array.resolvedElementType;</span><br><span class="line">    <span class="keyword">if</span> (elementType == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	String elementTypeName = array.getElementTypeName();</span><br><span class="line">    	<span class="keyword">if</span> (StringUtils.hasText(elementTypeName)) &#123;</span><br><span class="line">        	<span class="keyword">try</span> &#123;</span><br><span class="line">        		elementType = ClassUtils.forName(elementTypeName,</span><br><span class="line">        		<span class="keyword">this</span>.beanFactory.getBeanClassLoader());</span><br><span class="line">        		array.resolvedElementType = elementType;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        		<span class="comment">// Improve the message by showing the context.</span></span><br><span class="line">        		<span class="comment">//异常：Error resolving array type for " + argName</span></span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">else</span> &#123;</span><br><span class="line">    		elementType = Object.class;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resolveManagedArray(argName, (List&lt;?&gt;) value, elementType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>7、ManagedList，ManagedSet，ManagedMap</strong></p>
<p>包含运行时期的bean引用(将被解析为bean对象)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对ManagedList进行解析</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedList) &#123;</span><br><span class="line">    <span class="keyword">return</span> resolveManagedList(argName, (List&lt;?&gt;) value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对ManagedSet进行解析</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedSet) &#123;</span><br><span class="line">    <span class="keyword">return</span> resolveManagedSet(argName, (Set&lt;?&gt;) value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对ManagedMap进行解析</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedMap) &#123;</span><br><span class="line">    <span class="keyword">return</span> resolveManagedMap(argName, (Map&lt;?, ?&gt;) value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>8、ManagedProperties</strong></p>
<p>ManagedProperties表示的是一个spring管理的属性实例，它支持父/子 definition的合并。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对ManagedProperties进行解析</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedProperties) &#123;</span><br><span class="line">    Properties original = (Properties) value;</span><br><span class="line">    Properties copy = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; propEntry : original.entrySet()) &#123;</span><br><span class="line">    	Object propKey = propEntry.getKey();</span><br><span class="line">    	Object propValue = propEntry.getValue();</span><br><span class="line">    	<span class="keyword">if</span> (propKey <span class="keyword">instanceof</span> TypedStringValue) &#123;</span><br><span class="line">    		propKey = evaluate((TypedStringValue) propKey);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span> (propValue <span class="keyword">instanceof</span> TypedStringValue) &#123;</span><br><span class="line">    		propValue = evaluate((TypedStringValue) propValue);</span><br><span class="line">    	&#125;</span><br><span class="line">    	copy.put(propKey, propValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>9、TypedStringValue</strong></p>
<p>TypedStringValue保存的是一个类型的属性值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对TypedStringValue进行解析</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> TypedStringValue) &#123;</span><br><span class="line">    <span class="comment">// Convert value to target type here.</span></span><br><span class="line">    TypedStringValue typedStringValue = (TypedStringValue) value;</span><br><span class="line">    Object valueObject = evaluate(typedStringValue);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	Class&lt;?&gt; resolvedTargetType = resolveTargetType(typedStringValue);</span><br><span class="line">    	<span class="keyword">if</span> (resolvedTargetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">this</span>.typeConverter.convertIfNecessary(valueObject, resolvedTargetType);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">else</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> valueObject;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    	<span class="comment">// Improve the message by showing the context.</span></span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">    	<span class="comment">//异常：Error converting typed String value for " + argName</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>10、作为表达式进行评估</strong></p>
<p>将给定的值作为表达式进行评估。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">    return evaluate(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在完成上述解析之后，已经为我们的依赖注入做好了准备。这是真正把Bean对象设置到它所依赖的另一个Bean的属性中去的地方，可以看到，处理的属性也是各式各样的。具体属性的注入是在之前提到的BeanWrapper接口的实现类BeanWrapperImpl的setPropertyValue方法来完成。</p>
<h2 id="setPropertyValue方法"><a href="#setPropertyValue方法" class="headerlink" title="setPropertyValue方法"></a>setPropertyValue方法</h2><h3 id="a、方法声明"><a href="#a、方法声明" class="headerlink" title="a、方法声明"></a>a、方法声明</h3><p>这个方法是私有的，是BeanWrapperImpl实际处理的方法，其对外也提供了setPropertyValue的其它重载方法来提供服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setPropertyValue</span><span class="params">(PropertyTokenHolder tokens, PropertyValue pv)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException</span></span><br></pre></td></tr></table></figure>
<h3 id="b、PropertyTokenHolder是BeanWrapperImpl的内部类"><a href="#b、PropertyTokenHolder是BeanWrapperImpl的内部类" class="headerlink" title="b、PropertyTokenHolder是BeanWrapperImpl的内部类"></a>b、PropertyTokenHolder是BeanWrapperImpl的内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static class PropertyTokenHolder &#123;</span><br><span class="line">    public String canonicalName;</span><br><span class="line">    public String actualName;</span><br><span class="line">    public String[] keys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在setPropertyValue方法中会根据tokens变量是否为null,有两个不同的分支。其中当tokens为null时，则会对属性名进行递归调用分析处理，返回分析处理后的BeanWrapImpl对象nestedBw。如果nestedBw==this,则会设置pv的resolvedTokens属性值，最后将调用nestedBw对象的设置属性值方法设置属性。来具体看看：</p>
<p><hr></p>
<h3 id="c、其中当tokens为null时，即对集合类的域进行注入"><a href="#c、其中当tokens为null时，即对集合类的域进行注入" class="headerlink" title="c、其中当tokens为null时，即对集合类的域进行注入"></a>c、其中当tokens为null时，即对集合类的域进行注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置tokens的索引和keys</span></span><br><span class="line">PropertyTokenHolder getterTokens = <span class="keyword">new</span> PropertyTokenHolder();</span><br><span class="line">getterTokens.canonicalName = tokens.canonicalName;</span><br><span class="line">getterTokens.actualName = tokens.actualName;</span><br><span class="line">getterTokens.keys = <span class="keyword">new</span> String[tokens.keys.length - <span class="number">1</span>];</span><br><span class="line">System.arraycopy(tokens.keys, <span class="number">0</span>, getterTokens.keys, <span class="number">0</span>, tokens.keys.length - <span class="number">1</span>);</span><br><span class="line">Object propValue;</span><br><span class="line"><span class="comment">//getPropertyValue用来获取Bean中对对象注入的引用；</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	propValue = getPropertyValue(getterTokens);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NotReadablePropertyException ex) &#123;</span><br><span class="line"><span class="comment">//异常：Cannot access indexed value in property referenced </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1、propValue为null</strong></p>
<p>propValue为null<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (propValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 空值映射的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.autoGrowNestedPaths) &#123;</span><br><span class="line">    	<span class="comment">// <span class="doctag">TODO:</span> cleanup, this is pretty hacky</span></span><br><span class="line">    	<span class="keyword">int</span> lastKeyIndex = tokens.canonicalName.lastIndexOf(<span class="string">'['</span>);</span><br><span class="line">    	getterTokens.canonicalName = tokens.canonicalName.substring(<span class="number">0</span>, lastKeyIndex);</span><br><span class="line">    	propValue = setDefaultValue(getterTokens);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//异常：Cannot access indexed value in property referenced " +</span></span><br><span class="line">	<span class="string">"in indexed property path '"</span> + propertyName + <span class="string">"': returned null"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2、对array进行注入</strong></p>
<p>对array进行注入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (propValue.getClass().isArray()) &#123;</span><br><span class="line">    PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);</span><br><span class="line">    Class requiredType = propValue.getClass().getComponentType();</span><br><span class="line">    <span class="keyword">int</span> arrayIndex = Integer.parseInt(key);</span><br><span class="line">    Object oldValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span> (isExtractOldValueForEditor() &amp;&amp; arrayIndex &lt; Array.getLength(propValue)) &#123;</span><br><span class="line">    		oldValue = Array.get(propValue, arrayIndex);</span><br><span class="line">    	&#125;</span><br><span class="line">    	Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),</span><br><span class="line">    			requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));</span><br><span class="line">    	Array.set(propValue, arrayIndex, convertedValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">    <span class="comment">//异常：Invalid array index in property path '" + propertyName</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2、对list进行注入</strong></p>
<p>对list进行注入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (propValue <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">    PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);</span><br><span class="line">    Class requiredType = GenericCollectionTypeResolver.getCollectionReturnType(</span><br><span class="line">    		pd.getReadMethod(), tokens.keys.length);</span><br><span class="line">    List list = (List) propValue;</span><br><span class="line">    <span class="keyword">int</span> index = Integer.parseInt(key);</span><br><span class="line">    Object oldValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isExtractOldValueForEditor() &amp;&amp; index &lt; list.size()) &#123;</span><br><span class="line">    	oldValue = list.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">    Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),</span><br><span class="line">    		requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));</span><br><span class="line">    <span class="keyword">int</span> size = list.size();</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size &amp;&amp; index &lt; <span class="keyword">this</span>.autoGrowCollectionLimit) &#123;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &lt; index; i++) &#123;</span><br><span class="line">    		<span class="keyword">try</span> &#123;</span><br><span class="line">    			list.add(<span class="keyword">null</span>);</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">catch</span> (NullPointerException ex) &#123;</span><br><span class="line">    		    <span class="comment">//异常：InvalidPropertyException</span></span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	list.add(convertedValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">    		list.set(index, convertedValue);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">    		<span class="comment">//异常：Invalid list index in property path '" + propertyName + "'"</span></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2、对map进行注入</strong></p>
<p>对map进行注入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (propValue <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">    PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);</span><br><span class="line">    Class mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(</span><br><span class="line">    		pd.getReadMethod(), tokens.keys.length);</span><br><span class="line">    Class mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(</span><br><span class="line">    		pd.getReadMethod(), tokens.keys.length);</span><br><span class="line">    Map map = (Map) propValue;</span><br><span class="line">    <span class="comment">//重要提示：不要在这里传递完整的属性名称</span></span><br><span class="line">    TypeDescriptor typeDescriptor = (mapKeyType != <span class="keyword">null</span> ?</span><br><span class="line">    		TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));</span><br><span class="line">    Object convertedMapKey = convertIfNecessary(<span class="keyword">null</span>, <span class="keyword">null</span>, key, mapKeyType, typeDescriptor);</span><br><span class="line">    Object oldValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isExtractOldValueForEditor()) &#123;</span><br><span class="line">    	oldValue = map.get(convertedMapKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在这里传递完整的属性名称和旧值，因为希望对map值有完整的转换能力。</span></span><br><span class="line">    Object convertedMapValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),</span><br><span class="line">    		mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));</span><br><span class="line">    map.put(convertedMapKey, convertedMapValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="其中当tokens不为null时，即对非集合类的域进行注入"><a href="#其中当tokens不为null时，即对非集合类的域进行注入" class="headerlink" title="其中当tokens不为null时，即对非集合类的域进行注入"></a>其中当tokens不为null时，即对非集合类的域进行注入</h3><p>这里是核心的地方，取得注入属性的set方法，通过反射机制，把对象注入进去。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Method writeMethod = (pd <span class="keyword">instanceof</span> GenericTypeAwarePropertyDescriptor ?</span><br><span class="line">    ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :</span><br><span class="line">    pd.getWriteMethod());</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的几篇分析我们大概的熟悉了Bean创建和对象依赖注入的一个过程，在这个过程中，spring需要根据Beandefinition中的信息来递归完成依赖注入。并且这些递归的入口都是getBean这个方法。</p>
<p>一个递归是在上下文体系中查找需要的Bean和创建Bean的递归调用；</p>
<p>另一个递归是在依赖注入时通过递归调用容器的getBean方法，得到当前Bean的依赖Bean，同时也触发对依赖Bean的创建和注入。</p>
<p>在对Bean的属性进行依赖注入时解析的过程也是一个递归的过程。这样就可以根据依赖关系，一层一层的完成Bean的创建和注入，直到最后完成当前Bean的创建。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p>《Spring技术内幕》</p>
</li>
<li><p><a href="https://www.cnblogs.com/davidwang456/p/4213652.html" target="_blank" rel="noopener">https://www.cnblogs.com/davidwang456/p/4213652.html</a></p>
</li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/spring-series-inject-props/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/spring-series-createbean/">Spring源码系列：依赖注入（二）createBean</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T06:13:30.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/spring-series-createbean/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>在<a href="https://juejin.im/post/5a7532746fb9a0633a70d57f" target="_blank" rel="noopener">Spring源码系列：依赖注入（一）（AbstractBeanFactory-getBean）</a>最后说道getBean是依赖注入的起点，bean的创建都是通过createBean来完成具体的创建的。createBean的具体实现是在AbstractAutowireCapableBeanFactory中的。本篇就捋一捋这个方法看下bean的创建过程。</p>
<p>这个方法是AbstractAutowireCapableBeanFactory这个类的中心方法，其作用就是创建一个bean实例，填充bean实例，后置处理等。</p>
<p>在createBean中主要做了三件事：</p>
<ul>
<li>判断需要创建的Bean是否可以实例化，这个类是否可以通过类装载器来载入</li>
<li>是否配置了后置处理器相关处理（如果配置了则返回一个代理）</li>
<li>创建Bean</li>
</ul>
<p>具体来看方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	RootBeanDefinition mbdToUse = mbd;</span><br><span class="line">	<span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line">	<span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line">	<span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line">	<span class="comment">//判断需要创建的Bean是否可以实例化，这个类是否可以通过类装载器来载入</span></span><br><span class="line">	Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">	<span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">		mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prepare method overrides.</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		mbdToUse.prepareMethodOverrides();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">		<span class="comment">//异常：Validation of method overrides failed</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target </span></span><br><span class="line">		<span class="comment">//bean instance.</span></span><br><span class="line">		<span class="comment">//是否配置了后置处理器相关处理（如果配置了则返回一个代理）</span></span><br><span class="line">		Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">		<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">	    <span class="comment">//异常:BeanPostProcessor before instantiation of bean failed</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//创建Bean</span></span><br><span class="line">	Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中可以看到，创建bean是交给doCreateBean方法来创建的。继续看doCreateBean这个方法：<br>（这里面涉及到一个BeanWrapper这个接口，小伙伴可以移步了解一下《<a href="https://juejin.im/post/5a77f3eb6fb9a06361085451" target="_blank" rel="noopener">Spring源码系列：BeanWrapper</a>》）</p>
<p><strong>代码 1：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用BeanWrapper来持有创建出来的Bean对象</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//如果是单例的话，则先把缓存中的同名bean清除</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">	instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际创建的交给createBeanInstance来完成，</span></span><br><span class="line"><span class="comment">//bean的生成，这里会使用默认的类生成器，包装成BeanWrapperImpl类，</span></span><br><span class="line"><span class="comment">//为了下面的populateBean方法的属性注入做准备  </span></span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">	instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line">Class&lt;?&gt; beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br></pre></td></tr></table></figure></p>
<p><strong>代码 2：</strong> </p>
<p>允许后处理器修改合并的bean定义。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">    		applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    	<span class="comment">//异常：Post-processing of merged bean definition failed</span></span><br><span class="line">    	&#125;</span><br><span class="line">    	mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>代码 3 ：</strong></p>
<p>即使被BeanFactoryAware等生命周期接口触发，也要尽快地缓存singletons 以便能够解析循环引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">		isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">if (earlySingletonExposure) &#123;</span><br><span class="line">	if (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(&quot;Eagerly caching bean &apos;&quot; + beanName +</span><br><span class="line">				&quot;&apos; to allow for resolving potential circular references&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">		@Override</span><br><span class="line">		public Object getObject() throws BeansException &#123;</span><br><span class="line">			return getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>代码 4:</strong></p>
<p>这里是对bean的初始化的地方，一般情况下依赖注入就在这里发生；这个exposedObject变量保存的是在初始化处理完以后返回的作为依赖注入完成之后的bean。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">	<span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">		exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">//抛出</span></span><br><span class="line">	<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException)</span><br><span class="line">	    ex).getBeanName())) &#123;</span><br><span class="line">		<span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//异常:Initialization of bean failed</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>代码 5:</strong></p>
<p>这里是注册bean<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">	registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line">catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">    //异常处理</span><br><span class="line">&#125;</span><br><span class="line">//返回结果</span><br><span class="line">return exposedObject;</span><br></pre></td></tr></table></figure></p>
<p>上面的5个代码段均是doCreateBean中的处理逻辑，有兴趣的小伙伴可以自行查阅源码。从上面的代码中我们依然没有得到具体创建的过程，因为在doCreateBean中又依赖：<code>createBeanInstance</code>和<code>populateBean</code>两个方法。</p>
<p>在<code>createBeanInstance</code>中生成了Bean所包含的java对象。来看是怎么生成的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 确保bean类实际上已经解析过了，可以实例化</span></span><br><span class="line">	Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">		<span class="comment">//异常：Bean class isn't public, and non-public access not allowed:beanName</span></span><br><span class="line">	&#125;</span><br><span class="line">     <span class="comment">//1. 使用工厂方法来进行bean的实例化</span></span><br><span class="line">	<span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>)  &#123;</span><br><span class="line">		<span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新创建相同的bean时快捷方式...</span></span><br><span class="line">	<span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">				resolved = <span class="keyword">true</span>;</span><br><span class="line">				autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">		<span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">			<span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.需要确定构造函数...,使用构造函数进行bean实例化</span></span><br><span class="line">	Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">	<span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">			mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">			mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">		<span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.没有特殊的处理：只需使用无参数构造函数。（默认构造函数）</span></span><br><span class="line">	<span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面这段代码可以看出，对象的生成有许多不同的方式，有通过工厂的，也有通过容器的autowire特性生成的。当然这些生成方式都是由相关的BeanDefinition来指定的。</p>
<p><strong>Spring中配置Bean的方式我们常用的一种是通过xml文件来配置，还有就是通过注解的方式来配置</strong>。</p>
<ul>
<li><strong>demo1</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.glmapper.test.User"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"glmapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>       </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种方式，通过class提供的权限定名，spring就可以利用反射机制创建这个bean。</p>
<ul>
<li><strong>demo2</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.glmapper.test.UserFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getUser"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"glmapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>           </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种是利用静态工厂方法来创建的，提供的class并非是类的权限定名， 而是静态工厂的全类名；除此之外还需要指定获取bean的方法（此处是getUser）和参数（参数是glmapper）。</p>
<ul>
<li><strong>demo3</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userFactory&quot; class=&quot;com.glmapper.test.UserInstanceFactory&quot;&gt;</span><br><span class="line">    &lt;!--用一个集合来保存我当前的对象实例--&gt;</span><br><span class="line">    &lt;property name=&quot;map&quot;&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=&quot;user1&quot;&gt;</span><br><span class="line">                &lt;bean class=&quot;com.glmapper.test.User&quot;&gt;</span><br><span class="line">                    &lt;property name=&quot;name&quot; value=&quot;glmapper1&quot;&gt;&lt;/property&gt;        </span><br><span class="line">                &lt;/bean&gt;</span><br><span class="line">            &lt;/entry&gt;    </span><br><span class="line"></span><br><span class="line">            &lt;entry key=&quot;user2&quot;&gt;</span><br><span class="line">                &lt;bean class=&quot;com.glmapper.test.User&quot;&gt;</span><br><span class="line">                    &lt;property name=&quot;name&quot; value=&quot;glmapper2&quot;&gt;&lt;/property&gt;   </span><br><span class="line">                &lt;/bean&gt;</span><br><span class="line">            &lt;/entry&gt;</span><br><span class="line">        &lt;/map&gt;  </span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"> &lt;/bean&gt;</span><br><span class="line"> </span><br><span class="line"> //实例1</span><br><span class="line"> &lt;bean id=&quot;user1&quot; factory-bean=&quot;userFactory&quot; factory-method=&quot;getUserInstance&quot;&gt;</span><br><span class="line">    &lt;constructor-arg value=&quot;user1&quot;&gt;&lt;/constructor-arg&gt;           </span><br><span class="line"> &lt;/bean&gt;</span><br><span class="line">//实例2</span><br><span class="line"> &lt;bean id=&quot;user2&quot; factory-bean=&quot;userFactory&quot; factory-method=&quot;getUserInstance&quot;&gt;</span><br><span class="line">    &lt;constructor-arg value=&quot;user2&quot;&gt;&lt;/constructor-arg&gt;           </span><br><span class="line"> &lt;/bean</span><br></pre></td></tr></table></figure>
<p>这种方式和静态工厂的区别在于我们需要先实例化一个工厂对象，然后才能使用这个工厂对象来创建我们的bean。getUserInstance通过key值来获取我们已经实例化好的对象（当然方式有很多，此处以map来举个例子）。<code>关于注解的和使用FactoryBean接口的这里就暂时不说，后期再聊</code></p>
<p>OK，继续来分钟，上面说到的是以工厂方法创建bean，具体的源码有点长，这里就不放了，大概思路就如上面所提到的那几种方式。接下来看下常见的使用instantiateBean方式（使用它的默认构造函数）来构建bean的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Object beanInstance;</span><br><span class="line">		<span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;</span><br><span class="line">	    <span class="comment">//获取系统安全接口。</span></span><br><span class="line">	    <span class="comment">//如果已经为当前应用程序建立了安全管理器，则返回该安全管理器; </span></span><br><span class="line">	    <span class="comment">//否则，返回null。</span></span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			beanInstance = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="keyword">return</span> getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">		&#125;</span><br><span class="line">		BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">		initBeanWrapper(bw);</span><br><span class="line">		<span class="keyword">return</span> bw;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="comment">//异常：Instantiation of bean failed</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，上面的创建都是通过：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br></pre></td></tr></table></figure>
<p>这样一段代码来完成的，是的，这里已经快接近真相了。从语义上来分析，先是获取了一种策略，然后利用当前获取的策略再去执行实例化。OK，我们看下getInstantiationStrategy()拿到的是什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回实例化策略用于创建bean实例。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> InstantiationStrategy <span class="title">getInstantiationStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.instantiationStrategy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认的实例化测试是使用CGLIB代理</span></span><br><span class="line"><span class="keyword">private</span> InstantiationStrategy instantiationStrategy = <span class="keyword">new</span> CglibSubclassingInstantiationStrategy();</span><br></pre></td></tr></table></figure>
<p>看到这里我们清楚了，默认构造函数的情况下，在spring中会使用Cglib来进行bean的实例化（关于cglib此处不再赘述）。我们看下CglibSubclassingInstantiationStrategy这个类的申明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibSubclassingInstantiationStrategy</span> <span class="keyword">extends</span> <span class="title">SimpleInstantiationStrategy</span></span></span><br></pre></td></tr></table></figure>
<p>它继承自SimpleInstantiationStrategy ，这个又是什么鬼呢？</p>
<p><code>SimpleInstantiationStrategy是Spring用来生成Bean对象的默认类，在这个类中提供了两种实例化java对象的方法，一种是基于java自身反射机制的BeanUtils，还有一种就是基于Cglib</code>。</p>
<p>如何创建的就不说了；到这里createBeanInstance就说完了（Bean已经创建了）；但是仅仅是创建，spring还没有处理它们，比如说bean对象的属性，依赖关系等等。这些就是上面提到的另外一个方法populateBean；</p>
<p>这个方法其实就做了一件事：<strong>使用bean定义中的属性值在给定的BeanWrapper中填充bean实例。</strong>分段来看：<br>下面这段代码是先将BeanDefinition中设置的property值封装成PropertyValues，然后检测我们的BeanWrapper是否为Null，如果为null则抛出异常或者跳过当前空实例赋值阶段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取到BeanDefinition中设置的property值，封装成PropertyValues</span></span><br><span class="line">PropertyValues pvs = mbd.getPropertyValues();</span><br><span class="line"><span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">	<span class="comment">//异常：Cannot apply property values to null instance</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面这段代码的意思是给任何InstantiationAwareBeanPostProcessors提供在设置属性之前修改bean状态的机会。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">    		InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">    		<span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">    			continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line">    			<span class="keyword">break</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面就是对具体注入方式的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理autowire的注入；可以根据bean的名称和类型来注入</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">	mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">    MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 则根据名称添加基于自动装配的属性值。</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">    	autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据类型添加基于自动装配的属性值。</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">    	autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pvs = newPvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个判断条件，在满足的情况下做的处理分别是：</p>
<ul>
<li>在工厂将给定属性值应用到给定的bean后，对其进行后处理。 允许检查所有的依赖关系是否被满足，例如基于bean属性设置器上的“Required”注解。还允许替换要应用的属性值，通常通过创建基于原始PropertyValues的新MutablePropertyValues实例，添加或删除特定值。</li>
<li>执行依赖性检查    </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回这个工厂是否拥有一个InstantiationAwareBeanPostProcessor</span></span><br><span class="line"><span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line"><span class="comment">//返回依赖检查代码。</span></span><br><span class="line"><span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line"><span class="comment">//从给定的BeanWrapper中提取一组已过滤的PropertyDescriptors，</span></span><br><span class="line"><span class="comment">//不包括在被忽略的依赖性接口上定义的被忽略的依赖类型或属性（译注）。</span></span><br><span class="line">	PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">	<span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">    	<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">        		InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">        		pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">        		<span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        			<span class="keyword">return</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">		checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是对属性进行注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applyPropertyValues(beanName, mbd, bw, pvs);</span><br></pre></td></tr></table></figure>
<p>这个方法描述的是对属性进行解析然后注入的过程；先来分析下applyPropertyValues的申明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(String beanName</span></span></span><br><span class="line"><span class="function"><span class="params">, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span></span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>beanName bean名称</li>
<li>mbd 合并的bean definition</li>
<li>bw 包装目标对象的BeanWrapper</li>
<li>pvs 新的属性值</li>
</ul>
<p>代码分段来看：</p>
<ul>
<li><p>参数验证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pvs == <span class="keyword">null</span> || pvs.isEmpty()) &#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>pvs参数处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">    mpvs = (MutablePropertyValues) pvs;</span><br><span class="line">    <span class="keyword">if</span> (mpvs.isConverted()) &#123;</span><br><span class="line">    	<span class="comment">// 使用预先转换后的值。</span></span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">    		bw.setPropertyValues(mpvs);</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">    		<span class="comment">//异常：Error setting property values</span></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    original = mpvs.getPropertyValueList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>valueResolver来解析BeanDefinition</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionValueResolver valueResolver = </span><br><span class="line"><span class="keyword">new</span> BeanDefinitionValueResolver(<span class="keyword">this</span>, beanName, mbd, converter);</span><br></pre></td></tr></table></figure>
</li>
<li><p>为解析值创建一个副本，注入到bean中的是副本的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a deep copy, resolving any references for values.</span></span><br><span class="line">List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> ArrayList&lt;PropertyValue&gt;(original.size());</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> resolveNecessary = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line">    <span class="comment">//返回此持有者是否已经包含转换后的值（true），还是需要转换值（false）。</span></span><br><span class="line">    <span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">    	deepCopy.add(pv);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    	String propertyName = pv.getName();</span><br><span class="line">    	Object originalValue = pv.getValue();</span><br><span class="line">    	<span class="comment">//看下面的注释resolveValueIfNecessary</span></span><br><span class="line">    	Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">    	Object convertedValue = resolvedValue;</span><br><span class="line">    	<span class="keyword">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">    			!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line">    	<span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">    		convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 可能将转换的值存储在合并的bean定义中，以避免为每个创建的bean实例重新转换。</span></span><br><span class="line">    	<span class="keyword">if</span> (resolvedValue == originalValue) &#123;</span><br><span class="line">    		<span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">    			pv.setConvertedValue(convertedValue);</span><br><span class="line">    		&#125;</span><br><span class="line">    		deepCopy.add(pv);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue &amp;&amp;</span><br><span class="line">    			!((TypedStringValue) originalValue).isDynamic() &amp;&amp;</span><br><span class="line">    			!(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;</span><br><span class="line">    		pv.setConvertedValue(convertedValue);</span><br><span class="line">    		deepCopy.add(pv);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">else</span> &#123;</span><br><span class="line">    		resolveNecessary = <span class="keyword">true</span>;</span><br><span class="line">    		deepCopy.add(<span class="keyword">new</span> PropertyValue(pv, convertedValue));</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>resolveValueIfNecessary</p>
<p>  给定一个PropertyValue，返回一个value，必要时解析对工厂中其他bean的引用。value可以是：</p>
<ul>
<li>一个BeanDefinition，它导致创建一个相应的新的bean实例。 Singleton标志和这样的”inner beans”的名字被忽略：内部beans是匿名原型。</li>
<li>RuntimeBeanReference(必须解析)</li>
<li>ManagedList</li>
<li>ManagedSet</li>
<li>ManagedMap</li>
<li>一个普通的对象或null，在这种情况下，它是孤立的。</li>
</ul>
</li>
</ul>
<p>下面这段代码时依赖注入发生的地方，其实际上是在BeanWrapperImpl中来完成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    bw.setPropertyValues(<span class="keyword">new</span> MutablePropertyValues(deepCopy));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">    <span class="comment">//异常：Error setting property values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面说到spring是通过BeanDefinitionValueResolver来解析BeanDefinition的，然后再注入到property中，关于这个过程在下一篇中来说。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/spring-series-createbean/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
    </div>
    
      <div id="page-nav" class="pagination">
	<span class="page-number current">1</span><a class="page-number" href="/categories/spring/page/2/">2</a><a class="page-number" href="/categories/spring/page/3/">3</a><a class="extend next" rel="next" href="/categories/spring/page/2/">Next</a>
      </div>
    
  </section>

</div>

</div>

</section>
</div>

    <!-- BEGIN PRE-FOOTER -->
    <div class="pre-footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN BOTTOM ABOUT BLOCK -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>About Us</h2>
            <p>Computer Lab is a software development and marketing company based in Brooklyn, New York. <br><br> Computer Lab was founded in 2015, and is focused on so on and so forth.</p>
          </div>
          <!-- END BOTTOM ABOUT BLOCK -->

          <!-- BEGIN BOTTOM CONTACTS -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>Contact</h2>
            <address class="margin-bottom-40">
              140 Metropolitan Avenue<br>
              5th Floor<br>
              Brooklyn, NY 11249<br>
              Phone: 716-472-4484<br>
              Email: <a href="mailto:ptsteadman@gmail.com">ptsteadman@gmail.com</a><br>
            </address>
          </div>
          <!-- END BOTTOM CONTACTS -->

	
          <!-- BEGIN TWITTER BLOCK --> 
          <div class="col-md-4 col-sm-6 pre-footer-col">

	  <a data-tweet-limit="1" class="twitter-timeline" href="https://twitter.com/computerlab_" data-widget-id="678830341331820544">Tweets by @computerlab_</a>

	  <script>!function(d,s,id){var
	  js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

          </div>
          <!-- END TWITTER BLOCK -->
	
        </div>
      </div>
    </div>
    <!-- END PRE-FOOTER -->

    <!-- BEGIN FOOTER -->
    <div class="footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN COPYRIGHT -->
          <div class="col-md-6 col-sm-6 padding-top-10">
                  &copy; 2020 glmapper<br>
 <a href="javascript:;">Privacy Policy</a> | <a href="javascript:;">Terms of Service</a>
          </div>
          <!-- END COPYRIGHT -->
	  <!-- BEGIN SOCIAL -->
<div class="col-md-6 col-sm-6">
  <ul class="social-footer list-unstyled list-inline pull-right">
    
      <li><a href="https://github.com/ptsteadman"><i class="fa fa-github"></i></a></li>
    
      <li><a href="https://twitter.com/ptsteadman"><i class="fa fa-twitter"></i></a></li>
    
      <li><a href="https://www.facebook.com/ptsteadman"><i class="fa fa-facebook"></i></a></li>
    
      <li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li>
    
      <li><a href="https://linkedin.com/in/ptsteadman"><i class="fa fa-linkedin"></i></a></li>
    
      <li><a href="http://stackoverflow.com/users/2480493/patrick-steadman"><i class="fa fa-stackoverflow"></i></a></li>
    
  </ul>  
</div>
<!-- END SOCIAL -->

        </div>
      </div>
    </div>
    <!-- END FOOTER -->

  <!-- BEGIN CORE PLUGINS (REQUIRED FOR ALL PAGES) -->
<!--[if lt IE 9]>
<script src="/metronic/assets/plugins/respond.min.js"></script>
<![endif]--> 
<script src="/metronic/assets/plugins/jquery.min.js"></script>
<script src="/metronic/assets/plugins/jquery-migrate.min.js"></script>
<script src="/metronic/assets/plugins/bootstrap/js/bootstrap.min.js"></script>
<script src="/metronic/assets/corporate/scripts/back-to-top.js"></script>
<script src="/metronic/assets/plugins/owl.carousel/owl.carousel.min.js"></script>
<script src="/metronic/assets/corporate/scripts/layout.js"></script>
<script src="/js/wow.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script type="text/javascript">
    jQuery(document).ready(function() {
        Layout.init();    
        Layout.initOWL();
        Layout.initTwitter();
        Layout.initFixHeaderWithPreHeader(); /* Switch On Header Fixing (only if you have pre-header) */
        Layout.initNavScrolling(); 
	new WOW().init();
    });
</script>
<!-- END CORE PLUGINS -->

<!-- BEGIN PAGE-SPECIFIC PLUGINS --> 







<!-- END PAGE-SPECIFIC PLUGINS --> 

<!-- BEGIN INTEGRATIONS -->





<!-- END INTEGRATIONS -->

</body>
</html>
