<!DOCTYPE html>
<!--[if IE 8]> <html lang="en" class="ie8 no-js"> <![endif]-->
<!--[if IE 9]> <html lang="en" class="ie9 no-js"> <![endif]-->
<!--[if !IE]><!-->
<html lang="en">
<!--<![endif]-->
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Category: spring mvc | glmapper</title>

  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <meta name="description" content="从平凡的世界中全身而退">
<meta property="og:type" content="website">
<meta property="og:title" content="glmapper">
<meta property="og:url" content="http://www.glmapper.com/categories/spring-mvc/index.html">
<meta property="og:site_name" content="glmapper">
<meta property="og:description" content="从平凡的世界中全身而退">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="glmapper">
<meta name="twitter:description" content="从平凡的世界中全身而退">
  
    <link rel="alternative" href="/atom.xml" title="glmapper" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
    
  <meta content="{{ title }}" name="description">
  <meta content="{{ title }}" name="keywords">
  <meta content="{{ title }}" name="author">

  <link href="http://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700|PT+Sans+Narrow|Source+Sans+Pro:200,300,400,600,700,900&amp;subset=all" rel="stylesheet" type="text/css">

  <!-- Global styles START -->   
  <link rel="stylesheet" href="/metronic/assets/plugins/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/bootstrap/css/bootstrap.min.css">
  <!-- Global styles END --> 
   
  <!-- Page level plugin styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/animate.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/owl.carousel/assets/owl.carousel.css">
  <!-- Page level plugin styles END -->

  <!-- Theme styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/components.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/slider.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/portfolio.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style-responsive.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/themes/red.css">
  <link rel="stylesheet" href="/css/theme-styles.css">
  <!-- Theme styles END -->
</head>
</html>
<body class="corporate">
  <!-- BEGIN TOP BAR -->
<div class="pre-header">
  <div class="container">
    <div class="row">
      <!-- BEGIN TOP BAR LEFT PART -->
      <div class="col-md-6 col-sm-6 col-xs-9 additional-shop-info">
	<ul class="list-unstyled list-inline">
	  <li><i class="fa fa-phone"></i><span>716-472-4484</span></li>
	  <li><i class="fa fa-envelope-o"></i><span>ptsteadman@gmail.com</span></li>
	</ul>
      </div>
      <!-- END TOP BAR LEFT PART -->
      <!-- BEGIN TOP BAR MENU -->
      <div class="col-md-6 col-sm-6 col-xs-3 additional-nav">
	<ul class="list-unstyled list-inline pull-right">
	  <li><a href="/login">Log In</a></li>
	</ul>
      </div>
      <!-- END TOP BAR MENU -->
    </div>
  </div>        
</div>
<!-- END TOP BAR -->
<!-- BEGIN HEADER -->
<div class="header">
  <div class="container">
    <!--<a class="site-logo" href="/" id="logo">glmapper</a>-->

    <a class="site-logo" href="/">
      <img src="/metronic/assets/corporate/img/logos/logo-corp-red.png" alt="Metronic FrontEnd">
    </a>

    <a href="javascript:void(0);" class="mobi-toggler"><i class="fa fa-bars"></i></a>

    <!-- BEGIN NAVIGATION -->
    <div class="header-navigation pull-right font-transform-inherit">
      <ul>
	
	<li class="">
	  <a href="/">Home</a>
	</li>
	
	<li class="">
	  <a href="/projects/">Projects</a>
	</li>
	
	<li class="">
	  <a href="/archives/">Blog</a>
	</li>
	
	<li class="">
	  <a href="/contact/">Contact</a>
	</li>
	
	<li class="">
	  <a href="/about/">About</a>
	</li>
	
	<!-- BEGIN TOP SEARCH -->
	<li class="menu-search">
	  <span class="sep"></span>
	  <i class="fa fa-search search-btn"></i>
	  <div class="search-box">
	    <form action="#">
	      <div class="input-group">
		<input type="text" placeholder="Search" class="form-control st-default-search-input">
		<span class="input-group-btn">
		  <button class="btn btn-primary" type="submit">Search</button>
		</span>
	      </div>
	    </form>
	  </div> 
	</li>
	<!-- END TOP SEARCH -->
      </ul>
    </div>
    <!-- END NAVIGATION -->
  </div>
</div>
<!-- Header END -->

  <div class="container">
  <ul class="breadcrumb">
    <li><a href="/">Home</a></li>
    <li><a href="/blog">Blog</a></li>
    <li class="active">spring mvc</li>
  </ul>
<section id="main">
 <h1>spring mvc</h1>
 <div class="row">

<div class="col-xs-12 blog-posts">


  <section class="archives-wrap">
    <div class="archives">
      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/spring-base-webmvc5/">SpringMVC源码系列：九大组件小记</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T06:21:07.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/spring-base-webmvc5/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/web/" title="web">web</a>,
  
    <a href="/tags/mvc/" title="mvc">mvc</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>前面几篇文章都是针对于SpringMVC中的具体组件进行源码分析的；本文主要用于补充记录一下关于SpringMVC中九大组件的学习。这个会牵扯出除之前的几篇<code>HandlerMapping</code>之外的其他一些基础组件。</p>
<p>之前简单的有介绍过<code>DispatcherServlet</code>这个类的体系结构，此处就不再赘述了。在<code>DispatcherServlet</code>类中，其在mvc子容器进行初始化时就会完成对九大组件的初始化工作，具体哪九大组件后面会慢慢说到。先来看下在<code>DispatcherServlet</code>中是通过哪些方法来完成初始化工作的,先贴一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.initMultipartResolver(context);</span><br><span class="line">    <span class="keyword">this</span>.initLocaleResolver(context);</span><br><span class="line">    <span class="keyword">this</span>.initThemeResolver(context);</span><br><span class="line">    <span class="keyword">this</span>.initHandlerMappings(context);</span><br><span class="line">    <span class="keyword">this</span>.initHandlerAdapters(context);</span><br><span class="line">    <span class="keyword">this</span>.initHandlerExceptionResolvers(context);</span><br><span class="line">    <span class="keyword">this</span>.initRequestToViewNameTranslator(context);</span><br><span class="line">    <span class="keyword">this</span>.initViewResolvers(context);</span><br><span class="line">    <span class="keyword">this</span>.initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中的<code>onRefresh</code>方法就是<code>DispatcherServlet</code>的入口方法。在<code>onRefresh</code>中又通过调用<code>initStrategies</code>方法来将各个组件的初始化逻辑进行整合，个人理解其实就是策略套策略，在一个就是职责也明确。</p>
<p>在<code>initStrategies</code>方法中又通过调用组件各自的初始化方法来完成具体的初始化工作。从这个地方其实就可以清楚的看出SpringMVC中的9个组件名称了。下面就来捋一捋这九大组件的基本职责。</p>
<h2 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h2><p>关于handlermapping在下面几篇文章中做过一些基本介绍，但是还不是很全，对于handlermapping的子类还没有分析完，这个会后期更新的。</p>
<ul>
<li><a href="https://juejin.im/post/5a5700705188257323350f42" target="_blank" rel="noopener">SpringMVC源码系列：HandlerMapping</a></li>
<li><a href="https://juejin.im/post/5a5700db6fb9a01cbf38427a" target="_blank" rel="noopener">SpringMVC源码系列：AbstractHandlerMapping</a></li>
<li><a href="https://juejin.im/post/5a8e2c486fb9a06357750b12" target="_blank" rel="noopener">SpringMVC源码系列：AbstractUrlHandlerMapping</a></li>
</ul>
<p>对于<code>HandlerMapping</code>来说，其作用就是根据<code>request</code>找到相应的处理器<code>Handler</code>和<code>Intecepter</code>拦截器。具体细节参数上面第一篇文章。</p>
<h2 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h2><p>如果说<code>HandlerMapping</code>是一支笔，那么<code>HandlerAdapter</code>就是用笔的人。也就是说<code>HandlerAdapter</code>就是使用处理器干活的人。为什么呢？来看下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">    <span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, Object var3)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest var1, Object var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是一目了然了，在<code>HandlerAdapter</code>接口中提供了<code>handle</code>这样一个方法，参数中Object handler第三个参数其实就是一个处理器，那我们就知道了，<code>handle</code>方法就是使用<code>handler</code>来处理逻辑的。处理之后返回一个<code>ModelAndView</code>。</p>
<h2 id="HandlerExceptionResolver"><a href="#HandlerExceptionResolver" class="headerlink" title="HandlerExceptionResolver"></a>HandlerExceptionResolver</h2><p>这个是<code>SpringMVC</code>中的异常处理组件，<code>HandlerExceptionResolver</code>这个组件的作用就是根据异常设置<code>ModelAndView</code>，然后再将处理结果交给<code>render</code>方法进行渲染。当然<code>render</code>也仅仅只是负责将<code>ModelAndView</code>渲染成页面，<code>ModelAndView</code>的具体来源它不关心。</p>
<p>这里需要说明一下，加入在渲染过程中发生异常怎么办？从上面的分析我们可以清楚的知道，<code>HandlerExceptionResolver</code>这个组件对异常的处理结果是<code>ModelAndView</code>，然后再由<code>render</code>方法进行渲染，也就是说<code>HandlerExceptionResolver</code>是在渲染之前工作的，因此渲染过程中发生异常，<code>HandlerExceptionResolver</code>是不会处理的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="function">ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, Object var3, Exception var4)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>HandlerExceptionResolver</code>中也只有一个方法，这个方法就是从异常中解析出<code>ModelAndView</code>。</p>
<h2 id="ViewResolver"><a href="#ViewResolver" class="headerlink" title="ViewResolver"></a>ViewResolver</h2><p><code>ViewResolver</code>的作用是将<code>String</code>类型的逻辑视图根据local解析为<code>View</code>视图的。下面是<code>ViewResolver</code>的源码接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewResolver</span> </span>&#123;</span><br><span class="line">    <span class="function">View <span class="title">resolveViewName</span><span class="params">(String viewName, Locale local)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看到，在<code>ViewResolver</code>中也是只有一个方法，从<code>resolveViewName</code>方法的参数和返回结果就很好的解释了其作用。</p>
<ul>
<li>viewName String类型的视图名</li>
<li>local 区域，可以用来做国际化。</li>
</ul>
<p><code>View</code>实际上是用来渲染页面的，也就是说将程序返回的结果填入到具体的模板里面，生成具体的视图文件，比如：jsp，ftl，html等。</p>
<p>但是这里又会牵扯出两个问题：</p>
<ul>
<li>用什么模板？</li>
<li>参数怎么填入？</li>
</ul>
<p>当然，这两个问题也就是本小节说的<code>ViewResolver</code>需要解决的问题。大体分为两种：</p>
<h3 id="针对单一视图类型的解析器"><a href="#针对单一视图类型的解析器" class="headerlink" title="针对单一视图类型的解析器"></a>针对单一视图类型的解析器</h3><ul>
<li>InternalResourceViewResolver</li>
<li>FreeMarkerViewResolver</li>
</ul>
<p>上面两种是用的最多的两种，<code>InternalResourceViewResolver</code>用来解析jsp，而<code>FreeMarkerViewResolver</code>则是针对FreeMarker。</p>
<h3 id="针对同时解析多种类型视图的解析器"><a href="#针对同时解析多种类型视图的解析器" class="headerlink" title="针对同时解析多种类型视图的解析器"></a>针对同时解析多种类型视图的解析器</h3><ul>
<li><p>BeanNameViewResolver</p>
<p>  需要同时使用视图名和对应的local来解析视图。它需要将每一个视图名和对应的视图类型配置到相应的properties文件中。（后面讲组件实现细节时给出列子）</p>
</li>
<li><p>XmlViewResolver</p>
<p>  XmlViewResolver和BeanNameViewResolver有点差不多，BeanNameViewResolver使用的是xml格式的配置文件。</p>
</li>
<li><p>ResourceBundleViewResolver</p>
<p>  这个其实就是根据viewName从Spring容器中查找bean，再根据这个bean来找到对应的视图。</p>
</li>
</ul>
<h2 id="LocalResolver"><a href="#LocalResolver" class="headerlink" title="LocalResolver"></a>LocalResolver</h2><p>在上面的<code>ViewResolver</code>中提到，解析视图需要两个参数，一个是String类型的逻辑视图名，另外一个是local。<code>LocalResolver</code>的作用就是从request中解析出local的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LocaleResolver</span> </span>&#123;</span><br><span class="line">    <span class="function">Locale <span class="title">resolveLocale</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLocale</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Locale local)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个方法是从request中解析出local，第二个方法是将local设置到request中。</p>
<p>关于local大多数情况下都是用来做国际化处理的。</p>
<h2 id="ThemeResolver"><a href="#ThemeResolver" class="headerlink" title="ThemeResolver"></a>ThemeResolver</h2><p>解析主题的。这个我平时除了SpringMVC自己提供的功能外，很少自己去扩展使用，即使是换主题也没有做过。不过既然存在肯定是有存在的原因的。对于我们常见的网页界面活着手机界面来说，一套主题无非就是换一套图片，活着css样式文件等等。我们通过<code>ThemeResolver</code>这个就可以实现这样的功能。具体使用其实也就是配一套properties文件供系统在不同的时候读取切换；当然使用这个也是可以实现国际化的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThemeResolver</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">resolveThemeName</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setThemeName</span><span class="params">(HttpServletRequest request, HttpServletResponse response, String themeName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RequestToViewNameTranslator"><a href="#RequestToViewNameTranslator" class="headerlink" title="RequestToViewNameTranslator"></a>RequestToViewNameTranslator</h2><p>这个其实还是挺有意思的，就是将request请求转换为视图名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface RequestToViewNameTranslator &#123;</span><br><span class="line">    String getViewName(HttpServletRequest request) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RequestToViewNameTranslator</code>只有一个默认的实现类<code>DefaultRequestToViewNameTranslator</code>。</p>
<p>在<code>DefaultRequestToViewNameTranslator</code>具体实现了getViewName(HttpServletRequest request)方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getViewName</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    String lookupPath = <span class="keyword">this</span>.urlPathHelper.getLookupPathForRequest(request);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.prefix + <span class="keyword">this</span>.transformPath(lookupPath) + <span class="keyword">this</span>.suffix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是委派给urlPathHelper帮助类得到请求的后缀名称，比如通过 请求路径比如/glmapper/login.do转换得到/login.do  ；具体怎么转换成视图也会在后面的组件介绍中给出具体的例子。</p>
<h2 id="MultipartResolver"><a href="#MultipartResolver" class="headerlink" title="MultipartResolver"></a>MultipartResolver</h2><p>这个相应小伙伴们也不陌生，做网站多多少少会涉及到文件上传。<code>MultipartResolver</code>就是用来处理上传请求的。其处理方式就是将request包装成<code>MultipartHttpServletRequest</code>。然后我们就可以用<code>MultipartHttpServletRequest</code>这个直接调用getFile获取的文件了。</p>
<h2 id="FlashMapManager"><a href="#FlashMapManager" class="headerlink" title="FlashMapManager"></a>FlashMapManager</h2><p>这个在redirect是进行参数传递需要用到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlashMapManager</span> </span>&#123;</span><br><span class="line">    <span class="function">FlashMap <span class="title">retrieveAndUpdate</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveOutputFlashMap</span><span class="params">(FlashMap flashMap, HttpServletRequest request, HttpServletResponse response)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>retrieveAndUpdate</code>这个方法是用来恢复参数的，对于恢复过的和超时的参数将都会被删除掉。</p>
<p><code>saveOutputFlashMap</code>这个方法是用来保存参数的。</p>
<p><code>FlashMapManager</code>的默认实现机制中参数的存储是放在session中的。我之前在一个项目中就有遇到过这种情况，对于一些我们不想暴露在url中的参数，在进行请求转发时，可以使用@RedirectAttributes将参数保存，然后在下一个处理器中获取到。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇主要是来对九大组件做一个笼统的介绍，细节实现及案例均不涉及；在后续的SpringMVC源码系列中对各个组件的实现细节分析时再一探究竟吧。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/spring-base-webmvc5/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/spring-base-webmvc4/">SpringMVC源码系列：AbstractUrlHandlerMapping</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T06:20:26.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/spring-base-webmvc4/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/web/" title="web">web</a>,
  
    <a href="/tags/mvc/" title="mvc">mvc</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p><code>AbstractUrlHandlerMapping</code>是通过url来进行匹配的，也就是说通过url与对应的Handler包存到一个Map中，然后在getHandlerInternal方法中使用url作为key从Map中获取我们的handler。</p>
<p><code>AbstractUrlHandlerMapping</code>实现了从url获取handler的过程，具体的映射关系，也就是handlerMap则是交给具体子类来去完成的。<code>AbstractUrlHandlerMapping</code>中定义了handlerMap用来维护映射关系，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; handlerMap = </span><br><span class="line"><span class="keyword">new</span> LinkedHashMap&lt;String, Object&gt;();</span><br></pre></td></tr></table></figure></p>
<p>除此之外，还有一个rootHandler,这个用于处理“/”请求。</p>
<p>在前面三篇文章中提到过，handler的获取是通过getHandlerInternal方法完成的，下面看下具体的源码，分析下handler的获取和handlerMap的构建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找给定请求的URL路径的Handler。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">Exception </span>&#123;</span><br><span class="line">    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">    <span class="comment">//使用lookupPath从Map中查找handler</span></span><br><span class="line">    Object handler = lookupHandler(lookupPath, request);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="comment">//临时变量，保存原始的handler</span></span><br><span class="line">    	Object rawHandler = <span class="keyword">null</span>;</span><br><span class="line">    	<span class="comment">//是否是‘/’根路径</span></span><br><span class="line">    	<span class="keyword">if</span> (<span class="string">"/"</span>.equals(lookupPath)) &#123;</span><br><span class="line">    	    <span class="comment">//获取rootHandler</span></span><br><span class="line">    		rawHandler = getRootHandler();</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//如果rawHandler是null</span></span><br><span class="line">    	<span class="keyword">if</span> (rawHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	    <span class="comment">//获取默认的handler</span></span><br><span class="line">    		rawHandler = getDefaultHandler();</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//如果rawHandler不是null</span></span><br><span class="line">    	<span class="keyword">if</span> (rawHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="comment">// 如果是string类型，则到容器中查找具体的bean</span></span><br><span class="line">    		<span class="keyword">if</span> (rawHandler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    			String handlerName = (String) rawHandler;</span><br><span class="line">    			<span class="comment">//容器中获取</span></span><br><span class="line">    			rawHandler = getApplicationContext().getBean(handlerName);</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="comment">//校验handler和request是否匹配</span></span><br><span class="line">    		validateHandler(rawHandler, request);</span><br><span class="line">    		<span class="comment">//注册拦截器</span></span><br><span class="line">    		handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, <span class="keyword">null</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//日志debug</span></span><br><span class="line">    <span class="keyword">if</span> (handler != <span class="keyword">null</span> &amp;&amp; logger.isDebugEnabled()) &#123;</span><br><span class="line">    	logger.debug(<span class="string">"Mapping ["</span> + lookupPath + <span class="string">"] to "</span> + handler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (handler == <span class="keyword">null</span> &amp;&amp; logger.isTraceEnabled()) &#123;</span><br><span class="line">    	logger.trace(<span class="string">"No handler mapping found for ["</span> + lookupPath + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回handler</span></span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>getHandlerInternal</code>方法中有几个方法调用，像getLookupPathForRequest、getRootHandler、getDefaultHandler、lookupHandler、buildPathExposingHandler等。其中getLookupPathForRequest、getRootHandler、getDefaultHandler这几个没啥好说的；比较核心的就是lookupHandler、buildPathExposingHandler这两个方法。</p>
<ul>
<li><p>lookupHandler</p>
<p>  lookupHandler使用getUrlPathHelper().getLookupPathForRequest(request)获取到的lookupPath从Map中查找需要的Handler,通常情况下是直接get不到的。为什么呢？原因在于很多的handler都是使用了Pattern的匹配模式，比如说“/user/*”,星号表示匹配任意内容，并非是指定url串中的字符。如果Pattern中包含了PathVariable,也不能直接从Map中获取到。</p>
<p>  除此之外，一个url还可能和多个Pattern相匹配，那么这个时候咱们肯定就需要选择最优的，所以说查找过程其实并不是直接从map中获取那么简单。那么就来看下在lookupHandler中都干了哪些事情：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">lookupHandler</span><span class="params">(String urlPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 直接匹配，直接从Map中获取</span></span><br><span class="line">    Object handler = <span class="keyword">this</span>.handlerMap.get(urlPath);</span><br><span class="line">    <span class="comment">//取到了</span></span><br><span class="line">    <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="comment">// 如果是string类型，则从容器中获取Bean</span></span><br><span class="line">    	<span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    		String handlerName = (String) handler;</span><br><span class="line">    		handler = getApplicationContext().getBean(handlerName);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//验证是否匹配</span></span><br><span class="line">    	validateHandler(handler, request);</span><br><span class="line">    	<span class="comment">//注册拦截器</span></span><br><span class="line">    	<span class="keyword">return</span> buildPathExposingHandler(handler, urlPath, urlPath, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Pattern 匹配，带*号的模式与url进行匹配</span></span><br><span class="line">    List&lt;String&gt; matchingPatterns = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String registeredPattern : <span class="keyword">this</span>.handlerMap.keySet()) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (getPathMatcher().match(registeredPattern, urlPath)) &#123;</span><br><span class="line">    		matchingPatterns.add(registeredPattern);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span> (useTrailingSlashMatch()) &#123;</span><br><span class="line">    		<span class="keyword">if</span> (!registeredPattern.endsWith(<span class="string">"/"</span>) &amp;&amp; getPathMatcher().match(registeredPattern + <span class="string">"/"</span>, urlPath)) &#123;</span><br><span class="line">    			matchingPatterns.add(registeredPattern +<span class="string">"/"</span>);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取最佳匹配</span></span><br><span class="line">    String bestPatternMatch = <span class="keyword">null</span>;</span><br><span class="line">    Comparator&lt;String&gt; patternComparator = getPathMatcher().getPatternComparator(urlPath);</span><br><span class="line">    <span class="keyword">if</span> (!matchingPatterns.isEmpty()) &#123;</span><br><span class="line">    	Collections.sort(matchingPatterns, patternComparator);</span><br><span class="line">    	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    		logger.debug(<span class="string">"Matching patterns for request ["</span> + urlPath + <span class="string">"] are "</span> + matchingPatterns);</span><br><span class="line">    	&#125;</span><br><span class="line">    	bestPatternMatch = matchingPatterns.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最佳匹配不为null</span></span><br><span class="line">    <span class="keyword">if</span> (bestPatternMatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从Map中看看是否有对应的Handler  </span></span><br><span class="line">    	handler = <span class="keyword">this</span>.handlerMap.get(bestPatternMatch);</span><br><span class="line">    	<span class="comment">//如果Map中没有</span></span><br><span class="line">    	<span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="comment">//是否以/结尾</span></span><br><span class="line">    		Assert.isTrue(bestPatternMatch.endsWith(<span class="string">"/"</span>));</span><br><span class="line">    		<span class="comment">//去除/之后再获取一次</span></span><br><span class="line">    		handler = <span class="keyword">this</span>.handlerMap.get(bestPatternMatch.substring(<span class="number">0</span>, bestPatternMatch.length() - <span class="number">1</span>));</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 如果是String类型，则从容器中获取Bean?</span></span><br><span class="line">    	<span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    		String handlerName = (String) handler;</span><br><span class="line">    		handler = getApplicationContext().getBean(handlerName);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//验证是否匹配</span></span><br><span class="line">    	validateHandler(handler, request);</span><br><span class="line">    	String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestPatternMatch, urlPath);</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// 可能有多种最佳模式，让我们确保我们有正确的URI模板变量（译）</span></span><br><span class="line">    	Map&lt;String, String&gt; uriTemplateVariables = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">    	<span class="keyword">for</span> (String matchingPattern : matchingPatterns) &#123;</span><br><span class="line">    		<span class="keyword">if</span> (patternComparator.compare(bestPatternMatch, matchingPattern) == <span class="number">0</span>) &#123;</span><br><span class="line">    			Map&lt;String, String&gt; vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, urlPath);</span><br><span class="line">    			Map&lt;String, String&gt; decodedVars = getUrlPathHelper().decodePathVariables(request, vars);</span><br><span class="line">    			uriTemplateVariables.putAll(decodedVars);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    		logger.debug(<span class="string">"URI Template variables for request ["</span> + urlPath + <span class="string">"] are "</span> + uriTemplateVariables);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> buildPathExposingHandler(handler, bestPatternMatch, pathWithinMapping, uriTemplateVariables);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No handler found...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，关于译注的部分需要说一下；代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; uriTemplateVariables = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">for</span> (String matchingPattern : matchingPatterns) &#123;</span><br><span class="line">    <span class="keyword">if</span> (patternComparator.compare(bestPatternMatch, matchingPattern) == <span class="number">0</span>) &#123;</span><br><span class="line">    	Map&lt;String, String&gt; vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, urlPath);</span><br><span class="line">    	Map&lt;String, String&gt; decodedVars =</span><br><span class="line">    	getUrlPathHelper().decodePathVariables(request, vars);</span><br><span class="line">    	uriTemplateVariables.putAll(decodedVars);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前是通过sort方法进行排序的，然后将第一个作为bestPatternMatch，但是如果多个pattern的顺序相同，也就是说sort返回的是0,存在多种最佳匹配，那就需要确保我们有正确的URI模板变量。上面代码就是处理这种情况的。</p>
<ul>
<li><p>buildPathExposingHandler</p>
<p>  这个方法在上面的两段代码中都频繁出现，那么这个方法到底有什么作用呢？代码中我注释的是注册拦截器，那么注册的又是什么拦截器？带着这两个问题，我们来看下代码。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//buildPathExposingHandler为给定的rawHandler构建一个Handler对象，并在执</span></span><br><span class="line"><span class="comment">//行处理程序之前暴露实际的处理程序PATH_WITHIN_HANDLER_MAPPING_ATTRIBUT</span></span><br><span class="line"><span class="comment">//E以及URI_TEMPLATE_VARIABLES_ATTRIBUTE。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认实现用一个特殊的拦截器构建一个HandlerExecutionChain，该拦截器暴露</span></span><br><span class="line"><span class="comment">//path属性和uri模板变量。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">buildPathExposingHandler</span><span class="params">(Object rawHandler, </span></span></span><br><span class="line"><span class="function"><span class="params">    String bestMatchingPattern,</span></span></span><br><span class="line"><span class="function"><span class="params">    String pathWithinMapping, </span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;String, String&gt; uriTemplateVariables)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    HandlerExecutionChain chain = <span class="keyword">new</span> HandlerExecutionChain(rawHandler);</span><br><span class="line">    chain.addInterceptor(<span class="keyword">new</span> PathExposingHandlerInterceptor(bestMatchingPattern, pathWithinMapping));</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(uriTemplateVariables)) &#123;</span><br><span class="line">    	chain.addInterceptor(<span class="keyword">new</span> UriTemplateVariablesHandlerInterceptor(uriTemplateVariables));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>四个参数：</p>
<ul>
<li>rawHandler 原始处理程序</li>
<li>bestMatchingPattern 最佳匹配模式</li>
<li>pathWithinMapping 在执行Handler之前公开的路径</li>
<li>uriTemplateVariables 如果没有找到变量，URI模板变量可以是{null}</li>
</ul>
<p>从代码注释翻译及代码内容可以了解到，buildPathExposingHandler的作用就是给已经查找到的handler注册两个拦截器</p>
<ul>
<li>ExposingHandlerInterceptor</li>
<li>UriTemplateVariablesHandlerInterceptor</li>
</ul>
<p>这两个类均是<code>AbstractUrlHandlerMapping</code>的内部类，也就是两个内部拦截器。这两个拦截器的主要作用就是将与当前url实际匹配的pattern、匹配条件以及url模板参数等设置到request的属性里面去，这样在后面的处理过程中就可以直接从request属性中获取。看下两个内部类的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PathExposingHandlerInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String bestMatchingPattern;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String pathWithinMapping;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathExposingHandlerInterceptor</span><span class="params">(String bestMatchingPattern, String pathWithinMapping)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.bestMatchingPattern = bestMatchingPattern;</span><br><span class="line">    	<span class="keyword">this</span>.pathWithinMapping = pathWithinMapping;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> </span>&#123;</span><br><span class="line">    	exposePathWithinMapping(<span class="keyword">this</span>.bestMatchingPattern,</span><br><span class="line">    	<span class="keyword">this</span>.pathWithinMapping, request);</span><br><span class="line">    	<span class="comment">//设置request属性</span></span><br><span class="line">    	request.setAttribute(HandlerMapping.INTROSPECT_TYPE_LEVEL_MAPPING, supportsTypeLevelMappings());</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">UriTemplateVariablesHandlerInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; uriTemplateVariables;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UriTemplateVariablesHandlerInterceptor</span><span class="params">(Map&lt;String, String&gt; uriTemplateVariables)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.uriTemplateVariables = uriTemplateVariables;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">    HttpServletResponse response, Object handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这exposeUriTemplateVariables种设置request属性</span></span><br><span class="line">    	exposeUriTemplateVariables(<span class="keyword">this</span>.uriTemplateVariables, request);</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从内部类的代码可以看出，这两个内部类是通过在preHandle方法中调用exposePathWithinMapping和exposeUriTemplateVariables完成属性设置到request中的。</p>
<p>对于查找handler的关键其实就是维护url和handler的映射关系，也就是handlerMap的构建。在<code>AbstractUrlHandlerMapping</code>中是通过registerHandler这个方法来构建handlerMap的。<code>AbstractUrlHandlerMapping</code>提供了两个registerHandler方法，下面就通过代码来看下具体的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandler</span><span class="params">(String[] urlPaths, String beanName)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    Assert.notNull(urlPaths, <span class="string">"URL path array must not be null"</span>);</span><br><span class="line">    <span class="keyword">for</span> (String urlPath : urlPaths) &#123;</span><br><span class="line">    	registerHandler(urlPath, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个registerHandler是将多个url注册到一个处理器。beanName其实就是咱们处理器的名称，可以通过beanName到容器中去找到真正的处理器Bean。具体处理就是通过遍历所有的url，然后再通过调用第二个registerHandler将handler注册到handlerMap中。来看第二个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandler</span><span class="params">(String urlPath, Object handler)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    Assert.notNull(urlPath, <span class="string">"URL path must not be null"</span>);</span><br><span class="line">    Assert.notNull(handler, <span class="string">"Handler object must not be null"</span>);</span><br><span class="line">    Object resolvedHandler = handler;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果的handler是string类型，并且不是lazyInitHandlers，则从SpringMV</span></span><br><span class="line">    <span class="comment">//C容器中获取handler</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.lazyInitHandlers &amp;&amp; handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    	String handlerName = (String) handler;</span><br><span class="line">    	<span class="keyword">if</span> (getApplicationContext().isSingleton(handlerName)) &#123;</span><br><span class="line">    		resolvedHandler = getApplicationContext().getBean(handlerName);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Object mappedHandler = <span class="keyword">this</span>.handlerMap.get(urlPath);</span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (mappedHandler != resolvedHandler) &#123;</span><br><span class="line">    		<span class="comment">//异常处理</span></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//是否是跟路径</span></span><br><span class="line">    	<span class="keyword">if</span> (urlPath.equals(<span class="string">"/"</span>)) &#123;</span><br><span class="line">    		<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">    			logger.info(<span class="string">"Root mapping to "</span> +</span><br><span class="line">    			getHandlerDescription(handler));</span><br><span class="line">    		&#125;</span><br><span class="line">    		setRootHandler(resolvedHandler);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//是否是*模式</span></span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span> (urlPath.equals(<span class="string">"/*"</span>)) &#123;</span><br><span class="line">    		<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">    			logger.info(<span class="string">"Default mapping to "</span> +</span><br><span class="line">    			getHandlerDescription(handler));</span><br><span class="line">    		&#125;</span><br><span class="line">    		setDefaultHandler(resolvedHandler);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//加入到handlerMap中</span></span><br><span class="line">    	<span class="keyword">else</span> &#123;</span><br><span class="line">    		<span class="keyword">this</span>.handlerMap.put(urlPath, resolvedHandler);</span><br><span class="line">    		<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        		logger.info(<span class="string">"Mapped URL path ["</span> + urlPath + <span class="string">"] onto "</span> +</span><br><span class="line">        		getHandlerDescription(handler));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个里面首先是看Map中是否有原来传入的url，如果没有就加入，如果有就看下原来保存的和当前注册的handler是否是同一个，如果不是同一个就抛出异常。（同一个url不可能存在两个不同的handler）。</p>
<p>在put之前，也做了一些“/”和“/*”的验证处理，如果是这两种路径的话就不保存到handlerMap中了。</p>
<ul>
<li>“/”：setRootHandler(resolvedHandler);</li>
<li>“/*”：setDefaultHandler(resolvedHandler);</li>
</ul>
<p>OK，到这<code>AbstractUrlHandlerMapping</code>这个类就分析完了，其实<code>AbstractUrlHandlerMapping</code>做的事情就是定义了一个框子，子类只要完成对Map的初始化就可以了。关于<code>AbstractUrlHandlerMapping</code>的子类后续再谈。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/spring-base-webmvc4/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/spring-base-webmvc3/">SpringMVC系列源码：DispatcherServlet</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T06:03:59.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/spring-base-webmvc3/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/web/" title="web">web</a>,
  
    <a href="/tags/mvc/" title="mvc">mvc</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>前面两篇文章直接对SpringMVC里面的组件进行了源码分析，可能很多小伙伴都会觉得有点摸不着头脑。所以今天再岔回来说一说SpringMVC的核心控制器，以此为轴心来学习整个SpringMVC的知识体系。</p>
<h2 id="SpringMVC在项目中如何使用的？"><a href="#SpringMVC在项目中如何使用的？" class="headerlink" title="SpringMVC在项目中如何使用的？"></a>SpringMVC在项目中如何使用的？</h2><p>前面在《<a href="https://juejin.im/post/59f3ef5c51882534aa0691b2" target="_blank" rel="noopener">项目开发框架-SSM</a>》一篇文章中已经详细的介绍过了SSM项目中关于Spring的一些配置文件，对于一个Spring应用，必不可少的是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;param-value&gt;classpath*:config/applicationContext.xml&lt;/param-value&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置一个监听器将请求转发给 Spring框架 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring监听器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过ContextLoadListener来完成Spring容器的初始化以及Bean的装载《<a href="https://juejin.im/post/59a286866fb9a0249d616fbb" target="_blank" rel="noopener">Spring技术内幕学习：Spring的启动过程</a>》。那么如果在我们需要提供WEB功能，则还需要另外一个，那就是SpringMVC,当然我们同样需要一个用来初始化SpringMVC的配置（初始化9大组件的过程：前面两篇《<a href="https://juejin.im/post/5a55791c6fb9a01c975a2025" target="_blank" rel="noopener">SpringMVC源码系列：HandlerMapping</a>》和《<a href="https://juejin.im/post/5a558b1d6fb9a01cbd587b99" target="_blank" rel="noopener">SpringMVC源码系列：AbstractHandlerMapping</a>》是关于HnadlerMapping的，当然不仅仅这两个，还有其他几个重要的子类，后续会持续更新）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mvc-dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置springMVC需要加载的配置文件 spring-dao.xml,spring-service.xml,spring-web.xml </span></span><br><span class="line"><span class="comment">		Mybatis（如果有） - &gt; spring -&gt; springmvc --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mvc-dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 默认匹配所有的请求 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.htm<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当我们在web.xml中配置好上述内容（当然还得保证咱们的Spring的配置以及SpringMVC的配置文件没有问题的情况下），启动web容器（如jetty），就可以通过在浏览器输入诸如：<a href="http://localhost:80/myproject/index.do" target="_blank" rel="noopener">http://localhost:80/myproject/index.do</a> 的方式来访问我们的应用了。</p>
<p>俗话说知其然，之气所以然；那么为什么在配置好相关的配置文件之后，我们就能访问我们的SSM项目了呢？从发送一条那样的请求（<a href="http://localhost:80/myproject/index.do）展示出最后的界面，这个过程在，Spring帮我们做了哪些事情呢？（SpringIOC容器的初始化在《[Spring技术内幕-容器刷新：wac.refresh](https://juejin.im/post/5a3f5b43f265da432e5c37ea)》文中已经大概的说了下大家可以参考一下）" target="_blank" rel="noopener">http://localhost:80/myproject/index.do）展示出最后的界面，这个过程在，Spring帮我们做了哪些事情呢？（SpringIOC容器的初始化在《[Spring技术内幕-容器刷新：wac.refresh](https://juejin.im/post/5a3f5b43f265da432e5c37ea)》文中已经大概的说了下大家可以参考一下）</a></p>
<h2 id="SpringMVC处理请求的过程"><a href="#SpringMVC处理请求的过程" class="headerlink" title="SpringMVC处理请求的过程"></a>SpringMVC处理请求的过程</h2><p>先通过下面这张图来整个了解下SpringMVC请求处理的过程；图中从1-13，大体上描述了请求从发送到界面展示的这样一个过程。<br><img src="https://user-gold-cdn.xitu.io/2018/1/12/160e9cb552fb7aa0?w=935&amp;h=922&amp;f=png&amp;s=48045" alt=""><br>从上面这张图中，我们可以很明显的看到有一个DispatcherServlet这样一个类，处于各个请求处理过程中的分发站。实际上，在SpringMVC中，整个处理过程的顶层设计都在这里面。通常我们将DispatcherServlet称为SpringMVC的前端控制器，它是SpringMVC中最核心的类。下面我们就来揭开DispatcherServlet的面纱吧！</p>
<h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p>OK，我们直接来看DispatcherServlet的类定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">FrameworkServlet</span></span></span><br></pre></td></tr></table></figure></p>
<p>DispatcherServlet继承自FrameworkServlet，就这样？</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/12/160ea3f0d911990e?w=511&amp;h=300&amp;f=jpeg&amp;s=13176" alt=""></p>
<p>下面才是他家的族谱：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/12/160ea4067691d914?w=1056&amp;h=691&amp;f=png&amp;s=21550" alt=""></p>
<p>首先为什么要有绿色的部门，有的同学可能已经想到了，绿色部分不是Spring的，而是java自己的；Spring通过HttpServletBean这位年轻人成功的拥有了JAVA WEB 血统（本来Spring就是用JAVA写的，哈哈）。关于Servlet这个小伙伴可以看下我之前的文章，有简单的介绍了这个接口。</p>
<p>话说回来，既然DispatcherServlet归根揭底是一个Servlet，那么就肯定具有Servlet功能行为。</p>
<p><code>敲黑板！！！Servlet的生命周期是啥（init-&gt;service-&gt;destroy ： 加载-&gt;实例化-&gt;服务-&gt;销毁）。</code></p>
<p>其实这里我想说的就是service这个方法，当然，在DispatcherServlet中并没有service方法，但是它有一个doService方法！（引的好难…）</p>
<p>doService是DispatcherServlet的入口，我们来看下这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    	String resumed = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult() ? <span class="string">" resumed"</span> : <span class="string">""</span>;</span><br><span class="line">    	logger.debug(<span class="string">"DispatcherServlet with name '"</span> + getServletName() + <span class="string">"'"</span> + resumed +</span><br><span class="line">    			<span class="string">" processing "</span> + request.getMethod() + <span class="string">" request for ["</span> + getRequestUri(request) + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在include的情况下保留请求属性的快照，以便能够在include之后恢复原始属性。</span></span><br><span class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//确定给定的请求是否是包含请求，即不是从外部进入的顶级HTTP请求。</span></span><br><span class="line">    <span class="comment">//检查是否存在“javax.servlet.include.request_uri”请求属性。 可以检查只包含请求中的任何请求属性。</span></span><br><span class="line">    <span class="comment">//(可以看下面关于isIncludeRequest解释)</span></span><br><span class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">    	attributesSnapshot = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    	Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">    	<span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">    		String attrName = (String) attrNames.nextElement();</span><br><span class="line">    		<span class="keyword">if</span> (<span class="keyword">this</span>.cleanupAfterInclude || attrName.startsWith(<span class="string">"org.springframework.web.servlet"</span>)) &#123;</span><br><span class="line">    			attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使框架可用于handler和view对象。</span></span><br><span class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</span><br><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</span><br><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line">    <span class="comment">//FlashMap用于保存转发请求的参数的</span></span><br><span class="line">    FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">    <span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">    &#125;</span><br><span class="line">    request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span><br><span class="line">    request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	doDispatch(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">    		<span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line">    		<span class="keyword">if</span> (attributesSnapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">    			restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PS：“javax.servlet.include.request_uri”是INCLUDE_REQUEST_URI_ATTRIBUTE常量的值。isIncludeRequest(request)方法的作用我们可以借助一条JSP的指令来理解：</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:incluede page=<span class="string">"index.jsp"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p><code>这条指令是指在一个页面中嵌套了另一个页面，那么我们知道JSP在运行期间是会被编译成相应的Servlet类来运行的，所以在Servlet中也会有类似的功能和调用语法，这就是RequestDispatch.include()方法。
那么在一个被别的servlet使用RequestDispatcher的include方法调用过的servlet中，如果它想知道那个调用它的servlet的上下文信息该怎么办呢，那就可以通过request中的attribute中的如下属性获取：</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javax.servlet.include.request_uri</span><br><span class="line">javax.servlet.include.context_path</span><br><span class="line">javax.servlet.include.servlet_path</span><br><span class="line">javax.servlet.include.path_info</span><br><span class="line">javax.servlet.include.query_string</span><br></pre></td></tr></table></figure>
<p>在doService中，下面的try块中可以看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    doDispatch(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doService并没有直接进行处理，二是将请求交给了doDispatch进行具体的处理。当然在调用doDispatch之前，doService也是做了一些事情的，比如说判断请求是不是inclde请求，设置一些request属性等。</p>
<h2 id="FlashMap支撑的Redirect参数传递问题"><a href="#FlashMap支撑的Redirect参数传递问题" class="headerlink" title="FlashMap支撑的Redirect参数传递问题"></a>FlashMap支撑的Redirect参数传递问题</h2><p>在doService中除了webApplicationContext、localeResolver、themeResolve和themeSource四个提供给handler和view使用的四个参数外，后面的三个都是和FlashMap有关的，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FlashMap用于保存转发请求的参数的</span></span><br><span class="line">FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line"><span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">	request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">&#125;</span><br><span class="line">request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span><br><span class="line">request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span><br></pre></td></tr></table></figure></p>
<p>注释中提到，FlashMap主要用于Redirect转发时参数的传递；</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/13/160ed457b177f8c3?w=423&amp;h=149&amp;f=jpeg&amp;s=6126" alt=""><br>就拿表单重复提交这个问题来说,一种方案就是：在处理完post请求之后，然后Redirect到一个get的请求，这样即使用户刷新也不会有重复提交的问题。但是问题在于,前面的post请求时提交订单，提交完后redirect到一个显示订单的页面，显然在显示订单的页面我们需要知道订单的信息，但是redirect本身是没有参数传递功能的，按照普通的模式如果想传递参数，就只能将参数拼接在url中，但是url在get请求下又是有长度限制的；另外，对于一些场景下，我们也不希望自己的参数暴露在url中。</p>
<p>对于上述问题，我们就可以用FlashMap来进行参数传递了；我们需要在redirect之前将需要的参数写入OUTPUT_FLASH_MAP_ATTRIBUTE，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ServletRequestAttributes SRAttributes = (ServletRequestAttributes)(RequestContextHolder.getRequestAttributes());</span><br><span class="line">HttpServletRequest req = SRAttributes.getRequest();</span><br><span class="line">FlashMap flashMap = (FlashMap)(req.getAttribute(DispatcherServlet.OUTPUT_FLASH_MAP_ATTRIBUTE));</span><br><span class="line">flashMap.put(<span class="string">"myname"</span>,<span class="string">"glmapper_2018"</span>);</span><br></pre></td></tr></table></figure>
<p>这样在redirect之后的handler中spring就会自动将其设置到model里面。但是如果仅仅是这样，每次redirect时都写上面那样一段代码是不是又显得很鸡肋呢？当然，spring也为我们提供了更加方便的用法，即在我们的handler方法的参数中使用RedirectAttributes类型变量即可（前段时间用到这个，本来是想单独写一篇关于参数传递问题的，借此机会就省略一篇吧，吼吼…），来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/detail/&#123;productId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">detail</span><span class="params">(HttpServletRequest request,HttpServletResponse </span></span></span><br><span class="line"><span class="function"><span class="params">    response,RedirectAttributes attributes, @PathVariable String productId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotBlank(productId)) &#123;</span><br><span class="line">	logger.info(<span class="string">"[产品详情]:detail = &#123;&#125;"</span>,JSONObject.toJSONString(map));</span><br><span class="line">	mv.addObject(<span class="string">"detail"</span>,JSONObject.toJSONString(getDetail(productId)));</span><br><span class="line">	mv.addObject(<span class="string">"title"</span>, <span class="string">"详情"</span>);</span><br><span class="line">	mv.setViewName(<span class="string">"detail.ftl"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果没有获取到productId</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">	attributes.addFlashAttribute(<span class="string">"msg"</span>, <span class="string">"产品不存在"</span>);</span><br><span class="line">	attributes.addFlashAttribute(<span class="string">"productName"</span>, productName);</span><br><span class="line">	attributes.addFlashAttribute(<span class="string">"title"</span>, <span class="string">"有点问题！"</span>);</span><br><span class="line">	mv.setViewName(<span class="string">"redirect:"</span>/error/fail.htm<span class="string">");</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">return mv;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这段代码时我前段时间做全局错误处理模块时对原有业务逻辑错误返回的一个抽象，因为要将错误统一处理，就不可能在具体的handler中直接返回到错误界面，所以就将所有的错误处理都redirect到error/fail.htm这个handler method中处理。redirect的参数问题上面已经描述过了，这里就不在细说，就是简单的例子和背景，知道怎么去使用RedirectAttributes。</p>
<p>RedirectAttributes这个原理也很简单，就是相当于存在了一个session中，但是这个session在用过一次之后就销毁了，即在fail.htm这个方法中获取之后如果再进行redirect，参数还会丢失，那么就在fail.htm中继续使用RedirectAttributes来存储参数再传递到下一个handler。</p>
<h2 id="doDispatch方法"><a href="#doDispatch方法" class="headerlink" title="doDispatch方法"></a>doDispatch方法</h2><p>为了偷懒，上面强行插入了对Spring中redirect参数传递问题的解释。回归到咱们的doDispatch方法。</p>
<p>作用：处理实际的调度到handler。handler将通过按顺序应用servlet的HandlerMappings来获得。<br>HandlerAdapter将通过查询servlet已安装的HandlerAdapter来查找支持处理程序类的第一个HandlerAdapter。所有的HTTP方法都由这个方法处理。这取决于HandlerAdapter或处理程序自己决定哪些方法是可以接受的。</p>
<p>其实在doDispatch中最核心的代码就4行，我们来看下：</p>
<ul>
<li><p>根据request找到我们的handler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Determine handler for the current request.</span></span><br><span class="line">   mappedHandler = getHandler(processedRequest);</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据handler找到对应的HandlerAdapter</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">   HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br></pre></td></tr></table></figure>
<ul>
<li>HandlerAdapter处理handler</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Actually invoke the handler.</span></span><br><span class="line">   mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br></pre></td></tr></table></figure>
<ul>
<li>调用processDispatchResult方法处理上述过程中得结果综合，当然也包括找到view并且渲染输出给用户<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我们以上述为轴心，来看下它的整个源码(具体代码含义在代码中标注)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//当前请求request</span></span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    <span class="comment">//处理器链（handler和拦截器）</span></span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//用户标识multipartRequest（文件上传请求）</span></span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//很熟悉吧，这个就是我们返回给用户的包装视图</span></span><br><span class="line">    	ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">    	<span class="comment">//处理请求过程中抛出的异常。这个异常是不包括渲染过程中抛出的异常的</span></span><br><span class="line">    	Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">    	    <span class="comment">//检查是不是上传请求</span></span><br><span class="line">    		processedRequest = checkMultipart(request);</span><br><span class="line">    		multipartRequestParsed = (processedRequest != request);</span><br><span class="line">    </span><br><span class="line">    		<span class="comment">// 通过当前请求确定相应的handler</span></span><br><span class="line">    		mappedHandler = getHandler(processedRequest);</span><br><span class="line">    		<span class="comment">//如果没有找到：就会报异常，这个异常我们在搭建SpringMVC应用时会经常遇到：</span></span><br><span class="line">    		<span class="comment">//No mapping found for HTTP request with URI XXX in</span></span><br><span class="line">    		<span class="comment">//DispatcherServlet with name XXX</span></span><br><span class="line">    		<span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    			noHandlerFound(processedRequest, response);</span><br><span class="line">    			<span class="keyword">return</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    </span><br><span class="line">    		<span class="comment">// 根据handler找到HandlerAdapter</span></span><br><span class="line">    		HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">    </span><br><span class="line">    		<span class="comment">//处理GET和Head请求的Last-Modified</span></span><br><span class="line">    		</span><br><span class="line">    		<span class="comment">//获取请求方法</span></span><br><span class="line">    		String method = request.getMethod();</span><br><span class="line">    		<span class="comment">//这个方法是不是GET方法</span></span><br><span class="line">    		<span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">    		<span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">    			<span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">    			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    				logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">    			&#125;</span><br><span class="line">    			<span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">    				<span class="keyword">return</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">            <span class="comment">//这里就是我们SpringMVC拦截器的preHandle方法的处理</span></span><br><span class="line">    		<span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">    			<span class="keyword">return</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">            </span><br><span class="line">    		<span class="comment">// 调用具体的Handler，并且返回我们的mv对象.</span></span><br><span class="line">    		mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">            <span class="comment">//如果需要异步处理的话就直接返回</span></span><br><span class="line">    		<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">    			<span class="keyword">return</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">            <span class="comment">//这个其实就是处理视图（view）为空的情况，会根据request设置默认的view</span></span><br><span class="line">    		applyDefaultViewName(processedRequest, mv);</span><br><span class="line">    		<span class="comment">//这里就是我们SpringMVC拦截器的postHandle方法的处理</span></span><br><span class="line">    		mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    		dispatchException = ex;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">    		<span class="comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span></span><br><span class="line">    		<span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">    		dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//处理返回结果；（异常处理、页面渲染、拦截器的afterCompletion触发等）</span></span><br><span class="line">    	processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    	triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">    	triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">    			<span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否执行异步请求</span></span><br><span class="line">    	<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">    		<span class="comment">// 如果是的话，就替代拦截器的postHandle 和 afterCompletion方法执行</span></span><br><span class="line">    		<span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    			mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">else</span> &#123;</span><br><span class="line">    		<span class="comment">// 删除上传请求的资源</span></span><br><span class="line">    		<span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">    			cleanupMultipart(processedRequest);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体来看，doDispatch做了两件事情：</p>
<ul>
<li>处理请求</li>
<li>页面渲染</li>
</ul>
<h3 id="doDispatch处理过程流程图"><a href="#doDispatch处理过程流程图" class="headerlink" title="doDispatch处理过程流程图"></a>doDispatch处理过程流程图</h3><p><img src="https://user-gold-cdn.xitu.io/2018/1/13/160ee44a53228b69?w=682&amp;h=644&amp;f=png&amp;s=36088" alt=""></p>
<p>那上面就是整个DispatcherServlet的一个大概内容了，关于SpringMVC容器的初始化，我们在先把DispatcherServlet中涉及到的九大组件撸完之后再回头来学习。关于九大组件目前已经有过两篇是关于HandlerMapping的了，由于我们打算对于整个SpringMVC体系结构都进行一次梳理，因此，会将九大组件从接口设计以及子类都会通过源码的方式来呈现。</p>
<p><code>大家如果有什么意见或者建议可以在下方评论区留言，也可以给我们发邮件（glmapper_2018@163.com）!欢迎小伙伴与我们一起交流，一起成长。</code></p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/spring-base-webmvc3/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/spring-base-webmvc2/">SpringMVC源码系列：AbstractHandlerMapping</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T06:02:35.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/spring-base-webmvc2/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/web/" title="web">web</a>,
  
    <a href="/tags/mvc/" title="mvc">mvc</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>AbstractHandlerMapping是实现HandlerMapping接口的一个抽象基类。支持排序，默认处理程序，处理程序拦截器，包括由路径模式映射的处理程序拦截器。所有的HandlerMapping都继承自AbstractHandlerMapping。另外，此基类不支持PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE的暴露，此属性的支持取决于具体的子类，通常基于请求URL映射。</p>
<p>前面说到，HandlerMapping的作用就是通过request查找Handler和Interceptors。具体的获取均是通过子类来实现的。</p>
<h2 id="1-AbstractHandlerMapping-的类定义"><a href="#1-AbstractHandlerMapping-的类定义" class="headerlink" title="1.AbstractHandlerMapping 的类定义"></a>1.AbstractHandlerMapping 的类定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractHandlerMapping extends WebApplicationObjectSupport</span><br><span class="line"> implements HandlerMapping, Ordered &#123;</span><br></pre></td></tr></table></figure>
<p>AbstractHandlerMapping继承了WebApplicationObjectSupport，初始化时会自动调用模板方法initApplicationContext；AbstractHandlerMapping的创建也就是在这个方法里面完成的。同时实现了HandlerMapping和Ordered接口，这也就是上面提到的支持排序的原因。</p>
<h2 id="2-AbstractHandlerMapping属性分析"><a href="#2-AbstractHandlerMapping属性分析" class="headerlink" title="2.AbstractHandlerMapping属性分析"></a>2.AbstractHandlerMapping属性分析</h2><ul>
<li><p>排序值 order</p>
<p>  默认值为Integer的最大值，后面注释的意思是和没有排序是一样的，因为只有理论上才可能超过Integer.MAX_VALUE。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private int order = Integer.MAX_VALUE;  // default: same as non-Ordered</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认处理器 defaultHandler</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Object defaultHandler;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Spring工具类 urlPathHelper</p>
<p>  Helper类用于URL路径匹配。提供对RequestDispatcher中URL路径的支持，包括并支持一致的URL解码。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private UrlPathHelper urlPathHelper = new UrlPathHelper();</span><br></pre></td></tr></table></figure>
</li>
<li><p>spring工具类 PathMatcher(AntPathMatcher)</p>
<p>  用于基于字符串的路径匹配的策略接口。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private PathMatcher pathMatcher = new AntPathMatcher();</span><br></pre></td></tr></table></figure>
</li>
<li><p>拦截器列表 interceptors</p>
<p>  用于配置SpringMVC的拦截器，配置方式由两种：<br></p>
<ul>
<li>1.注册HandlerMapping时通过属性设置<br></li>
<li><p>2.通过子类的extendInterceptors钩子方法进行设置（extendInterceptors方法是在initApplicationContext中调用的）<br></p>
<p>interceptors并不会直接使用，二是通过initInterceptors方法按照类型分配到mappedInterceptors和adaptedInterceptors中进行使用，<strong><strong>interceptors只用于配置。</strong></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final List&lt;Object&gt; interceptors = new ArrayList&lt;Object&gt;();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>adaptedInterceptors</p>
<p>  被分配到adaptedInterceptors中的类型的拦截器不需要进行匹配，在getHandler中会全部添加到返回值HandlerExecutionChain里面。他 只能从 interceptors中获取。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final List&lt;HandlerInterceptor&gt; adaptedInterceptors = new ArrayList&lt;HandlerInterceptor&gt;();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>corsProcessor</p>
<p>  CorsProcessor作用是接受请求和CorsConfiguration并更新响应的策略。<br>  此组件不关心如何选择CorsConfiguration，而是采取后续操作，例如应用CORS验证检查，并拒绝响应或将CORS头添加到响应中。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private CorsProcessor corsProcessor = new DefaultCorsProcessor();</span><br></pre></td></tr></table></figure>
</li>
<li><p>corsConfigSource</p>
<p>  根据路径模式上映射的CorsConfiguration集合提供每个请求的CorsConfiguration实例。支持精确的路径映射URI（如“/ admin”）以及Ant样式的路径模式（如“/ admin / **”）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private final UrlBasedCorsConfigurationSource corsConfigSource </span><br><span class="line">= new UrlBasedCorsConfigurationSource();</span><br></pre></td></tr></table></figure>
</li>
<li><p>跨域相关问题</p>
</li>
</ul>
<p>CorsConfiguration 具体封装跨域配置信息的pojo<br><br>CorsConfigurationSource request与跨域配置信息映射的容器<br><br>CorsProcessor 具体进行跨域操作的类<br></p>
<h2 id="3-AbstractHandlerMapping-中的get-amp-set方法"><a href="#3-AbstractHandlerMapping-中的get-amp-set方法" class="headerlink" title="3.AbstractHandlerMapping 中的get&amp;set方法"></a>3.AbstractHandlerMapping 中的get&amp;set方法</h2><h3 id="3-1-setOrder"><a href="#3-1-setOrder" class="headerlink" title="3.1 setOrder"></a>3.1 setOrder</h3><p>指定此HandlerMapping bean的排序值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final void setOrder(int order) &#123;</span><br><span class="line">  this.order = order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-2-setDefaultHandler"><a href="#3-2-setDefaultHandler" class="headerlink" title="3.2 setDefaultHandler"></a>3.2 setDefaultHandler</h3><p>指定此HandlerMapping bean的排序值。<br>设置此处理程序映射的默认处理程序。<br>如果没有找到特定的映射，这个处理程序将被返回。<br>缺省值为null，表示没有默认处理程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void setDefaultHandler(Object defaultHandler) &#123;</span><br><span class="line">	this.defaultHandler = defaultHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-3-getDefaultHandler"><a href="#3-3-getDefaultHandler" class="headerlink" title="3.3 getDefaultHandler"></a>3.3 getDefaultHandler</h3><p>返回此处理程序映射的默认处理程序，如果没有，则返回null。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object getDefaultHandler() &#123;</span><br><span class="line">	return this.defaultHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-4-setAlwaysUseFullPath"><a href="#3-4-setAlwaysUseFullPath" class="headerlink" title="3.4 setAlwaysUseFullPath"></a>3.4 setAlwaysUseFullPath</h3><p>如果URL查找始终使用当前servlet上下文中的完整路径，请进行设置。 否则，如果适用，则使用当前servlet映射中的路径（即，在web.xml中“… / *”servlet映射的情况下）。<br>默认是“false”。setAlwaysUseFullPath中的实现具体是委托给urlPathHelper和corsConfigSource来完成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setAlwaysUseFullPath(boolean alwaysUseFullPath) &#123;</span><br><span class="line">	this.urlPathHelper.setAlwaysUseFullPath(alwaysUseFullPath);</span><br><span class="line">	this.corsConfigSource.setAlwaysUseFullPath(alwaysUseFullPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-5-setUrlDecode"><a href="#3-5-setUrlDecode" class="headerlink" title="3.5 setUrlDecode"></a>3.5 setUrlDecode</h3><p>如果上下文路径和请求URI应该被URL解码，则设置。两者都是由Servlet API返回“undecoded”，与servlet路径相反。根据Servlet规范（ISO-8859-1）使用请求编码或默认编码。setUrlDecode中的实现具体是委托给urlPathHelper和corsConfigSource来完成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setUrlDecode(boolean urlDecode) &#123;</span><br><span class="line">	this.urlPathHelper.setUrlDecode(urlDecode);</span><br><span class="line">	this.corsConfigSource.setUrlDecode(urlDecode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-6-setRemoveSemicolonContent"><a href="#3-6-setRemoveSemicolonContent" class="headerlink" title="3.6 setRemoveSemicolonContent"></a>3.6 setRemoveSemicolonContent</h3><p>如果“;” （分号）内容应该从请求URI中去除,则设置。默认值是true。setRemoveSemicolonContent中的实现具体是委托给urlPathHelper和corsConfigSource来完成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setRemoveSemicolonContent(boolean removeSemicolonContent) &#123;</span><br><span class="line">	this.urlPathHelper.setRemoveSemicolonContent(removeSemicolonContent);</span><br><span class="line">	this.corsConfigSource.setRemoveSemicolonContent(removeSemicolonContent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-7-setUrlPathHelper"><a href="#3-7-setUrlPathHelper" class="headerlink" title="3.7 setUrlPathHelper"></a>3.7 setUrlPathHelper</h3><p>设置UrlPathHelper以用于解析查找路径。<br>使用它可以用自定义子类覆盖默认的UrlPathHelper，或者跨多个HandlerMappings和MethodNameResolvers共享通用的UrlPathHelper设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void setUrlPathHelper(UrlPathHelper urlPathHelper) &#123;</span><br><span class="line">	Assert.notNull(urlPathHelper, &quot;UrlPathHelper must not be null&quot;);</span><br><span class="line">	this.urlPathHelper = urlPathHelper;</span><br><span class="line">	this.corsConfigSource.setUrlPathHelper(urlPathHelper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-8-getUrlPathHelper"><a href="#3-8-getUrlPathHelper" class="headerlink" title="3.8 getUrlPathHelper"></a>3.8 getUrlPathHelper</h3><p>返回UrlPathHelper实现以用于解析查找路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public UrlPathHelper getUrlPathHelper() &#123;</span><br><span class="line">	return urlPathHelper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-9-setPathMatcher"><a href="#3-9-setPathMatcher" class="headerlink" title="3.9 setPathMatcher"></a>3.9 setPathMatcher</h3><p>将PathMatcher实现设置为用于匹配注册的URL模式的URL路径。 默认是AntPathMatcher。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void setPathMatcher(PathMatcher pathMatcher) &#123;</span><br><span class="line">	Assert.notNull(pathMatcher, &quot;PathMatcher must not be null&quot;);</span><br><span class="line">	this.pathMatcher = pathMatcher;</span><br><span class="line">	this.corsConfigSource.setPathMatcher(pathMatcher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-10-setInterceptors"><a href="#3-10-setInterceptors" class="headerlink" title="3.10 setInterceptors"></a>3.10 setInterceptors</h3><p>设置拦截器以应用此处理程序映射映射的所有处理程序。<br>支持的拦截器类型是<strong>HandlerInterceptor，WebRequestInterceptor和MappedInterceptor。</strong><br>映射拦截器仅适用于请求与其路径模式相匹配的URL。映射的拦截器Bean在初始化期间也会按类型检测到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ublic void setInterceptors(Object... interceptors) &#123;</span><br><span class="line">	this.interceptors.addAll(Arrays.asList(interceptors));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>其他几个get&amp;set方法就不列出来了，有兴趣的小伙伴可以自行阅读...</code></p>
<h2 id="4-AbstractHandlerMapping的创建"><a href="#4-AbstractHandlerMapping的创建" class="headerlink" title="4. AbstractHandlerMapping的创建"></a>4. AbstractHandlerMapping的创建</h2><p>因为AbstractHandlerMapping继承了WebApplicationObjectSupport类，因此AbstractHandlerMapping的创建就是依托于模板方法initApplicationContext来完成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void initApplicationContext() throws BeansException &#123;</span><br><span class="line">	extendInterceptors(this.interceptors);</span><br><span class="line">	detectMappedInterceptors(this.adaptedInterceptors);</span><br><span class="line">	initInterceptors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从方法结构可以了解到，initApplicationContext中包括三个子处理方法。</p>
<ul>
<li>extendInterceptors：这也是一个模板方法，在AbstractHandlerMapping中并没有具体实现（方法体是空的），主要是用于给子类提供一个添加（修改）Interceptors的入口（现有的SpringMVC实现中均未使用）。</li>
<li><p>detectMappedInterceptors：用于将SpringMVC容器及父容器中的所有MappedInterceptor类型的Bean添加到MappedInterceptors属性中。</p>
<p>  <code>检测MappedInterceptor类型的bean，并将它们添加到映射的拦截器列表中。
  除了可能通过setInterceptors提供的任何MappedInterceptors之外，还会调用此方法，默认情况下将从当前上下文及其祖先中添加所有MappedInterceptor类型的Bean。子类可以覆盖和优化这个策略。</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void detectMappedInterceptors(List&lt;HandlerInterceptor&gt; mappedInterceptors) &#123;</span><br><span class="line">	mappedInterceptors.addAll(</span><br><span class="line">			BeanFactoryUtils.beansOfTypeIncludingAncestors(</span><br><span class="line">					getApplicationContext(), MappedInterceptor.class, true, false).values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>initInterceptors：初始化指定的拦截器，检查MappedInterceptors并根据需要调整HandlerInterceptors和WebRequestInterceptors。（当前Spring版本时4.3.6） </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void initInterceptors() &#123;</span><br><span class="line">    if (!this.interceptors.isEmpty()) &#123;</span><br><span class="line">    	for (int i = 0; i &lt; this.interceptors.size(); i++) &#123;</span><br><span class="line">    		Object interceptor = this.interceptors.get(i);</span><br><span class="line">    		if (interceptor == null) &#123;</span><br><span class="line">    			throw new IllegalArgumentException(&quot;Entry number &quot; + i + &quot; in interceptors array is null&quot;);</span><br><span class="line">    		&#125;</span><br><span class="line">    		this.adaptedInterceptors.add(adaptInterceptor(interceptor));</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个是4.1.5版本的initInterceptors方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected void initInterceptors() &#123;</span><br><span class="line">    if (!this.interceptors.isEmpty()) &#123;</span><br><span class="line">    	for (int i = 0; i &lt; this.interceptors.size(); i++) &#123;</span><br><span class="line">    		Object interceptor = this.interceptors.get(i);</span><br><span class="line">    		if (interceptor == null) &#123;</span><br><span class="line">    			throw new IllegalArgumentException(&quot;Entry number &quot; + i + &quot; in interceptors array is null&quot;);</span><br><span class="line">    		&#125;</span><br><span class="line">    		if (interceptor instanceof MappedInterceptor) &#123;</span><br><span class="line">    			this.mappedInterceptors.add((MappedInterceptor) interceptor);</span><br><span class="line">    		&#125;</span><br><span class="line">    		else &#123;</span><br><span class="line">    			this.adaptedInterceptors.add(adaptInterceptor(interceptor));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>在4.1.5中版本中，initInterceptors的工作是将interceptors属性里面所包含的对象按照类型添加到adaptedInterceptors或者mappedInterceptors中。在4.1.5版本中mappedInterceptors是AbstractHandlerMapping的属性之一。主要原因是因为，springMVC自4.2开始添加了跨域的支持，也就是上面属性中的后两个。PS：在阅读Spring相关源码时需要关注不同版本的变更及区别，不要只关注某一个版本，另外就是个人觉得阅读源码的关注点应该在编码方式、设计模式使用、设计思想及理念，而不仅仅是知道他是如何实现的】</code></p>
<p>这里顺便说下mappedInterceptors的作用：mappedInterceptors中的拦截器在使用时需要与请求的url进行匹配，只有匹配成功后才会添加到getHandler的返回值HandlerExecytionChain里。</p>
<p><strong>adaptInterceptor方法:</strong></p>
<p>使给定的拦截器对象适配HandlerInterceptor接口。默认情况下，支持的拦截器类型是HandlerInterceptor和WebRequestInterceptor。每个给定的WebRequestInterceptor将被封装在WebRequestHandlerInterceptorAdapter中。可以在子类中重写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected HandlerInterceptor adaptInterceptor(Object interceptor) &#123;</span><br><span class="line">	if (interceptor instanceof HandlerInterceptor) &#123;</span><br><span class="line">		return (HandlerInterceptor) interceptor;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (interceptor instanceof WebRequestInterceptor) &#123;</span><br><span class="line">		return new WebRequestHandlerInterceptorAdapter((WebRequestInterceptor) interceptor);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		throw new IllegalArgumentException(&quot;Interceptor type not supported: &quot; + interceptor.getClass().getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-Handler和Interceptor的获取"><a href="#5-Handler和Interceptor的获取" class="headerlink" title="5.Handler和Interceptor的获取"></a>5.Handler和Interceptor的获取</h2><p>HandlerMapping是通过getHandler方法来获取Handler和Interceptor的。因此在抽象基类AbstractHandlerMapping中提供了具体的实现。并且在AbstractHandlerMapping中，getHandler使用final关键字修饰的，也就是说，子类不能再进行对此方法进行覆盖重写了。</p>
<p>getHandler的作用就是查找给定请求的handler，如果找不到特定请求，则返回到默认handler。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">	//通过getHandlerInternal方法来获取handler</span><br><span class="line">	Object handler = getHandlerInternal(request);</span><br><span class="line">	//如果前一个方法没有获取到，则使用默认的handler</span><br><span class="line">	if (handler == null) &#123;</span><br><span class="line">	    //默认的Handler就是AbstractHandlerMapping中的handler属性通过set得到的值</span><br><span class="line">		handler = getDefaultHandler();</span><br><span class="line">	&#125;</span><br><span class="line">	//如果还是没有找到Hander，则直接返回Null</span><br><span class="line">	if (handler == null) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	// Bean name or resolved handler?</span><br><span class="line">	//如果找到的handler是String类型的，</span><br><span class="line">	if (handler instanceof String) &#123;</span><br><span class="line">	    //则以它为名到spring Mvc的容器中查找相应的Bean</span><br><span class="line">		String handlerName = (String) handler;</span><br><span class="line">		handler = getApplicationContext().getBean(handlerName);</span><br><span class="line">	&#125;</span><br><span class="line">    //先根据handler和request创建一个HandlerExecutionChain对象，</span><br><span class="line">	HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</span><br><span class="line">	if (CorsUtils.isCorsRequest(request)) &#123;</span><br><span class="line">		CorsConfiguration globalConfig = this.corsConfigSource.getCorsConfiguration(request);</span><br><span class="line">		CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);</span><br><span class="line">		CorsConfiguration config = (globalConfig != null ? globalConfig.combine(handlerConfig) : handlerConfig);</span><br><span class="line">		executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">	&#125;</span><br><span class="line">	return executionChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>getHandlerInternal</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected abstract Object getHandlerInternal(HttpServletRequest request) throws Exception;</span><br></pre></td></tr></table></figure>
<p>查找给定请求的handler，如果找不到特定请求，则返回null。 这个方法被getHandler调用; 如果设置了null返回值，将导致默认handler。<br>在CORS pre-flight请求上，这个方法应该返回一个不匹配飞行前请求的匹配项，而是根据URL路径，“Access-Control-Request-Method”头中的HTTP方法和头文件 从“Access-Control-Request-Headers”头部获得，从而允许CORS配置通过getCorsConfigurations获得，<br>注意：这个方法也可以返回一个预先构建的HandlerExecutionChain，将一个处理程序对象与动态确定的拦截器组合在一起。状态指定的拦截器将被合并到这个现有的链中。</p>
<p><strong>getHandlerExecutionChain</strong>：</p>
<p>getLookupPathForRequest:返回给定请求的映射查找路径，如果适用的话，在当前的servlet映射中，或者在web应用程序中返回。如果在RequestDispatcher中调用include请求，则检测包含请求URL。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) &#123;</span><br><span class="line">    //如果handler是HandlerExecutionChain类型则直接强转为HandlerExecutionChain类型，</span><br><span class="line">        //如果不是则根据handler创建一个新的HandlerExecutionChain实例对象</span><br><span class="line">	HandlerExecutionChain chain = (handler instanceof HandlerExecutionChain ?</span><br><span class="line">			(HandlerExecutionChain) handler : new HandlerExecutionChain(handler));</span><br><span class="line">    //返回给定请求的映射查找路径</span><br><span class="line">	String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);</span><br><span class="line">	//遍历当前adaptedInterceptors链表</span><br><span class="line">	for (HandlerInterceptor interceptor : this.adaptedInterceptors) &#123;</span><br><span class="line">	    //如果是MappedInterceptor类型则</span><br><span class="line">		if (interceptor instanceof MappedInterceptor) &#123;</span><br><span class="line">			MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;</span><br><span class="line">			//拦截器是否应用于给定的请求路径，如果是则返回true</span><br><span class="line">			if (mappedInterceptor.matches(lookupPath, this.pathMatcher)) &#123;</span><br><span class="line">				chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			chain.addInterceptor(interceptor);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为给定的handler构建一个HandlerExecutionChain，包括可用的拦截器。默认实现用给定的handler，handler映射的通用拦截器以及与当前请求URL相匹配的任何MappedInterceptors构建标准的HandlerExecutionChain。拦截器按照他们注册的顺序添加。为了扩展/重新排列拦截器列表，子类可以覆盖它。<br></p>
<p>需要注意的是，传入的handler对象可能是原始handler或预构建的HandlerExecutionChain。这个方法应该明确地处理这两种情况，建立一个新的HandlerExecutionChain或者扩展现有的链。为了简单地在自定义子类中添加拦截器，可以考虑调用super.getHandlerExecutionChain（handler，request）并在返回的链对象上调用HandlerExecutionChain＃addInterceptor。</p>
<p><strong>getCorsHandlerExecutionChain</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected HandlerExecutionChain getCorsHandlerExecutionChain(HttpServletRequest request,</span><br><span class="line">		HandlerExecutionChain chain, CorsConfiguration config) &#123;</span><br><span class="line">    //通过请求头的http方法是否options判断是否预请求，</span><br><span class="line">	if (CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">		HandlerInterceptor[] interceptors = chain.getInterceptors();</span><br><span class="line">		//如果是使用PreFlightRequest替换处理器</span><br><span class="line">		chain = new HandlerExecutionChain(new PreFlightHandler(config), interceptors);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">    	//如果是普通请求，添加一个拦截器CorsInterceptor。</span><br><span class="line">		chain.addInterceptor(new CorsInterceptor(config));</span><br><span class="line">	&#125;</span><br><span class="line">	return chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新HandlerExecutionChain进行与CORS（HTTP访问控制：跨域资源共享）相关的处理。</p>
<ul>
<li>对于pre-flight请求，默认实现用一个简单的HttpRequestHandler来替换选择的handler，该HttpRequestHandler调用已配置的setCorsProcessor。（将处理器替换为内部类PreFlightHandler）</li>
<li>对于普通的请求，默认实现插入一个HandlerInterceptor，它执行与CORS有关的检查并添加CORS头。（添加CorsInterceptor拦截器）</li>
</ul>
<h2 id="AbstractHandlerMapping中的两个内部类"><a href="#AbstractHandlerMapping中的两个内部类" class="headerlink" title="AbstractHandlerMapping中的两个内部类"></a>AbstractHandlerMapping中的两个内部类</h2><p>这两个内部类就是用来校验request是否cors，并封装对应的Adapter的。</p>
<ul>
<li>PreFlightRequest是CorsProcessor对于HttpRequestHandler的一个适配器。这样HandlerAdapter直接使用HttpRequestHandlerAdapter处理。</li>
<li>CorsInterceptor 是CorsProcessor对于HandlerInterceptorAdapter的适配器。</li>
</ul>
<p>具体的类信息如下：</p>
<h3 id="PreFlightHandler"><a href="#PreFlightHandler" class="headerlink" title="PreFlightHandler"></a>PreFlightHandler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private class PreFlightHandler implements HttpRequestHandler, CorsConfigurationSource &#123;</span><br><span class="line"></span><br><span class="line">	private final CorsConfiguration config;</span><br><span class="line"></span><br><span class="line">	public PreFlightHandler(CorsConfiguration config) &#123;</span><br><span class="line">		this.config = config;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;</span><br><span class="line">		corsProcessor.processRequest(this.config, request, response);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public CorsConfiguration getCorsConfiguration(HttpServletRequest request) &#123;</span><br><span class="line">		return this.config;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CorsInterceptor"><a href="#CorsInterceptor" class="headerlink" title="CorsInterceptor"></a>CorsInterceptor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private class CorsInterceptor extends HandlerInterceptorAdapter implements CorsConfigurationSource &#123;</span><br><span class="line"></span><br><span class="line">	private final CorsConfiguration config;</span><br><span class="line"></span><br><span class="line">	public CorsInterceptor(CorsConfiguration config) &#123;</span><br><span class="line">		this.config = config;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</span><br><span class="line">			throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		return corsProcessor.processRequest(this.config, request, response);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public CorsConfiguration getCorsConfiguration(HttpServletRequest request) &#123;</span><br><span class="line">		return this.config;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此AbstractHandlerMapping中的一些源码就结束了，AbstractHandlerMapping为HandlerMapping的功能提供的一些具体的模板描述，但是具体的细节实现还需要从其子类中来慢慢分析。关于这部分中涉及到的如HandlerExecutionChain，cors跨域等问题，后面会根据实际情况另开篇幅来学习。</p>
<p><code>大家如果有什么意见或者建议可以在下方评论区留言，也可以给我们发邮件（glmapper_2018@163.com）!欢迎小伙伴与我们一起交流，一起成长。</code></p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/spring-base-webmvc2/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/spring-base-webmvc1/">SpringMVC源码系列：HandlerMapping</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T06:01:34.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/spring-base-webmvc1/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/web/" title="web">web</a>,
  
    <a href="/tags/mvc/" title="mvc">mvc</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>HandlerMapping接口是用来查找Handler的。在SpringMvc中，DispatcherServlet处理分发很多请求，而每个请求都需要一个Handler来处理，具体接受到一个请求后使用哪个Handler来处理呢？这就是Handler要做的事情。因此，HandlerMapping的作用就是根据request找到相应的处理器Handler和Interceptors。</p>
<p>下面是Spring中对HandlerMapping接口的说明：</p>
<p><code>This class can be implemented by application developers, although this is not necessary, as BeanNameUrlHandlerMapping and DefaultAnnotationHandlerMapping are included in the framework. The former is the default if no HandlerMapping bean is registered in the application context.</code><br><br>这个类可以由应用程序开发人员实现，尽管这不是必须的，因为BeanNameUrlHandlerMapping和DefaultAnnotationHandlerMapping已经包含在框架中，作为HandlerMapping的默认实现。 如果在应用程序上下文中没有注册HandlerMapping bean，BeanNameUrlHandlerMapping是默认值。</p>
<p><code>HandlerMapping implementations can support mapped interceptors but do not have to. A handler will always be wrapped in a HandlerExecutionChain instance, optionally accompanied by some HandlerInterceptor instances.The DispatcherServlet will first call each HandlerInterceptor&#39;s preHandle  method in the given order, finally invoking the handler itself if all preHandle methods have returned true</code><br><br>HandlerMapping实现可以支持映射的拦截器，但不必如此；handler将始终被封装在HandlerExecutionChain实例中，并可由一些HandlerInterceptor实例执行。在给定的顺序中，DispatcherServlet将首先调用每个HandlerInterceptor的preHandle方法，如果所有的preHandle方法都返回true，那么最后调用handler本身。</p>
<p><code>The ability to parameterize this mapping is a powerful and unusual capability of this MVC framework. For example, it is possible to write a custom mapping based on session state, cookie state or many other variables. No other MVC framework seems to be equally flexible.</code><br><br>参数化这个映射的能力是这个MVC框架的一个强大且不同寻常的能力。 例如，可以根据会话状态，cookie状态或许多其他变量编写自定义映射。 没有其他MVC框架似乎同样灵活。</p>
<p><code>Note: Implementations can implement the Ordered interface to be able to specify a sorting order and thus a priority for getting applied by DispatcherServlet. Non-Ordered instances get treated as lowest priority.</code><br><br>注：实现可以实现Ordered接口，以便能够指定排序顺序，从而指定由DispatcherServlet应用的优先级。 无序实例被视为最低优先级。</p>
<h2 id="1-接口常量"><a href="#1-接口常量" class="headerlink" title="1.接口常量"></a>1.接口常量</h2><h3 id="1-1、PATH-WITHIN-HANDLER-MAPPING-ATTRIBUTE"><a href="#1-1、PATH-WITHIN-HANDLER-MAPPING-ATTRIBUTE" class="headerlink" title="1.1、PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE"></a>1.1、PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE</h3><p>HttpServletRequest属性的名称，它包含处理程序映射中的路径，比如模式匹配，或者完全相关的URI(通常在DispatcherServlet的映射中)。此属性不需要所有HandlerMapping实现支持。基于url的HandlerMappings通常会支持它，但是处理程序不应该期望这个请求属性在所有场景中都存在。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Name of the &#123;@link HttpServletRequest&#125; attribute that contains the path</span><br><span class="line"> * within the handler mapping, in case of a pattern match, or the full</span><br><span class="line"> * relevant URI (typically within the DispatcherServlet&apos;s mapping) else.</span><br><span class="line"> * &lt;p&gt;Note: This attribute is not required to be supported by all</span><br><span class="line"> * HandlerMapping implementations. URL-based HandlerMappings will</span><br><span class="line"> * typically support it, but handlers should not necessarily expect</span><br><span class="line"> * this request attribute to be present in all scenarios.</span><br><span class="line"> */</span><br><span class="line">String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.pathWithinHandlerMapping&quot;;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-2、BEST-MATCHING-PATTERN-ATTRIBUTE"><a href="#1-2、BEST-MATCHING-PATTERN-ATTRIBUTE" class="headerlink" title="1.2、BEST_MATCHING_PATTERN_ATTRIBUTE"></a>1.2、BEST_MATCHING_PATTERN_ATTRIBUTE</h3><p>HttpServletRequest属性的名称，包括处理程序映射中的最佳匹配模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Name of the &#123;@link HttpServletRequest&#125; attribute that contains the</span><br><span class="line"> * best matching pattern within the handler mapping.</span><br><span class="line"> * &lt;p&gt;Note: This attribute is not required to be supported by all</span><br><span class="line"> * HandlerMapping implementations. URL-based HandlerMappings will</span><br><span class="line"> * typically support it, but handlers should not necessarily expect</span><br><span class="line"> * this request attribute to be present in all scenarios.</span><br><span class="line"> */</span><br><span class="line">String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.bestMatchingPattern&quot;;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-3、INTROSPECT-TYPE-LEVEL-MAPPING"><a href="#1-3、INTROSPECT-TYPE-LEVEL-MAPPING" class="headerlink" title="1.3、INTROSPECT_TYPE_LEVEL_MAPPING"></a>1.3、INTROSPECT_TYPE_LEVEL_MAPPING</h3><p>HttpServletRequest属性的名称，指示是否应该检查类型级别的映射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Name of the boolean &#123;@link HttpServletRequest&#125; attribute that indicates</span><br><span class="line"> * whether type-level mappings should be inspected.</span><br><span class="line"> * &lt;p&gt;Note: This attribute is not required to be supported by all</span><br><span class="line"> * HandlerMapping implementations.</span><br><span class="line"> */</span><br><span class="line">String INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.class.getName() + &quot;.introspectTypeLevelMapping&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="1-4、URI-TEMPLATE-VARIABLES-ATTRIBUTE"><a href="#1-4、URI-TEMPLATE-VARIABLES-ATTRIBUTE" class="headerlink" title="1.4、URI_TEMPLATE_VARIABLES_ATTRIBUTE"></a>1.4、URI_TEMPLATE_VARIABLES_ATTRIBUTE</h3><p>包含URI模板映射的HttpServletRequest属性的名称，将变量名称映射到值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Name of the &#123;@link HttpServletRequest&#125; attribute that contains the URI</span><br><span class="line"> * templates map, mapping variable names to values.</span><br><span class="line"> * &lt;p&gt;Note: This attribute is not required to be supported by all</span><br><span class="line"> * HandlerMapping implementations. URL-based HandlerMappings will</span><br><span class="line"> * typically support it, but handlers should not necessarily expect</span><br><span class="line"> * this request attribute to be present in all scenarios.</span><br><span class="line"> */</span><br><span class="line">String URI_TEMPLATE_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.uriTemplateVariables&quot;;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-5、MATRIX-VARIABLES-ATTRIBUTE"><a href="#1-5、MATRIX-VARIABLES-ATTRIBUTE" class="headerlink" title="1.5、MATRIX_VARIABLES_ATTRIBUTE"></a>1.5、MATRIX_VARIABLES_ATTRIBUTE</h3><p>包含带有URI矩阵变量的映射的HttpServletRequest属性的名称。此属性不需要所有HandlerMapping实现支持，也可能不存在，这取决于HandlerMapping是否被配置为在请求URI中保留矩阵变量内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Name of the &#123;@link HttpServletRequest&#125; attribute that contains a map with</span><br><span class="line"> * URI matrix variables.</span><br><span class="line"> * &lt;p&gt;Note: This attribute is not required to be supported by all</span><br><span class="line"> * HandlerMapping implementations and may also not be present depending on</span><br><span class="line"> * whether the HandlerMapping is configured to keep matrix variable content</span><br><span class="line"> * in the request URI.</span><br><span class="line"> */</span><br><span class="line">String MATRIX_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.matrixVariables&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="1-6、PRODUCIBLE-MEDIA-TYPES-ATTRIBUTE"><a href="#1-6、PRODUCIBLE-MEDIA-TYPES-ATTRIBUTE" class="headerlink" title="1.6、PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE"></a>1.6、PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE</h3><p>HttpServletRequest属性的名称，该属性包含可用于映射处理程序的可生成的MediaTypes集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Name of the &#123;@link HttpServletRequest&#125; attribute that contains the set of</span><br><span class="line"> * producible MediaTypes applicable to the mapped handler.</span><br><span class="line"> * &lt;p&gt;Note: This attribute is not required to be supported by all</span><br><span class="line"> * HandlerMapping implementations. Handlers should not necessarily expect</span><br><span class="line"> * this request attribute to be present in all scenarios.</span><br><span class="line"> */</span><br><span class="line">String PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.producibleMediaTypes&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="2-核心方法"><a href="#2-核心方法" class="headerlink" title="2.核心方法"></a>2.核心方法</h2><p>HandlerMapping接口中只有一个方法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;</span><br></pre></td></tr></table></figure></p>
<p>从方法定义可以看出，getHandler方法就是通过request来获取一个HandlerExecutionChain；该方法在不同的子类中都有实现，具体的实现后面说子类的时候在详细分析。</p>
<h2 id="3-HandlerMapping的子类"><a href="#3-HandlerMapping的子类" class="headerlink" title="3.HandlerMapping的子类"></a>3.HandlerMapping的子类</h2><p><img src="https://user-gold-cdn.xitu.io/2018/1/10/160de1fc214fe76d?w=1298&amp;h=974&amp;f=png&amp;s=35893" alt=""><br><code>图中黄色部分表示已经过时的类，时间开发中不建议再使用。</code></p>
<p>在HandlerMapping的体系中可以看出，HandlerMapping下属子类可分为两个分支；</p>
<ul>
<li>AbstractHandlerMethodMapping</li>
<li>AbstractUrlHandlerMapping</li>
</ul>
<p>上述两个抽象类又均是AbstractHandlerMapping的子类。关于AbstractHandlerMapping我们下篇文章来学习。</p>
<p><code>大家如果有什么意见或者建议可以在下方评论区留言，也可以给我们发邮件（glmapper_2018@163.com）!欢迎小伙伴与我们一起交流，一起成长。</code></p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/spring-base-webmvc1/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
    </div>
    
      <div id="page-nav" class="pagination">
	<span class="page-number current">1</span>
      </div>
    
  </section>

</div>

</div>

</section>
</div>

    <!-- BEGIN PRE-FOOTER -->
    <div class="pre-footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN BOTTOM ABOUT BLOCK -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>About Us</h2>
            <p>Computer Lab is a software development and marketing company based in Brooklyn, New York. <br><br> Computer Lab was founded in 2015, and is focused on so on and so forth.</p>
          </div>
          <!-- END BOTTOM ABOUT BLOCK -->

          <!-- BEGIN BOTTOM CONTACTS -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>Contact</h2>
            <address class="margin-bottom-40">
              140 Metropolitan Avenue<br>
              5th Floor<br>
              Brooklyn, NY 11249<br>
              Phone: 716-472-4484<br>
              Email: <a href="mailto:ptsteadman@gmail.com">ptsteadman@gmail.com</a><br>
            </address>
          </div>
          <!-- END BOTTOM CONTACTS -->

	
          <!-- BEGIN TWITTER BLOCK --> 
          <div class="col-md-4 col-sm-6 pre-footer-col">

	  <a data-tweet-limit="1" class="twitter-timeline" href="https://twitter.com/computerlab_" data-widget-id="678830341331820544">Tweets by @computerlab_</a>

	  <script>!function(d,s,id){var
	  js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

          </div>
          <!-- END TWITTER BLOCK -->
	
        </div>
      </div>
    </div>
    <!-- END PRE-FOOTER -->

    <!-- BEGIN FOOTER -->
    <div class="footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN COPYRIGHT -->
          <div class="col-md-6 col-sm-6 padding-top-10">
                  &copy; 2020 glmapper<br>
 <a href="javascript:;">Privacy Policy</a> | <a href="javascript:;">Terms of Service</a>
          </div>
          <!-- END COPYRIGHT -->
	  <!-- BEGIN SOCIAL -->
<div class="col-md-6 col-sm-6">
  <ul class="social-footer list-unstyled list-inline pull-right">
    
      <li><a href="https://github.com/ptsteadman"><i class="fa fa-github"></i></a></li>
    
      <li><a href="https://twitter.com/ptsteadman"><i class="fa fa-twitter"></i></a></li>
    
      <li><a href="https://www.facebook.com/ptsteadman"><i class="fa fa-facebook"></i></a></li>
    
      <li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li>
    
      <li><a href="https://linkedin.com/in/ptsteadman"><i class="fa fa-linkedin"></i></a></li>
    
      <li><a href="http://stackoverflow.com/users/2480493/patrick-steadman"><i class="fa fa-stackoverflow"></i></a></li>
    
  </ul>  
</div>
<!-- END SOCIAL -->

        </div>
      </div>
    </div>
    <!-- END FOOTER -->

  <!-- BEGIN CORE PLUGINS (REQUIRED FOR ALL PAGES) -->
<!--[if lt IE 9]>
<script src="/metronic/assets/plugins/respond.min.js"></script>
<![endif]--> 
<script src="/metronic/assets/plugins/jquery.min.js"></script>
<script src="/metronic/assets/plugins/jquery-migrate.min.js"></script>
<script src="/metronic/assets/plugins/bootstrap/js/bootstrap.min.js"></script>
<script src="/metronic/assets/corporate/scripts/back-to-top.js"></script>
<script src="/metronic/assets/plugins/owl.carousel/owl.carousel.min.js"></script>
<script src="/metronic/assets/corporate/scripts/layout.js"></script>
<script src="/js/wow.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script type="text/javascript">
    jQuery(document).ready(function() {
        Layout.init();    
        Layout.initOWL();
        Layout.initTwitter();
        Layout.initFixHeaderWithPreHeader(); /* Switch On Header Fixing (only if you have pre-header) */
        Layout.initNavScrolling(); 
	new WOW().init();
    });
</script>
<!-- END CORE PLUGINS -->

<!-- BEGIN PAGE-SPECIFIC PLUGINS --> 







<!-- END PAGE-SPECIFIC PLUGINS --> 

<!-- BEGIN INTEGRATIONS -->





<!-- END INTEGRATIONS -->

</body>
</html>
