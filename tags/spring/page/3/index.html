<!DOCTYPE html>
<!--[if IE 8]> <html lang="en" class="ie8 no-js"> <![endif]-->
<!--[if IE 9]> <html lang="en" class="ie9 no-js"> <![endif]-->
<!--[if !IE]><!-->
<html lang="en">
<!--<![endif]-->
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Tag: spring | glmapper</title>

  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <meta name="description" content="从平凡的世界中全身而退">
<meta property="og:type" content="website">
<meta property="og:title" content="glmapper">
<meta property="og:url" content="http://www.glmapper.com/tags/spring/page/3/index.html">
<meta property="og:site_name" content="glmapper">
<meta property="og:description" content="从平凡的世界中全身而退">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="glmapper">
<meta name="twitter:description" content="从平凡的世界中全身而退">
  
    <link rel="alternative" href="/atom.xml" title="glmapper" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
    
  <meta content="{{ title }}" name="description">
  <meta content="{{ title }}" name="keywords">
  <meta content="{{ title }}" name="author">

  <link href="http://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700|PT+Sans+Narrow|Source+Sans+Pro:200,300,400,600,700,900&amp;subset=all" rel="stylesheet" type="text/css">

  <!-- Global styles START -->   
  <link rel="stylesheet" href="/metronic/assets/plugins/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/bootstrap/css/bootstrap.min.css">
  <!-- Global styles END --> 
   
  <!-- Page level plugin styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/animate.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/owl.carousel/assets/owl.carousel.css">
  <!-- Page level plugin styles END -->

  <!-- Theme styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/components.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/slider.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/portfolio.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style-responsive.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/themes/red.css">
  <link rel="stylesheet" href="/css/theme-styles.css">
  <!-- Theme styles END -->
</head>
</html>
<body class="corporate">
  <!-- BEGIN TOP BAR -->
<div class="pre-header">
  <div class="container">
    <div class="row">
      <!-- BEGIN TOP BAR LEFT PART -->
      <div class="col-md-6 col-sm-6 col-xs-9 additional-shop-info">
	<ul class="list-unstyled list-inline">
	  <li><i class="fa fa-phone"></i><span>716-472-4484</span></li>
	  <li><i class="fa fa-envelope-o"></i><span>ptsteadman@gmail.com</span></li>
	</ul>
      </div>
      <!-- END TOP BAR LEFT PART -->
      <!-- BEGIN TOP BAR MENU -->
      <div class="col-md-6 col-sm-6 col-xs-3 additional-nav">
	<ul class="list-unstyled list-inline pull-right">
	  <li><a href="/login">Log In</a></li>
	</ul>
      </div>
      <!-- END TOP BAR MENU -->
    </div>
  </div>        
</div>
<!-- END TOP BAR -->
<!-- BEGIN HEADER -->
<div class="header">
  <div class="container">
    <!--<a class="site-logo" href="/" id="logo">glmapper</a>-->

    <a class="site-logo" href="/">
      <img src="/metronic/assets/corporate/img/logos/logo-corp-red.png" alt="Metronic FrontEnd">
    </a>

    <a href="javascript:void(0);" class="mobi-toggler"><i class="fa fa-bars"></i></a>

    <!-- BEGIN NAVIGATION -->
    <div class="header-navigation pull-right font-transform-inherit">
      <ul>
	
	<li class="">
	  <a href="/">Home</a>
	</li>
	
	<li class="">
	  <a href="/projects/">Projects</a>
	</li>
	
	<li class="">
	  <a href="/archives/">Blog</a>
	</li>
	
	<li class="">
	  <a href="/contact/">Contact</a>
	</li>
	
	<li class="">
	  <a href="/about/">About</a>
	</li>
	
	<!-- BEGIN TOP SEARCH -->
	<li class="menu-search">
	  <span class="sep"></span>
	  <i class="fa fa-search search-btn"></i>
	  <div class="search-box">
	    <form action="#">
	      <div class="input-group">
		<input type="text" placeholder="Search" class="form-control st-default-search-input">
		<span class="input-group-btn">
		  <button class="btn btn-primary" type="submit">Search</button>
		</span>
	      </div>
	    </form>
	  </div> 
	</li>
	<!-- END TOP SEARCH -->
      </ul>
    </div>
    <!-- END NAVIGATION -->
  </div>
</div>
<!-- Header END -->

  <div class="container">
  <ul class="breadcrumb">
    <li><a href="/">Home</a></li>
    <li><a href="/blog">Blog</a></li>
    <li class="active">Tagged: spring</li>
  </ul>
<section id="main">
  <h1>Tagged: spring</h1>
  <div class="row">

<div class="col-xs-12 blog-posts">


  <section class="archives-wrap">
    <div class="archives">
      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/spring-base-webmvc3/">SpringMVC系列源码：DispatcherServlet</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T06:03:59.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/spring-base-webmvc3/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/web/" title="web">web</a>,
  
    <a href="/tags/mvc/" title="mvc">mvc</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>前面两篇文章直接对SpringMVC里面的组件进行了源码分析，可能很多小伙伴都会觉得有点摸不着头脑。所以今天再岔回来说一说SpringMVC的核心控制器，以此为轴心来学习整个SpringMVC的知识体系。</p>
<h2 id="SpringMVC在项目中如何使用的？"><a href="#SpringMVC在项目中如何使用的？" class="headerlink" title="SpringMVC在项目中如何使用的？"></a>SpringMVC在项目中如何使用的？</h2><p>前面在《<a href="https://juejin.im/post/59f3ef5c51882534aa0691b2" target="_blank" rel="noopener">项目开发框架-SSM</a>》一篇文章中已经详细的介绍过了SSM项目中关于Spring的一些配置文件，对于一个Spring应用，必不可少的是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;param-value&gt;classpath*:config/applicationContext.xml&lt;/param-value&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置一个监听器将请求转发给 Spring框架 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring监听器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过ContextLoadListener来完成Spring容器的初始化以及Bean的装载《<a href="https://juejin.im/post/59a286866fb9a0249d616fbb" target="_blank" rel="noopener">Spring技术内幕学习：Spring的启动过程</a>》。那么如果在我们需要提供WEB功能，则还需要另外一个，那就是SpringMVC,当然我们同样需要一个用来初始化SpringMVC的配置（初始化9大组件的过程：前面两篇《<a href="https://juejin.im/post/5a55791c6fb9a01c975a2025" target="_blank" rel="noopener">SpringMVC源码系列：HandlerMapping</a>》和《<a href="https://juejin.im/post/5a558b1d6fb9a01cbd587b99" target="_blank" rel="noopener">SpringMVC源码系列：AbstractHandlerMapping</a>》是关于HnadlerMapping的，当然不仅仅这两个，还有其他几个重要的子类，后续会持续更新）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mvc-dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置springMVC需要加载的配置文件 spring-dao.xml,spring-service.xml,spring-web.xml </span></span><br><span class="line"><span class="comment">		Mybatis（如果有） - &gt; spring -&gt; springmvc --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mvc-dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 默认匹配所有的请求 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.htm<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当我们在web.xml中配置好上述内容（当然还得保证咱们的Spring的配置以及SpringMVC的配置文件没有问题的情况下），启动web容器（如jetty），就可以通过在浏览器输入诸如：<a href="http://localhost:80/myproject/index.do" target="_blank" rel="noopener">http://localhost:80/myproject/index.do</a> 的方式来访问我们的应用了。</p>
<p>俗话说知其然，之气所以然；那么为什么在配置好相关的配置文件之后，我们就能访问我们的SSM项目了呢？从发送一条那样的请求（<a href="http://localhost:80/myproject/index.do）展示出最后的界面，这个过程在，Spring帮我们做了哪些事情呢？（SpringIOC容器的初始化在《[Spring技术内幕-容器刷新：wac.refresh](https://juejin.im/post/5a3f5b43f265da432e5c37ea)》文中已经大概的说了下大家可以参考一下）" target="_blank" rel="noopener">http://localhost:80/myproject/index.do）展示出最后的界面，这个过程在，Spring帮我们做了哪些事情呢？（SpringIOC容器的初始化在《[Spring技术内幕-容器刷新：wac.refresh](https://juejin.im/post/5a3f5b43f265da432e5c37ea)》文中已经大概的说了下大家可以参考一下）</a></p>
<h2 id="SpringMVC处理请求的过程"><a href="#SpringMVC处理请求的过程" class="headerlink" title="SpringMVC处理请求的过程"></a>SpringMVC处理请求的过程</h2><p>先通过下面这张图来整个了解下SpringMVC请求处理的过程；图中从1-13，大体上描述了请求从发送到界面展示的这样一个过程。<br><img src="https://user-gold-cdn.xitu.io/2018/1/12/160e9cb552fb7aa0?w=935&amp;h=922&amp;f=png&amp;s=48045" alt=""><br>从上面这张图中，我们可以很明显的看到有一个DispatcherServlet这样一个类，处于各个请求处理过程中的分发站。实际上，在SpringMVC中，整个处理过程的顶层设计都在这里面。通常我们将DispatcherServlet称为SpringMVC的前端控制器，它是SpringMVC中最核心的类。下面我们就来揭开DispatcherServlet的面纱吧！</p>
<h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p>OK，我们直接来看DispatcherServlet的类定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">FrameworkServlet</span></span></span><br></pre></td></tr></table></figure></p>
<p>DispatcherServlet继承自FrameworkServlet，就这样？</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/12/160ea3f0d911990e?w=511&amp;h=300&amp;f=jpeg&amp;s=13176" alt=""></p>
<p>下面才是他家的族谱：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/12/160ea4067691d914?w=1056&amp;h=691&amp;f=png&amp;s=21550" alt=""></p>
<p>首先为什么要有绿色的部门，有的同学可能已经想到了，绿色部分不是Spring的，而是java自己的；Spring通过HttpServletBean这位年轻人成功的拥有了JAVA WEB 血统（本来Spring就是用JAVA写的，哈哈）。关于Servlet这个小伙伴可以看下我之前的文章，有简单的介绍了这个接口。</p>
<p>话说回来，既然DispatcherServlet归根揭底是一个Servlet，那么就肯定具有Servlet功能行为。</p>
<p><code>敲黑板！！！Servlet的生命周期是啥（init-&gt;service-&gt;destroy ： 加载-&gt;实例化-&gt;服务-&gt;销毁）。</code></p>
<p>其实这里我想说的就是service这个方法，当然，在DispatcherServlet中并没有service方法，但是它有一个doService方法！（引的好难…）</p>
<p>doService是DispatcherServlet的入口，我们来看下这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    	String resumed = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult() ? <span class="string">" resumed"</span> : <span class="string">""</span>;</span><br><span class="line">    	logger.debug(<span class="string">"DispatcherServlet with name '"</span> + getServletName() + <span class="string">"'"</span> + resumed +</span><br><span class="line">    			<span class="string">" processing "</span> + request.getMethod() + <span class="string">" request for ["</span> + getRequestUri(request) + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在include的情况下保留请求属性的快照，以便能够在include之后恢复原始属性。</span></span><br><span class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//确定给定的请求是否是包含请求，即不是从外部进入的顶级HTTP请求。</span></span><br><span class="line">    <span class="comment">//检查是否存在“javax.servlet.include.request_uri”请求属性。 可以检查只包含请求中的任何请求属性。</span></span><br><span class="line">    <span class="comment">//(可以看下面关于isIncludeRequest解释)</span></span><br><span class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">    	attributesSnapshot = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    	Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">    	<span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">    		String attrName = (String) attrNames.nextElement();</span><br><span class="line">    		<span class="keyword">if</span> (<span class="keyword">this</span>.cleanupAfterInclude || attrName.startsWith(<span class="string">"org.springframework.web.servlet"</span>)) &#123;</span><br><span class="line">    			attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使框架可用于handler和view对象。</span></span><br><span class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</span><br><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</span><br><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line">    <span class="comment">//FlashMap用于保存转发请求的参数的</span></span><br><span class="line">    FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">    <span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">    &#125;</span><br><span class="line">    request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span><br><span class="line">    request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	doDispatch(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">    		<span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line">    		<span class="keyword">if</span> (attributesSnapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">    			restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PS：“javax.servlet.include.request_uri”是INCLUDE_REQUEST_URI_ATTRIBUTE常量的值。isIncludeRequest(request)方法的作用我们可以借助一条JSP的指令来理解：</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:incluede page=<span class="string">"index.jsp"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p><code>这条指令是指在一个页面中嵌套了另一个页面，那么我们知道JSP在运行期间是会被编译成相应的Servlet类来运行的，所以在Servlet中也会有类似的功能和调用语法，这就是RequestDispatch.include()方法。
那么在一个被别的servlet使用RequestDispatcher的include方法调用过的servlet中，如果它想知道那个调用它的servlet的上下文信息该怎么办呢，那就可以通过request中的attribute中的如下属性获取：</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javax.servlet.include.request_uri</span><br><span class="line">javax.servlet.include.context_path</span><br><span class="line">javax.servlet.include.servlet_path</span><br><span class="line">javax.servlet.include.path_info</span><br><span class="line">javax.servlet.include.query_string</span><br></pre></td></tr></table></figure>
<p>在doService中，下面的try块中可以看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    doDispatch(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doService并没有直接进行处理，二是将请求交给了doDispatch进行具体的处理。当然在调用doDispatch之前，doService也是做了一些事情的，比如说判断请求是不是inclde请求，设置一些request属性等。</p>
<h2 id="FlashMap支撑的Redirect参数传递问题"><a href="#FlashMap支撑的Redirect参数传递问题" class="headerlink" title="FlashMap支撑的Redirect参数传递问题"></a>FlashMap支撑的Redirect参数传递问题</h2><p>在doService中除了webApplicationContext、localeResolver、themeResolve和themeSource四个提供给handler和view使用的四个参数外，后面的三个都是和FlashMap有关的，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FlashMap用于保存转发请求的参数的</span></span><br><span class="line">FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line"><span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">	request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">&#125;</span><br><span class="line">request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span><br><span class="line">request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span><br></pre></td></tr></table></figure></p>
<p>注释中提到，FlashMap主要用于Redirect转发时参数的传递；</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/13/160ed457b177f8c3?w=423&amp;h=149&amp;f=jpeg&amp;s=6126" alt=""><br>就拿表单重复提交这个问题来说,一种方案就是：在处理完post请求之后，然后Redirect到一个get的请求，这样即使用户刷新也不会有重复提交的问题。但是问题在于,前面的post请求时提交订单，提交完后redirect到一个显示订单的页面，显然在显示订单的页面我们需要知道订单的信息，但是redirect本身是没有参数传递功能的，按照普通的模式如果想传递参数，就只能将参数拼接在url中，但是url在get请求下又是有长度限制的；另外，对于一些场景下，我们也不希望自己的参数暴露在url中。</p>
<p>对于上述问题，我们就可以用FlashMap来进行参数传递了；我们需要在redirect之前将需要的参数写入OUTPUT_FLASH_MAP_ATTRIBUTE，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ServletRequestAttributes SRAttributes = (ServletRequestAttributes)(RequestContextHolder.getRequestAttributes());</span><br><span class="line">HttpServletRequest req = SRAttributes.getRequest();</span><br><span class="line">FlashMap flashMap = (FlashMap)(req.getAttribute(DispatcherServlet.OUTPUT_FLASH_MAP_ATTRIBUTE));</span><br><span class="line">flashMap.put(<span class="string">"myname"</span>,<span class="string">"glmapper_2018"</span>);</span><br></pre></td></tr></table></figure>
<p>这样在redirect之后的handler中spring就会自动将其设置到model里面。但是如果仅仅是这样，每次redirect时都写上面那样一段代码是不是又显得很鸡肋呢？当然，spring也为我们提供了更加方便的用法，即在我们的handler方法的参数中使用RedirectAttributes类型变量即可（前段时间用到这个，本来是想单独写一篇关于参数传递问题的，借此机会就省略一篇吧，吼吼…），来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/detail/&#123;productId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">detail</span><span class="params">(HttpServletRequest request,HttpServletResponse </span></span></span><br><span class="line"><span class="function"><span class="params">    response,RedirectAttributes attributes, @PathVariable String productId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotBlank(productId)) &#123;</span><br><span class="line">	logger.info(<span class="string">"[产品详情]:detail = &#123;&#125;"</span>,JSONObject.toJSONString(map));</span><br><span class="line">	mv.addObject(<span class="string">"detail"</span>,JSONObject.toJSONString(getDetail(productId)));</span><br><span class="line">	mv.addObject(<span class="string">"title"</span>, <span class="string">"详情"</span>);</span><br><span class="line">	mv.setViewName(<span class="string">"detail.ftl"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果没有获取到productId</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">	attributes.addFlashAttribute(<span class="string">"msg"</span>, <span class="string">"产品不存在"</span>);</span><br><span class="line">	attributes.addFlashAttribute(<span class="string">"productName"</span>, productName);</span><br><span class="line">	attributes.addFlashAttribute(<span class="string">"title"</span>, <span class="string">"有点问题！"</span>);</span><br><span class="line">	mv.setViewName(<span class="string">"redirect:"</span>/error/fail.htm<span class="string">");</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">return mv;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这段代码时我前段时间做全局错误处理模块时对原有业务逻辑错误返回的一个抽象，因为要将错误统一处理，就不可能在具体的handler中直接返回到错误界面，所以就将所有的错误处理都redirect到error/fail.htm这个handler method中处理。redirect的参数问题上面已经描述过了，这里就不在细说，就是简单的例子和背景，知道怎么去使用RedirectAttributes。</p>
<p>RedirectAttributes这个原理也很简单，就是相当于存在了一个session中，但是这个session在用过一次之后就销毁了，即在fail.htm这个方法中获取之后如果再进行redirect，参数还会丢失，那么就在fail.htm中继续使用RedirectAttributes来存储参数再传递到下一个handler。</p>
<h2 id="doDispatch方法"><a href="#doDispatch方法" class="headerlink" title="doDispatch方法"></a>doDispatch方法</h2><p>为了偷懒，上面强行插入了对Spring中redirect参数传递问题的解释。回归到咱们的doDispatch方法。</p>
<p>作用：处理实际的调度到handler。handler将通过按顺序应用servlet的HandlerMappings来获得。<br>HandlerAdapter将通过查询servlet已安装的HandlerAdapter来查找支持处理程序类的第一个HandlerAdapter。所有的HTTP方法都由这个方法处理。这取决于HandlerAdapter或处理程序自己决定哪些方法是可以接受的。</p>
<p>其实在doDispatch中最核心的代码就4行，我们来看下：</p>
<ul>
<li><p>根据request找到我们的handler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Determine handler for the current request.</span></span><br><span class="line">   mappedHandler = getHandler(processedRequest);</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据handler找到对应的HandlerAdapter</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">   HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br></pre></td></tr></table></figure>
<ul>
<li>HandlerAdapter处理handler</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Actually invoke the handler.</span></span><br><span class="line">   mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br></pre></td></tr></table></figure>
<ul>
<li>调用processDispatchResult方法处理上述过程中得结果综合，当然也包括找到view并且渲染输出给用户<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我们以上述为轴心，来看下它的整个源码(具体代码含义在代码中标注)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//当前请求request</span></span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    <span class="comment">//处理器链（handler和拦截器）</span></span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//用户标识multipartRequest（文件上传请求）</span></span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//很熟悉吧，这个就是我们返回给用户的包装视图</span></span><br><span class="line">    	ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">    	<span class="comment">//处理请求过程中抛出的异常。这个异常是不包括渲染过程中抛出的异常的</span></span><br><span class="line">    	Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">    	    <span class="comment">//检查是不是上传请求</span></span><br><span class="line">    		processedRequest = checkMultipart(request);</span><br><span class="line">    		multipartRequestParsed = (processedRequest != request);</span><br><span class="line">    </span><br><span class="line">    		<span class="comment">// 通过当前请求确定相应的handler</span></span><br><span class="line">    		mappedHandler = getHandler(processedRequest);</span><br><span class="line">    		<span class="comment">//如果没有找到：就会报异常，这个异常我们在搭建SpringMVC应用时会经常遇到：</span></span><br><span class="line">    		<span class="comment">//No mapping found for HTTP request with URI XXX in</span></span><br><span class="line">    		<span class="comment">//DispatcherServlet with name XXX</span></span><br><span class="line">    		<span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    			noHandlerFound(processedRequest, response);</span><br><span class="line">    			<span class="keyword">return</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    </span><br><span class="line">    		<span class="comment">// 根据handler找到HandlerAdapter</span></span><br><span class="line">    		HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">    </span><br><span class="line">    		<span class="comment">//处理GET和Head请求的Last-Modified</span></span><br><span class="line">    		</span><br><span class="line">    		<span class="comment">//获取请求方法</span></span><br><span class="line">    		String method = request.getMethod();</span><br><span class="line">    		<span class="comment">//这个方法是不是GET方法</span></span><br><span class="line">    		<span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">    		<span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">    			<span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">    			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    				logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">    			&#125;</span><br><span class="line">    			<span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">    				<span class="keyword">return</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">            <span class="comment">//这里就是我们SpringMVC拦截器的preHandle方法的处理</span></span><br><span class="line">    		<span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">    			<span class="keyword">return</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">            </span><br><span class="line">    		<span class="comment">// 调用具体的Handler，并且返回我们的mv对象.</span></span><br><span class="line">    		mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">            <span class="comment">//如果需要异步处理的话就直接返回</span></span><br><span class="line">    		<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">    			<span class="keyword">return</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">            <span class="comment">//这个其实就是处理视图（view）为空的情况，会根据request设置默认的view</span></span><br><span class="line">    		applyDefaultViewName(processedRequest, mv);</span><br><span class="line">    		<span class="comment">//这里就是我们SpringMVC拦截器的postHandle方法的处理</span></span><br><span class="line">    		mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    		dispatchException = ex;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">    		<span class="comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span></span><br><span class="line">    		<span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">    		dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//处理返回结果；（异常处理、页面渲染、拦截器的afterCompletion触发等）</span></span><br><span class="line">    	processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    	triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">    	triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">    			<span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否执行异步请求</span></span><br><span class="line">    	<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">    		<span class="comment">// 如果是的话，就替代拦截器的postHandle 和 afterCompletion方法执行</span></span><br><span class="line">    		<span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    			mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">else</span> &#123;</span><br><span class="line">    		<span class="comment">// 删除上传请求的资源</span></span><br><span class="line">    		<span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">    			cleanupMultipart(processedRequest);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体来看，doDispatch做了两件事情：</p>
<ul>
<li>处理请求</li>
<li>页面渲染</li>
</ul>
<h3 id="doDispatch处理过程流程图"><a href="#doDispatch处理过程流程图" class="headerlink" title="doDispatch处理过程流程图"></a>doDispatch处理过程流程图</h3><p><img src="https://user-gold-cdn.xitu.io/2018/1/13/160ee44a53228b69?w=682&amp;h=644&amp;f=png&amp;s=36088" alt=""></p>
<p>那上面就是整个DispatcherServlet的一个大概内容了，关于SpringMVC容器的初始化，我们在先把DispatcherServlet中涉及到的九大组件撸完之后再回头来学习。关于九大组件目前已经有过两篇是关于HandlerMapping的了，由于我们打算对于整个SpringMVC体系结构都进行一次梳理，因此，会将九大组件从接口设计以及子类都会通过源码的方式来呈现。</p>
<p><code>大家如果有什么意见或者建议可以在下方评论区留言，也可以给我们发邮件（glmapper_2018@163.com）!欢迎小伙伴与我们一起交流，一起成长。</code></p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/spring-base-webmvc3/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/spring-base-webmvc2/">SpringMVC源码系列：AbstractHandlerMapping</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T06:02:35.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/spring-base-webmvc2/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/web/" title="web">web</a>,
  
    <a href="/tags/mvc/" title="mvc">mvc</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>AbstractHandlerMapping是实现HandlerMapping接口的一个抽象基类。支持排序，默认处理程序，处理程序拦截器，包括由路径模式映射的处理程序拦截器。所有的HandlerMapping都继承自AbstractHandlerMapping。另外，此基类不支持PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE的暴露，此属性的支持取决于具体的子类，通常基于请求URL映射。</p>
<p>前面说到，HandlerMapping的作用就是通过request查找Handler和Interceptors。具体的获取均是通过子类来实现的。</p>
<h2 id="1-AbstractHandlerMapping-的类定义"><a href="#1-AbstractHandlerMapping-的类定义" class="headerlink" title="1.AbstractHandlerMapping 的类定义"></a>1.AbstractHandlerMapping 的类定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractHandlerMapping extends WebApplicationObjectSupport</span><br><span class="line"> implements HandlerMapping, Ordered &#123;</span><br></pre></td></tr></table></figure>
<p>AbstractHandlerMapping继承了WebApplicationObjectSupport，初始化时会自动调用模板方法initApplicationContext；AbstractHandlerMapping的创建也就是在这个方法里面完成的。同时实现了HandlerMapping和Ordered接口，这也就是上面提到的支持排序的原因。</p>
<h2 id="2-AbstractHandlerMapping属性分析"><a href="#2-AbstractHandlerMapping属性分析" class="headerlink" title="2.AbstractHandlerMapping属性分析"></a>2.AbstractHandlerMapping属性分析</h2><ul>
<li><p>排序值 order</p>
<p>  默认值为Integer的最大值，后面注释的意思是和没有排序是一样的，因为只有理论上才可能超过Integer.MAX_VALUE。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private int order = Integer.MAX_VALUE;  // default: same as non-Ordered</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认处理器 defaultHandler</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Object defaultHandler;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Spring工具类 urlPathHelper</p>
<p>  Helper类用于URL路径匹配。提供对RequestDispatcher中URL路径的支持，包括并支持一致的URL解码。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private UrlPathHelper urlPathHelper = new UrlPathHelper();</span><br></pre></td></tr></table></figure>
</li>
<li><p>spring工具类 PathMatcher(AntPathMatcher)</p>
<p>  用于基于字符串的路径匹配的策略接口。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private PathMatcher pathMatcher = new AntPathMatcher();</span><br></pre></td></tr></table></figure>
</li>
<li><p>拦截器列表 interceptors</p>
<p>  用于配置SpringMVC的拦截器，配置方式由两种：<br></p>
<ul>
<li>1.注册HandlerMapping时通过属性设置<br></li>
<li><p>2.通过子类的extendInterceptors钩子方法进行设置（extendInterceptors方法是在initApplicationContext中调用的）<br></p>
<p>interceptors并不会直接使用，二是通过initInterceptors方法按照类型分配到mappedInterceptors和adaptedInterceptors中进行使用，<strong><strong>interceptors只用于配置。</strong></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final List&lt;Object&gt; interceptors = new ArrayList&lt;Object&gt;();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>adaptedInterceptors</p>
<p>  被分配到adaptedInterceptors中的类型的拦截器不需要进行匹配，在getHandler中会全部添加到返回值HandlerExecutionChain里面。他 只能从 interceptors中获取。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final List&lt;HandlerInterceptor&gt; adaptedInterceptors = new ArrayList&lt;HandlerInterceptor&gt;();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>corsProcessor</p>
<p>  CorsProcessor作用是接受请求和CorsConfiguration并更新响应的策略。<br>  此组件不关心如何选择CorsConfiguration，而是采取后续操作，例如应用CORS验证检查，并拒绝响应或将CORS头添加到响应中。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private CorsProcessor corsProcessor = new DefaultCorsProcessor();</span><br></pre></td></tr></table></figure>
</li>
<li><p>corsConfigSource</p>
<p>  根据路径模式上映射的CorsConfiguration集合提供每个请求的CorsConfiguration实例。支持精确的路径映射URI（如“/ admin”）以及Ant样式的路径模式（如“/ admin / **”）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private final UrlBasedCorsConfigurationSource corsConfigSource </span><br><span class="line">= new UrlBasedCorsConfigurationSource();</span><br></pre></td></tr></table></figure>
</li>
<li><p>跨域相关问题</p>
</li>
</ul>
<p>CorsConfiguration 具体封装跨域配置信息的pojo<br><br>CorsConfigurationSource request与跨域配置信息映射的容器<br><br>CorsProcessor 具体进行跨域操作的类<br></p>
<h2 id="3-AbstractHandlerMapping-中的get-amp-set方法"><a href="#3-AbstractHandlerMapping-中的get-amp-set方法" class="headerlink" title="3.AbstractHandlerMapping 中的get&amp;set方法"></a>3.AbstractHandlerMapping 中的get&amp;set方法</h2><h3 id="3-1-setOrder"><a href="#3-1-setOrder" class="headerlink" title="3.1 setOrder"></a>3.1 setOrder</h3><p>指定此HandlerMapping bean的排序值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final void setOrder(int order) &#123;</span><br><span class="line">  this.order = order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-2-setDefaultHandler"><a href="#3-2-setDefaultHandler" class="headerlink" title="3.2 setDefaultHandler"></a>3.2 setDefaultHandler</h3><p>指定此HandlerMapping bean的排序值。<br>设置此处理程序映射的默认处理程序。<br>如果没有找到特定的映射，这个处理程序将被返回。<br>缺省值为null，表示没有默认处理程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void setDefaultHandler(Object defaultHandler) &#123;</span><br><span class="line">	this.defaultHandler = defaultHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-3-getDefaultHandler"><a href="#3-3-getDefaultHandler" class="headerlink" title="3.3 getDefaultHandler"></a>3.3 getDefaultHandler</h3><p>返回此处理程序映射的默认处理程序，如果没有，则返回null。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object getDefaultHandler() &#123;</span><br><span class="line">	return this.defaultHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-4-setAlwaysUseFullPath"><a href="#3-4-setAlwaysUseFullPath" class="headerlink" title="3.4 setAlwaysUseFullPath"></a>3.4 setAlwaysUseFullPath</h3><p>如果URL查找始终使用当前servlet上下文中的完整路径，请进行设置。 否则，如果适用，则使用当前servlet映射中的路径（即，在web.xml中“… / *”servlet映射的情况下）。<br>默认是“false”。setAlwaysUseFullPath中的实现具体是委托给urlPathHelper和corsConfigSource来完成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setAlwaysUseFullPath(boolean alwaysUseFullPath) &#123;</span><br><span class="line">	this.urlPathHelper.setAlwaysUseFullPath(alwaysUseFullPath);</span><br><span class="line">	this.corsConfigSource.setAlwaysUseFullPath(alwaysUseFullPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-5-setUrlDecode"><a href="#3-5-setUrlDecode" class="headerlink" title="3.5 setUrlDecode"></a>3.5 setUrlDecode</h3><p>如果上下文路径和请求URI应该被URL解码，则设置。两者都是由Servlet API返回“undecoded”，与servlet路径相反。根据Servlet规范（ISO-8859-1）使用请求编码或默认编码。setUrlDecode中的实现具体是委托给urlPathHelper和corsConfigSource来完成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setUrlDecode(boolean urlDecode) &#123;</span><br><span class="line">	this.urlPathHelper.setUrlDecode(urlDecode);</span><br><span class="line">	this.corsConfigSource.setUrlDecode(urlDecode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-6-setRemoveSemicolonContent"><a href="#3-6-setRemoveSemicolonContent" class="headerlink" title="3.6 setRemoveSemicolonContent"></a>3.6 setRemoveSemicolonContent</h3><p>如果“;” （分号）内容应该从请求URI中去除,则设置。默认值是true。setRemoveSemicolonContent中的实现具体是委托给urlPathHelper和corsConfigSource来完成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setRemoveSemicolonContent(boolean removeSemicolonContent) &#123;</span><br><span class="line">	this.urlPathHelper.setRemoveSemicolonContent(removeSemicolonContent);</span><br><span class="line">	this.corsConfigSource.setRemoveSemicolonContent(removeSemicolonContent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-7-setUrlPathHelper"><a href="#3-7-setUrlPathHelper" class="headerlink" title="3.7 setUrlPathHelper"></a>3.7 setUrlPathHelper</h3><p>设置UrlPathHelper以用于解析查找路径。<br>使用它可以用自定义子类覆盖默认的UrlPathHelper，或者跨多个HandlerMappings和MethodNameResolvers共享通用的UrlPathHelper设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void setUrlPathHelper(UrlPathHelper urlPathHelper) &#123;</span><br><span class="line">	Assert.notNull(urlPathHelper, &quot;UrlPathHelper must not be null&quot;);</span><br><span class="line">	this.urlPathHelper = urlPathHelper;</span><br><span class="line">	this.corsConfigSource.setUrlPathHelper(urlPathHelper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-8-getUrlPathHelper"><a href="#3-8-getUrlPathHelper" class="headerlink" title="3.8 getUrlPathHelper"></a>3.8 getUrlPathHelper</h3><p>返回UrlPathHelper实现以用于解析查找路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public UrlPathHelper getUrlPathHelper() &#123;</span><br><span class="line">	return urlPathHelper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-9-setPathMatcher"><a href="#3-9-setPathMatcher" class="headerlink" title="3.9 setPathMatcher"></a>3.9 setPathMatcher</h3><p>将PathMatcher实现设置为用于匹配注册的URL模式的URL路径。 默认是AntPathMatcher。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void setPathMatcher(PathMatcher pathMatcher) &#123;</span><br><span class="line">	Assert.notNull(pathMatcher, &quot;PathMatcher must not be null&quot;);</span><br><span class="line">	this.pathMatcher = pathMatcher;</span><br><span class="line">	this.corsConfigSource.setPathMatcher(pathMatcher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-10-setInterceptors"><a href="#3-10-setInterceptors" class="headerlink" title="3.10 setInterceptors"></a>3.10 setInterceptors</h3><p>设置拦截器以应用此处理程序映射映射的所有处理程序。<br>支持的拦截器类型是<strong>HandlerInterceptor，WebRequestInterceptor和MappedInterceptor。</strong><br>映射拦截器仅适用于请求与其路径模式相匹配的URL。映射的拦截器Bean在初始化期间也会按类型检测到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ublic void setInterceptors(Object... interceptors) &#123;</span><br><span class="line">	this.interceptors.addAll(Arrays.asList(interceptors));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>其他几个get&amp;set方法就不列出来了，有兴趣的小伙伴可以自行阅读...</code></p>
<h2 id="4-AbstractHandlerMapping的创建"><a href="#4-AbstractHandlerMapping的创建" class="headerlink" title="4. AbstractHandlerMapping的创建"></a>4. AbstractHandlerMapping的创建</h2><p>因为AbstractHandlerMapping继承了WebApplicationObjectSupport类，因此AbstractHandlerMapping的创建就是依托于模板方法initApplicationContext来完成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void initApplicationContext() throws BeansException &#123;</span><br><span class="line">	extendInterceptors(this.interceptors);</span><br><span class="line">	detectMappedInterceptors(this.adaptedInterceptors);</span><br><span class="line">	initInterceptors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从方法结构可以了解到，initApplicationContext中包括三个子处理方法。</p>
<ul>
<li>extendInterceptors：这也是一个模板方法，在AbstractHandlerMapping中并没有具体实现（方法体是空的），主要是用于给子类提供一个添加（修改）Interceptors的入口（现有的SpringMVC实现中均未使用）。</li>
<li><p>detectMappedInterceptors：用于将SpringMVC容器及父容器中的所有MappedInterceptor类型的Bean添加到MappedInterceptors属性中。</p>
<p>  <code>检测MappedInterceptor类型的bean，并将它们添加到映射的拦截器列表中。
  除了可能通过setInterceptors提供的任何MappedInterceptors之外，还会调用此方法，默认情况下将从当前上下文及其祖先中添加所有MappedInterceptor类型的Bean。子类可以覆盖和优化这个策略。</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void detectMappedInterceptors(List&lt;HandlerInterceptor&gt; mappedInterceptors) &#123;</span><br><span class="line">	mappedInterceptors.addAll(</span><br><span class="line">			BeanFactoryUtils.beansOfTypeIncludingAncestors(</span><br><span class="line">					getApplicationContext(), MappedInterceptor.class, true, false).values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>initInterceptors：初始化指定的拦截器，检查MappedInterceptors并根据需要调整HandlerInterceptors和WebRequestInterceptors。（当前Spring版本时4.3.6） </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void initInterceptors() &#123;</span><br><span class="line">    if (!this.interceptors.isEmpty()) &#123;</span><br><span class="line">    	for (int i = 0; i &lt; this.interceptors.size(); i++) &#123;</span><br><span class="line">    		Object interceptor = this.interceptors.get(i);</span><br><span class="line">    		if (interceptor == null) &#123;</span><br><span class="line">    			throw new IllegalArgumentException(&quot;Entry number &quot; + i + &quot; in interceptors array is null&quot;);</span><br><span class="line">    		&#125;</span><br><span class="line">    		this.adaptedInterceptors.add(adaptInterceptor(interceptor));</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个是4.1.5版本的initInterceptors方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected void initInterceptors() &#123;</span><br><span class="line">    if (!this.interceptors.isEmpty()) &#123;</span><br><span class="line">    	for (int i = 0; i &lt; this.interceptors.size(); i++) &#123;</span><br><span class="line">    		Object interceptor = this.interceptors.get(i);</span><br><span class="line">    		if (interceptor == null) &#123;</span><br><span class="line">    			throw new IllegalArgumentException(&quot;Entry number &quot; + i + &quot; in interceptors array is null&quot;);</span><br><span class="line">    		&#125;</span><br><span class="line">    		if (interceptor instanceof MappedInterceptor) &#123;</span><br><span class="line">    			this.mappedInterceptors.add((MappedInterceptor) interceptor);</span><br><span class="line">    		&#125;</span><br><span class="line">    		else &#123;</span><br><span class="line">    			this.adaptedInterceptors.add(adaptInterceptor(interceptor));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>在4.1.5中版本中，initInterceptors的工作是将interceptors属性里面所包含的对象按照类型添加到adaptedInterceptors或者mappedInterceptors中。在4.1.5版本中mappedInterceptors是AbstractHandlerMapping的属性之一。主要原因是因为，springMVC自4.2开始添加了跨域的支持，也就是上面属性中的后两个。PS：在阅读Spring相关源码时需要关注不同版本的变更及区别，不要只关注某一个版本，另外就是个人觉得阅读源码的关注点应该在编码方式、设计模式使用、设计思想及理念，而不仅仅是知道他是如何实现的】</code></p>
<p>这里顺便说下mappedInterceptors的作用：mappedInterceptors中的拦截器在使用时需要与请求的url进行匹配，只有匹配成功后才会添加到getHandler的返回值HandlerExecytionChain里。</p>
<p><strong>adaptInterceptor方法:</strong></p>
<p>使给定的拦截器对象适配HandlerInterceptor接口。默认情况下，支持的拦截器类型是HandlerInterceptor和WebRequestInterceptor。每个给定的WebRequestInterceptor将被封装在WebRequestHandlerInterceptorAdapter中。可以在子类中重写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected HandlerInterceptor adaptInterceptor(Object interceptor) &#123;</span><br><span class="line">	if (interceptor instanceof HandlerInterceptor) &#123;</span><br><span class="line">		return (HandlerInterceptor) interceptor;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (interceptor instanceof WebRequestInterceptor) &#123;</span><br><span class="line">		return new WebRequestHandlerInterceptorAdapter((WebRequestInterceptor) interceptor);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		throw new IllegalArgumentException(&quot;Interceptor type not supported: &quot; + interceptor.getClass().getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-Handler和Interceptor的获取"><a href="#5-Handler和Interceptor的获取" class="headerlink" title="5.Handler和Interceptor的获取"></a>5.Handler和Interceptor的获取</h2><p>HandlerMapping是通过getHandler方法来获取Handler和Interceptor的。因此在抽象基类AbstractHandlerMapping中提供了具体的实现。并且在AbstractHandlerMapping中，getHandler使用final关键字修饰的，也就是说，子类不能再进行对此方法进行覆盖重写了。</p>
<p>getHandler的作用就是查找给定请求的handler，如果找不到特定请求，则返回到默认handler。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">	//通过getHandlerInternal方法来获取handler</span><br><span class="line">	Object handler = getHandlerInternal(request);</span><br><span class="line">	//如果前一个方法没有获取到，则使用默认的handler</span><br><span class="line">	if (handler == null) &#123;</span><br><span class="line">	    //默认的Handler就是AbstractHandlerMapping中的handler属性通过set得到的值</span><br><span class="line">		handler = getDefaultHandler();</span><br><span class="line">	&#125;</span><br><span class="line">	//如果还是没有找到Hander，则直接返回Null</span><br><span class="line">	if (handler == null) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	// Bean name or resolved handler?</span><br><span class="line">	//如果找到的handler是String类型的，</span><br><span class="line">	if (handler instanceof String) &#123;</span><br><span class="line">	    //则以它为名到spring Mvc的容器中查找相应的Bean</span><br><span class="line">		String handlerName = (String) handler;</span><br><span class="line">		handler = getApplicationContext().getBean(handlerName);</span><br><span class="line">	&#125;</span><br><span class="line">    //先根据handler和request创建一个HandlerExecutionChain对象，</span><br><span class="line">	HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</span><br><span class="line">	if (CorsUtils.isCorsRequest(request)) &#123;</span><br><span class="line">		CorsConfiguration globalConfig = this.corsConfigSource.getCorsConfiguration(request);</span><br><span class="line">		CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);</span><br><span class="line">		CorsConfiguration config = (globalConfig != null ? globalConfig.combine(handlerConfig) : handlerConfig);</span><br><span class="line">		executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">	&#125;</span><br><span class="line">	return executionChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>getHandlerInternal</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected abstract Object getHandlerInternal(HttpServletRequest request) throws Exception;</span><br></pre></td></tr></table></figure>
<p>查找给定请求的handler，如果找不到特定请求，则返回null。 这个方法被getHandler调用; 如果设置了null返回值，将导致默认handler。<br>在CORS pre-flight请求上，这个方法应该返回一个不匹配飞行前请求的匹配项，而是根据URL路径，“Access-Control-Request-Method”头中的HTTP方法和头文件 从“Access-Control-Request-Headers”头部获得，从而允许CORS配置通过getCorsConfigurations获得，<br>注意：这个方法也可以返回一个预先构建的HandlerExecutionChain，将一个处理程序对象与动态确定的拦截器组合在一起。状态指定的拦截器将被合并到这个现有的链中。</p>
<p><strong>getHandlerExecutionChain</strong>：</p>
<p>getLookupPathForRequest:返回给定请求的映射查找路径，如果适用的话，在当前的servlet映射中，或者在web应用程序中返回。如果在RequestDispatcher中调用include请求，则检测包含请求URL。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) &#123;</span><br><span class="line">    //如果handler是HandlerExecutionChain类型则直接强转为HandlerExecutionChain类型，</span><br><span class="line">        //如果不是则根据handler创建一个新的HandlerExecutionChain实例对象</span><br><span class="line">	HandlerExecutionChain chain = (handler instanceof HandlerExecutionChain ?</span><br><span class="line">			(HandlerExecutionChain) handler : new HandlerExecutionChain(handler));</span><br><span class="line">    //返回给定请求的映射查找路径</span><br><span class="line">	String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);</span><br><span class="line">	//遍历当前adaptedInterceptors链表</span><br><span class="line">	for (HandlerInterceptor interceptor : this.adaptedInterceptors) &#123;</span><br><span class="line">	    //如果是MappedInterceptor类型则</span><br><span class="line">		if (interceptor instanceof MappedInterceptor) &#123;</span><br><span class="line">			MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;</span><br><span class="line">			//拦截器是否应用于给定的请求路径，如果是则返回true</span><br><span class="line">			if (mappedInterceptor.matches(lookupPath, this.pathMatcher)) &#123;</span><br><span class="line">				chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			chain.addInterceptor(interceptor);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为给定的handler构建一个HandlerExecutionChain，包括可用的拦截器。默认实现用给定的handler，handler映射的通用拦截器以及与当前请求URL相匹配的任何MappedInterceptors构建标准的HandlerExecutionChain。拦截器按照他们注册的顺序添加。为了扩展/重新排列拦截器列表，子类可以覆盖它。<br></p>
<p>需要注意的是，传入的handler对象可能是原始handler或预构建的HandlerExecutionChain。这个方法应该明确地处理这两种情况，建立一个新的HandlerExecutionChain或者扩展现有的链。为了简单地在自定义子类中添加拦截器，可以考虑调用super.getHandlerExecutionChain（handler，request）并在返回的链对象上调用HandlerExecutionChain＃addInterceptor。</p>
<p><strong>getCorsHandlerExecutionChain</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected HandlerExecutionChain getCorsHandlerExecutionChain(HttpServletRequest request,</span><br><span class="line">		HandlerExecutionChain chain, CorsConfiguration config) &#123;</span><br><span class="line">    //通过请求头的http方法是否options判断是否预请求，</span><br><span class="line">	if (CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">		HandlerInterceptor[] interceptors = chain.getInterceptors();</span><br><span class="line">		//如果是使用PreFlightRequest替换处理器</span><br><span class="line">		chain = new HandlerExecutionChain(new PreFlightHandler(config), interceptors);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">    	//如果是普通请求，添加一个拦截器CorsInterceptor。</span><br><span class="line">		chain.addInterceptor(new CorsInterceptor(config));</span><br><span class="line">	&#125;</span><br><span class="line">	return chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新HandlerExecutionChain进行与CORS（HTTP访问控制：跨域资源共享）相关的处理。</p>
<ul>
<li>对于pre-flight请求，默认实现用一个简单的HttpRequestHandler来替换选择的handler，该HttpRequestHandler调用已配置的setCorsProcessor。（将处理器替换为内部类PreFlightHandler）</li>
<li>对于普通的请求，默认实现插入一个HandlerInterceptor，它执行与CORS有关的检查并添加CORS头。（添加CorsInterceptor拦截器）</li>
</ul>
<h2 id="AbstractHandlerMapping中的两个内部类"><a href="#AbstractHandlerMapping中的两个内部类" class="headerlink" title="AbstractHandlerMapping中的两个内部类"></a>AbstractHandlerMapping中的两个内部类</h2><p>这两个内部类就是用来校验request是否cors，并封装对应的Adapter的。</p>
<ul>
<li>PreFlightRequest是CorsProcessor对于HttpRequestHandler的一个适配器。这样HandlerAdapter直接使用HttpRequestHandlerAdapter处理。</li>
<li>CorsInterceptor 是CorsProcessor对于HandlerInterceptorAdapter的适配器。</li>
</ul>
<p>具体的类信息如下：</p>
<h3 id="PreFlightHandler"><a href="#PreFlightHandler" class="headerlink" title="PreFlightHandler"></a>PreFlightHandler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private class PreFlightHandler implements HttpRequestHandler, CorsConfigurationSource &#123;</span><br><span class="line"></span><br><span class="line">	private final CorsConfiguration config;</span><br><span class="line"></span><br><span class="line">	public PreFlightHandler(CorsConfiguration config) &#123;</span><br><span class="line">		this.config = config;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;</span><br><span class="line">		corsProcessor.processRequest(this.config, request, response);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public CorsConfiguration getCorsConfiguration(HttpServletRequest request) &#123;</span><br><span class="line">		return this.config;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CorsInterceptor"><a href="#CorsInterceptor" class="headerlink" title="CorsInterceptor"></a>CorsInterceptor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private class CorsInterceptor extends HandlerInterceptorAdapter implements CorsConfigurationSource &#123;</span><br><span class="line"></span><br><span class="line">	private final CorsConfiguration config;</span><br><span class="line"></span><br><span class="line">	public CorsInterceptor(CorsConfiguration config) &#123;</span><br><span class="line">		this.config = config;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</span><br><span class="line">			throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		return corsProcessor.processRequest(this.config, request, response);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public CorsConfiguration getCorsConfiguration(HttpServletRequest request) &#123;</span><br><span class="line">		return this.config;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此AbstractHandlerMapping中的一些源码就结束了，AbstractHandlerMapping为HandlerMapping的功能提供的一些具体的模板描述，但是具体的细节实现还需要从其子类中来慢慢分析。关于这部分中涉及到的如HandlerExecutionChain，cors跨域等问题，后面会根据实际情况另开篇幅来学习。</p>
<p><code>大家如果有什么意见或者建议可以在下方评论区留言，也可以给我们发邮件（glmapper_2018@163.com）!欢迎小伙伴与我们一起交流，一起成长。</code></p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/spring-base-webmvc2/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/spring-base-webmvc1/">SpringMVC源码系列：HandlerMapping</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T06:01:34.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/spring-base-webmvc1/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/web/" title="web">web</a>,
  
    <a href="/tags/mvc/" title="mvc">mvc</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>HandlerMapping接口是用来查找Handler的。在SpringMvc中，DispatcherServlet处理分发很多请求，而每个请求都需要一个Handler来处理，具体接受到一个请求后使用哪个Handler来处理呢？这就是Handler要做的事情。因此，HandlerMapping的作用就是根据request找到相应的处理器Handler和Interceptors。</p>
<p>下面是Spring中对HandlerMapping接口的说明：</p>
<p><code>This class can be implemented by application developers, although this is not necessary, as BeanNameUrlHandlerMapping and DefaultAnnotationHandlerMapping are included in the framework. The former is the default if no HandlerMapping bean is registered in the application context.</code><br><br>这个类可以由应用程序开发人员实现，尽管这不是必须的，因为BeanNameUrlHandlerMapping和DefaultAnnotationHandlerMapping已经包含在框架中，作为HandlerMapping的默认实现。 如果在应用程序上下文中没有注册HandlerMapping bean，BeanNameUrlHandlerMapping是默认值。</p>
<p><code>HandlerMapping implementations can support mapped interceptors but do not have to. A handler will always be wrapped in a HandlerExecutionChain instance, optionally accompanied by some HandlerInterceptor instances.The DispatcherServlet will first call each HandlerInterceptor&#39;s preHandle  method in the given order, finally invoking the handler itself if all preHandle methods have returned true</code><br><br>HandlerMapping实现可以支持映射的拦截器，但不必如此；handler将始终被封装在HandlerExecutionChain实例中，并可由一些HandlerInterceptor实例执行。在给定的顺序中，DispatcherServlet将首先调用每个HandlerInterceptor的preHandle方法，如果所有的preHandle方法都返回true，那么最后调用handler本身。</p>
<p><code>The ability to parameterize this mapping is a powerful and unusual capability of this MVC framework. For example, it is possible to write a custom mapping based on session state, cookie state or many other variables. No other MVC framework seems to be equally flexible.</code><br><br>参数化这个映射的能力是这个MVC框架的一个强大且不同寻常的能力。 例如，可以根据会话状态，cookie状态或许多其他变量编写自定义映射。 没有其他MVC框架似乎同样灵活。</p>
<p><code>Note: Implementations can implement the Ordered interface to be able to specify a sorting order and thus a priority for getting applied by DispatcherServlet. Non-Ordered instances get treated as lowest priority.</code><br><br>注：实现可以实现Ordered接口，以便能够指定排序顺序，从而指定由DispatcherServlet应用的优先级。 无序实例被视为最低优先级。</p>
<h2 id="1-接口常量"><a href="#1-接口常量" class="headerlink" title="1.接口常量"></a>1.接口常量</h2><h3 id="1-1、PATH-WITHIN-HANDLER-MAPPING-ATTRIBUTE"><a href="#1-1、PATH-WITHIN-HANDLER-MAPPING-ATTRIBUTE" class="headerlink" title="1.1、PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE"></a>1.1、PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE</h3><p>HttpServletRequest属性的名称，它包含处理程序映射中的路径，比如模式匹配，或者完全相关的URI(通常在DispatcherServlet的映射中)。此属性不需要所有HandlerMapping实现支持。基于url的HandlerMappings通常会支持它，但是处理程序不应该期望这个请求属性在所有场景中都存在。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Name of the &#123;@link HttpServletRequest&#125; attribute that contains the path</span><br><span class="line"> * within the handler mapping, in case of a pattern match, or the full</span><br><span class="line"> * relevant URI (typically within the DispatcherServlet&apos;s mapping) else.</span><br><span class="line"> * &lt;p&gt;Note: This attribute is not required to be supported by all</span><br><span class="line"> * HandlerMapping implementations. URL-based HandlerMappings will</span><br><span class="line"> * typically support it, but handlers should not necessarily expect</span><br><span class="line"> * this request attribute to be present in all scenarios.</span><br><span class="line"> */</span><br><span class="line">String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.pathWithinHandlerMapping&quot;;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-2、BEST-MATCHING-PATTERN-ATTRIBUTE"><a href="#1-2、BEST-MATCHING-PATTERN-ATTRIBUTE" class="headerlink" title="1.2、BEST_MATCHING_PATTERN_ATTRIBUTE"></a>1.2、BEST_MATCHING_PATTERN_ATTRIBUTE</h3><p>HttpServletRequest属性的名称，包括处理程序映射中的最佳匹配模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Name of the &#123;@link HttpServletRequest&#125; attribute that contains the</span><br><span class="line"> * best matching pattern within the handler mapping.</span><br><span class="line"> * &lt;p&gt;Note: This attribute is not required to be supported by all</span><br><span class="line"> * HandlerMapping implementations. URL-based HandlerMappings will</span><br><span class="line"> * typically support it, but handlers should not necessarily expect</span><br><span class="line"> * this request attribute to be present in all scenarios.</span><br><span class="line"> */</span><br><span class="line">String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.bestMatchingPattern&quot;;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-3、INTROSPECT-TYPE-LEVEL-MAPPING"><a href="#1-3、INTROSPECT-TYPE-LEVEL-MAPPING" class="headerlink" title="1.3、INTROSPECT_TYPE_LEVEL_MAPPING"></a>1.3、INTROSPECT_TYPE_LEVEL_MAPPING</h3><p>HttpServletRequest属性的名称，指示是否应该检查类型级别的映射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Name of the boolean &#123;@link HttpServletRequest&#125; attribute that indicates</span><br><span class="line"> * whether type-level mappings should be inspected.</span><br><span class="line"> * &lt;p&gt;Note: This attribute is not required to be supported by all</span><br><span class="line"> * HandlerMapping implementations.</span><br><span class="line"> */</span><br><span class="line">String INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.class.getName() + &quot;.introspectTypeLevelMapping&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="1-4、URI-TEMPLATE-VARIABLES-ATTRIBUTE"><a href="#1-4、URI-TEMPLATE-VARIABLES-ATTRIBUTE" class="headerlink" title="1.4、URI_TEMPLATE_VARIABLES_ATTRIBUTE"></a>1.4、URI_TEMPLATE_VARIABLES_ATTRIBUTE</h3><p>包含URI模板映射的HttpServletRequest属性的名称，将变量名称映射到值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Name of the &#123;@link HttpServletRequest&#125; attribute that contains the URI</span><br><span class="line"> * templates map, mapping variable names to values.</span><br><span class="line"> * &lt;p&gt;Note: This attribute is not required to be supported by all</span><br><span class="line"> * HandlerMapping implementations. URL-based HandlerMappings will</span><br><span class="line"> * typically support it, but handlers should not necessarily expect</span><br><span class="line"> * this request attribute to be present in all scenarios.</span><br><span class="line"> */</span><br><span class="line">String URI_TEMPLATE_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.uriTemplateVariables&quot;;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-5、MATRIX-VARIABLES-ATTRIBUTE"><a href="#1-5、MATRIX-VARIABLES-ATTRIBUTE" class="headerlink" title="1.5、MATRIX_VARIABLES_ATTRIBUTE"></a>1.5、MATRIX_VARIABLES_ATTRIBUTE</h3><p>包含带有URI矩阵变量的映射的HttpServletRequest属性的名称。此属性不需要所有HandlerMapping实现支持，也可能不存在，这取决于HandlerMapping是否被配置为在请求URI中保留矩阵变量内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Name of the &#123;@link HttpServletRequest&#125; attribute that contains a map with</span><br><span class="line"> * URI matrix variables.</span><br><span class="line"> * &lt;p&gt;Note: This attribute is not required to be supported by all</span><br><span class="line"> * HandlerMapping implementations and may also not be present depending on</span><br><span class="line"> * whether the HandlerMapping is configured to keep matrix variable content</span><br><span class="line"> * in the request URI.</span><br><span class="line"> */</span><br><span class="line">String MATRIX_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.matrixVariables&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="1-6、PRODUCIBLE-MEDIA-TYPES-ATTRIBUTE"><a href="#1-6、PRODUCIBLE-MEDIA-TYPES-ATTRIBUTE" class="headerlink" title="1.6、PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE"></a>1.6、PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE</h3><p>HttpServletRequest属性的名称，该属性包含可用于映射处理程序的可生成的MediaTypes集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Name of the &#123;@link HttpServletRequest&#125; attribute that contains the set of</span><br><span class="line"> * producible MediaTypes applicable to the mapped handler.</span><br><span class="line"> * &lt;p&gt;Note: This attribute is not required to be supported by all</span><br><span class="line"> * HandlerMapping implementations. Handlers should not necessarily expect</span><br><span class="line"> * this request attribute to be present in all scenarios.</span><br><span class="line"> */</span><br><span class="line">String PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.producibleMediaTypes&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="2-核心方法"><a href="#2-核心方法" class="headerlink" title="2.核心方法"></a>2.核心方法</h2><p>HandlerMapping接口中只有一个方法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;</span><br></pre></td></tr></table></figure></p>
<p>从方法定义可以看出，getHandler方法就是通过request来获取一个HandlerExecutionChain；该方法在不同的子类中都有实现，具体的实现后面说子类的时候在详细分析。</p>
<h2 id="3-HandlerMapping的子类"><a href="#3-HandlerMapping的子类" class="headerlink" title="3.HandlerMapping的子类"></a>3.HandlerMapping的子类</h2><p><img src="https://user-gold-cdn.xitu.io/2018/1/10/160de1fc214fe76d?w=1298&amp;h=974&amp;f=png&amp;s=35893" alt=""><br><code>图中黄色部分表示已经过时的类，时间开发中不建议再使用。</code></p>
<p>在HandlerMapping的体系中可以看出，HandlerMapping下属子类可分为两个分支；</p>
<ul>
<li>AbstractHandlerMethodMapping</li>
<li>AbstractUrlHandlerMapping</li>
</ul>
<p>上述两个抽象类又均是AbstractHandlerMapping的子类。关于AbstractHandlerMapping我们下篇文章来学习。</p>
<p><code>大家如果有什么意见或者建议可以在下方评论区留言，也可以给我们发邮件（glmapper_2018@163.com）!欢迎小伙伴与我们一起交流，一起成长。</code></p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/spring-base-webmvc1/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/spring-series-context-refresh/">Spring源码系列-容器刷新</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T05:59:19.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/spring-series-context-refresh/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p><code>Spring对于程序员说来说都不陌生；作为一个强大的开源技术，帮助我们能够更好的进行项目的开发与维护。</code></p>
<p>上次在Spring的启动过程文章中对Spring的启动过程做了一个较为详细的说明和分析。那么在实际的过程中，Spring的启动实际上就是Spring容器的初始化过程。本文将从源码的角度结合自己断点执行过程中保留的现场来分析一下容器的刷新过程（主要分析前几个方法，后面几个会分开来说）。</p>
<p>Spring的启动是通过ContextLoaderListener来进行的，在ContextLoaderListener中通过委托父类ContextLoader的initWebApplicationContext来完成具体的初始化过程。具体的启动过程可以看下之前的那篇文章。</p>
<p>在initWebApplicationContext方法是用来创建容器的，核心代码如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/24/160878791bfd4866?w=776&amp;h=306&amp;f=png&amp;s=21620" alt=""><br>今天主要来看configureAndRefreshWebApplicationContext方法中最后的wac.refresh()到底发生了哪些事;</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/24/1608789936e4812b?w=656&amp;h=628&amp;f=png&amp;s=37436" alt=""></p>
<h3 id="1、obtainFreshBeanFactory：BeanFactory的刷新和创建"><a href="#1、obtainFreshBeanFactory：BeanFactory的刷新和创建" class="headerlink" title="1、obtainFreshBeanFactory：BeanFactory的刷新和创建"></a>1、obtainFreshBeanFactory：BeanFactory的刷新和创建</h3><p>refresh()方法主要为IoC容器Bean的生命周期管理提供条件，Spring IoC容器载入Bean定义资源文件从其子类容器的refreshBeanFactory()方法启动，所以整个refresh()中“ConfigurableListableBeanFactory beanFactory =obtainFreshBeanFactory();”这句以后代码的都是注册容器的信息源和生命周期事件，载入过程就是从这句代码启动。<br>AbstractApplicationContext的obtainFreshBeanFactory()方法调用子类容器的refreshBeanFactory()方法，启动容器载入Bean定义资源文件的过程。<br>refresh()方法的作用是：在创建IoC容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IoC容器。refresh的作用类似于对IoC容器的重启，在新建立好的容器中对容器进行初始化，对Bean定义资源进行载入。<br>和refreshBeanFactory方法类似，载入Bean定义的方法loadBeanDefinitions也使用了委派模式，在AbstractRefreshableApplicationContext类中只定义了抽象方法，具体的实现调用子类容器中的方法实现。</p>
<p><strong>//通知子类去刷新内部bean 工厂</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/24/160878ba771d7cb0?w=627&amp;h=229&amp;f=png&amp;s=12991" alt=""><br>再来看refreshBeanFactory</p>
<p><code>此实现执行该上下文的底层bean工厂的实际刷新，关闭以前的bean工厂（如果有的话），并为上下文生命周期的下一阶段初始化一个新的bean工厂。</code></p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/24/160878cb0149042c?w=881&amp;h=366&amp;f=png&amp;s=21522" alt=""></p>
<p><strong>customizeBeanFactory(DefaultListableBeanFactory beanFactory)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">        //通过当前上下文来自定义内部bean工厂&lt;br&gt;</span><br><span class="line">	 * Customize the internal bean factory used by this context.</span><br><span class="line">	 * Called for each &#123;@link #refresh()&#125; attempt.</span><br><span class="line">	 * &lt;p&gt;The default implementation applies this context&apos;s</span><br><span class="line">	 * &#123;@linkplain #setAllowBeanDefinitionOverriding &quot;allowBeanDefinitionOverriding&quot;&#125;</span><br><span class="line">	 * and &#123;@linkplain #setAllowCircularReferences &quot;allowCircularReferences&quot;&#125; settings,</span><br><span class="line">	 * if specified. Can be overridden in subclasses to customize any of</span><br><span class="line">	 * &#123;@link DefaultListableBeanFactory&#125;&apos;s settings.</span><br><span class="line">	 * @param beanFactory the newly created bean factory for this context</span><br><span class="line">	 * @see DefaultListableBeanFactory#setAllowBeanDefinitionOverriding</span><br><span class="line">	 * @see DefaultListableBeanFactory#setAllowCircularReferences</span><br><span class="line">	 * @see DefaultListableBeanFactory#setAllowRawInjectionDespiteWrapping</span><br><span class="line">	 * @see DefaultListableBeanFactory#setAllowEagerClassLoading</span><br><span class="line">	 */</span><br><span class="line">	protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123;</span><br><span class="line">		if (this.allowBeanDefinitionOverriding != null) &#123;</span><br><span class="line">			beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);</span><br><span class="line">		&#125;</span><br><span class="line">		if (this.allowCircularReferences != null) &#123;</span><br><span class="line">			beanFactory.setAllowCircularReferences(this.allowCircularReferences);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>XmlWebApplicationContext类中loadBeanDefinitions（beanFactory）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;</span><br><span class="line">		// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span><br><span class="line">		XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">		// Configure the bean definition reader with this context&apos;s</span><br><span class="line">		// resource loading environment.</span><br><span class="line">		beanDefinitionReader.setEnvironment(getEnvironment());</span><br><span class="line">		beanDefinitionReader.setResourceLoader(this);</span><br><span class="line">		beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span><br><span class="line"></span><br><span class="line">		// Allow a subclass to provide custom initialization of the reader,</span><br><span class="line">		// then proceed with actually loading the bean definitions.</span><br><span class="line">		initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">		loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>AbstractApplicationContext调用loadBeanDefinitions(DefaultListableBeanFactory beanFactory) ，此方法根据首先创建XmlBeanDefinitionReader对象，然后配置该对象的上下文和资源加载环境，同时调用子类实现的initBeanDefinitionReader对XmlBeanDefinitionReader进行个性化配置，最近后入到initBeanDefinitionReader(beanDefinitionReader)的调用：</p>
<ol>
<li>据给定的BeanFactory创建XmlBeanDefinitionReader 对象  </li>
<li>配置beanDefinitionReader的上下文和资源加载环境  </li>
<li>用子类实现的initBeanDefinitionReader对XmlBeanDefinitionReader进行个性化配置initBeanDefinitionReader(beanDefinitionReader);  </li>
<li>调用载入Bean定义的方法，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器  </li>
</ol>
<p><strong>装载bean定义通过XmlBeanDefinitionReader。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Create a new XmlBeanDefinitionReader for the given BeanFactory. 通过给定的bean工厂创建一个新的XmlBeanDefinitionReader</span><br><span class="line">1.XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">2.使用上下文的资源加载环境配置bean定义读取器。</span><br><span class="line">   beanDefinitionReader.setEnvironment(getEnvironment());</span><br><span class="line">   beanDefinitionReader.setResourceLoader(this);</span><br><span class="line">   beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span><br><span class="line">3.允许子类提供reader的自定义初始化，然后继续实际加载bean定义。</span><br><span class="line">    //通过制定的XmlBeanDefinitionReader来载入beandefinitionReader </span><br><span class="line">   initBeanDefinitionReader(beanDefinitionReader)</span><br><span class="line">   // 通过制定的XmlBeanDefinitionReader来载入bean definitions</span><br><span class="line">   loadBeanDefinitions(beanDefinitionReader)</span><br></pre></td></tr></table></figure>
<p>AbstractApplicationContext调用loadBeanDefinitions(beanDefinitionReader)，这个方法是取得资源或资源路径然后通过传入的reader去加载BeanDefinitions。<br><img src="https://user-gold-cdn.xitu.io/2017/12/24/160879563687ab72?w=997&amp;h=205&amp;f=png&amp;s=22629" alt=""></p>
<h3 id="2、loadBeanDefinitions"><a href="#2、loadBeanDefinitions" class="headerlink" title="2、loadBeanDefinitions"></a>2、loadBeanDefinitions</h3><p>目前使用Spring的配置都是基于XML的，因此使用XmlBeanDefinitionReader 中的loadBeanDefinitions方法。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/24/1608797d7481bc37?w=583&amp;h=112&amp;f=png&amp;s=7511" alt=""><br><img src="https://user-gold-cdn.xitu.io/2017/12/24/160879802355b9b2?w=799&amp;h=444&amp;f=png&amp;s=27799" alt=""><br>看doLoadBeanDefinitions,这个就是具体的读取文件配置，然后注册成Bean</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087994cca671ae?w=578&amp;h=141&amp;f=png&amp;s=9005" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/24/1608799702d1a27a?w=778&amp;h=467&amp;f=png&amp;s=29776" alt=""></p>
<h3 id="3、prepareBeanFactory"><a href="#3、prepareBeanFactory" class="headerlink" title="3、prepareBeanFactory"></a>3、prepareBeanFactory</h3><p>配置工厂的标准上下文特性，如上下文的类装载器和后处理器。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/24/160879d74f10ac5c?w=810&amp;h=569&amp;f=png&amp;s=52456" alt=""></p>
<ul>
<li>告诉内部bean工厂使用上下文的类装入器等。</li>
<li>上下文回调配置bean工厂。</li>
<li>BeanFactory接口未登记为普通工厂的解析式。MessageSource登记（为自动装配创建）作为一个Bean</li>
<li>如果创建；就去寻找LoadTimeWeaver，然后准备组织</li>
<li>注册默认环境bean。</li>
</ul>
<p>通过断点来看下当前的beanFactory</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/24/160879dad75a8048?w=612&amp;h=583&amp;f=png&amp;s=53737" alt=""><br><img src="https://user-gold-cdn.xitu.io/2017/12/24/160879ed5cdaef5f?w=604&amp;h=560&amp;f=png&amp;s=49027" alt=""><br>继续执行…</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087a04fe33eb56?w=752&amp;h=168&amp;f=png&amp;s=14279" alt=""><br><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087a06f5fb4c2e?w=808&amp;h=188&amp;f=png&amp;s=22508" alt=""><br>beanDefinitionMap</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087a1b5ada4189?w=1191&amp;h=413&amp;f=png&amp;s=48945" alt=""><br>manualSingletonNames</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087a204892dc0a?w=782&amp;h=306&amp;f=png&amp;s=32662" alt=""></p>
<h3 id="4、postProcessBeanFactory"><a href="#4、postProcessBeanFactory" class="headerlink" title="4、postProcessBeanFactory"></a>4、postProcessBeanFactory</h3><p>注册web特性的全局域</p>
<p><strong>1).registerWebApplicationScopes</strong><br><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087a32aa0195bc?w=855&amp;h=201&amp;f=png&amp;s=15426" alt=""><br>注册具有web特性的域；包括：”request”, “session”, “globalSession”, “application”</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087a462ab9a807?w=824&amp;h=408&amp;f=png&amp;s=35130" alt=""><br>看下存储结构：<br><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087a48b52b1efb?w=530&amp;h=46&amp;f=png&amp;s=3519" alt=""><br>registerScope方法<br><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087a4cda81d6b1?w=809&amp;h=140&amp;f=png&amp;s=11295" alt=""><br><strong>2).registerEnvironmentBeans</strong></p>
<p>注册web特性 环境bean（“contextparameters”、“ContextAttribute”）与给定的WebApplicationContext使用BeanFactory。</p>
<p>1.servletContext<br><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087a7c6281aca0?w=1220&amp;h=401&amp;f=png&amp;s=52028" alt=""><br>2.servletConfig<br><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087a98a9e47514?w=1224&amp;h=255&amp;f=png&amp;s=38217" alt=""><br>3.registerSingleton</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087ac67b8a29be?w=773&amp;h=308&amp;f=png&amp;s=31414" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087ac95dcd1938?w=1071&amp;h=246&amp;f=png&amp;s=34326" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087acbf2427eda?w=880&amp;h=305&amp;f=png&amp;s=34889" alt=""><br>这里是找到了我们默认的配置文件参数：<br><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087aceb75503c0?w=796&amp;h=334&amp;f=png&amp;s=52552" alt=""><br>beanName=contextParameters</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087af2fc1441a9?w=689&amp;h=172&amp;f=png&amp;s=11770" alt=""><br><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087af4eefec01f?w=1127&amp;h=165&amp;f=png&amp;s=26627" alt=""><br><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087af6a105d944?w=886&amp;h=269&amp;f=png&amp;s=34219" alt=""><br>最后是将contextAttributes放入；contextAttributes中包含的属性值比较多，具体如下面所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087b0058a9d783?w=931&amp;h=258&amp;f=png&amp;s=37259" alt=""><br>主要包括：<br>javax.servlet.context.tempdir,<br>org.apache.catalina.resources, org.springframework.web.context.support.ServletContextScope, org.apache.tomcat.util.scan.MergedWebXml,<br>org.apache.tomcat.InstanceManager,<br>org.apache.catalina.jsp_classpath,<br>javax.websocket.server.ServerContainer,<br>org.apache.tomcat.JarScanner</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087b145d6705ce?w=1123&amp;h=223&amp;f=png&amp;s=28111" alt=""><br>这里是把需要的东西全部载入进来了，有很多。就不贴了(mime-mapping)….</p>
<h3 id="5、invokeBeanFactoryPostProcessors"><a href="#5、invokeBeanFactoryPostProcessors" class="headerlink" title="5、invokeBeanFactoryPostProcessors"></a>5、invokeBeanFactoryPostProcessors</h3><p><strong>BeanDefinitionRegistryPostProcessor实例化</strong>：标准BeanFactoryPostProcessor的扩展，BeanFactoryPostProcessor的作用是用来进一步定义注册的BeanDefinition，IoC容器本质就是Bean管理，所以BeanFactoryPostProcessor本身也是Bean，要对BeanFactoryPostProcessor的BeanDefinition进一步定义就通过BeanDefinitionRegistryPostProcessor进行注册，BeanDefinitionRegistryPostProcessor及其子类是Ioc容器最实例化的一类Bean。它们在ConfigurableApplicationContext（ApplicationContext子接口）实现类调用refresh()方法调用invokeBeanFactoryPostProcessors(beanFactory);方法时就被实例化。</p>
<p>OK，今天关于这部分的分析就到此结束了，后面的过程会在下一篇Spring系列文章中继续来讲refresh中的过程。</p>
<p><code>如果您对系列文章有任何意见，可以给我留言，感谢大家。</code></p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/spring-series-context-refresh/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/project-frame-maven-ssm/">基于maven构建多模块化的SSM框架</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T05:48:13.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/project-frame-maven-ssm/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/maven/" title="maven">maven</a>,
  
    <a href="/tags/ssm/" title="ssm">ssm</a>,
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/mybatis/" title="mybatis">mybatis</a>,
  
    <a href="/tags/web/" title="web">web</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>之前写过一篇SSM的框架整合；<a href="https://juejin.im/post/59f3ef5c51882534aa0691b2" target="_blank" rel="noopener">项目开发框架-SSM</a>；对SSM中的一些点进行了学习记录,那篇文章也是基于maven来创建的，那么为什么又要搞一篇呢？以我当前公司项目A来说，A项目包括前台、后台子项目【前台用于对外，后台用于管理】，如果按照前一篇文章的那种方式来进行，我们就需要建立两个单独的框架来进行开发，一样的拥有一套从dmo实体类包，util包，dao包，service包以及controller包，这种结构非常的紧凑和独立，但是问题在于，我们前后台使用的是同一个库，dmo、util、dao以及service中都会存在大量重复的代码，很多基础方法无法公用；另外一个原因是，我们还需要包装一些接口向外提供服务【不局限于我们自己的这两个系统】，这样一来，我们又需要再去抽离一次service，非常不方便。因此就使用maven来构建多模块项目，对于util、dao、rpc服务接口以及service进行模块化分离，这样一来，这些模块就可以对我们自己的前后台以及外部提供一些公关的服务，避免了大量的代码重复，也方便管理。</p>
<p><code>Maven多模块项目，通过合理的模块拆分，实现代码的复用，便于维护和管理。尤其是一些开源框架，也是采用多模块的方式，提供插件集成，用户可以根据需要配置指定的模块。</code></p>
<h1 id="构建多模块化项目"><a href="#构建多模块化项目" class="headerlink" title="构建多模块化项目"></a>构建多模块化项目</h1><p><code>基于maven构建多模块化项目主要依赖于maven可以实现父子项目的关系，子项目可以父项目的依赖Jar包，这样也方便我们去共同管理jar依赖，但是由于一个项目中毕竟会有很多人进行协同开发，在此过程中如果没有很好的约束，对于这种多模块化来说，解决jar包的冲突也很繁琐。</code></p>
<h2 id="新建一个父工程"><a href="#新建一个父工程" class="headerlink" title="新建一个父工程"></a>新建一个父工程</h2><p>1.创建maven项目</p>
<ul>
<li>step1:(新建maven项目)<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd33922055090e?w=522&amp;h=495&amp;f=jpeg&amp;s=27781" alt=""></li>
<li>step2:(勾选创建一个简单工程)<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd339da27c69e2?w=647&amp;h=349&amp;f=jpeg&amp;s=25698" alt=""></li>
<li>step3:(填写工程配置：主要是打包方式要选择pom方式)<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd33a64043c613?w=646&amp;h=609&amp;f=jpeg&amp;s=41840" alt=""><br>点击finish，父项目就创建成功了！<br>2.创建子项目</li>
<li>step1:(右击父项目-&gt;maven-&gt;New Maven Model Project)<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd345841f4595f?w=779&amp;h=549&amp;f=jpeg&amp;s=71841" alt=""></li>
<li>step2:<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd3469ac355dd4?w=641&amp;h=580&amp;f=jpeg&amp;s=37396" alt=""></li>
<li>step3:(一般情况下，我们项目中的util、dao、service都是可以直接分出来的，这里我们选择quickstart来构建,用于生产后面的jar包提供服务。我们的web子项目选择webapp来构建，用于配置文件、jsp文件/ftl/html/js/css等界面资源文件维护)<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd346f632a56de?w=648&amp;h=580&amp;f=jpeg&amp;s=57047" alt=""><br>点击finish，完成子模块的构建！构建之后的项目结构为：<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd34b0b69a6b8f?w=283&amp;h=242&amp;f=jpeg&amp;s=10977" alt=""><br>此时，我们的父模块中已经有了子模块的项目标识，新建的dao模块中不包括webapp此类的文件夹。那么这时就可以将我们的数据访问相关的类和接口都放在这个子模块中，如果其他项目需要使用，我们直接引入就行，引入方式如下（下面截图是从service模块引入dao模块的，这里的groupId，artifactId，version我们可以在dao的pom文件中直接复制使用）：<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd34f0c9671a6d?w=562&amp;h=82&amp;f=jpeg&amp;s=7070" alt=""><br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd34fdf62d1288?w=735&amp;h=289&amp;f=jpeg&amp;s=33325" alt=""><br>（上面新建的过程只作为演示而用，下面的引入和上面的新建项目并非一个项目）<br>其他的模块构建和dao的构建过程是一样的，这里就不一一构建了。源码地址在下面，解压之后，以maven项目方式导入，修改下数据库配置文件应该就可以直接运行了（当前项目基于jdk1.7写的，有的小伙伴如果用1.8的话，应该会出现jsp无法编译的一个错误）；源码附件中还有一个setting文件,阿里的，个人觉得用起来很不错，也推荐给大家!</li>
</ul>
<p>源码地址：<a href="http://download.csdn.net/download/sinat_25518349/10124726" target="_blank" rel="noopener">http://download.csdn.net/download/sinat_25518349/10124726</a><br>【这个是csdn的地址，现在资源上传还必需要选择C币，小伙伴如果没有csdn账户或者C币不足，可以在文章留言区留言，留下邮箱，我发给你们】</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/project-frame-maven-ssm/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/project-frame-ssm/">项目开发框架-SSM</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T05:41:24.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/project-frame-ssm/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/ssm/" title="ssm">ssm</a>,
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/mybatis/" title="mybatis">mybatis</a>,
  
    <a href="/tags/web/" title="web">web</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<h1 id="1-Spring"><a href="#1-Spring" class="headerlink" title="1.Spring"></a>1.Spring</h1><p>无需多言，作为开源届数一数二的典例，项目开发中无处不在；<br>核心IOC容器，用来装载bean（java中的类）-用Spring的IOC容器来管理Bean的生命周期，有了这样一种机制，我们就可以不用在代码中去重复的做new操作。<br>aop，面向切面编程，spring中最主要的是用于事务方面的使用。</p>
<h1 id="2-Spring-MVC"><a href="#2-Spring-MVC" class="headerlink" title="2.Spring MVC"></a>2.Spring MVC</h1><p>作用于web层，相当于controller，与struts中的action一样，都是用来处理用户请求的。同时，相比于struts2来说，更加细粒度，它是基于方法层面的，而struts是基于类层面的。<br><img src="https://user-gold-cdn.xitu.io/2017/10/28/ab2648fd768293a6fa61959ba1dbbc40" alt=""></p>
<h1 id="3-MyBatis"><a href="#3-MyBatis" class="headerlink" title="3.MyBatis"></a>3.MyBatis</h1><p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。[来自：<a href="http://www.mybatis.org/mybatis-3/zh/index.html]" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/zh/index.html]</a></p>
<p><strong>他人总结</strong></p>
<ul>
<li>Hibernate功能强大，数据库无关性好，O/R映射能力强，如果你对Hibernate相当精通，而且对Hibernate进行了适当的封装，那么你的项目整个持久层代码会相当简单，需要写的代码很少，开发速度很快，非常爽。 </li>
<li>Hibernate的缺点就是学习门槛不低，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡取得平衡，以及怎样用好Hibernate方面需要你的经验和能力都很强才行。 </li>
<li>MYBATIS入门简单，即学即用，提供了数据库查询的自动对象绑定功能，而且延续了很好的SQL使用经验，对于没有那么高的对象模型要求的项目来说，相当完美。 </li>
<li>MYBATIS的缺点就是框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。<h1 id="4-SSM框架整合"><a href="#4-SSM框架整合" class="headerlink" title="4.SSM框架整合"></a>4.SSM框架整合</h1>本项目将以购物为背景，主要包括商品信息及库存【因为想顺便学习一下事务的处理】、订单信息。下面将从数据库创建、项目结构说明、配置文件、业务代码等方面进行一步步说明。<h2 id="4-1-数据库创建"><a href="#4-1-数据库创建" class="headerlink" title="4.1 数据库创建"></a>4.1 数据库创建</h2>1.商品表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `goods` (</span><br><span class="line">  `goods_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;商品ID&apos;,</span><br><span class="line">  `goodsname` varchar(100) NOT NULL COMMENT &apos;商品名称&apos;,</span><br><span class="line">  `number` int(11) NOT NULL COMMENT &apos;商品库存&apos;,</span><br><span class="line">   PRIMARY KEY (`goods_id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8 COMMENT=&apos;商品表&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>初始化表数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `goods` (`goods_id`, `goodsname`, `number`)</span><br><span class="line">VALUES (1001, &apos;SN卫衣&apos;, 15)</span><br></pre></td></tr></table></figure></p>
<p>2.订单表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `orderinfo` (</span><br><span class="line">  `order_id` varchar(20) NOT NULL COMMENT &apos;订单编号&apos;,</span><br><span class="line">  `goods_id` bigint(18) NOT NULL COMMENT &apos;商品ID&apos;,</span><br><span class="line">  `user_id` bigint(10) NOT NULL COMMENT &apos;用户ID&apos;,</span><br><span class="line">  `order_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &apos;下单时间&apos; ,</span><br><span class="line">   PRIMARY KEY (`order_id`),</span><br><span class="line">   INDEX `idx_order_id` (`order_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;订单表&apos;</span><br></pre></td></tr></table></figure></p>
<p>OK，至此表结构及初始化数据构建完成，下面说下基于Mavan的项目结构。</p>
<h2 id="项目结构说明"><a href="#项目结构说明" class="headerlink" title="项目结构说明"></a>项目结构说明</h2><p>因为项目是使用maven来管理jar包的，先来贴一下，pom.xml的配置</p>
<ul>
<li>pom.xml<br>为了避免学习小伙伴崇尚拿来主义【也就是去除了xmlns之类的东西】，这里只放项目依赖的jar包的dependencies；本案例将本着“需则用”的原则，避免在网上看到的各种乱七八糟的依赖都丢进来的情况，造成资源浪费和干扰阅读。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">		&lt;!-- 单元测试 --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 1.日志 slf4j--&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;1.1.1&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 2.数据库连接驱动 --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;5.1.37&lt;/version&gt;</span><br><span class="line">			&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!-- 2.数据库连接池 --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;c3p0&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;c3p0&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;0.9.1.2&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 3.MyBatis 以及 spring-mybatis --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 4.Servlet 相关依赖 --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;taglibs&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;standard&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;1.1.2&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;jstl&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;jstl&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;2.5.4&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 5.Spring --&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;!-- 5.1 Spring核心 ：core bean context --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!-- 5.2 Spring jdbc依赖，事务依赖 --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-tx&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!-- 5.3 Spring web依赖&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!-- 5.4 Spring test --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 6.redis客户端:Jedis【不使用的话可以直接去除】 --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;protostuff-core&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;1.0.8&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;protostuff-runtime&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;1.0.8&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 7.工具类 --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;3.2&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">	&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>*项目结构图</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/28/2c7ad9c13a987f35dec09b1aa58d8eb8" alt=""><br><em>src/test/java：用于junit的测试类
</em>src/main/java:<br>   dao:数据库处理<br>   service:业务处理<br>   enums:项目枚举<br>   mapper:dao中方法对应mybatis映射文件，Sql就在这里面<br>   web：控制器，controller<br>   entity:项目中的实体类，如：商品类和订单类</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li>jdbc.properties<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://serverName:port/dbname?useUnicode=true&amp;characterEncoding=utf8</span><br><span class="line">jdbc.username=[填写自己的数据库用户名]</span><br><span class="line">jdbc.password=[填写自己的数据库登录密码]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>logback.xml<br>这里直接用的是控制台输出，如果是生产环境，可以根据具体的需求进行配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;configuration debug=&quot;true&quot;&gt;</span><br><span class="line">	&lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">	 ch.qos.logback.classic.encoder.PatternLayoutEncoder --&gt;</span><br><span class="line">		&lt;encoder&gt;</span><br><span class="line">			&lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;</span><br><span class="line">		&lt;/encoder&gt;</span><br><span class="line">	&lt;/appender&gt;</span><br><span class="line">	&lt;root level=&quot;debug&quot;&gt;</span><br><span class="line">		&lt;appender-ref ref=&quot;STDOUT&quot; /&gt;</span><br><span class="line">	&lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>mybatis-config<br>这里主要是MyBaties全局配置文件的配置，可以将一些类的别名、主键自增配置、驼峰命名规则配置等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">	&lt;!-- 配置全局属性 --&gt;</span><br><span class="line">	&lt;settings&gt;</span><br><span class="line">		&lt;!-- 使用jdbc的getGeneratedKeys获取数据库自增主键值 --&gt;</span><br><span class="line">		&lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot; /&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 使用列别名替换列名 默认:true --&gt;</span><br><span class="line">		&lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot; /&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 开启驼峰命名转换:Table&#123;create_time&#125; -&gt; Entity&#123;createTime&#125; --&gt;</span><br><span class="line">		&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">	&lt;/settings&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>spring 相关配置文件<br>为了更加清晰的了解spring各个组件的作用，这里将数据源的配置、事务配置和视图解析器的配置分开来。<br><strong>spring-dao.xml</strong><br>这里面主要就是spring配置整合mybatis的具体过程，具体包括：<br>1.引入数据库配置文件<br>2.配置数据源【数据库连接池】<br>3.配置SqlSessionFactory对象<br>4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 1.配置数据库相关参数properties的属性：$&#123;url&#125; --&gt;</span><br><span class="line">&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 2.数据库连接池 --&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">	&lt;!-- 配置连接池属性 --&gt;</span><br><span class="line">	&lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- c3p0连接池的私有属性 --&gt;</span><br><span class="line">	&lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot; /&gt;</span><br><span class="line">	&lt;!-- 关闭连接后不自动commit --&gt;</span><br><span class="line">	&lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">	&lt;!-- 获取连接超时时间 --&gt;</span><br><span class="line">	&lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot; /&gt;</span><br><span class="line">	&lt;!-- 当获取连接失败重试次数 --&gt;</span><br><span class="line">	&lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 3.配置SqlSessionFactory对象 --&gt;</span><br><span class="line">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">	&lt;!-- 注入数据库连接池 --&gt;</span><br><span class="line">	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">	&lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;</span><br><span class="line">	&lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot; /&gt;</span><br><span class="line">	&lt;!-- 扫描entity包 使用别名 --&gt;</span><br><span class="line">	&lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.glmapper.framerwork.entity&quot; /&gt;</span><br><span class="line">	&lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt;</span><br><span class="line">	&lt;property name=&quot;mapperLocations&quot; value=&quot;com.glmapper.framerwork.mapper/*.xml&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt;</span><br><span class="line">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">	&lt;!-- 注入sqlSessionFactory --&gt;</span><br><span class="line">	&lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt;</span><br><span class="line">	&lt;!-- 给出需要扫描Dao接口包 --&gt;</span><br><span class="line">	&lt;property name=&quot;basePackage&quot; value=&quot;com.glmapper.framerwork.dao&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>spring-service<br>实际的开发过程中事务一般都是在service层进行操作。因此用一个单独的spring-service.xml来进行事务的相关的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   &lt;!-- 扫描service包下所有使用注解的类型 --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.glmapper.framerwork.service&quot; /&gt;</span><br><span class="line">&lt;!-- 配置事务管理器 --&gt;</span><br><span class="line">&lt;bean id=&quot;transactionManager&quot;</span><br><span class="line">	class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">	&lt;!-- 注入数据库连接池 --&gt;</span><br><span class="line">	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 配置基于注解的声明式事务 --&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>spring-web.xml<br>配置SpringMVC；需要说明一下，一般我们在实际的开发过程中，会配置json2map解析。这里没有用到就不贴出来，读者可以自行网上搜索一波。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 1.开启SpringMVC注解模式 --&gt;</span><br><span class="line">&lt;mvc:annotation-driven /&gt;</span><br><span class="line">&lt;!-- 2.静态资源默认servlet配置</span><br><span class="line">	(1)加入对静态资源的处理：js,css,图片等</span><br><span class="line">	(2)允许使用&quot;/&quot;做整体映射</span><br><span class="line"> --&gt;</span><br><span class="line"> &lt;mvc:default-servlet-handler/&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;!-- 3.配置视图解析器ViewResolver --&gt;</span><br><span class="line"> &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line"> 	&lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;</span><br><span class="line"> 	&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;</span><br><span class="line"> 	&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;</span><br><span class="line"> &lt;/bean&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;!-- 4.扫描web相关的bean --&gt;</span><br><span class="line"> &lt;context:component-scan base-package=&quot;com.glmapper.framerwork.web&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>web.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 编码过滤器 --&gt;  </span><br><span class="line">    &lt;filter&gt;  </span><br><span class="line">        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;  </span><br><span class="line">        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;  </span><br><span class="line">        &lt;async-supported&gt;true&lt;/async-supported&gt;  </span><br><span class="line">        &lt;init-param&gt;  </span><br><span class="line">            &lt;param-name&gt;encoding&lt;/param-name&gt;  </span><br><span class="line">            &lt;param-value&gt;UTF-8&lt;/param-value&gt;  </span><br><span class="line">        &lt;/init-param&gt;  </span><br><span class="line">    &lt;/filter&gt;  </span><br><span class="line">    &lt;filter-mapping&gt;  </span><br><span class="line">        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;  </span><br><span class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  </span><br><span class="line">    &lt;/filter-mapping&gt;  </span><br><span class="line">     &lt;!-- Spring监听器 --&gt;  </span><br><span class="line">    &lt;listener&gt;  </span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  </span><br><span class="line">    &lt;/listener&gt;  </span><br><span class="line">    &lt;!-- 防止Spring内存溢出监听器 --&gt;  </span><br><span class="line">    &lt;listener&gt;  </span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt;  </span><br><span class="line">    &lt;/listener&gt; </span><br><span class="line">&lt;!-- 配置DispatcherServlet --&gt;</span><br><span class="line">	&lt;servlet&gt;</span><br><span class="line">		&lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;</span><br><span class="line">		&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">		&lt;!-- 配置springMVC需要加载的配置文件</span><br><span class="line">			spring-dao.xml,spring-service.xml,spring-web.xml</span><br><span class="line">			Mybatis - &gt; spring -&gt; springmvc</span><br><span class="line">		 --&gt;</span><br><span class="line">		&lt;init-param&gt;</span><br><span class="line">			&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">			&lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt;</span><br><span class="line">		&lt;/init-param&gt;</span><br><span class="line">	&lt;/servlet&gt;</span><br><span class="line">	&lt;servlet-mapping&gt;</span><br><span class="line">		&lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;</span><br><span class="line">		&lt;!-- 默认匹配所有的请求 --&gt;</span><br><span class="line">		&lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">	&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>至此，所有的配置文件结束，下面将进行具体的代码环节</p>
<h2 id="业务代码"><a href="#业务代码" class="headerlink" title="业务代码"></a>业务代码</h2><p>这里mapper中的xml文件就不贴了，自行脑补。。。。</p>
<ul>
<li>实体类：包括商品和订单</li>
</ul>
<p><strong>商品类</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 商品信息类</span><br><span class="line"> * @author glmapper</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Goods &#123;</span><br><span class="line">	private long goodsId;// 商品ID</span><br><span class="line">	private String goodsName;// 商品名称</span><br><span class="line">	private int number;// 商品库存</span><br><span class="line"></span><br><span class="line">	public long getGoodsId() &#123;</span><br><span class="line">		return goodsId;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setGoodsId(long goodsId) &#123;</span><br><span class="line">		this.goodsId = goodsId;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getGoodsName() &#123;</span><br><span class="line">		return goodsName;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setGoodsName(String goodsName) &#123;</span><br><span class="line">		this.goodsName = goodsName;</span><br><span class="line">	&#125;</span><br><span class="line">	public int getNumber() &#123;</span><br><span class="line">		return number;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setNumber(int number) &#123;</span><br><span class="line">		this.number = number;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>订单类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 订单信息类</span><br><span class="line"> * @author glmapper</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class OrderInfo &#123;</span><br><span class="line">	private String orderId;//订单ID</span><br><span class="line">	private long goodsId;//商品ID</span><br><span class="line">	private long userId;//用户ID</span><br><span class="line">	private Date orderTime;//下单时间</span><br><span class="line">	public String getOrderId() &#123;</span><br><span class="line">		return orderId;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setOrderId(String orderId) &#123;</span><br><span class="line">		this.orderId = orderId;</span><br><span class="line">	&#125;</span><br><span class="line">	public long getGoodsId() &#123;</span><br><span class="line">		return goodsId;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setGoodsId(long goodsId) &#123;</span><br><span class="line">		this.goodsId = goodsId;</span><br><span class="line">	&#125;</span><br><span class="line">	public long getUserId() &#123;</span><br><span class="line">		return userId;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setUserId(long userId) &#123;</span><br><span class="line">		this.userId = userId;</span><br><span class="line">	&#125;</span><br><span class="line">	public Date getOrderTime() &#123;</span><br><span class="line">		return orderTime;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setOrderTime(Date orderTime) &#123;</span><br><span class="line">		this.orderTime = orderTime;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>商品dao</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public interface GoodsDao &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 通过ID查询单件商品信息</span><br><span class="line">	 * </span><br><span class="line">	 * @param id</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	Goods queryById(long id);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 查询所有商品信息</span><br><span class="line">	 * </span><br><span class="line">	 * @param offset 查询起始位置</span><br><span class="line">	 * @param limit 查询条数</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	List&lt;Goods&gt; queryAll(@Param(&quot;offset&quot;) int offset, @Param(&quot;limit&quot;) int limit);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 减少商品库存</span><br><span class="line">	 * </span><br><span class="line">	 * @param bookId</span><br><span class="line">	 * @return 如果影响行数等于&gt;1，表示更新的记录行数</span><br><span class="line">	 */</span><br><span class="line">	int reduceNumber(long goodsId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>订单dao</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface OrderInfoDao &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 插入订单记录</span><br><span class="line">	 * </span><br><span class="line">	 * @param OrderInfo orderInfo</span><br><span class="line">	 * @return 插入的行数</span><br><span class="line">	 */</span><br><span class="line">	int insertOrderInfo(OrderInfo orderInfo);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 通过主键查询订单记录，返回订单实体 </span><br><span class="line">	 * @param orderId</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	OrderInfo queryByOrderId(String orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下单服务接口orderService</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">@Service(&quot;orderService&quot;)</span><br><span class="line">public class OrderServiceImpl implements OrderService &#123;</span><br><span class="line">	//log生成器</span><br><span class="line">	private Logger logger = LoggerFactory.getLogger(OrderServiceImpl.class);</span><br><span class="line">	</span><br><span class="line">	// 注入dao依赖【商品dao，订单dao】</span><br><span class="line">	@Autowired</span><br><span class="line">	private GoodsDao goodsDao;</span><br><span class="line">	@Autowired</span><br><span class="line">	private OrderInfoDao orderInfoDao;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public Goods getById(long goodsId) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return goodsDao.queryById(goodsId);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public List&lt;Goods&gt; getList(int offset,int limit) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return goodsDao.queryAll(offset, limit);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	@Transactional</span><br><span class="line">	public OrderInfo buyGoods(long goodsId, long userId) &#123;</span><br><span class="line">		//扣减库存，插入订单 =一个事务  如果失败则执行回滚</span><br><span class="line">		try &#123;</span><br><span class="line">			// 减库存</span><br><span class="line">			int update = goodsDao.reduceNumber(goodsId);</span><br><span class="line">			if (update &lt;= 0) &#123;// 库存不足</span><br><span class="line">				throw new NoNumberException(&quot;no number&quot;);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				// 执行预约操作</span><br><span class="line">				OrderInfo orderInfo=new OrderInfo();</span><br><span class="line">				orderInfo.setGoodsId(goodsId);</span><br><span class="line">				orderInfo.setUserId(userId);</span><br><span class="line">				orderInfo.setOrderTime(new Date());</span><br><span class="line">				String orderId=getRandomOrderId(goodsId);</span><br><span class="line">				orderInfo.setOrderId(orderId);</span><br><span class="line">				int insert = orderInfoDao.insertOrderInfo(orderInfo);</span><br><span class="line">				if (insert &lt;= 0) &#123;// 重复预约</span><br><span class="line">					throw new RepeatAppointException(&quot;repeat appoint&quot;);</span><br><span class="line">				&#125; else &#123;// 预约成功</span><br><span class="line">					return orderInfo;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			//这里可以丰富下具体的返回信息</span><br><span class="line">			logger.error(&quot;下单失败&quot;);</span><br><span class="line">		&#125; </span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private String getRandomOrderId(long goodsId) &#123;</span><br><span class="line">		SimpleDateFormat dateFormater = new SimpleDateFormat(&quot;yyyyMMddhhmmss&quot;);</span><br><span class="line">		String prefix=dateFormater.format(new Date());</span><br><span class="line">		String goodsIdStr=goodsId+&quot;&quot;;</span><br><span class="line">		String temp=&quot;&quot;;</span><br><span class="line">		for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">			Random random=new Random(goodsIdStr.length()-1);</span><br><span class="line">			temp+=goodsIdStr.charAt(random.nextInt());</span><br><span class="line">		&#125;</span><br><span class="line">		return prefix+temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>OK，至此所有核心代码及配置文件罗列完毕；【mapper中的xml和具体的controller就不贴了，相信大家对这个也不陌生。本文主要意图在于梳理下自己学习中的一些点，SSM框架在实际的应用开发中还会有很多其他的开源技术结合进来，如：quartz,redis等。当前本文的列子就是一个空壳子，以备参考吧】</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/project-frame-ssm/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/spring-series-starting/">Spring源码系列：Spring的启动过程</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T05:37:30.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/spring-series-starting/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>Spring对于程序员说来说都不陌生；作为一个强大的开源技术，帮助我们能够更好的进行项目的开发与维护。<br>直接进入主题吧。Spring的启动过程实际上就是Ioc容器初始化以及载入Bean的过程；本文主要是学习记录下前半部分（Ioc容器的初始化），新手上路，如有错误，请指正！<br>1.从配置文件说起</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener</span><br><span class="line">     <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在一般的WEB项目中，项目的启动一般是从web.xml文件的载入开始的。如果我们的项目中使用了Spring，那么你肯定会在你的web.xml文件中看到上面的配置。Spring正是通过ContextLoaderListener监听器来进行容器初始化的。下面通过代码进行分析。</p>
<p>2.Spring容器加载的三步走</p>
<ul>
<li>step1:创建一个WebApplicationContext</li>
<li>step2:配置并且刷新Bean</li>
<li>step3：将容器初始化到servlet上下文中</li>
</ul>
<p>3.WebApplicationContext的创建过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span></span></span><br></pre></td></tr></table></figure></p>
<p>从ContextLoaderListener的定义可以看出，该监听器继承了ContextLoader，并且重写了ServletContextListener中的contextInitialized和contextDestroyed方法。</p>
<p>在contextInitialized中，通过调用父类（ContextLoader）的initWebApplicationContext方法进行容器创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">    initWebApplicationContext(event.getServletContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面来看initWebApplicationContext的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1：判断当前容器是否存在，如果存在则报容器已经存在的异常信息</span></span><br><span class="line">    <span class="keyword">if</span> (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">          <span class="string">"Cannot initialize context because there is already a root application context present - "</span> +</span><br><span class="line">          <span class="string">"check whether you have multiple ContextLoader* definitions in your web.xml!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Log logger = LogFactory.getLog(ContextLoader.class);</span><br><span class="line">    <span class="comment">//下面这个日志就是我们经常在启动Spring项目时看到的日志信息: </span></span><br><span class="line">    <span class="comment">//Initializing Spring root WebApplicationContext</span></span><br><span class="line">    <span class="comment">//Root WebApplicationContext: initialization started</span></span><br><span class="line">    servletContext.log(<span class="string">"Initializing Spring root WebApplicationContext"</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">"Root WebApplicationContext: initialization started"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Store context in local instance variable, to guarantee that</span></span><br><span class="line">      <span class="comment">// it is available on ServletContext shutdown.</span></span><br><span class="line">      <span class="comment">//如果当前容器为null,则创建一个容器，并将servletContext上下文作为参数传递进去，</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.context = createWebApplicationContext(servletContext);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//判断当前容器是否为可配置的，只有是Configurable的容器，才能进行后续的配置</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">        ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class="keyword">this</span>.context;</span><br><span class="line">        <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">          <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">          <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">          <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// The context instance was injected without an explicit parent -&gt;</span></span><br><span class="line">            <span class="comment">// determine parent for root web application context, if any.</span></span><br><span class="line">            ApplicationContext parent = loadParentContext(servletContext);</span><br><span class="line">            cwac.setParent(parent);</span><br><span class="line">          &#125;</span><br><span class="line">           <span class="comment">//三步走中的第二步：配置并且刷新当前容器</span></span><br><span class="line">          configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//将配置并且刷新过的容器存入servlet上下文中，并以WebApplicationContext的类名作为key值</span></span><br><span class="line"></span><br><span class="line">      servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.context);</span><br><span class="line"></span><br><span class="line">      ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">      <span class="keyword">if</span> (ccl == ContextLoader.class.getClassLoader()) &#123;</span><br><span class="line">        currentContext = <span class="keyword">this</span>.context;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ccl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        currentContextPerThread.put(ccl, <span class="keyword">this</span>.context);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Published root WebApplicationContext as ServletContext attribute with name ["</span> +</span><br><span class="line">            WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        <span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">        logger.info(<span class="string">"Root WebApplicationContext: initialization completed in "</span> + elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//返回创建好的容器</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">      logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">      servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">      logger.error(<span class="string">"Context initialization failed"</span>, err);</span><br><span class="line">      servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>下面我们在看下是如何创建WebApplicationContext的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(ServletContext sc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先来确定context是由什么类定义的，并且判断当前容器是否为可配置的</span></span><br><span class="line">    Class&lt;?&gt; contextClass = determineContextClass(sc);</span><br><span class="line">    <span class="keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Custom context class ["</span> + contextClass.getName() +</span><br><span class="line">          <span class="string">"] is not of type ["</span> + ConfigurableWebApplicationContext.class.getName() + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建可配置的上下文容器</span></span><br><span class="line">    <span class="keyword">return</span> (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>最后来看下determineContextClass这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; determineContextClass(ServletContext servletContext) &#123;</span><br><span class="line">    <span class="comment">//首先从web.xml中查看用户是否自己定义了context</span></span><br><span class="line">    String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);</span><br><span class="line">    <span class="comment">//如果有，则通过反射创建实例</span></span><br><span class="line">    <span class="keyword">if</span> (contextClassName != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">            <span class="string">"Failed to load custom context class ["</span> + contextClassName + <span class="string">"]"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*如果没有，则去defaultStrategies里面取【defaultStrategies是Propertites类的/对象，在ContextLoader中的静态代码块中初始化的；具体可看下下面的图像】；默认容器是XmlWebApplicationContext*/</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   contextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">            <span class="string">"Failed to load default context class ["</span> + contextClassName + <span class="string">"]"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>总的来说就是：Spring的web工程首先回去检查用户是否自己定义了context，如果有就采用；如果没有就使用Spring默认的。<br>defaultStrategies初始化：<br><img src="https://user-gold-cdn.xitu.io/2017/8/27/62ee7d396cdab1a3636d6d4237b4ca76" alt=""></p>
<p>至此，容器创建完成。下面是整个过程的一个流程图（有疏漏，回头补一个时序图）：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/8/27/f4fe5698c40759d2a1eadb1a0d390f91" alt=""></p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/spring-series-starting/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/spring-aop-advice/">聊一聊 AOP：Advice 源码解析</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T05:22:10.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/spring-aop-advice/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/aop/" title="aop">aop</a>,
  
    <a href="/tags/聊一聊/" title="聊一聊">聊一聊</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<blockquote>
<p>在第一篇中的例子和概念介绍中我们对 Advice 有了一个初步的认知。在Spring AOP中，Advice的作用就是用来描述 Spring AOP 围绕方法调用而注入的切面行为。</p>
</blockquote>
<p>本篇文章将从源码的角度来看一看 <code>Advice</code> 到底是什么样的？又是怎么完成通知的？</p>
<h2 id="Advice-接口"><a href="#Advice-接口" class="headerlink" title="Advice 接口"></a>Advice 接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.aopalliance.aop;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tag interface for Advice. Implementations can be any type</span></span><br><span class="line"><span class="comment"> * of advice, such as Interceptors.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> $Id: Advice.java,v 1.1 2004/03/19 17:02:16 johnsonr Exp $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Advice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Advice</code> 接口的定义是在 <code>org.aopalliance.aop</code> 包下面的；从上面的代码中我们可以知道，<code>Advice</code> 接口并没有提供任何的方法；类似的接口定义还有<code>java</code> 中的如<code>Serializable</code>接口，这类接口一般称之为标识接口；标识接口对实现它的类没有任何的语义要求,仅仅是充当一个标示的作用,用来表明实现它的类属于一个特定的类型（从这种标识性角度来说，和注解其实挺像的）；</p>
<p><code>Spring AOP</code>中通过定义和使用这样一个统一的接口，为的就是能够为切面增强的织入功能做更多的细化和扩展。下面就对常见的三个<code>Advice</code>进行分析。</p>
<h2 id="BeforeAdvice"><a href="#BeforeAdvice" class="headerlink" title="BeforeAdvice"></a>BeforeAdvice</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeforeAdvice</span> <span class="keyword">extends</span> <span class="title">Advice</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口也是一个标识接口。看下 <code>BeforeAdvice</code> 的继承关系：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/22/1642834fc63bae1d?w=1644&amp;h=250&amp;f=png&amp;s=77901" alt=""></p>
<p><code>MethodBeforeAdvice</code> 是 <code>BeforeAdvice</code> 为待增强的目标方法设置的前置增强接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodBeforeAdvice</span> <span class="keyword">extends</span> <span class="title">BeforeAdvice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">    Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MethodBeforeAdvice</code> 中提供了一个回调函数 <code>before(…)</code> ；</p>
<p>作为回调函数，<code>before</code> 方法的实现在 <code>Advice</code> 中被配置到目标方法后，会在调用目标方法时被回调。来看下<code>before</code>方法的几个参数：</p>
<ul>
<li>Method method ：（ method being invoked）这个参数是目标方法的反射对象；</li>
<li>Object[] args ：（arguments to the method）目标方法的输入参数；</li>
<li>Object target ：（target of the method invocation）方法调用的目标</li>
</ul>
<h2 id="AspectJMethodBeforeAdvice"><a href="#AspectJMethodBeforeAdvice" class="headerlink" title="AspectJMethodBeforeAdvice"></a>AspectJMethodBeforeAdvice</h2><p><code>AspectJMethodBeforeAdvice</code> 继承了 <code>AbstractAspectJAdvice</code> 抽象类，并实现了 <code>MethodBeforeAdvice</code> 接口。从 <code>AspectJMethodBeforeAdvice</code> 类中代码可以得知，<code>AspectJMethodBeforeAdvice</code> 重写 <code>before</code> 方法的实现是 通过调用父类的 <code>invokeAdviceMethod</code> 方法完成的。也就是说<code>Spring AOP</code> 的<code>Advice</code>包装了<code>AspectJ</code>的<code>before</code>方法。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642a5ea16c25b2d?w=1578&amp;h=618&amp;f=png&amp;s=128780" alt=""></p>
<p>Spring AOP的实现后面再说，我们先自己来实现一个简单的通知。</p>
<h2 id="自定义-Advice实现-MethodBeforeAdvice"><a href="#自定义-Advice实现-MethodBeforeAdvice" class="headerlink" title="自定义 Advice实现 MethodBeforeAdvice"></a>自定义 Advice实现 MethodBeforeAdvice</h2><p>定义我们自己的 <code>GlmapperBeforeMethodAdvice</code> ；这里实现 <code>MethodBeforeAdvice</code> 接口，然后重写 <code>before</code> 这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 自定义的 GlmapperBeforeMethodAdvice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: glmapper@leishu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/6/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperBeforeMethodAdvice</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class"><span class="title">MethodBeforeAdvice</span>,<span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER =</span><br><span class="line">    LoggerFactory.getLogger(GlmapperBeforeMethodAdvice.class.getSimpleName());</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"invoke BeforeAdvice successfully..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result=invocation.proceed();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，有了这个 <code>GlmapperBeforeMethodAdvice</code> ，再来看看怎么用它；同样本篇文章所使用的案例均使用前一篇博客中的那个脚手架来完成。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--我们的目标类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"goodsService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.service.impl.GoodsServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--我们自定义的Advice--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"glmapperBeforeMethodAdvice"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.Advice.GlmapperBeforeMethodAdvice"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 声明切入点adviser --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"adviser"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.RegexpMethodPointcutAdvisor"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里使用我们自定义的advice--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advice"</span> <span class="attr">ref</span>=<span class="string">"glmapperBeforeMethodAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- pattern指定queryAll方法作为切入点； \. 这个是转义使用--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pattern"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">value</span>=<span class="string">"com\.glmapper\.framerwork\.service\.impl\.GoodsServiceImpl\.queryAll"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义代理对象 返回实例是目标对象 target属性指定的goodsService对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"proxyService"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"goodsService"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--源码内固定的属性private String[] interceptorNames;  --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">value</span>&gt;</span>adviser<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>客户端部分，通过SpringContextUtil来拿代理对象；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/initPage"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">initPage</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">		HttpServletResponse response, ModelAndView view)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取代理bean</span></span><br><span class="line">    GoodsService proxyService= (GoodsService) SpringContextUtil.getBean(<span class="string">"proxyService"</span>);</span><br><span class="line">    <span class="comment">//调用</span></span><br><span class="line">    List&lt;Goods&gt; goods = proxyService.queryAll(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    view.addObject(<span class="string">"goodsList"</span>, goods);</span><br><span class="line">    view.setViewName(<span class="string">"goodslist"</span>);</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志输出满足我们的期望（如下）：<br><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642abd5c1097135?w=1516&amp;h=62&amp;f=png&amp;s=26032" alt=""></p>
<p>同样的，在<code>GlmapperBeforeMethodAdvice</code>基础上再实现 <code>AfterReturningAdvice </code>接口，重写<code>afterReturning</code>方法，就能实现后置通知。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[]</span></span></span><br><span class="line"><span class="function"><span class="params">args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"invoke AfterAdvice successfully..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方式在<a href="https://juejin.im/post/5b1ca657f265da6e5a205c45" target="_blank" rel="noopener">聊一聊 AOP ：表现形式与基础概念</a>中有说道。</p>
<h2 id="Advice-在-Aop-中的实现原理"><a href="#Advice-在-Aop-中的实现原理" class="headerlink" title="Advice 在 Aop 中的实现原理"></a>Advice 在 Aop 中的实现原理</h2><p>这里感觉没什么好说的，上面的案例其实就是Spring提供给我们使用的接口。因为MethodBeforeAdvice等都是继承自 AbstractAspectJAdvice 这个抽象类；我们就来看下这个抽象类里面的一些核心逻辑吧。我们按照AspectJMethodBeforeAdvice这里这个类里面before提供的线索来一步步分析。</p>
<p>首先在AspectJMethodBeforeAdvice里before方法中调用的是这个逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoke the advice method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> jpMatch the JoinPointMatch that matched this execution join point</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnValue the return value from the method execution (may be null)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ex the exception thrown by the method execution (may be null)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the invocation result</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable in case of invocation failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeAdviceMethod</span><span class="params">(JoinPointMatch jpMatch, Object</span></span></span><br><span class="line"><span class="function"><span class="params">returnValue, Throwable ex)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> invokeAdviceMethodWithGivenArgs(argBinding(getJoinPoint(),</span><br><span class="line">	jpMatch, returnValue, ex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 argBinding 方法的作用是获取方法执行连接点上的参数，并将一组参数输出给Advice方法。</p>
<p>继续来看invokeAdviceMethodWithGivenArgs这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeAdviceMethodWithGivenArgs</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">Throwable </span>&#123;</span><br><span class="line">    <span class="comment">//保存一份参数副本</span></span><br><span class="line">    Object[] actualArgs = args;</span><br><span class="line">    <span class="comment">//验证下参数是否不存在</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdviceMethod.getParameterTypes().length == <span class="number">0</span>) &#123;</span><br><span class="line">    	actualArgs = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//设置下方法的访问权限</span></span><br><span class="line">    	ReflectionUtils.makeAccessible(<span class="keyword">this</span>.aspectJAdviceMethod);</span><br><span class="line">    	<span class="comment">// invoke执行；这里先通过aspectInstanceFactory对像拿到我们的目标对象实例，然后再进行invoke调用执行</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.aspectJAdviceMethod.invoke(<span class="keyword">this</span>.aspectInstanceFactory.getAspectInstance(), actualArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">"Mismatch on arguments to advice method ["</span> +</span><br><span class="line">    			<span class="keyword">this</span>.aspectJAdviceMethod + <span class="string">"]; pointcut expression ["</span> +</span><br><span class="line">    			<span class="keyword">this</span>.pointcut.getPointcutExpression() + <span class="string">"]"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">    	<span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码其实就是通过反射的方式执行了我们的目标方法。我们再回过头来看下我们的目标方法到底在哪里去进行增强的；这里我们通过配置文件来看：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 代理对象 返回实例是目标对象 target属性指定的AOPservice对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"proxyService"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"goodsService"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--源码内固定的属性private String[] interceptorNames;  --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>adviser<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>代理对象proxyService实现上是ProxyFactoryBean产生的；这里就不在阐述BeanFactory和FactoryBean的区别了。</p>
<p>从上面的配置文件我们可以简单的了解到，代理对象实际上是我们目标对象+adviser共同组成；而在adviser里面又包括了我们的通知。</p>
<p>ProxyFactoryBean继承了FactoryBean，我们知道FactoryBean也是用来生成bean的，但是它生成的bean是通过其getObject方法来获取的。OK，那我们来看下ProxyFactoryBean的getObject方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a proxy. Invoked when clients obtain beans from this factory bean.</span></span><br><span class="line"><span class="comment"> * Create an instance of the AOP proxy to be returned by this factory.</span></span><br><span class="line"><span class="comment"> * The instance will be cached for a singleton, and create on each call to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> getObject()&#125; for a proxy.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a fresh AOP proxy reflecting the current state of this factory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">//初始化Advisor链</span></span><br><span class="line">    initializeAdvisorChain();</span><br><span class="line">    <span class="comment">//如果是单例，则获取单例对象</span></span><br><span class="line">    <span class="keyword">if</span> (isSingleton()) &#123;</span><br><span class="line">    	<span class="keyword">return</span> getSingletonInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span> (<span class="keyword">this</span>.targetName == <span class="keyword">null</span>) &#123;</span><br><span class="line">    		logger.warn(<span class="string">"Using non-singleton proxies with singleton targets is often undesirable. "</span> +</span><br><span class="line">    				<span class="string">"Enable prototype proxies by setting the 'targetName' property."</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> newPrototypeInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>返回一个代理。当客户端从这个工厂bean获取bean时调用。创建该工厂返回的AOP代理的一个实例。该实例将被缓存为一个单例，并在每次调用时创建。</p>
</blockquote>
<p>initializeAdvisorChain：创建 advisor（拦截器）链。每次添加新的 prototype 实例时，源自 BeanFactory 的 Advisor 都将被刷新。通过工厂 API 以编程方式添加的拦截器不受此类更改的影响。（译注）；其实就是根据我们配置的interceptorNames来初始化我们的advisor（拦截器）链，用来增强我们的目标调用方法。</p>
<p>下面是getSingletonInstance这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the singleton instance of this class's proxy object,</span></span><br><span class="line"><span class="comment"> * lazily creating it if it hasn't been created already.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the shared singleton proxy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Object <span class="title">getSingletonInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.singletonInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//创建目标对象的代理</span></span><br><span class="line">    	<span class="keyword">this</span>.targetSource = freshTargetSource();</span><br><span class="line">    	<span class="keyword">if</span> (<span class="keyword">this</span>.autodetectInterfaces &amp;&amp; getProxiedInterfaces().length == <span class="number">0</span> &amp;&amp; !isProxyTargetClass()) &#123;</span><br><span class="line">        	<span class="comment">// Rely on AOP infrastructure to tell us what interfaces to proxy.</span></span><br><span class="line">        	<span class="comment">//获取目标类</span></span><br><span class="line">        	Class&lt;?&gt; targetClass = getTargetClass();</span><br><span class="line">        	<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">        		<span class="keyword">throw</span> <span class="keyword">new</span> FactoryBeanNotInitializedException(<span class="string">"Cannot determine target class for proxy"</span>);</span><br><span class="line">        	&#125;</span><br><span class="line">        	setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, <span class="keyword">this</span>.proxyClassLoader));</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// Initialize the shared singleton instance.</span></span><br><span class="line">    	<span class="keyword">super</span>.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">    	<span class="keyword">this</span>.singletonInstance = getProxy(createAopProxy());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.singletonInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码最核心的是getProxy这个方法，这里方式有两个方式，一个是cglib，另外一种是jdk动态代理：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642c20eec4d6c09?w=1536&amp;h=506&amp;f=png&amp;s=201462" alt=""></p>
<p>这里我们以默认的动态代理的方式来说：(<code>org.springframework.aop.framework.JdkDynamicAopProxy类中</code>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    	logger.debug(<span class="string">"Creating JDK dynamic proxy: target source is "</span> +</span><br><span class="line">    	<span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt;[] proxiedInterfaces =</span><br><span class="line">    AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised);</span><br><span class="line">    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法返回的就是指定接口的代理类实例，该接口将方法调用分派给指定的调用处理程序。</p>
<p>到此整个AOP代理生成逻辑就完了。</p>
<p>总结一下就是我们的代理类中其实包括了我们AOP增强的那部分逻辑的，这个其实从上面的配置文件中就很清楚的可以看出来；所以从Adivce介个角度来说，它其实会被抱在advisor中，然后在被传递到代理对象中，代理对象除了拥有我们目标对象的能力之外，还包括了Adivce的能力；通过这种方式就实现了增强。</p>
<p>关于Advice就到这里了，下一章会来单独说一下 PointCut 。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/spring-aop-advice/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/spring-aop-base/">聊一聊 AOP ：表现形式与基础概念</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T05:20:06.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/spring-aop-base/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/aop/" title="aop">aop</a>,
  
    <a href="/tags/聊一聊/" title="聊一聊">聊一聊</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<blockquote>
<p>aop 终于提上日程来写一写了。</p>
</blockquote>
<h2 id="系列目录"><a href="#系列目录" class="headerlink" title="系列目录"></a>系列目录</h2><p>本系列分为 上、中、下三篇。上篇主要是介绍如果使用 AOP ，提供了demo和配置方式说明；中篇来对实现 AOP 的技术原理进行分析；下篇主要针对Spring中对于AOP的实现进行源码分析。</p>
<ul>
<li><a href="">从一个例子说起</a><ul>
<li><a href="">基于代理的方式</a> </li>
<li><a href="">纯POJO切面 配置方式</a></li>
<li><a href="">AspectJ 注解方式</a></li>
<li><a href="">AspectJ XML 配置方式</a></li>
<li><a href="">表达式说明</a>  </li>
</ul>
</li>
<li><a href="">基础概念</a><ul>
<li><a href="">AOP概念</a></li>
<li><a href="">Target Object</a></li>
<li><a href="">织入（Weave</a></li>
<li><a href="">Proxy</a></li>
<li><a href="">Introduction</a></li>
<li><a href="">Aspect</a></li>
<li><a href="">Joinpoint</a></li>
<li><a href="">Pointcut</a></li>
<li><a href="">Advice</a><ul>
<li><a href="">概念</a></li>
<li><a href="">分类</a></li>
</ul>
</li>
<li><a href="">关系</a></li>
</ul>
</li>
<li><a href="">一些坑</a></li>
</ul>
<h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p>项目地址：<a href="https://github.com/glmapper/glmapper-ssm-parent" target="_blank" rel="noopener">glmapper-ssm-parent</a></p>
<p>这个项目里面包含了下面几种 AOP 实现方式的所有代码，有兴趣的同学可以fork跑一下。这个demo中列举了4中方式的实现：</p>
<ul>
<li>基于代码的方式</li>
<li>基于纯POJO类的方式</li>
<li>基于Aspect注解的方式</li>
<li>基于注入式Aspect的方式</li>
</ul>
<p>目前我们经常用到的是<strong>基于Aspect注解的方式</strong>的方式。下面来一个个了解下不同方式的表现形式。</p>
<h2 id="基于代理的方式"><a href="#基于代理的方式" class="headerlink" title="基于代理的方式"></a>基于代理的方式</h2><p>这种方式看起来很好理解，但是配置起来相当麻烦；小伙伴们可以参考项目来看，这里只贴出比较关键的流程代码。</p>
<h3 id="1、首先定义一个接口：GoodsService"><a href="#1、首先定义一个接口：GoodsService" class="headerlink" title="1、首先定义一个接口：GoodsService"></a>1、首先定义一个接口：GoodsService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GoodsService</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询所有商品信息</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> offset 查询起始位置</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> limit 查询条数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">List&lt;Goods&gt; <span class="title">queryAll</span><span class="params">(<span class="keyword">int</span> offset,<span class="keyword">int</span> limit)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、GoodsService-实现类"><a href="#2、GoodsService-实现类" class="headerlink" title="2、GoodsService 实现类"></a>2、GoodsService 实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"goodsService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsServiceImpl</span> <span class="keyword">implements</span> <span class="title">GoodsService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span> </span><br><span class="line">	<span class="keyword">private</span> GoodsDao goodsDao;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Goods&gt; <span class="title">queryAll</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"执行了queryAll方法"</span>);</span><br><span class="line">		List&lt;Goods&gt; list = <span class="keyword">new</span> ArrayList&lt;Goods&gt;();</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、定义一个通知类-LoggerHelper，该类继承-MethodBeforeAdvice和-AfterReturningAdvice。"><a href="#3、定义一个通知类-LoggerHelper，该类继承-MethodBeforeAdvice和-AfterReturningAdvice。" class="headerlink" title="3、定义一个通知类 LoggerHelper，该类继承 MethodBeforeAdvice和 AfterReturningAdvice。"></a>3、定义一个通知类 LoggerHelper，该类继承 MethodBeforeAdvice和 AfterReturningAdvice。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通知类 LoggerHelper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerHelper</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span>,</span></span><br><span class="line"><span class="class"><span class="title">AfterReturningAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(LoggerHelper.class);</span><br><span class="line">    <span class="comment">//MethodBeforeAdvice的before方法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"before current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//AfterReturningAdvice的afterReturning方法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object o, Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">    Object[] objects, Object o1)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"afterReturning current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、重点，这个配置需要关注下。这个项目里面我是配置在applicationContext-xml文件中的。"><a href="#4、重点，这个配置需要关注下。这个项目里面我是配置在applicationContext-xml文件中的。" class="headerlink" title="4、重点，这个配置需要关注下。这个项目里面我是配置在applicationContext.xml文件中的。"></a>4、重点，这个配置需要关注下。这个项目里面我是配置在applicationContext.xml文件中的。</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义被代理者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"goodsServiceImpl"</span> <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.service.impl.GoodsServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义通知内容，也就是切入点执行前后需要做的事情 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loggerHelper"</span> <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.aspect.LoggerHelper"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义切入点位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loggerPointcut"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.JdkRegexpMethodPointcut"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">".*query.*"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使切入点与通知相关联，完成切面配置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 从这里可以帮助我们理解Advisor，advice和pointcut之间的关系--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--adivce和pointcut是Advisor的两个属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loggerHelperAdvisor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.DefaultPointcutAdvisor"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advice"</span> <span class="attr">ref</span>=<span class="string">"loggerHelper"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pointcut"</span> <span class="attr">ref</span>=<span class="string">"loggerPointcut"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 设置代理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"proxy"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 代理的对象 ，也就是目标类--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span> <span class="attr">ref</span>=<span class="string">"goodsServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 使用切面 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span> <span class="attr">value</span>=<span class="string">"loggerHelperAdvisor"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 代理接口，商品接口 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span> <span class="attr">value</span>=<span class="string">"com.glmapper.framerwork.service.GoodsService"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="5、使用：注解注入方式"><a href="#5、使用：注解注入方式" class="headerlink" title="5、使用：注解注入方式"></a>5、使用：注解注入方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/buy"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line">    <span class="comment">//因为我们已经在配置文件中配置了proxy，</span></span><br><span class="line">    <span class="comment">//所以这里可以直接注入拿到我们的代理类</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GoodsService proxy;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/initPage"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">initPage</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">    	HttpServletResponse response, ModelAndView view)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里使用proxy执行了*query*,</span></span><br><span class="line">    List&lt;Goods&gt; goods = proxy.queryAll(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    view.addObject(<span class="string">"goodsList"</span>, goods);</span><br><span class="line">    view.setViewName(<span class="string">"goodslist"</span>);</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6、使用：工具类方式手动获取bean"><a href="#6、使用：工具类方式手动获取bean" class="headerlink" title="6、使用：工具类方式手动获取bean"></a>6、使用：工具类方式手动获取bean</h3><p>这个方式是通过一个SpringContextUtil工具类来获取代理对象的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/initPage&quot;)</span><br><span class="line">public ModelAndView initPage(HttpServletRequest request,</span><br><span class="line">	HttpServletResponse response, ModelAndView view) &#123;</span><br><span class="line">    //这里通过工具类来拿，效果一样的。</span><br><span class="line">    GoodsService proxy= (GoodsService) SpringContextUtil.getBean(&quot;proxy&quot;);</span><br><span class="line">    List&lt;Goods&gt; goods = proxy.queryAll(10,10);</span><br><span class="line">    view.addObject(&quot;goodsList&quot;, goods);</span><br><span class="line">    view.setViewName(&quot;goodslist&quot;);</span><br><span class="line">    return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="7、SpringContextUtil-类的定义"><a href="#7、SpringContextUtil-类的定义" class="headerlink" title="7、SpringContextUtil 类的定义"></a>7、SpringContextUtil 类的定义</h3><p>这个还是有点坑的，首先SpringContextUtil是继承ApplicationContextAware这个接口，我们希望能够SpringContextUtil可以被Spring容器直接管理，所以，需要使用 @Component 标注。标注了之后最关键的是它得能够被我们配置的注入扫描扫到（亲自踩的坑，我把它放在一个扫不到的包下面，一直debug都是null；差点砸电脑…）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringContextUtil</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring应用上下文环境</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现ApplicationContextAware接口的回调方法，设置上下文环境</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationContext</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        SpringContextUtil.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ApplicationContext</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取对象</span></span><br><span class="line"><span class="comment">     * 这里重写了bean方法，起主要作用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Object 一个以所给名字注册的bean的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8、运行结果"><a href="#8、运行结果" class="headerlink" title="8、运行结果"></a>8、运行结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">21:04:47.940 [http-nio-8080-exec-7] INFO </span><br><span class="line">c.g.framerwork.aspect.LoggerHelper - before current</span><br><span class="line">time:1529413487940</span><br><span class="line"></span><br><span class="line">执行了queryAll方法</span><br><span class="line"></span><br><span class="line">21:04:47.940 [http-nio-8080-exec-7] INFO </span><br><span class="line">c.g.framerwork.aspect.LoggerHelper - afterReturning current</span><br><span class="line">time:1529413487940</span><br></pre></td></tr></table></figure>
<p>上面就是最最经典的方式，就是通过代理的方式来实现AOP的过程。</p>
<h2 id="纯POJO切面-aop-config"><a href="#纯POJO切面-aop-config" class="headerlink" title="纯POJO切面 aop:config"></a>纯POJO切面 <a href="aop:config" target="_blank" rel="noopener">aop:config</a></h2><p>注意这里和LoggerHelper的区别，这里的LoggerAspect并没有继承任何接口或者抽象类。</p>
<h3 id="1、POJO-类定义"><a href="#1、POJO-类定义" class="headerlink" title="1、POJO 类定义"></a>1、POJO 类定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: [描述文本]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="guolei.sgl@antfin.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/6/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER =</span><br><span class="line">    LoggerFactory.getLogger(LoggerHelper.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"before current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"afterReturning current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义通知内容，也就是切入点执行前后需要做的事情 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loggerAspect"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.aspect.LoggerAspect"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"loggerAspect"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"loggerPointCut"</span>  <span class="attr">expression</span>=</span></span><br><span class="line"><span class="tag">    	"<span class="attr">execution</span>(* <span class="attr">com.glmapper.framerwork.service.impl.</span>*<span class="attr">.</span>*(<span class="attr">..</span>)) " /&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!-- 定义 Advice --&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!-- 前置通知 --&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"loggerPointCut"</span> <span class="attr">method</span>=<span class="string">"before"</span> /&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!-- 后置通知 --&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut-ref</span>=<span class="string">"loggerPointCut"</span></span></span><br><span class="line"><span class="tag">    	<span class="attr">method</span>=<span class="string">"afterReturning"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意这里LoggerAspect中的before和afterReturning如果有参数，这里需要处理下，否则会报 <strong>0 formal unbound in pointcut</strong> 异常。</p>
<h2 id="AspectJ-注解驱动方式"><a href="#AspectJ-注解驱动方式" class="headerlink" title="@AspectJ 注解驱动方式"></a>@AspectJ 注解驱动方式</h2><p>这种方式是最简单的一种实现，直接使用 @Aspect 注解标注我们的切面类即可。</p>
<h3 id="1、定义切面类，并使用-Aspect-进行标注"><a href="#1、定义切面类，并使用-Aspect-进行标注" class="headerlink" title="1、定义切面类，并使用 @Aspect 进行标注"></a>1、定义切面类，并使用 @Aspect 进行标注</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 使用Aspect注解驱动的方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="guolei.sgl@antfin.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/6/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerAspectInject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(LoggerAspectInject.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.glmapper.framerwork.service.impl.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"before current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AfterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"afterReturning current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、使用方式1：配置文件方式声明-bean"><a href="#2、使用方式1：配置文件方式声明-bean" class="headerlink" title="2、使用方式1：配置文件方式声明 bean"></a>2、使用方式1：配置文件方式声明 bean</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义通知内容，也就是切入点执行前后需要做的事情 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loggerAspectInject"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.aspect.LoggerAspectInject"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义被代理者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"goodsServiceImpl"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.service.impl.GoodsServiceImpl"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3、客户端使用："><a href="#3、客户端使用：" class="headerlink" title="3、客户端使用："></a>3、客户端使用：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/buy"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/initPage"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">initPage</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">    		HttpServletResponse response, ModelAndView view)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过SpringContextUtil手动获取 代理bean</span></span><br><span class="line">    	GoodsService goodsService=(GoodsService)</span><br><span class="line">    	SpringContextUtil.getBean(<span class="string">"goodsServiceImpl"</span>);</span><br><span class="line">    </span><br><span class="line">    	List&lt;Goods&gt; goods = goodsService.queryAll(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    	view.addObject(<span class="string">"goodsList"</span>, goods);</span><br><span class="line">    	view.setViewName(<span class="string">"goodslist"</span>);</span><br><span class="line">    	<span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、使用方式2：使用-component注解托管给IOC"><a href="#4、使用方式2：使用-component注解托管给IOC" class="headerlink" title="4、使用方式2：使用@component注解托管给IOC"></a>4、使用方式2：使用@component注解托管给IOC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">//这里加上了Component注解，就不需要在xml中配置了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerAspectInject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER =</span><br><span class="line">    LoggerFactory.getLogger(LoggerAspectInject.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.glmapper.framerwork.service.impl.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"before current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AfterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"afterReturning current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5、客户端代码："><a href="#5、客户端代码：" class="headerlink" title="5、客户端代码："></a>5、客户端代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/buy"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line">    <span class="comment">//直接注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GoodsService goodsService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/initPage"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">initPage</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">    		HttpServletResponse response, ModelAndView view)</span> </span>&#123;</span><br><span class="line">    	</span><br><span class="line">    	List&lt;Goods&gt; goods = goodsService.queryAll(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    	view.addObject(<span class="string">"goodsList"</span>, goods);</span><br><span class="line">    	view.setViewName(<span class="string">"goodslist"</span>);</span><br><span class="line">    	<span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6、比较完整的一个LoggerAspectInject，在实际工程中可以直接参考"><a href="#6、比较完整的一个LoggerAspectInject，在实际工程中可以直接参考" class="headerlink" title="6、比较完整的一个LoggerAspectInject，在实际工程中可以直接参考"></a>6、比较完整的一个LoggerAspectInject，在实际工程中可以直接参考</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: aop</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="henugl@1992.163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: glmapper@磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/6/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerAspectInject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER= LoggerFactory.getLogger(LoggerAspectInject.class);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.glmapper.book.web.controller.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"cutIn()"</span>)   <span class="comment">// 定义Pointcut，名称即下面的标识"aroundAdvice</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint poin)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"环绕通知"</span>);</span><br><span class="line">        Object object = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            object = poin.proceed();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 advise</span></span><br><span class="line">    <span class="comment">//这个方法只是一个标识，相当于在配置文件中定义了pointcut的id,此方法没有返回值和参数</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterAdvice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置返回 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关于命名切入点</strong>：上面的例子中cutIn方法可以被称之为命名切入点，命名切入点可以被其他切入点引用，而匿名切入点是不可以的。只有@AspectJ支持命名切入点，而Schema风格不支持命名切入点。<br>如下所示，@AspectJ使用如下方式引用命名切入点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.glmapper.book.web.controller.*.*(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//引入命名切入点</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"前置通知"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注入式-AspectJ-切面"><a href="#注入式-AspectJ-切面" class="headerlink" title="注入式 AspectJ 切面"></a>注入式 AspectJ 切面</h2><p>这种方式我感觉是第二种和第三种的结合的一种方式。</p>
<h3 id="1、定义切面类"><a href="#1、定义切面类" class="headerlink" title="1、定义切面类"></a>1、定义切面类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@description</span>: 注入式 也是一种通过XML方式配置的方式</span></span><br><span class="line"><span class="comment">* <span class="doctag">@email</span>: &lt;a href="guolei.sgl@antfin.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span>: 18/6/20</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerAspectHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(LoggerAspectHelper.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调动方法前执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> point</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"before current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在调用方法前后执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> point</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"around current time:"</span>+System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">if</span>(point.getArgs().length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> point.proceed(point.getArgs());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> point.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在调用方法之后执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> point</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint point)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"after current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> point</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doThrowing</span><span class="params">(JoinPoint point, Throwable ex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"throwing current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、XML-配置"><a href="#2、XML-配置" class="headerlink" title="2、XML 配置"></a>2、XML 配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loggerAspectHelper"</span>    </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.aspect.LoggerAspectHelper"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"configAspect"</span> <span class="attr">ref</span>=<span class="string">"loggerAspectHelper"</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--配置com.glmapper.framerwork.service.imp</span></span><br><span class="line"><span class="comment">    	包下所有类或接口的所有方法 --&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"cutIn"</span> <span class="attr">expression</span>=</span></span><br><span class="line"><span class="tag">    	"<span class="attr">execution</span>(* <span class="attr">com.glmapper.framerwork.service.impl.</span>*<span class="attr">.</span>*(<span class="attr">..</span>))" /&gt;</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="tag">&lt;<span class="name">aop:before</span>   <span class="attr">pointcut-ref</span>=<span class="string">"cutIn"</span> <span class="attr">method</span>=<span class="string">"doBefore"</span> /&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">aop:after</span>    <span class="attr">pointcut-ref</span>=<span class="string">"cutIn"</span> <span class="attr">method</span>=<span class="string">"doAfter"</span> /&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">aop:around</span>   <span class="attr">pointcut-ref</span>=<span class="string">"cutIn"</span> <span class="attr">method</span>=<span class="string">"doAround"</span> /&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut-ref</span>=<span class="string">"cutIn"</span> </span></span><br><span class="line"><span class="tag">    	    <span class="attr">method</span>=<span class="string">"doThrowing"</span> <span class="attr">throwing</span>=<span class="string">"ex"</span> /&gt;</span></span><br><span class="line">    	</span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3、结果"><a href="#3、结果" class="headerlink" title="3、结果"></a>3、结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">23:39:48.756 [http-nio-8080-exec-4] INFO  c.g.f.aspect.LoggerAspectHelper</span><br><span class="line">- before current time:1529509188756</span><br><span class="line">23:39:48.757 [http-nio-8080-exec-4] INFO  c.g.f.aspect.LoggerAspectHelper</span><br><span class="line">- around current time:1529509188757</span><br><span class="line">excute queryAll method...</span><br><span class="line">23:39:48.757 [http-nio-8080-exec-4] INFO  c.g.f.aspect.LoggerAspectHelper</span><br><span class="line">- after current time:1529509188757</span><br></pre></td></tr></table></figure>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><hr>
<p>从上面的例子中我们都是使用一些正则表达式来指定我们的切入点的。在实际的使用中，不仅仅是execution，还有其他很多种类型的表达式。下面就列举一些：</p>
<h3 id="1、execution"><a href="#1、execution" class="headerlink" title="1、execution"></a>1、execution</h3><p>用于匹配方法执行的连接点;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.glmapper.book.web.controller.*.*(..))</span><br></pre></td></tr></table></figure>
<ul>
<li>execution（）表达式的主体；</li>
<li>第一个 “*” 符号表示返回值的类型任意；</li>
<li>com.glmapper.book.web.controller       AOP所切的服务的包名，即，我们的业务部分</li>
<li>包名后面的”.”    表示当前包及子包</li>
<li>第二个”*”    表示类名，即所有类</li>
<li>.*(..) 表示任何方法名，括号表示参数，两个点表示任何参数类型</li>
</ul>
<h2 id="2、within"><a href="#2、within" class="headerlink" title="2、within"></a>2、within</h2><p>用于匹配指定类型内的方法执行;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果在com.glmapper.book.web.controller包或其下的任何子包中</span></span><br><span class="line"><span class="comment">//定义了该类型，则在Web层中有一个连接点。</span></span><br><span class="line">within(com.glmapper.book.web.controller..*)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.glmapper.book.web.controller..*)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>@within：用于匹配所以持有指定注解类型内的方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 注解定义</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="henugl@1992.163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: glmapper@磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/6/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD,ElementType.FIELD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AuthAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何目标对象对应的类型持有AuthAnnotation注解的类方法；必须是在目标对象上声明这个注解，在接口上声明的对它不起作用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@within</span>(com.glmapper.book.common.annotaion.AuthAnnotation)</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有被@AdviceAnnotation标注的类都将匹配</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@within(com.glmapper.book.common.annotaion.AuthAnnotation)"</span>) </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3、this"><a href="#3、this" class="headerlink" title="3、this"></a>3、this</h3><p>用于匹配当前AOP代理对象类型的执行方法；注意是AOP代理对象的类型匹配，这样就可能包括引入接口也类型匹配；this中使用的表达式必须是类型全限定名，不支持通配符；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前目标对象（非AOP对象）实现了 UserService 接口的任何方法</span></span><br><span class="line"><span class="keyword">this</span>(com.glmapper.book.web.service.UserService)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于向通知方法中传入代理对象的引用。</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"cutIn() &amp;&amp; this(proxy)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">(ProceedingJoinPoint poin,Object proxy)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"前置通知"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、target"><a href="#4、target" class="headerlink" title="4、target"></a>4、target</h3><p>用于匹配当前目标对象类型的执行方法；注意是目标对象的类型匹配，这样就不包括引入接口也类型匹配；target中使用的表达式必须是类型全限定名，不支持通配符；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前目标对象（非AOP对象）实现了 UserService 接口的任何方法</span></span><br><span class="line">target(com.glmapper.book.web.service.UserService)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于向通知方法中传入代理对象的引用。</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"cutIn() &amp;&amp; target(proxy)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">(ProceedingJoinPoint poin,Object proxy)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"前置通知"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>@target：用于匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解；任何目标对象持有Secure注解的类方法；这个和@within一样必须是在目标对象上声明这个注解，在接口上声明的对它同样不起作用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@target</span>(com.glmapper.book.common.annotaion.AuthAnnotation)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@target(com.glmapper.book.common.annotaion.AuthAnnotation)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="5、args"><a href="#5、args" class="headerlink" title="5、args"></a>5、args</h3><p>用于匹配当前执行的方法传入的参数为指定类型的执行方法；参数类型列表中的参数必须是类型全限定名，通配符不支持；args属于动态切入点，这种切入点开销非常大，非特殊情况最好不要使用；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任何一个以接受“传入参数类型为java.io.Serializable”开头，</span></span><br><span class="line"><span class="comment">//且其后可跟任意个任意类型的参数的方法执行，</span></span><br><span class="line"><span class="comment">//args指定的参数类型是在运行时动态匹配的</span></span><br><span class="line">args (java.io.Serializable,..)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于将参数传入到通知方法中。</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"cutIn() &amp;&amp; args(age,username)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvide</span><span class="params">(JoinPoint point, <span class="keyword">int</span> age, String username)</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@args：用于匹配当前执行的方法传入的参数持有指定注解的执行；任何一个只接受一个参数的方法，且方法运行时传入的参数持有注解AuthAnnotation；动态切入点，类似于arg指示符；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@args</span> (com.glmapper.book.common.annotaion.AuthAnnotation)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"@args(com.glmapper.book.common.annotaion.AuthAnnotation)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvide</span><span class="params">(JoinPoint point)</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6、-annotation"><a href="#6、-annotation" class="headerlink" title="6、@annotation"></a>6、@annotation</h3><p>使用“@annotation(注解类型)”匹配当前执行方法持有指定注解的方法；注解类型也必须是全限定类型名；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前执行方法上持有注解 AuthAnnotation将被匹配</span></span><br><span class="line"><span class="meta">@annotation</span>(com.glmapper.book.common.annotaion.AuthAnnotation)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配连接点被它参数指定的AuthAnnotation注解的方法。</span></span><br><span class="line"><span class="comment">//也就是说，所有被指定注解标注的方法都将匹配。</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.glmapper.book.common.annotaion.AuthAnnotation)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>还有一种是bean的方式，没用过。有兴趣可以看看。</p>
</blockquote>
<p>例子在下面说到的基础概念部分对应给出。</p>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>基础概念部分主要将 AOP 中的一些概念点捋一捋，这部分主要参考了官网上的一些解释。</p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p><code>AOP(Aspect-Oriented Programming)</code>， 即 <strong>面向切面编程</strong>, 它与 <code>OOP</code>( <code>Object-Oriented Programming</code>, 面向对象编程) 相辅相成, 提供了与 <code>OOP</code> 不同的抽象软件结构的视角。在 <code>OOP</code> 中,我们以类(class)作为我们的基本单元, 而 <code>AOP</code> 中的基本单元是 <strong>Aspect(切面)</strong>。</p>
<p><strong>横切关注点</strong>(<code>Cross Cutting Concern</code>)：独立服务，如系统日志。如果不是独立服务（就是与业务耦合比较强的服务）就不能横切了。通常这种独立服务需要遍布系统各个角落，遍布在业务流程之中。</p>
<h2 id="Target-Object"><a href="#Target-Object" class="headerlink" title="Target Object"></a>Target Object</h2><p>目标对象。织入 advice 的目标对象。 目标对象也被称为 <code>advised object</code>。<br>因为 Spring AOP 使用运行时代理的方式来实现 aspect, 因此 adviced object 总是一个代理对象(proxied object)；注意， adviced object 指的不是原来的类, 而是织入 advice 后所产生的代理类。</p>
<h2 id="织入（Weave）"><a href="#织入（Weave）" class="headerlink" title="织入（Weave）"></a>织入（Weave）</h2><p>即<code>Advice</code>应用在<code>JoinPoint</code>的过程，这个过程叫织入。从另外一个角度老说就是将 <code>aspect</code> 和其他对象连接起来, 并创建 <code>adviced object</code> 的过程。</p>
<p>根据不同的实现技术， <code>AOP</code>织入有三种方式:</p>
<ul>
<li>编译器织入，这要求有特殊的<code>Java</code>编译器</li>
<li>类装载期织入， 这需要有特殊的类装载器</li>
<li>动态代理织入, 在运行期为目标类添加增强( <code>Advice</code> )生成子类的方式。</li>
</ul>
<p>Spring 采用动态代理织入, 而AspectJ采用编译器织入和类装载期</p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>Spring AOP默认使用代理的是标准的JDK动态代理。这使得任何接口（或一组接口）都可以代理。</p>
<p>Spring AOP也可以使用CGLIB代理。如果业务对象不实现接口，则默认使用CGLIB。对接口编程而不是对类编程是一种很好的做法；业务类通常会实现一个或多个业务接口。在一些特殊的情况下，即需要通知的接口上没有声明的方法，或者需要将代理对象传递给具体类型的方法，有可能强制使用CGLIB。</p>
<h2 id="Introductions"><a href="#Introductions" class="headerlink" title="Introductions"></a>Introductions</h2><p>我们知道Java语言本身并非是动态的，就是我们的类一旦编译完成，就很难再为他添加新的功能。但是在一开始给出的例子中，虽然我们没有向对象中添加新的方法，但是已经向其中添加了新的功能。这种属于向现有的方法添加新的功能，那能不能为一个对象添加新的方法呢？答案肯定是可以的，使用introduction就能够实现。</p>
<p>introduction：动态为某个类增加或减少方法。为一个类型添加额外的方法或字段。Spring AOP 允许我们为 <code>目标对象</code> 引入新的接口(和对应的实现)。</p>
<h2 id="Aspect"><a href="#Aspect" class="headerlink" title="Aspect"></a>Aspect</h2><p>切面：通知和切入点的结合。</p>
<p>切面实现了cross-cutting（横切）功能。最常见的是logging模块、方法执行耗时模块，这样，程序按功能被分为好几层，如果按传统的继承的话，商业模型继承日志模块的话需要插入修改的地方太多，而通过创建一个切面就可以使用AOP来实现相同的功能了，我们可以针对不同的需求做出不同的切面。</p>
<p>而将散落于各个业务对象之中的Cross-cutting concerns 收集起来，设计各个独立可重用的对象，这些对象称之为Aspect；在上面的例子中我们根据不同的配置方式，定义了四种不同形式的切面。</p>
<h2 id="Joinpoint"><a href="#Joinpoint" class="headerlink" title="Joinpoint"></a>Joinpoint</h2><p>Aspect 在应用程序执行时加入业务流程的点或时机称之为 Joinpoint ，具体来说，就是 Advice 在应用程序中被呼叫执行的时机，这个时机可能是某个方法被呼叫之前或之后（或两者都有），或是某个异常发生的时候。</p>
<h3 id="Joinpoint-amp-ProceedingJoinPoint"><a href="#Joinpoint-amp-ProceedingJoinPoint" class="headerlink" title="Joinpoint &amp; ProceedingJoinPoint"></a>Joinpoint &amp; ProceedingJoinPoint</h3><p>环绕通知 = 前置+目标方法执行+后置通知，proceed方法就是用于启动目标方法执行的。</p>
<p>环绕通知 ProceedingJoinPoint 执行 proceed 方法 的作用是让目标方法执行 ，这 也是环绕通知和前置、后置通知方法的一个最大区别。</p>
<p>Proceedingjoinpoint 继承了 JoinPoint 。是在JoinPoint的基础上暴露出 proceed 这个方法。proceed很重要，这个是aop代理链执行的方法；暴露出这个方法，就能支持<a href="aop:around" target="_blank" rel="noopener">aop:around</a> 这种切面（其他的几种切面只需要用到JoinPoint，这跟切面类型有关）， 能决定是否走代理链还是走自己拦截的其他逻辑。</p>
<p>在环绕通知的方法中是需要返回一个Object类型对象的，如果把环绕通知的方法返回类型是void，将会导致一些无法预估的情况，比如：404。</p>
<h2 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h2><p>匹配 <code>join points</code>的谓词。<code>Advice</code>与切入点表达式相关联, 并在切入点匹配的任何连接点上运行。（例如，具有特定名称的方法的执行）。由切入点表达式匹配的连接点的概念是<code>AOP</code>的核心，<code>Spring</code>默认使用<code>AspectJ</code>切入点表达式语言。</p>
<p>在 <code>Spring</code> 中, 所有的方法都可以认为是<code>Joinpoint</code>, 但是我们并不希望在所有的方法上都添加 <code>Advice</code>, 而 <code>Pointcut</code> 的作用就是提供一组规则(使用 <code>AspectJ pointcut expression language</code> 来描述) 来匹配<code>Joinpoint</code>, 给满足规则的<code>Joinpoint</code> 添加 <code>Advice</code>。</p>
<h3 id="Pointcut-和-Joinpoint"><a href="#Pointcut-和-Joinpoint" class="headerlink" title="Pointcut 和 Joinpoint"></a>Pointcut 和 Joinpoint</h3><p>在<code>Spring AOP</code> 中, 所有的方法执行都是 <code>join point</code>。 而 <code>point cut</code> 是一个描述信息，它修饰的是 <code>join point</code>， 通过 <code>point cut</code>，我们就可以确定哪些 <code>join point</code> 可以被织入<code>Advice</code>。 因此<code>join point</code> 和 <code>point cut</code>本质上就是两个不同维度上的东西。</p>
<p><code>advice</code> 是在 <code>join point</code> 上执行的, 而 <code>point cut</code> 规定了哪些 <code>join point</code> 可以执行哪些 <code>advice</code>。</p>
<h2 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Advice 是我们切面功能的实现，它是切点的真正执行的地方。比如像前面例子中打印时间的几个方法（被@Before等注解标注的方法都是一个通知）；Advice 在 Jointpoint 处插入代码到应用程序中。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>BeforeAdvice，AfterAdvice，区别在于Advice在目标方法之前调用还是之后调用，Throw Advice 表示当目标发生异常时调用Advice。</p>
<ul>
<li>before advice： 在 join point 前被执行的 advice. 虽然 before advice 是在 join point 前被执行, 但是它并不能够阻止 join     point 的执行, 除非发生了异常(即我们在 before advice 代码中, 不能人为地决定是否继续执行 join point 中的代码)</li>
<li>after return advice： 在一个 join point 正常返回后执行的 advice</li>
<li>after throwing advice： 当一个 join point 抛出异常后执行的 advice</li>
<li>after(final) advice： 无论一个 join point 是正常退出还是发生了异常, 都会被执行的 advice.</li>
<li>around advice：在 join point 前和 joint point 退出后都执行的 advice. 这个是最常用的 advice.</li>
</ul>
<h2 id="Advice、JoinPoint、PointCut-关系"><a href="#Advice、JoinPoint、PointCut-关系" class="headerlink" title="Advice、JoinPoint、PointCut 关系"></a>Advice、JoinPoint、PointCut 关系</h2><p><img src="https://user-gold-cdn.xitu.io/2018/6/21/1641e065ec1ad2e7?w=712&amp;h=148&amp;f=jpeg&amp;s=22970" alt=""></p>
<p>下面这张图是在网上一位大佬的博客里发现的，可以帮助我们更好的理解这些概念之间的关系。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/21/1641e0a1e65715e4?w=581&amp;h=405&amp;f=jpeg&amp;s=32663" alt="图片源自网络"></p>
<p>上面是对于AOP中涉及到的一些基本概念及它们之间的关系做了简单的梳理。</p>
<h2 id="一些坑"><a href="#一些坑" class="headerlink" title="一些坑"></a>一些坑</h2><p>在调试程序过程中出现的一些问题记录</p>
<h3 id="1、使用AOP拦截controller层的服务成功，但是页面报错404"><a href="#1、使用AOP拦截controller层的服务成功，但是页面报错404" class="headerlink" title="1、使用AOP拦截controller层的服务成功，但是页面报错404"></a>1、使用AOP拦截controller层的服务成功，但是页面报错404</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint poin)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"环绕通知"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是再使用环绕通知时，需要给方法一个返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint poin)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"环绕通知"</span>);</span><br><span class="line">    <span class="keyword">return</span> poin.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、0-formal-unbound-in-pointcut"><a href="#2、0-formal-unbound-in-pointcut" class="headerlink" title="2、0 formal unbound in pointcut"></a>2、0 formal unbound in pointcut</h3><p>在spring 4.x中 提供了aop注解方式 带参数的方式。看下面例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(value = <span class="string">"execution(* com.glmapper.framerwork.service.impl.*(int,int)) &amp;&amp; args(i,j)"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Before</span>(value=<span class="string">"cutIn(i, j)"</span>,argNames = <span class="string">"i,j"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">( <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"---------begins with "</span> + i + <span class="string">"-"</span> +j);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如说这里，Before中有两个int类型的参数，如果此时我们在使用时没有给其指定参数，那么就会抛出：<strong>Caused by: java.lang.IllegalArgumentException: error at ::0 formal unbound in pointcut</strong> 异常信息。</p>
<p><code>本来是想放在一篇里面的，但是实在太长了，就分开吧；周末更新下</code></p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/spring-aop-base/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/topic-resttemplate/">聊一聊 RestTemplate</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T04:24:19.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/topic-resttemplate/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/web/" title="web">web</a>,
  
    <a href="/tags/聊一聊/" title="聊一聊">聊一聊</a>,
  
    <a href="/tags/restful/" title="restful">restful</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<blockquote>
<p>最近这段时间用了下 RestTemplate 这个类，抽点时间总结下一些东西，希望对大家有所帮助。</p>
</blockquote>
<p>从 3.0 版本开始，Spring 提供了 RestTemplate 作为用于访问 Rest 服务的客户端，RestTemplate 提供了多种便捷访问远程 Http 服务的方法，能够大大提高客户端的编写效率。</p>
<p>本篇文章将从 RestTemplate 提供的 API 入手，先来了解下 RestTemplate 的具体使用，然后再对其中涉及到的几个核心类进行分析，最后再来分析下 RestTemplate 执行的整个流程，篇幅比较长，建议先码为快！</p>
<h2 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h2><p>在平时的使用中，我们通常都是使用包装好的getForObject/getForEntity，postForObject/postForEntity/postForLocation，put以及delete。</p>
<h3 id="get-请求处理"><a href="#get-请求处理" class="headerlink" title="get 请求处理"></a>get 请求处理</h3><p>getForEntity方法的返回值是一个ResponseEntity<t>，ResponseEntity<t>是Spring对HTTP请求响应的封装，包括了几个重要的元素，如响应码、contentType、contentLength、响应消息体等。</t></t></p>
<ul>
<li>url：调用的服务的地址</li>
<li>responseType：返回的body类型</li>
<li>uriVariables：有两种形式:<ul>
<li>可以用一个数字做占位符，最后是一个可变长度的参数，来一一替换前面的占位符<br><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682a71d3436f37?w=2110&amp;h=188&amp;f=png&amp;s=69713" alt=""></li>
<li>也可以前面使用name={name}这种形式，最后一个参数是一个map，map的key即为前边占位符的名字，map的value为参数值<br><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682a77dd355749?w=2084&amp;h=196&amp;f=png&amp;s=69867" alt=""></li>
</ul>
</li>
</ul>
<h4 id="responseType-测试案例"><a href="#responseType-测试案例" class="headerlink" title="responseType 测试案例"></a>responseType 测试案例</h4><p>定义的一个controller资源：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682a97f48fb171?w=1262&amp;h=282&amp;f=png&amp;s=54017" alt=""><br>这里分别使用不同的 responseType 进行测试：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682a93da364cf1?w=1536&amp;h=498&amp;f=png&amp;s=134357" alt=""></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getForEntity(responseType=Map.class):&#123;glmapper=hello glmapper&#125;</span><br><span class="line">getForEntity(responseType=String.class):&#123;&quot;glmapper&quot;:&quot;hello glmapper&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="uriVariables-测试案例"><a href="#uriVariables-测试案例" class="headerlink" title="uriVariables 测试案例"></a>uriVariables 测试案例</h4><p>先来看下非map方式的，两个controller，两种不同方式的参数获取（本质上是一样的）<br><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682ab556c128fc?w=1412&amp;h=272&amp;f=png&amp;s=70152" alt=""></p>
<ul>
<li>使用占位符的方式：</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682abcc1d8c3ca?w=1504&amp;h=240&amp;f=png&amp;s=69526" alt=""></p>
<ul>
<li>使用 map 的方式：</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682ac3e84dbb0a?w=1504&amp;h=276&amp;f=png&amp;s=66893" alt=""></p>
<h3 id="getForObject"><a href="#getForObject" class="headerlink" title="getForObject"></a>getForObject</h3><p>getForObject 函数实际上是对 getForEntity 函数的进一步封装，如果只关注返回的消息体的内容，对其他信息都不关注，那么就可以使用 getForObject。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682ad954b5df90?w=1148&amp;h=278&amp;f=png&amp;s=46924" alt=""></p>
<p>这里调用就比getForEntity要简单一点了，可以直接拿到对象：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682ae0804d0692?w=1504&amp;h=146&amp;f=png&amp;s=37689" alt=""></p>
<p>getForObject 的几个重载方法和 getForEntity 基本是一样的。</p>
<h3 id="post-请求处理"><a href="#post-请求处理" class="headerlink" title="post 请求处理"></a>post 请求处理</h3><p>在RestTemplate中，POST请求可以通过如下三个方法来发起：postForEntity，postForObject，postForLocation。</p>
<h4 id="postForEntity-案例"><a href="#postForEntity-案例" class="headerlink" title="postForEntity 案例"></a>postForEntity 案例</h4><p><img src="https://user-gold-cdn.xitu.io/2018/10/18/1668778ea595c23b?w=1212&amp;h=232&amp;f=png&amp;s=49938" alt=""><br>调用获取：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/18/16687792c19ca889?w=1588&amp;h=286&amp;f=png&amp;s=74538" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postForEntity(URI url, <span class="meta">@Nullable</span> Object request, Class&lt;T&gt; responseType)</span><br></pre></td></tr></table></figure>
<ul>
<li>方法的第一参数表示要调用的服务的地址</li>
<li>方法的第二个参数表示上传的参数</li>
<li>方法的第三个参数表示返回的消息体的数据类型</li>
</ul>
<h4 id="postForObject-案例"><a href="#postForObject-案例" class="headerlink" title="postForObject 案例"></a>postForObject 案例</h4><p>和 getForObject 相对应，只关注返回的消息体。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877ade7c3795c?w=1556&amp;h=228&amp;f=png&amp;s=67804" alt=""></p>
<h4 id="postForLocation-案例"><a href="#postForLocation-案例" class="headerlink" title="postForLocation 案例"></a>postForLocation 案例</h4><p>postForLocation也是提交新资源，提交成功之后，返回新资源的URI，postForLocation的参数和前面两种的参数基本一致，只不过该方法的返回值为Uri，这个只需要服务提供者返回一个Uri即可，该Uri表示新资源的位置。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877b5de7b3e06?w=1522&amp;h=324&amp;f=png&amp;s=88249" alt=""></p>
<p>这里有点坑，我们需要把这个uri添加到response的header中，不然后面拿到的是null。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877b96ded6304?w=1414&amp;h=194&amp;f=png&amp;s=39251" alt=""></p>
<h3 id="exchange"><a href="#exchange" class="headerlink" title="exchange"></a>exchange</h3><p>exchange 方法和上述这些方法差别在于需要多一个请求类型的参数：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877c1ee29bf31?w=1556&amp;h=194&amp;f=png&amp;s=50603" alt=""></p>
<h2 id="AsyncRestTemplate-异步客户端"><a href="#AsyncRestTemplate-异步客户端" class="headerlink" title="AsyncRestTemplate 异步客户端"></a>AsyncRestTemplate 异步客户端</h2><p>RestTemplate的异步实现方式。所涉及到的API和RestTemplate基本一致。区别在于RestTemplate直接返回结果，而AsyncRestTemplate返回的是ListenableFuture。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877cd10d2bb0e?w=1372&amp;h=716&amp;f=png&amp;s=139753" alt=""></p>
<h2 id="RestTemplate-拦截器"><a href="#RestTemplate-拦截器" class="headerlink" title="RestTemplate 拦截器"></a>RestTemplate 拦截器</h2><p>Spring提供了ClientHttpRequestInterceptor和AsyncClientHttpRequestInterceptor两个接口，分别可以对RestTemplate和AsyncRestTemplate发起的请求进行拦截，并在其被发送至服务端之前修改请求或是增强相应的信息。</p>
<ul>
<li><p>ClientHttpRequestInterceptor 拦截 RestTemplate<br><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877d579c56a0c?w=1380&amp;h=368&amp;f=png&amp;s=83172" alt=""></p>
</li>
<li><p>AsyncClientHttpRequestInterceptor 拦截AsyncRestTemplate<br><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877e0ff73a952?w=1548&amp;h=366&amp;f=png&amp;s=93632" alt=""></p>
</li>
</ul>
<p>设置拦截器就是通过提供的 setInterceptors 设置即可：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877ef7ccd132e?w=1368&amp;h=492&amp;f=png&amp;s=112979" alt=""></p>
<h2 id="自定义-ResponseErrorHandler"><a href="#自定义-ResponseErrorHandler" class="headerlink" title="自定义 ResponseErrorHandler"></a>自定义 ResponseErrorHandler</h2><p>ResponseErrorHandler 接口定义了当response发生错误时需要进行的操作。这里我们自定义一个CustomResponseErrorHandler，当返回的code不是200时，就表示执行出错了。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668fe76528a5659?w=1560&amp;h=630&amp;f=png&amp;s=146140" alt=""></p>
<p>设置 ResponseErrorHandler：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668fe8f603b0760?w=1574&amp;h=338&amp;f=png&amp;s=117473" alt=""></p>
<p>执行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668fe97d6c85821?w=2672&amp;h=348&amp;f=png&amp;s=173962" alt=""></p>
<h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><p>下面来梳理下 RestTemplate 中请求处理的流程。下图中 XXXX 表示我们调用的 API 方法。大体流程就是：api 内部做一些请求相关的处理封装，然后交给 execute 方法执行，最后真正处理则是在 doExecute 方法中完成。<br><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668f78ce0e92b1e?w=294&amp;h=248&amp;f=png&amp;s=5157" alt=""></p>
<p>下面以 getForEntity 方法的执行过程来分析：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668f7c60711d002?w=1452&amp;h=248&amp;f=png&amp;s=68902" alt=""></p>
<p>getForEntity 方法：</p>
<ul>
<li>基于给定响应类型，返回一个请求回调实现，准备请求。</li>
<li>基于给定响应类型，返回 ResponseEntity 的响应提取器。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668f7e5d410b82e?w=1570&amp;h=246&amp;f=png&amp;s=66950" alt=""><br>execute 方法：</p>
<ul>
<li>这个方法里面是对url进行urlencode编码处理的，统一转为URL。这里我们也可以手动把参数进行网络编码。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668f8294bc82e81?w=1516&amp;h=886&amp;f=png&amp;s=207580" alt=""><br>doExecute是请求真正处理的方法，这里来重点看下这个方法的执行过程：</p>
<ul>
<li>createRequest</li>
<li>doWithRequest</li>
<li>execute</li>
<li>handleResponse</li>
</ul>
<h4 id="1、createRequest"><a href="#1、createRequest" class="headerlink" title="1、createRequest"></a>1、createRequest</h4><p>这个方法的作用就是创建一个 ClientHttpRequest 对象。RestTemplate集成了 HttpAccessor这个抽象类，创建ClientHttpRequest的过程就是在其父类HttpAccessor中通过默认的 ClientHttpRequestFactory 实现类 SimpleClientHttpRequestFactory 完成具体的请求创建。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668f8a70f4e1664?w=1462&amp;h=370&amp;f=png&amp;s=91033" alt=""></p>
<ul>
<li><p>1、创建 java.net.HttpURLConnection 对象</p>
</li>
<li><p>2、设置 connection，包括 connectTimeout、setDoInput 等。</p>
</li>
<li><p>3、bufferRequestBody 用于标志是否使用缓存流的形式，默认是 true。缺点是当发送大量数据时，比如 put/post，存在内存消耗严重。该值可以通过 SimpleClientHttpRequestFactory#setBufferRequestBody来修改。</p>
</li>
</ul>
<blockquote>
<p>不同版本的变更还是比较大的，大家在阅读源码时，还是从最新的代码来看。</p>
</blockquote>
<h4 id="2、doWithRequest"><a href="#2、doWithRequest" class="headerlink" title="2、doWithRequest"></a>2、doWithRequest</h4><p>RequestCallback 封装了请求体和请求头对象。这里会遍历所有的 HttpMessageConverter，解析成所有支持的MediaType，放在allSupportedMediaTypes中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getHeaders().setAccept(allSupportedMediaTypes);</span><br></pre></td></tr></table></figure>
<p>RestTemplate中对应了两个内部类的实现：</p>
<ul>
<li><p>AcceptHeaderRequestCallback.doWithRequest的处理。<br>发送请求时，Http头部需要设置Accept字段，该字段表明了发送请求的这方接受的媒体类型（消息格式），也是响应端要返回的信息的媒体类型（消息格式）。<br>根据postForEntity方法的第三个参数responseType，程序将选择适合的解析器XXXConverter，并依据该解析器找出所有支持的媒体类型。</p>
<ul>
<li>HttpEntityRequestCallback.doWithRequest的处理。<br>如果是POST请求并且消息体存在时，除了设置Accept字段，还可能需要设置Content-Type字段，该字段表明了所发送请求的媒体类型（消息格式），也是响应端接受的媒体类型（消息格式）。<br>根据postForEntity方法的第二个参数request，程序将选择适合的解析器XXXConverter，将请求消息写入输出流。</li>
</ul>
</li>
</ul>
<h4 id="3、execute"><a href="#3、execute" class="headerlink" title="3、execute"></a>3、execute</h4><p>这里会把请求头/体封装到connect，然后发送请求。跟踪 execute 方法执行，定位到SimpleBufferingClientHttpRequest#executeInternal方法：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668fdccb7601b1f?w=1570&amp;h=612&amp;f=png&amp;s=177702" alt=""><br>这里是使用实例 SimpleBufferingClientHttpRequest 封装请求体和请求头。从代码中可以看到：</p>
<ul>
<li>delete 时通过前面设置的 DoOutput参数和是否可以设置输出流来判断是否需要发送请求体如果是 delete 请求，那么很明显 DoOutput = false，不会有封装请求体的过程，即不执行FileCopyUtils.copy(bufferedOutput, this.connection.getOutputStream())。</li>
</ul>
<h4 id="4、handleResponse"><a href="#4、handleResponse" class="headerlink" title="4、handleResponse"></a>4、handleResponse</h4><p>最后就是 response 的解析了，从代码来看，主要还是 Error 的解析。这里的ErrorHandler我们前面也提到，可以通过实现 ResponseErrorHandler 来自定义 异常处理。<br><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668fe3ae92b7ead?w=1532&amp;h=502&amp;f=png&amp;s=109859" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇先介绍了RestTemplate的API使用，挑了几个介绍了下，更多使用细节还是要针对不同的场景来决定。接着对拦截器，异步RestTemplate以及错误处理器做了简单的介绍并给出了案例。最后分析了下RestTemplate的执行流程，篇幅原因执行流程部分只是大概捋了捋，其中还是很多细节有时间再补充，这部分主要就是看底层是如何通信的，已经请求参数的传递等。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/topic-resttemplate/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
    </div>
    
      <div id="page-nav" class="pagination">
	<a class="extend prev" rel="prev" href="/tags/spring/page/2/">Prev</a><a class="page-number" href="/tags/spring/">1</a><a class="page-number" href="/tags/spring/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/tags/spring/page/4/">4</a><a class="extend next" rel="next" href="/tags/spring/page/4/">Next</a>
      </div>
    
  </section>

</div>

</div>

</section>
</div>


    <!-- BEGIN PRE-FOOTER -->
    <div class="pre-footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN BOTTOM ABOUT BLOCK -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>About Us</h2>
            <p>Computer Lab is a software development and marketing company based in Brooklyn, New York. <br><br> Computer Lab was founded in 2015, and is focused on so on and so forth.</p>
          </div>
          <!-- END BOTTOM ABOUT BLOCK -->

          <!-- BEGIN BOTTOM CONTACTS -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>Contact</h2>
            <address class="margin-bottom-40">
              140 Metropolitan Avenue<br>
              5th Floor<br>
              Brooklyn, NY 11249<br>
              Phone: 716-472-4484<br>
              Email: <a href="mailto:ptsteadman@gmail.com">ptsteadman@gmail.com</a><br>
            </address>
          </div>
          <!-- END BOTTOM CONTACTS -->

	
          <!-- BEGIN TWITTER BLOCK --> 
          <div class="col-md-4 col-sm-6 pre-footer-col">

	  <a data-tweet-limit="1" class="twitter-timeline" href="https://twitter.com/computerlab_" data-widget-id="678830341331820544">Tweets by @computerlab_</a>

	  <script>!function(d,s,id){var
	  js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

          </div>
          <!-- END TWITTER BLOCK -->
	
        </div>
      </div>
    </div>
    <!-- END PRE-FOOTER -->

    <!-- BEGIN FOOTER -->
    <div class="footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN COPYRIGHT -->
          <div class="col-md-6 col-sm-6 padding-top-10">
                  &copy; 2020 glmapper<br>
 <a href="javascript:;">Privacy Policy</a> | <a href="javascript:;">Terms of Service</a>
          </div>
          <!-- END COPYRIGHT -->
	  <!-- BEGIN SOCIAL -->
<div class="col-md-6 col-sm-6">
  <ul class="social-footer list-unstyled list-inline pull-right">
    
      <li><a href="https://github.com/ptsteadman"><i class="fa fa-github"></i></a></li>
    
      <li><a href="https://twitter.com/ptsteadman"><i class="fa fa-twitter"></i></a></li>
    
      <li><a href="https://www.facebook.com/ptsteadman"><i class="fa fa-facebook"></i></a></li>
    
      <li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li>
    
      <li><a href="https://linkedin.com/in/ptsteadman"><i class="fa fa-linkedin"></i></a></li>
    
      <li><a href="http://stackoverflow.com/users/2480493/patrick-steadman"><i class="fa fa-stackoverflow"></i></a></li>
    
  </ul>  
</div>
<!-- END SOCIAL -->

        </div>
      </div>
    </div>
    <!-- END FOOTER -->

  <!-- BEGIN CORE PLUGINS (REQUIRED FOR ALL PAGES) -->
<!--[if lt IE 9]>
<script src="/metronic/assets/plugins/respond.min.js"></script>
<![endif]--> 
<script src="/metronic/assets/plugins/jquery.min.js"></script>
<script src="/metronic/assets/plugins/jquery-migrate.min.js"></script>
<script src="/metronic/assets/plugins/bootstrap/js/bootstrap.min.js"></script>
<script src="/metronic/assets/corporate/scripts/back-to-top.js"></script>
<script src="/metronic/assets/plugins/owl.carousel/owl.carousel.min.js"></script>
<script src="/metronic/assets/corporate/scripts/layout.js"></script>
<script src="/js/wow.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script type="text/javascript">
    jQuery(document).ready(function() {
        Layout.init();    
        Layout.initOWL();
        Layout.initTwitter();
        Layout.initFixHeaderWithPreHeader(); /* Switch On Header Fixing (only if you have pre-header) */
        Layout.initNavScrolling(); 
	new WOW().init();
    });
</script>
<!-- END CORE PLUGINS -->

<!-- BEGIN PAGE-SPECIFIC PLUGINS --> 







<!-- END PAGE-SPECIFIC PLUGINS --> 

<!-- BEGIN INTEGRATIONS -->





<!-- END INTEGRATIONS -->

</body>
</html>
