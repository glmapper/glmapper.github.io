<!DOCTYPE html>
<!--[if IE 8]> <html lang="en" class="ie8 no-js"> <![endif]-->
<!--[if IE 9]> <html lang="en" class="ie9 no-js"> <![endif]-->
<!--[if !IE]><!-->
<html lang="en">
<!--<![endif]-->
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Tag: Reactor | glmapper</title>

  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <meta name="description" content="从平凡的世界中全身而退">
<meta property="og:type" content="website">
<meta property="og:title" content="glmapper">
<meta property="og:url" content="http://www.glmapper.com/tags/Reactor/index.html">
<meta property="og:site_name" content="glmapper">
<meta property="og:description" content="从平凡的世界中全身而退">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="glmapper">
<meta name="twitter:description" content="从平凡的世界中全身而退">
  
    <link rel="alternative" href="/atom.xml" title="glmapper" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
    
  <meta content="{{ title }}" name="description">
  <meta content="{{ title }}" name="keywords">
  <meta content="{{ title }}" name="author">

  <link href="http://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700|PT+Sans+Narrow|Source+Sans+Pro:200,300,400,600,700,900&amp;subset=all" rel="stylesheet" type="text/css">

  <!-- Global styles START -->   
  <link rel="stylesheet" href="/metronic/assets/plugins/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/bootstrap/css/bootstrap.min.css">
  <!-- Global styles END --> 
   
  <!-- Page level plugin styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/animate.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/owl.carousel/assets/owl.carousel.css">
  <!-- Page level plugin styles END -->

  <!-- Theme styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/components.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/slider.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/portfolio.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style-responsive.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/themes/red.css">
  <link rel="stylesheet" href="/css/theme-styles.css">
  <!-- Theme styles END -->
</head>
</html>
<body class="corporate">
  <!-- BEGIN TOP BAR -->
<div class="pre-header">
  <div class="container">
    <div class="row">
      <!-- BEGIN TOP BAR LEFT PART -->
      <div class="col-md-6 col-sm-6 col-xs-9 additional-shop-info">
	<ul class="list-unstyled list-inline">
	  <li><i class="fa fa-phone"></i><span>716-472-4484</span></li>
	  <li><i class="fa fa-envelope-o"></i><span>ptsteadman@gmail.com</span></li>
	</ul>
      </div>
      <!-- END TOP BAR LEFT PART -->
      <!-- BEGIN TOP BAR MENU -->
      <div class="col-md-6 col-sm-6 col-xs-3 additional-nav">
	<ul class="list-unstyled list-inline pull-right">
	  <li><a href="/login">Log In</a></li>
	</ul>
      </div>
      <!-- END TOP BAR MENU -->
    </div>
  </div>        
</div>
<!-- END TOP BAR -->
<!-- BEGIN HEADER -->
<div class="header">
  <div class="container">
    <!--<a class="site-logo" href="/" id="logo">glmapper</a>-->

    <a class="site-logo" href="/">
      <img src="/metronic/assets/corporate/img/logos/logo-corp-red.png" alt="Metronic FrontEnd">
    </a>

    <a href="javascript:void(0);" class="mobi-toggler"><i class="fa fa-bars"></i></a>

    <!-- BEGIN NAVIGATION -->
    <div class="header-navigation pull-right font-transform-inherit">
      <ul>
	
	<li class="">
	  <a href="/">Home</a>
	</li>
	
	<li class="">
	  <a href="/projects/">Projects</a>
	</li>
	
	<li class="">
	  <a href="/archives/">Blog</a>
	</li>
	
	<li class="">
	  <a href="/contact/">Contact</a>
	</li>
	
	<li class="">
	  <a href="/about/">About</a>
	</li>
	
	<!-- BEGIN TOP SEARCH -->
	<li class="menu-search">
	  <span class="sep"></span>
	  <i class="fa fa-search search-btn"></i>
	  <div class="search-box">
	    <form action="#">
	      <div class="input-group">
		<input type="text" placeholder="Search" class="form-control st-default-search-input">
		<span class="input-group-btn">
		  <button class="btn btn-primary" type="submit">Search</button>
		</span>
	      </div>
	    </form>
	  </div> 
	</li>
	<!-- END TOP SEARCH -->
      </ul>
    </div>
    <!-- END NAVIGATION -->
  </div>
</div>
<!-- Header END -->

  <div class="container">
  <ul class="breadcrumb">
    <li><a href="/">Home</a></li>
    <li><a href="/blog">Blog</a></li>
    <li class="active">Tagged: Reactor</li>
  </ul>
<section id="main">
  <h1>Tagged: Reactor</h1>
  <div class="row">

<div class="col-xs-12 blog-posts">


  <section class="archives-wrap">
    <div class="archives">
      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2019/08/24/base-java-reacotr/">响应式编程 Reactor 小记</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2019-08-24T00:59:26.000Z" itemprop="datePublished">2019/08/24</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2019/08/24/base-java-reacotr/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/java/" title="java">java</a>,
  
    <a href="/tags/Reactor/" title="Reactor">Reactor</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<h2 id="从响应式编程说起"><a href="#从响应式编程说起" class="headerlink" title="从响应式编程说起"></a>从响应式编程说起</h2><p>响应式编程是一种关注于数据流（data streams）和变化传递（propagation of change）的异步编程方式。 这意味着它可以用既有的编程语言表达静态（如数组）或动态（如事件源）的数据流。</p>
<p>在响应式编程方面，微软跨出了第一步，它在 .NET 生态中创建了响应式扩展库（Reactive Extensions library, Rx）。接着 RxJava 在 JVM 上实现了响应式编程。后来，在 JVM 平台出现了一套标准的响应式 编程规范，它定义了一系列标准接口和交互规范。并整合到 Java 9 中（Flow 类）。</p>
<p>响应式编程通常作为面向对象编程中的“观察者模式”（Observer design pattern）的一种扩展。 响应式流（reactive streams）与“迭代子模式”（Iterator design pattern）也有相通之处， 因为其中也有 Iterable-Iterator 这样的对应关系。主要的区别在于，Iterator 是基于 “拉取”（pull）方式的，而响应式流是基于“推送”（push）方式的。</p>
<ul>
<li>iterator 是一种“命令式”（imperative）编程范式，即使访问元素的方法是 Iterable 的唯一职责。关键在于，什么时候执行 next() 获取元素取决于开发者。</li>
<li>响应式流中，相对应的角色是 Publisher-Subscriber，但是当有新的值到来的时候 ，却反过来由发布者（Publisher） 通知订阅者（Subscriber），这种“推送”模式是响应式的关键</li>
</ul>
<p>此外，对推送来的数据的操作是通过一种声明式（declaratively）而不是命令式（imperatively）的方式表达的：开发者通过描述“控制流程”来定义对数据流的处理逻辑。</p>
<p>除了数据推送，对错误处理（error handling）和完成（completion）信号的定义也很完善。一个 Publisher 可以推送新的值到它的 Subscriber（调用 onNext 方法）， 同样也可以推送错误（调用 onError 方法）和完成（调用 onComplete 方法）信号。 错误和完成信号都可以终止响应式流。可以用下边的表达式描述：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onNext x <span class="number">0</span>..N [onError | onComplete]</span><br></pre></td></tr></table></figure>
<p>这种方式非常灵活，无论是有/没有值，还是 n 个值（包括有无限个值的流，比如时钟的持续读秒），都可处理。</p>
<blockquote>
<p>以上来自 <a href="https://projectreactor.io/docs/core/release/reference/" target="_blank" rel="noopener">https://projectreactor.io/docs/core/release/reference/</a> 翻译</p>
</blockquote>
<h2 id="Reactive-Streams"><a href="#Reactive-Streams" class="headerlink" title="Reactive Streams"></a>Reactive Streams</h2><p>Reactive Streams 是上面提到的一套标准的响应式编程规范。它由四个核心概念构成：</p>
<ul>
<li><p>消息发布者：只有一个 subscribe 接口，是订阅者调用的，用来订阅发布者的消息。发布者在订阅者调用 request 之后把消息 push 给订阅者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Publisher</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>订阅者：订阅者包括四个接口，这些接口都由 Publisher 触发调用的。onSubscribe 告诉订阅者订阅成功，并返回了一个 Subscription ；通过 Subscription 订阅者可以告诉发布者发送指定数量的消息（request 完成） ；onNext 是发布者有消息时，调用订阅者这个接口来达到发布消息的目的；onError 通知订阅者，发布者出现了错误；onComplete 通知订阅者消息发送完毕。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>订阅：包括两个接口，请求 n 个消息和取消此次订阅。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subscription</span> </span>&#123;</span><br><span class="line">    <span class="comment">// request(n)用来发起请求数据,其中n表示请求数据的数量,它必须大于0,</span></span><br><span class="line">    <span class="comment">// 否则会抛出IllegalArgumentException,并触发onError,request的调用会</span></span><br><span class="line">    <span class="comment">// 累加,如果没有终止,最后会触发相应次数的onNext方法.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span><br><span class="line">    <span class="comment">// cancel相当于取消订阅,调用之后,后续不会再收到订阅,onError 和 </span></span><br><span class="line">    <span class="comment">// onComplete也不会被触发</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理器：Processor 同时继承了 Subscriber 和 Publisher；其代表一个处理阶段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt;, <span class="title">Publisher</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Reactive Streams 通过上面的四个核心概念和相关的函数，对响应式流进行了一个框架性的约定，它没有具体实现。简单来说，它只提供通用的、合适的解决方案，大家都按照这个规约来实现就好了。</p>
<p>Java 的 Reactive Programming 类库主要有三个，分别是 Akka-Streams ，RxJava 和 Project Reactor。Spring 5 开始支持 Reactive Programming，其底层使用的是 Project Reactor。本篇主要是对 Project Reactor 中的一些点进行学习总结。</p>
<h2 id="Project-Reactor"><a href="#Project-Reactor" class="headerlink" title="Project Reactor"></a>Project Reactor</h2><p>Project Reactor 是一个基于 Java 8 的实现了响应式流规范 （Reactive Streams specification）的响应式库。</p>
<p>Reactor 引入了实现 Publisher 的响应式类 Flux 和 Mono，以及丰富的操作方式。 一个 Flux 对象代表一个包含 0..N 个元素的响应式序列，而一个 Mono 对象代表一个包含零或者一个（0..1）元素的结果。</p>
<h3 id="Flux-和-Mono"><a href="#Flux-和-Mono" class="headerlink" title="Flux 和 Mono"></a>Flux 和 Mono</h3><p>Flux 是生产者，即我们上面提到的 Publisher，它代表的是一个包含 0-N 个元素的异步序列，Mono可以看做 Flux 的有一个特例，代表 0-1 个元素，如果不需要生产任何元素，只是需要一个完成任务的信号，可以使用 Mono。</p>
<h4 id="Flux-包含-0-N-个元素的异步序列"><a href="#Flux-包含-0-N-个元素的异步序列" class="headerlink" title="Flux-包含 0-N 个元素的异步序列"></a>Flux-包含 0-N 个元素的异步序列</h4><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/reactor/reactor-flux.jpg" alt="Flux"></p>
<p>先来看这张图，这里是直接从官方文档上贴过来的。就这张图做下说明，先来关注几个点：</p>
<ul>
<li>从左到右的时间序列轴</li>
<li>1-6 为 Flux enitted（发射）的元素</li>
<li>上面 6 后面的竖线标识已经成功完成了</li>
<li>下面的 1-3 表示转换的结果</li>
<li>❌  表示出现了error，对应的是执行了onError</li>
<li>operator : 操作符，声明式的可组装的响应式方法，其组装成的链称为“操作链”</li>
</ul>
<p>那整体来看就是 Flux 产生元数据，通过一系列 operator 操作得到转换结果，正常成功就是 onCompleted，出现错误就是 onError。看下面的一个小例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">"glmapper"</span>,<span class="string">"leishu"</span>).subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// subscription 表示订阅关系</span></span><br><span class="line">        System.out.println(<span class="string">"onSubscribe,"</span>+ subscription.getClass());</span><br><span class="line">        <span class="comment">// subscription 通过 request 来触发 onNext</span></span><br><span class="line">        subscription.request(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"currrent value is = "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"it's error."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"it's completed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onSubscribe,class reactor.core.publisher.StrictSubscriber</span><br><span class="line">currrent value is = glmapper</span><br><span class="line">currrent value is = leishu</span><br><span class="line">it&apos;s completed.</span><br></pre></td></tr></table></figure>
<p>如果在 onSubscribe 方法中我们不执行 request，则不会有后续任何操作。关于 request 下面看。</p>
<blockquote>
<p>Flux<t> 是一个能够发出 0 到 N 个元素的标准的 Publisher<t>，它会被一个 “error”  或 “completion” 信号终止。因此，一个 Flux 的结果可能是一个 value、completion 或 error。 就像在响应式流规范中规定的那样，这三种类型的信号被翻译为面向下游的 <code>onNext</code>，<code>onComplete</code>和<code>onError</code>方法。</t></t></p>
</blockquote>
<h4 id="Mono-异步的-0-1-结果"><a href="#Mono-异步的-0-1-结果" class="headerlink" title="Mono-异步的 0-1 结果"></a>Mono-异步的 0-1 结果</h4><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/reactor/reactor-mono.jpg" alt="Mono"></p>
<p>这张图也来自官方文档，和上面 Flux 的区别就是，Mono 最多只能 emitted 一个元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono.just(<span class="string">"glmapper"</span>).subscribe(System.out::println);</span><br></pre></td></tr></table></figure></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通过上面两段小的代码来看，最直观的感受是，Flux 相当于一个 List，Mono 相当于 Optional。其实在编程中所有的结果我们都可以用 List 来 表示，但是当只返回一个或者没有结果时，用 Optional 可能会更精确些。</p>
<blockquote>
<p>Optional 相关概念可自行搜索 jdk Optional</p>
</blockquote>
<p>另外，Mono 和 Flux 都提供了一些工厂方法，用于创建相关的实例，这里简单罗列一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以指定序列中包含的全部元素。创建出来的 Flux </span></span><br><span class="line"><span class="comment">// 序列在发布这些元素之后会自动结束。</span></span><br><span class="line">Flux.just(<span class="string">"glmapper"</span>, <span class="string">"leishu"</span>);</span><br><span class="line"><span class="comment">// 从一个Iterable 对象中创建 Flux 对象,当然还可以是数组、Stream对象等</span></span><br><span class="line">Flux.fromIterable(Arrays.asList(<span class="string">"glmapper"</span>,<span class="string">"leishu"</span>));</span><br><span class="line"><span class="comment">// 创建一个只包含错误消息的序列。</span></span><br><span class="line">Flux.error(<span class="keyword">new</span> IllegalStateException());</span><br><span class="line"><span class="comment">// 创建一个包含了从 0 开始递增的 Long 对象的序列。其中包含的元素按照指定的间</span></span><br><span class="line"><span class="comment">// 隔来发布。除了间隔时间之外，还可以指定起始元素发布之前的延迟时间。</span></span><br><span class="line">Flux.interval(Duration.ofMillis(<span class="number">100</span>)).take(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 创建一个不包含任何消息通知的序列。</span></span><br><span class="line">Flux.never();</span><br><span class="line"><span class="comment">// 创建一个不包含任何元素，只发布结束消息的序列。</span></span><br><span class="line">Flux.empty(); </span><br><span class="line"><span class="comment">// 创建包含从 start 起始的 count 个数量的 Integer 对象的序列</span></span><br><span class="line">Flux.range(<span class="keyword">int</span> start, <span class="keyword">int</span> count);</span><br><span class="line"><span class="comment">// Mono 同上</span></span><br><span class="line">Mono.empty();</span><br><span class="line">Mono.never();</span><br><span class="line">Mono.just(<span class="string">"glmapper"</span>);</span><br><span class="line">Mono.error(<span class="keyword">new</span> IllegalStateException());</span><br></pre></td></tr></table></figure></p>
<p>上面的这些静态方法适合于简单的序列生成，当序列的生成需要复杂的逻辑时，则应该使用 generate() 或 create() 方法。</p>
<h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><ul>
<li>Operator：Operator 是一系列函数式的便捷操作，可以链式调用。所有函数调用基本都 是 Reactor 的 Operator ，比如 just，map，flatMap，filter 等。</li>
<li>Processor：上面从 Processor 的接口定义可以看出，它既是一个 Subscriber，又是一个 Publisher；Processor 夹在第一个 Publisher 和最后一个 Subscriber 中间，对数据进行处理。有点类似 stream 里的 map，filter 等方法。具体在数据流转中， Processor 以 Subscriber 的身份订阅 Publisher 接受数据，又以 Publisher 的方式接受其它 Subscriber 的订阅，它从自己订阅的 Publisher 收到数据后，做一些处理，然后转发给订阅它的 Subscriber。</li>
<li>back pressure：背压。对 MQ 有了解的应该清楚，消息积压一般是在消费端，也就是说生产端只负责生产，并不会关心消费端的消费能力，这样就到导致 pressure 积压在消费端，这个是正向的。从上面对 Reactor 中的一些了解，Subscriber 是主动向 Publisher 请求的，这样当消费端消费的速度没有生产者快时，这些消息还是积压在生产端；这种好处就是生产者可以根据实际情况适当的调整生产消息的速度。</li>
<li>Hot VS Cold ：参考 <a href="https://htmlpreview.github.io/?https://github.com/get-set/reactor-core/blob/master-zh/src/docs/index.html#reactor.hotCold" target="_blank" rel="noopener">Hot VS Cold</a></li>
</ul>
<h3 id="核心调用过程"><a href="#核心调用过程" class="headerlink" title="核心调用过程"></a>核心调用过程</h3><p>Reactor 的核心调用过程大致可以分为图中的几个阶段<br><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/reactor/reactor-processor.jpg" alt=""></p>
<ul>
<li>声明：无论是使用 just 或者其他什么方式创建反应式流，这个过程都可以称之为声明，因为此时这些代码不会被实际的执行。</li>
<li>subscribe：当调用 subscribe 时，整个执行过程便进入 subscribe 阶段，经过一系列的调用之后，subscribe 动作会代理给具体的 Flux 来实现。</li>
<li>onSubscribe：onSubscribe 阶段指的是 Subscriber#onSubscribe 方法被依次调用的阶段。这个阶段会让各 Subscriber 知道 subscribe 方法已被触发，真正的处理流程马上就要开始。</li>
<li>request：onSubscribe 阶段是表示订阅动作的方式，让各 Subscriber 知悉，准备开始处理数据。当最终的 Subscriber 做好处理数据的准备之后，它便会调用 Subscription 的 request 方法请求数据。</li>
<li>onNext：通过调用 Subscriber 的 onNext 方法，进行真正的响应式的数据处理。</li>
<li>onComplete：成功的终端状态，没有进一步的事件将被发送。</li>
<li>onError：错误的终端状态（和 onComplete 一样，当发生时，后面的将不会在继续执行）。</li>
</ul>
<h3 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h3><p>当需要处理 Flux 或 Mono 中的消息时，可以通过 subscribe 方法来添加相应的订阅逻辑。在调用 subscribe 方法时可以指定需要处理的消息类型。可以只处理其中包含的正常消息，也可以同时处理错误消息和完成消息。</p>
<h4 id="通过-subscribe-方法处理正常和错误消息"><a href="#通过-subscribe-方法处理正常和错误消息" class="headerlink" title="通过 subscribe() 方法处理正常和错误消息"></a>通过 subscribe() 方法处理正常和错误消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">   .concatWith(Mono.error(<span class="keyword">new</span> IllegalStateException()))</span><br><span class="line">   .subscribe(System.out::println, System.err::println);</span><br></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">java.lang.IllegalStateException</span><br></pre></td></tr></table></figure></p>
<p>正常的消息处理相对简单。当出现错误时，有多种不同的处理策略:</p>
<ul>
<li>通过 onErrorReturn() 方法返回一个默认值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    .concatWith(Mono.error(<span class="keyword">new</span> IllegalStateException()))</span><br><span class="line">    .onErrorReturn(<span class="number">0</span>)</span><br><span class="line">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<ul>
<li>通过 onErrorResume()方法来根据不同的异常类型来选择要使用的产生元素的流<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">       .concatWith(Mono.error(<span class="keyword">new</span> IllegalArgumentException()))</span><br><span class="line">       .onErrorResume(e -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (e <span class="keyword">instanceof</span> IllegalStateException) &#123;</span><br><span class="line">               <span class="keyword">return</span> Mono.just(<span class="number">0</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> IllegalArgumentException) &#123;</span><br><span class="line">               <span class="keyword">return</span> Mono.just(-<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> Mono.empty();</span><br><span class="line">           &#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure></p>
<ul>
<li>通过 retry 操作符来进行重试，重试的动作是通过重新订阅序列来实现的。在使用 retry 操作符时可以指定重试的次数。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    .concatWith(Mono.error(<span class="keyword">new</span> IllegalStateException()))</span><br><span class="line">    .retry(<span class="number">1</span>)</span><br><span class="line">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">Exception in thread &quot;main&quot; reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.IllegalStateException</span><br><span class="line">Caused by: java.lang.IllegalStateException</span><br><span class="line">	at com.glmapper.bridge.boot.reactor.SimpleTest.testFluxSub(SimpleTest.java:75)</span><br><span class="line">	at com.glmapper.bridge.boot.reactor.SimpleTest.main(SimpleTest.java:23)</span><br></pre></td></tr></table></figure></p>
<h3 id="调度器-Scheduler"><a href="#调度器-Scheduler" class="headerlink" title="调度器 Scheduler"></a>调度器 Scheduler</h3><p>在 Reactor 中，执行模式以及执行过程取决于所使用的 Scheduler，Scheduler 是一个拥有广泛实现类的抽象接口，Schedulers 类提供的静态方法用于达成如下的执行环境：</p>
<ul>
<li><p>当前线程（Schedulers.immediate()）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Schedulers.immediate().schedule(()-&gt;&#123;</span><br><span class="line">   System.out.println(Thread.currentThread().getName()+<span class="string">"-"</span>+<span class="number">11</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main-11</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可重用的单线程（Schedulers.single()）。注意，这个方法对所有调用者都提供同一个线程来使用， 直到该调度器（Scheduler）被废弃。如果你想使用专一的线程，就对每一个调用使用 Schedulers.newSingle()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Schedulers.single().schedule(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"-"</span>+<span class="number">11</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// single-1-11</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>弹性线程池（Schedulers.elastic()。它根据需要创建一个线程池，重用空闲线程。线程池如果空闲时间过长 （默认为 60s）就会被废弃。对于 I/O 阻塞的场景比较适用。 Schedulers.elastic() 能够方便地给一个阻塞 的任务分配它自己的线程，从而不会妨碍其他任务和资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Schedulers.elastic().schedule(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"-"</span>+<span class="number">11</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// elastic-2-11</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>固定大小线程池（Schedulers.parallel()）。所创建线程池的大小与 CPU 个数等同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Schedulers.parallel().schedule(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"-"</span>+<span class="number">11</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// parallel-1-11</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>基于现有的 ExecutorService 创建 Scheduler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">Schedulers.fromExecutorService(executorService).schedule(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"-"</span>+<span class="number">11</span>);</span><br><span class="line">&#125;);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// pool-4-thread-1-11</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>基于 newXXX 方法来创建调度器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Schedulers.newElastic(<span class="string">"test-elastic"</span>).schedule(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"-"</span>+<span class="number">11</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// test-elastic-4-11</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>一些操作符默认会使用一个指定的调度器（通常也允许开发者调整为其他调度器）例如， 通过工厂方法 Flux.interval(Duration.ofMillis(100)) 生成的每 100ms 打点一次的 Flux<long>， 默认情况下使用的是 Schedulers.parallel()，下边的代码演示了如何将其装换为 Schedulers.single()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; intervalResult = Flux.interval(Duration.ofMillis(<span class="number">100</span>),</span><br><span class="line">        Schedulers.newSingle(<span class="string">"test"</span>))</span><br><span class="line">        .map(i -&gt; Thread.currentThread().getName() +<span class="string">"@"</span>+i);</span><br><span class="line">        intervalResult.subscribe(System.out::println);</span><br></pre></td></tr></table></figure></long></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test-1@0</span><br><span class="line">test-1@1</span><br><span class="line">test-1@2</span><br><span class="line">test-1@3</span><br><span class="line">test-1@4</span><br><span class="line">// 省略</span><br></pre></td></tr></table></figure></p>
<h3 id="publishOn-和-subscribeOn"><a href="#publishOn-和-subscribeOn" class="headerlink" title="publishOn 和 subscribeOn"></a>publishOn 和 subscribeOn</h3><p>Reactor 提供了两种在响应式链中调整调度器 Scheduler 的方法：publishOn 和 subscribeOn。 它们都接受一个 Scheduler 作为参数，从而可以改变调度器。但是 publishOn 在链中出现的位置是有讲究的，而 subscribeOn 则无所谓。</p>
<ul>
<li>publishOn 的用法和处于订阅链（subscriber chain）中的其他操作符一样。它将上游 信号传给下游，同时执行指定的调度器 Scheduler 的某个工作线程上的回调。 它会 改变后续的操作符的执行所在线程 （直到下一个 publishOn 出现在这个链上）</li>
<li>subscribeOn 用于订阅（subscription）过程，作用于那个向上的订阅链（发布者在被订阅 时才激活，订阅的传递方向是向上游的）。所以，无论你把 subscribeOn 至于操作链的什么位置， 它都会影响到源头的线程执行环境（context）。 但是，它不会影响到后续的 publishOn，后者仍能够切换其后操作符的线程执行环境。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Flux.create(sink -&gt; &#123;</span><br><span class="line">        sink.next(Thread.currentThread().getName());</span><br><span class="line">        sink.complete();</span><br><span class="line">    &#125;)</span><br><span class="line">    .publishOn(Schedulers.single())</span><br><span class="line">    .map(x -&gt; String.format(<span class="string">"[%s] %s"</span>, Thread.currentThread().getName(), x))</span><br><span class="line">    .publishOn(Schedulers.elastic())</span><br><span class="line">    .map(x -&gt; String.format(<span class="string">"[%s] %s"</span>, Thread.currentThread().getName(), x))</span><br><span class="line">    .subscribeOn(Schedulers.parallel())</span><br><span class="line">    .toStream()</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[elastic-<span class="number">2</span>] [single-<span class="number">1</span>] parallel-<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>上面这段代码使用 create() 方法创建一个新的 Flux 对象，其中包含唯一的元素是当前线程的名称。</p>
<p>接着是两对 publishOn() 和 map()方法，其作用是先切换执行时的调度器，再把当前的线程名称作为前缀添加。</p>
<p>最后通过 subscribeOn()方法来改变流产生时的执行方式。</p>
<p>最内层的线程名字 parallel-1 来自产生流中元素时使用的 Schedulers.parallel()调度器，中间的线程名称 single-1 来自第一个 map 操作之前的 Schedulers.single() 调度器，最外层的线程名字 elastic-2 来自第二个 map 操作之前的 Schedulers.elastic()调度器。</p>
<blockquote>
<p>先到这里，剩下的想到再补充…</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://projectreactor.io/docs/core/release/reference/" target="_blank" rel="noopener">https://projectreactor.io/docs/core/release/reference/</a></li>
<li><a href="https://htmlpreview.github.io/?https://github.com/get-set/reactor-core/blob/master-zh/src/docs/index.html#about-doc" target="_blank" rel="noopener">https://htmlpreview.github.io/?https://github.com/get-set/reactor-core/blob/master-zh/src/docs/index.html#about-doc</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-cn-with-reactor-response-encode/index.html?lnk=hmhm" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-cn-with-reactor-response-encode/index.html?lnk=hmhm</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2019/08/24/base-java-reacotr/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
    </div>
    
      <div id="page-nav" class="pagination">
	<span class="page-number current">1</span>
      </div>
    
  </section>

</div>

</div>

</section>
</div>


    <!-- BEGIN PRE-FOOTER -->
    <div class="pre-footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN BOTTOM ABOUT BLOCK -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>About Us</h2>
            <p>Computer Lab is a software development and marketing company based in Brooklyn, New York. <br><br> Computer Lab was founded in 2015, and is focused on so on and so forth.</p>
          </div>
          <!-- END BOTTOM ABOUT BLOCK -->

          <!-- BEGIN BOTTOM CONTACTS -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>Contact</h2>
            <address class="margin-bottom-40">
              140 Metropolitan Avenue<br>
              5th Floor<br>
              Brooklyn, NY 11249<br>
              Phone: 716-472-4484<br>
              Email: <a href="mailto:ptsteadman@gmail.com">ptsteadman@gmail.com</a><br>
            </address>
          </div>
          <!-- END BOTTOM CONTACTS -->

	
          <!-- BEGIN TWITTER BLOCK --> 
          <div class="col-md-4 col-sm-6 pre-footer-col">

	  <a data-tweet-limit="1" class="twitter-timeline" href="https://twitter.com/computerlab_" data-widget-id="678830341331820544">Tweets by @computerlab_</a>

	  <script>!function(d,s,id){var
	  js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

          </div>
          <!-- END TWITTER BLOCK -->
	
        </div>
      </div>
    </div>
    <!-- END PRE-FOOTER -->

    <!-- BEGIN FOOTER -->
    <div class="footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN COPYRIGHT -->
          <div class="col-md-6 col-sm-6 padding-top-10">
                  &copy; 2020 glmapper<br>
 <a href="javascript:;">Privacy Policy</a> | <a href="javascript:;">Terms of Service</a>
          </div>
          <!-- END COPYRIGHT -->
	  <!-- BEGIN SOCIAL -->
<div class="col-md-6 col-sm-6">
  <ul class="social-footer list-unstyled list-inline pull-right">
    
      <li><a href="https://github.com/ptsteadman"><i class="fa fa-github"></i></a></li>
    
      <li><a href="https://twitter.com/ptsteadman"><i class="fa fa-twitter"></i></a></li>
    
      <li><a href="https://www.facebook.com/ptsteadman"><i class="fa fa-facebook"></i></a></li>
    
      <li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li>
    
      <li><a href="https://linkedin.com/in/ptsteadman"><i class="fa fa-linkedin"></i></a></li>
    
      <li><a href="http://stackoverflow.com/users/2480493/patrick-steadman"><i class="fa fa-stackoverflow"></i></a></li>
    
  </ul>  
</div>
<!-- END SOCIAL -->

        </div>
      </div>
    </div>
    <!-- END FOOTER -->

  <!-- BEGIN CORE PLUGINS (REQUIRED FOR ALL PAGES) -->
<!--[if lt IE 9]>
<script src="/metronic/assets/plugins/respond.min.js"></script>
<![endif]--> 
<script src="/metronic/assets/plugins/jquery.min.js"></script>
<script src="/metronic/assets/plugins/jquery-migrate.min.js"></script>
<script src="/metronic/assets/plugins/bootstrap/js/bootstrap.min.js"></script>
<script src="/metronic/assets/corporate/scripts/back-to-top.js"></script>
<script src="/metronic/assets/plugins/owl.carousel/owl.carousel.min.js"></script>
<script src="/metronic/assets/corporate/scripts/layout.js"></script>
<script src="/js/wow.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script type="text/javascript">
    jQuery(document).ready(function() {
        Layout.init();    
        Layout.initOWL();
        Layout.initTwitter();
        Layout.initFixHeaderWithPreHeader(); /* Switch On Header Fixing (only if you have pre-header) */
        Layout.initNavScrolling(); 
	new WOW().init();
    });
</script>
<!-- END CORE PLUGINS -->

<!-- BEGIN PAGE-SPECIFIC PLUGINS --> 







<!-- END PAGE-SPECIFIC PLUGINS --> 

<!-- BEGIN INTEGRATIONS -->





<!-- END INTEGRATIONS -->

</body>
</html>
