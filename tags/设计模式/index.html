<!DOCTYPE html>
<!--[if IE 8]> <html lang="en" class="ie8 no-js"> <![endif]-->
<!--[if IE 9]> <html lang="en" class="ie9 no-js"> <![endif]-->
<!--[if !IE]><!-->
<html lang="en">
<!--<![endif]-->
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Tag: 设计模式 | glmapper</title>

  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <meta name="description" content="从平凡的世界中全身而退">
<meta property="og:type" content="website">
<meta property="og:title" content="glmapper">
<meta property="og:url" content="http://www.glmapper.com/tags/设计模式/index.html">
<meta property="og:site_name" content="glmapper">
<meta property="og:description" content="从平凡的世界中全身而退">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="glmapper">
<meta name="twitter:description" content="从平凡的世界中全身而退">
  
    <link rel="alternative" href="/atom.xml" title="glmapper" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
    
  <meta content="{{ title }}" name="description">
  <meta content="{{ title }}" name="keywords">
  <meta content="{{ title }}" name="author">

  <link href="http://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700|PT+Sans+Narrow|Source+Sans+Pro:200,300,400,600,700,900&amp;subset=all" rel="stylesheet" type="text/css">

  <!-- Global styles START -->   
  <link rel="stylesheet" href="/metronic/assets/plugins/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/bootstrap/css/bootstrap.min.css">
  <!-- Global styles END --> 
   
  <!-- Page level plugin styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/animate.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/owl.carousel/assets/owl.carousel.css">
  <!-- Page level plugin styles END -->

  <!-- Theme styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/components.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/slider.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/portfolio.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style-responsive.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/themes/red.css">
  <link rel="stylesheet" href="/css/theme-styles.css">
  <!-- Theme styles END -->
</head>
</html>
<body class="corporate">
  <!-- BEGIN TOP BAR -->
<div class="pre-header">
  <div class="container">
    <div class="row">
      <!-- BEGIN TOP BAR LEFT PART -->
      <div class="col-md-6 col-sm-6 col-xs-9 additional-shop-info">
	<ul class="list-unstyled list-inline">
	  <li><i class="fa fa-phone"></i><span>716-472-4484</span></li>
	  <li><i class="fa fa-envelope-o"></i><span>ptsteadman@gmail.com</span></li>
	</ul>
      </div>
      <!-- END TOP BAR LEFT PART -->
      <!-- BEGIN TOP BAR MENU -->
      <div class="col-md-6 col-sm-6 col-xs-3 additional-nav">
	<ul class="list-unstyled list-inline pull-right">
	  <li><a href="/login">Log In</a></li>
	</ul>
      </div>
      <!-- END TOP BAR MENU -->
    </div>
  </div>        
</div>
<!-- END TOP BAR -->
<!-- BEGIN HEADER -->
<div class="header">
  <div class="container">
    <!--<a class="site-logo" href="/" id="logo">glmapper</a>-->

    <a class="site-logo" href="/">
      <img src="/metronic/assets/corporate/img/logos/logo-corp-red.png" alt="Metronic FrontEnd">
    </a>

    <a href="javascript:void(0);" class="mobi-toggler"><i class="fa fa-bars"></i></a>

    <!-- BEGIN NAVIGATION -->
    <div class="header-navigation pull-right font-transform-inherit">
      <ul>
	
	<li class="">
	  <a href="/">Home</a>
	</li>
	
	<li class="">
	  <a href="/projects/">Projects</a>
	</li>
	
	<li class="">
	  <a href="/archives/">Blog</a>
	</li>
	
	<li class="">
	  <a href="/contact/">Contact</a>
	</li>
	
	<li class="">
	  <a href="/about/">About</a>
	</li>
	
	<!-- BEGIN TOP SEARCH -->
	<li class="menu-search">
	  <span class="sep"></span>
	  <i class="fa fa-search search-btn"></i>
	  <div class="search-box">
	    <form action="#">
	      <div class="input-group">
		<input type="text" placeholder="Search" class="form-control st-default-search-input">
		<span class="input-group-btn">
		  <button class="btn btn-primary" type="submit">Search</button>
		</span>
	      </div>
	    </form>
	  </div> 
	</li>
	<!-- END TOP SEARCH -->
      </ul>
    </div>
    <!-- END NAVIGATION -->
  </div>
</div>
<!-- Header END -->

  <div class="container">
  <ul class="breadcrumb">
    <li><a href="/">Home</a></li>
    <li><a href="/blog">Blog</a></li>
    <li class="active">Tagged: 设计模式</li>
  </ul>
<section id="main">
  <h1>Tagged: 设计模式</h1>
  <div class="row">

<div class="col-xs-12 blog-posts">


  <section class="archives-wrap">
    <div class="archives">
      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2020/01/28/java-design-model-adapter/">菜鸟成长系列-适配器模式</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2020-01-28T07:32:14.000Z" itemprop="datePublished">2020/01/28</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2020/01/28/java-design-model-adapter/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/设计模式/" title="设计模式">设计模式</a>,
  
    <a href="/tags/读书笔记/" title="读书笔记">读书笔记</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<blockquote>
<p>本文为阅读 《JAVA与模式》的个人笔记，文中相关概念及背景描述参考书本。如有不当，请联系指正。</p>
</blockquote>
<p><strong>定义：适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配为无法在一起工作的两个类能够在一起工作 -《JAVA与模式》</strong></p>
<p>适配、包装、转换几个字眼从汉字的字面意思来说是不同的，不同在于这几个词所对应的行为不同；但是他们所期望的目的是差不多一致的，就是将不可用变成可用。所以常说的适配器模式、转换器模式以及包装模式指的都是一个模式。</p>
<h2 id="适配器模式的两种形式"><a href="#适配器模式的两种形式" class="headerlink" title="适配器模式的两种形式"></a>适配器模式的两种形式</h2><p>在 java 语言体系中，根据适配类型的不同。适配器模式可以分为：<strong>类的适配器模式</strong>和<strong>对象的适配器模式</strong>。</p>
<h3 id="类的适配器模式"><a href="#类的适配器模式" class="headerlink" title="类的适配器模式"></a>类的适配器模式</h3><p>顾名思义，类的适配器模式是把被适配的类的 API 转换成为目标类的 API。</p>
<p>这里涉及到三个角色：</p>
<ul>
<li>目标角色：客户端期待的接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 源类没有的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sampleOperation1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 源类没有的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sampleOperation2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>源角色：现有需要被适配的接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sampleOperation1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// todo your biz</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>适配器角色：把源接口转换成目标接口的适配器类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// todo your biz</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于源类没有 sampleOperation2 方法，因此适配器类中补充上这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// todo your biz</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Target 接口申明了两个方法：sampleOperation1 和 sampleOperation2 ，而源角色 Adaptee 是一个具体的类，它只有一个 sampleOperation1 方法，但是没有 sampleOperation2 这个方法。适配器角色 Adapter 扩展了 Adaptee ，同时又实现了目标接口，由于 Adaptee 没有 sampleOperation2 方法，而目标接口又要求这个方法，因此适配器角色 Adapter 实现了这个方法。</p>
<p>适配器模式所达到的效果是：<strong>使用一个具体类把源（Adaptee）适配到目标（Target）中，这样一来，如果源以及源的子类都使用此类适配，就行不通了。由于适配器类是源的子类，因此可以在适配器类中置换掉源的一些方法；另外，由于只引进了一个适配器类，因此只有一个路线达到目标类，使问题得到简化。</strong></p>
<h3 id="对象的适配器模式"><a href="#对象的适配器模式" class="headerlink" title="对象的适配器模式"></a>对象的适配器模式</h3><p>与类的适配器模式一样，对象的适配器模式把被适配的类的 API 转换成为目标类的 API ，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到 Adaptee 类，而是使用委派关系连接到 Adaptee 类。这里我们只需要对前面的 Adapter 做简单的修改即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjAdapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjAdapter</span><span class="params">(Adaptee adaptee)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.sampleOperation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// todo your biz</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上这里所说的委派就是组合。</p>
</blockquote>
<p>适配器模式的用意在于将接口不同而功能相同或者相近的两个接口加以转换，这里面包括适配器角色补充了一个源角色没有的方法。需要注意的是，不要误以为适配器模式就是为了补充源角色没有的方法而准备的。</p>
<h2 id="在什么情况下需要使用适配器模式"><a href="#在什么情况下需要使用适配器模式" class="headerlink" title="在什么情况下需要使用适配器模式"></a>在什么情况下需要使用适配器模式</h2><p>书中提到的有三种场景，但是在实际的工程中，场景要远远多于书中所说的。</p>
<ul>
<li>1、系统需要使用现有的类，而此类的接口不符合系统的需要</li>
<li>2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有很复杂的接口</li>
<li>3、在设计里，需要改变多个已有的子类的接口，如果使用类的适配器模式，就需要针对每一个子类做一个适配器，而这不太实际。</li>
</ul>
<h2 id="与一些模式的区别"><a href="#与一些模式的区别" class="headerlink" title="与一些模式的区别"></a>与一些模式的区别</h2><h3 id="与桥接器模式的区别"><a href="#与桥接器模式的区别" class="headerlink" title="与桥接器模式的区别"></a>与桥接器模式的区别</h3><p>桥接器模式的用意是要把实现和它的接口分开，以便于它们可以独立的变化。桥接器模式并不是用来把一个已有的对象接到不匹配的接口上的，当一个客户端只知道一个特定的接口，但是又必须与具有不同接口的类打交道时，就应当使用适配器模式。</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/designmodel/bridge.jpg" alt=""></p>
<h3 id="与装饰模式的区别"><a href="#与装饰模式的区别" class="headerlink" title="与装饰模式的区别"></a>与装饰模式的区别</h3><p>一个装饰类也是位于客户端和另一个 Component 对象之间的，在它接到客户端的调用后把调用传给一个或者几个 Component 对象。一个纯粹的装饰类必须与 Component 对象在接口上的完全相同，并增强后者的功能。</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/designmodel/decrator.jpg" alt=""><br>与适配器类不同的是，装饰类不能改变它所装饰的 Component 对象的接口。</p>
<blockquote>
<p>装饰模式可以这样理解，《开局一把枪，装备全靠打：皮肤、装备加持就是角色的装饰》</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇是在阅读 《JAVA与模式》一书所做的笔记记录，以备后续方便查阅。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2020/01/28/java-design-model-adapter/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/java-design-model-strategy/">菜鸟成长系列-策略模式</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T06:24:27.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/java-design-model-strategy/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/设计模式/" title="设计模式">设计模式</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<blockquote>
<p>上次在模板方法模式中有提及到，模板方法模式通常不会单独来试用，在一些实际的应用中会搭配其他的模式来使用，比如说今天要学习的策略模式。</p>
</blockquote>
<p>一直我都很喜欢策略这个词，有种莫名的高大上，对三国有了解的小伙伴肯定会知道，有的谋士是比较直接的，献计就是献计，有话当面说；但是也有的谋士就是比较喜欢搞一种神秘感，弄个小布袋子里面塞个小布条（简称：锦囊）；对于一件很棘手的事情，在交代下去的时候就会有这样的嘱咐：“此事关系重大，还望XXX（昵称）务必处理妥帖；这里有三个锦囊，如果XXXX，你就拆开第X个锦囊，然后XXXX”；有时候我就很不解，假如真在遇到事情的时候来看，那路上丢了怎么办？一摸口袋就懵逼了有木有？</p>
<p>扯远了，不过意思就是这个意思，一个锦囊其实就是一种策略；然后它有一个总的背景（我们称之为上下文环境），这个大背景下，每个不同的场景都会有一中策略来对应处理；</p>
<p>我们先以上面的列子为背景来撸一个小的例子，然后再去看一个spring中比较典型的策略模式使用，最后再来探讨下策略模式的类图，并以此来说明策略模式中的一些基本角色及其职责。</p>
<h3 id="锦囊妙计"><a href="#锦囊妙计" class="headerlink" title="锦囊妙计"></a>锦囊妙计</h3><blockquote>
<p>兵马未动，粮草先行；但是这个运输粮草到底是走水路还是走陆地呢？那这得看往哪运…</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.policy;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 大背景，运输粮草</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/5/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransportFood</span> </span>&#123;</span><br><span class="line">    <span class="comment">//持有一个运输策略的对象</span></span><br><span class="line">    <span class="keyword">private</span> TransportFoodStrategy strategy;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，传入一个具体策略对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strategy    具体策略对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TransportFood</span><span class="params">(TransportFoodStrategy strategy)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 策略方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trasportFood</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        strategy.trasport();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是我们的总体背景，就是运输粮草；但是这个只是说要运输粮草，但是并没有说是怎么运？这就得TransportFoodStrategy这个运输策略有具体的运输方案。</p>
<ul>
<li>运输方案1：如果粮草是从武汉到南京，OK，那就走水运吧。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 运输粮草的策略之水运运输</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/5/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaterTransportStrategy</span> <span class="keyword">implements</span> <span class="title">TransportFoodStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trasport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用船，走水运"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运输方案2：如果从内蒙到北京；那就走陆运吧。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 运输粮草的策略之陆地运输</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/5/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LandTransportStrategy</span> <span class="keyword">implements</span> <span class="title">TransportFoodStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trasport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用马车，走陆运"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，来看下妙计使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 决策制定-客户端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/5/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        TransportFoodStrategy strategy =</span><br><span class="line">        getTransportFoodStrategy(<span class="string">"内蒙到北京"</span>);</span><br><span class="line"></span><br><span class="line">        TransportFood transportFood = <span class="keyword">new</span> TransportFood(strategy);</span><br><span class="line">        transportFood.trasportFood();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取运输方案</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lineType 运输路线</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TransportFoodStrategy <span class="title">getTransportFoodStrategy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String lineType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lineType.equals(<span class="string">"内蒙到北京"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LandTransportStrategy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lineType.equals(<span class="string">"武汉到南京"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WaterTransportStrategy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-&gt; 用马车，走陆运</span><br></pre></td></tr></table></figure>
<p>粮草运完了，真正的表演开始了…</p>
<h3 id="Spring中典型的策略模式使用"><a href="#Spring中典型的策略模式使用" class="headerlink" title="Spring中典型的策略模式使用"></a>Spring中典型的策略模式使用</h3><p>我们知道spring加载资源文件是通过ResourceLoader来搞定的。在ResourceLoader中提供了一个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个方法的注解中说道</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//允许多个资源调用。</span><br><span class="line">allowing for multiple &#123;@link Resource#getInputStream()&#125; calls.</span><br></pre></td></tr></table></figure>
<p>这里就很赤裸裸了，他告诉了你要获取资源，但是如果获取资源呢？这就得看有哪些具体的获取策略了。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/5/1633103f6010a684?w=1724&amp;h=642&amp;f=png&amp;s=329841" alt=""></p>
<p>上图就是Resource的具体子类实现，也就是一些具体的策略。我们比较常见的应该算是UrlResource（加载URL指定的资源）和ClasspathResource（加载类路径中的资源）这两个。再来看下这个getResource这个方法的实现：</p>
<blockquote>
<p>getResource方法是在DefaultResourceLoader中具体实现的；DefaultResourceLoader是ResourceLoader的默认实现。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">	Assert.notNull(location, <span class="string">"Location must not be null"</span>);</span><br><span class="line">	<span class="comment">//首先使用ProtocolResolver来通过location参数创建Resource对象</span></span><br><span class="line">	<span class="comment">// spring4.3.x开始才有的</span></span><br><span class="line">	<span class="keyword">for</span> (ProtocolResolver protocolResolver : <span class="keyword">this</span>.protocolResolvers) &#123;</span><br><span class="line">            Resource resource = protocolResolver.resolve(location,<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> resource;</span><br><span class="line">            &#125;</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">//指定路径的</span></span><br><span class="line">	<span class="keyword">if</span> (location.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//以classpath开头的</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(</span><br><span class="line">		CLASSPATH_URL_PREFIX.length()), getClassLoader());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//这里是先尝试解析是否是带有网络协议的资源，</span></span><br><span class="line">	<span class="comment">//如果解析异常，则是在异常处理中使用了一种默认的机制。</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Try to parse the location as a URL...</span></span><br><span class="line">			URL url = <span class="keyword">new</span> URL(location);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">			<span class="comment">// No URL -&gt; resolve as resource path.</span></span><br><span class="line">			<span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/io/ProtocolResolver.html" target="_blank" rel="noopener">ProtocolResolver</a></p>
<p>其实我们可以发现，这里的location其实和我们上面那个例子中的lineType的作用是一样的，根据这个来确定具体使用哪个策略方法。</p>
<ul>
<li>策略1：使用ProtocolResolver来通过location参数创建Resource对象，在<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/io/ProtocolResolver.html" target="_blank" rel="noopener">ProtocolResolver</a>中关于ProtocolResolver的解释是：A resolution strategy for protocol-specific resource handles-协议专用资源句柄的解析策略。</li>
<li>策略2：返回给定路径上资源的资源句柄。</li>
<li>策略3：以classpath:为前缀的，这种location参数直接返回一个ClassPathResource对象，表示加载classes路径下的资源；</li>
<li>策略4：使用网络协议作为前缀的，比如http、ftp等，这种直接返回一个UrlResource对象；</li>
<li>策略5：无前缀的，在默认实现中和第三种一样是加载classes路径下的资源，不同的是此处当作是ClassPathContextResource来处理的。</li>
</ul>
<p>Spring中Resource的策(tao)略(lu)说完了，再回过头来看下策略模式的一些具体理论知识。</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><blockquote>
<p>定义：策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。</p>
</blockquote>
<p>结合前面的例子分析和这段定义，可以知道，其实策略模式真的意图不是如何实现策略算法，它更在意的是如何组织这些算法。</p>
<p>这也是策略模式的使用可以让程序结构更灵活，具有更好的维护性和扩展性的重要因素。</p>
<p><strong>类图：</strong><br><img src="https://user-gold-cdn.xitu.io/2018/5/6/1633122266b7c893?w=1232&amp;h=570&amp;f=png&amp;s=36574" alt="类图"><br><code>这个类图画的确实是有点丑，但是为了亲手绘制一下，所以还请多多见谅！</code></p>
<p><strong>类图中的一些角色：</strong></p>
<ul>
<li>context：策略背景，也就是需要使用策略的主体；它持有一个strategy类的引用</li>
<li>strategy：抽象策略，这个角色给出了所有具体策略类所需的接口。所以通常是一个抽象类或者接口。</li>
<li>strategyPolicy：具体策略，它的作用就是包装具体的算法或者行为</li>
</ul>
<p>那么在实际的应用中，策略模式到底给我们带来的好处是什么，它能够帮助我们解决什么样的问题呢？这个需要从模式本身的优缺点来看：</p>
<p><strong>优点</strong></p>
<ul>
<li><p>策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。</p>
</li>
<li><p>策略模式可以避免使用多重条件(if-else)语句。通常对于一个背景主体，一般只会有一种策略算法可供使用，使用多重条件句的话不易维护；因为它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起了。</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><p>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。</p>
</li>
<li><p>由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。–如果策略很多，通常会采用一些混合策略来避免策略类的不断膨胀。</p>
</li>
</ul>
<p>在了解其优缺点的情况下，我们就可以合理的将其放在一些适当的场景中来；如以下场景：</p>
<ul>
<li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 </li>
<li>一个系统需要动态地在几种算法中选择一种。   </li>
<li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li>
</ul>
<p><strong>参考</strong></p>
<ul>
<li>《JAVA与模式》</li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/05/10/2491891.html" target="_blank" rel="noopener">《JAVA与模式》之策略模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/strategy-pattern.html" target="_blank" rel="noopener">策略模式</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/java-design-model-strategy/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/java-design-model-modulemethod/">菜鸟成长系列-模板方法模式</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T06:23:37.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/java-design-model-modulemethod/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/设计模式/" title="设计模式">设计模式</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<blockquote>
<p>模板方法模式在sring中有大量的应用，一般我们会使用模板方法来将当前的实现委托给子类来实现，增强代码的可扩展性和复用性。因为涉及到父子类关系，所以模板方法模式是基于“继承”来实现的；模板方法模式属于行为型模式。</p>
</blockquote>
<p><code>简单地说就是，通过父类来定义一系列的算法骨架，并且约定这些方法及其调用顺序，而具体的某些特定方法由子类实现。</code></p>
<p>先来看一个小demo；我们以写博客来举例子，一般我们写博客的步骤如下：</p>
<ul>
<li>打开目标网站</li>
<li>打开编辑器</li>
<li>写文章</li>
<li>发布文章</li>
</ul>
<h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><p>首先是定义一个父类，并且提供一个模板方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.mudolmethod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 抽象模板父类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTemplateMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流程方法1：抽象方法，供子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">openTargetWebSite</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流程方法2：子类可选择重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openMarkDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开编辑器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流程方法3：抽象方法，供子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeBlog</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流程方法4：子类可选择重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publisher</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发布文章"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法，此处申明为final，是不希望子类覆盖这个方法，防止更改流程的执行顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">templateWriteBlog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        openTargetWebSite();</span><br><span class="line">        openMarkDown();</span><br><span class="line">        writeBlog();</span><br><span class="line">        publisher();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中我们提供了一个templateWriteBlog方法，这里方法中包括了写博客的一些流程。在这些流程方法中有些方法父类提供了默认实现，而一些具有差异性的方法则让子类来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.mudolmethod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 子类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JueJinTemplateMethodPolicy</span> <span class="keyword">extends</span> <span class="title">AbstractTemplateMethod</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openTargetWebSite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开掘金网站"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBlog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"写一篇Spring相关的文章"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类1：JueJinTemplateMethodPolicy，这个子类中实现了父类中的部分方法，包括：openTargetWebSite和writeBlog。（一般情况下不会去重写父类默认已经实现的方法，仅实现父类中预留的抽象方法来实现）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.mudolmethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 子类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CSDNTemplateMethodPolicy</span> <span class="keyword">extends</span> <span class="title">AbstractTemplateMethod</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openTargetWebSite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开CSDN网站"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBlog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"写一篇设计模式文章"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类2：CSDNTemplateMethodPolicy,这个子类的作用其实和子类1是一样的，只不过是提供了另外的一种实现策略；（很多情况下，模板方法模式都是和策略模式来联合使用的，通过一套模板机制，对于模板中的部分流程通过不同的策略来实现不同的功能）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.mudolmethod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 子类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractTemplateMethod csdnTemplate = <span class="keyword">new</span> CSDNTemplateMethodPolicy();</span><br><span class="line">        csdnTemplate.templateWriteBlog();</span><br><span class="line"></span><br><span class="line">        AbstractTemplateMethod juejinTemplate = <span class="keyword">new</span> JueJinTemplateMethodPolicy();</span><br><span class="line">        juejinTemplate.templateWriteBlog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打开CSDN网站</span><br><span class="line">打开编辑器</span><br><span class="line">写一篇设计模式文章</span><br><span class="line">发布文章</span><br><span class="line"></span><br><span class="line">打开掘金网站</span><br><span class="line">打开编辑器</span><br><span class="line">写一篇Spring相关的文章</span><br><span class="line">发布文章</span><br></pre></td></tr></table></figure>
<p>上面是客户端代码及输出结果。通过输出我们可以明显的看出，模板中的一些方法将延迟到子类中去实现，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。因此对于模板方法这个模式来说，父类是始终控制着整个流程主动权的，而子类只是辅助父类实现某些可定制的步骤。 </p>
<h2 id="模式解析"><a href="#模式解析" class="headerlink" title="模式解析"></a>模式解析</h2><p>先看下模板方法模式的类图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/30/163148bb2155fca2?w=459&amp;h=315&amp;f=png&amp;s=85263" alt=""></p>
<p>从类图中可以看出，模板方法模式中的角色也是很简单的，主要包括两个角色：</p>
<ul>
<li><p>抽象模板（AbstractTemplate）：</p>
<ul>
<li>定义一个或者多个抽象操作，以便于让子类实现。这些抽象操作就是流程中的基本操作（对应的是模板方法中的某个具体的操作方法）；这些基本操作是一个顶级逻辑的组成步骤</li>
<li>定义并且实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类中取实现，当然，在这个顶级逻辑中，部分方法也可以由父类来提供默认实现的。</li>
</ul>
</li>
<li><p>具体类（SubTemplateImpl)：</p>
<ul>
<li>实现父类所定义的一个或者多个抽象方法</li>
<li>每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法的不同实现。</li>
</ul>
</li>
</ul>
<p>模板方法中的这个方法的概念拆开来说包括两种，一种是模板方法，还有一种是模板方法里面的基本方法。模板方法定义游戏规则，基本方法实现规则中的每个部分。</p>
<p>模板方法带来的优势是显而易见的，它可以帮助我们有效的帮助我们搞定下面的这些场景问题：</p>
<ul>
<li>封装不变部分，扩展可变部分。 </li>
<li>提取公共代码，便于维护。 </li>
<li>行为由父类控制，子类实现。</li>
</ul>
<p>但是缺点也很明显，因为对于每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p>
<h3 id="典型的模板方法模式的应用"><a href="#典型的模板方法模式的应用" class="headerlink" title="典型的模板方法模式的应用"></a>典型的模板方法模式的应用</h3><p>最先想到的就是servlet，servlet的生命周期(以前经常遇到的面试点，现在已经没人问了吧)</p>
<ul>
<li>初始化 init</li>
<li>处理   service</li>
<li>销毁   destroy</li>
</ul>
<blockquote>
<p>其实这里我觉得也是模板方法的一种体现，虽然在servlet中没有定义顶层的模板方法来控制这个流程(我的想法是这个流程是由容器来控制的，也可能是一种默认的约定)。</p>
</blockquote>
<p>在其子类GenericServlet中对init和destroy有了默认的实现，而service方法则是交由子类来实现的，也就是说任何servlet类均必须实现service方法。</p>
<p>这里的service方法就是一个模板方法。service方法中调用了7个do方法中的一个或者几个，完成对客户端的响应，这些do方法需要由HttpServlet的具体子类提供。</p>
<p>HttpServlet中的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse</span></span></span><br><span class="line"><span class="function"><span class="params">resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String method = req.getMethod();</span><br><span class="line">        <span class="keyword">long</span> lastModified;</span><br><span class="line">        <span class="keyword">if</span> (method.equals(<span class="string">"GET"</span>)) &#123;</span><br><span class="line">            lastModified = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">            <span class="keyword">if</span> (lastModified == -<span class="number">1L</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> ifModifiedSince =</span><br><span class="line">                req.getDateHeader(<span class="string">"If-Modified-Since"</span>);</span><br><span class="line">                <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">                    <span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp.setStatus(<span class="number">304</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"HEAD"</span>)) &#123;</span><br><span class="line">            lastModified = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">            <span class="keyword">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">            <span class="keyword">this</span>.doHead(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"POST"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"PUT"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doPut(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"DELETE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doDelete(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"OPTIONS"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doOptions(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"TRACE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doTrace(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String errMsg =</span><br><span class="line">            lStrings.getString(<span class="string">"http.method_not_implemented"</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> Object[]&#123;method&#125;;</span><br><span class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">            resp.sendError(<span class="number">501</span>, errMsg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>FrameworkServlet中的实现(FrameworkServlet是SpringMVC核心控制器DispatchServlet的父类)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Override the parent class implementation in order to intercept</span></span><br><span class="line"><span class="comment"> PATCH requests.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">	HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class="line">	<span class="keyword">if</span> (HttpMethod.PATCH == httpMethod || httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">		processRequest(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">super</span>.service(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于模板方法模式的学习就到这里了。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/java-design-model-modulemethod/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/java-design-model-obs/">菜鸟成长系列-观察者模式</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T06:22:46.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/java-design-model-obs/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/设计模式/" title="设计模式">设计模式</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p><code>最近想深入研究下响应式编程，作为基础很有必要来把观察者模式撸一遍；一开始我是觉得很easy,然后就直接开撸了，撸着撸着发现撸不动了。因为我突然不太明白这个模式了，说好的观察者，到底发布-订阅的两者执行者谁才是观察者？又或者说还有其他角色？但是根据《JAVA与模式》一书中的结构，并没有额外的角色出现。</code></p>
<p>思考中….，好吧想不出来….，跑步去…</p>
<p>跑步时我给自己罗列了几个问题：</p>
<blockquote>
<p>这里先抛出定义：GOF给观察者模式如下定义：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
</blockquote>
<ul>
<li>既然是对象状态发生变更，那么到底是谁的状态发生了变更，又导致了谁被通知。</li>
<li>观察者模式既然又可以称之为“发布-订阅模式”，那么对应起来，观察者到底承当了“发布”的角色还是“订阅”的角色。就是说观察者到底是主动的还是被动的？</li>
<li>被观察者又干了什么事？它是主动的还是被动的角色？</li>
</ul>
<p>这里由于一些定式思维，总会觉得既然是“被观察者”，那么这个“被”字就是不是就表明“被观察者”是被动接受变更的一方，也就是接受通知的一方呢？</p>
<p>之前我也是走到这个胡同里了，程序写完总觉得哪里不对；回过头看，还是自己太年轻，没有get到哪些大佬们的点。</p>
<p>先来看程序；这里用掘金来打个比方，我的博客glmmaper作为被观察者，也就是发布者。掘金小伙伴们作为观察者，也就是订阅者。</p>
<p>具体逻辑：小伙伴们（订阅者）关注（订阅）了我的博客（发布者），如果我发布了一篇文章（状态变更），就会通知（推送消息）所有关注我的小伙伴。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.observor;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 抽象主题接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增关注者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer 关注的小伙伴</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFocusObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消关注</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer 取消关注的小伙伴</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeFocusObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知机制，通知机制由相关事件来触发，比如说发布文章</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> blogName          博客名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> articleName       文章名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(String blogName,String articleName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三个方法，一个是博客主页增加了一个关注者；一个是博客主页有小伙伴取消的关注（对于博客来说就是移除一个关注者，这里不知道是否也会觉得别扭？明明你取消的关注，为啥说成是我移除你，也就是不让你关注了，还能这么玩?这里肯定是需要在引入其他的一些辅助机制，比如说你在客户端发起了一个取消关注的请求，后端处理的时候掘金的工程师们就是在我的关注列表中将你移除的，嗯，这么一想确实是我不让你关注了。😄….）；最后一个方法是发起一个通知。下面是一个具体的博客，比如说是glmapper；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.observor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 这个是具体发布者，这里比喻成我的博客glmapper</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span>  <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 我的当前关注列表 */</span></span><br><span class="line">    List&lt;Observer&gt; Observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">/** 我的博客名 ：求关注 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String blogName = <span class="string">"glmapper"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFocusObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        Observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeFocusObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        Observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(String blogName,String articleName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer:Observers) &#123;</span><br><span class="line">            observer.update(blogName,articleName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里是发布文章，触发通知事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishArticle</span><span class="params">(String articleName)</span></span>&#123;</span><br><span class="line">        notifyObservers(blogName,articleName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面提到，通知事件肯定是由于某些状态发生变更了，才会进行通知，这里就可以比方为我发布了一篇博客，然后通知你（这里只能假如你关注了）。再来看观察者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.observor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 订阅者抽象接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用此方法会更新状态，做出相应的动作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> blogName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> articleName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String blogName,String articleName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象订阅者，有一个update方法，通知你去做出相应的动作，具体动作每个观察者都可能不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.observor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 这个是具体订阅者,这里可以比喻成博客关注者，</span></span><br><span class="line"><span class="comment"> * 收到变更信息之后需要做出相应的动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String blogName,String articleName)</span> </span>&#123;</span><br><span class="line">        System.out.println(blogName+<span class="string">"发布了新的文章，文章名为："</span>+articleName);</span><br><span class="line">        read(articleName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String articleName)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"即将阅读 "</span>+articleName+<span class="string">" 这篇文章"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是一个具体的关注者，加入说就是你。博客更新之后发了一个通知给你(掘金app推送的消息)，然后你点了一下，这个也是一种动作。例子中举的是read,就是关注者做出阅读的动作。</p>
<p>看下最后的运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glmapper.designmode.observor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: [描述文本]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/4/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMainIndex</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//博客主体</span></span><br><span class="line">        ConcreteSubject subject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        <span class="comment">//关注者：handSome是帅气的意思</span></span><br><span class="line">        Observer handSome = <span class="keyword">new</span> ConcreteObserver();</span><br><span class="line">        <span class="comment">//增加一个关注者</span></span><br><span class="line">        subject.addFocusObserver(handSome);</span><br><span class="line">        <span class="comment">//发一篇文章</span></span><br><span class="line">        subject.publishArticle(<span class="string">"设计模式-观察者模式"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">glmapper发布了新的文章，文章名为：设计模式-观察者模式</span><br><span class="line">即将阅读 设计模式-观察者模式 这篇文章</span><br></pre></td></tr></table></figure>
<p><strong>酒桶说：啊，欢乐时光总是短暂的</strong></p>
<p>所以作为积累，还是需要将一些基本的概念来罗列一下的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/22/162eddecf0e6a860?w=607&amp;h=253&amp;f=jpeg&amp;s=27115" alt="观察者模式类图"></p>
<p><strong>主要角色：</strong></p>
<ul>
<li>抽象主题角色（Subject：主题角色将所有对观察者对象的引用保存在一个集合中，每个主题可以有任意多个观察者。抽象主题提供了增加和删除等观察者对象的接口。</li>
<li>抽象观察者角色（Observer）：为所有的具体观察者定义一个接口，在观察的主题发生改变时更新自己。</li>
<li>具体主题角色（ConcreteSubject）(1个)：存储相关状态到具体观察者对象，当具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个具体子类实现。</li>
<li>具体观察者角色（ConcretedObserver）(多个)：存储一个具体主题对象，存储相关状态，实现抽象观察者角色所要求的更新接口，以使得其自身状态和主题的状态保持一致。</li>
</ul>
<p><strong>具体关系：</strong></p>
<ul>
<li><p>抽象主题（Subject）(接口)–&gt;被具体主题（ConcreteSubject）角色(1个)实现</p>
</li>
<li><p>抽象观察者（Observer）(接口)–&gt;被具体观察者（ConcretedObserver）角色(N个)实现</p>
</li>
<li><p>观察者对象载入主题方法,并在主题方法中调用观察者对象实现的接口方法update来让自己发生变更响应。</p>
</li>
</ul>
<p><strong>一些场景：</strong></p>
<ul>
<li>当对一个对象的的改动会引发其他对象的变动时，而且你无法预测有多少个对象需要被改动。</li>
<li>当一个对象需要有能力通知其他对象，且不需要了解这些对象是什么类型时。</li>
</ul>
<p>基于发布订阅的具体实现例子还是很多的，比较典型的就是这种订阅一个博客，然后博客更新推送；还有微信公众号，服务号这些。</p>
<p>到这里我们再回过头来看一开始留下的几个问题：</p>
<ul>
<li>被观察者的状态发生变更，然后“主动通知”观察者，并不是说，观察者主动去获取通知。</li>
<li>被观察者是消息发布者，观察者是消息订阅者；观察者是被动接受者。</li>
<li>被观察者的作用就是存储当前的观察者列表，然后提供一些通知机制来告诉观察者自己发生了状态变更，是主动者。</li>
</ul>
<p>OK，观察者模式就撸到这里，也欢迎小伙伴们提出自己珍贵的意见；有写的不当之处烦请及时提出。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/java-design-model-obs/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/java-design-model-builder/">菜鸟成长系列-Builder 建造者模式</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T06:00:21.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/java-design-model-builder/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/设计模式/" title="设计模式">设计模式</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p><a href="https://juejin.im/post/59feb9296fb9a0451a75c21e" target="_blank" rel="noopener">菜鸟成长系列-面向对象的四大基础特性</a><br><br><a href="https://juejin.im/post/5a0d60ee6fb9a045272525af" target="_blank" rel="noopener">菜鸟成长系列-多态、接口和抽象类</a><br><br><a href="https://juejin.im/post/5a2bad01518825619a029c0e" target="_blank" rel="noopener">菜鸟成长系列-面向对象的6种设计原则</a><br><br><a href="https://juejin.im/post/5a366d756fb9a045076fc04f" target="_blank" rel="noopener">菜鸟成长系列-单例模式</a><br><a href="https://juejin.im/post/5a3f08335188253aea1f8cb9" target="_blank" rel="noopener">菜鸟成长系列-工厂模式</a></p>
<p><code>建造者模式也是创建型中的一种，用于负责创建对象。建造者模式可以将一个产品的内部表象与产品的生成过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。</code></p>
<h2 id="什么是产品的内部表象？"><a href="#什么是产品的内部表象？" class="headerlink" title="什么是产品的内部表象？"></a>什么是产品的内部表象？</h2><p>一个产品常有不用的组成成分作为产品的零件，这些零件有可能是对象，也有可能不是对象，他们通常又叫做产品的内部表象。不同的产品可以有不同的内部表象，也就是可以有不同的零件。<strong>使用建造者模式可以使客户端不需要知道所生成的产品对象有哪些零件，每个产品的对应零件彼此有何不同，是怎么建造出来的，以及怎样组成产品。</strong></p>
<h2 id="工厂模式与建造者模式"><a href="#工厂模式与建造者模式" class="headerlink" title="工厂模式与建造者模式"></a>工厂模式与建造者模式</h2><p>上一篇我们讨论了工厂模式，我们知道工厂模式一般都是创建一个产品，注重的是把这个产品创建出来就行，只要创建出来，不关心这个产品的组成部分。从代码上看，工厂模式就是一个方法，用这个方法就能生产出产品。那么对于建造者模式呢？<br><strong>建造者模式也是创建一个产品，但是不仅要把这个产品创建出来，还要关系这个产品的组成细节，    组成过程。从代码上看（下面给出），建造者模式在建造产品时，这个产品有很多方法，建造者模式会根据这些相同方法但是不同执行顺序建造出不同组成细节的产品。</strong></p>
<h2 id="建造者模式的结构"><a href="#建造者模式的结构" class="headerlink" title="建造者模式的结构"></a>建造者模式的结构</h2><p><img src="https://user-gold-cdn.xitu.io/2017/12/30/160a55b4d5613629?w=914&amp;h=285&amp;f=png&amp;s=126359" alt=""><br>结构组件角色说明：</p>
<ul>
<li>抽象建造者（Builder）:抽象类， 规范产品的组建，一般是由子类实现具体的组件过程</li>
<li>具体建造者（ConcreteBuilder ）：具体的构建器 </li>
<li>导演者（Director） : 统一组装过程(可省略)</li>
<li>产品（Product）:产品的抽象类</li>
</ul>
<p>Director角色是与客户端打交道的角色。Director将客户端创建产品的请求划分为对各个零件的建造请求，再将这些请求委派给具体的ConcreteBuilder角色。ConcreteBuilder是做具体建造工作的，但是对客户端是透明的。</p>
<p>一般来说，每有一个产品类，就有一个相应的具体建造者类。这些产品应当有一样数目的零件，而每有一个零件就相应的在所有的建造者角色里有一个建造方法。</p>
<h2 id="建造一封邮件"><a href="#建造一封邮件" class="headerlink" title="建造一封邮件"></a>建造一封邮件</h2><p>通过代码来看下各个角色的职责：</p>
<ul>
<li>Director</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.model.builder;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * 导演者类</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @time 2017年12月30日上午11:33:26	</span><br><span class="line"> * @version glmapper_v1.0</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Director &#123;</span><br><span class="line">	private Builder builder;</span><br><span class="line">	/**</span><br><span class="line">	 * 产品构造方法，负责调用各个零件建造方法</span><br><span class="line">	 */</span><br><span class="line">	public EmailProduct construct()&#123;</span><br><span class="line">		builder = new ConcreteBuilder();</span><br><span class="line">		builder.buildFromAddress();</span><br><span class="line">		builder.buildToAddress();</span><br><span class="line">		builder.buildSubject();</span><br><span class="line">		builder.buildContent();</span><br><span class="line">		builder.buildSupplement();</span><br><span class="line">		return builder.returnEmailProduct();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Builder</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.model.builder;</span><br><span class="line">/**</span><br><span class="line"> * 抽象建造者 提供不同的构建组件方法</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @time 2017年12月30日上午11:31:34	</span><br><span class="line"> * @version glmapper_v1.0</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public interface Builder &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 构建发件人信息</span><br><span class="line">	 */</span><br><span class="line">	public void buildFromAddress();</span><br><span class="line">	/**</span><br><span class="line">	 * 构建收件人信息</span><br><span class="line">	 */</span><br><span class="line">	public void buildToAddress();</span><br><span class="line">	/**</span><br><span class="line">	 * 构建邮件内容</span><br><span class="line">	 */</span><br><span class="line">	public void buildContent();</span><br><span class="line">	/**</span><br><span class="line">	 * 构建邮件附件</span><br><span class="line">	 */</span><br><span class="line">	public void buildSupplement();</span><br><span class="line">	/**</span><br><span class="line">	 * 构建邮件主题</span><br><span class="line">	 */</span><br><span class="line">	public void buildSubject();</span><br><span class="line">	/**</span><br><span class="line">	 * 返回构建的产品</span><br><span class="line">	 */</span><br><span class="line">	public EmailProduct returnEmailProduct();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ConcreteBuilder</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.model.builder;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * 具体产品的建造器</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @time 2017年12月30日上午11:31:11	</span><br><span class="line"> * @version glmapper_v1.0</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ConcreteBuilder implements Builder&#123;</span><br><span class="line">	</span><br><span class="line">	private EmailProduct emailProduct = new EmailProduct();</span><br><span class="line">	public void buildFromAddress() &#123;</span><br><span class="line">		emailProduct.setFromAddress(&quot;00001111@glmapper.com&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void buildToAddress() &#123;</span><br><span class="line">		emailProduct.setToAddress(&quot;00001112@glmapper.com&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void buildContent() &#123;</span><br><span class="line">		emailProduct.setContent(&quot;我写了一个建造者模式的例子，希望大佬给点意见&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void buildSupplement() &#123;</span><br><span class="line">		emailProduct.setSupplement(&quot;附件：BuilderDemo.rar&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void buildSubject() &#123;</span><br><span class="line">		emailProduct.setSubject(&quot;给大佬的一封建造者模式的Demo&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public EmailProduct returnEmailProduct() &#123;</span><br><span class="line">		System.out.println(emailProduct.toString());</span><br><span class="line">		return emailProduct;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Product</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.model.builder;</span><br><span class="line">/**</span><br><span class="line"> * 产品类（产品类中包括不同组件：此处使用字段方式模式组件）</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @time 2017年12月30日上午11:30:13	</span><br><span class="line"> * @version glmapper_v1.0</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class EmailProduct &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 发件地址</span><br><span class="line">	 */</span><br><span class="line">	private String fromAddress;</span><br><span class="line">	/**</span><br><span class="line">	 * 收件地址</span><br><span class="line">	 */</span><br><span class="line">	private String toAddress;</span><br><span class="line">	/**</span><br><span class="line">	 * 邮件主题</span><br><span class="line">	 */</span><br><span class="line">	private String subject;</span><br><span class="line">	/**</span><br><span class="line">	 * 邮件内容</span><br><span class="line">	 */</span><br><span class="line">	private String content;</span><br><span class="line">	/**</span><br><span class="line">	 * 邮件附件</span><br><span class="line">	 */</span><br><span class="line">	private String supplement;</span><br><span class="line">	</span><br><span class="line">	public String getFromAddress() &#123;</span><br><span class="line">		return fromAddress;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setFromAddress(String fromAddress) &#123;</span><br><span class="line">		this.fromAddress = fromAddress;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getToAddress() &#123;</span><br><span class="line">		return toAddress;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setToAddress(String toAddress) &#123;</span><br><span class="line">		this.toAddress = toAddress;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getSubject() &#123;</span><br><span class="line">		return subject;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setSubject(String subject) &#123;</span><br><span class="line">		this.subject = subject;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getContent() &#123;</span><br><span class="line">		return content;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setContent(String content) &#123;</span><br><span class="line">		this.content = content;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getSupplement() &#123;</span><br><span class="line">		return supplement;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setSupplement(String supplement) &#123;</span><br><span class="line">		this.supplement = supplement;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;EmailProduct [fromAddress=&quot; + fromAddress + &quot;, toAddress=&quot; + toAddress + &quot;, subject=&quot; + subject</span><br><span class="line">				+ &quot;, content=&quot; + content + &quot;, supplement=&quot; + supplement + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>客户端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.model.builder;</span><br><span class="line">/**</span><br><span class="line"> * 客户端</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @time 2017年12月30日上午11:45:53	</span><br><span class="line"> * @version glmapper_v1.0</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MainTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new Director().construct();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">建造发件人信息组件...</span><br><span class="line">建造收件人信息组件...</span><br><span class="line">建造邮件主题信息组件...</span><br><span class="line">建造邮件内容信息组件...</span><br><span class="line">建造邮件附件信息组件...</span><br><span class="line">（为了方便看，这里把结果的显示做了调整）</span><br><span class="line">EmailProduct ：</span><br><span class="line">[</span><br><span class="line">    fromAddress=00001111@glmapper.com,</span><br><span class="line">    toAddress=00001112@glmapper.com,</span><br><span class="line">    subject=给大佬的一封建造者模式的Demo,</span><br><span class="line">    content=我写了一个建造者模式的例子，希望大佬给点意见,</span><br><span class="line">    supplement=附件：BuilderDemo.rar</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="建造者模式的关注点"><a href="#建造者模式的关注点" class="headerlink" title="建造者模式的关注点"></a>建造者模式的关注点</h2><p>有些情况下，一个对象会有一些重要的性质，在他们没有恰当的值之前，对象不能作为一个完整的产品来使用。就如上面发送一个电子邮件所示，电子邮件有发件人地址、收件人地址、主题、内容、附录等部分，而在收件人地址没有赋值之前，这个电子邮件是不能发送的。在某些情况下，一个对象的一些性质必须按照某个顺序赋值才有意义，在某个性质没有赋值之前，另一个性质则无法赋值。这些情况使得性质本身的建造涉及到复杂的业务逻辑。</p>
<p>而此时，对象相当于一个有待建造的产品，而对象的这些性质相当于产品的零件，建造产品的过程是建造零件的过程。由于建造零件的过程很复杂，因此，这些零件的健在过程往往会被“外部化”到另一个称作为建造者的对象里，建造者对象返回给客户端的是一个全部零件都建造完毕的产品对象。</p>
<p>在实际的应用过程中，建造者模式也有不同的变种，比如说省略抽象建造者角色或者省略导演者角色等等，在某些情况下，建造者模式可以通过省略某些角色来达到过度到模板方法模式。</p>
<p>OK，关于建造者模式的其他变种这里就不讨论了，留一个想象空间！（这段字代表一个微笑的表情(*￣︶￣)）</p>
<h2 id="java中建造者模式：JavaMail"><a href="#java中建造者模式：JavaMail" class="headerlink" title="java中建造者模式：JavaMail"></a>java中建造者模式：JavaMail</h2><p>JavaMail是一组J2SE的扩展API的一个类库，我们可以使用这个API来开发一个功能完备的电子邮件客户端软件。在JavaMail中就主要使用了建造者模式，当然还有我们上一篇中说道的抽象工厂模式。</p>
<h3 id="建造者模式在JavaMail中的使用"><a href="#建造者模式在JavaMail中的使用" class="headerlink" title="建造者模式在JavaMail中的使用"></a>建造者模式在JavaMail中的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.model.builder;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import javax.mail.Message;</span><br><span class="line">import javax.mail.Session;</span><br><span class="line">import javax.mail.Transport;</span><br><span class="line">import javax.mail.internet.InternetAddress;</span><br><span class="line">import javax.mail.internet.MimeMessage;</span><br><span class="line">/**</span><br><span class="line"> * 邮件发送-建造者模式</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @time 2017年12月30日下午2:04:46	</span><br><span class="line"> * @version glmapper_v1.0</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MailSender &#123;</span><br><span class="line">	private static MimeMessage message;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//基本属性</span><br><span class="line">		String smptHost = &quot;smpt.xxx.com&quot;;</span><br><span class="line">		String fromAddress = &quot;00001111@glmapper.com&quot;;</span><br><span class="line">		String toAddress = &quot;00001112@glmapper.com&quot;;</span><br><span class="line">		Properties p= new Properties();</span><br><span class="line">		p.put(&quot;mail.smtp.host&quot;, smptHost);</span><br><span class="line">		Session session = Session.getDefaultInstance(p);</span><br><span class="line">		try &#123;</span><br><span class="line">			InternetAddress to = new InternetAddress(toAddress);</span><br><span class="line">			InternetAddress from = new InternetAddress(fromAddress);</span><br><span class="line">			//创建message对象</span><br><span class="line">			message = new MimeMessage(session);</span><br><span class="line">			//下面就是组装零件的过程</span><br><span class="line">			message.setFrom(from);</span><br><span class="line">			message.setRecipient(Message.RecipientType.TO, to);</span><br><span class="line">			message.setSubject(&quot;hello builder&quot;);</span><br><span class="line">			message.setText(&quot;我写了一个建造者模式的例子，希望大佬给点意见&quot;);</span><br><span class="line">			</span><br><span class="line">			Transport.send(message);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK,建造者模式就到这里了!</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/java-design-model-builder/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/java-design-model-factory/">菜鸟成长系列-工厂模式</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T05:58:07.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/java-design-model-factory/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/设计模式/" title="设计模式">设计模式</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p><a href="https://juejin.im/post/59feb9296fb9a0451a75c21e" target="_blank" rel="noopener">菜鸟成长系列-面向对象的四大基础特性</a><br><br><a href="https://juejin.im/post/5a0d60ee6fb9a045272525af" target="_blank" rel="noopener">菜鸟成长系列-多态、接口和抽象类</a><br><br><a href="https://juejin.im/post/5a2bad01518825619a029c0e" target="_blank" rel="noopener">菜鸟成长系列-面向对象的6种设计原则</a><br><br><a href="https://juejin.im/post/5a366d756fb9a045076fc04f" target="_blank" rel="noopener">菜鸟成长系列-单例模式</a></p>
<p><code>上一篇我们已经对创建型模式中的单例模式进行了学习，今天来学习另外一个比较重要并且经常使用的模式-工厂模式；工厂模式专门负责将大量有共同接口的类实例化。其可以动态的决定将哪一个类实例化，不必事先知道每次要实例化哪一个类。</code></p>
<p>工厂模式具有以下三种形态：</p>
<ul>
<li>简单工厂模式：又称静态工厂模式</li>
<li>工厂方法模式：又称多态性工厂模式或者虚拟构造子模式</li>
<li>抽象工厂模式：又称工具箱模式</li>
</ul>
<p>本篇文章将对这三种形态的工厂模式进行一些基本的学习，并通过例子来直观的感受下不同形态的具体实现方式。最后再分析下JAVA以及Spring中是如何使用的。</p>
<h2 id="1、简单工厂模式"><a href="#1、简单工厂模式" class="headerlink" title="1、简单工厂模式"></a>1、简单工厂模式</h2><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/160864d040dbd467?w=444&amp;h=258&amp;f=png&amp;s=7739" alt=""><br>从上图可以看出，简单工厂模式涉及到工厂角色、抽象产品角色以及具体产品角色等三个角色。各角色职能如下：</p>
<ul>
<li>工厂类：担任这个角色的是工厂方法模式的核心，含有与应用紧密相关的具体业务逻辑。工厂类在客户端的直接调用下创建产品对象，它往往由一个具体的java类实现</li>
<li>抽象产品：担任这个角色的类是工厂方法模式所创建的对象的父类，或它们共同拥有的接口。抽象产品角色可以用一个java接口或者抽象类来实现</li>
<li>具体产品：工厂方法模式所创建的任何对象都是这个角色的实例，具体产品角色由一个java类实现</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/24/160873bd0f72bce6?w=637&amp;h=247&amp;f=png&amp;s=61193" alt=""><br>来看例子，考虑到今天有小伙伴来我这做客，本demo将以做菜来实现一波。首先工厂就是厨房，抽象类就是笼统的菜，实现类就是具体哪个菜。</p>
<ul>
<li><p>抽象产品</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.factory;</span><br><span class="line">/**</span><br><span class="line"> * 抽象类角色：food接口，约束类型</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月24日上午10:38:36</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public interface IFood &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 提供一个展示食物细节的方法</span><br><span class="line">	 * @param foodName 食物名称</span><br><span class="line">	 */</span><br><span class="line">	public void showFood();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体产品-鱼</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.factory;</span><br><span class="line">/**</span><br><span class="line"> * 具体产品-食物鱼</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月24日上午10:51:29</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class FishFood implements IFood</span><br><span class="line">&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void showFood() &#123;</span><br><span class="line">		System.out.println(&quot;一盘鱼&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>具体产品-土豆丝</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.factory;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * 具体食物：土豆丝</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月24日上午10:47:17</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ShreddedPotatoesFood implements IFood&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void showFood() &#123;</span><br><span class="line">		System.out.println(&quot;一盘土豆丝&quot;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>工厂角色 - 食物工厂</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.factory;</span><br><span class="line">/**</span><br><span class="line"> * 工厂角色-食物工厂</span><br><span class="line"> * </span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月24日上午10:41:10</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SimpleFoodFactory &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 提供一个静态方法，用于获取食物</span><br><span class="line">	 * @param foodType 食物类型</span><br><span class="line">	 * @return 具体食物</span><br><span class="line">	 */</span><br><span class="line">	public static IFood getFood(String foodType)&#123;</span><br><span class="line">		IFood food = null;</span><br><span class="line">		if (foodType.equals(&quot;fish&quot;)) &#123;</span><br><span class="line">			food = new FishFood();</span><br><span class="line">		&#125;</span><br><span class="line">		if (foodType.equals(&quot;potatoes&quot;)) &#123;</span><br><span class="line">			food = new ShreddedPotatoesFood();</span><br><span class="line">		&#125;</span><br><span class="line">		return food;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>客户端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.factory;</span><br><span class="line">/**</span><br><span class="line"> * 客户端</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月24日上午10:45:17</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MainTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		IFood fishfood = SimpleFoodFactory.getFood(&quot;fish&quot;);</span><br><span class="line">		fishfood.showFood();</span><br><span class="line">		</span><br><span class="line">		IFood potatoesfood = SimpleFoodFactory.getFood(&quot;potatoes&quot;);</span><br><span class="line">		potatoesfood.showFood();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一盘鱼</span><br><span class="line">一盘土豆丝</span><br></pre></td></tr></table></figure>
<p>OK，菜做完了，可以吃了。。。</p>
<p>我们来讨论下简单工厂模式的优缺点：</p>
<p><code>优点：模式的核心是工厂类，这个类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例。而客户端则可以免除直接创建产品对象的责任，而仅仅负责消费产品即可。用一句话来说就是：简单工厂模式这个做法实现了对责任的分割。</code><br><br><code>缺点：集中了所有产品的创建逻辑，形成了一个无所不能的全职类，但是之前我们在讨论设计原则的时候说过，我们要尽量避免这种情况的发生，这种就很明显破坏了单一职责这条原则，另外也不满足开闭原则的约束。当我们需要进行品类扩展时，我们需要不断的去修改我们的工厂的业务逻辑，一方面是工厂类会急速的膨胀，另一方面因为囊括了不同的产品对于我们后期的维护造成一定的影响。</code></p>
<h2 id="2、工厂方法模式"><a href="#2、工厂方法模式" class="headerlink" title="2、工厂方法模式"></a>2、工厂方法模式</h2><p>这个时候一个同事说他是南方人，另外一个同事说他是北方人，吃不惯今天的菜。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/24/160873c493ae7259?w=400&amp;h=292&amp;f=jpeg&amp;s=16450" alt=""><br>好吧，既然这样，那我就只能点外卖了。。。但是为了防止他们变卦自己的家乡，我需要做一个计划，下面就是计划图：<br><img src="https://user-gold-cdn.xitu.io/2017/12/24/1608709a15936dea?w=626&amp;h=366&amp;f=png&amp;s=16564" alt=""></p>
<p>从上图中我们可以看出，工厂方法模式的角色包括以下几种：</p>
<ul>
<li>抽象工厂：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。</li>
<li>具体工厂：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建产品对象。</li>
<li>抽象产品：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口</li>
<li>具体产品：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应。</li>
</ul>
<p>因为我的同事都是来自不同地方的，他们的口味也都不一样，但是呢同事都是第一次来我家吃饭，所以为了招待周全，根据同事不同的口味叫不同口味的鱼。</p>
<ul>
<li><p>抽象工厂角色：获取食物</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.factory;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * 角色1：抽象工厂 - 负责获取食物</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月24日下午1:59:28</span><br><span class="line"> */</span><br><span class="line">public interface MethodFoodFactory &#123;</span><br><span class="line">	//获取食物的方法</span><br><span class="line">	public IFishFood getFood();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体工厂1：获取南方食物-鱼</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.factory;</span><br><span class="line">/**</span><br><span class="line"> * 南方口味外卖 - 鱼</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月24日下午2:03:36</span><br><span class="line"> */</span><br><span class="line">public class SouthFishFactory implements MethodFoodFactory&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public IFishFood getFood() &#123;</span><br><span class="line">		return new SouthFishFood();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>具体工厂2：获取北方食物-鱼</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.factory;</span><br><span class="line">/**</span><br><span class="line"> * 北方口味外卖 - 鱼</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月24日下午2:03:36</span><br><span class="line"> */</span><br><span class="line">public class NorthFishFactory implements MethodFoodFactory&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public IFishFood getFood() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return new NorthFishFood();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>具体产品1：南方食物- 鱼</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.factory;</span><br><span class="line">/**</span><br><span class="line"> * 南方口味-鱼</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月24日下午2:16:17</span><br><span class="line"> */</span><br><span class="line">public class SouthFishFood implements IFishFood&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void showFood() &#123;</span><br><span class="line">		System.out.println(&quot;来自南方厨师做的鱼&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>具体产品2：北方食物-鱼</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.factory;</span><br><span class="line">/**</span><br><span class="line"> * 北方口味  - 鱼</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月24日下午2:12:55</span><br><span class="line"> */</span><br><span class="line">public class NorthFishFood implements IFishFood &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void showFood() &#123;</span><br><span class="line">		System.out.println(&quot;来自北方厨师做的鱼&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>客户端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.factory;</span><br><span class="line">/**</span><br><span class="line"> * 客户端</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月24日上午10:45:17</span><br><span class="line"> */</span><br><span class="line">public class MainTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//点一个南方口味外卖</span><br><span class="line">		MethodFoodFactory southFoodFactory = new SouthFishFactory();</span><br><span class="line">		//点一个北方口味外卖</span><br><span class="line">		MethodFoodFactory northFoodFactory = new NorthFishFactory();</span><br><span class="line">		//拿到南方口味外卖鱼</span><br><span class="line">		southFoodFactory.getFood().showFood();</span><br><span class="line">		//拿到北方口味外卖鱼</span><br><span class="line">		northFoodFactory.getFood().showFood();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">来自南方厨师做的鱼</span><br><span class="line">来自北方厨师做的鱼</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>OK，这样我们就满足了不同区域同时关于鱼口味的需求了，以后升值加薪就指望他们了。。。</p>
<p>关于工厂方法模式的优缺点：</p>
<p><code>优点：</code><br><br><code>1、  在工厂方法中，用户只需要知道所要产品的具体工厂，无须关系具体的创建过程，甚至不需要具体产品类的类名。</code><br><br><code>2、  在系统增加新的产品时，我们只需要添加一个具体产品类和对应的实现工厂，无需对原工厂进行任何修改，很好地符合了“开闭原则”</code><br><br><code>缺点：</code><br><br><code>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，是的系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</code></p>
<h2 id="3、抽象工厂模式"><a href="#3、抽象工厂模式" class="headerlink" title="3、抽象工厂模式"></a>3、抽象工厂模式</h2><p>准备吃饭的时候突然又来了几位同事，而且他们有的喜欢吃酸菜鱼，有的喜欢吃红烧鱼，这就很头疼。于是，只能根据他们的需要继续点外卖。（这个就给出一个结构图，并且将每种角色都用具体的场景来说明了，具体的代码可以参考这个图例自己尝试一下。）</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/24/1608737380bd3c2f?w=781&amp;h=491&amp;f=png&amp;s=29480" alt=""><br>OK，终于可以吃饭了！</p>
<h2 id="4、三种形态的工厂模式在java中的使用"><a href="#4、三种形态的工厂模式在java中的使用" class="headerlink" title="4、三种形态的工厂模式在java中的使用"></a>4、三种形态的工厂模式在java中的使用</h2><h3 id="4-1、简单工厂模式在java中的使用"><a href="#4-1、简单工厂模式在java中的使用" class="headerlink" title="4.1、简单工厂模式在java中的使用"></a>4.1、简单工厂模式在java中的使用</h3><p>java.text.DateFormat （一个抽象类）这个类相信很多小伙伴都用到过，在java API中，这个类算是一个简单工厂模式的典型应用了（此处还是与上篇一样，不考虑期源码细节，也不介绍基本用法）。来看它的几个方法：</p>
<ul>
<li>public final static DateFormat getDateInstance()</li>
<li>public final static DateFormat getDateInstance(int style)</li>
<li>public final static DateFormat getDateInstance(int style, Locale aLocale)</li>
</ul>
<p>作为一个抽象类，却提供了很多的静态工厂方法，就像上面列举的那三个一样。有小伙伴可能会疑惑，为啥子一个抽象类阔以有自己的实例，并通过几个方法提供自己的实例。我们知道，抽象类是不可以有自己的实例对象的，但是需要注意的是，DateFormat的工厂方法是静态的，并不是普通的方法，也就是说，不需要通过创建实例对象的方式去调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final static DateFormat getDateInstance()</span><br><span class="line">&#123;</span><br><span class="line">    return get(0, DEFAULT, 2, Locale.getDefault(Locale.Category.FORMAT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getDateInstance方法并没有通过调用DateFormat的构造方法来创建对象。</p>
<h3 id="4-2、工厂方法模式在java中的应用"><a href="#4-2、工厂方法模式在java中的应用" class="headerlink" title="4.2、工厂方法模式在java中的应用"></a>4.2、工厂方法模式在java中的应用</h3><p>java.net.URL类，类图如下，<br><img src="https://user-gold-cdn.xitu.io/2017/12/24/16087550e7bff0c2?w=701&amp;h=346&amp;f=png&amp;s=44805" alt=""><br>URL对象通过一个工厂方法openConnection()返回一个URLConnection类型的对象。URLConnection是一个抽象类，因此所返还的不可能是这个抽象类的实例，而必然是其具体子类的实例。</p>
<h3 id="4-3、抽象工厂模式在java中的应用"><a href="#4-3、抽象工厂模式在java中的应用" class="headerlink" title="4.3、抽象工厂模式在java中的应用"></a>4.3、抽象工厂模式在java中的应用</h3><p>根据java与模式一书的介绍，在java中使用抽象工厂模式的是 JAVA awt的peer架构，通过抽象工厂模式来构建分属于不同操作系统的peer构件。这个我也没用过，了解即可。</p>
<p>关于Spring中工厂模式的使用会在后续Spring源码分析系列中给大家详细分析，这里就不重复了。</p>
<p>今天的学习就到此结束了，祝大家周末愉快。话说今天平安夜，大家都是在家写代码吗？</p>
<p><code>如果您对系列文章有任何意见，可以给我留言，感谢大家。</code></p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/java-design-model-factory/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/java-design-model-singleton/">菜鸟成长系列-单例模式</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T05:57:08.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/java-design-model-singleton/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/设计模式/" title="设计模式">设计模式</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p><a href="https://juejin.im/post/59feb9296fb9a0451a75c21e" target="_blank" rel="noopener">菜鸟成长系列-面向对象的四大基础特性</a><br><br><a href="https://juejin.im/post/5a0d60ee6fb9a045272525af" target="_blank" rel="noopener">菜鸟成长系列-多态、接口和抽象类</a><br><br><a href="https://juejin.im/post/5a2bad01518825619a029c0e" target="_blank" rel="noopener">菜鸟成长系列-面向对象的6种设计原则</a><br></p>
<p><code>前面已经将设计模式中的基本内容撸了一下，今天开始正式开始设计模式系列的内容，因为网上也有很多关于设计模式的技术博客，从不同的角度对设计模式都做了很详细的解读；本系列的模式除了基本的概念和模型之外，还会结合java自身使用的和Spring中使用的一些案例来进行学习分析。</code><br><br><code>水平有限，如果存在不当之处，希望大家多提意见，灰常感谢！</code><br><br>设计模式中总体分为三类:<br><br><strong>一、创建型(5)：</strong></p>
<ul>
<li>工厂方法[Factory Method]</li>
<li>抽象工厂[Abstract Factory]</li>
<li>原型[Prototype]</li>
<li>建造者[Builder]</li>
<li><a href="https://juejin.im/editor/drafts/5a366d756fb9a045076fc04f" target="_blank" rel="noopener">单例[Singleton]</a></li>
</ul>
<p>还有一个简单工厂[Simple  Factory]，目前有两种，有的把单例模式作为这5种之一，有的是将简单工厂作为这5种之一。这里不做讨论，原则上两个都是，只是划分规则不同。</p>
<p><strong>二、结构型(7)</strong></p>
<ul>
<li>适配器[Adapter]</li>
<li>桥接[Bridge]</li>
<li>组合[Composite]</li>
<li>装饰[Decorator]</li>
<li>外观[Facade]</li>
<li>享元[Flyweight]</li>
<li>代理[Proxy]</li>
</ul>
<p><strong>三、行为型(11)</strong></p>
<ul>
<li>策略[Strategy]</li>
<li>模板方法[Template method]</li>
<li>职责链[Chain of Responsibility]</li>
<li>迭代器[Iterator]</li>
<li>状态[State]</li>
<li>访问者[Visitor]</li>
<li>命令[Command]</li>
<li>备忘录[Memento]</li>
<li>观察者[Observer]</li>
<li>中介者[Mediator]</li>
<li>解释器[Interpreter]</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><code>首先它是一种创建型模式，与其他模式区别在于：单例模式确保被创建的类只有一个实例对象，而且自行实例化并向整个系统提供这个实例。一般情况下我们称当前这个类为单例类。</code></p>
<p>从上面这段话中我们可以了解到，单例模式具备以下三个要点：</p>
<ul>
<li>某个类只能有一个实例</li>
<li>必须自行创建这个实例[具体的对象创建由类本身负责，其他类不负责当前类的创建]</li>
<li>必须向整个系统提供这个实例[也就是说，当前类需要对外提供一个获取当前实例的一个方法，且该方法不能是私有的]</li>
</ul>
<p>OK，来看单例模式的几种实现方式。</p>
<p><strong>方式一：饿汉式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.singleton;</span><br><span class="line">/**</span><br><span class="line"> * 单例模式-饿汉式</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月17日下午10:30:38</span><br><span class="line"> */</span><br><span class="line">public class EagerSingleton &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 内部直接提供一个eagerSingletonInstance；</span><br><span class="line">	 * 我们知道，一般情况下，如果一个变量被static final修饰了，那么该变量将会被视为常量。</span><br><span class="line">	 * 满足要点：自行创建</span><br><span class="line">	 */</span><br><span class="line">	private static final EagerSingleton eagerSingletonInstance = new EagerSingleton();</span><br><span class="line">	/**</span><br><span class="line">	 * 提供一个私有的构造函数，这样其他类就无法通过new</span><br><span class="line">	 * EagerSingleton()来获取对象了，同样也保证了当前类不可以被继承</span><br><span class="line">	 * 满足要点：某个类只能有一个实例</span><br><span class="line">	 */</span><br><span class="line">	private EagerSingleton()&#123;&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 对外提供一个获取实例的方法</span><br><span class="line">	 * 满足要点：向整个系统提供这个实例</span><br><span class="line">	 */</span><br><span class="line">	public static EagerSingleton getInstance()&#123;</span><br><span class="line">		return eagerSingletonInstance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>方式二：懒汉式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.singleton;</span><br><span class="line">/**</span><br><span class="line"> * 单例模式-懒汉式</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月17日下午10:45:54</span><br><span class="line"> */</span><br><span class="line">public class LazySingleton &#123;</span><br><span class="line">	//提供一个私有静态变量，注意区别与饿汉式中的static final。</span><br><span class="line">	private static LazySingleton lazySingletonInstance = null ;</span><br><span class="line">	//同样需要提供一个私有的构造方法，其作用与饿汉式中的作用一样</span><br><span class="line">	private LazySingleton()&#123;&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 1.使用synchronized来保证线程同步</span><br><span class="line">	 * 2.实例的具体创建被延迟到第一次调用getInstance方法时来进行</span><br><span class="line">	 * 3.如果当前实例已经存在，不再重复创建</span><br><span class="line">	 */</span><br><span class="line">	public synchronized static LazySingleton getInstance()&#123;</span><br><span class="line">		if (lazySingletonInstance == null) &#123;</span><br><span class="line">			lazySingletonInstance = new LazySingleton();</span><br><span class="line">		&#125;</span><br><span class="line">		return lazySingletonInstance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>饿汉式单例类在自己被加载时就自己实例化了，即便加载器是静态的，在饿汉式单例类被加载时仍会将自己实例化。从资源利用角度来说，这个比懒汉式单例类稍微的差一些。如果从速度和响应时间来看，饿汉式就会比懒汉式好一些。懒汉式在单例类进行实例化时，必须处理好在多个线程同时首次引用此类时的访问限制问题。</p>
<p><strong>方式三：登记式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.singleton;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">/**</span><br><span class="line"> * 单例模式-登记式</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月17日下午10:58:36</span><br><span class="line"> */</span><br><span class="line">public class RegisterSingleton &#123;</span><br><span class="line">	//提供一个私有的HashMap类型的registerSingletonInstance存储该RegisterSingleton类型的单例</span><br><span class="line">	private static HashMap&lt;String,Object&gt; registerSingletonInstance = new HashMap&lt;&gt;();</span><br><span class="line">	//通过static静态代码块来进行初始化RegisterSingleton当前类的实例，并将当前实例存入registerSingletonInstance</span><br><span class="line">	static &#123;</span><br><span class="line">		RegisterSingleton singleton = new RegisterSingleton();</span><br><span class="line">		registerSingletonInstance.put(singleton.getClass().getName(), singleton);</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 注意区别，此处提供的是非private类型的，说明当前类可以被继承</span><br><span class="line">	 */</span><br><span class="line">	protected RegisterSingleton()&#123;&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 获取实例的方法</span><br><span class="line">	 */</span><br><span class="line">	public static RegisterSingleton getInstance(String name)&#123;</span><br><span class="line">		//如果name为空，则那么默认为当前类的全限定名</span><br><span class="line">		if (name == null) &#123;</span><br><span class="line">			name =&quot;com.glmapper.design.singleton.RegisterSingleton&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		//如果map中没有查询到指定的单例，则将通过Class.forName(name)来创建一个实例对象，并存入map中</span><br><span class="line">		if (registerSingletonInstance.get(name)==null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				registerSingletonInstance.put(name, Class.forName(name).newInstance());</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//返回实例</span><br><span class="line">		return (RegisterSingleton) registerSingletonInstance.get(name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>登记式单例是Gof为了克服饿汉式和懒汉式单例类均不可被继承的缺点而设计的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.singleton;</span><br><span class="line">/**</span><br><span class="line"> * 登记式-单例-子类</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月17日下午11:14:03</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ChildRegisterSingleton extends RegisterSingleton</span><br><span class="line">&#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 由于子类必须允许父类以构造方法调用产生实例，因此，子类的构造方法必须</span><br><span class="line">	 * 是public类型的。但是这样一来，就等于说可以允许以new </span><br><span class="line">	 * ChildRegisterSingleton()的方式产生实例，而不必在父类的登记中。</span><br><span class="line">	 */</span><br><span class="line">	public ChildRegisterSingleton()&#123;&#125;	</span><br><span class="line">	</span><br><span class="line">	//客户端测试获取实例</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		ChildRegisterSingleton crs1 = (ChildRegisterSingleton) getInstance(</span><br><span class="line">				&quot;com.glmapper.design.singleton.ChildRegisterSingleton&quot;);</span><br><span class="line">		ChildRegisterSingleton crs2 = (ChildRegisterSingleton) getInstance(</span><br><span class="line">				&quot;com.glmapper.design.singleton.ChildRegisterSingleton&quot;);</span><br><span class="line">		System.out.println(crs1 == crs2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">返回：true   这个同志们可以自行验证，肯定是一样的。但是不能使用new，</span><br><span class="line">因为前提约束是，需在父类中登记的才是单例。</span><br></pre></td></tr></table></figure>
<p>方式四：双重检测模式，双重检测方式在某些书上或者文献中说对于java语言来说是不成立的，但是目前确实是通过某种技巧完成了在java中使用双重检测机制的单例模式的实现，；这种技巧后面来说；<code>关于为什么java语言对于双重检测成例不成立，大家可以在[BLOCH01]文献中看下具体情况。</code><br><br>先来看一个单线程模式下的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.singleton;</span><br><span class="line">/**</span><br><span class="line"> * 一个错误的单例例子</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月17日下午11:53:04</span><br><span class="line"> */</span><br><span class="line">public class DoubleCheckSingleton &#123;</span><br><span class="line">	private static DoubleCheckSingleton instance=null;</span><br><span class="line">	public static DoubleCheckSingleton getDoubleCheckSingleton()&#123;</span><br><span class="line">		if (instance == null) &#123;</span><br><span class="line">			instance = new DoubleCheckSingleton();</span><br><span class="line">		&#125;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个很明显是一个错误的例子，对于A/B两个线程，因为step 1并没有使用同步策略，因此线程A/B可能会同时进行// step 2，这样的话，就会可能创建两个对象。那么正确的方式如下：使用synchronized关键字来保证同步。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.singleton;</span><br><span class="line">/**</span><br><span class="line"> * 这是一个正确的打开方式哦。。。</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月17日下午11:53:04</span><br><span class="line"> */</span><br><span class="line">public class DoubleCheckSingleton &#123;</span><br><span class="line">	private static DoubleCheckSingleton instance=null;</span><br><span class="line">	//使用synchronized来保证getDoubleCheckSingleton同一时刻只能被一个线程访问</span><br><span class="line">	public synchronized static DoubleCheckSingleton getDoubleCheckSingleton()&#123;</span><br><span class="line">		if (instance == null) &#123;</span><br><span class="line">			instance = new DoubleCheckSingleton();</span><br><span class="line">		&#125;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式虽然保证了线程安全性，但是也存在另外一种问题：同步化操作仅仅在instance首次初始化操作之前会起到作用，如果instance已经完成了初始化，对于getDoubleCheckSingleton每一次调用来说都会阻塞其他线程，造成一个不必要的瓶颈。那我们就通过使用更加细粒度化的锁，来适当的减小额外的开销。OK，下面再来一个错误的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.design.singleton;</span><br><span class="line">/**</span><br><span class="line"> * 一个错误的单例例子</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月17日下午11:53:04</span><br><span class="line"> */</span><br><span class="line">public class DoubleCheckSingleton &#123;</span><br><span class="line">	private static DoubleCheckSingleton instance=null;</span><br><span class="line">	//使用synchronized来保证getDoubleCheckSingleton同一时刻只能被一个线程访问</span><br><span class="line">	public static DoubleCheckSingleton getDoubleCheckSingleton()&#123;</span><br><span class="line">		if (instance == null) &#123;  //1</span><br><span class="line">		    // B线程检测到uniqueInstance不为空</span><br><span class="line">			synchronized (DoubleCheckSingleton.class) &#123; //2</span><br><span class="line">				if (instance == null) &#123; //3</span><br><span class="line">					instance = new DoubleCheckSingleton();//4</span><br><span class="line">					// A线程被指令重排了，刚好先赋值了；但还没执行完构造函数。</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// 后面B线程执行时将引发：对象尚未初始化错误。</span><br><span class="line">		return instance;//5</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来没什么毛病呀？我们来分析，两个线程A和B，同时到达1,且都通过了1的检测。此时A到了4，B在2。此时B线程检测到instance不为空，A线程被指令重排了，刚好先赋值了；但还没执行完构造函数；再接下来B线程执行时将引发：对象尚未初始化错误（5）。</p>
<p>对于上面的问题，我们可以通过volatile关键字来修饰instance对象，来保证instance对象的内存可见性和防止指令重排序。这个也就是前面说到的“技巧”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static DoubleCheckSingleton instance=null;</span><br><span class="line">改为：</span><br><span class="line">private static volatile DoubleCheckSingleton instance=null;</span><br></pre></td></tr></table></figure>
<p>本篇将单例模式的几种情况进行了分析。后面将会对将java中和Spring中所使用的单例场景进行具体的案例分析。</p>
<h2 id="JAVA中的单例模式使用"><a href="#JAVA中的单例模式使用" class="headerlink" title="JAVA中的单例模式使用"></a>JAVA中的单例模式使用</h2><p>JAVA中对于单例模式的使用最经典的就是RunTime这个类。<br><img src="https://user-gold-cdn.xitu.io/2017/12/23/160822319952bbf9?w=585&amp;h=219&amp;f=png&amp;s=94731" alt=""><br><img src="https://user-gold-cdn.xitu.io/2017/12/23/16082235b1827b2c?w=653&amp;h=316&amp;f=png&amp;s=138718" alt=""><br>注释解读：每个Java应用程序都有一个Runtime类的单个实例，允许应用程序与运行应用程序的环境进行交互。 当前运行时可以从getRuntime方法获得。应用程序不能创建它自己的这个类的实例。</p>
<p>看过上篇文章的小伙伴可能比较清楚，这里RunTime使用的是懒汉式单例的方式来创建的。Runtime提供了一个静态工厂方法getRuntime方法用于获取Runtime实例。Runtime这个类的具体源码分析和只能此处不做分析。</p>
<h2 id="Spring中的单例"><a href="#Spring中的单例" class="headerlink" title="Spring中的单例"></a>Spring中的单例</h2><p>Spring依赖注入Bean实例默认是单例的。Spring中bean的依赖注入都是依赖AbstractBeanFactory的getBean方法来完成的。那我们就来看看在getBean中都发生了什么。</p>
<p><strong>org.springframework.beans.factory.suppor.AbstractBeanFactory</strong><br><img src="https://user-gold-cdn.xitu.io/2017/12/23/1608240b1b8b27b1?w=794&amp;h=500&amp;f=png&amp;s=266167" alt=""><br>从上面这张图中我们啥也看不出，只知道在getBean中又调用了doGetBean方法（Spring中还有java源码中有很多类似的写法，好处在于我们可以通过子类继承，继而编写我们自己的处理逻辑）。OK，再来看看doGetBean方法。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/23/16082466281582ea?w=813&amp;h=270&amp;f=png&amp;s=162783" alt=""><br>来看下这个方法的注释：<strong>返回指定的bean可以共享或独立的实例</strong> （谷歌+有道+百度）</p>
<ul>
<li>name:要检索的bean的名称</li>
<li>requiredType:要检索的bean所需的类型</li>
<li>args:如果使用静态工厂方法的显式参数创建原型，则使用参数。 在其他情况下使用非空args值是无效的。</li>
<li>typeCheckOnly:获得实例是否是为了类型检查，而不是实际的使用</li>
</ul>
<p>这个方法体内的代码非常的多，那么我们本文不是来学习Spring的，所以我们只看我们关心的部分，<br><img src="https://user-gold-cdn.xitu.io/2017/12/23/160824f12ec92598?w=571&amp;h=39&amp;f=png&amp;s=4554" alt=""><br><strong>为手工注册的singleton检查单例缓存。</strong>,从这个注释可以看出，此处就是我们获取实例的地方，再往下看。</p>
<p>此处和上面的getBean一样，也是通过模板方法的方式进行调用的。<br><img src="https://user-gold-cdn.xitu.io/2017/12/23/1608251887dbdedd?w=496&amp;h=72&amp;f=png&amp;s=26281" alt=""><br>OK，这里我们看到了获取单例实例的具体实现过程。<br><strong>返回注册在给定名称下的(原始的)singleton对象。检查已经实例化的单例，并且还允许提前引用当前创建的单例（解析循环引用）。</strong><br><img src="https://user-gold-cdn.xitu.io/2017/12/23/1608251b22075527?w=748&amp;h=451&amp;f=png&amp;s=254552" alt=""><br>这里使用的是饿汉式中的双重检测机制来实现的。</p>
<p>OK，至此单例模式的学习就结束了，下一篇文章将会介绍工厂模式（简单工厂，工厂方法，抽象工厂）。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/java-design-model-singleton/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
    </div>
    
      <div id="page-nav" class="pagination">
	<span class="page-number current">1</span>
      </div>
    
  </section>

</div>

</div>

</section>
</div>


    <!-- BEGIN PRE-FOOTER -->
    <div class="pre-footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN BOTTOM ABOUT BLOCK -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>About Us</h2>
            <p>Computer Lab is a software development and marketing company based in Brooklyn, New York. <br><br> Computer Lab was founded in 2015, and is focused on so on and so forth.</p>
          </div>
          <!-- END BOTTOM ABOUT BLOCK -->

          <!-- BEGIN BOTTOM CONTACTS -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>Contact</h2>
            <address class="margin-bottom-40">
              140 Metropolitan Avenue<br>
              5th Floor<br>
              Brooklyn, NY 11249<br>
              Phone: 716-472-4484<br>
              Email: <a href="mailto:ptsteadman@gmail.com">ptsteadman@gmail.com</a><br>
            </address>
          </div>
          <!-- END BOTTOM CONTACTS -->

	
          <!-- BEGIN TWITTER BLOCK --> 
          <div class="col-md-4 col-sm-6 pre-footer-col">

	  <a data-tweet-limit="1" class="twitter-timeline" href="https://twitter.com/computerlab_" data-widget-id="678830341331820544">Tweets by @computerlab_</a>

	  <script>!function(d,s,id){var
	  js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

          </div>
          <!-- END TWITTER BLOCK -->
	
        </div>
      </div>
    </div>
    <!-- END PRE-FOOTER -->

    <!-- BEGIN FOOTER -->
    <div class="footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN COPYRIGHT -->
          <div class="col-md-6 col-sm-6 padding-top-10">
                  &copy; 2020 glmapper<br>
 <a href="javascript:;">Privacy Policy</a> | <a href="javascript:;">Terms of Service</a>
          </div>
          <!-- END COPYRIGHT -->
	  <!-- BEGIN SOCIAL -->
<div class="col-md-6 col-sm-6">
  <ul class="social-footer list-unstyled list-inline pull-right">
    
      <li><a href="https://github.com/ptsteadman"><i class="fa fa-github"></i></a></li>
    
      <li><a href="https://twitter.com/ptsteadman"><i class="fa fa-twitter"></i></a></li>
    
      <li><a href="https://www.facebook.com/ptsteadman"><i class="fa fa-facebook"></i></a></li>
    
      <li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li>
    
      <li><a href="https://linkedin.com/in/ptsteadman"><i class="fa fa-linkedin"></i></a></li>
    
      <li><a href="http://stackoverflow.com/users/2480493/patrick-steadman"><i class="fa fa-stackoverflow"></i></a></li>
    
  </ul>  
</div>
<!-- END SOCIAL -->

        </div>
      </div>
    </div>
    <!-- END FOOTER -->

  <!-- BEGIN CORE PLUGINS (REQUIRED FOR ALL PAGES) -->
<!--[if lt IE 9]>
<script src="/metronic/assets/plugins/respond.min.js"></script>
<![endif]--> 
<script src="/metronic/assets/plugins/jquery.min.js"></script>
<script src="/metronic/assets/plugins/jquery-migrate.min.js"></script>
<script src="/metronic/assets/plugins/bootstrap/js/bootstrap.min.js"></script>
<script src="/metronic/assets/corporate/scripts/back-to-top.js"></script>
<script src="/metronic/assets/plugins/owl.carousel/owl.carousel.min.js"></script>
<script src="/metronic/assets/corporate/scripts/layout.js"></script>
<script src="/js/wow.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script type="text/javascript">
    jQuery(document).ready(function() {
        Layout.init();    
        Layout.initOWL();
        Layout.initTwitter();
        Layout.initFixHeaderWithPreHeader(); /* Switch On Header Fixing (only if you have pre-header) */
        Layout.initNavScrolling(); 
	new WOW().init();
    });
</script>
<!-- END CORE PLUGINS -->

<!-- BEGIN PAGE-SPECIFIC PLUGINS --> 







<!-- END PAGE-SPECIFIC PLUGINS --> 

<!-- BEGIN INTEGRATIONS -->





<!-- END INTEGRATIONS -->

</body>
</html>
