<!DOCTYPE html>
<!--[if IE 8]> <html lang="en" class="ie8 no-js"> <![endif]-->
<!--[if IE 9]> <html lang="en" class="ie9 no-js"> <![endif]-->
<!--[if !IE]><!-->
<html lang="en">
<!--<![endif]-->
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Tag: java | glmapper</title>

  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <meta name="description" content="从平凡的世界中全身而退">
<meta property="og:type" content="website">
<meta property="og:title" content="glmapper">
<meta property="og:url" content="http://www.glmapper.com/tags/java/index.html">
<meta property="og:site_name" content="glmapper">
<meta property="og:description" content="从平凡的世界中全身而退">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="glmapper">
<meta name="twitter:description" content="从平凡的世界中全身而退">
  
    <link rel="alternative" href="/atom.xml" title="glmapper" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
    
  <meta content="{{ title }}" name="description">
  <meta content="{{ title }}" name="keywords">
  <meta content="{{ title }}" name="author">

  <link href="http://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700|PT+Sans+Narrow|Source+Sans+Pro:200,300,400,600,700,900&amp;subset=all" rel="stylesheet" type="text/css">

  <!-- Global styles START -->   
  <link rel="stylesheet" href="/metronic/assets/plugins/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/bootstrap/css/bootstrap.min.css">
  <!-- Global styles END --> 
   
  <!-- Page level plugin styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/animate.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/owl.carousel/assets/owl.carousel.css">
  <!-- Page level plugin styles END -->

  <!-- Theme styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/components.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/slider.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/portfolio.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style-responsive.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/themes/red.css">
  <link rel="stylesheet" href="/css/theme-styles.css">
  <!-- Theme styles END -->
</head>
</html>
<body class="corporate">
  <!-- BEGIN TOP BAR -->
<div class="pre-header">
  <div class="container">
    <div class="row">
      <!-- BEGIN TOP BAR LEFT PART -->
      <div class="col-md-6 col-sm-6 col-xs-9 additional-shop-info">
	<ul class="list-unstyled list-inline">
	  <li><i class="fa fa-phone"></i><span>716-472-4484</span></li>
	  <li><i class="fa fa-envelope-o"></i><span>ptsteadman@gmail.com</span></li>
	</ul>
      </div>
      <!-- END TOP BAR LEFT PART -->
      <!-- BEGIN TOP BAR MENU -->
      <div class="col-md-6 col-sm-6 col-xs-3 additional-nav">
	<ul class="list-unstyled list-inline pull-right">
	  <li><a href="/login">Log In</a></li>
	</ul>
      </div>
      <!-- END TOP BAR MENU -->
    </div>
  </div>        
</div>
<!-- END TOP BAR -->
<!-- BEGIN HEADER -->
<div class="header">
  <div class="container">
    <!--<a class="site-logo" href="/" id="logo">glmapper</a>-->

    <a class="site-logo" href="/">
      <img src="/metronic/assets/corporate/img/logos/logo-corp-red.png" alt="Metronic FrontEnd">
    </a>

    <a href="javascript:void(0);" class="mobi-toggler"><i class="fa fa-bars"></i></a>

    <!-- BEGIN NAVIGATION -->
    <div class="header-navigation pull-right font-transform-inherit">
      <ul>
	
	<li class="">
	  <a href="/">Home</a>
	</li>
	
	<li class="">
	  <a href="/projects/">Projects</a>
	</li>
	
	<li class="">
	  <a href="/archives/">Blog</a>
	</li>
	
	<li class="">
	  <a href="/contact/">Contact</a>
	</li>
	
	<li class="">
	  <a href="/about/">About</a>
	</li>
	
	<!-- BEGIN TOP SEARCH -->
	<li class="menu-search">
	  <span class="sep"></span>
	  <i class="fa fa-search search-btn"></i>
	  <div class="search-box">
	    <form action="#">
	      <div class="input-group">
		<input type="text" placeholder="Search" class="form-control st-default-search-input">
		<span class="input-group-btn">
		  <button class="btn btn-primary" type="submit">Search</button>
		</span>
	      </div>
	    </form>
	  </div> 
	</li>
	<!-- END TOP SEARCH -->
      </ul>
    </div>
    <!-- END NAVIGATION -->
  </div>
</div>
<!-- Header END -->

  <div class="container">
  <ul class="breadcrumb">
    <li><a href="/">Home</a></li>
    <li><a href="/blog">Blog</a></li>
    <li class="active">Tagged: java</li>
  </ul>
<section id="main">
  <h1>Tagged: java</h1>
  <div class="row">

<div class="col-xs-12 blog-posts">


  <section class="archives-wrap">
    <div class="archives">
      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2020/03/16/java-base-iterator-of-set/">聊一聊 CopyOnWriteArraySet 的迭代删除</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2020-03-16T01:26:12.000Z" itemprop="datePublished">2020/03/16</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2020/03/16/java-base-iterator-of-set/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/java/" title="java">java</a>,
  
    <a href="/tags/set/" title="set">set</a>,
  
    <a href="/tags/CopyOnWriteArraySet/" title="CopyOnWriteArraySet">CopyOnWriteArraySet</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>上周在工程中涉及到一个清理 Set 集合的操作，将满足设定条件的项从 Set 中删除掉。简化版本代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; sets = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">    sets.add(<span class="string">"1"</span>);</span><br><span class="line">    sets.add(<span class="string">"3"</span>);</span><br><span class="line">    sets.add(<span class="string">"3"</span>);</span><br><span class="line">    sets.add(<span class="string">"4"</span>);</span><br><span class="line">    Iterator&lt;String&gt; iterator = sets.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sets);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个看起来是个很常规的问题，没有验证就直接发了线下环境，然后就收到了业务方反馈的服务无法正常使用的问题了。</p>
<h3 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h3><p>先来看下上述代码所抛出的异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.UnsupportedOperationException</span><br><span class="line">	at java.util.concurrent.CopyOnWriteArrayList$COWIterator.remove(CopyOnWriteArrayList.java:<span class="number">1178</span>)</span><br><span class="line">	at com.glmapper.bridge.boot.TestMain.main(TestMain.java:<span class="number">21</span>)</span><br></pre></td></tr></table></figure>
<p>关于 UnsupportedOperationException 这个异常没有什么好说的，在集合操作中经常出现，网上也有很多关于这个异常的说明，这里不再赘述。这里我比较关注的是，我使用的是 CopyOnWriteArraySet，迭代器也是 sets 的，但是异常中居然出现了 CopyOnWriteArrayList，查看了 CopyOnWriteArraySet 的类继承关系，和 CopyOnWriteArrayList 也没啥关系。</p>
<h3 id="排查-amp-结果"><a href="#排查-amp-结果" class="headerlink" title="排查&amp;结果"></a>排查&amp;结果</h3><p>通过查看了 CopyOnWriteArraySet 的代码，发现 CopyOnWriteArraySet 内部其实是持有了一个 CopyOnWriteArrayList 的对象实例，其内部的所有操作都是基于 CopyOnWriteArrayList 这个对象来进行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArraySet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Creates an empty set.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于-CopyOnWriteArrayList-的操作"><a href="#关于-CopyOnWriteArrayList-的操作" class="headerlink" title="关于 CopyOnWriteArrayList 的操作"></a>关于 CopyOnWriteArrayList 的操作</h3><p><strong>写操作</strong></p>
<p>在 CopyOnWriteArrayList 里处理写操作（包括 add、remove、set 等）是先将原始的数据通过 JDK1.6 的 Arrays.copyof() 来生成一份新的数组。add 的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 这里是生产新的数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后续的操作都是在新的数据对象上进行写，写完后再将原来的引用指向到当前这个数据对象，这样保证了每次写都是在新的对象上（因为要保证写的一致性，这里要对各种写操作要加一把锁，JDK1.6 在这里用了重入锁），</p>
<p><strong>读操作</strong></p>
<p>读的时候就是在引用的当前对象上进行读（包括 get，iterator 等），不存在加锁和阻塞，针对 iterator 使用了一个叫 COWIterator 的简化版迭代器，因为不支持写操作，当获取 CopyOnWriteArrayList 的迭代器时，是将迭代器里的数据引用指向当前引用指向的数据对象，无论未来发生什么写操作，都不会再更改迭代器里的数据对象引用，所以迭代器也很安全。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>因为 CopyOnWriteArraySet 的内部操作都是基于 CopyOnWriteArrayList 的，从异常来看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.CopyOnWriteArrayList$COWIterator.remove(CopyOnWriteArrayList.java:1178)</span><br></pre></td></tr></table></figure></p>
<p>COWIterator 是 CopyOnWriteArrayList 内部提供的一个简化版的迭代器。所以异常里面出现这个就理所应当了。在来看下 COWIterator 这里简化版的迭代器的 remove 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Not supported. Always throws UnsupportedOperationException.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> UnsupportedOperationException always; &#123;<span class="doctag">@code</span> remove&#125;</span></span><br><span class="line"><span class="comment">*         is not supported by this iterator.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里实际上是直接就会抛出异常的，另外这里在多补充一个关于 HashSet 的迭代器移除，HashSet 其实内部是持有的 HashMap 实例，因此它的迭代器是 HashMap 内部提供的 HashIterator：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; p = current;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    current = <span class="keyword">null</span>;</span><br><span class="line">    K key = p.key;</span><br><span class="line">    removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里其实也可以看到，在对非安全的集合做 remove 操作时会经常遇到的 ConcurrentModificationException 这个异常。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2020/03/16/java-base-iterator-of-set/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2019/08/24/base-java-reacotr/">响应式编程 Reactor 小记</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2019-08-24T00:59:26.000Z" itemprop="datePublished">2019/08/24</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2019/08/24/base-java-reacotr/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/java/" title="java">java</a>,
  
    <a href="/tags/Reactor/" title="Reactor">Reactor</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<h2 id="从响应式编程说起"><a href="#从响应式编程说起" class="headerlink" title="从响应式编程说起"></a>从响应式编程说起</h2><p>响应式编程是一种关注于数据流（data streams）和变化传递（propagation of change）的异步编程方式。 这意味着它可以用既有的编程语言表达静态（如数组）或动态（如事件源）的数据流。</p>
<p>在响应式编程方面，微软跨出了第一步，它在 .NET 生态中创建了响应式扩展库（Reactive Extensions library, Rx）。接着 RxJava 在 JVM 上实现了响应式编程。后来，在 JVM 平台出现了一套标准的响应式 编程规范，它定义了一系列标准接口和交互规范。并整合到 Java 9 中（Flow 类）。</p>
<p>响应式编程通常作为面向对象编程中的“观察者模式”（Observer design pattern）的一种扩展。 响应式流（reactive streams）与“迭代子模式”（Iterator design pattern）也有相通之处， 因为其中也有 Iterable-Iterator 这样的对应关系。主要的区别在于，Iterator 是基于 “拉取”（pull）方式的，而响应式流是基于“推送”（push）方式的。</p>
<ul>
<li>iterator 是一种“命令式”（imperative）编程范式，即使访问元素的方法是 Iterable 的唯一职责。关键在于，什么时候执行 next() 获取元素取决于开发者。</li>
<li>响应式流中，相对应的角色是 Publisher-Subscriber，但是当有新的值到来的时候 ，却反过来由发布者（Publisher） 通知订阅者（Subscriber），这种“推送”模式是响应式的关键</li>
</ul>
<p>此外，对推送来的数据的操作是通过一种声明式（declaratively）而不是命令式（imperatively）的方式表达的：开发者通过描述“控制流程”来定义对数据流的处理逻辑。</p>
<p>除了数据推送，对错误处理（error handling）和完成（completion）信号的定义也很完善。一个 Publisher 可以推送新的值到它的 Subscriber（调用 onNext 方法）， 同样也可以推送错误（调用 onError 方法）和完成（调用 onComplete 方法）信号。 错误和完成信号都可以终止响应式流。可以用下边的表达式描述：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onNext x <span class="number">0</span>..N [onError | onComplete]</span><br></pre></td></tr></table></figure>
<p>这种方式非常灵活，无论是有/没有值，还是 n 个值（包括有无限个值的流，比如时钟的持续读秒），都可处理。</p>
<blockquote>
<p>以上来自 <a href="https://projectreactor.io/docs/core/release/reference/" target="_blank" rel="noopener">https://projectreactor.io/docs/core/release/reference/</a> 翻译</p>
</blockquote>
<h2 id="Reactive-Streams"><a href="#Reactive-Streams" class="headerlink" title="Reactive Streams"></a>Reactive Streams</h2><p>Reactive Streams 是上面提到的一套标准的响应式编程规范。它由四个核心概念构成：</p>
<ul>
<li><p>消息发布者：只有一个 subscribe 接口，是订阅者调用的，用来订阅发布者的消息。发布者在订阅者调用 request 之后把消息 push 给订阅者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Publisher</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>订阅者：订阅者包括四个接口，这些接口都由 Publisher 触发调用的。onSubscribe 告诉订阅者订阅成功，并返回了一个 Subscription ；通过 Subscription 订阅者可以告诉发布者发送指定数量的消息（request 完成） ；onNext 是发布者有消息时，调用订阅者这个接口来达到发布消息的目的；onError 通知订阅者，发布者出现了错误；onComplete 通知订阅者消息发送完毕。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>订阅：包括两个接口，请求 n 个消息和取消此次订阅。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subscription</span> </span>&#123;</span><br><span class="line">    <span class="comment">// request(n)用来发起请求数据,其中n表示请求数据的数量,它必须大于0,</span></span><br><span class="line">    <span class="comment">// 否则会抛出IllegalArgumentException,并触发onError,request的调用会</span></span><br><span class="line">    <span class="comment">// 累加,如果没有终止,最后会触发相应次数的onNext方法.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span><br><span class="line">    <span class="comment">// cancel相当于取消订阅,调用之后,后续不会再收到订阅,onError 和 </span></span><br><span class="line">    <span class="comment">// onComplete也不会被触发</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理器：Processor 同时继承了 Subscriber 和 Publisher；其代表一个处理阶段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt;, <span class="title">Publisher</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Reactive Streams 通过上面的四个核心概念和相关的函数，对响应式流进行了一个框架性的约定，它没有具体实现。简单来说，它只提供通用的、合适的解决方案，大家都按照这个规约来实现就好了。</p>
<p>Java 的 Reactive Programming 类库主要有三个，分别是 Akka-Streams ，RxJava 和 Project Reactor。Spring 5 开始支持 Reactive Programming，其底层使用的是 Project Reactor。本篇主要是对 Project Reactor 中的一些点进行学习总结。</p>
<h2 id="Project-Reactor"><a href="#Project-Reactor" class="headerlink" title="Project Reactor"></a>Project Reactor</h2><p>Project Reactor 是一个基于 Java 8 的实现了响应式流规范 （Reactive Streams specification）的响应式库。</p>
<p>Reactor 引入了实现 Publisher 的响应式类 Flux 和 Mono，以及丰富的操作方式。 一个 Flux 对象代表一个包含 0..N 个元素的响应式序列，而一个 Mono 对象代表一个包含零或者一个（0..1）元素的结果。</p>
<h3 id="Flux-和-Mono"><a href="#Flux-和-Mono" class="headerlink" title="Flux 和 Mono"></a>Flux 和 Mono</h3><p>Flux 是生产者，即我们上面提到的 Publisher，它代表的是一个包含 0-N 个元素的异步序列，Mono可以看做 Flux 的有一个特例，代表 0-1 个元素，如果不需要生产任何元素，只是需要一个完成任务的信号，可以使用 Mono。</p>
<h4 id="Flux-包含-0-N-个元素的异步序列"><a href="#Flux-包含-0-N-个元素的异步序列" class="headerlink" title="Flux-包含 0-N 个元素的异步序列"></a>Flux-包含 0-N 个元素的异步序列</h4><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/reactor/reactor-flux.jpg" alt="Flux"></p>
<p>先来看这张图，这里是直接从官方文档上贴过来的。就这张图做下说明，先来关注几个点：</p>
<ul>
<li>从左到右的时间序列轴</li>
<li>1-6 为 Flux enitted（发射）的元素</li>
<li>上面 6 后面的竖线标识已经成功完成了</li>
<li>下面的 1-3 表示转换的结果</li>
<li>❌  表示出现了error，对应的是执行了onError</li>
<li>operator : 操作符，声明式的可组装的响应式方法，其组装成的链称为“操作链”</li>
</ul>
<p>那整体来看就是 Flux 产生元数据，通过一系列 operator 操作得到转换结果，正常成功就是 onCompleted，出现错误就是 onError。看下面的一个小例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">"glmapper"</span>,<span class="string">"leishu"</span>).subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// subscription 表示订阅关系</span></span><br><span class="line">        System.out.println(<span class="string">"onSubscribe,"</span>+ subscription.getClass());</span><br><span class="line">        <span class="comment">// subscription 通过 request 来触发 onNext</span></span><br><span class="line">        subscription.request(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"currrent value is = "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"it's error."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"it's completed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onSubscribe,class reactor.core.publisher.StrictSubscriber</span><br><span class="line">currrent value is = glmapper</span><br><span class="line">currrent value is = leishu</span><br><span class="line">it&apos;s completed.</span><br></pre></td></tr></table></figure>
<p>如果在 onSubscribe 方法中我们不执行 request，则不会有后续任何操作。关于 request 下面看。</p>
<blockquote>
<p>Flux<t> 是一个能够发出 0 到 N 个元素的标准的 Publisher<t>，它会被一个 “error”  或 “completion” 信号终止。因此，一个 Flux 的结果可能是一个 value、completion 或 error。 就像在响应式流规范中规定的那样，这三种类型的信号被翻译为面向下游的 <code>onNext</code>，<code>onComplete</code>和<code>onError</code>方法。</t></t></p>
</blockquote>
<h4 id="Mono-异步的-0-1-结果"><a href="#Mono-异步的-0-1-结果" class="headerlink" title="Mono-异步的 0-1 结果"></a>Mono-异步的 0-1 结果</h4><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/reactor/reactor-mono.jpg" alt="Mono"></p>
<p>这张图也来自官方文档，和上面 Flux 的区别就是，Mono 最多只能 emitted 一个元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono.just(<span class="string">"glmapper"</span>).subscribe(System.out::println);</span><br></pre></td></tr></table></figure></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通过上面两段小的代码来看，最直观的感受是，Flux 相当于一个 List，Mono 相当于 Optional。其实在编程中所有的结果我们都可以用 List 来 表示，但是当只返回一个或者没有结果时，用 Optional 可能会更精确些。</p>
<blockquote>
<p>Optional 相关概念可自行搜索 jdk Optional</p>
</blockquote>
<p>另外，Mono 和 Flux 都提供了一些工厂方法，用于创建相关的实例，这里简单罗列一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以指定序列中包含的全部元素。创建出来的 Flux </span></span><br><span class="line"><span class="comment">// 序列在发布这些元素之后会自动结束。</span></span><br><span class="line">Flux.just(<span class="string">"glmapper"</span>, <span class="string">"leishu"</span>);</span><br><span class="line"><span class="comment">// 从一个Iterable 对象中创建 Flux 对象,当然还可以是数组、Stream对象等</span></span><br><span class="line">Flux.fromIterable(Arrays.asList(<span class="string">"glmapper"</span>,<span class="string">"leishu"</span>));</span><br><span class="line"><span class="comment">// 创建一个只包含错误消息的序列。</span></span><br><span class="line">Flux.error(<span class="keyword">new</span> IllegalStateException());</span><br><span class="line"><span class="comment">// 创建一个包含了从 0 开始递增的 Long 对象的序列。其中包含的元素按照指定的间</span></span><br><span class="line"><span class="comment">// 隔来发布。除了间隔时间之外，还可以指定起始元素发布之前的延迟时间。</span></span><br><span class="line">Flux.interval(Duration.ofMillis(<span class="number">100</span>)).take(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 创建一个不包含任何消息通知的序列。</span></span><br><span class="line">Flux.never();</span><br><span class="line"><span class="comment">// 创建一个不包含任何元素，只发布结束消息的序列。</span></span><br><span class="line">Flux.empty(); </span><br><span class="line"><span class="comment">// 创建包含从 start 起始的 count 个数量的 Integer 对象的序列</span></span><br><span class="line">Flux.range(<span class="keyword">int</span> start, <span class="keyword">int</span> count);</span><br><span class="line"><span class="comment">// Mono 同上</span></span><br><span class="line">Mono.empty();</span><br><span class="line">Mono.never();</span><br><span class="line">Mono.just(<span class="string">"glmapper"</span>);</span><br><span class="line">Mono.error(<span class="keyword">new</span> IllegalStateException());</span><br></pre></td></tr></table></figure></p>
<p>上面的这些静态方法适合于简单的序列生成，当序列的生成需要复杂的逻辑时，则应该使用 generate() 或 create() 方法。</p>
<h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><ul>
<li>Operator：Operator 是一系列函数式的便捷操作，可以链式调用。所有函数调用基本都 是 Reactor 的 Operator ，比如 just，map，flatMap，filter 等。</li>
<li>Processor：上面从 Processor 的接口定义可以看出，它既是一个 Subscriber，又是一个 Publisher；Processor 夹在第一个 Publisher 和最后一个 Subscriber 中间，对数据进行处理。有点类似 stream 里的 map，filter 等方法。具体在数据流转中， Processor 以 Subscriber 的身份订阅 Publisher 接受数据，又以 Publisher 的方式接受其它 Subscriber 的订阅，它从自己订阅的 Publisher 收到数据后，做一些处理，然后转发给订阅它的 Subscriber。</li>
<li>back pressure：背压。对 MQ 有了解的应该清楚，消息积压一般是在消费端，也就是说生产端只负责生产，并不会关心消费端的消费能力，这样就到导致 pressure 积压在消费端，这个是正向的。从上面对 Reactor 中的一些了解，Subscriber 是主动向 Publisher 请求的，这样当消费端消费的速度没有生产者快时，这些消息还是积压在生产端；这种好处就是生产者可以根据实际情况适当的调整生产消息的速度。</li>
<li>Hot VS Cold ：参考 <a href="https://htmlpreview.github.io/?https://github.com/get-set/reactor-core/blob/master-zh/src/docs/index.html#reactor.hotCold" target="_blank" rel="noopener">Hot VS Cold</a></li>
</ul>
<h3 id="核心调用过程"><a href="#核心调用过程" class="headerlink" title="核心调用过程"></a>核心调用过程</h3><p>Reactor 的核心调用过程大致可以分为图中的几个阶段<br><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/reactor/reactor-processor.jpg" alt=""></p>
<ul>
<li>声明：无论是使用 just 或者其他什么方式创建反应式流，这个过程都可以称之为声明，因为此时这些代码不会被实际的执行。</li>
<li>subscribe：当调用 subscribe 时，整个执行过程便进入 subscribe 阶段，经过一系列的调用之后，subscribe 动作会代理给具体的 Flux 来实现。</li>
<li>onSubscribe：onSubscribe 阶段指的是 Subscriber#onSubscribe 方法被依次调用的阶段。这个阶段会让各 Subscriber 知道 subscribe 方法已被触发，真正的处理流程马上就要开始。</li>
<li>request：onSubscribe 阶段是表示订阅动作的方式，让各 Subscriber 知悉，准备开始处理数据。当最终的 Subscriber 做好处理数据的准备之后，它便会调用 Subscription 的 request 方法请求数据。</li>
<li>onNext：通过调用 Subscriber 的 onNext 方法，进行真正的响应式的数据处理。</li>
<li>onComplete：成功的终端状态，没有进一步的事件将被发送。</li>
<li>onError：错误的终端状态（和 onComplete 一样，当发生时，后面的将不会在继续执行）。</li>
</ul>
<h3 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h3><p>当需要处理 Flux 或 Mono 中的消息时，可以通过 subscribe 方法来添加相应的订阅逻辑。在调用 subscribe 方法时可以指定需要处理的消息类型。可以只处理其中包含的正常消息，也可以同时处理错误消息和完成消息。</p>
<h4 id="通过-subscribe-方法处理正常和错误消息"><a href="#通过-subscribe-方法处理正常和错误消息" class="headerlink" title="通过 subscribe() 方法处理正常和错误消息"></a>通过 subscribe() 方法处理正常和错误消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">   .concatWith(Mono.error(<span class="keyword">new</span> IllegalStateException()))</span><br><span class="line">   .subscribe(System.out::println, System.err::println);</span><br></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">java.lang.IllegalStateException</span><br></pre></td></tr></table></figure></p>
<p>正常的消息处理相对简单。当出现错误时，有多种不同的处理策略:</p>
<ul>
<li>通过 onErrorReturn() 方法返回一个默认值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    .concatWith(Mono.error(<span class="keyword">new</span> IllegalStateException()))</span><br><span class="line">    .onErrorReturn(<span class="number">0</span>)</span><br><span class="line">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<ul>
<li>通过 onErrorResume()方法来根据不同的异常类型来选择要使用的产生元素的流<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">       .concatWith(Mono.error(<span class="keyword">new</span> IllegalArgumentException()))</span><br><span class="line">       .onErrorResume(e -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (e <span class="keyword">instanceof</span> IllegalStateException) &#123;</span><br><span class="line">               <span class="keyword">return</span> Mono.just(<span class="number">0</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> IllegalArgumentException) &#123;</span><br><span class="line">               <span class="keyword">return</span> Mono.just(-<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> Mono.empty();</span><br><span class="line">           &#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure></p>
<ul>
<li>通过 retry 操作符来进行重试，重试的动作是通过重新订阅序列来实现的。在使用 retry 操作符时可以指定重试的次数。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    .concatWith(Mono.error(<span class="keyword">new</span> IllegalStateException()))</span><br><span class="line">    .retry(<span class="number">1</span>)</span><br><span class="line">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">Exception in thread &quot;main&quot; reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.IllegalStateException</span><br><span class="line">Caused by: java.lang.IllegalStateException</span><br><span class="line">	at com.glmapper.bridge.boot.reactor.SimpleTest.testFluxSub(SimpleTest.java:75)</span><br><span class="line">	at com.glmapper.bridge.boot.reactor.SimpleTest.main(SimpleTest.java:23)</span><br></pre></td></tr></table></figure></p>
<h3 id="调度器-Scheduler"><a href="#调度器-Scheduler" class="headerlink" title="调度器 Scheduler"></a>调度器 Scheduler</h3><p>在 Reactor 中，执行模式以及执行过程取决于所使用的 Scheduler，Scheduler 是一个拥有广泛实现类的抽象接口，Schedulers 类提供的静态方法用于达成如下的执行环境：</p>
<ul>
<li><p>当前线程（Schedulers.immediate()）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Schedulers.immediate().schedule(()-&gt;&#123;</span><br><span class="line">   System.out.println(Thread.currentThread().getName()+<span class="string">"-"</span>+<span class="number">11</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main-11</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可重用的单线程（Schedulers.single()）。注意，这个方法对所有调用者都提供同一个线程来使用， 直到该调度器（Scheduler）被废弃。如果你想使用专一的线程，就对每一个调用使用 Schedulers.newSingle()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Schedulers.single().schedule(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"-"</span>+<span class="number">11</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// single-1-11</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>弹性线程池（Schedulers.elastic()。它根据需要创建一个线程池，重用空闲线程。线程池如果空闲时间过长 （默认为 60s）就会被废弃。对于 I/O 阻塞的场景比较适用。 Schedulers.elastic() 能够方便地给一个阻塞 的任务分配它自己的线程，从而不会妨碍其他任务和资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Schedulers.elastic().schedule(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"-"</span>+<span class="number">11</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// elastic-2-11</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>固定大小线程池（Schedulers.parallel()）。所创建线程池的大小与 CPU 个数等同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Schedulers.parallel().schedule(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"-"</span>+<span class="number">11</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// parallel-1-11</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>基于现有的 ExecutorService 创建 Scheduler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">Schedulers.fromExecutorService(executorService).schedule(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"-"</span>+<span class="number">11</span>);</span><br><span class="line">&#125;);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// pool-4-thread-1-11</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>基于 newXXX 方法来创建调度器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Schedulers.newElastic(<span class="string">"test-elastic"</span>).schedule(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"-"</span>+<span class="number">11</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// test-elastic-4-11</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>一些操作符默认会使用一个指定的调度器（通常也允许开发者调整为其他调度器）例如， 通过工厂方法 Flux.interval(Duration.ofMillis(100)) 生成的每 100ms 打点一次的 Flux<long>， 默认情况下使用的是 Schedulers.parallel()，下边的代码演示了如何将其装换为 Schedulers.single()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; intervalResult = Flux.interval(Duration.ofMillis(<span class="number">100</span>),</span><br><span class="line">        Schedulers.newSingle(<span class="string">"test"</span>))</span><br><span class="line">        .map(i -&gt; Thread.currentThread().getName() +<span class="string">"@"</span>+i);</span><br><span class="line">        intervalResult.subscribe(System.out::println);</span><br></pre></td></tr></table></figure></long></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test-1@0</span><br><span class="line">test-1@1</span><br><span class="line">test-1@2</span><br><span class="line">test-1@3</span><br><span class="line">test-1@4</span><br><span class="line">// 省略</span><br></pre></td></tr></table></figure></p>
<h3 id="publishOn-和-subscribeOn"><a href="#publishOn-和-subscribeOn" class="headerlink" title="publishOn 和 subscribeOn"></a>publishOn 和 subscribeOn</h3><p>Reactor 提供了两种在响应式链中调整调度器 Scheduler 的方法：publishOn 和 subscribeOn。 它们都接受一个 Scheduler 作为参数，从而可以改变调度器。但是 publishOn 在链中出现的位置是有讲究的，而 subscribeOn 则无所谓。</p>
<ul>
<li>publishOn 的用法和处于订阅链（subscriber chain）中的其他操作符一样。它将上游 信号传给下游，同时执行指定的调度器 Scheduler 的某个工作线程上的回调。 它会 改变后续的操作符的执行所在线程 （直到下一个 publishOn 出现在这个链上）</li>
<li>subscribeOn 用于订阅（subscription）过程，作用于那个向上的订阅链（发布者在被订阅 时才激活，订阅的传递方向是向上游的）。所以，无论你把 subscribeOn 至于操作链的什么位置， 它都会影响到源头的线程执行环境（context）。 但是，它不会影响到后续的 publishOn，后者仍能够切换其后操作符的线程执行环境。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Flux.create(sink -&gt; &#123;</span><br><span class="line">        sink.next(Thread.currentThread().getName());</span><br><span class="line">        sink.complete();</span><br><span class="line">    &#125;)</span><br><span class="line">    .publishOn(Schedulers.single())</span><br><span class="line">    .map(x -&gt; String.format(<span class="string">"[%s] %s"</span>, Thread.currentThread().getName(), x))</span><br><span class="line">    .publishOn(Schedulers.elastic())</span><br><span class="line">    .map(x -&gt; String.format(<span class="string">"[%s] %s"</span>, Thread.currentThread().getName(), x))</span><br><span class="line">    .subscribeOn(Schedulers.parallel())</span><br><span class="line">    .toStream()</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[elastic-<span class="number">2</span>] [single-<span class="number">1</span>] parallel-<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>上面这段代码使用 create() 方法创建一个新的 Flux 对象，其中包含唯一的元素是当前线程的名称。</p>
<p>接着是两对 publishOn() 和 map()方法，其作用是先切换执行时的调度器，再把当前的线程名称作为前缀添加。</p>
<p>最后通过 subscribeOn()方法来改变流产生时的执行方式。</p>
<p>最内层的线程名字 parallel-1 来自产生流中元素时使用的 Schedulers.parallel()调度器，中间的线程名称 single-1 来自第一个 map 操作之前的 Schedulers.single() 调度器，最外层的线程名字 elastic-2 来自第二个 map 操作之前的 Schedulers.elastic()调度器。</p>
<blockquote>
<p>先到这里，剩下的想到再补充…</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://projectreactor.io/docs/core/release/reference/" target="_blank" rel="noopener">https://projectreactor.io/docs/core/release/reference/</a></li>
<li><a href="https://htmlpreview.github.io/?https://github.com/get-set/reactor-core/blob/master-zh/src/docs/index.html#about-doc" target="_blank" rel="noopener">https://htmlpreview.github.io/?https://github.com/get-set/reactor-core/blob/master-zh/src/docs/index.html#about-doc</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-cn-with-reactor-response-encode/index.html?lnk=hmhm" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-cn-with-reactor-response-encode/index.html?lnk=hmhm</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2019/08/24/base-java-reacotr/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2019/08/19/base-java-generics/">聊一聊-JAVA 泛型中的通配符 T，E，K，V，？</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2019-08-19T07:20:35.000Z" itemprop="datePublished">2019/08/19</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2019/08/19/base-java-generics/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/java/" title="java">java</a>,
  
    <a href="/tags/泛型/" title="泛型">泛型</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许开发者在编译时检测到非法的类型。</p>
<p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<h2 id="泛型带来的好处"><a href="#泛型带来的好处" class="headerlink" title="泛型带来的好处"></a>泛型带来的好处</h2><p>在没有泛型的情况的下，通过对类型 Object 的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是本身就是一个安全隐患。</p>
<p>那么泛型的好处就是在编译的时候能够检查类型安全，并且所有的强制转换都是自动和隐式的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperGeneric</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">this</span>.t = t; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 不指定类型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noSpecifyType</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GlmapperGeneric glmapperGeneric = <span class="keyword">new</span> GlmapperGeneric();</span><br><span class="line">    glmapperGeneric.set(<span class="string">"test"</span>);</span><br><span class="line">    <span class="comment">// 需要强制类型转换</span></span><br><span class="line">    String test = (String) glmapperGeneric.get();</span><br><span class="line">    System.out.println(test);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 指定类型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specifyType</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GlmapperGeneric&lt;String&gt; glmapperGeneric = <span class="keyword">new</span> GlmapperGeneric();</span><br><span class="line">    glmapperGeneric.set(<span class="string">"test"</span>);</span><br><span class="line">    <span class="comment">// 不需要强制类型转换</span></span><br><span class="line">    String test = glmapperGeneric.get();</span><br><span class="line">    System.out.println(test);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码中的 specifyType 方法中 省去了强制转换，可以在编译时候检查类型安全，可以用在类，方法，接口上。</p>
<h2 id="泛型中通配符"><a href="#泛型中通配符" class="headerlink" title="泛型中通配符"></a>泛型中通配符</h2><p>我们在定义泛型类，泛型方法，泛型接口的时候经常会碰见很多不同的通配符，比如 T，E，K，V 等等，这些通配符又都是什么意思呢？</p>
<h3 id="常用的-T，E，K，V，？"><a href="#常用的-T，E，K，V，？" class="headerlink" title="常用的 T，E，K，V，？"></a>常用的 T，E，K，V，？</h3><p>本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。<strong>通常情况下，T，E，K，V，？ 是这样约定的：</strong></p>
<ul>
<li>？ 表示不确定的 java 类型</li>
<li>T (type) 表示具体的一个java类型</li>
<li>K V (key value) 分别代表java键值中的Key Value</li>
<li>E (element) 代表Element</li>
</ul>
<h3 id="？-无界通配符"><a href="#？-无界通配符" class="headerlink" title="？ 无界通配符"></a>？ <strong>无界通配符</strong></h3><p>先从一个小例子看起，原文在 <a href="https://codeday.me/bug/20180113/116421.html" target="_blank" rel="noopener">这里</a> 。</p>
<p>我有一个父类 Animal 和几个子类，如狗、猫等，现在我需要一个动物的列表，我的第一个想法是像这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Animal&gt; listAnimals</span><br></pre></td></tr></table></figure>
<p>但是老板的想法确实这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Animal&gt; listAnimals</span><br></pre></td></tr></table></figure>
<p>为什么要使用通配符而不是简单的泛型呢？通配符其实在声明局部变量时是没有什么意义的，但是当你为一个方法声明一个参数时，它是非常重要的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countLegs</span> <span class="params">(List&lt;? extends Animal &gt; animals )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( Animal animal : animals )</span><br><span class="line">    &#123;</span><br><span class="line">        retVal += animal.countLegs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countLegs1</span> <span class="params">(List&lt; Animal &gt; animals )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( Animal animal : animals )</span><br><span class="line">    &#123;</span><br><span class="line">        retVal += animal.countLegs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Dog&gt; dogs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> 	<span class="comment">// 不会报错</span></span><br><span class="line">    countLegs( dogs );</span><br><span class="line">	<span class="comment">// 报错</span></span><br><span class="line">    countLegs1(dogs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用 countLegs1 时，就会飘红，提示的错误信息如下：</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/generics/generics-1.jpg" alt=""></p>
<p>所以，对于不确定或者不关心实际要操作的类型，可以使用无限制通配符（尖括号里一个问号，即 &lt;?&gt; ），表示可以持有任何类型。像 countLegs 方法中，限定了上届，但是不关心具体类型是什么，所以对于传入的 Animal 的所有子类都可以支持，并且不会报错。而 countLegs1 就不行。</p>
<h3 id="上界通配符-lt-extends-E-gt"><a href="#上界通配符-lt-extends-E-gt" class="headerlink" title="上界通配符 &lt; ? extends E&gt;"></a>上界通配符 &lt; ? extends E&gt;</h3><blockquote>
<p>上届：用 extends 关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。</p>
</blockquote>
<p>在类型参数中使用 extends 表示这个泛型中的参数必须是 E 或者 E 的子类，这样有两个好处：</p>
<ul>
<li>如果传入的类型不是 E 或者 E 的子类，编译不成功</li>
<li>泛型中可以使用 E 的方法，要不然还得强转成 E 才能使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;K extends A, E extends B&gt; <span class="function">E <span class="title">test</span><span class="params">(K arg1, E arg2)</span></span>&#123;</span><br><span class="line">    E result = arg2;</span><br><span class="line">    arg2.compareTo(arg1);</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>类型参数列表中如果有多个类型参数上限，用逗号分开</p>
</blockquote>
<h3 id="下界通配符-lt-super-E-gt"><a href="#下界通配符-lt-super-E-gt" class="headerlink" title="下界通配符 &lt; ? super E&gt;"></a>下界通配符 &lt; ? super E&gt;</h3><blockquote>
<p>下界: 用 super 进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object</p>
</blockquote>
<p>在类型参数中使用 super 表示这个泛型中的参数必须是 E 或者 E 的父类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dst, List&lt;T&gt; src)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T t : src) &#123;</span><br><span class="line">        dst.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Dog&gt; dogs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Animal&gt; animals = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> Test3().test(animals,dogs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Dog 是 Animal 的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dst 类型 “大于等于” src 的类型，这里的“大于等于”是指 dst 表示的范围比 src 要大，因此装得下 dst 的容器也就能装 src 。</p>
<h3 id="？-和-T-的区别"><a href="#？-和-T-的区别" class="headerlink" title="？ 和 T 的区别"></a>？ 和 T 的区别</h3><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/generics/generics-2.jpg" alt=""></p>
<p>？和 T 都表示不确定的类型，区别在于我们可以对 T 进行操作，但是对 ？ 不行，比如如下这种 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以</span></span><br><span class="line">T t = operate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以</span></span><br><span class="line">？ car = operate();</span><br></pre></td></tr></table></figure>
<p>简单总结下：</p>
<p>T 是一个 确定的 类型，通常用于泛型类和泛型方法的定义，？是一个 不确定 的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。</p>
<h4 id="区别1：通过-T-来-确保-泛型参数的一致性"><a href="#区别1：通过-T-来-确保-泛型参数的一致性" class="headerlink" title="区别1：通过 T 来 确保 泛型参数的一致性"></a>区别1：通过 T 来 确保 泛型参数的一致性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 T 来 确保 泛型参数的一致性</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="keyword">void</span></span><br><span class="line">test(List&lt;T&gt; dest, List&lt;T&gt; src)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span></span><br><span class="line">test(List&lt;? extends Number&gt; dest, List&lt;? extends Number&gt; src)</span><br></pre></td></tr></table></figure>
<p>像下面的代码中，约定的 T 是 Number 的子类才可以，但是申明时是用的 String ，所以就会飘红报错。</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/generics/generics-3.jpg" alt=""></p>
<p>不能保证两个 List 具有相同的元素类型的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GlmapperGeneric&lt;String&gt; glmapperGeneric = new GlmapperGeneric&lt;&gt;();</span><br><span class="line">List&lt;String&gt; dest = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Number&gt; src = new ArrayList&lt;&gt;();</span><br><span class="line">glmapperGeneric.testNon(dest,src);</span><br></pre></td></tr></table></figure>
<p>上面的代码在编译器并不会报错，但是当进入到 testNon 方法内部操作时（比如赋值），对于 dest 和 src 而言，就还是需要进行类型转换。</p>
<h4 id="区别2：类型参数可以多重限定而通配符不行"><a href="#区别2：类型参数可以多重限定而通配符不行" class="headerlink" title="区别2：类型参数可以多重限定而通配符不行"></a>区别2：类型参数可以多重限定而通配符不行</h4><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/generics/generics-4.jpg" alt=""></p>
<p>使用 &amp; 符号设定多重边界（Multi Bounds)，指定泛型类型 T 必须是 MultiLimitInterfaceA 和 MultiLimitInterfaceB 的共有子类型，此时变量 t 就具有了所有限定的方法和属性。对于通配符来说，因为它不是一个确定的类型，所以不能进行多重限定。</p>
<h4 id="区别3：通配符可以使用超类限定而类型参数不行"><a href="#区别3：通配符可以使用超类限定而类型参数不行" class="headerlink" title="区别3：通配符可以使用超类限定而类型参数不行"></a>区别3：通配符可以使用超类限定而类型参数不行</h4><p>类型参数 T 只具有 一种 类型限定方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T extends A</span><br></pre></td></tr></table></figure>
<p>但是通配符 ? 可以进行 两种限定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? extends A</span><br><span class="line">? <span class="keyword">super</span> A</span><br></pre></td></tr></table></figure>
<h2 id="Class-lt-T-gt-和-Class-lt-gt-区别"><a href="#Class-lt-T-gt-和-Class-lt-gt-区别" class="headerlink" title="Class&lt;T&gt; 和 Class&lt;?&gt; 区别"></a><code>Class&lt;T&gt;</code> 和 <code>Class&lt;?&gt;</code> 区别</h2><p>前面介绍了 ？ 和 T 的区别，那么对于，<code>Class&lt;T&gt;</code> 和 <code>&lt;Class&lt;?&gt;</code> 又有什么区别呢？<br><code>Class&lt;T&gt;</code> 和 <code>Class&lt;?&gt;</code></p>
<p>最常见的是在反射场景下的使用，这里以用一段发射的代码来说明下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过反射的方式生成  multiLimit </span></span><br><span class="line"><span class="comment">// 对象，这里比较明显的是，我们需要使用强制类型转换</span></span><br><span class="line">MultiLimit multiLimit = (MultiLimit)</span><br><span class="line">Class.forName(<span class="string">"com.glmapper.bridge.boot.generic.MultiLimit"</span>).newInstance();</span><br></pre></td></tr></table></figure>
<p>对于上述代码，在运行期，如果反射的类型不是 MultiLimit 类，那么一定会报 java.lang.ClassCastException 错误。</p>
<p>对于这种情况，则可以使用下面的代码来代替，使得在在编译期就能直接 检查到类型的问题：</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/generics/generics-5.jpg" alt=""></p>
<p><code>Class&lt;T&gt;</code> 在实例化的时候，T 要替换成具体类。<code>Class&lt;?&gt;</code> 它是个通配泛型，? 可以代表任何类型，所以主要用于声明时的限制情况。比如，我们可以这样做申明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; clazz;</span><br><span class="line"><span class="comment">// 不可以，因为 T 需要指定类型</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;T&gt; clazzT;</span><br></pre></td></tr></table></figure>
<p>所以当不知道定声明什么类型的 Class 的时候可以定义一 个Class&lt;?&gt;。</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/generics/generics-6.jpg" alt=""></p>
<p>那如果也想 <code>public Class&lt;T&gt; clazzT;</code> 这样的话，就必须让当前的类也指定 T ，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; clazz;</span><br><span class="line">    <span class="comment">// 不会报错</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;T&gt; clazzT;</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文零碎整理了下 JAVA 泛型中的一些点，不是很全，仅供参考。如果文中有不当的地方，欢迎指正。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.toutiao.com/a6694132392728199683" target="_blank" rel="noopener">JAVA泛型通配符T，E，K，V区别，网友回复：一文秒懂</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2019/08/19/base-java-generics/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2019/07/23/maven-debug/">一个 maven 插件打包问题的排查</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2019-07-23T11:12:48.000Z" itemprop="datePublished">2019/07/23</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2019/07/23/maven-debug/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/java/" title="java">java</a>,
  
    <a href="/tags/maven/" title="maven">maven</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>最近研究 <a href="https://github.com/sofastack/sofa-ark" target="_blank" rel="noopener">sofa-ark</a> 的插件机制时，发现当执行完 <code>maven clean install -DskipTests</code> 时，打在 target 目录下的 <code>xxx.jar</code> 与安装到本地仓库的 <code>xxx.jar</code> 大小不一致。</p>
<ul>
<li><p>target 目录下的插件大小<br>  <img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-one.jpg" alt=""></p>
</li>
<li><p>.m2 下的插件大小</p>
<p>  <img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-two.jpg" alt=""></p>
</li>
</ul>
<p>其实一开始看到这种现象也是懵逼，同一个工程，同一次命令执行，但是得到的两个 jar 包大小差距巨大。那么对于这种问题，我想到的有两点：</p>
<ul>
<li>debug 打包插件执行过程</li>
<li>了解 maven 插件的生命周期</li>
</ul>
<h2 id="debug-打包插件执行过程"><a href="#debug-打包插件执行过程" class="headerlink" title="debug 打包插件执行过程"></a>debug 打包插件执行过程</h2><p>这里需要借助 IDEA 中的远程 debug 能力来完成。目前有两个工程，一个是我们的主工程，工程名为上面截图中的 mq-client-ark-plugin ，另一个是打包插件的源码工程，如下图所示：</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-three.jpg" alt=""></p>
<p>那么下面就一步一步来完成远程 <code>debug</code> 的配置。</p>
<h3 id="1、使用-mvnDebug-命令开启-debug-模式"><a href="#1、使用-mvnDebug-命令开启-debug-模式" class="headerlink" title="1、使用 mvnDebug 命令开启 debug 模式"></a>1、使用 mvnDebug 命令开启 debug 模式</h3><p>在主工程 <code>mq-client-ark-plugin</code> 的根目录下执行  <code>mvnDebug install</code>（当然除了 <code>install</code> 之外，也可以是 <code>compile</code>、<code>package</code>、<code>test</code>、<code>deploy</code> 等）。</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-four.jpg" alt=""></p>
<p>当执行完 <code>mvnDebug install</code> 后，可以看到这个阻塞监听 8000 端口了。</p>
<h3 id="2、源码工程配置远程-debug"><a href="#2、源码工程配置远程-debug" class="headerlink" title="2、源码工程配置远程 debug"></a>2、源码工程配置远程 debug</h3><p>在 <code>idea</code> 主界面找下下图的工具菜单，选择 <code>Edit Configurations...</code><br><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-five.jpg" alt=""><br>打开配置面板之后，左上角 <code>+</code> 选择 <code>Remote</code><br><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-six.jpg" alt=""><br>填写相关远程 debug 参数</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-seven.jpg" alt=""></p>
<ul>
<li><code>Host</code> : 远程目标主机地址，因为之前 主工程也是本地启动的，所以这里就是 <code>localhost</code></li>
<li><code>Port</code> : 远程目标主机开启的远程 <code>debug</code> 端口</li>
<li>开启远程 <code>debug</code> 参数：<code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000</code></li>
</ul>
<p>配置完成之后，执行 <code>debug</code> ，可以看下已经连接到了目标机器：</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-eight.jpg" alt=""></p>
<p>在来看主工程这里，在源码工程没有执行上面的 <code>debug</code> 按钮之前，一直都是阻塞的，执行之后 <code>maven</code> 执行的生命周期开始了:<br><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-nine.jpg" alt=""></p>
<p>如上图，因为在源码工程中打了断点，所以当执行到 <code>sofa-ark-maven-plugin</code> 插件时阻塞了。</p>
<h2 id="从-maven-执行的生命周期找出问题根源"><a href="#从-maven-执行的生命周期找出问题根源" class="headerlink" title="从 maven 执行的生命周期找出问题根源"></a>从 maven 执行的生命周期找出问题根源</h2><p>上面已经搞定了对目标插件源码的 <code>debug</code> 模式的开启，那么下面就是对插件代码进行 <code>debug</code> 操作。节省篇幅，这里直接将断点放在目标代码行位置：</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-ten.jpg" alt=""></p>
<p>分析这段代码</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-11.jpg" alt=""></p>
<ul>
<li>1、获取到项目的 <code>Artifact</code> ,此时 <code>Artifact</code> 的 <code>file</code> 为：<br><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-12.jpg" alt=""></li>
<li>2、重新设置的 <code>File</code></li>
<li>3、重新设置了 <code>artifact</code></li>
</ul>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-13.jpg" alt=""></p>
<p>如果单从上面 <code>debug</code> 来看，其实很难解释开篇的那个问题。那么这里在回过头来看下 主工程的 <code>maven</code> 执行日志：</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-14.jpg" alt=""></p>
<p>如上图中圈红的部分，代表 <code>maven install</code> 所经历的所有阶段。可以看到 <code>sofa-ark-plugin-maven-plugin</code> 是在  <code>maven-install-plugin</code> 后面，那这意味着什么呢？</p>
<p><strong>我们知道在 target 目录下得到的 xxx.jar 是打包阶段的产物，而 .m2 下面的是 install 的产物。</strong></p>
<blockquote>
<p>当然这里没有涉及到 <code>deploy</code> ，<code>deploy</code> 是 <code>install</code> 之后的操作，比如发布到远程仓库。</p>
</blockquote>
<p>现在再来看，因为 <code>sofa-ark-plugin-maven-plugin</code> 在执行 <code>install</code> 插件之前将 目标文件给替换了，所以导致打包生成的 <code>target</code> 目录下的 <code>xxx.jar</code> 和 安装到本地仓库的 <code>xxx.jar</code> 不一致。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文记录了日常的一个问题排查过程，包括两个小点，一个是如何去 debug maven 的插件，另外一个是简单了解下 maven 打包的生命周期。</p>
<blockquote>
<p>关于 maven 打包的生命周期的代码没有具体研究过，不过这里可以大概猜测下，就是 maven 在执行命令时，有个类似于中央控制器的东西，通过解析 maven 命令得到一个 LifeCycle 或者 一个 Pipeline （LifeCycle 或者 Pipeline 实际上就是组装了一系列的插件）。然后 LifeCycle 或者 Pipeline 启动执行，遍历插件，依次执行插件的 execute 方法。</p>
</blockquote>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2019/07/23/maven-debug/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2019/06/30/topic-jar-manifest-intro/">聊一聊 JAR 文件和 MANIFEST.MF</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2019-06-30T01:54:03.000Z" itemprop="datePublished">2019/06/30</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2019/06/30/topic-jar-manifest-intro/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/java/" title="java">java</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>在 JAVA 语言这个圈子里面摸爬滚打，除了对于语言层面和框架层面的学习之外，有一些东西它一直存在，但是确没有对它们有足够的重视，因为都觉得它是理所当然，比如 JAR 是个什么？</p>
<p>提到 JAR，最先可能想到的就是依赖，比如 fastjson.jar ，它可以作为依赖在项目中来引用，但是不能通过 java -jar 来执行，这种就是非可执行的 JAR。另外一种，比如我们项目打包之后生成的 JAR （当然也可能是 war），我们可以通过 java -jar 来运行程序，我们把它称之为可执行的 JAR。</p>
<p>JAR 作用大体可以分为以下几种：</p>
<ul>
<li>用于发布和使用类库</li>
<li>作为应用程序和扩展的构建单元</li>
<li>作为组件、applet 或者插件程序的部署单位</li>
<li>用于打包与组件相关联的辅助资源</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>JAR 文件是一种归档文件，以 ZIP 格式构建，以 .jar 为文件扩展名。用户可以使用 JDK 自带的 jar 命令创建或提取 JAR 文件。也可以使用其他 zip 压缩工具，不过压缩时 zip 文件头里的条目顺序很重要，因为 MANIFEST 文件常需放在首位。JAR 文件内的文件名是 Unicode 文本。</p>
<p>JAR 文件（Java 归档，英语：Java Archive）是一种软件包文件格式，通常用于聚合大量的 Java 类文件、相关的元数据和资源（文本、图片等）文件到一个文件，以便分发 Java 平台应用软件或库。</p>
<blockquote>
<p>以上来自维基百科 </p>
</blockquote>
<p>JAR 文件格式提供了许多优势和功能，其中很多是传统的压缩格式如 ZIP 或者 TAR 所没有提供的。它们包括：</p>
<ul>
<li>安全性：可以对 JAR 文件内容加上数字化签名。这样，能够识别签名的工具就可以有选择地为您授予软件安全特权，这是其他文件做不到的，它还可以检测代码是否被篡改过。</li>
<li>减少下载时间：如果一个 applet 捆绑到一个 JAR 文件中，那么浏览器就可以在一个 HTTP 事务中下载这个 applet 的类文件和相关的资源，而不是对每一个文件打开一个新连接。</li>
<li>压缩：JAR 格式允许您压缩文件以提高存储效率。</li>
<li>传输平台扩展。Java 扩展框架 (Java Extensions Framework) 提供了向 Java 核心平台添加功能的方法，这些扩展是用 JAR 文件打包的 (Java 3D 和 JavaMail 就是由 Sun 开发的扩展例子 )。</li>
<li>包密封：存储在 JAR 文件中的包可以选择进行 密封，以增强版本一致性和安全性。密封一个包意味着包中的所有类都必须在同一 JAR 文件中找到。</li>
<li>包版本控制：一个 JAR 文件可以包含有关它所包含的文件的数据，如厂商和版本信息。</li>
<li>可移植性：处理 JAR 文件的机制是 Java 平台核心 API 的标准部分。</li>
</ul>
<h2 id="JAR-文件格式"><a href="#JAR-文件格式" class="headerlink" title="JAR 文件格式"></a>JAR 文件格式</h2><p>这里分别给出两个 JAR 的解压之后的示例</p>
<h3 id="普通的-JAR-解压之后的文件目录"><a href="#普通的-JAR-解压之后的文件目录" class="headerlink" title="普通的 JAR 解压之后的文件目录"></a>普通的 JAR 解压之后的文件目录</h3><p>以 fastjson 为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── META-INF</span><br><span class="line">│   ├── LICENSE.txt</span><br><span class="line">│   ├── MANIFEST.MF</span><br><span class="line">│   ├── NOTICE.txt</span><br><span class="line">│   ├── maven</span><br><span class="line">│   │   └── com.alibaba</span><br><span class="line">│   │       └── fastjson</span><br><span class="line">│   │           ├── pom.properties</span><br><span class="line">│   │           └── pom.xml</span><br><span class="line">│   └── services</span><br><span class="line">│       ├── javax.ws.rs.ext.MessageBodyReader</span><br><span class="line">│       ├── javax.ws.rs.ext.MessageBodyWriter</span><br><span class="line">│       ├── javax.ws.rs.ext.Providers</span><br><span class="line">│       └── org.glassfish.jersey.internal.spi.AutoDiscoverable</span><br><span class="line">└── com</span><br><span class="line">    └── alibaba</span><br><span class="line">        └── fastjson</span><br><span class="line">            ├── JSON.class</span><br><span class="line">            ├── JSONArray.class</span><br><span class="line">            ├── JSONAware.class</span><br><span class="line">            ├── JSONException.class</span><br><span class="line">            ├── JSONObject.class</span><br><span class="line">            ....省略</span><br></pre></td></tr></table></figure></p>
<h3 id="可执行的-jar-以-SpringBoot-的-FAT-JAR-为例）"><a href="#可执行的-jar-以-SpringBoot-的-FAT-JAR-为例）" class="headerlink" title="可执行的 jar (以 SpringBoot 的 FAT JAR 为例）"></a>可执行的 jar (以 SpringBoot 的 FAT JAR 为例）</h3><p>这个 jar 是从 start.spring.io 上下载下来的一个最简单的 demo 打包来的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">├── BOOT-INF</span><br><span class="line">│   ├── classes</span><br><span class="line">│   │   ├── application.properties</span><br><span class="line">│   │   └── com</span><br><span class="line">│   │       └── example   # 应用的.class 文件目录</span><br><span class="line">│   │           └── demo</span><br><span class="line">│   │               └── DemoApplication.class</span><br><span class="line">│   └── lib # 这里存放的是应用的 Maven 依赖的jar包文件</span><br><span class="line">│       ├── javax.annotation-api-1.3.2.jar</span><br><span class="line">│       ├── jul-to-slf4j-1.7.26.jar</span><br><span class="line">│       ├── log4j-api-2.11.2.jar</span><br><span class="line">│       ├── log4j-to-slf4j-2.11.2.jar</span><br><span class="line">│       ├── logback-classic-1.2.3.jar</span><br><span class="line">│       ├── logback-core-1.2.3.jar</span><br><span class="line">│       ├── slf4j-api-1.7.26.jar</span><br><span class="line">│       ├── snakeyaml-1.23.jar</span><br><span class="line">│       ├── spring-aop-5.1.8.RELEASE.jar</span><br><span class="line">│       ├── spring-beans-5.1.8.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-2.1.6.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-autoconfigure-2.1.6.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-2.1.6.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-logging-2.1.6.RELEASE.jar</span><br><span class="line">│       ├── spring-context-5.1.8.RELEASE.jar</span><br><span class="line">│       ├── spring-core-5.1.8.RELEASE.jar</span><br><span class="line">│       ├── spring-expression-5.1.8.RELEASE.jar</span><br><span class="line">│       └── spring-jcl-5.1.8.RELEASE.jar</span><br><span class="line">├── META-INF</span><br><span class="line">│   ├── MANIFEST.MF</span><br><span class="line">│   └── maven</span><br><span class="line">│       └── com.example</span><br><span class="line">│           └── demo</span><br><span class="line">│               ├── pom.properties</span><br><span class="line">│               └── pom.xml</span><br><span class="line">└── org</span><br><span class="line">    └── springframework</span><br><span class="line">        └── boot</span><br><span class="line">            └── loader #存放的是 Spring boot loader 的 class 文件</span><br><span class="line">                ├── ExecutableArchiveLauncher.class</span><br><span class="line">                ├── JarLauncher.class</span><br><span class="line">                ├── LaunchedURLClassLoader$UseFastConnectionExceptionsEnumeration.class</span><br><span class="line">                ├── LaunchedURLClassLoader.class</span><br><span class="line">                ├── Launcher.class</span><br><span class="line">                ├── MainMethodRunner.class</span><br><span class="line">                ├── PropertiesLauncher$1.class</span><br><span class="line">                ├── PropertiesLauncher$ArchiveEntryFilter.class</span><br><span class="line">                ├── PropertiesLauncher$PrefixMatchingArchiveFilter.class</span><br><span class="line">                ├── PropertiesLauncher.class</span><br><span class="line">                ├── WarLauncher.class</span><br><span class="line">                ├── archive</span><br><span class="line">                │   ├── Archive$Entry.class</span><br><span class="line">                │   ├── ...</span><br><span class="line">                ├── data</span><br><span class="line">                │   ├── RandomAccessData.class</span><br><span class="line">                │   ├── ...</span><br><span class="line">                ├── jar</span><br><span class="line">                │   ├── AsciiBytes.class</span><br><span class="line">                │   ├── ...</span><br><span class="line">                └── util</span><br><span class="line">                    └── SystemPropertyUtils.class</span><br></pre></td></tr></table></figure>
<h2 id="META-INF"><a href="#META-INF" class="headerlink" title="META-INF"></a>META-INF</h2><p>大多数 JAR 文件包含一个 META-INF 目录，它用于存储包和扩展的配置数据，如安全性和版本信息。Java 2 平台（标准版【J2SE】）识别并解释 META-INF 目录中的下述文件和目录，以便配置应用程序、扩展和类装载器：</p>
<ul>
<li>MANIFEST.MF：这个 manifest 文件定义了与扩展和包相关的数据。</li>
<li>通过 MAVEN 插件打包进来的文件比如：<ul>
<li>maven</li>
<li>services ： 存储所有服务提供程序配置文件</li>
</ul>
</li>
<li>其他的还有一些不常看到的：<ul>
<li>INDEX.LIST ：这个文件由 jar工具的新选项 -i生成，它包含在应用程序或者扩展中定义的包的位置信息。它是 JarIndex 实现的一部分，并由类装载器用于加速类装载过程。 </li>
<li>.SF：这是 JAR 文件的签名文件</li>
<li>.DSA：与签名文件相关联的签名程序块文件，它存储了用于签名 JAR 文件的公共签名。</li>
<li>LICENSE.txt ：证书信息</li>
<li>NOTICE.txt ： 公告信息</li>
</ul>
</li>
</ul>
<h2 id="可执行的-JAR"><a href="#可执行的-JAR" class="headerlink" title="可执行的 JAR"></a>可执行的 JAR</h2><p> 可以执行的 JAR 与 普通的 JAR 最直接的区别就是能否通过 java -jar 来执行。</p>
<blockquote>
<p>一个 可执行的 jar文件是一个自包含的 Java 应用程序，它存储在特别配置的 JAR 文件中，可以由 JVM 直接执行它而无需事先提取文件或者设置类路径。要运行存储在非可执行的 JAR 中的应用程序，必须将它加入到您的类路径中，并用名字调用应用程序的主类。但是使用可执行的 JAR 文件，我们可以不用提取它或者知道主要入口点就可以运行一个应用程序。可执行 JAR 有助于方便发布和执行 Java 应用程序</p>
</blockquote>
<p> 一个可执行的 JAR 必须通过 menifest 文件的头引用它所需要的所有其他从属 JAR。如果使用了 -jar选项，那么环境变量 CLASSPATH 和在命令行中指定的所有类路径都被 JVM 所忽略。</p>
<h3 id="MANIFEST-MF-文件"><a href="#MANIFEST-MF-文件" class="headerlink" title="MANIFEST.MF 文件"></a>MANIFEST.MF 文件</h3><p>当我们用 JAR 命令打完包后，会在根目录下面创建 META-INF 目录，该目录下面会有一些对该 JAR 包信息的描述，其中肯定会有一个 MANIFEST.MF 文件，该文件包含了该 JAR 包的版本、创建人和类搜索路径等信息。</p>
<ul>
<li><p>FASTJSON jar 中的 MANIFEST.MF 文件</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0              # 用来定义manifest文件的版本</span><br><span class="line">Archiver-Version: Plexus Archiver  # 详见 http://codehaus-plexus.github.io/plexus-archiver/</span><br><span class="line">Built-By: wenshao                  # 构建者</span><br><span class="line">Created-By: Apache Maven 3.5.0  #  # 声明该文件的生成者，一般该属性是由 jar 命令行工具生成的</span><br><span class="line">Build-Jdk: 1.8.0_162               # 基于构建的 JDK 版本</span><br></pre></td></tr></table></figure>
</li>
<li><p>SpringBoot demo 的 MANIFEST.MF 文件</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Implementation-Title: demo                     # 定义了扩展实现的标题</span><br><span class="line">Implementation-Version: 0.0.1-SNAPSHOT         # 定义扩展实现的版本</span><br><span class="line">Start-Class: com.example.demo.DemoApplication  # 启动类</span><br><span class="line">Spring-Boot-Classes: BOOT-INF/classes/         # 编译之后的 class 文件目录</span><br><span class="line">Spring-Boot-Lib: BOOT-INF/lib/                 # 当前工程依赖的 jar 包目录</span><br><span class="line">Build-Jdk-Spec: 1.8                            # 指定的 JDK 版本</span><br><span class="line">Spring-Boot-Version: 2.1.6.RELEASE             # SpringBoot 版本</span><br><span class="line">Created-By: Maven Archiver 3.4.0             </span><br><span class="line">Main-Class: org.springframework.boot.loader.JarLauncher  # Main 函数</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在 Java 平台中， MANIFEST 文件是 JAR 归档中所包含的特殊文件，MANIFEST 文件被用来定义扩展或文件打包相关数据。</p>
<p>MANIFEST 文件作为一个元数据文件，它包含了不同部分中的 k-v 对数据。</p>
<p>如果一个 JAR 文件被当作可执行文件，则其中的 MANIFEST 文件需要指出该程序的主类文件，如上面案例中的 SpringBoot demo 的那个 jar 中的MANIFEST 文件所示 </p>
<h3 id="MANIFEST-作用"><a href="#MANIFEST-作用" class="headerlink" title="MANIFEST 作用"></a>MANIFEST 作用</h3><p>从 MANIFEST 文件中提供的信息大概可以了解到其基本作用</p>
<ul>
<li>JAR 包基本信息描述</li>
<li>Main-Class 指定程序的入口，这样可以直接用java -jar xxx.jar来运行程序</li>
<li>Class-Path 指定jar包的依赖关系，class loader会依据这个路径来搜索class</li>
</ul>
<h3 id="获取-MANIFEST-MF"><a href="#获取-MANIFEST-MF" class="headerlink" title="获取 MANIFEST.MF"></a>获取 MANIFEST.MF</h3><p>JDK 中提供了可以获取 jar 包中 MANIFEST.MF 文件信息的工具，可以通过 java.util.jar 这个类库来获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JarFile jar = <span class="keyword">new</span> JarFile(<span class="keyword">new</span> File(<span class="string">"/Users/glmapper/Documents/test/demo/target/demo-0.0.1-SNAPSHOT.jar"</span>));</span><br><span class="line">Manifest manifest = jar.getManifest();</span><br><span class="line">Attributes mainAttributes = manifest.getMainAttributes();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Object, Object&gt; attrEntry : mainAttributes.entrySet())&#123;</span><br><span class="line">    System.out.println(<span class="string">"main\t"</span>+attrEntry.getKey()+<span class="string">":"</span>+attrEntry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;String, Attributes&gt; entries = manifest.getEntries();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, Attributes&gt; entry : entries.entrySet()) &#123;</span><br><span class="line">    Attributes values = entry.getValue();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; attrEntry : values.entrySet()) &#123;</span><br><span class="line">        System.out.println(attrEntry.getKey() + <span class="string">":"</span> + attrEntry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main	Implementation-Title:demo</span><br><span class="line">main	Implementation-Version:0.0.1-SNAPSHOT</span><br><span class="line">main	Start-Class:com.example.demo.DemoApplication</span><br><span class="line">main	Spring-Boot-Classes:BOOT-INF/classes/</span><br><span class="line">main	Spring-Boot-Lib:BOOT-INF/lib/</span><br><span class="line">main	Build-Jdk-Spec:1.8</span><br><span class="line">main	Spring-Boot-Version:2.1.6.RELEASE</span><br><span class="line">main	Created-By:Maven Archiver 3.4.0</span><br><span class="line">main	Manifest-Version:1.0</span><br><span class="line">main	Main-Class:org.springframework.boot.loader.JarLauncher</span><br></pre></td></tr></table></figure></p>
<h2 id="Jar-文件和-Manifest-在-java-中的定义"><a href="#Jar-文件和-Manifest-在-java-中的定义" class="headerlink" title="Jar 文件和 Manifest 在 java 中的定义"></a>Jar 文件和 Manifest 在 java 中的定义</h2><p>下面为 JarFile 的定义，从代码就可以看出，前面我们所介绍的 Jar 是以 ZIP 格式构建一种归档文件，因为它是 ZipFile 的子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JarFile</span> <span class="keyword">extends</span> <span class="title">ZipFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SoftReference&lt;Manifest&gt; manRef;</span><br><span class="line">    <span class="keyword">private</span> JarEntry manEntry;</span><br><span class="line">    <span class="keyword">private</span> JarVerifier jv;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> jvInitialized;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> verify;</span><br><span class="line">    <span class="comment">//指示是否存在Class-Path属性（仅当hasCheckedSpecialAttributes为true时才有效）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasClassPathAttribute;</span><br><span class="line">    <span class="comment">// 如果清单检查特殊属性，则为 true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> hasCheckedSpecialAttributes;</span><br><span class="line">    <span class="comment">// 在SharedSecrets中设置JavaUtilJarAccess</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SharedSecrets.setJavaUtilJarAccess(<span class="keyword">new</span> JavaUtilJarAccessImpl());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The JAR manifest file name.（JAR清单文件名）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MANIFEST_NAME = <span class="string">"META-INF/MANIFEST.MF"</span>;</span><br><span class="line">    <span class="comment">// 省略其他</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是 Manifest 类的定义，用来描述 JAR 的 清单文件。从其属性中也很好的观察到，其存储的就是 K-V 键值对数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manifest</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// manifest main attributes</span></span><br><span class="line">    <span class="keyword">private</span> Attributes attr = <span class="keyword">new</span> Attributes();</span><br><span class="line">    <span class="comment">// manifest entries</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Attributes&gt; entries = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 省略其他</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>JAR 格式远远超出了一种压缩格式，它有许多可以改进效率、安全性和组织 Java 应用程序的功能。因为这些功能已经建立在核心平台 – 包括编译器和类装载器 – 中了，所以开发人员可以利用 JAR 文件格式的能力简化和改进开发和部署过程。</p>
<h2 id="附：常见的-jar工具用法"><a href="#附：常见的-jar工具用法" class="headerlink" title="附：常见的 jar工具用法"></a>附：常见的 jar工具用法</h2><table>
<thead>
<tr>
<th style="text-align:left">功能</th>
<th style="text-align:left">命令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">用一个单独的文件创建一个 JAR 文件</td>
<td style="text-align:left">jar cf jar-file input-file…</td>
</tr>
<tr>
<td style="text-align:left">用一个目录创建一个 JAR 文件</td>
<td style="text-align:left">jar cf jar-file dir-name</td>
</tr>
<tr>
<td style="text-align:left">创建一个未压缩的 JAR 文件</td>
<td style="text-align:left">jar cf0 jar-file dir-name</td>
</tr>
<tr>
<td style="text-align:left">更新一个 JAR 文件</td>
<td style="text-align:left">jar uf jar-file input-file…</td>
</tr>
<tr>
<td style="text-align:left">查看一个 JAR 文件的内容</td>
<td style="text-align:left">jar tf jar-file</td>
</tr>
<tr>
<td style="text-align:left">提取一个 JAR 文件的内容</td>
<td style="text-align:left">jar xf jar-file</td>
</tr>
<tr>
<td style="text-align:left">从一个 JAR 文件中提取特定的文件</td>
<td style="text-align:left">jar xf jar-file archived-file…</td>
</tr>
<tr>
<td style="text-align:left">运行一个打包为可执行 JAR 文件的应用程序</td>
<td style="text-align:left">java -jar app.jar</td>
</tr>
</tbody>
</table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-jar/index.html" target="_blank" rel="noopener">JAR 文件揭密</a></li>
<li><a href="https://zh.wikipedia.org/wiki/JAR_(%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F" target="_blank" rel="noopener">JAR</a>)</li>
<li><a href="https://docs.oracle.com/javase/6/docs/technotes/guides/jar/jar.html" target="_blank" rel="noopener">JAR File Specification</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2019/06/30/topic-jar-manifest-intro/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2019/04/29/cas-several-qa/">并发编程-关于 CAS 的几个问题</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2019-04-29T02:25:57.000Z" itemprop="datePublished">2019/04/29</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2019/04/29/cas-several-qa/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/java/" title="java">java</a>,
  
    <a href="/tags/cas/" title="cas">cas</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<h2 id="CAS-相关基础知识"><a href="#CAS-相关基础知识" class="headerlink" title="CAS 相关基础知识"></a>CAS 相关基础知识</h2><p>CAS的全称是Compare And Swap ,即比较交换。CAS 中一般会设计到3个参数:</p>
<ul>
<li>内存值 V</li>
<li>旧的预期值A</li>
<li>要修改的新值B</li>
</ul>
<p>当且仅当预期值 A 和内存值 V 相同时，将内存值V修改为 B，否则什么都不做。</p>
<blockquote>
<p>这里关于 CPU 指令对于 CAS 的支持不深入研究,有兴趣的可以自行了解。</p>
</blockquote>
<h2 id="CAS-几个问题"><a href="#CAS-几个问题" class="headerlink" title="CAS 几个问题"></a>CAS 几个问题</h2><p>很多书籍和文章中都有提出它存在的几个问题：</p>
<ul>
<li>1、循环时间长开销很大</li>
<li>2、只能保证一个共享变量的原子操作</li>
<li>3、ABA 问题</li>
</ul>
<p>下面就这三个问题展开来聊一下。</p>
<h3 id="1、关于“循环时间长开销很大”的疑惑与验证"><a href="#1、关于“循环时间长开销很大”的疑惑与验证" class="headerlink" title="1、关于“循环时间长开销很大”的疑惑与验证"></a>1、关于“循环时间长开销很大”的疑惑与验证</h3><p>自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的开销。但是真的是这样吗？到底多大的并发量才造成 CAS 的自旋次数会增加呢？另外，对于当前的机器及JDK，在无锁，无CAS 的情况下，是否对于结果的影响是真的那么明显呢？对于这个问题，下面做了一个简单的测试，但是测试结果也只是针对在我本地环境下，各位看官可以拉一下代码，在自己电脑上 run 一下，把机器信息、JDK版本以及测试结果留言到评论区。</p>
<blockquote>
<p>本文案例可以这里获取：<a href="https://github.com/glmapper/glmapper-blog-samples/tree/master/glmapper-blog-sample-cas" target="_blank" rel="noopener">glmapper-blog-sample-cas</a></p>
</blockquote>
<p>这里我是用了一个很简单的案例，就是整数自增。使用了两种方式去测试的，一种是无锁，也不用 CAS 操作，另外一种是基于 CAS 的方式。（关于加锁的方式没有验证，有时间再补充吧~）</p>
<h4 id="计数器类"><a href="#计数器类" class="headerlink" title="计数器类"></a>计数器类</h4><p>计数器里面有两个方法，一种是CAS 自旋方式，一种是直接自增。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> AtomicInteger safeCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> unsafe = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 使用自旋的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">safeCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = safeCount.get();</span><br><span class="line">            <span class="keyword">boolean</span> success = safeCount.compareAndSet(i,++i);</span><br><span class="line">            <span class="keyword">if</span> (success)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 普通方式自增</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsafeCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        unsafe++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="模拟并发"><a href="#模拟并发" class="headerlink" title="模拟并发"></a>模拟并发</h4><p>这里我们模拟使用 1000 个线程，执行 30 次来看下结果，包括总耗时和结果的正确性。</p>
<ul>
<li><p>CAS 方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testSafe</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 实例化一个 Counter 计数器对象</span></span><br><span class="line">    Counter counter = <span class="keyword">new</span> Counter();</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(testCounts);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ;i &lt; testCounts;i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="comment">// 调用 safeCount 方法</span></span><br><span class="line">                counter. safeCount();</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    <span class="comment">// 结束时间</span></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    safeTotalCostTime += (end-start);</span><br><span class="line">    <span class="keyword">return</span> counter.safeCount.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>普通方式</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testUnSafe</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 实例化一个 Counter 计数器对象</span></span><br><span class="line">    Counter counter = <span class="keyword">new</span> Counter();</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(testCounts);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt; testCounts;i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">// 调用 unsafeCount 方法</span></span><br><span class="line">            counter.unsafeCount();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    <span class="comment">// 结束时间</span></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    unsafeTotalCostTime += (end-start);</span><br><span class="line">    <span class="keyword">return</span> counter.unsafe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>main 方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    // 执行 300 次</span><br><span class="line">    for (int i =0 ;i&lt; 300;i++)&#123;</span><br><span class="line">        // 普通方式</span><br><span class="line">        int unSafeResult = testUnSafe();</span><br><span class="line">        // cas 方式</span><br><span class="line">        int safeResult = testSafe();</span><br><span class="line">        // 结果验证，若果正确就将成功次数增加</span><br><span class="line">        if (unSafeResult == testCounts)&#123;</span><br><span class="line">            totalUnSafeCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 同上</span><br><span class="line">        if (safeResult == testCounts)&#123;</span><br><span class="line">            totalSafeCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;test count = &quot; + testCounts);</span><br><span class="line">    System.out.println(&quot;非安全计数器正确个数 = &quot; + totalUnSafeCount);</span><br><span class="line">    System.out.println(&quot;非安全计数器耗时 = &quot; + unsafeTotalCostTime);</span><br><span class="line">    System.out.println(&quot;安全计数器正确个数 = &quot; + totalSafeCount);</span><br><span class="line">    System.out.println(&quot;安全计数器耗时 = &quot; + safeTotalCostTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我的机器信息如下：</p>
<ul>
<li>MacBook Pro (Retina, 15-inch, Mid 2015)</li>
<li>处理器：2.2 GHz Intel Core i7</li>
<li>内存：16 GB 1600 MHz DDR3</li>
</ul>
<p>下面是一些测试数据。</p>
<h4 id="1000-线程数-300-次数"><a href="#1000-线程数-300-次数" class="headerlink" title="1000(线程数) * 300(次数)"></a>1000(线程数) * 300(次数)</h4><p>测试结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test count = 1000</span><br><span class="line">非安全计数器正确个数 = 300</span><br><span class="line">非安全计数器耗时 = 27193</span><br><span class="line">安全计数器正确个数 = 300</span><br><span class="line">安全计数器耗时 = 26337</span><br></pre></td></tr></table></figure></p>
<p>居然发现不使用 CAS 的方式居然比使用自旋 CAS 的耗时要高出将近 1s。另外一个意外的点，我尝试了好几次，不使用 CAS 的情况得到的结果正确率基本也是 4 个 9  以上的比率，极少数会出现计算结果错误的情况。</p>
<h4 id="3000-线程数-30-次数"><a href="#3000-线程数-30-次数" class="headerlink" title="3000(线程数) * 30(次数)"></a>3000(线程数) * 30(次数)</h4><p>测试结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test count = 3000</span><br><span class="line">非安全计数器正确个数 = 30</span><br><span class="line">非安全计数器耗时 = 7816</span><br><span class="line">安全计数器正确个数 = 30</span><br><span class="line">安全计数器耗时 = 8073</span><br></pre></td></tr></table></figure></p>
<p>这里看到在耗时上已经很接近了。这里需要考虑另外一个可能影响的点是，因为 testUnSafe 是 testSafe 之前执行的，“JVM 和 机器本身热身” 影响耗时虽然很小，但是也存在一定的影响。</p>
<h4 id="5000-线程数-30-次数"><a href="#5000-线程数-30-次数" class="headerlink" title="5000(线程数) * 30(次数)"></a>5000(线程数) * 30(次数)</h4><p>测试结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test count = 5000</span><br><span class="line">非安全计数器正确个数 = 30</span><br><span class="line">非安全计数器耗时 = 23213</span><br><span class="line">安全计数器正确个数 = 30</span><br><span class="line">安全计数器耗时 = 14161</span><br></pre></td></tr></table></figure></p>
<p>随着并发量的增加，这里奇怪的是，普通自增方式所消耗的时间要高于CAS方式消耗的时间将近 8-9s 。</p>
<p>当尝试 10000 次时，是的你没猜错，抛出了 OOM 。但是从执行的结果来看，并没有说随着并发量的增大，普通方式错误的概率会增加，也没有出现预想的 CAS 方式的耗时要比 普通模式耗时多。</p>
<blockquote>
<p>由于测试样本数据比较单一，对于测试结果没法做结论，欢迎大家将各自机器的结果提供出来，以供参考。另外就是，最近看到很多面试的同学，如果有被问道这个问题，还是需要谨慎考虑下。关于是否“打脸”还是“被打脸”还需要更多的测试结果。</p>
</blockquote>
<h3 id="CAS-到底是怎么操作的"><a href="#CAS-到底是怎么操作的" class="headerlink" title="CAS 到底是怎么操作的"></a>CAS 到底是怎么操作的</h3><ul>
<li>CPU 指令</li>
<li>Unsafe 类 </li>
</ul>
<h3 id="2、ABA-问题的简单复现"><a href="#2、ABA-问题的简单复现" class="headerlink" title="2、ABA 问题的简单复现"></a>2、ABA 问题的简单复现</h3><p>网上关于 CAS 讨论另外一个点就是 CAS 中的 ABA 问题，相信大多数同学在面试时如果被问到 CAS ，那么 ABA 问题也会被问到，然后接着就是怎么避免这个问题，是的套路就是这么一环扣一环的。</p>
<p>我相信 90% 以上的开发人员在实际的工程中是没有遇到过这个问题的，即使遇到过，在特定的情况下也是不会影响到计算结果。但是既然这个问题会被反复提到，那就一定有它导致 bug 的场景，找了一个案例供大家参考：<a href="https://blog.csdn.net/wufaliang003/article/details/78797203" target="_blank" rel="noopener">CAS下ABA问题及优化方案</a> 。</p>
<p>这里先不去考虑怎么去规避这个问题，我们想怎么去通过简单的模拟先来复现这个 ABA 问题。其实这个也很简单，如果你对线程交叉、顺序执行了解的话。</p>
<h3 id="如何实现多线程的交叉执行"><a href="#如何实现多线程的交叉执行" class="headerlink" title="如何实现多线程的交叉执行"></a>如何实现多线程的交叉执行</h3><p>这个点实际上也是一个在面试过程中很常见的一个基础问题，我在提供的代码中给了三种实现方式，有兴趣的同学可以拉代码看下。</p>
<p>下面以 lock 的方式来模拟下这个场景，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionAlternateTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计数器</span></span><br><span class="line">    <span class="keyword">public</span> AtomicInteger safeCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// lock</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// condition 1/2/3 用于三个线程触发执行的条件</span></span><br><span class="line">    Condition c1 = lock.newCondition();</span><br><span class="line">    Condition c2 = lock.newCondition();</span><br><span class="line">    Condition c3 = lock.newCondition();</span><br><span class="line">    <span class="comment">// 模拟并发执行</span></span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 线程1 ，A </span></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (count % <span class="number">3</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            safeCount.compareAndSet(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"thread1:"</span>+safeCount.get());</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 唤醒条件2</span></span><br><span class="line">            c2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">     <span class="comment">// 线程2 ，B </span></span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (count % <span class="number">3</span> != <span class="number">1</span>)&#123;</span><br><span class="line">                c2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            safeCount.compareAndSet(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">"thread2:"</span>+safeCount.get());</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 唤醒条件3</span></span><br><span class="line">            c3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 线程2 ，A</span></span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (count % <span class="number">3</span> != <span class="number">2</span>)&#123;</span><br><span class="line">                c3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            safeCount.compareAndSet(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"thread3:"</span>+safeCount.get());</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 唤醒条件1</span></span><br><span class="line">            c1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 启动启动线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        t3.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ConditionAlternateTest test = <span class="keyword">new</span> ConditionAlternateTest();</span><br><span class="line">        test.threadStart();</span><br><span class="line">        test.countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread1:<span class="number">1</span></span><br><span class="line">thread2:<span class="number">0</span></span><br><span class="line">thread3:<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>上面线程交叉的案例实际上并不是严格意义上的 ABA 问题的复现，这里仅是模拟下产生的一个最简单的过程。如果大家有好的案例，也可以分享一下。</p>
<h3 id="ABA-问题解决"><a href="#ABA-问题解决" class="headerlink" title="ABA 问题解决"></a>ABA 问题解决</h3><p>常见实践：“版本号”的比对，一个数据一个版本，版本变化，即使值相同，也不应该修改成功。</p>
<p>java 中提供了 AtomicStampedReference 这个类来解决这个 ABA 问题。<br>AtomicStampedReference 原子类是一个带有时间戳的对象引用，在每次修改后，AtomicStampedReference 不仅会设置新值而且还会记录更改的时间。当 AtomicStampedReference 设置对象值时，对象值以及时间戳都必须满足期望值才能写入成功，这也就解决了反复读写时，无法预知值是否已被修改的窘境。</p>
<p>实现代码这里就不贴了，基于前面的代码改造，下面贴一下运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread1,第一次修改;值为=1</span><br><span class="line">thread2,已经改回为原始值;值为=0</span><br><span class="line">thread3,第二次修改;值为=1</span><br></pre></td></tr></table></figure></p>
<h3 id="3、只能保证一个共享变量的原子操作"><a href="#3、只能保证一个共享变量的原子操作" class="headerlink" title="3、只能保证一个共享变量的原子操作"></a>3、只能保证一个共享变量的原子操作</h3><p>当对一个共享变量执行操作时，我们可以使用 CAS 的方式来保证原子操作，但是对于对多个变量操作时，循环 CAS 就无法保证操作的原子性了，那么这种场景下，我们就需要使用加锁的方式来解决。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2019/04/29/cas-several-qa/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/java-up-juc2/">JUC·ThreadPoolExecutor 线程池</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T06:17:41.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/java-up-juc2/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/java/" title="java">java</a>,
  
    <a href="/tags/线程/" title="线程">线程</a>,
  
    <a href="/tags/thread/" title="thread">thread</a>,
  
    <a href="/tags/并发编程/" title="并发编程">并发编程</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>ThreadPoolExecutor算是JUC中最常用的类之一了。ThreadPoolExecutor，顾名思义，thread-pool-executor,硬翻译就是“线程-池-执行者”；java中，通过ThreadPoolExecutor可以很容易的创建一个线程池。但是我们为什么要使用线程池？呢？它能够带来什么样的优势呢？它又是怎么实现的呢？OK，带着这几个问题，我们来学习一下JAVA中的线程池技术。</p>
<h2 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h2><p>关于这个问题其实有点鸡肋，我觉得再问这个问题之前更应该问为什么要有线程池。那为什么呢?</p>
<hr>
<p>this is a 例子：</p>
<p><code>快递行业最近两年发展的灰常火热，听说工资也非常的高，搞得我一天天的都没有心思去好好写代码了...</code></p>
<p><code>之前的小快递公司都是没有固定的快递员的，就是说，每次去送一件快递，站点负责人就需要去找一个人来帮忙送，送完之后就没有然后了(当然，钱还是要给的)。</code></p>
<p><code>但是后来随着货越来越多，找人给钱成本太大，而且农忙时还需要花很长时间去找人，所以就雇用了5个人，签了合同，长期为站点配送。</code></p>
<p>以前都是随时用随时找，现在不是，现在是成立了一个物流公司，开了一个配送部，配送部门规定正式配送员最多只能有五个人。</p>
<p><strong>之前配送的缺点是什么：</strong></p>
<ul>
<li>每次有货，我都会去临时找一个人，然后签订临时合同，送完之后解除合同。很麻烦。<br>这也是不用线程池的缺点，就是任务来了，我们需要频繁的去创建新的线程，用完之后还需要释放线程资源，对于系统的消耗是很大的。</li>
<li>因为配送的货车只有那么几个，如果临时签订的人多了，车子不够用，其他人只能等着车子送完之后才能用。</li>
</ul>
<p><strong>成立配送部之后解决的问题</strong></p>
<ul>
<li>成立配送部之后呢，因为签订的是劳务合同，我们可以重复的让配送员配送不同的货物。达到线程资源的复用。</li>
<li>因为限定了最多招聘的人数，可以很好的避免招过多无用的人。</li>
</ul>
<hr>
<p>OK，我们以上述例子来对应理解线程池的基本原理</p>
<p>先来看下，JAVA对ThreadPoolExecutor的类申明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span></span><br></pre></td></tr></table></figure>
<p>在<a href="https://juejin.im/post/5a7578a05188257a59119951" target="_blank" rel="noopener">【初识】-JUC·Executor框架</a>中给出了Executor的继承体系。ThreadPoolExecutor就是具备线程池功能的集成者。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法一</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">                          </span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">         </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//构造方法二</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         threadFactory, defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造方法三</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造方法四</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出，构造方法（一、二、三）都是通过调用（四）来做具体属性初始化的。那么我们直接来看构造方法四；在构造方法四中总共需要7个参数，先来看下每个参数的具体含义：</p>
<ul>
<li><p>corePoolSize</p>
<p>  核心线程数大小。那么什么是核心线程数呢，我们可以类比于上面例子中的配送部中签订劳动合同的人的个数。</p>
</li>
<li><p>maximumPoolSize</p>
<p>  最大线程数。加入说现在是双十一期间，快递异常的多，配送部的5个人完全忙不过来，而且仓库也满了，怎么办呢？这个时候就需要再招聘一些临时配送员，假设maximumPoolSize为10，那么也就是说，临时招聘可以招5个人，配送部签订正式劳动合同的人和签订临时合同的人加一块不能超过配送部规定的最大人数（10人）。所以说，maximumPoolSize就是线程池能够允许的存在的最大线程的数量。</p>
</li>
<li><p>keepAliveTime</p>
<p>  存活时间。为什么要有这个呢？想一下，双十一过去了，货物已经配送的差不多了。临时合同写的是如果临时配送员2天没有配送了，那配送部就有权利终止临时合同，现在已经达到2天这个点了，需要开除这些临时配送专员了。对于线程池来说，keepAliveTime就是用来表示，当除核心线程池之外的线程超过keepAliveTime时间之后，就需要被系统回收了。</p>
</li>
<li><p>unit</p>
<p>  keepAliveTime的时间单位。</p>
</li>
<li><p>workQueue</p>
<p>  工作队列。这个就相当于一个仓库，现在配送部5个人都在配送，但是还不断的有新的快递达到，这个时候就需要一个仓库来存放这些快递。对于线程池来说，当核心线程都有自己的任务处理，并且还有任务进来的时候，就会将任务添加到工作队列中去。</p>
</li>
<li><p>threadFactory</p>
<p>  线程工厂。就是用来创建线程的。可以类比成招聘组，会给每个线程分配名字或者编号这样。</p>
</li>
<li><p>handler</p>
<p>  RejectedExecutionHandler 用来描述拒绝策略的。假设现在我的仓库也满足，并且配送部已经达到10个人了。怎么办呢，那么只能采用一些策略来拒绝任务了。</p>
<h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="comment">//RUNNING；该状态的线程池接收新任务，并且处理阻塞队列中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//SHUTDOWN；该状态的线程池不接收新任务，但会处理阻塞队列中的任务；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//STOP；不接收新任务，也不处理阻塞队列中的任务，并且会中断正在运行的任务；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//线程池彻底终止，就变成TERMINATED状态。 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>
<p>下面是在网上发现的一位大牛的图；感觉可以较为直观的描述状态的变更</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/7/161702fd7393291e?w=1033&amp;h=406&amp;f=jpeg&amp;s=82514" alt=""></p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616ff08ec07b0e9?w=543&amp;h=443&amp;f=png&amp;s=136351" alt="线程池执行原理"></p>
<p>有几个点需要注意。</p>
<h3 id="1、如何提交一个任务到线程池？"><a href="#1、如何提交一个任务到线程池？" class="headerlink" title="1、如何提交一个任务到线程池？"></a>1、如何提交一个任务到线程池？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//任务为null,直接抛出空指针异常</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//如果线程数大于等于基本线程数，将任务加入队列</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果少于corePoolSize线程正在运行，请尝试使用给定命令启动一个新线程作为其第一个任务。 对addWorker的调用会自动检查runState和workerCount，从而防止错误报警，在不应该的时候通过返回false来添加线程。</li>
<li>如果一个任务能够成功排队，那么我们仍然需要再次检查是否应该添加一个线程（因为现有的线程自上次检查以来已经死掉）或者自从进入这个方法以来，池关闭了。所以我们重新检查状态，如果当前command已经stop了，那么就退出工作队列，如果没有的话就开始一个新的线程。</li>
<li>如果队列满了，会想尝试去创建一个新的线程去执行，如果创建不了，那就执行拒绝策略。</li>
</ul>
<h3 id="2、如何创建一个线程去处理任务？"><a href="#2、如何创建一个线程去处理任务？" class="headerlink" title="2、如何创建一个线程去处理任务？"></a>2、如何创建一个线程去处理任务？</h3><p>通过实现这个接口去创建一个新的线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、如何将任务添加到队列？"><a href="#3、如何将任务添加到队列？" class="headerlink" title="3、如何将任务添加到队列？"></a>3、如何将任务添加到队列？</h3><p>通过addWorker方法来添加，其实在excute中只是作为一个提交任务的入口，实际的处理逻辑都是在addWorker这个方法里来完成的。addWorker有两个参数：</p>
<ul>
<li>firstTask 当前任务</li>
<li>core 用来标注当前需要创建的线程是否是核心线程，如果core为true，则表明创建的是核心线程，也就是说当前还没有达到最大核心线程数。</li>
</ul>
<p>先来看下这个方法的前半部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">//自旋方式</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取当前线程池的状态</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//如果状态是STOP，TIDYING,TERMINATED状态的话，则会返回false</span></span><br><span class="line">        <span class="comment">//如果状态是SHUTDOWN，但是firstTask不为空或者workQueue为空的话，那么直接返回false。</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//通过自旋的方式，判断要添加的worker是否为corePool范畴之内的</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>//如果超过CAPACITY限制了则直接返回false<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc &gt;= CAPACITY</span><br></pre></td></tr></table></figure></p>
<p>//判断当前的workerCount是否大于corePoolsize，否则则判断是否大于maximumPoolSize<br>//具体的比较取决于入参core是true还是false。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc &gt;= (core ? corePoolSize : maximumPoolSize)</span><br></pre></td></tr></table></figure></p>
<p>如果上面两个有一个满足了，则直接返回false。</p>
<p>下面是判断WorkerCount通过CAS操作增加1是否成功，成功的话就到此结束<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">    <span class="keyword">break</span> retry;</span><br></pre></td></tr></table></figure></p>
<p>如果不成功，则再次判断当前线程池的状态，如果现在获取到的状态与进入自旋的状态不一致的话，那么则通过continue retry重新进行状态的判断。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line"><span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">    <span class="keyword">continue</span> retry;</span><br></pre></td></tr></table></figure></p>
<p><br><br>再来看下这个方法的后面半个部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">Worker w = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    <span class="comment">//创建一个新的Worker对象</span></span><br><span class="line">    w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">    <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在锁定的情况下重新检查。</span></span><br><span class="line">            <span class="comment">// 在一下情况退出：ThreadFactory 创建失败或者在获取锁之前shut down了</span></span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">           <span class="comment">//状态校验</span></span><br><span class="line">            <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.isAlive()) <span class="comment">// 预先检查t是可以启动的</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                <span class="comment">//添加至workers中</span></span><br><span class="line">                workers.add(w);</span><br><span class="line">                <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                <span class="comment">//如果超过了历史最大线程数，则将当前池数量设置为历史最大线程记录数</span></span><br><span class="line">                <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                    largestPoolSize = s;</span><br><span class="line">                <span class="comment">//标识添加工作线程成功</span></span><br><span class="line">                workerAdded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果添加成功则启动当前工作线程</span></span><br><span class="line">        <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">            <span class="comment">//并将当前线程状态设置为已启动</span></span><br><span class="line">            workerStarted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//添加失败</span></span><br><span class="line">    <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">        addWorkerFailed(w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拒绝策略有哪些？"><a href="#拒绝策略有哪些？" class="headerlink" title="拒绝策略有哪些？"></a>拒绝策略有哪些？</h3><p><img src="https://user-gold-cdn.xitu.io/2018/2/7/16170281c265a605?w=591&amp;h=155&amp;f=png&amp;s=75622" alt=""></p>
<ul>
<li>1、AbortPolicy：直接抛出异常，默认策略；</li>
<li>2、CallerRunsPolicy：使用调用者自己的当前线程来执行任务；</li>
<li>3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li>4、DiscardPolicy：直接丢弃任务；</li>
</ul>
<p>当然我们也可以自定义拒绝策略。</p>
<h3 id="常用工作队列类型"><a href="#常用工作队列类型" class="headerlink" title="常用工作队列类型"></a>常用工作队列类型</h3><p><strong>1、ArrayBlockingQueue</strong></p>
<p>基于数组的阻塞队列，长度有限</p>
<p><strong>2、LinkedBlockingQuene</strong></p>
<p>基于链表的阻塞队列，长度无限，使用这个可能会导致我们的拒绝策略失效。因为可以无限的创建新的工作线程。</p>
<p><strong>3、PriorityBlockingQueue</strong></p>
<p>具有优先级的无界阻塞队列；</p>
<p><strong>3、SynchronousQuene</strong></p>
<p>SynchronousQuene是一个是一个不存储元素的BlockingQueue；每一个put操作必须要等待一个take操作，否则不能继续添加元素。所以这个比较特殊，它不存我们的任务，也就说说它的每个put操作必须等到另一个线程调用take操作，否则put操作一直处于阻塞状态。</p>
<h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><p>这个是ThreadPoolExecutor的一个内部类，表示一个工作线程。重要的是这个内部类实现了AbstractQueuedSynchronizer（AQS:抽象队列同步器）抽象类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当前work持有的线程 */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** 运行的初始任务。 可能为空。*/</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** 每个线程完成任务的计数器 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">    <span class="comment">// 禁止中断，直到runWorker</span></span><br><span class="line">        setState(-<span class="number">1</span>); </span><br><span class="line">        <span class="comment">//想提交的任务交给当前工作线程</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">//通过线程工厂创建一个新的线程</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将run方法的执行委托给外部runWorker */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否锁定</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 0代表解锁状态。</span></span><br><span class="line">    <span class="comment">// 1代表锁定状态。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试获取锁（重写AQS的方法）</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试释放锁（重写AQS的方法）</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">//尝试加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">//是否锁定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line">    <span class="comment">//如果启动则中断</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h2><p>最后来看下runWorker这个方法（ThreadPoolExecutor中的方法）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = null;</span><br><span class="line">    w.unlock(); // allow interrupts</span><br><span class="line">    boolean completedAbruptly = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            // If pool is stopping, ensure thread is interrupted;</span><br><span class="line">            // if not, ensure thread is not interrupted.  This</span><br><span class="line">            // requires a recheck in second case to deal with</span><br><span class="line">            // shutdownNow race while clearing interrupt</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    thrown = x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                task = null;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>下面是对注释的蹩脚翻译，欢迎吐槽，但注意尺度，O(∩_∩)O哈哈~</code></p>
<p>主要工作循环运行。重复地从队列中获取任务并执行它们，同时处理一些问题: </p>
<ul>
<li>我们可能会从最初的任务开始，在这种情况下，我们不需要得到第一个任务。否则，只要池正在运行，我们就从getTask获得任务。 如果它返回null，则由于更改池状态或配置参数而导致worker退出。其他退出的结果是在外部代码中抛出的异常，在这种情况下completeAbruptly成立，这通常会导致processWorkerExit来取代这个线程。</li>
<li>在运行任何任务之前，获取锁以防止任务正在执行时发生其他池中断，调用clearInterruptsForTaskRun确保除非池正在停止，则此线程没有设置其中断。</li>
<li>每个任务运行之前都会调用beforeExecute，这可能会引发一个异常，在这种情况下，我们会导致线程死亡（断开循环completeAbruptly为true），而不处理任务。</li>
<li>假设beforeExecute正常完成，我们运行任务，收集任何抛出的异常发送到afterExecute。 我们分别处理RuntimeException，Error（这两个规范保证我们陷阱）和任意的Throwables。 因为我们不能在Runnable.run中重新抛出Throwable，所以我们把它们封装在Errors中（到线程的UncaughtExceptionHandler）。 任何抛出的异常也保守地导致线程死亡。</li>
<li>task.run完成后，我们调用afterExecute，这也可能会抛出一个异常，这也会导致线程死亡。 根据JLS Sec 14.20，即使task.run抛出，这个异常也是有效的。</li>
</ul>
<p>异常机制的最终效果是afterExecute和线程的UncaughtExceptionHandler拥有关于用户代码遇到的任何问题的准确信息。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文是JUC的第二篇，意在通过查看源码来了解线程池的具体工作原理。文中如果存在不当的描述，希望小伙伴们能够及时提出。灰常感谢！</p>
<p><code>欢迎关注微信公众号，干货满满哦~</code><br><img src="https://user-gold-cdn.xitu.io/2018/2/7/161704e6a5057ad6?w=258&amp;h=258&amp;f=jpeg&amp;s=15516" alt=""></p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/java-up-juc2/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/java-up-juc1/">JUC·Executor 框架</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T06:16:22.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/java-up-juc1/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/java/" title="java">java</a>,
  
    <a href="/tags/线程/" title="线程">线程</a>,
  
    <a href="/tags/thread/" title="thread">thread</a>,
  
    <a href="/tags/并发编程/" title="并发编程">并发编程</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>多线程和并发这两个东西真的是向往已久，总是有一种神秘的感觉，想去探索一波，又担心水平不够无法驾驭。想以读书笔记的方式来写，但是又觉得缺少自己的一些思考；但是在没有足够并发编程经验的情况下又没法去写出很深刻的东西，毕竟没有踩过坑。所以在阅读spring源码的同时，也想抽点时间来看一看JUC的东西，关于这块只能说是记录自己学习JUC的一个过程，尝试用一些具体的代码demo来加深理解。所以就把本系列写成《【 初识】-JUC·XXXX》，用来让自己打开并发编程的大门。</p>
<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><p>JUC即java.util.concurrent；也就是java提供的并发包。JUC中从包结构上来看主要是：</p>
<ul>
<li><p>java.util.concurrent</p>
<p>  在这个包下面主要是线程池、并发集合以及一些并发工具类。线程池相关是围绕Excetor框架来构建；这也是本文下面部分的重点。</p>
</li>
<li><p>java.util.concurrent.atomic</p>
<p>  这个包下面是一些原子操作类，算是并发辅助工具类，基本实现依赖于CAS；</p>
</li>
<li><p>java.util.concurrent.locks</p>
<p>  这个从名字就可以知道它的作用，就是提供锁。</p>
</li>
</ul>
<h2 id="JUC各个模块的类"><a href="#JUC各个模块的类" class="headerlink" title="JUC各个模块的类"></a>JUC各个模块的类</h2><ul>
<li>整体框架</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/6/16169e20a66c9495?w=533&amp;h=297&amp;f=png&amp;s=78638" alt=""></p>
<ul>
<li>atomic</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/6/16169e2d7ef5a81d?w=411&amp;h=384&amp;f=png&amp;s=87131" alt=""></p>
<ul>
<li>locks</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/6/16169e3528be1404?w=411&amp;h=297&amp;f=png&amp;s=65720" alt=""></p>
<ul>
<li>并发集合</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/6/16169e3a4b53404b?w=440&amp;h=563&amp;f=png&amp;s=138892" alt=""></p>
<ul>
<li>并发工具</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/6/16169e3eca541b38?w=406&amp;h=260&amp;f=png&amp;s=52976" alt=""></p>
<ul>
<li><p>forkJoin</p>
<p>  fork-join在JUC中有下面三个类：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt;, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinWorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br></pre></td></tr></table></figure>
</code></pre><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>Future提供了可以获取异步执行结果的方法，区别于Runnable的run方法，run是不提供返回结果的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//取消</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="comment">//如果任务完成前被取消，则返回true。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//如果任务执行结束，无论是正常结束或是中途取消还是发生异常，都返回true。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取异步执行的结果，如果没有结果可用，此方法会阻塞直到异步计算完成。</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="comment">//获取异步执行结果，如果没有结果可用，此方法会阻塞，但是会有时间限制，</span></span><br><span class="line">    <span class="comment">//如果阻塞时间超过设定的timeout时间，该方法将抛出异常。</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, </span></span><br><span class="line"><span class="function">    ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>声明了一个名称为call()的方法，同时这个方法可以有返回值V，也可以抛出异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123; </span><br><span class="line">  <span class="function">V   <span class="title">call</span><span class="params">()</span>   <span class="keyword">throws</span> Exception</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于Callable和Future的使用一般情况下都是结合我们的线程池来使用的。</p>
<h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>Executor接口是线程池实现的顶级接口，其和spring中的BeanFactory所承担的角色差不多，就是提供顶级的功能约束，具体实现交于不同子类来完成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given command at some time in the future.  The command</span></span><br><span class="line"><span class="comment">     * may execute in a new thread, in a pooled thread, or in the calling</span></span><br><span class="line"><span class="comment">     * thread, at the discretion of the &lt;tt&gt;Executor&lt;/tt&gt; implementation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command the runnable task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if this task cannot be</span></span><br><span class="line"><span class="comment">     * accepted for execution.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if command is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是JUC中Executor框架的整体结构：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/6/16169fcf02873970?w=544&amp;h=381&amp;f=png&amp;s=111229" alt=""></p>
<h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//关闭线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//是否为Shutdown状态</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//是否为Terminated状态</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//超过超时时间时，会监测ExecutorService是否已经关闭</span></span><br><span class="line">    <span class="comment">//若关闭则返回true，否则返回false。</span></span><br><span class="line">    <span class="comment">//一般情况下会和shutdown方法组合使用。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回一个Future对象，参数接收的是一个Callable的实现</span></span><br><span class="line">    <span class="comment">//Callable接口中的call()方法有一个返回值，可以返回任务的执行结果</span></span><br><span class="line">    <span class="comment">//区别于Runnable接口中的run()方法（void修饰，没有返回值）。</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">    </span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    <span class="comment">//返回一个Future对象，通过返回的Future对象，我们可以检查提交的任务是否执行完成了。 </span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回一个Future的List，其中对应着每个Callable任务执行后的Future对象。</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="comment">//增加了超时控制    </span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="comment">//接收参数是一个Callable的集合，</span></span><br><span class="line">    <span class="comment">//返回的是所有Callable集合任务中某一个任务的执行结果</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="comment">//增加了超时控制</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ExecutorService 再Executor接口的基础上扩展了对线程池状态的控制以及提交任务执行的超时控制。线程池的基本功能还不够完善，不能真正的具备处理具体业务的能力（毕竟是个接口，O(∩_∩)O哈哈~）。</p>
<p>开个篇，慢慢学~</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/java-up-juc1/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/java-base-thread-deadlock/">怎么写一个死锁？</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T05:55:55.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/java-base-thread-deadlock/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/java/" title="java">java</a>,
  
    <a href="/tags/线程/" title="线程">线程</a>,
  
    <a href="/tags/thread/" title="thread">thread</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>刚把手头上的项目代码撸完，闲来看看博客，然后就看到了线程这块的东西。之前有简单的记录过线程和进行的零碎知识。<br><br><a href="https://juejin.im/post/59d9a22a6fb9a00a4171b395" target="_blank" rel="noopener">JAVA基础知识系列—进程、线程安全</a></p>
<p>看着看着就想着怎么能写一个死锁呢，打开eclipse，突然感觉无从下手；之前都是一直在解决阻塞、死锁这些问题，现在反过来去写一个死锁感觉有点莫名奇妙。。。</p>
<p>ok,写一个死锁就要有一种场景，并且满足死锁的条件。</p>
<ul>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p>首先要有竞争的资源，并且两个线程要同时都在等待对方释放资源。那我们先弄两个资源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object lock=new Object();</span><br><span class="line">Object lock2=new Object();</span><br></pre></td></tr></table></figure>
<p>然后有两个线程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tr1 tr1=new Tr1(lock, lock2);</span><br><span class="line">Tr2 tr2=new Tr2(lock, lock2);</span><br><span class="line">		</span><br><span class="line">Thread t1=new Thread(tr1);</span><br><span class="line">Thread t2=new Thread(tr2);</span><br></pre></td></tr></table></figure>
<p>启动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>
<p>那么对于lock，lock2怎么再线程内部产生竞争关系呢？来看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.base.synchronize;</span><br><span class="line"></span><br><span class="line">public class Tr1 implements Runnable &#123;</span><br><span class="line">	</span><br><span class="line">	Object lock;</span><br><span class="line">	Object lock2;</span><br><span class="line"></span><br><span class="line">	public Tr1(Object lock,Object lock2)&#123;</span><br><span class="line">		this.lock= lock;</span><br><span class="line">		this.lock2= lock2;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">	    //获取lock</span><br><span class="line">		synchronized (lock) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+&quot;获取了lock锁&quot;);</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(3000);</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">			//获取lock2</span><br><span class="line">			synchronized (lock2) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+&quot;获取了lock2锁&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Tr2 implements Runnable &#123;</span><br><span class="line">	</span><br><span class="line">	Object lock;</span><br><span class="line">	Object lock2;</span><br><span class="line"></span><br><span class="line">	public Tr2(Object lock,Object lock2)&#123;</span><br><span class="line">		this.lock= lock;</span><br><span class="line">		this.lock2= lock2;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">	    //获取lock2</span><br><span class="line">		synchronized (lock2) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+&quot;获取了lock2锁&quot;);</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(3000);</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">			//获取lock</span><br><span class="line">			synchronized (lock) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+&quot;获取了lock锁&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析一下：当线程1获取lock时，线程2获取了lock2锁；然后线程1继续执行，到这里，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (lock2) &#123;</span><br><span class="line">	System.out.println(Thread.currentThread().getName()+&quot;获取了lock2锁&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时需要获取到lock2这个锁，但是lock2现在被线程2持有；同时，线程2也开始执行到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (lock) &#123;</span><br><span class="line">	System.out.println(Thread.currentThread().getName()+&quot;获取了lock锁&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时线程2也在尝试获取lock这把锁，但是lock又被线程1持有了。两个线程都在等待对方释放资源，造成了死锁。OK，完成了。。。<br><br>当我准备关机时，发现还在等呢？<br><img src="https://user-gold-cdn.xitu.io/2017/12/11/16045832711bea87?w=920&amp;h=142&amp;f=png&amp;s=13705" alt=""><br>？？那为什么呢？？<br>我们开看下发生了什么….</p>
<ul>
<li>通过jps来看下我们程序进程<br><img src="https://user-gold-cdn.xitu.io/2017/12/11/16045865f54208b5?w=529&amp;h=128&amp;f=png&amp;s=39317" alt=""></li>
<li>使用jstack -l 【pid】 来看下信息</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/11/16045874f9e2c635?w=917&amp;h=474&amp;f=png&amp;s=224928" alt=""><br>两个线程都处于BLOCKED状态了…,继续往下看<br><img src="https://user-gold-cdn.xitu.io/2017/12/11/1604587202fa162d?w=793&amp;h=386&amp;f=png&amp;s=161336" alt=""><br>found 1 deadlock.如我们所愿，死锁发生了！</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/java-base-thread-deadlock/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/java-bird-three/">菜鸟成长系列-面向对象的6种设计原则</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T05:53:06.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/java-bird-three/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/java/" title="java">java</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p><code>菜鸟成长系列拖了一周多了，今天继续之前的思路来进行。按照之前的规划，这篇主要来学习设计原则先关知识。通过本文学习，希望大家一方面能是能够认识这些原则是什么，能够在日常的开发中起到怎样的约束，并且用这些原则来提高代码的复用性和可维护性，另一方面是对后续的设计模式的学习能够有一些基础。</code></p>
<p><a href="https://juejin.im/post/59fe7797518825592451e66c" target="_blank" rel="noopener">菜鸟成长系列-概述</a><br><br><a href="https://juejin.im/post/59feb9296fb9a0451a75c21e" target="_blank" rel="noopener">菜鸟成长系列-面向对象的四大基础特性</a><br><br><a href="https://juejin.im/post/5a0d60ee6fb9a045272525af" target="_blank" rel="noopener">菜鸟成长系列-多态、接口和抽象类</a><br></p>
<hr>
<p>设计原则，在java与模式这本书中有提到，用于提高系统可维护性的同时，也提高系统的可复用性。这本书中主要讲了六种设计原则：</p>
<ul>
<li>“开-闭”原则</li>
<li>里氏替换原则</li>
<li>依赖倒置原则</li>
<li>接口隔离原则</li>
<li>单一职责原则</li>
<li>迪特米法则</li>
</ul>
<p>这些设计原则首先都是复用的原则，遵循这些原则可以有效的提高系统的复用性，同时也提高了系统的可维护性。</p>
<h2 id="“开-闭”原则"><a href="#“开-闭”原则" class="headerlink" title="“开-闭”原则"></a>“开-闭”原则</h2><p>网上看到一个人的解释，他是这样来比喻的：一个本子，已经写完了，你不可能撕几张纸粘上去吧，最好的办法是买个新的。<br><br>道理就是这样，一个已经做好的程序，不支持修改的，因为修改的话，有可能造成程序无法运行或报错，所以，通常程序只支持扩展，不支持修改。</p>
<ul>
<li>1.为什么会有这样一个原则来作为程序设计的一种约束呢？<br><br><code>在软件的生命周期内，由于软件功能或者结构的变化、升级和维护等原因需要对软件原有代码进行修改，在修改的过程中可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且还需要进行软件的重新测试，因此我们希望在软件设计之初，能够用一种原则来进行一些基本的约束，使得在软件后期的功能变更、扩展或者维护更加容易</code></li>
<li>2.开闭原则解决的问题是什么？<br><br><code>当软件需要进行改变时，我们应该尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。通过这样一种原则，可以很好的实现在保证原有功能稳定的前提下扩展新的功能</code></li>
<li>3.什么是开闭原则呢？<br><br><code>一个软件实体(类、模块或函数)应当对扩展开放，对修改关闭。也就是说在扩展或者修改软件功能时，应尽量在不修改原有代码的情况下进行</code></li>
</ul>
<p>举个简单的栗子：现在有这样一个需求，系统需要通过QQ来进行验证登录。OK，我们来撸代码：</p>
<ul>
<li><p>用户类User</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * 用户信息类</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午10:54:09</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class User &#123;</span><br><span class="line">	private String userName;//用户名</span><br><span class="line">	private String passWord;//密码</span><br><span class="line">	public String getUserName() &#123;</span><br><span class="line">		return userName;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setUserName(String userName) &#123;</span><br><span class="line">		this.userName = userName;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getPassWord() &#123;</span><br><span class="line">		return passWord;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setPassWord(String passWord) &#123;</span><br><span class="line">		this.passWord = passWord;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>QQ核心验证逻辑</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * QQ验证器</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午10:49:24</span><br><span class="line"> */</span><br><span class="line">public class QQAuther &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 用于验证QQ登录信息</span><br><span class="line">	 */</span><br><span class="line">    public boolean validateQQ(User user)</span><br><span class="line">    &#123;</span><br><span class="line">        //模拟下逻辑</span><br><span class="line">        return user.toString()==null?false:true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>核心验证服务类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * 用于验证的核心服务</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午10:47:04</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class AuthService &#123;</span><br><span class="line">	//持有一个QQ验证器对象</span><br><span class="line">	private QQAuther qqAuther;</span><br><span class="line">	//通过构造器注入qqAuther对象</span><br><span class="line">	public AuthService(QQAuther qqAuther) &#123;</span><br><span class="line">		this.qqAuther = qqAuther;</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	 * 验证用户合法性</span><br><span class="line">	 */</span><br><span class="line">	public boolean validateUser(User user)&#123;</span><br><span class="line">		return qqAuther.validateQQ(user);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>客户端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * 客户端调用验证</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午10:50:13</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class AuthClient &#123;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//获取用户信息</span><br><span class="line">		User user = UserHolder.getUser();</span><br><span class="line">		QQAuther qqAuther = new QQAuther();</span><br><span class="line">		AuthService authService = new AuthService(qqAuther);</span><br><span class="line">		//获取验证结果</span><br><span class="line">		boolean isOK = authService.validateUser(user);</span><br><span class="line">		System.out.println(isOK);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK,完事了！但是现在需要接入微博的开放平台接口；修改代码…。<br>增加一个微博验证器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * 微博核心验证器</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午11:01:10</span><br><span class="line"> */</span><br><span class="line">public class WeiBoAuther &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 用于验证QQ登录信息</span><br><span class="line">	 */</span><br><span class="line">    public boolean validateWeiBo(User user)</span><br><span class="line">    &#123;</span><br><span class="line">        return user.toString()==null?false:true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>核心验证服务修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * 用于验证的核心服务</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午10:47:04</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class AuthService &#123;</span><br><span class="line">	//持有一个QQ验证器对象</span><br><span class="line">	private Object obj;</span><br><span class="line">	//通过构造器注入qqAuther对象</span><br><span class="line">	public AuthService(Object obj) &#123;</span><br><span class="line">		this.obj = obj;</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	 * 验证用户合法性</span><br><span class="line">	 */</span><br><span class="line">	public boolean validateUser(User user)&#123;</span><br><span class="line">	    //这里仅作为模拟，一般情况下会通过使用定义枚举&amp;工厂模式来完成</span><br><span class="line">		if (obj instanceof QQAuther) &#123;</span><br><span class="line">			return new QQAuther().validateQQ(user);</span><br><span class="line">		&#125;</span><br><span class="line">		if(obj instanceof WeiBoAuther)&#123;</span><br><span class="line">			return new WeiBoAuther().validateWeiBo(user);</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端改变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * 客户端调用验证</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午10:50:13</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class AuthClient &#123;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//获取用户信息</span><br><span class="line">		User user = UserHolder.getUser();</span><br><span class="line">		</span><br><span class="line">		//QQ</span><br><span class="line">		QQAuther qqAuther = new QQAuther();</span><br><span class="line">		boolean isQQOK = new AuthService(qqAuther).validateUser(user);</span><br><span class="line">		System.out.println(isQQOK);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		//微博</span><br><span class="line">		WeiBoAuther weiBoAuther = new WeiBoAuther();</span><br><span class="line">		boolean isWeiBoOK = new AuthService(weiBoAuther).validateUser(user);</span><br><span class="line">		System.out.println(isWeiBoOK);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，改进完成！但是又有新的需求，接入微信….。假如我们现在把微信开放平台也接入了，然后又来需求要接入支付宝账户、苏宁易购账户等等。。。就需要不断的修改代码。那么这个时候就需要在设计之初用到我们的开闭原则来做一个约束了。继续撸：<br><br>首先我们需要需要定义一个接口用于约束：</p>
<ul>
<li><p>验证器接口，用于被QQ/WEIBO/微信/苏宁易购等开发平台验证器实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * 定义一个约束接口 </span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午11:32:32</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public interface ValidateInteface &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 提供一个验证入口</span><br><span class="line">	 */</span><br><span class="line">	boolean validate(User user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>QQ修改之后</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * QQ验证器</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午10:49:24</span><br><span class="line"> */</span><br><span class="line">public class QQAuther implements ValidateInteface&#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 用于验证QQ登录信息</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public boolean validate(User user) &#123;</span><br><span class="line">		return user.toString()==null?false:true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>微博修改之后</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * 微博核心验证器</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午11:01:10</span><br><span class="line"> */</span><br><span class="line">public class WeiBoAuther implements ValidateInteface&#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 用于验证QQ登录信息</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public boolean validate(User user) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		 return user.toString()==null?false:true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>核心验证服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * 用于验证的核心服务</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午10:47:04</span><br><span class="line"> */</span><br><span class="line">public class AuthService &#123;</span><br><span class="line">	//持有一个QQ验证器对象</span><br><span class="line">	private ValidateInteface validate;</span><br><span class="line">	//通过构造器注入qqAuther对象</span><br><span class="line">	public AuthService(ValidateInteface validate) &#123;</span><br><span class="line">		this.validate = validate;</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	 * 验证用户合法性</span><br><span class="line">	 */</span><br><span class="line">	public boolean validateUser(User user)&#123;</span><br><span class="line">		return validate.validate(user);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>客户端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framerwork;</span><br><span class="line">/**</span><br><span class="line"> * 客户端调用验证</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月9日下午10:50:13</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class AuthClient &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//获取用户信息</span><br><span class="line">		User user = UserHolder.getUser();</span><br><span class="line">		//QQ</span><br><span class="line">		ValidateInteface qqAuther = new QQAuther();</span><br><span class="line">		boolean isQQOK = new AuthService(qqAuther).validateUser(user);</span><br><span class="line">		System.out.println(isQQOK);</span><br><span class="line">		//微博</span><br><span class="line">		ValidateInteface weiBoAuther = new WeiBoAuther();</span><br><span class="line">		boolean isWeiBoOK = new AuthService(weiBoAuther).validateUser(user);</span><br><span class="line">		System.out.println(isWeiBoOK);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进之后我们可以发现，对于原来的核心验证服务类、各验证器类，无论增加什么方式接入，我们都不需要去修改它的代码了。而此时我们需要做的就是新增一个验证器（例如苏宁易购验证器），然后继承ValidateInterface接口就行了。总体来首，开闭原则的核心是：</p>
<ul>
<li>抽象化</li>
<li>对可变性的封装原则（1.不可变性不应该散落在代码的多处，而应当被封装到一个对象里面；2.一种可变性不应当与另外一种可变性混合在一起）</li>
</ul>
<p>（大家如果有更简单暴力的例子，可以留言；这个例子想了很多都感觉不是很恰当，还是从工作中抽象出来的）。</p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p><code>任何父类可以出现的地方，子类一定可以出现</code><br><br>里氏替换原则算是对“开闭”原则的补充，上面也提到，实现“开闭”原则的关键步骤是抽象化，而父类与子类的继承关系就是抽象化的一种具体体现，所以里氏替换原则是对实现抽象化的具体步骤的规范。</p>
<p><code>摘自java与模式中的定义:如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。</code></p>
<p>下图中描述了一种继承关系，从最高层的动物一直衍生出具体的动物。OK，写一段断码来看看：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/10/1603e46c66904d41?w=651&amp;h=352&amp;f=png&amp;s=11022" alt=""></p>
<ul>
<li><p>顶层抽象父类-Animal</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framework.model.lsp;</span><br><span class="line">/**</span><br><span class="line"> * 顶层抽象父类动物类</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月10日上午10:51:30</span><br><span class="line"> */</span><br><span class="line">public abstract class Animal &#123;</span><br><span class="line">	//提供一个抽象方法，以供不同子类来进行具体的实现</span><br><span class="line">	public abstract void eatFood(String foodName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体动物类型-Dog</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> package com.glmapper.framework.model.lsp;</span><br><span class="line">/**</span><br><span class="line"> *子类-小狗</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月10日上午10:54:17</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Dog extends Animal&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void eatFood(String foodName) &#123;</span><br><span class="line">		System.out.println(&quot;小狗吃&quot;+foodName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>具体动物-哈士奇</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> package com.glmapper.framework.model.lsp;</span><br><span class="line">/**</span><br><span class="line"> * 具体小狗的种类-子类哈士奇</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月10日上午10:56:59</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class HSQDog extends Dog&#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 重写父类方法</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public void eatFood(String foodName) &#123;</span><br><span class="line">		System.out.println(&quot;哈士奇吃&quot;+foodName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>客户端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framework.model.lsp;</span><br><span class="line">//客户端程序</span><br><span class="line">public class ClientMain &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//子类</span><br><span class="line">		HSQDog hsqdog=new HSQDog();</span><br><span class="line">		hsqdog.eatFood(&quot;饼干&quot;);</span><br><span class="line">		//父类</span><br><span class="line">		Dog dog = new HSQDog();</span><br><span class="line">		dog.eatFood(&quot;饼干&quot;);</span><br><span class="line">		//顶层父类</span><br><span class="line">		Animal animal = new HSQDog();</span><br><span class="line">		animal.eatFood(&quot;饼干&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">哈士奇吃饼干</span><br><span class="line">哈士奇吃饼干</span><br><span class="line">哈士奇吃饼干</span><br></pre></td></tr></table></figure>
<p>可以看出我们最开始说的那句话<strong>任何父类可以出现的地方，子类一定可以出现</strong>，反过来是不成立的。我的理解是子类通过集成获取的父类的属性和行为，并且子类自身也具有自己的属性和行为；父类可以出现的地方必然是需要用到父类的属性或者行为，而子类都涵盖了父类的这些信息，因此可以做到替换。反过来不行是因为父类在上述的例子中只是充当了一种类型约束，它可能不具有子类的某些特征，因此就无法做到真正的替换。</p>
<p><code>里氏替换原则是继承复用的基石，只有当子类可以替换掉基类，软件单位的功能不会受到影响时，基类才能被真正的复用，而子类也才能够在基类的基础上增加新的功能。</code></p>
<h1 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h1><p><code>实现“开闭”原则的关键是抽象化，并且从抽象化导出具体化实现。如果说开闭原则是面向对象设计的目标的话，依赖倒转原则就是面向对象设计的主要机制（java与模式）。</code><br><br><code>依赖倒转原则：要依赖与抽象，不依赖于具体实现。</code></p>
<p>怎么理解呢?<br></p>
<ul>
<li><p>1）高层模块不应该直接依赖于底层模块的具体实现，而应该依赖于底层的抽象。换言之，模块间的依赖是通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。</p>
</li>
<li><p>2）接口和抽象类不应该依赖于实现类，而实现类依赖接口或抽象类。这一点其实不用多说，很好理解，“面向接口编程”思想正是这点的最好体现</p>
</li>
</ul>
<p>首先是第一点，从复用的角度来说，高层次的模块是设计者应当复用的。但是在传统的过程性的设计中，复用却侧重于具体层次模块的复用。比如算法的复用，数据结构的复用，函数库的复用等，都不可避免是具体层次模块里面的复用。较高层次的结构依赖于较低层次的结构，然后较低层次的结构又依赖于更低层次的结构，直到依赖到每一行代码为止。然后对低层次修改也会逐层修改，一直到最高层的设计模块中。</p>
<p><code>对于一个系统来说，一般抽象层次越高，它的稳定性就越好，因此也是作为复用的重点</code>。</p>
<p>“倒转”，实际上就是指复用应当将复用的重点放在抽象层上，如果抽象层次的模块相对独立于具体层次模块的话，那么抽象层次的模块的复用便是相对较为容易的了。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/10/1603e7d16270426f?w=423&amp;h=398&amp;f=jpeg&amp;s=44474" alt=""><br>在很多情况下，一个java程序需要引用一个对象，如果这个对象有一个抽象类型的话，应当使用这个抽象类型作为变量的静态类型。<br>在上面我们画了动物和小狗的类图关系，在客户端调用的时候有三种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//子类(方式1)</span><br><span class="line">HSQDog hsqdog=new HSQDog();</span><br><span class="line">hsqdog.eatFood(&quot;饼干&quot;);</span><br><span class="line">//父类（方式2）</span><br><span class="line">Dog dog = new HSQDog();</span><br><span class="line">dog.eatFood(&quot;饼干&quot;);</span><br><span class="line">//顶层父类（方式3）</span><br><span class="line">Animal animal = new HSQDog();</span><br><span class="line">animal.eatFood(&quot;饼干&quot;);</span><br></pre></td></tr></table></figure>
<p>如果我们需要一个哈士奇（HSQDog）的话，我们不应当使用方式1，而是应当使用方式2或者方式3。</p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p><code>接口隔离原则：使用多个专门的接口比使用单一的总接口要好。换句话说，从一个客户类的角度来讲：一个类对另外一个类的依赖性应当是建立在最小的接口上的。</code><br>这个其实在我们实际的开发中是经常遇到的。比如我们需要编写一个完成一个产品的一些操作接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framework.model.isp;</span><br><span class="line">/**</span><br><span class="line"> * 一个产品服务接口</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月10日下午12:01:31</span><br><span class="line"> */</span><br><span class="line">public interface ProductService &#123;</span><br><span class="line">	//增加产品</span><br><span class="line">	public int addProduct(Product p);</span><br><span class="line">	//删除产产品</span><br><span class="line">	public int deleteProduct(int pId);</span><br><span class="line">	//修改产品</span><br><span class="line">	public int updateProduct(Product p);</span><br><span class="line">	//查询一个产品</span><br><span class="line">	public Product queryProduct(int pId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>OK，我们在ProductService中提供了对产品的增删改查；但是随着需求升级，我们需要可以增加对产品新的批量导入和导出。OK，这时在接口中继续新增两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//从excel中批量导入</span><br><span class="line">public void batchImportFromExcel();</span><br><span class="line">//从excel中批量导导出</span><br><span class="line">public void batchExportFromExcel();</span><br></pre></td></tr></table></figure></p>
<p>然后需求又需要扩展，需要增加增加购买产品、产品订单生产、查询订单、订单详情….；这样一来，我们的ProductService就会慢慢的急速膨胀。与此对应的具体的实现逻辑ProductServiceImpl类也会变得非常的庞大，可能单类会超过数千行代码。</p>
<p>那么我们就需要进行接口隔离，将产品的基本操作如增删改查放在一个接口，将产品订单处理放在一个接口，将产品申购放在一个接口，将批量操作放在一个接口等等…对于每一个接口我们只关心某一类特定的职责，这个其实就是和单一职责原则有点挂钩了。<br><code>通过这种设计，降低了单个接口的复杂度，使得接口的“内聚性”更高，“耦合性”更低。由此可以看出接口隔离原则的必要性。</code></p>
<h2 id="迪特米法则"><a href="#迪特米法则" class="headerlink" title="迪特米法则"></a>迪特米法则</h2><p><code>迪特米法则：又称为最少知识原则，就是说一个对象应当对其他对象尽可能少的了解；看下迪特米法则的几种表述：</code><br><br><code>1.只与你直接的朋友们通信</code><br><br><code>2.不跟陌生人说话</code><br><br><code>3.每一个软件单位对其他的单位都只有最少知识，而且局限于那些与本单位密切相关的软件单位</code><br></p>
<p>也就是说，如果两个雷不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要电泳另一个类的某一个方法的话，可以通过第三者进行消息的转发。代码看下：</p>
<ul>
<li><p>某个人</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framework.model.isp;</span><br><span class="line">/**</span><br><span class="line"> * 某个人</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月10日下午12:39:45</span><br><span class="line"> */</span><br><span class="line">public class SomeOne &#123;</span><br><span class="line">	//具体oprateion行为</span><br><span class="line">	public void oprateion(Friend friend)&#123;</span><br><span class="line">		Stranger stranger =friend.provide();</span><br><span class="line">		stranger.oprateion3();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">SomeOne具有一个oprateion方法，该方法接受Friend为参数，根据上面的定义可以知道Friend是SomeOne的“朋友”（直接通信了）</span><br></pre></td></tr></table></figure>
</li>
<li><p>朋友</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framework.model.isp;</span><br><span class="line">/**</span><br><span class="line"> * 朋友</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月10日下午12:40:09</span><br><span class="line"> */</span><br><span class="line">public class Friend &#123;</span><br><span class="line">	private Stranger stranger = new Stranger();</span><br><span class="line">	public Stranger provide()&#123;</span><br><span class="line">		return stranger;</span><br><span class="line">	&#125;</span><br><span class="line">	public void opration2()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">很明显SomeOne的opration方法不满足迪特米法则，因为这个方法中涉及到了陌生人Stranger,Stranger不是SomeOne的朋友</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>OK，我们来通过迪特米法则进行改造。</p>
<ul>
<li>改造之后的SomeOne</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framework.model.isp;</span><br><span class="line">/**</span><br><span class="line"> * 某个人</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月10日下午12:39:45</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SomeOne &#123;</span><br><span class="line">	//具体oprateion行为</span><br><span class="line">	public void oprateion(Friend friend)&#123;</span><br><span class="line">		friend.forward();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>改造之后的朋友</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.framework.model.isp;</span><br><span class="line">/**</span><br><span class="line"> * 朋友</span><br><span class="line"> * @author glmapper</span><br><span class="line"> * @date 2017年12月10日下午12:40:09</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Friend &#123;</span><br><span class="line">	private Stranger stranger = new Stranger();</span><br><span class="line">	public void opration2()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	//进行转发</span><br><span class="line">	public void forward() &#123;</span><br><span class="line">		stranger.oprateion3();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于调用了转发，因此SomeOne中就不会和陌生人Stranger直接的关系就被忽略了。满足了直接和朋友通信、不与陌生人说话的条件。<br><br>但是迪特米法则带来的问题也是很明显的：即会在系统中造出大量的小方法散落在系统的各个角落，这些方法仅仅是传递消息的调用，与系统的业务逻辑没有任何关系。</p>
<h2 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h2><p>上面在接口隔离中有提到过，单一职责其实很好理解，解释尽量的使得我们的每一个类或者接口只完成本职工作以内的事情，不参与其他任何逻辑。比如说苹果榨汁机我就只用来榨苹果汁，如果你需要榨黄瓜汁的话，你就得买一个黄瓜榨汁机。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OK ，至此，设计原则部分就复习完了。总结一下：</p>
<ul>
<li><ol>
<li>单一职责原则要求实现类要职责单一；</li>
</ol>
</li>
<li><ol start="2">
<li>里氏替换原则要求不要去破坏继承系统；</li>
</ol>
</li>
<li><ol start="3">
<li>依赖倒置原则要求面向接口编程；</li>
</ol>
</li>
<li><ol start="4">
<li>接口隔离原则要求在设计接口的时候要精简单一；</li>
</ol>
</li>
<li><ol start="5">
<li>迪米特法则要求要降低耦合；</li>
</ol>
</li>
<li><ol start="6">
<li>开闭原则是总纲，要求对扩展开发，对修改关闭。</li>
</ol>
</li>
</ul>
<p>大家周末愉快！（如果有不当之处，希望大家及时指出，多谢！）</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/java-bird-three/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
    </div>
    
      <div id="page-nav" class="pagination">
	<span class="page-number current">1</span><a class="page-number" href="/tags/java/page/2/">2</a><a class="extend next" rel="next" href="/tags/java/page/2/">Next</a>
      </div>
    
  </section>

</div>

</div>

</section>
</div>


    <!-- BEGIN PRE-FOOTER -->
    <div class="pre-footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN BOTTOM ABOUT BLOCK -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>About Us</h2>
            <p>Computer Lab is a software development and marketing company based in Brooklyn, New York. <br><br> Computer Lab was founded in 2015, and is focused on so on and so forth.</p>
          </div>
          <!-- END BOTTOM ABOUT BLOCK -->

          <!-- BEGIN BOTTOM CONTACTS -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>Contact</h2>
            <address class="margin-bottom-40">
              140 Metropolitan Avenue<br>
              5th Floor<br>
              Brooklyn, NY 11249<br>
              Phone: 716-472-4484<br>
              Email: <a href="mailto:ptsteadman@gmail.com">ptsteadman@gmail.com</a><br>
            </address>
          </div>
          <!-- END BOTTOM CONTACTS -->

	
          <!-- BEGIN TWITTER BLOCK --> 
          <div class="col-md-4 col-sm-6 pre-footer-col">

	  <a data-tweet-limit="1" class="twitter-timeline" href="https://twitter.com/computerlab_" data-widget-id="678830341331820544">Tweets by @computerlab_</a>

	  <script>!function(d,s,id){var
	  js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

          </div>
          <!-- END TWITTER BLOCK -->
	
        </div>
      </div>
    </div>
    <!-- END PRE-FOOTER -->

    <!-- BEGIN FOOTER -->
    <div class="footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN COPYRIGHT -->
          <div class="col-md-6 col-sm-6 padding-top-10">
                  &copy; 2020 glmapper<br>
 <a href="javascript:;">Privacy Policy</a> | <a href="javascript:;">Terms of Service</a>
          </div>
          <!-- END COPYRIGHT -->
	  <!-- BEGIN SOCIAL -->
<div class="col-md-6 col-sm-6">
  <ul class="social-footer list-unstyled list-inline pull-right">
    
      <li><a href="https://github.com/ptsteadman"><i class="fa fa-github"></i></a></li>
    
      <li><a href="https://twitter.com/ptsteadman"><i class="fa fa-twitter"></i></a></li>
    
      <li><a href="https://www.facebook.com/ptsteadman"><i class="fa fa-facebook"></i></a></li>
    
      <li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li>
    
      <li><a href="https://linkedin.com/in/ptsteadman"><i class="fa fa-linkedin"></i></a></li>
    
      <li><a href="http://stackoverflow.com/users/2480493/patrick-steadman"><i class="fa fa-stackoverflow"></i></a></li>
    
  </ul>  
</div>
<!-- END SOCIAL -->

        </div>
      </div>
    </div>
    <!-- END FOOTER -->

  <!-- BEGIN CORE PLUGINS (REQUIRED FOR ALL PAGES) -->
<!--[if lt IE 9]>
<script src="/metronic/assets/plugins/respond.min.js"></script>
<![endif]--> 
<script src="/metronic/assets/plugins/jquery.min.js"></script>
<script src="/metronic/assets/plugins/jquery-migrate.min.js"></script>
<script src="/metronic/assets/plugins/bootstrap/js/bootstrap.min.js"></script>
<script src="/metronic/assets/corporate/scripts/back-to-top.js"></script>
<script src="/metronic/assets/plugins/owl.carousel/owl.carousel.min.js"></script>
<script src="/metronic/assets/corporate/scripts/layout.js"></script>
<script src="/js/wow.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script type="text/javascript">
    jQuery(document).ready(function() {
        Layout.init();    
        Layout.initOWL();
        Layout.initTwitter();
        Layout.initFixHeaderWithPreHeader(); /* Switch On Header Fixing (only if you have pre-header) */
        Layout.initNavScrolling(); 
	new WOW().init();
    });
</script>
<!-- END CORE PLUGINS -->

<!-- BEGIN PAGE-SPECIFIC PLUGINS --> 







<!-- END PAGE-SPECIFIC PLUGINS --> 

<!-- BEGIN INTEGRATIONS -->





<!-- END INTEGRATIONS -->

</body>
</html>
