<!DOCTYPE html>
<!--[if IE 8]> <html lang="en" class="ie8 no-js"> <![endif]-->
<!--[if IE 9]> <html lang="en" class="ie9 no-js"> <![endif]-->
<!--[if !IE]><!-->
<html lang="en">
<!--<![endif]-->
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Tag: SOFATracer | glmapper</title>

  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <meta name="description" content="从平凡的世界中全身而退">
<meta property="og:type" content="website">
<meta property="og:title" content="glmapper">
<meta property="og:url" content="http://www.glmapper.com/tags/SOFATracer/index.html">
<meta property="og:site_name" content="glmapper">
<meta property="og:description" content="从平凡的世界中全身而退">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="glmapper">
<meta name="twitter:description" content="从平凡的世界中全身而退">
  
    <link rel="alternative" href="/atom.xml" title="glmapper" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
    
  <meta content="{{ title }}" name="description">
  <meta content="{{ title }}" name="keywords">
  <meta content="{{ title }}" name="author">

  <link href="http://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700|PT+Sans+Narrow|Source+Sans+Pro:200,300,400,600,700,900&amp;subset=all" rel="stylesheet" type="text/css">

  <!-- Global styles START -->   
  <link rel="stylesheet" href="/metronic/assets/plugins/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/bootstrap/css/bootstrap.min.css">
  <!-- Global styles END --> 
   
  <!-- Page level plugin styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/animate.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/owl.carousel/assets/owl.carousel.css">
  <!-- Page level plugin styles END -->

  <!-- Theme styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/components.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/slider.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/portfolio.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style-responsive.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/themes/red.css">
  <link rel="stylesheet" href="/css/theme-styles.css">
  <!-- Theme styles END -->
</head>
</html>
<body class="corporate">
  <!-- BEGIN TOP BAR -->
<div class="pre-header">
  <div class="container">
    <div class="row">
      <!-- BEGIN TOP BAR LEFT PART -->
      <div class="col-md-6 col-sm-6 col-xs-9 additional-shop-info">
	<ul class="list-unstyled list-inline">
	  <li><i class="fa fa-phone"></i><span>716-472-4484</span></li>
	  <li><i class="fa fa-envelope-o"></i><span>ptsteadman@gmail.com</span></li>
	</ul>
      </div>
      <!-- END TOP BAR LEFT PART -->
      <!-- BEGIN TOP BAR MENU -->
      <div class="col-md-6 col-sm-6 col-xs-3 additional-nav">
	<ul class="list-unstyled list-inline pull-right">
	  <li><a href="/login">Log In</a></li>
	</ul>
      </div>
      <!-- END TOP BAR MENU -->
    </div>
  </div>        
</div>
<!-- END TOP BAR -->
<!-- BEGIN HEADER -->
<div class="header">
  <div class="container">
    <!--<a class="site-logo" href="/" id="logo">glmapper</a>-->

    <a class="site-logo" href="/">
      <img src="/metronic/assets/corporate/img/logos/logo-corp-red.png" alt="Metronic FrontEnd">
    </a>

    <a href="javascript:void(0);" class="mobi-toggler"><i class="fa fa-bars"></i></a>

    <!-- BEGIN NAVIGATION -->
    <div class="header-navigation pull-right font-transform-inherit">
      <ul>
	
	<li class="">
	  <a href="/">Home</a>
	</li>
	
	<li class="">
	  <a href="/projects/">Projects</a>
	</li>
	
	<li class="">
	  <a href="/archives/">Blog</a>
	</li>
	
	<li class="">
	  <a href="/contact/">Contact</a>
	</li>
	
	<li class="">
	  <a href="/about/">About</a>
	</li>
	
	<!-- BEGIN TOP SEARCH -->
	<li class="menu-search">
	  <span class="sep"></span>
	  <i class="fa fa-search search-btn"></i>
	  <div class="search-box">
	    <form action="#">
	      <div class="input-group">
		<input type="text" placeholder="Search" class="form-control st-default-search-input">
		<span class="input-group-btn">
		  <button class="btn btn-primary" type="submit">Search</button>
		</span>
	      </div>
	    </form>
	  </div> 
	</li>
	<!-- END TOP SEARCH -->
      </ul>
    </div>
    <!-- END NAVIGATION -->
  </div>
</div>
<!-- Header END -->

  <div class="container">
  <ul class="breadcrumb">
    <li><a href="/">Home</a></li>
    <li><a href="/blog">Blog</a></li>
    <li class="active">Tagged: SOFATracer</li>
  </ul>
<section id="main">
  <h1>Tagged: SOFATracer</h1>
  <div class="row">

<div class="col-xs-12 blog-posts">


  <section class="archives-wrap">
    <div class="archives">
      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2020/01/20/sofa-tracer-integration-analysis/">一文详解蚂蚁金服分布式链路组件 SOFATracer 的埋点机制</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2020-01-20T03:43:56.000Z" itemprop="datePublished">2020/01/20</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2020/01/20/sofa-tracer-integration-analysis/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/SOFATracer/" title="SOFATracer">SOFATracer</a>,
  
    <a href="/tags/OpenTracing/" title="OpenTracing">OpenTracing</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>SOFATracer 是一个用于分布式系统调用跟踪的组件，通过统一的 TraceId 将调用链路中的各种网络调用情况以日志的方式记录下来，以达到透视化网络调用的目的，这些链路数据可用于故障的快速发现，服务治理等。</p>
<blockquote>
<p>GITHUB 地址：<a href="https://github.com/sofastack/sofa-tracer/pulls" target="_blank" rel="noopener">https://github.com/sofastack/sofa-tracer/pulls</a> （欢迎 star）<br>官方文件地址：<a href="https://www.sofastack.tech/projects/sofa-tracer/overview/" target="_blank" rel="noopener">https://www.sofastack.tech/projects/sofa-tracer/overview/</a></p>
</blockquote>
<p>2018 年末时至 2019 年初，SOFA 团队发起过 <a href="https://www.sofastack.tech/tags/%E5%89%96%E6%9E%90-sofatracer-%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">剖析-sofatracer-框架</a> 的源码解析系列文章。这个系列中，基本对 SOFATracer 所提供的能力及实现原理都做了比较全面的分析，有兴趣的同学可以看下。</p>
<p>从官方文档及 PR 来看，目前 SOFATracer 已经支持了对以下开源组件的埋点支持：</p>
<ul>
<li>Spring MVC</li>
<li>RestTemplate</li>
<li>HttpClient</li>
<li>OkHttp3</li>
<li>JDBC </li>
<li>Dubbo(2.6/2.7)</li>
<li>SOFARPC</li>
<li>Redis</li>
<li>MongoDB</li>
<li>Spring Message</li>
<li>Spring Cloud Stream (基于 Spring Message 的埋点)</li>
<li>RocketMQ</li>
<li>Spring Cloud FeignClient</li>
<li>Hystrix</li>
</ul>
<blockquote>
<p>大多数能力提供在 3.x 版本，2.x 版本从官方 issue 中可以看到后续将不在继续提供新的功能更新；这也是和 SpringBoot 宣布不在继续维护 1.x 版本有关系。</p>
</blockquote>
<p>本文将从插件的角度来分析，SOFATracer 是如何实现对上述组件进行埋点的；通过本文，除了了解 SOFATracer 的埋点机制之外，也可以对上述组件的基本扩展机制以及基本原理有一点学习。</p>
<h2 id="标准-Servlet-规范埋点原理"><a href="#标准-Servlet-规范埋点原理" class="headerlink" title="标准 Servlet 规范埋点原理"></a>标准 Servlet 规范埋点原理</h2><p>SOFATracer 支持对标准 Servlet 规范的 web mvc 埋点，包括普通的 servlet 和 Springmvc 等；基本原理就是基于 Servelt 规范所提供的 <code>javax.servlet.Filter</code> 过滤器接口扩展实现。</p>
<blockquote>
<p>过滤器位于 client 和 web 应用程序之间，用于检查和修改两者之间流过的请求和响应信息。在请求到达 Servlet 之前，过滤器截获请求。在响应送给客户端之前，过滤器截获响应。多个过滤器形成一个 FilterChain，FilterChain 中不同过滤器的先后顺序由部署文件 web.xml 中过滤器映射<filter-mapping>的顺序决定。最先截获客户端请求的过滤器将最后截获 Servlet 的响应信息。</filter-mapping></p>
</blockquote>
<p>web 应用程序一般作为请求的接收方，在 Tracer 中应用是作为 server 存在的，其在解析 SpanContext 时所对应的事件为 sr (server receive)。</p>
<p>SOFATracer 在 sofa-tracer-springmvc-plugin 插件中解析及产生 span 的过程大致如下：</p>
<ul>
<li>Servlet Filter 拦截到 request 请求</li>
<li>从请求中解析 SpanContext </li>
<li>通过 SpanContext 构建当前 MVC 的 span </li>
<li>给当前 span 设置 tag、log。</li>
<li>在 filter 处理的最后，结束 span。</li>
</ul>
<p>当然这里面还会设计到其他很多细节，比如给 span 设置哪些 tag 属性、如果处理异步线程透传等等。本篇不展开细节探讨，有兴趣的同学可以自行阅读代码或者和我交流。</p>
<h2 id="Dubbo-埋点原理"><a href="#Dubbo-埋点原理" class="headerlink" title="Dubbo 埋点原理"></a>Dubbo 埋点原理</h2><p>Dubbo 埋点在 SOFATracer 中实际上提供了两个插件，分别用于支持 Dubbo 2.6.x 和 Dubbo 2.7.x；Duddo 埋点也是基于 Filter ，此Filter 是 Dubbo 提供的 SPI 扩展-<a href="http://dubbo.apache.org/zh-cn/docs/dev/impls/filter.html" target="_blank" rel="noopener">调用拦截扩展</a> 机制实现。</p>
<p>像 Dubbo 或者 SOFARpc 等 rpc 框架的埋点，通常需要考虑的点比较多，首先是 rpc 框架分客户端和服务端，所以在埋点时 rpc 的客户端和服务端必须要有所区分；再者就是 rpc 的调用方式包括很多种，如常见的同步调用、异步调用、oneway 等等，调用方式不同，所对应的 span 的结束时机也不同，重要是的基本所有的 rpc 框架都会使用线程池用来发起和处理请求，那么如何保证 tracer 在多线程环境下不串也很重要。</p>
<p>另外 Dubbo 2.6.x 和 Dubbo 2.7.x 在异步回调处理上差异比较大，Dubbo 2.7.x 中提供了 onResponse 方法（后面又升级为 Listener，包括 onResponse 和 onError 两个方法）；而 Dubbo 2.6.x 中则并未提供相应的机制，只能通过对 future 的硬编码处理来完成埋点和上报。</p>
<blockquote>
<p>这个问题 zipkin brave 对 Dubbo 2.6.x 的埋点时其实也没有考虑到，在做 SOFATracer 支持 Dubbo 2.6.x 时发现了这个 bug，并做了修复。</p>
</blockquote>
<p>SOFATracer 中提供的 DubboSofaTracerFilter 类： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span>(group = &#123; CommonConstants.PROVIDER, CommonConstants.CONSUMER &#125;, value = <span class="string">"dubboSofaTracerFilter"</span>, order = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboSofaTracerFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// todo trace</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SOFATracer 中用于处理 Dubbo 2.6.x 版本中异步回调处理的核心代码：</p>
<blockquote>
<p>Dubbo 异步处理依赖 ResponseFuture 接口，但是 ResponseFuture 在核心链路上并非是以数据或者 list 的形式存在，所以在链路上只会存在一个 ResponseFuture，因此如果我自定义一个类来实现 ResponseFuture 接口是没法达到预期目的的，因为运行期会存在覆盖 ResponseFuture 的问题。所以在设计上，SOFATracer 会通过 ResponseFuture 构建一个新的 FutureAdapter出来用于传递。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">ensureSpanFinishes</span><span class="params">(Future&lt;Object&gt; future, Invocation invocation, Invoker&lt;?&gt; invoker)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> deferFinish = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (future <span class="keyword">instanceof</span> FutureAdapter) &#123;</span><br><span class="line">        deferFinish = <span class="keyword">true</span>;</span><br><span class="line">        ResponseFuture original = ((FutureAdapter&lt;Object&gt;) future).getFuture();</span><br><span class="line">        ResponseFuture wrapped = <span class="keyword">new</span> AsyncResponseFutureDelegate(invocation, invoker, original);</span><br><span class="line">        <span class="comment">// Ensures even if no callback added later, for example when a consumer, we finish the span</span></span><br><span class="line">        wrapped.setCallback(<span class="keyword">null</span>);</span><br><span class="line">        RpcContext.getContext().setFuture(<span class="keyword">new</span> FutureAdapter&lt;&gt;(wrapped));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deferFinish;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="http-客户端埋点原理"><a href="#http-客户端埋点原理" class="headerlink" title="http 客户端埋点原理"></a>http 客户端埋点原理</h2><p>http 客户端埋点包括 HttpClient、OkHttp、RestTemplate 等，此类埋点一般都是基于拦截器机制来实现的，如 HttpClient 使用的 HttpRequestInterceptor、HttpResponseInterceptor；OkHttp 使用的 okhttp3.Interceptor；RestTemplate 使用的 ClientHttpRequestInterceptor。</p>
<p>以 OkHttp 为例，简单分析下 http 客户端埋点的实现原理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取请求</span></span><br><span class="line">    Request request = chain.request();</span><br><span class="line">    <span class="comment">// 解析出 SpanContext ，然后构建 Span</span></span><br><span class="line">    SofaTracerSpan sofaTracerSpan = okHttpTracer.clientSend(request.method());</span><br><span class="line">    <span class="comment">// 发起具体的调用</span></span><br><span class="line">    Response response = chain.proceed(appendOkHttpRequestSpanTags(request, sofaTracerSpan));</span><br><span class="line">    <span class="comment">// 结束 span</span></span><br><span class="line">    okHttpTracer.clientReceive(String.valueOf(response.code()));</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Datasource-埋点原理"><a href="#Datasource-埋点原理" class="headerlink" title="Datasource 埋点原理"></a>Datasource 埋点原理</h2><p>和标准 servlet 规范实现一样，所有基于 <code>javax.sql.DataSource</code> 实现的 DataSource 均可以使用 SOFATracer 进行埋点。因为 DataSource 并没有提供像 Servlet 那样的过滤器或者拦截器，所以 SOFATracer 中没法直接通过常规的方式（Filter/SPI扩展拦截/拦截器等）进行埋点，而是使用了代理模式的方式来实现的。</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/tracers/datasource.jpg" alt=""></p>
<p>上图为 SOFATracer 中 DataSource 代理类实现的类继承结构体系；可以看出，SOFATracer 中自定义了一个 BaseDataSource 抽象类，该抽象类继承 <code>javax.sql.DataSource</code> 接口，SmartDataSource 作为 BaseDataSource 的唯一子类，也就是 SOFATracer 中所使用的 代理类。所以如果你使用了 <code>sofa-tracer-datasource-plugin</code> 插件的话，可以看到最终运行时的 Datasource 类型是 <code>com.alipay.sofa.tracer.plugins.datasource.SmartDataSource</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实际被代理的 datasource</span></span><br><span class="line">    <span class="keyword">protected</span> DataSource        delegate;</span><br><span class="line">    <span class="comment">//  sofatracer 中自定义的拦截器，用于对连接操作、db操作等进行拦截埋点</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;Interceptor&gt; interceptors;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Interceptor&gt; dataSourceInterceptors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Interceptor 主要包括以下三种类型：</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/tracers/datasourceinteceptor.jpg" alt=""></p>
<p>以 StatementTracerInterceptor 为例 StatementTracerInterceptor 将将会拦截到所有 PreparedStatement 接口的方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatementTracerInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tracer 类型为 client </span></span><br><span class="line">    <span class="keyword">private</span> DataSourceClientTracer clientTracer;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClientTracer</span><span class="params">(DataSourceClientTracer clientTracer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// tracer 对象实例</span></span><br><span class="line">        <span class="keyword">this</span>.clientTracer = clientTracer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 记录当前系统时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        String resultCode = SofaTracerConstant.RESULT_SUCCESS;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开始一个 span</span></span><br><span class="line">            clientTracer.startTrace(chain.getOriginalSql());</span><br><span class="line">            <span class="comment">// 执行</span></span><br><span class="line">            <span class="keyword">return</span> chain.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            resultCode = SofaTracerConstant.RESULT_FAILED;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 这里计算执行时间 System.currentTimeMillis() - start</span></span><br><span class="line">            <span class="comment">// 结束一个 span</span></span><br><span class="line">            clientTracer.endTrace(System.currentTimeMillis() - start, resultCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总体思路是，Datasource 通过组合的方式自定义一个代理类（实际上也可以理解为适配器模式中的对象适配模型方式），对所有目标对象的方式进行代理拦截，在执行具体的 sql 或者连接操作之前创建 datasource 的 span，在操作结束之后结束 span，并进行上报。</p>
<h2 id="消息埋点"><a href="#消息埋点" class="headerlink" title="消息埋点"></a>消息埋点</h2><p>消息框架组件包括很多，像常见的 RocketMQ、Kafka 等；处理各个组件自己提供的客户端之外，像 Spring 就提供了很多消息组件的封装，包括Spring Cloud Stream、Spring Integration、Spring Message 等等。SOFATracer 基于 Spring Message 标准实现了对常见消息组件和 Spring Cloud Stream 的埋点支持，同时也提供了基于 RocketMQ 客户端模式的埋点实现。</p>
<h3 id="Spring-Messaging-埋点实现原理"><a href="#Spring-Messaging-埋点实现原理" class="headerlink" title="Spring Messaging 埋点实现原理"></a>Spring Messaging 埋点实现原理</h3><p>spring-messaging 模块为集成 messaging api 和消息协议提供支持。这里我们先看一个 pipes-and-filters 架构模型：</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/mq/spring-messaging.jpg" alt=""></p>
<p>spring-messaging 的 support 模块中提供了各种不同的 MessageChannel 实现和 channel interceptor 支持，因此在对 spring-messaging 进行埋点时我们自然就会想到去使用 channel interceptor。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SOFATracer 实现的基于 spring-messaging 消息拦截器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaTracerChannelInterceptor</span> <span class="keyword">implements</span> <span class="title">ChannelInterceptor</span>, <span class="title">ExecutorChannelInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// todo trace</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// THIS IS ChannelInterceptor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 发送之前</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送后</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">postSend</span><span class="params">(Message&lt;?&gt; message, MessageChannel channel, <span class="keyword">boolean</span> sent)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成发送之后</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">afterSendCompletion</span><span class="params">(Message&lt;?&gt; message, MessageChannel channel, <span class="keyword">boolean</span> sent, @Nullable Exception ex)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收消息之前</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">preReceive</span><span class="params">(MessageChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收后</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Message&lt;?&gt; postReceive(Message&lt;?&gt; message, MessageChannel channel) &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成接收消息之后</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">afterReceiveCompletion</span><span class="params">(@Nullable Message&lt;?&gt; message, MessageChannel channel, @Nullable Exception ex)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 ChannelInterceptor 实现了消息传递全生命周期的管控，通过暴露出来的方法，可以轻松的实现各个阶段的扩展埋点。</p>
<h3 id="RocketMQ-埋点实现原理"><a href="#RocketMQ-埋点实现原理" class="headerlink" title="RocketMQ 埋点实现原理"></a>RocketMQ 埋点实现原理</h3><p>RocketMQ 本身是提供了对 Opentracing 规范支持的，由于其支持的版本较高，与 SOFATracer 所实现的 Opentracing 版本不一致，所以在一定程度上不兼容；因此 SOFATracer（opentracing 0.22.0 版本）自身又单独提供了 RocketMQ  的插件。</p>
<p>RocketMQ 埋点其实是通过两个 hook 接口来完成，实际上在 RocketMQ 的官方文档中貌似并没有提到这两个点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RocketMQ 消息消费端 hook 接口埋点实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaTracerConsumeMessageHook</span> <span class="keyword">implements</span> <span class="title">ConsumeMessageHook</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RocketMQ 消息发送端 hook 接口埋点实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaTracerSendMessageHook</span> <span class="keyword">implements</span> <span class="title">SendMessageHook</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>首先是 SendMessageHook 接口，SendMessageHook 接口提供了两个方法，sendMessageBefore 和 sendMessageAfter，SOFATracer 在实现埋点时，sendMessageBefore 中用来解析和构建 span，sendMessageAfter 中用于拿到结果然后结束 span。</p>
<p>同样的，ConsumeMessageHook 中也提供了两个方法（consumeMessageBefore和consumeMessageAfter），可以提供给 SOFATracer 来从消息中解析出透传的 tracer 信息然后再将 tracer 信息透传到下游链路中去。</p>
<h2 id="redis-埋点原理"><a href="#redis-埋点原理" class="headerlink" title="redis 埋点原理"></a>redis 埋点原理</h2><p>SOFATracer 中的 redis 埋点是基于 spring data redis 实现的，没有针对具体的 redis 客户端来埋点。另外 redis 埋点部分参考的是开源社区<a href="https://github.com/opentracing-contrib/java-spring-cloud/tree/master/instrument-starters/opentracing-spring-cloud-redis-starter" target="_blank" rel="noopener">opentracing-spring-cloud-redis-starter</a>中的实现逻辑。</p>
<p>redis 的埋点实现与 Datasource 的锚点实现基本思路是一致的，都是通过一层代理来是实现的拦截。<code>sofa-tracer-redis-plugin</code> 中对所有的 redis 操作都通过 RedisActionWrapperHelper 进行了一层包装，在执行具体的命令前后通过 SOFATracer 自己提供的 API 进行埋点操作。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">doInScope</span><span class="params">(String command, Supplier&lt;T&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建 span</span></span><br><span class="line">    Span span = buildSpan(command);</span><br><span class="line">    <span class="keyword">return</span> activateAndCloseSpan(span, supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 span 的生命周期内执行具体命令</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">activateAndCloseSpan</span><span class="params">(Span span, Supplier&lt;T&gt; supplier)</span> </span>&#123;</span><br><span class="line">    Throwable candidateThrowable = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行命令</span></span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        candidateThrowable = t;</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidateThrowable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过 tracer api 结束一个span</span></span><br><span class="line">        redisSofaTracer.clientReceiveTagFinish((SofaTracerSpan) span, <span class="string">"00"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之后 mongodb 的埋点也是基于 spring data 实现，埋点的实现思路和 redis 基本相同，这里就不在单独分析。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对蚂蚁金服分布式链路组件 SOFATracer 的埋点机制做了简要的介绍；从各个组件的埋点机制来看，整体思路就是对组件操作进行包装，在请求或者命令执行的前后进行 span 构建和上报。目前一些主流的链路跟踪组件像 brave 也是基于此思路，区别在于 brave 并非是直接基于 opentracing 规范进行编码，而是其自己封装了一整套 api ，然后通过面向 opentracing api 进行一层适配；另外一个非常流行的 skywalking 则是基于 java agent 实现，埋点实现的机制上与 SOFATracer 和 brave 不同。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.sofastack.tech/projects/sofa-tracer/overview/" target="_blank" rel="noopener">SOFATracer</a></li>
<li><a href="https://www.cnblogs.com/davidwang456/p/4446796.html" target="_blank" rel="noopener">spring源码分析之spring-messaging模块详解</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2020/01/20/sofa-tracer-integration-analysis/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/12/07/sofa-tracer-mvc-plugin/">SOFATracer 插件埋点机制详解</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-12-07T14:34:14.000Z" itemprop="datePublished">2018/12/07</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/12/07/sofa-tracer-mvc-plugin/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/SOFATracer/" title="SOFATracer">SOFATracer</a>,
  
    <a href="/tags/Disruptor/" title="Disruptor">Disruptor</a>,
  
    <a href="/tags/OpenTracing/" title="OpenTracing">OpenTracing</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<blockquote>
<p>SOFATracer 是一个用于分布式系统调用跟踪的组件，通过统一的 <code>traceId</code> 将调用链路中的各种网络调用情况以日志的方式记录下来，以达到透视化网络调用的目的。这些日志可用于故障的快速发现，服务治理等。</p>
</blockquote>
<p>从 <a href="http://www.sofastack.tech/sofa-tracer/docs/roadmap" target="_blank" rel="noopener">RoadMap</a> 和 <a href="https://github.com/alipay/sofa-tracer/pulls" target="_blank" rel="noopener">PR</a> 来看，目前 SOFATracer 已经支持了丰富的组件插件埋点。</p>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543318400761-682a9d1a-b194-4a87-9fac-9e1a38a9247e.png" alt="img"></p>
<p>目前还未支持的主要是 Dubbo、MQ 以及 Redis 等。本文将从 SOFATracer 已提供的一个插件源码来分析下 SOFATracer 插件的埋点实现。</p>
<h2 id="1-SOFATracer-插件埋点机制"><a href="#1-SOFATracer-插件埋点机制" class="headerlink" title="1 SOFATracer 插件埋点机制"></a>1 SOFATracer 插件埋点机制</h2><p>SOFATracer 插件的作用实际上就是对于不同组件进行埋点，以便于收集这些组件的链路数据。SOFATracer 埋点方式一般是通过 Filter、Interceptor 机制实现的。</p>
<p>另一个是，SOFATracer 的埋点方式并不是基于 OT-api 进行埋点的，而是基于 SOFATracer 自己的 api 进行埋点的，详见 <a href="https://github.com/alipay/sofa-tracer/issues/126" target="_blank" rel="noopener">issue#126</a>。</p>
<h3 id="1-1-Filter-or-Interceptor"><a href="#1-1-Filter-or-Interceptor" class="headerlink" title="1.1 Filter or Interceptor"></a>1.1 Filter or Interceptor</h3><p>目前已实现的插件中，像 MVC 插件是基于 Filter 进行埋点的，httpclient、resttemplate 等是基于Interceptor进行埋点的。在实现插件时，要根据不同插件的特性来选择具体的埋点方式。</p>
<p> 当然除了这两种方式之外还可以通过静态代理的方式来实现埋点。比如 sofa-tracer-datasource-plugin 插件就是将不同的数据源进行统一代理给 SmartDatasource，从而实现埋点的。</p>
<h3 id="1-2-AbstractTracer-API"><a href="#1-2-AbstractTracer-API" class="headerlink" title="1.2 AbstractTracer API"></a>1.2 AbstractTracer API</h3><p>SOFATracer 中所有的插件均需要实现自己的 Tracer 实例，如 Mvc 的 SpringMvcTracer 、HttpClient的 HttpClientTracer 等，这一点与基于 Opentracing-api 接口埋点的实现有所区别。</p>
<ul>
<li>1、基于 SOFATracer api 埋点方式插件扩展</li>
</ul>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543324415543-aba1c5fe-7cb4-46ae-9aee-2fe5441a5f98.png" alt="img"></p>
<p>AbstractTracer 是 SOFATracer 用于插件扩展使用的一个抽象类，根据插件类型不同，又可以分为 clientTracer 和 serverTracer，分别对应于：AbstractClientTracer 和 AbstractServerTracer，再通过 AbstractClientTracer 和 AbstractServerTracer 衍生出具体的组件 Tracer 实现。这种方式的好处在于，所有的插件实现均由 SOFATracer 本身来管控，对于不同的组件可以轻松的实现差异化和定制化。缺点也源于此，每增加一个组件都需要做一些重复工作。</p>
<ul>
<li>2、基于 OpenTracing-api 埋点方式插件扩展</li>
</ul>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543324680485-cdb3793c-b830-490e-832f-b58e12091f7d.png" alt="img"></p>
<p>这种埋点方式不基于 SOFATracer  自身提供的 API，而是基于 OpenTracing-api 接口。因为均遵循 OpenTracing-api 规范，所以组件和 Tracer 实现可以独立分开来维护。这样就可以对接开源的一些基于 OpenTracing-api 规范实现的组件。例如：<a href="https://github.com/opentracing-contrib" target="_blank" rel="noopener">OpenTracing API Contributions</a>。</p>
<p>SOFATracer 在后面将会在 4.0 版本中支持基于 OT-api 的埋点方式，对外部组件接入扩展提供支持。</p>
<h3 id="1-3-AbstractTracer"><a href="#1-3-AbstractTracer" class="headerlink" title="1.3 AbstractTracer"></a>1.3 AbstractTracer</h3><p>这里先来看下 AbstractTracer  这个抽象类中具体提供了哪些抽象方法，也就是对于 AbstractClientTracer 和 AbstractServerTracer 需要分别扩展哪些能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取client端 摘要日志日志名</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getClientDigestReporterLogName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取client端 摘要日志滚动策略key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getClientDigestReporterRollingKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取client端 摘要日志日志名key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getClientDigestReporterLogNameKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取client端 摘要日志编码器</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getClientDigestEncoder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 创建client端 统计日志Reporter类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> AbstractSofaTracerStatisticReporter <span class="title">generateClientStatReporter</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志日志名</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getServerDigestReporterLogName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志滚动策略key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getServerDigestReporterRollingKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志日志名key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getServerDigestReporterLogNameKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志编码器</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getServerDigestEncoder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 创建server端 统计日志Reporter类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> AbstractSofaTracerStatisticReporter <span class="title">generateServerStatReporter</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>从  AbstractTracer 类提供的抽象方法来看，不管是 client 还是 server，在具体的 Tracer 组件实现中，都必须提供以下实现：</p>
<ul>
<li>DigestReporterLogName :当前组件摘要日志的日志名称</li>
<li>DigestReporterRollingKey : 当前组件摘要日志的滚动策略</li>
<li>SpanEncoder：对摘要日志进行编码的编码器实现</li>
<li>AbstractSofaTracerStatisticReporter : 统计日志 reporter 类的实现类。</li>
</ul>
<h2 id="2-SpringMVC-插件埋点分析"><a href="#2-SpringMVC-插件埋点分析" class="headerlink" title="2 SpringMVC 插件埋点分析"></a>2 SpringMVC 插件埋点分析</h2><p>这里我们以 SpringMVC 插件为例，来分析下如何实现一个埋点插件的。这里是官方给出的案例工程：基于 <a href="https://github.com/alipay/sofa-tracer/blob/master/tracer-samples/tracer-sample-with-springmvc" target="_blank" rel="noopener">Spring MVC 示例落地日志</a> 。</p>
<h3 id="2-1-实现-Tracer-实例"><a href="#2-1-实现-Tracer-实例" class="headerlink" title="2.1 实现 Tracer 实例"></a>2.1 实现 Tracer 实例</h3><p>SpringMvcTracer 继承了 AbstractServerTracer 类，是对 serverTracer 的扩展。</p>
<blockquote>
<p>PS：如何确定一个组件是client端还是server端呢？就是看当前组件是请求的发起方还是请求的接受方，如果是请求发起方则一般是client端，如果是请求接收方则是 server 端。那么对于 MVC 来说，是请求接受方，因此这里实现了 AbstractServerTracer 类。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcTracer</span> <span class="keyword">extends</span> <span class="title">AbstractServerTracer</span></span></span><br></pre></td></tr></table></figure>
<h4 id="2-1-1-构造函数与单例对象"><a href="#2-1-1-构造函数与单例对象" class="headerlink" title="2.1.1 构造函数与单例对象"></a>2.1.1 构造函数与单例对象</h4><p>在构造函数中，需要传入当前 Tracer 的 traceType，SpringMvcTracer 的 traceType 为 “springmvc”。这里也可以看到，tracer 实例是一个单例对象，对于其他插件也是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SpringMvcTracer springMvcTracer = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * Spring MVC Tracer Singleton</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> singleton</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SpringMvcTracer <span class="title">getSpringMvcTracerSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (springMvcTracer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SpringMvcTracer.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (springMvcTracer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                springMvcTracer = <span class="keyword">new</span> SpringMvcTracer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> springMvcTracer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SpringMvcTracer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"springmvc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-AbstractServerTracer-抽象类"><a href="#2-1-2-AbstractServerTracer-抽象类" class="headerlink" title="2.1.2 AbstractServerTracer 抽象类"></a>2.1.2 AbstractServerTracer 抽象类</h4><p>在看 SpringMvcTracer 实现之前，先来看下 AbstractServerTracer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractServerTracer</span> <span class="keyword">extends</span> <span class="title">AbstractTracer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数，子类必须提供一个构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractServerTracer</span><span class="params">(String tracerType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(tracerType, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为是server端，所以Client先关的提供了默认实现，返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getClientDigestReporterLogName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getClientDigestReporterRollingKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getClientDigestReporterLogNameKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getClientDigestEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AbstractSofaTracerStatisticReporter <span class="title">generateClientStatReporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合上面  AbstractTracer 小节中抽象方法分析，这里在 AbstractServerTracer 中将 client 对应的抽象方法提供了默认实现，也就是说如果要继承 AbstractServerTracer 类，那么就必须实现 server 对应的所有抽象方法。</p>
<h4 id="2-1-3-SpringMVCTracer-实现"><a href="#2-1-3-SpringMVCTracer-实现" class="headerlink" title="2.1.3 SpringMVCTracer 实现"></a>2.1.3 SpringMVCTracer 实现</h4><p>下面是 SpringMvcTracer 部分对 server 部分抽象方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getServerDigestReporterLogName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SpringMvcLogEnum.SPRING_MVC_DIGEST.getDefaultLogName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getServerDigestReporterRollingKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SpringMvcLogEnum.SPRING_MVC_DIGEST.getRollingKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getServerDigestReporterLogNameKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SpringMvcLogEnum.SPRING_MVC_DIGEST.getLogNameKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getServerDigestEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Boolean.TRUE.toString().equalsIgnoreCase(</span><br><span class="line">        SofaTracerConfiguration.getProperty(SPRING_MVC_JSON_FORMAT_OUTPUT))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringMvcDigestJsonEncoder();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringMvcDigestEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AbstractSofaTracerStatisticReporter <span class="title">generateServerStatReporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> generateSofaMvcStatReporter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前 SOFATracer 日志名、滚动策略key等都是通过枚举类来定义的，也就是一个组件会对应这样一个枚举类，在枚举类里面定义这些常量。</p>
<h3 id="2-2-SpringMvcLogEnum-类实现"><a href="#2-2-SpringMvcLogEnum-类实现" class="headerlink" title="2.2 SpringMvcLogEnum 类实现"></a>2.2 SpringMvcLogEnum 类实现</h3><p>SpringMVC 插件中的枚举类是 SpringMvcLogEnum。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SpringMvcLogEnum &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 摘要日志相关</span></span><br><span class="line">    SPRING_MVC_DIGEST(<span class="string">"spring_mvc_digest_log_name"</span>, </span><br><span class="line">                      <span class="string">"spring-mvc-digest.log"</span>,</span><br><span class="line">                      <span class="string">"spring_mvc_digest_rolling"</span>), </span><br><span class="line">    <span class="comment">// 统计日志相关</span></span><br><span class="line">    SPRING_MVC_STAT(<span class="string">"spring_mvc_stat_log_name"</span>, </span><br><span class="line">                    <span class="string">"spring-mvc-stat.log"</span>, </span><br><span class="line">                    <span class="string">"spring_mvc_stat_rolling"</span>);</span><br><span class="line">    <span class="comment">// 省略部分代码....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 XXXLogEnum 枚举类中定义了当前组件对应的摘要日志和统计日志的日志名和滚动策略，因为 SOFATracer 目前还没有服务端的能力，链路数据不是直接上报给 server 的，因此 SOFATracer 提供了落到磁盘的能力。不同插件的链路日志也会通过 XXXLogEnum 指定的名称将链路日志输出到各个组件对应的日志目录下。</p>
<h3 id="2-3-统计日志-Reportor-实现"><a href="#2-3-统计日志-Reportor-实现" class="headerlink" title="2.3 统计日志 Reportor 实现"></a>2.3 统计日志 Reportor 实现</h3><p>SOFATracer 中统计日志打印的实现需要各个组件自己来完成，具体就是需要实现一个AbstractSofaTracerStatisticReporter 的子类，然后实现 doReportStat 这个方法。当然对于目前的实现来说，我们也会重写 print 方法。</p>
<h4 id="2-3-1-doReportStat"><a href="#2-3-1-doReportStat" class="headerlink" title="2.3.1 doReportStat"></a>2.3.1 doReportStat</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doReportStat</span><span class="params">(SofaTracerSpan sofaTracerSpan)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; tagsWithStr = sofaTracerSpan.getTagsWithStr();</span><br><span class="line">    <span class="comment">// 构建StatMapKey对象</span></span><br><span class="line">    StatMapKey statKey = <span class="keyword">new</span> StatMapKey();</span><br><span class="line">    <span class="comment">// 增加 key:当前应用名</span></span><br><span class="line">    statKey.addKey(CommonSpanTags.LOCAL_APP, tagsWithStr.get(CommonSpanTags.LOCAL_APP));</span><br><span class="line">    <span class="comment">// 增加 key:请求 url</span></span><br><span class="line">    statKey.addKey(CommonSpanTags.REQUEST_URL, tagsWithStr.get(CommonSpanTags.REQUEST_URL));</span><br><span class="line">    <span class="comment">// 增加 key:请求方法</span></span><br><span class="line">    statKey.addKey(CommonSpanTags.METHOD, tagsWithStr.get(CommonSpanTags.METHOD));</span><br><span class="line">    <span class="comment">// 压测标志</span></span><br><span class="line">    statKey.setLoadTest(TracerUtils.isLoadTest(sofaTracerSpan));</span><br><span class="line">    <span class="comment">// 请求响应码</span></span><br><span class="line">    String resultCode = tagsWithStr.get(CommonSpanTags.RESULT_CODE);</span><br><span class="line">    <span class="comment">// 请求成功标识</span></span><br><span class="line">    <span class="keyword">boolean</span> success = (resultCode != <span class="keyword">null</span> &amp;&amp; resultCode.length() &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span></span><br><span class="line">        .isHttpOrMvcSuccess(resultCode));</span><br><span class="line">    statKey.setResult(success ? <span class="string">"true"</span> : <span class="string">"false"</span>);</span><br><span class="line">    <span class="comment">//end</span></span><br><span class="line">    statKey.setEnd(TracerUtils.getLoadTestMark(sofaTracerSpan));</span><br><span class="line">    <span class="comment">//value the count and duration</span></span><br><span class="line">    <span class="keyword">long</span> duration = sofaTracerSpan.getEndTime() - sofaTracerSpan.getStartTime();</span><br><span class="line">    <span class="keyword">long</span> values[] = <span class="keyword">new</span> <span class="keyword">long</span>[] &#123; <span class="number">1</span>, duration &#125;;</span><br><span class="line">    <span class="comment">// reserve</span></span><br><span class="line">    <span class="keyword">this</span>.addStat(statKey, values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这里就是就是将统计日志添加到日志槽里，等待被消费(输出到日志)。具体可以参考：SofaTracerStatisticReporterManager.StatReporterPrinter。</p>
<h4 id="2-3-2-print"><a href="#2-3-2-print" class="headerlink" title="2.3.2 print"></a>2.3.2 print</h4><p>print 方法是实际将数据写入到磁盘的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(StatKey statKey, <span class="keyword">long</span>[] values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isClosePrint.get()) &#123;</span><br><span class="line">        <span class="comment">//关闭统计日志输出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(statKey <span class="keyword">instanceof</span> StatMapKey)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StatMapKey statMapKey = (StatMapKey) statKey;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 构建需要打印的数据串</span></span><br><span class="line">        jsonBuffer.reset();</span><br><span class="line">        jsonBuffer.appendBegin();</span><br><span class="line">        jsonBuffer.append(<span class="string">"time"</span>, Timestamp.currentTime());</span><br><span class="line">        jsonBuffer.append(<span class="string">"stat.key"</span>, <span class="keyword">this</span>.statKeySplit(statMapKey));</span><br><span class="line">        jsonBuffer.append(<span class="string">"count"</span>, values[<span class="number">0</span>]);</span><br><span class="line">        jsonBuffer.append(<span class="string">"total.cost.milliseconds"</span>, values[<span class="number">1</span>]);</span><br><span class="line">        jsonBuffer.append(<span class="string">"success"</span>, statMapKey.getResult());</span><br><span class="line">        <span class="comment">//压测</span></span><br><span class="line">        jsonBuffer.appendEnd(<span class="string">"load.test"</span>, statMapKey.getEnd());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (appender <span class="keyword">instanceof</span> LoadTestAwareAppender) &#123;</span><br><span class="line">            ((LoadTestAwareAppender) appender).append(jsonBuffer.toString(),</span><br><span class="line">                statMapKey.isLoadTest());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            appender.append(jsonBuffer.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里强制刷一次</span></span><br><span class="line">        appender.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        SelfLog.error(<span class="string">"统计日志&lt;"</span> + statTracerName + <span class="string">"&gt;输出异常"</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>print 这个方法里面就是将 statMapKey 中，也就是 doReportStat 中塞进来的数据转换成  json 格式，然后刷到磁盘。需要注意的是这里是强制 flush 了一次。如果没有重写 print 这个方法的话，则是在SofaTracerStatisticReporterManager.StatReporterPrinter 里面调用 print 方法刷到磁盘。</p>
<h3 id="2-4-数据传播格式实现"><a href="#2-4-数据传播格式实现" class="headerlink" title="2.4 数据传播格式实现"></a>2.4 数据传播格式实现</h3><p>SOFATracer 支持使用 OpenTracing 的内建格式进行上下文传播。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcHeadersCarrier</span> <span class="keyword">implements</span> <span class="title">TextMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, String&gt; headers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpringMvcHeadersCarrier</span><span class="params">(HashMap&lt;String, String&gt; headers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.headers = headers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        headers.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> headers.entrySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-自定义编码格式实现"><a href="#2-5-自定义编码格式实现" class="headerlink" title="2.5 自定义编码格式实现"></a>2.5 自定义编码格式实现</h3><p>这个决定了摘要日志打印的格式，和在统计日志里面的实现要有所区分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcDigestJsonEncoder</span> <span class="keyword">extends</span> <span class="title">AbstractDigestSpanEncoder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重写encode,对span进行编码处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(SofaTracerSpan span)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        JsonStringBuilder jsonStringBuilder = <span class="keyword">new</span> JsonStringBuilder();</span><br><span class="line">        <span class="comment">//日志打印时间</span></span><br><span class="line">        jsonStringBuilder.appendBegin(<span class="string">"time"</span>, Timestamp.format(span.getEndTime()));</span><br><span class="line">        appendSlot(jsonStringBuilder, span);</span><br><span class="line">        <span class="keyword">return</span> jsonStringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具体字段处理</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendSlot</span><span class="params">(JsonStringBuilder jsonStringBuilder, SofaTracerSpan sofaTracerSpan)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        SofaTracerSpanContext context = sofaTracerSpan.getSofaTracerSpanContext();</span><br><span class="line">        Map&lt;String, String&gt; tagWithStr = sofaTracerSpan.getTagsWithStr();</span><br><span class="line">        Map&lt;String, Number&gt; tagWithNumber = sofaTracerSpan.getTagsWithNumber();</span><br><span class="line">        <span class="comment">//当前应用名</span></span><br><span class="line">        jsonStringBuilder</span><br><span class="line">            .append(CommonSpanTags.LOCAL_APP, tagWithStr.get(CommonSpanTags.LOCAL_APP));</span><br><span class="line">        <span class="comment">//TraceId</span></span><br><span class="line">        jsonStringBuilder.append(<span class="string">"traceId"</span>, context.getTraceId());</span><br><span class="line">        <span class="comment">//RpcId</span></span><br><span class="line">        jsonStringBuilder.append(<span class="string">"spanId"</span>, context.getSpanId());</span><br><span class="line">        <span class="comment">//请求 URL</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.REQUEST_URL,</span><br><span class="line">            tagWithStr.get(CommonSpanTags.REQUEST_URL));</span><br><span class="line">        <span class="comment">//请求方法</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.METHOD, tagWithStr.get(CommonSpanTags.METHOD));</span><br><span class="line">        <span class="comment">//Http 状态码</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.RESULT_CODE,</span><br><span class="line">            tagWithStr.get(CommonSpanTags.RESULT_CODE));</span><br><span class="line">        Number requestSize = tagWithNumber.get(CommonSpanTags.REQ_SIZE);</span><br><span class="line">        <span class="comment">//Request Body 大小 单位为byte</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.REQ_SIZE,</span><br><span class="line">            (requestSize == <span class="keyword">null</span> ? <span class="number">0L</span> : requestSize.longValue()));</span><br><span class="line">        Number responseSize = tagWithNumber.get(CommonSpanTags.RESP_SIZE);</span><br><span class="line">        <span class="comment">//Response Body 大小，单位为byte</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.RESP_SIZE, (responseSize == <span class="keyword">null</span> ? <span class="number">0L</span></span><br><span class="line">            : responseSize.longValue()));</span><br><span class="line">        <span class="comment">//请求耗时（MS）</span></span><br><span class="line">        jsonStringBuilder.append(<span class="string">"time.cost.milliseconds"</span>,</span><br><span class="line">            (sofaTracerSpan.getEndTime() - sofaTracerSpan.getStartTime()));</span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.CURRENT_THREAD_NAME,</span><br><span class="line">            tagWithStr.get(CommonSpanTags.CURRENT_THREAD_NAME));</span><br><span class="line">        <span class="comment">//穿透数据放在最后</span></span><br><span class="line">        jsonStringBuilder.appendEnd(<span class="string">"baggage"</span>, baggageSerialized(context));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里其实也可以看出，统计日志和摘要日志的不同点。统计日志里面核心的数据是 span 里面的 tags 数据，但是其主要作用是统计当前组件的次数。摘要日志里面除了 tags 里面的数据之外还会包括例如 traceId 和 spanId 等信息。</p>
<ul>
<li>统计日志</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"time"</span>:<span class="string">"2018-11-28 14:42:25.127"</span>,<span class="attr">"stat.key"</span>:&#123;<span class="attr">"method"</span>:<span class="string">"GET"</span>,<span class="attr">"local.app"</span>:<span class="string">"SOFATracerSpringMVC"</span>,<span class="attr">"request.url"</span>:<span class="string">"http://localhost:8080/springmvc"</span>&#125;,<span class="attr">"count"</span>:<span class="number">3</span>,<span class="attr">"total.cost.milliseconds"</span>:<span class="number">86</span>,<span class="attr">"success"</span>:<span class="string">"true"</span>,<span class="attr">"load.test"</span>:<span class="string">"F"</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>摘要日志</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"time"</span>:<span class="string">"2018-11-28 14:46:08.216"</span>,<span class="attr">"local.app"</span>:<span class="string">"SOFATracerSpringMVC"</span>,<span class="attr">"traceId"</span>:<span class="string">"0a0fe91b1543387568214100259231"</span>,<span class="attr">"spanId"</span>:<span class="string">"0.1"</span>,<span class="attr">"request.url"</span>:<span class="string">"http://localhost:8080/springmvc"</span>,<span class="attr">"method"</span>:<span class="string">"GET"</span>,<span class="attr">"result.code"</span>:<span class="string">"200"</span>,<span class="attr">"req.size.bytes"</span>:<span class="number">-1</span>,<span class="attr">"resp.size.bytes"</span>:<span class="number">0</span>,<span class="attr">"time.cost.milliseconds"</span>:<span class="number">2</span>,<span class="attr">"current.thread.name"</span>:<span class="string">"http-nio-8080-exec-2"</span>,<span class="attr">"baggage"</span>:<span class="string">""</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-请求拦截埋点"><a href="#2-6-请求拦截埋点" class="headerlink" title="2.6 请求拦截埋点"></a>2.6 请求拦截埋点</h3><p>对于基于标准 servlet 实现的组件，要实现对请求的拦截过滤，通常就是 Filter 了。sofa-tracer-springmvc-plugin 插件埋点的实现就是基于 Filter 机制完成的。</p>
<p>SpringMvcSofaTracerFilter 实现了 javax.servlet.Filter 接口，因此遵循标准的 servlet 规范的容器也可以通过此插件进行埋点。参考文档：<a href="https://github.com/alipay/sofa-tracer/tree/master/tracer-samples/tracer-sample-with-springmvc" target="_blank" rel="noopener">对于标准 servlet 容器的支持（ tomcat/jetty 等）</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcSofaTracerFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span></span><br></pre></td></tr></table></figure>
<h4 id="2-6-1-基本埋点思路"><a href="#2-6-1-基本埋点思路" class="headerlink" title="2.6.1 基本埋点思路"></a>2.6.1 基本埋点思路</h4><p>对于一个组件来说，一次处理过程一般是产生一个 span。这个span的生命周期是从接收到请求到返回响应这段过程。</p>
<p>但是这里需要考虑的问题是如何与上下游链路关联起来呢？在 Opentracing 规范中，可以在 Tracer 中 extract 出一个跨进程传递的 SpanContext 。然后通过这个 SpanContext 所携带的信息将当前节点关联到整个 tracer 链路中去。当然有提取(extract)就会有对应的注入(inject)。</p>
<p>链路的构建一般是 client-server-client-server 这种模式的，那这里就很清楚了，就是会在 client 端进行注入(inject)，然后再 server 端进行提取(extract)，反复进行，然后一直传递下去。</p>
<p> 在拿到 SpanContext 之后，此时当前的 span 就可以关联到这条链路中了，那么剩余的事情就是收集当前组件的一些数据。</p>
<p>整个过程大概分为以下几个阶段：</p>
<ul>
<li>从请求中提取 spanContext</li>
<li>构建 span，并将当前 span 存入当前 tracer上下文中（SofaTraceContext.push(span)） 。</li>
<li>设置一些信息到span中</li>
<li>返回响应</li>
<li>span结束&amp;上报</li>
</ul>
<p>下面逐一分析下这几个过程。</p>
<h4 id="2-6-2-从请求中提取-spanContext"><a href="#2-6-2-从请求中提取-spanContext" class="headerlink" title="2.6.2 从请求中提取 spanContext"></a>2.6.2 从请求中提取 spanContext</h4><p>这里的提取用到了上面我们提到的#数据传播格式实现#SpringMvcHeadersCarrier 这个类。上面分析到，因为mvc 做作为 server 端存在的，所以在 server 端就是从请求中 extract 出 SpanContext。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SofaTracerSpanContext <span class="title">getSpanContextFromRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="comment">// 获取请求头信息 </span></span><br><span class="line">    Enumeration headerNames = request.getHeaderNames();</span><br><span class="line">    <span class="keyword">while</span> (headerNames.hasMoreElements()) &#123;</span><br><span class="line">        String key = (String) headerNames.nextElement();</span><br><span class="line">        String value = request.getHeader(key);</span><br><span class="line">        headers.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿到 SofaTracer 实例对象</span></span><br><span class="line">    SofaTracer tracer = springMvcTracer.getSofaTracer();</span><br><span class="line">    <span class="comment">// 解析出 SofaTracerSpanContext（SpanContext的实现类）</span></span><br><span class="line">    SofaTracerSpanContext spanContext = (SofaTracerSpanContext) tracer.extract(</span><br><span class="line">        ExtendFormat.Builtin.B3_HTTP_HEADERS, <span class="keyword">new</span> SpringMvcHeadersCarrier(headers));</span><br><span class="line">    spanContext.setSpanId(spanContext.nextChildContextId());</span><br><span class="line">    <span class="keyword">return</span> spanContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-6-3-获取-span-amp-数据获取"><a href="#2-6-3-获取-span-amp-数据获取" class="headerlink" title="2.6.3 获取 span &amp; 数据获取"></a>2.6.3 获取 span &amp; 数据获取</h4><p>serverReceive 这个方法是在 AbstractTracer 类中提供了实现，子类不需要关注这个。在 SOFATracer 中将请求大致分为以下几个过程：</p>
<ul>
<li>客户端发送请求  clientSend      cs</li>
<li>服务端接受请求  serverReceive sr</li>
<li>服务端返回结果  serverSend     ss</li>
<li>客户端接受结果  clientReceive  cr</li>
</ul>
<p>无论是哪个插件，在请求处理周期内都可以从上述几个阶段中找到对应的处理方法。因此，SOFATracer 对这几个阶段处理进行了封装。这四个阶段实际上会产生两个 span，第一个 span 的起点是 cs，到 cr 结束；第二个 span是从 sr 开始，到 ss 结束。也就是说当执行 clientSend 和 serverReceive 时会返回一个 span 对象。来看下MVC中的实现：</p>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543395049905-22e60dd7-1b88-4d94-9b2d-39c94ce909c7.png" alt="img"></p>
<p>红色框内对应的服务端接受请求，也就是 sr 阶段，产生了一个 span 。红色框下面的这段代码是为当前这个 span 设置一些基本的信息，包括当前应用的应用名、当前请求的url、当前请求的请求方法以及请求大小。</p>
<h4 id="2-6-4-返回响应与结束-span"><a href="#2-6-4-返回响应与结束-span" class="headerlink" title="2.6.4 返回响应与结束 span"></a>2.6.4 返回响应与结束 span</h4><p>在 filter 链执行结束之后，在 finally 块中又补充了当前请求响应结果的一些信息到 span 中去。然后调用serverSend 结束当前 span。这里关于 serverSend 里面的逻辑就不展开说了，不过能够想到的是这里肯定是调用span.finish 这个方法( opentracing 规范中，span.finish 的执行标志着一个 span 的结束)，当前也会包括对于数据上报的一些逻辑处理等。</p>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543395799817-68deb1fd-e481-4230-a338-3bbf8512a8f8.png" alt="img"></p>
<h2 id="3-思路总结与插件编写流程"><a href="#3-思路总结与插件编写流程" class="headerlink" title="3 思路总结与插件编写流程"></a>3 思路总结与插件编写流程</h2><p>在第2节中以 SpringMVC 插件为例，分析了下  SOFATracer 插件埋点实现的一些细节。那么本节则从整体思路上来总结下如何编写一个 SOFATracer 的插件。</p>
<ul>
<li>1、确定所要实现的插件，然后确定以哪种方式来埋点</li>
<li>2、实现当前插件的 Tracer 实例，这里需要明确当前插件是以 client 存在还是以 server 存在。</li>
<li>3、实现一个枚举类，用来描述当前组件的日志名称和滚动策略 key 值等</li>
<li>4、实现插件摘要日志的 encoder ，实现当前组件的定制化输出</li>
<li>5、实现插件的统计日志 Reporter 实现类，通过继承 AbstractSofaTracerStatisticReporter 类并重写doReportStat。</li>
<li><p>6、定义当前插件的传播格式</p>
<p>当然最重要的还是对于要实现插件的理解，要明确我们需要收集哪些数据。</p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文先介绍了SOFATracer的埋点方式与标准OT-api 埋点方式的区别，然后对 SOFATracer 中 SpringMVC 插件的埋点实现进行了分析。希望通过本文能够让更多的同学理解埋点实现这样一个过程以及需要关注的一些点。如果有兴趣或者有什么实际的需求，欢迎来讨论。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/12/07/sofa-tracer-mvc-plugin/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/sofa-tracer-disruptor/">SOFATracer 中 Disruptor 实践</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T04:26:20.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/sofa-tracer-disruptor/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/SOFATracer/" title="SOFATracer">SOFATracer</a>,
  
    <a href="/tags/Disruptor/" title="Disruptor">Disruptor</a>,
  
    <a href="/tags/OpenTracing/" title="OpenTracing">OpenTracing</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<h2 id="OpenTraceing-规范"><a href="#OpenTraceing-规范" class="headerlink" title="OpenTraceing 规范"></a>OpenTraceing 规范</h2><ul>
<li><a href="https://github.com/opentracing-contrib/opentracing-specification-zh/blob/master/specification.md" target="_blank" rel="noopener">OpenTracing语义标准</a></li>
<li><a href="https://github.com/opentracing-contrib/opentracing-specification-zh/blob/master/semantic_conventions.md" target="_blank" rel="noopener">语义惯例</a></li>
<li><a href="http://opentracing.io/documentation/pages/spec" target="_blank" rel="noopener">官方文档</a></li>
</ul>
<h2 id="SOFATracer-对-OpenTraceing-的实现"><a href="#SOFATracer-对-OpenTraceing-的实现" class="headerlink" title="SOFATracer 对 OpenTraceing 的实现"></a>SOFATracer 对 OpenTraceing 的实现</h2><blockquote>
<p>SOFATracer  就是根据 OpenTracing 规范 衍生出来的分布式 链路跟 踪的解决方案。</p>
</blockquote>
<ul>
<li><a href="https://github.com/alipay/sofa-tracer" target="_blank" rel="noopener">GitHub SOFATrcer</a></li>
</ul>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>OpenTracing</code> 标准中有三个重要的相互关联的类型，分别是<code>Tracer</code>, <code>Span</code>和 <code>SpanContext</code>。</p>
<blockquote>
<p>【下面的概念说明过程中，如不做说明，所使用的案例代码均以SOFATracer中的实现为例。】</p>
</blockquote>
<h3 id="Tracer"><a href="#Tracer" class="headerlink" title="Tracer"></a>Tracer</h3><p>一个 <code>trace</code> 代表一个潜在的，分布式的，存在并行数据或并行执行轨迹（潜在的分布式、并行）的系统。一个<code>trace</code>可以认为是多个<code>span</code>的有向无环图（<code>DAG</code>）。</p>
<p>Tracer接口用来创建Span，以及处理如何处理Inject(serialize) 和 Extract (deserialize)，用于跨进程边界传递。</p>
<p><code>SOFATracer</code> 中 <code>SofaTracer</code>这个类实现了 <code>opentracing</code> 的 <code>Tracer</code> 接口，并在此规范接口上做了一些扩展。看下<code>Tracer</code> 中声明的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tracer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//启动一个新的span</span></span><br><span class="line">    <span class="function">SpanBuilder <span class="title">buildSpan</span><span class="params">(String operationName)</span></span>;</span><br><span class="line">    <span class="comment">//将SpanContext上下文Inject（注入）到carrier</span></span><br><span class="line">    &lt;C&gt; <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(SpanContext spanContext, Format&lt;C&gt; format, C carrier)</span></span>;</span><br><span class="line">    <span class="comment">//将SpanContext上下文从carrier中Extract（提取）</span></span><br><span class="line">    &lt;C&gt; <span class="function">SpanContext <span class="title">extract</span><span class="params">(Format&lt;C&gt; format, C carrier)</span></span>;   </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">SpanBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以从接口定义来看，要实现一个Tracer，必须要实现其以下的几个能力：</p>
<h4 id="启动一个新的span"><a href="#启动一个新的span" class="headerlink" title="启动一个新的span"></a>启动一个新的span</h4><p><code>SOFATracer</code> 实现了 <code>Tracer</code> 中 <code>buildSpan</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpanBuilder <span class="title">buildSpan</span><span class="params">(String operationName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SofaTracerSpanBuilder(operationName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>operationName</code> :操作名称，字符串类型，表示由Span完成的工作 (例如，RPC方法名称、函数名称或一个较大的计算任务中的阶段的名称)。操作名称应该用泛化的字符串形式标识出一个Span实例。</p>
<p>何为泛化的字符串形式，比如现在有一个操作：获取用户 ；下面有几种标识方式：</p>
<ul>
<li>1、/get</li>
<li>2、/get/user</li>
<li>3、/get/user/123</li>
</ul>
<p>方式1过于抽象，方式3过于具体。方式2是正确的操作名。</p>
<h4 id="将SpanContext上下文Inject（注入）到carrier"><a href="#将SpanContext上下文Inject（注入）到carrier" class="headerlink" title="将SpanContext上下文Inject（注入）到carrier"></a>将SpanContext上下文Inject（注入）到carrier</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;C&gt; <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(SpanContext spanContext, Format&lt;C&gt; format, C carrier)</span> </span>&#123;</span><br><span class="line">    RegistryExtractorInjector&lt;C&gt; registryInjector = TracerFormatRegistry.getRegistry(format);</span><br><span class="line">    <span class="keyword">if</span> (registryInjector == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported injector format: "</span> + format);</span><br><span class="line">    &#125;</span><br><span class="line">    registryInjector.inject((SofaTracerSpanContext) spanContext, carrier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>SpanContext</code> :实例</li>
<li><code>format</code>（格式化）描述，一般会是一个字符串常量，但不做强制要求。通过此描述，通知Tracer实现，如何对SpanContext进行编码放入到carrier中。<br>carrier，根据format确定。Tracer实现根据format声明的格式，将SpanContext序列化到carrier对象中。</li>
</ul>
<blockquote>
<p>RegistryExtractorInjector 见后面</p>
</blockquote>
<h4 id="将SpanContext上下文从carrier中Extract（提取）"><a href="#将SpanContext上下文从carrier中Extract（提取）" class="headerlink" title="将SpanContext上下文从carrier中Extract（提取）"></a>将SpanContext上下文从carrier中Extract（提取）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;C&gt; <span class="function">SpanContext <span class="title">extract</span><span class="params">(Format&lt;C&gt; format, C carrier)</span> </span>&#123;</span><br><span class="line">    RegistryExtractorInjector&lt;C&gt; registryExtractor = TracerFormatRegistry.getRegistry(format);</span><br><span class="line">    <span class="keyword">if</span> (registryExtractor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported extractor format: "</span> + format);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> registryExtractor.extract(carrier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>格式描述符(<code>format descriptor</code>)(通常但不一定是字符串常量)，告诉<code>Tracer</code>的实现如何在载体对象中对<code>SpanContext</code>进行编码</li>
<li>载体(<code>carrier</code>)，其类型由格式描述符指定<code>。Tracer</code>的实现将根据格式描述对此载体对象中的<code>SpanContext</code>进行编码</li>
</ul>
<p>返回一个<code>SpanContext</code>实例，可以使用这个<code>SpanContext</code>实例，通过<code>Tracer</code>创建新的<code>Span</code>。</p>
<h4 id="Format"><a href="#Format" class="headerlink" title="Format"></a>Format</h4><p>从<code>Tracer</code>的注入和提取来看，<code>format</code>都是必须的。</p>
<p><code>Inject</code>（注入）和<code>Extract</code>（提取）依赖于可扩展的<code>format</code>参数。<code>forma</code>t参数规定了另一个参数<code>&quot;carrier&quot;</code>的类型，同时约束了<code>&quot;carrier&quot;</code>中<code>SpanContext</code>是如何编码的。所有的<code>Tracer</code>实现，都必须支持下面的<code>format</code>。</p>
<ul>
<li><code>Text Map</code>: 基于字符串：字符串的<code>map</code>,对于<code>key</code>和<code>value</code>不约束字符集。</li>
<li><code>HTTP Headers</code>: 适合作为<code>HTTP</code>头信息的，基于字符串：字符串的<code>map</code>。（<code>RFC 7230.</code>在工程实践中，如何处理<code>HTTP</code>头具有多样性，强烈建议<code>tracer</code>的使用者谨慎使用<code>HTTP</code>头的键值空间和转义符）</li>
<li><code>Binary</code>: 一个简单的二进制大对象，记录<code>SpanContext</code>的信息。</li>
</ul>
<p>在上面的注入和提取代码中，有如下代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注入</span></span><br><span class="line">RegistryExtractorInjector&lt;C&gt; registryInjector  = </span><br><span class="line">    TracerFormatRegistry.getRegistry(format);</span><br><span class="line"><span class="comment">//提取</span></span><br><span class="line">RegistryExtractorInjector&lt;C&gt; registryExtractor = </span><br><span class="line">    TracerFormatRegistry.getRegistry(format);</span><br></pre></td></tr></table></figure>
<p>来通过<code>TracerFormatRegistry</code>这个类来来看下 <code>SOFATracer</code> 中的 <code>Format</code> 的具体实现。</p>
<h4 id="X-B3"><a href="#X-B3" class="headerlink" title="X-B3"></a>X-B3</h4><p>在看<code>Format</code>之前，先了解下<code>X-B3</code>。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Expose-Headers</span>: </span><br><span class="line"><span class="attribute">X-B3-TraceId,X-B3-ParentSpanId,X-B3-SpanId</span></span><br></pre></td></tr></table></figure>
<p><code>HTTP</code>请求时其<code>span</code>参数通过<code>http headers</code>来传递追踪信息；<code>header</code>中对应的<code>key</code>分别是:</p>
<ul>
<li>X-B3-TraceId: 64 encoded bits（id被encode为hex Strings）</li>
<li>X-B3-SpanId : 64 encoded bits</li>
<li>X-B3-ParentSpanId: 64 encoded bits</li>
<li>X-B3-Sampled:(是否采样) Boolean (either “1” or “0”)（下面的调用是否进行采样）</li>
<li>X-B3-Flags:a Long</li>
</ul>
<h4 id="SOFATracer-中的-Format"><a href="#SOFATracer-中的-Format" class="headerlink" title="SOFATracer 中的 Format"></a>SOFATracer 中的 Format</h4><p>具体代码在 <code>tracer-core -&gt; com.alipay.common.tracer.core.registy</code> 包下:</p>
<ul>
<li>TextMapFormatter</li>
<li>TextMapB3Formatter</li>
<li>HttpHeadersFormatter</li>
<li>HttpHeadersB3Formatter</li>
<li>BinaryFormater</li>
</ul>
<p><strong>BinaryFormater</strong>：这个的注入和提取实现没有编解码一说；本身就是基于二进制流的操作。</p>
<p><strong>TextMapB3Formatter/TextMapFormatter</strong> 和 <strong>HttpHeadersB3Formatter/HttpHeadersFormatter</strong> 区别就在于编解码不同。<code>HttpHeadersB3Formatter</code>使用的是 <code>URLDecoder.decode</code> &amp;&amp; <code>URLDecoder.encode</code> ; <code>TextMapB3Formatter</code> 返回的是值本身（如果为空或者<code>null</code>则返回空字符串）。</p>
<p><strong>TextMapFormatter</strong>和<strong>TextMapB3Formatter</strong>区别在于注入或者提取是使用的<code>key</code>不用。<code>TextMapB3Formatter</code>中使用的是 <code>x-b3-{}</code> 的字符串作为<code>key</code>。</p>
<h3 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h3><p>一个<code>span</code>代表系统中具有开始时间和执行时长的逻辑运行单元。<code>span</code>之间通过嵌套或者顺序排列建立逻辑因果关系。当<code>Span</code>结束后(<code>span.finish()</code>)，除了通过<code>Span</code>获取<code>SpanContext</code>外，下列其他所有方法都不允许被调用。</p>
<p>同样先来看下<code>opentracing</code>规范<code>api</code> 定义的 <code>span</code> 的定义及方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Span</span> <span class="keyword">extends</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="function">SpanContext <span class="title">context</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(<span class="keyword">long</span> finishMicros)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">setTag</span><span class="params">(String key, String value)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">setTag</span><span class="params">(String key, <span class="keyword">boolean</span> value)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">setTag</span><span class="params">(String key, Number value)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">log</span><span class="params">(Map&lt;String, ?&gt; fields)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">log</span><span class="params">(<span class="keyword">long</span> timestampMicroseconds, Map&lt;String, ?&gt; fields)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">log</span><span class="params">(String event)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">log</span><span class="params">(<span class="keyword">long</span> timestampMicroseconds, String event)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">setBaggageItem</span><span class="params">(String key, String value)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getBaggageItem</span><span class="params">(String key)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">setOperationName</span><span class="params">(String operationName)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">log</span><span class="params">(String eventName, <span class="comment">/* @Nullable */</span> Object payload)</span></span>;</span><br><span class="line">    <span class="function">Span <span class="title">log</span><span class="params">(<span class="keyword">long</span> timestampMicroseconds, String eventName, <span class="comment">/* @Nullable */</span> Object payload)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过Span获取SpanContext"><a href="#通过Span获取SpanContext" class="headerlink" title="通过Span获取SpanContext"></a>通过Span获取SpanContext</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SOFATracerSpan</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpanContext <span class="title">context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sofaTracerSpanContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回值，<code>Span</code>构建时传入的<code>SpanContext</code>。这个返回值在<code>Span</code>结束后(<code>span.finish()</code>)，依然可以使用。</p>
<h4 id="复写操作名"><a href="#复写操作名" class="headerlink" title="复写操作名"></a>复写操作名</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Span <span class="title">setOperationName</span><span class="params">(String operationName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.operationName = operationName;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>operationName</strong>:新的操作名，覆盖构建<code>Span</code>时，传入的操作名。</p>
<h4 id="结束Span"><a href="#结束Span" class="headerlink" title="结束Span"></a>结束Span</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.finish(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(<span class="keyword">long</span> endTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setEndTime(endTime);</span><br><span class="line">    <span class="comment">//关键记录:report span</span></span><br><span class="line">    <span class="keyword">this</span>.sofaTracer.reportSpan(<span class="keyword">this</span>);</span><br><span class="line">    SpanExtensionFactory.logStoppedSpan(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个可选参数，如果指定完成时间则使用当前指定的时间；如果省略此参数，使用当前时间作为完成时间。<code>finish</code>方法中会将当前<code>span</code>进行<code>report</code>操作。</p>
<h4 id="为Span设置tag"><a href="#为Span设置tag" class="headerlink" title="为Span设置tag"></a>为Span设置tag</h4><p><code>Tag</code>是一个<code>key:value</code>格式的数据。<code>key</code>必须是<code>String</code>类型，<code>value</code>可以是<strong>字符串、布尔或者数字</strong>。</p>
<ul>
<li>字符串类型的value 设置tag</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Span <span class="title">setTag</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(key) || StringUtils.isBlank(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.tagsWithStr.put(key, value);</span><br><span class="line">    <span class="comment">//注意:server 还是 client 在 OpenTracing 标准中是用 tags 标识的,所以在这里进行判断</span></span><br><span class="line">    <span class="keyword">if</span> (isServer()) &#123;</span><br><span class="line">        Reporter serverReporter = <span class="keyword">this</span>.sofaTracer.getServerReporter();</span><br><span class="line">        <span class="keyword">if</span> (serverReporter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.setLogType(serverReporter.getReporterType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isClient()) &#123;</span><br><span class="line">        Reporter clientReporter = <span class="keyword">this</span>.sofaTracer.getClientReporter();</span><br><span class="line">        <span class="keyword">if</span> (clientReporter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.setLogType(clientReporter.getReporterType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>布尔类型的value 设置tag</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Span <span class="title">setTag</span><span class="params">(String key, <span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.tagsWithBool.put(key, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>数字类型的value 设置tag</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Span <span class="title">setTag</span><span class="params">(String key, Number number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.tagsWithNumber.put(key, number);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Log结构化数据"><a href="#Log结构化数据" class="headerlink" title="Log结构化数据"></a>Log结构化数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Span <span class="title">log</span><span class="params">(<span class="keyword">long</span> currentTime, Map&lt;String, ?&gt; map)</span> </span>&#123;</span><br><span class="line">    AssertUtils.isTrue(currentTime &gt;= startTime, <span class="string">"current time must greater than start time"</span>);</span><br><span class="line">    <span class="keyword">this</span>.logs.add(<span class="keyword">new</span> LogData(currentTime, map));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Span <span class="title">log</span><span class="params">(Map&lt;String, ?&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.log(System.currentTimeMillis(), map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Map&lt;String, ?&gt; map</strong> : 键必须是字符串类型，值可以是任意类型</li>
<li><strong>currentTime</strong> : 时间戳。如果指定时间戳，那么它必须在<code>span</code>的开始和结束时间之内。</li>
</ul>
<h4 id="设置一个baggage（随行数据）元素"><a href="#设置一个baggage（随行数据）元素" class="headerlink" title="设置一个baggage（随行数据）元素"></a>设置一个baggage（随行数据）元素</h4><p><code>Baggage</code>元素是一个键值对集合，将这些值设置给给定的<code>Span</code>，<code>Span</code>的<code>SpanContext</code>，以及所有和此<code>Span</code>有直接或者间接关系的本地<code>Span</code>。 也就是说，<code>baggage</code>元素随<code>trace</code>一起保持在带内传递。（译者注：带内传递，在这里指，随应用程序调用过程一起传递）</p>
<p><code>Baggage</code>元素为<code>OpenTracing</code>的实现全栈集成，提供了强大的功能 （例如：任意的应用程序数据，可以在移动端创建它，显然的，它会一直传递了系统最底层的存储系统。由于它如此强大的功能，他也会产生巨大的开销，请小心使用此特性。</p>
<p>再次强调，请谨慎使用此特性。每一个键值都会被拷贝到每一个本地和远程的下级相关的<code>span</code>中，因此，总体上，他会有明显的网络和<code>CPU</code>开销。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Span <span class="title">setBaggageItem</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sofaTracerSpanContext.setBizBaggageItem(key, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SofaTracerSpan-中的属性"><a href="#SofaTracerSpan-中的属性" class="headerlink" title="SofaTracerSpan 中的属性"></a>SofaTracerSpan 中的属性</h4><ul>
<li>sofaTracer  : 当前 tracer</li>
<li>spanReferences : 当前span的关系，ChildOf(引用) or FollowsFrom（跟随）</li>
<li>tagsWithStr : String 类型的tag 集合</li>
<li>tagsWithBool : 布尔类型的tag集合</li>
<li>tagsWithNumber : 数值类型的tag集合</li>
<li>logs : log结构化数据列表，通过span.log（map）操作的map,均存储在logs中。</li>
<li>operationName：当前span的操作名</li>
<li>sofaTracerSpanContext：当前 spanContext</li>
<li>startTime : 当前span 开始时间</li>
<li>endTime  : 当前span 结束时间，在finish方法中传入。</li>
<li>logType : report时才有意义:摘要日志类型,日志能够正确打印的关键信息；当前 span 的日志类型,如:客户端为 rpc-client-digest.log,服务端为 rpc-server-digest.log</li>
<li>parentSofaTracerSpan：父亲 span,当作为客户端结束并弹出线程上下文时,需要将父亲 span 再放入</li>
</ul>
<h4 id="SpanContext"><a href="#SpanContext" class="headerlink" title="SpanContext"></a>SpanContext</h4><p><code>opentracing</code> 中 <code>SpanContext</code> 接口中只有一个<code>baggageItems</code>方法，通过这个方法来遍历所有的<code>baggage</code>元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpanContext</span> </span>&#123;</span><br><span class="line">    Iterable&lt;Map.Entry&lt;String, String&gt;&gt; baggageItems();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相对于<code>OpenTracing</code>中其他的功能，<code>SpanContext</code>更多的是一个“概念”。也就是说，<code>OpenTracing</code>实现中，需要重点考虑，并提供一套自己的<code>API</code>。</p>
<p><code>OpenTracing</code>的使用者仅仅需要，在创建<code>span</code>、向传输协议<code>Inject</code>（注入）和从传输协议中<code>Extract</code>（提取）时，使用<code>SpanContext</code>和<code>references</code>，</p>
<p><code>OpenTracing</code>要求，<code>SpanContext</code>是不可变的，目的是防止由于<code>Span</code>的结束和相互关系，造成的复杂生命周期问题。</p>
<h2 id="Disruptor-简介"><a href="#Disruptor-简介" class="headerlink" title="Disruptor 简介"></a>Disruptor 简介</h2><blockquote>
<p>A High Performance Inter-Thread Messaging Library 高性能的线程间消息传递库</p>
</blockquote>
<p>关于 Disruptor 的 一些原理分析可以参考：<a href="https://ifeve.com/disruptor/" target="_blank" rel="noopener">disruptor</a></p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>先通过 <code>Disruptor</code> 的一个小例子来有个直观的认识；先看下它的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Disruptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> EventFactory&lt;T&gt; eventFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">int</span> ringBufferSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ProducerType producerType,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> WaitStrategy waitStrategy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(</span><br><span class="line">        RingBuffer.create(producerType, eventFactory, ringBufferSize, waitStrategy),</span><br><span class="line">        <span class="keyword">new</span> BasicExecutor(threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>eventFactory : 在环形缓冲区中创建事件的 <code>factory</code></li>
<li>ringBufferSize:环形缓冲区的大小，必须是2的幂。</li>
<li>threadFactory：用于为处理器创建线程。</li>
<li>producerType：生成器类型以支持使用正确的<code>sequencer</code>和<code>publisher</code>创建<code>RingBuffer</code>；枚举类型，<code>SINGLE</code>、<code>MULTI</code>两个项。对应于 <code>SingleProducerSequencer</code>和<code>MultiProducerSequencer</code>两种<code>Sequencer</code>。</li>
<li>waitStrategy : 等待策略；</li>
</ul>
<p>如果我们想构造一个<code>disruptor</code>,那么我们就需要上面的这些组件。从<code>eventFactory</code>来看，还需要一个具体的<code>Event</code>来作为消息事件的载体。【下面按照官方给的案例进行简单的修改作为示例】</p>
<h3 id="消息事件-LongEvent-，能够被消费的数据载体"><a href="#消息事件-LongEvent-，能够被消费的数据载体" class="headerlink" title="消息事件 LongEvent ，能够被消费的数据载体"></a>消息事件 LongEvent ，能够被消费的数据载体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建消息事件的factory"><a href="#创建消息事件的factory" class="headerlink" title="创建消息事件的factory"></a>创建消息事件的factory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventFactory</span> <span class="keyword">implements</span> <span class="title">EventFactory</span>&lt;<span class="title">LongEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LongEvent <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LongEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ConsumerThreadFactory"><a href="#ConsumerThreadFactory" class="headerlink" title="ConsumerThreadFactory"></a>ConsumerThreadFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger index = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"disruptor-thread-"</span> + index.getAndIncrement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK ，上面的这些可以满足创建一个<code>disruptor</code>了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ringBufferCapacity = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//消息事件生产Factory</span></span><br><span class="line">LongEventFactory longEventFactory = <span class="keyword">new</span> LongEventFactory();</span><br><span class="line"><span class="comment">//执行事件处理器线程Factory</span></span><br><span class="line">ConsumerThreadFactory consumerThreadFactory = <span class="keyword">new</span> ConsumerThreadFactory();</span><br><span class="line"><span class="comment">//用于环形缓冲区的等待策略。</span></span><br><span class="line">WaitStrategy waitStrategy = <span class="keyword">new</span> BlockingWaitStrategy();</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建disruptor</span></span><br><span class="line">Disruptor&lt;LongEvent&gt; disruptor = <span class="keyword">new</span> Disruptor&lt;&gt;(</span><br><span class="line">    longEventFactory,</span><br><span class="line">    ringBufferCapacity,</span><br><span class="line">    longEventThreadFactory,</span><br><span class="line">    ProducerType.SINGLE,</span><br><span class="line">    waitStrategy);</span><br></pre></td></tr></table></figure>
<p>现在是已经有了 <code>disruptor</code> 了，然后通过：<code>start</code> 来启动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动 disruptor</span></span><br><span class="line"> disruptor.start();</span><br></pre></td></tr></table></figure>
<p>到这里，已经构建了一个<code>disruptor</code>；但是目前怎么使用它来发布消息和消费消息呢？</p>
<h3 id="发布消息"><a href="#发布消息" class="headerlink" title="发布消息"></a>发布消息</h3><p>下面在 <code>for</code> 循环中 发布 5 条数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> l = <span class="number">0</span>; l &lt; <span class="number">5</span>; l++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> sequence = ringBuffer.next();</span><br><span class="line">    LongEvent event = ringBuffer.get(sequence);</span><br><span class="line">    event.set(<span class="number">100</span>+l);</span><br><span class="line">    System.out.println(<span class="string">"publish event :"</span> + l);</span><br><span class="line">    ringBuffer.publish(sequence);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息已经发布，下面需要设定当前<code>disruptor</code>的消费处理器。前面已经有个<code>LongEvent</code> 和 <code>EventFactory</code> ; 在<code>disruptor</code>中是通过 <code>EventHandler</code> 来进行消息消费的。</p>
<h3 id="编写消费者代码"><a href="#编写消费者代码" class="headerlink" title="编写消费者代码"></a>编写消费者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventHandler</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">LongEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(LongEvent event, <span class="keyword">long</span> sequence, <span class="keyword">boolean</span> endOfBatch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Event: "</span> + event.getValue()+<span class="string">" -&gt; "</span> + Thread.currentThread().getName());</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 <code>eventHandler</code> 设置到 <code>disruptor</code> 的处理链上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将处理事件的事件处理程序 -&gt; 消费事件的处理程序</span></span><br><span class="line">LongEventHandler longEventHandler = <span class="keyword">new</span> LongEventHandler();</span><br><span class="line">disruptor.handleEventsWith(longEventHandler);</span><br></pre></td></tr></table></figure>
<h3 id="运行结果（这里）："><a href="#运行结果（这里）：" class="headerlink" title="运行结果（这里）："></a>运行结果（这里）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">publish event :0</span><br><span class="line">Event: 0 -&gt; disruptor-thread-1</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :1</span><br><span class="line">Event: 1 -&gt; disruptor-thread-1</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :2</span><br><span class="line">Event: 2 -&gt; disruptor-thread-1</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :3</span><br><span class="line">Event: 3 -&gt; disruptor-thread-1</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :4</span><br><span class="line">Event: 4 -&gt; disruptor-thread-1</span><br><span class="line">--------------------------------&gt;</span><br></pre></td></tr></table></figure>
<h2 id="基本概念和原理"><a href="#基本概念和原理" class="headerlink" title="基本概念和原理"></a>基本概念和原理</h2><h3 id="Disruptor"><a href="#Disruptor" class="headerlink" title="Disruptor"></a>Disruptor</h3><p>整个基于<code>ringBuffer</code>实现的生产者消费者模式的容器。主要属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RingBuffer&lt;T&gt; ringBuffer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConsumerRepository&lt;T&gt; consumerRepository = <span class="keyword">new</span> ConsumerRepository&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean started = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">private</span> ExceptionHandler&lt;? <span class="keyword">super</span> T&gt; exceptionHandler = <span class="keyword">new</span> ExceptionHandlerWrapper&lt;&gt;();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ringBuffer</code>：内部持有一个 <code>RingBuffer</code> 对象，<code>Disruptor</code> 内部的事件发布都是依赖这个<code>RingBuffer</code>对象完成的。</li>
<li><code>executor</code>：消费事件的线程池</li>
<li><code>consumerRepository</code>：提供存储库机制，用于将<code>EventHandler</code>与<code>EventProcessor</code>关联起来</li>
<li><code>started</code> : 用于标志当前<code>Disruptor</code>是否已经启动</li>
<li><code>exceptionHandler</code> : 异常处理器，用于处理<code>BatchEventProcessor</code>事件周期中 <code>uncaught exceptions</code> 。</li>
</ul>
<h3 id="RingBuffer"><a href="#RingBuffer" class="headerlink" title="RingBuffer"></a>RingBuffer</h3><p>环形队列[实现上是一个数组]，可以类比为<code>BlockingQueue</code>之类的队列，<code>ringBuffer</code>的使用，使得内存被循环使用，减少了某些场景的内存分配回收扩容等耗时操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RingBuffer</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">RingBufferFields</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Cursored</span>, <span class="title">EventSequencer</span>&lt;<span class="title">E</span>&gt;, <span class="title">EventSink</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>E：在事件的交换或并行协调期间存储用于共享的数据的实现 -&gt; 消息事件</li>
</ul>
<h3 id="Sequencer"><a href="#Sequencer" class="headerlink" title="Sequencer"></a>Sequencer</h3><p> <code>RingBuffer</code> 中 生产者的顶级父接口，其直接实现有<code>SingleProducerSequencer</code>和<code>MultiProducerSequencer</code>；对应 <code>SINGLE</code>、<code>MULTI</code> 两个枚举值。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16504080427c32c5?w=1046&amp;h=768&amp;f=png&amp;s=52527" alt=""></p>
<h3 id="EventHandler"><a href="#EventHandler" class="headerlink" title="EventHandler"></a>EventHandler</h3><p>事件处置器，改接口用于对外扩展来实现具体的消费逻辑。如上面 <code>demo</code> 中的 <code>LongEventHandler</code> ;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回调接口，用于处理&#123;@link RingBuffer&#125;中可用的事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(T event, <span class="keyword">long</span> sequence, <span class="keyword">boolean</span> endOfBatch)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>event</code> : <code>RingBuffer</code> 已经发布的事件</li>
<li><code>sequence</code> : 正在处理的事件 的序列号</li>
<li><code>endOfBatch</code> : 用来标识否是来自 <code>RingBuffer</code> 的批次中的最后一个事件</li>
</ul>
<h3 id="SequenceBarrier"><a href="#SequenceBarrier" class="headerlink" title="SequenceBarrier"></a>SequenceBarrier</h3><p>消费者路障。规定了消费者如何向下走。事实上，该路障算是变向的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessingSequenceBarrier</span> <span class="keyword">implements</span> <span class="title">SequenceBarrier</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当等待（探测）的需要不可用时，等待的策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WaitStrategy waitStrategy;</span><br><span class="line">    <span class="comment">//依赖的其它Consumer的序号，这个用于依赖的消费的情况，</span></span><br><span class="line">    <span class="comment">//比如A、B两个消费者，只有A消费完，B才能消费。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sequence     dependentSequence;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span>   alerted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//Ringbuffer的写入指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sequence     cursorSequence;</span><br><span class="line">    <span class="comment">//RingBuffer对应的Sequencer</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sequencer    sequencer;</span><br><span class="line">    <span class="comment">//exclude method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>waitStrategy</code> 决定了消费者采用何种等待策略。</p>
<h3 id="WaitStrategy"><a href="#WaitStrategy" class="headerlink" title="WaitStrategy"></a>WaitStrategy</h3><blockquote>
<p>Strategy employed for making {@link EventProcessor}s wait on a cursor {@link Sequence}.</p>
</blockquote>
<p><code>EventProcessor</code> 的等待策略；具体实现在 <code>disruptor</code> 中有8种，</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/4/165040897c8cd0fd?w=429&amp;h=184&amp;f=png&amp;s=70264" alt=""></p>
<p>这些等待策略不同的核心体现是在如何实现 <code>waitFor</code> 这个方法上。</p>
<h3 id="EventProcessor"><a href="#EventProcessor" class="headerlink" title="EventProcessor"></a>EventProcessor</h3><p>事件处理器，实际上可以理解为消费者模型的框架，实现了线程<code>Runnable</code>的<code>run</code>方法，将循环判断等操作封在了里面。该接口有三个实现类:</p>
<p><strong>1、BatchEventProcessor</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchEventProcessor</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">EventProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean           running          = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">private</span> ExceptionHandler&lt;? <span class="keyword">super</span> T&gt;   exceptionHandler = <span class="keyword">new</span> FatalExceptionHandler();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataProvider&lt;T&gt;         dataProvider;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SequenceBarrier         sequenceBarrier;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventHandler&lt;? <span class="keyword">super</span> T&gt; eventHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sequence                sequence         = <span class="keyword">new</span> Sequence(                                      Sequencer.INITIAL_CURSOR_VALUE);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimeoutHandler          timeoutHandler;</span><br><span class="line">    <span class="comment">//exclude method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ExceptionHandler：异常处理器</li>
<li>DataProvider：数据来源，对应 <code>RingBuffer</code></li>
<li>EventHandler：处理 <code>Event</code> 的回调对象</li>
<li>SequenceBarrier：对应的序号屏障</li>
<li>TimeoutHandler：超时处理器，默认情况为空，如果要设置，只需要要将关联的<code>EventHandler</code>实现<code>TimeOutHandler</code>即可。</li>
</ul>
<p>如果我们选择使用 <code>EventHandler</code> 的时候，默认使用的就是 <code>BatchEventProcessor</code>，它与<code>EventHandler</code>是一一对应，并且是单线程执行。</p>
<p>如果某个<code>RingBuffer</code>有多个<code>BatchEventProcessor</code>，那么就会每个<code>BatchEventProcessor</code>对应一个线程。</p>
<p><strong>2、WorkProcessor</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkProcessor</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">EventProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean running = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sequence sequence = <span class="keyword">new</span> Sequence(Sequencer.INITIAL_CURSOR_VALUE);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RingBuffer&lt;T&gt; ringBuffer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SequenceBarrier  sequenceBarrier;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WorkHandler&lt;? <span class="keyword">super</span> T&gt; workHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExceptionHandler&lt;? <span class="keyword">super</span> T&gt; exceptionHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sequence workSequence;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventReleaser eventReleaser = <span class="keyword">new</span> EventReleaser() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                sequence.set(Long.MAX_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimeoutHandler timeoutHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本和 <code>BatchEventProcessor</code> 类似，不同在于，用于处理<code>Event</code>的回调对象是<code>WorkHandler</code>。</p>
<h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/165040ee8a2eae73?w=1240&amp;h=750&amp;f=png&amp;s=312558" alt=""></p>
<h2 id="无消费者情况下，生产者保持生产，但是-remainingCapacity-保持不变"><a href="#无消费者情况下，生产者保持生产，但是-remainingCapacity-保持不变" class="headerlink" title="无消费者情况下，生产者保持生产，但是 remainingCapacity 保持不变"></a>无消费者情况下，生产者保持生产，但是 <code>remainingCapacity</code> 保持不变</h2><p>在写<code>demo</code>的过程中，本来想通过不设定 消费者 来观察 <code>RingBuffer</code> 可用容量变化的。但是验证过程中，一直得不到预期的结果，(注：没有设置消费者，只有生产者)，先看结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">publish event :0</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:0</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :1</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:1</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :2</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:2</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :3</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:3</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :4</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:4</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :5</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:5</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :6</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:6</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :7</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:7</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :8</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:8</span><br><span class="line">--------------------------------&gt;</span><br><span class="line">publish event :9</span><br><span class="line">bufferSie:8</span><br><span class="line">remainingCapacity:8</span><br><span class="line">cursor:9</span><br><span class="line">--------------------------------&gt;</span><br></pre></td></tr></table></figure>
<p>从结果来看，<code>remainingCapacity</code> 的值应该随着 发布的数量 递减的；但是实际上它并没有发生任何变化。</p>
<p>来看下<code>ringBuffer.remainingCapacity()</code> 这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the remaining capacity for this ringBuffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The number of slots remaining.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">remainingCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sequencer.remainingCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面又使用 <code>sequencer.remainingCapacity()</code>这个方法来计算的。上面的例子中使用的是<code>ProducerType.SINGLE</code>，那来看<code>SingleProducerSequencer</code> 这个里面<code>remainingCapacity</code>的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">remainingCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//上次申请完毕的序列值</span></span><br><span class="line">    <span class="keyword">long</span> nextValue = <span class="keyword">this</span>.nextValue;</span><br><span class="line">    <span class="comment">//计算当前已经消费到的序列值</span></span><br><span class="line">    <span class="keyword">long</span> consumed = Util.getMinimumSequence(gatingSequences, nextValue);</span><br><span class="line">    <span class="comment">//当前生产到的序列值</span></span><br><span class="line">    <span class="keyword">long</span> produced = nextValue;</span><br><span class="line">    <span class="keyword">return</span> getBufferSize() - (produced - consumed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来解释下这段代码的含义：</p>
<p>假设当前 <code>ringBuffer</code> 的 <code>bufferSize</code> 是 8 ；上次申请到的序列号是 5，其实也就是说已经生产过占用的序列号是5；假设当前已经消费到的序列号是 3，那么剩余的容量为： 8-（5-2） = 5；</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/4/1650414723061ce7?w=992&amp;h=744&amp;f=png&amp;s=310780" alt=""></p>
<p>因为这里我们可以确定 <code>bufferSize</code> 和 <code>produced</code> 的值了，那么 <code>remainingCapacity</code> 的结果就取决于<code>getMinimumSequence</code>的计算结果了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getMinimumSequence</span><span class="params">(<span class="keyword">final</span> Sequence[] sequences, <span class="keyword">long</span> minimum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = sequences.length; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> value = sequences[i].get();</span><br><span class="line">        minimum = Math.min(minimum, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是从 <code>Sequence</code> 数组中获取最小序列 。如果<code>sequences</code> 为空，则返回 <code>minimum</code>。回到上一步，看下<code>sequences</code>这个数组是从哪里过来的，它的值在哪里设置的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> consumed = Util.getMinimumSequence(gatingSequences, nextValue);</span><br></pre></td></tr></table></figure>
<p><code>gatingSequences</code>是 <code>SingleProducerSequencer</code>父类  <code>AbstractSequencer</code> 中的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> Sequence[] gatingSequences = <span class="keyword">new</span> Sequence[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p><code>gatingSequences</code> 是在下面这个方法里面来管理的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Sequencer#addGatingSequences(Sequence...)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addGatingSequences</span><span class="params">(Sequence... gatingSequences)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SequenceGroups.addSequences(<span class="keyword">this</span>, SEQUENCE_UPDATER, <span class="keyword">this</span>, gatingSequences);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的调用栈向前追溯有这几个地方调用了：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/4/1650415d0682db8f?w=1934&amp;h=560&amp;f=png&amp;s=203628" alt=""></p>
<p><code>WorkerPool</code>来管理多个消费者；<code>hangdlerEventsWith</code> 这个方法也是用来设置消费者的。但是在上面的测试案例中我们是想通过不设定消费者 只设定生成者 来观察 环形队列的占用情况，所以<code>gatingSequences</code> 会一直是空的，因此在计算时会把 <code>produced</code> 的值作为 <code>minimum</code> 返回。这样每次计算就相当于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> getBufferSize() - (produced - produced) === getBufferSize();</span><br></pre></td></tr></table></figure>
<p>也就验证了为何在不设定消费者的情况下，<code>remainingCapacity</code> 的值会一直保持不变。</p>
<h2 id="SOFATracer-中-Disruptor-实践"><a href="#SOFATracer-中-Disruptor-实践" class="headerlink" title="SOFATracer 中 Disruptor 实践"></a>SOFATracer 中 Disruptor 实践</h2><p><code>SOFATracer</code>中，<code>AsyncCommonDigestAppenderManager</code> 对 <code>disruptor</code> 进行了封装，用于处理外部组件的<code>Tracer</code>摘要日志。该部分借助 <code>AsyncCommonDigestAppenderManager</code> 的源码来分析下<code>SOFATracer</code>如何使用<code>disruptor</code>的。</p>
<p><code>SOFATracer</code>中使用了两种不同的事件模型，一种是<code>SOFATracer</code>内部使用的 <code>StringEvent</code> , 一种是 外部扩展使用的 <code>SofaTacerSpanEvent</code>。这里以 <code>SofaTacerSpanEvent</code> 这种事件模型来分析。<code>StringEvent</code> 消息事件模型对应的是 <code>AsyncCommonAppenderManager</code> 类封装的<code>disruptor</code>。</p>
<h3 id="SofaTracerSpanEvent-gt-LongEvent"><a href="#SofaTracerSpanEvent-gt-LongEvent" class="headerlink" title="SofaTracerSpanEvent ( -&gt; LongEvent)"></a>SofaTracerSpanEvent ( -&gt; LongEvent)</h3><p>定义消息事件模型，<code>SofaTacerSpanEvent</code> 和 前面 <code>demo</code> 中的 <code>LongEvent</code> 基本结构是一样的，主要是内部持有的消息数据不同，<code>LongEvent</code> 中是一个<code>long</code>类型的数据，<code>SofaTacerSpanEvent</code>中持有的是 <code>SofaTracerSpan</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaTracerSpanEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> SofaTracerSpan sofaTracerSpan;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SofaTracerSpan <span class="title">getSofaTracerSpan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sofaTracerSpan;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSofaTracerSpan</span><span class="params">(SofaTracerSpan sofaTracerSpan)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sofaTracerSpan = sofaTracerSpan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Consumer-gt-LongEventHandler"><a href="#Consumer-gt-LongEventHandler" class="headerlink" title="Consumer ( -&gt; LongEventHandler)"></a>Consumer ( -&gt; LongEventHandler)</h3><p><code>Consumer</code> 是 <code>AsyncCommonDigestAppenderManager</code> 的内部类;实现了 <code>EventHandler</code> 接口，这个<code>consumer</code>就是作为消费者存在的。</p>
<p>在<code>AsyncCommonAppenderManager</code>中也有一个，这个地方个人觉得可以抽出去，这样可以使得<code>AsyncCommonDigestAppenderManager/AsyncCommonAppenderManager</code>的代码看起来更干净；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">SofaTracerSpanEvent</span>&gt; </span>&#123;</span><br><span class="line">       <span class="comment">//日志类型集合，非该集合内的日志类型将不会被处理</span></span><br><span class="line">        <span class="keyword">protected</span> Set&lt;String&gt; logTypes = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;String&gt;());</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(SofaTracerSpanEvent event, <span class="keyword">long</span> sequence, <span class="keyword">boolean</span> endOfBatch)</span></span></span><br><span class="line"><span class="function">                                <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 拿到具体的消息数据 sofaTracerSpan</span></span><br><span class="line">            SofaTracerSpan sofaTracerSpan = event.getSofaTracerSpan();</span><br><span class="line">            <span class="comment">// 如果没有数据，则不做任何处理</span></span><br><span class="line">            <span class="keyword">if</span> (sofaTracerSpan != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String logType = sofaTracerSpan.getLogType();</span><br><span class="line">                    <span class="comment">// 验证当前日志类型是否可以被当前consumer消费</span></span><br><span class="line">                    <span class="keyword">if</span> (logTypes.contains(logType)) &#123;</span><br><span class="line">                        <span class="comment">// 获取编码类型</span></span><br><span class="line">                        SpanEncoder encoder = contextEncoders.get(logType);</span><br><span class="line">                        <span class="comment">//获取 appender</span></span><br><span class="line">                        TraceAppender appender = appenders.get(logType);</span><br><span class="line">                        <span class="comment">// 对数据进行编码处理</span></span><br><span class="line">                        String encodedStr = encoder.encode(sofaTracerSpan);</span><br><span class="line">                        <span class="keyword">if</span> (appender <span class="keyword">instanceof</span> LoadTestAwareAppender) &#123;</span><br><span class="line">                            ((LoadTestAwareAppender) appender).append(encodedStr,</span><br><span class="line">                                TracerUtils.isLoadTest(sofaTracerSpan));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            appender.append(encodedStr);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 刷新缓冲区，日志输出</span></span><br><span class="line">                        appender.flush();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   <span class="comment">// 异常省略</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLogType</span><span class="params">(String logType)</span> </span>&#123;</span><br><span class="line">            logTypes.add(logType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="SofaTracerSpanEventFactory-（-gt-LongEventFactory）"><a href="#SofaTracerSpanEventFactory-（-gt-LongEventFactory）" class="headerlink" title="SofaTracerSpanEventFactory （-&gt; LongEventFactory）"></a>SofaTracerSpanEventFactory （-&gt; LongEventFactory）</h3><p>用于产生消息事件的 <code>Factory</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaTracerSpanEventFactory</span> <span class="keyword">implements</span> <span class="title">EventFactory</span>&lt;<span class="title">SofaTracerSpanEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SofaTracerSpanEvent <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SofaTracerSpanEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ConsumerThreadFactory-gt-LongEventThreadFactory"><a href="#ConsumerThreadFactory-gt-LongEventThreadFactory" class="headerlink" title="ConsumerThreadFactory (-&gt; LongEventThreadFactory )"></a>ConsumerThreadFactory (-&gt; LongEventThreadFactory )</h3><p>用来产生消费线程的 <code>Factory</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String workName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWorkName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> workName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWorkName</span><span class="params">(String workName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workName = workName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        Thread worker = <span class="keyword">new</span> Thread(runnable, <span class="string">"Tracer-AsyncConsumer-Thread-"</span> + workName);</span><br><span class="line">        worker.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> worker;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建disruptor"><a href="#构建disruptor" class="headerlink" title="构建disruptor"></a>构建disruptor</h3><p><code>disruptor</code> 的构建是在 <code>AsyncCommonDigestAppenderManager</code> 的构造函数中完成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncCommonDigestAppenderManager</span><span class="params">(<span class="keyword">int</span> queueSize, <span class="keyword">int</span> consumerNumber)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用这个计算来保证realQueueSize是2的次幂（返回当前 大于等于queueSize的最小的2的次幂数 ）</span></span><br><span class="line">    <span class="keyword">int</span> realQueueSize = <span class="number">1</span> &lt;&lt; (<span class="number">32</span> - Integer.numberOfLeadingZeros(queueSize - <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//构建disruptor，使用的是 ProducerType.MULTI</span></span><br><span class="line">    <span class="comment">//等待策略是 BlockingWaitStrategy</span></span><br><span class="line">    disruptor = <span class="keyword">new</span> Disruptor&lt;SofaTracerSpanEvent&gt;(<span class="keyword">new</span> SofaTracerSpanEventFactory(),</span><br><span class="line">        realQueueSize, threadFactory, ProducerType.MULTI, <span class="keyword">new</span> BlockingWaitStrategy());</span><br><span class="line">    <span class="comment">//消费者列表</span></span><br><span class="line">    <span class="keyword">this</span>.consumers = <span class="keyword">new</span> ArrayList&lt;Consumer&gt;(consumerNumber);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; consumerNumber; i++) &#123;</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer();</span><br><span class="line">        consumers.add(consumer);</span><br><span class="line">        <span class="comment">//设置异常处理程序</span></span><br><span class="line">        disruptor.setDefaultExceptionHandler(<span class="keyword">new</span> ConsumerExceptionHandler());</span><br><span class="line">        <span class="comment">//绑定消费者</span></span><br><span class="line">        disruptor.handleEventsWith(consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否允许丢弃，从配置文件获取</span></span><br><span class="line">    <span class="keyword">this</span>.allowDiscard = Boolean.parseBoolean(SofaTracerConfiguration.getProperty(</span><br><span class="line">        SofaTracerConfiguration.TRACER_ASYNC_APPENDER_ALLOW_DISCARD, DEFAULT_ALLOW_DISCARD));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (allowDiscard) &#123;</span><br><span class="line">        <span class="comment">//是否记录丢失日志的数量</span></span><br><span class="line">        <span class="keyword">this</span>.isOutDiscardNumber = Boolean.parseBoolean(SofaTracerConfiguration.getProperty(</span><br><span class="line">            SofaTracerConfiguration.TRACER_ASYNC_APPENDER_IS_OUT_DISCARD_NUMBER,</span><br><span class="line">            DEFAULT_IS_OUT_DISCARD_NUMBER));</span><br><span class="line">        <span class="comment">//是否记录丢失日志的TraceId和RpcId</span></span><br><span class="line">        <span class="keyword">this</span>.isOutDiscardId = Boolean.parseBoolean(SofaTracerConfiguration.getProperty(</span><br><span class="line">            SofaTracerConfiguration.TRACER_ASYNC_APPENDER_IS_OUT_DISCARD_ID,</span><br><span class="line">            DEFAULT_IS_OUT_DISCARD_ID));</span><br><span class="line">        <span class="comment">//丢失日志的数量达到该阈值进行一次日志输出</span></span><br><span class="line">        <span class="keyword">this</span>.discardOutThreshold = Long.parseLong(SofaTracerConfiguration.getProperty(</span><br><span class="line">            SofaTracerConfiguration.TRACER_ASYNC_APPENDER_DISCARD_OUT_THRESHOLD,</span><br><span class="line">            DEFAULT_DISCARD_OUT_THRESHOLD));</span><br><span class="line">        <span class="keyword">if</span> (isOutDiscardNumber) &#123;</span><br><span class="line">            <span class="keyword">this</span>.discardCount = <span class="keyword">new</span> PaddedAtomicLong(<span class="number">0L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动-disruptor"><a href="#启动-disruptor" class="headerlink" title="启动 disruptor"></a>启动 disruptor</h3><p><code>disruptor</code>的启动委托给了<code>AsyncCommonDigestAppenderManager</code> 的<code>start</code>方法来执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">final</span> String workerName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.threadFactory.setWorkName(workerName);</span><br><span class="line">    <span class="keyword">this</span>.ringBuffer = <span class="keyword">this</span>.disruptor.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看下，<code>SOFATracer</code> 中 具体是在哪里调用这个<code>start</code> 的：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/4/165041aeac0dc066?w=576&amp;h=158&amp;f=png&amp;s=40516" alt=""></p>
<ul>
<li><code>CommonTracerManager</code> : 这个里面持有了<code>AsyncCommonDigestAppenderManager</code> 类的一个单例对象，并且是<code>static</code> 静态代码块中调用了<code>start</code>方法；这个用来输出普通日志。</li>
<li><code>SofaTracerDigestReporterAsyncManager</code>：这里类里面也是持有了<code>AsyncCommonDigestAppenderManager</code> 类的一个单例对像，并且提供了<code>getSofaTracerDigestReporterAsyncManager</code>方法来获取该单例，在这个方法中调用了<code>start</code>方法；该对象用来输出摘要日志。</li>
</ul>
<h3 id="发布事件"><a href="#发布事件" class="headerlink" title="发布事件"></a>发布事件</h3><p>前面的<code>demo</code>中是通过一个<code>for</code>循环来发布事件的，在 <code>SOFATracer</code> 中 的事件发布无非就是当有<code>Tracer</code>日志需要输出时会触发发布，那么对应的就是日志的 <code>append</code> 操作，将日志 <code>append</code> 到环形缓冲区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">append</span><span class="params">(SofaTracerSpan sofaTracerSpan)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">//是否允许丢弃</span></span><br><span class="line">    <span class="keyword">if</span> (allowDiscard) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//允许丢弃就使用tryNext尝试申请序列，申请不到抛出异常</span></span><br><span class="line">            sequence = ringBuffer.tryNext();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InsufficientCapacityException e) &#123;</span><br><span class="line">            <span class="comment">//是否输出丢失日志的TraceId和RpcId</span></span><br><span class="line">            <span class="keyword">if</span> (isOutDiscardId) &#123;</span><br><span class="line">                SofaTracerSpanContext sofaTracerSpanContext = sofaTracerSpan</span><br><span class="line">                    .getSofaTracerSpanContext();</span><br><span class="line">                <span class="keyword">if</span> (sofaTracerSpanContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    SynchronizingSelfLog.warn(<span class="string">"discarded tracer: traceId["</span></span><br><span class="line">                                              + sofaTracerSpanContext.getTraceId()</span><br><span class="line">                                              + <span class="string">"];spanId["</span> + sofaTracerSpanContext.getSpanId()</span><br><span class="line">                                              + <span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">//是否输出丢失日志的数量</span></span><br><span class="line">            <span class="keyword">if</span> ((isOutDiscardNumber) &amp;&amp; discardCount.incrementAndGet() == discardOutThreshold) &#123;</span><br><span class="line">                discardCount.set(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (isOutDiscardNumber) &#123;</span><br><span class="line">                    SynchronizingSelfLog.warn(<span class="string">"discarded "</span> + discardOutThreshold + <span class="string">" logs"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不允许丢弃则使用next方法</span></span><br><span class="line">        sequence = ringBuffer.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SofaTracerSpanEvent event = ringBuffer.get(sequence);</span><br><span class="line">        event.setSofaTracerSpan(sofaTracerSpan);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        SynchronizingSelfLog.error(<span class="string">"fail to add event"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发布</span></span><br><span class="line">    ringBuffer.publish(sequence);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SOFATracer 事件发布的调用逻辑：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/4/165041c4514a3102?w=1060&amp;h=1012&amp;f=png&amp;s=80785" alt=""></p>
<p>追溯调用的流程，可以知道当前 <code>span</code> 调用 <code>finish</code>时或者 <code>SOFATracer</code>中调用<code>reportSpan</code>时 就相当于发布了一个消息事件。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文对 <code>SOFATracer</code> 中使用 <code>Disruptor</code> 来进行日志输出的代码进行了简单的分析，更多内部细节原理可以自行看下<code>SOFATracer</code>的代码。<code>SOFATracer</code> 作为一种比较底层的中间件组件，在实际的业务开发中基本是无法感知的。但是作为技术来学习，还是有很多点可以挖一挖。</p>
<p><a href="https://github.com/alipay/sofa-tracer" target="_blank" rel="noopener">SOFATracer GitHub 传送门</a>。</p>
<blockquote>
<p>如果有小伙伴对中间件感兴趣，欢迎加入我们团队，欢迎来撩；对 SOFA 技术体系有兴趣的可以关注我们 <a href="https://github.com/alipay" target="_blank" rel="noopener">ALIPAY SOFA 社区</a>；附团队镇楼图。</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/4/1650426cfb443c99?w=1088&amp;h=708&amp;f=png&amp;s=1217313" alt=""></p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/sofa-tracer-disruptor/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
    </div>
    
      <div id="page-nav" class="pagination">
	<span class="page-number current">1</span>
      </div>
    
  </section>

</div>

</div>

</section>
</div>


    <!-- BEGIN PRE-FOOTER -->
    <div class="pre-footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN BOTTOM ABOUT BLOCK -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>About Us</h2>
            <p>Computer Lab is a software development and marketing company based in Brooklyn, New York. <br><br> Computer Lab was founded in 2015, and is focused on so on and so forth.</p>
          </div>
          <!-- END BOTTOM ABOUT BLOCK -->

          <!-- BEGIN BOTTOM CONTACTS -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>Contact</h2>
            <address class="margin-bottom-40">
              140 Metropolitan Avenue<br>
              5th Floor<br>
              Brooklyn, NY 11249<br>
              Phone: 716-472-4484<br>
              Email: <a href="mailto:ptsteadman@gmail.com">ptsteadman@gmail.com</a><br>
            </address>
          </div>
          <!-- END BOTTOM CONTACTS -->

	
          <!-- BEGIN TWITTER BLOCK --> 
          <div class="col-md-4 col-sm-6 pre-footer-col">

	  <a data-tweet-limit="1" class="twitter-timeline" href="https://twitter.com/computerlab_" data-widget-id="678830341331820544">Tweets by @computerlab_</a>

	  <script>!function(d,s,id){var
	  js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

          </div>
          <!-- END TWITTER BLOCK -->
	
        </div>
      </div>
    </div>
    <!-- END PRE-FOOTER -->

    <!-- BEGIN FOOTER -->
    <div class="footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN COPYRIGHT -->
          <div class="col-md-6 col-sm-6 padding-top-10">
                  &copy; 2020 glmapper<br>
 <a href="javascript:;">Privacy Policy</a> | <a href="javascript:;">Terms of Service</a>
          </div>
          <!-- END COPYRIGHT -->
	  <!-- BEGIN SOCIAL -->
<div class="col-md-6 col-sm-6">
  <ul class="social-footer list-unstyled list-inline pull-right">
    
      <li><a href="https://github.com/ptsteadman"><i class="fa fa-github"></i></a></li>
    
      <li><a href="https://twitter.com/ptsteadman"><i class="fa fa-twitter"></i></a></li>
    
      <li><a href="https://www.facebook.com/ptsteadman"><i class="fa fa-facebook"></i></a></li>
    
      <li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li>
    
      <li><a href="https://linkedin.com/in/ptsteadman"><i class="fa fa-linkedin"></i></a></li>
    
      <li><a href="http://stackoverflow.com/users/2480493/patrick-steadman"><i class="fa fa-stackoverflow"></i></a></li>
    
  </ul>  
</div>
<!-- END SOCIAL -->

        </div>
      </div>
    </div>
    <!-- END FOOTER -->

  <!-- BEGIN CORE PLUGINS (REQUIRED FOR ALL PAGES) -->
<!--[if lt IE 9]>
<script src="/metronic/assets/plugins/respond.min.js"></script>
<![endif]--> 
<script src="/metronic/assets/plugins/jquery.min.js"></script>
<script src="/metronic/assets/plugins/jquery-migrate.min.js"></script>
<script src="/metronic/assets/plugins/bootstrap/js/bootstrap.min.js"></script>
<script src="/metronic/assets/corporate/scripts/back-to-top.js"></script>
<script src="/metronic/assets/plugins/owl.carousel/owl.carousel.min.js"></script>
<script src="/metronic/assets/corporate/scripts/layout.js"></script>
<script src="/js/wow.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script type="text/javascript">
    jQuery(document).ready(function() {
        Layout.init();    
        Layout.initOWL();
        Layout.initTwitter();
        Layout.initFixHeaderWithPreHeader(); /* Switch On Header Fixing (only if you have pre-header) */
        Layout.initNavScrolling(); 
	new WOW().init();
    });
</script>
<!-- END CORE PLUGINS -->

<!-- BEGIN PAGE-SPECIFIC PLUGINS --> 







<!-- END PAGE-SPECIFIC PLUGINS --> 

<!-- BEGIN INTEGRATIONS -->





<!-- END INTEGRATIONS -->

</body>
</html>
