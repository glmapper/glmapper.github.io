<!DOCTYPE html>
<!--[if IE 8]> <html lang="en" class="ie8 no-js"> <![endif]-->
<!--[if IE 9]> <html lang="en" class="ie9 no-js"> <![endif]-->
<!--[if !IE]><!-->
<html lang="en">
<!--<![endif]-->
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Tag: 聊一聊 | glmapper</title>

  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <meta name="description" content="从平凡的世界中全身而退">
<meta property="og:type" content="website">
<meta property="og:title" content="glmapper">
<meta property="og:url" content="http://www.glmapper.com/tags/聊一聊/index.html">
<meta property="og:site_name" content="glmapper">
<meta property="og:description" content="从平凡的世界中全身而退">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="glmapper">
<meta name="twitter:description" content="从平凡的世界中全身而退">
  
    <link rel="alternative" href="/atom.xml" title="glmapper" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
    
  <meta content="{{ title }}" name="description">
  <meta content="{{ title }}" name="keywords">
  <meta content="{{ title }}" name="author">

  <link href="http://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700|PT+Sans+Narrow|Source+Sans+Pro:200,300,400,600,700,900&amp;subset=all" rel="stylesheet" type="text/css">

  <!-- Global styles START -->   
  <link rel="stylesheet" href="/metronic/assets/plugins/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/bootstrap/css/bootstrap.min.css">
  <!-- Global styles END --> 
   
  <!-- Page level plugin styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/animate.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/owl.carousel/assets/owl.carousel.css">
  <!-- Page level plugin styles END -->

  <!-- Theme styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/components.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/slider.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/portfolio.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style-responsive.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/themes/red.css">
  <link rel="stylesheet" href="/css/theme-styles.css">
  <!-- Theme styles END -->
</head>
</html>
<body class="corporate">
  <!-- BEGIN TOP BAR -->
<div class="pre-header">
  <div class="container">
    <div class="row">
      <!-- BEGIN TOP BAR LEFT PART -->
      <div class="col-md-6 col-sm-6 col-xs-9 additional-shop-info">
	<ul class="list-unstyled list-inline">
	  <li><i class="fa fa-phone"></i><span>716-472-4484</span></li>
	  <li><i class="fa fa-envelope-o"></i><span>ptsteadman@gmail.com</span></li>
	</ul>
      </div>
      <!-- END TOP BAR LEFT PART -->
      <!-- BEGIN TOP BAR MENU -->
      <div class="col-md-6 col-sm-6 col-xs-3 additional-nav">
	<ul class="list-unstyled list-inline pull-right">
	  <li><a href="/login">Log In</a></li>
	</ul>
      </div>
      <!-- END TOP BAR MENU -->
    </div>
  </div>        
</div>
<!-- END TOP BAR -->
<!-- BEGIN HEADER -->
<div class="header">
  <div class="container">
    <!--<a class="site-logo" href="/" id="logo">glmapper</a>-->

    <a class="site-logo" href="/">
      <img src="/metronic/assets/corporate/img/logos/logo-corp-red.png" alt="Metronic FrontEnd">
    </a>

    <a href="javascript:void(0);" class="mobi-toggler"><i class="fa fa-bars"></i></a>

    <!-- BEGIN NAVIGATION -->
    <div class="header-navigation pull-right font-transform-inherit">
      <ul>
	
	<li class="">
	  <a href="/">Home</a>
	</li>
	
	<li class="">
	  <a href="/projects/">Projects</a>
	</li>
	
	<li class="">
	  <a href="/archives/">Blog</a>
	</li>
	
	<li class="">
	  <a href="/contact/">Contact</a>
	</li>
	
	<li class="">
	  <a href="/about/">About</a>
	</li>
	
	<!-- BEGIN TOP SEARCH -->
	<li class="menu-search">
	  <span class="sep"></span>
	  <i class="fa fa-search search-btn"></i>
	  <div class="search-box">
	    <form action="#">
	      <div class="input-group">
		<input type="text" placeholder="Search" class="form-control st-default-search-input">
		<span class="input-group-btn">
		  <button class="btn btn-primary" type="submit">Search</button>
		</span>
	      </div>
	    </form>
	  </div> 
	</li>
	<!-- END TOP SEARCH -->
      </ul>
    </div>
    <!-- END NAVIGATION -->
  </div>
</div>
<!-- Header END -->

  <div class="container">
  <ul class="breadcrumb">
    <li><a href="/">Home</a></li>
    <li><a href="/blog">Blog</a></li>
    <li class="active">Tagged: 聊一聊</li>
  </ul>
<section id="main">
  <h1>Tagged: 聊一聊</h1>
  <div class="row">

<div class="col-xs-12 blog-posts">


  <section class="archives-wrap">
    <div class="archives">
      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/topic-session-cookie/">聊一聊 session和cookie</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T05:23:29.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/topic-session-cookie/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/聊一聊/" title="聊一聊">聊一聊</a>,
  
    <a href="/tags/session/" title="session">session</a>,
  
    <a href="/tags/cookie/" title="cookie">cookie</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<blockquote>
<p>本来是想写aop设计机制的，但是最近被session这个东西搞得有点头大，所以就抽点时间来整理下关于session的一些东西。</p>
</blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="">从http协议的无状态性说起</a><ul>
<li><a href="">无连接和无状态</a></li>
<li><a href="">持久连接</a></li>
<li><a href="">http无状态</a></li>
<li><a href="">如何保持状态信息</a></li>
</ul>
</li>
<li>Cookie<ul>
<li><a href="">Cookie机制原理</a></li>
<li><a href="">Cookie在servlet-api中的定义</a></li>
<li><a href="">Cookie属性</a></li>
<li><a href="">创建Cookie</a></li>
<li><a href="">Cookie更新</a></li>
<li><a href="">Cookie删除</a></li>
<li><a href="">从请求中获取Cookie</a></li>
<li><a href="">Cookie同源与跨域</a></li>
<li><a href="">Cookie数量&amp;大小限制及处理策略</a></li>
</ul>
</li>
<li>Session<ul>
<li><a href="">session机制原理</a></li>
<li><a href="">HttpSession</a></li>
<li><a href="">创建session</a></li>
<li><a href="">生命周期</a></li>
<li><a href="">session的有效期</a></li>
<li><a href="">分布式session</a><h2 id="从http协议的无状态性说起"><a href="#从http协议的无状态性说起" class="headerlink" title="从http协议的无状态性说起"></a>从http协议的无状态性说起</h2></li>
</ul>
</li>
</ul>
<p>HTTP是一种无状态协议。关于这个无状态之前我也不太理解，因为HTTP底层是TCP，既然是TCP，就是长连接，这个过程是保持连接状态的，又为什么说http是无状态的呢？先来搞清楚这两个概念：</p>
<h3 id="无连接和无状态"><a href="#无连接和无状态" class="headerlink" title="无连接和无状态"></a>无连接和无状态</h3><ul>
<li><p>无连接</p>
<p>  每次连接只处理一个请求，服务端处理完客户端一次请求，等到客户端作出回应之后便断开连接；</p>
</li>
<li><p>无状态</p>
<p>  是指服务端对于客户端每次发送的请求都认为它是一个新的请求，上一次会话和下一次会话没有联系；</p>
</li>
</ul>
<p>无连接的维度是连接，无状态的维度是请求；http是基于tcp的，而从http1.1开始默认使用持久连接；在这个连接过程中，客户端可以向服务端发送多次请求，但是各个请求之间的并没有什么联系；这样来考虑，就很好理解无状态这个概念了。</p>
<h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p><code>持久连接，本质上是客户端与服务器通信的时候，建立一个持久化的TCP连接，这个连接不会随着请求结束而关闭，通常会保持连接一段时间。</code></p>
<p>现有的持久连接类型有两种：HTTP/1.0+的keep-alive和HTTP/1.1的persistent。</p>
<ul>
<li>HTTP/1.0+的keep-alive</li>
</ul>
<p>先来开一张图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/13/163551ad5795255d?w=1444&amp;h=170&amp;f=png&amp;s=58043" alt=""><br>这张图是请求<a href="http://www.baidu.com时的请求头信息。这里面我们需要注意的是：" target="_blank" rel="noopener">www.baidu.com时的请求头信息。这里面我们需要注意的是：</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection: keep-alive</span><br></pre></td></tr></table></figure>
<p>我们每次发送一个HTTP请求，会附带一个connection:keep-alive，这个参数就是声明一个持久连接。</p>
<ul>
<li>HTTP/1.1的persistent</li>
</ul>
<p>HTTP/1.1的持久连接默认是开启的，只有首部中包含connection：close，才会事务结束之后关闭连接。当然服务器和客户端仍可以随时关闭持久连接。</p>
<p>当发送了connection：close首部之后客户端就没有办法在那条连接上发送更多的请求了。当然根据持久连接的特性，一定要传输正确的content-length。</p>
<p>还有根据HTTP/1.1的特性，是不应该和HTTP/1.0客户端建立持久连接的。最后，一定要做好重发的准备。</p>
<h3 id="http无状态"><a href="#http无状态" class="headerlink" title="http无状态"></a>http无状态</h3><p>OK，首先来明确下，这个状态的主体指的是什么？应该是信息，这些信息是由服务端所维护的与客户端交互的信息（也称为状态信息）；<br>因为HTTP本身是不保存任何用户的状态信息的，所以HTTP是无状态的协议。</p>
<h3 id="如何保持状态信息"><a href="#如何保持状态信息" class="headerlink" title="如何保持状态信息"></a>如何保持状态信息</h3><p>在聊这个这个问题之前，我们来考虑下为什么http自己不来做这个事情：也就是让http变成有状态的。</p>
<ul>
<li><p>http本身来实现状态维护</p>
<p>  从上面关于无状态的理解，如果现在需要让http自己变成有状态的，就意味着http协议需要保存交互的状态信息；暂且不说这种方式是否合适，但从维护状态信息这一点来说，代价就很高，因为既然保存了状态信息，那后续的一些行为必定也会受到状态信息的影响。</p>
<p>  从历史角度来说，最初的http协议只是用来浏览静态文件的，无状态协议已经足够，这样实现的负担也很轻。但是随着web技术的不断发展，越来越多的场景需要状态信息能够得以保存；一方面是http本身不会去改变它的这种无状态的特性（至少目前是这样的），另一方面业务场景又迫切的需要保持状态；那么这个时候就需要来“装饰”一下http，引入一些其他机制来实现有状态。</p>
</li>
<li><p>cookie和session体系</p>
<p>  通过引入cookie和session体系机制来维护状态信息。即用户第一次访问服务器的时候，服务器响应报头通常会出现一个Set-Cookie响应头，这里其实就是在本地设置一个cookie，当用户再次访问服务器的时候，http会附带这个cookie过去，cookie中存有sessionId这样的信息来到服务器这边确认是否属于同一次会话。</p>
</li>
</ul>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p> cookie是由服务器发送给客户端（浏览器）的小量信息，以{key：value}的形式存在。</p>
<h3 id="Cookie机制原理"><a href="#Cookie机制原理" class="headerlink" title="Cookie机制原理"></a>Cookie机制原理</h3><p> 客户端请求服务器时，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。而客户端浏览器会把Cookie保存起来。当浏览器再请求 服务器时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器通过检查该Cookie来获取用户状态。</p>
<p> 我们通过看下servlet-api中Cookie类的定义及属性，来更加具体的了解Cookie。</p>
<h3 id="Cookie在servlet-api中的定义"><a href="#Cookie在servlet-api中的定义" class="headerlink" title="Cookie在servlet-api中的定义"></a>Cookie在servlet-api中的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cookie</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6454587001725327448L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TSPECIALS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LSTRING_FILE =</span><br><span class="line">    <span class="string">"javax.servlet.http.LocalStrings"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ResourceBundle lStrings =</span><br><span class="line">    ResourceBundle.getBundle(<span class="string">"javax.servlet.http.LocalStrings"</span>);</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="keyword">private</span> String comment;</span><br><span class="line">    <span class="keyword">private</span> String domain;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxAge = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> secure;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> version = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isHttpOnly = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//....省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Cookie属性"><a href="#Cookie属性" class="headerlink" title="Cookie属性"></a>Cookie属性</h3><ul>
<li><p>name</p>
<p>  cookie的名字，Cookie一旦创建，名称便不可更改</p>
</li>
<li><p>value</p>
<p>  cookie值</p>
</li>
<li><p>comment</p>
<p>  该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明</p>
</li>
<li><p>domain</p>
<p>  可以访问该Cookie的域名。如果设置为“.baidu.com”，则所有以“baidu.com”结尾的域名都可以访问该Cookie；第一个字符必须为“.”</p>
</li>
<li><p>maxAge</p>
<p>  Cookie失效的时间，单位秒。</p>
<ul>
<li>正数，则超过maxAge秒之后失效。</li>
<li>负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。</li>
<li>为0，表示删除该Cookie。</li>
</ul>
</li>
<li><p>path</p>
<p>  该Cookie的使用路径。例如：</p>
<ul>
<li>path=/，说明本域名下contextPath都可以访问该Cookie。</li>
<li><p>path=/app/，则只有contextPath为“/app”的程序可以访问该Cookie</p>
<p>path设置时，其以“/”结尾.</p>
</li>
</ul>
</li>
<li><p>secure</p>
<p>  该Cookie是否仅被使用安全协议传输。这里的安全协议包括HTTPS，SSL等。默认为false。</p>
</li>
<li><p>version</p>
<p>  该Cookie使用的版本号。</p>
<ul>
<li>0 表示遵循Netscape的Cookie规范，目前大多数用的都是这种规范；</li>
<li><p>1 表示遵循W3C的RFC2109规范；规范过于严格，实施起来很难。</p>
<p>在servlet规范中默认是0；</p>
</li>
</ul>
</li>
<li><p>isHttpOnly</p>
<p>  HttpOnly属性是用来限制非HTTP协议程序接口对客户端Cookie进行访问；也就是说如果想要在客户端取到httponly的Cookie的唯一方法就是使用AJAX，将取Cookie的操作放到服务端，接收客户端发送的ajax请求后将取值结果通过HTTP返回客户端。这样能有效的防止XSS攻击。</p>
</li>
</ul>
<p>上述的这些属性，除了name与value属性会被提交外，其他的属性对于客户端来说都是不可读的，也是不可被提交的。</p>
<h3 id="创建Cookie"><a href="#创建Cookie" class="headerlink" title="创建Cookie"></a>创建Cookie</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"cookieSessionId"</span>,<span class="string">"qwertyuiop"</span>);</span><br><span class="line">cookie.setDomain(<span class="string">".baidu.com"</span>);             <span class="comment">// 设置域名</span></span><br><span class="line">cookie.setPath(<span class="string">"/"</span>);                        <span class="comment">// 设置路径</span></span><br><span class="line">cookie.setMaxAge(Integer.MAX_VALUE);        <span class="comment">// 设置有效期为永久</span></span><br><span class="line">response.addCookie(cookie);                 <span class="comment">// 回写到客户端</span></span><br></pre></td></tr></table></figure>
<p>创建Cookie只能通过上述方式来创建，因为在Cookie类中只提供了这样一个构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Cookie的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cookie</span><span class="params">(String name, String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; name.length() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//判断下是不是token</span></span><br><span class="line">        <span class="comment">//判断是不是和Cookie的属性字段重复</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isToken(name) &amp;&amp; !name.equalsIgnoreCase(<span class="string">"Comment"</span>) &amp;&amp;</span><br><span class="line">        !name.equalsIgnoreCase(<span class="string">"Discard"</span>) &amp;&amp;</span><br><span class="line">        !name.equalsIgnoreCase(<span class="string">"Domain"</span>) &amp;&amp;</span><br><span class="line">        !name.equalsIgnoreCase(<span class="string">"Expires"</span>) &amp;&amp;</span><br><span class="line">        !name.equalsIgnoreCase(<span class="string">"Max-Age"</span>) &amp;&amp;</span><br><span class="line">        !name.equalsIgnoreCase(<span class="string">"Path"</span>) &amp;&amp;</span><br><span class="line">        !name.equalsIgnoreCase(<span class="string">"Secure"</span>) &amp;&amp;</span><br><span class="line">        !name.equalsIgnoreCase(<span class="string">"Version"</span>) &amp;&amp; !name.startsWith(<span class="string">"$"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String errMsg =</span><br><span class="line">            lStrings.getString(<span class="string">"err.cookie_name_is_token"</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> Object[]&#123;name&#125;;</span><br><span class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(errMsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(lStrings.getString</span><br><span class="line">        (<span class="string">"err.cookie_name_blank"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Cookie更新"><a href="#Cookie更新" class="headerlink" title="Cookie更新"></a>Cookie更新</h3><p>在源码中可以知道，Cookie本身并没有提供修改的方法；在实际应用中，一般通过使用相同name的Cookie来覆盖原来的Cookie,以达到更新的目的。</p>
<p>但是这个修改的前提是需要具有相同domain，path的 Set-Cookie 消息头</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"cookieSessionId"</span>,<span class="string">"new-qwertyuiop"</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>
<h3 id="Cookie删除"><a href="#Cookie删除" class="headerlink" title="Cookie删除"></a>Cookie删除</h3><p>与Cookie更新一样，Cookie本身也没有提供删除的方法；但是从前面分析Cookie属性时了解到，删除Cookie可以通过将maxAge设置为0即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"cookieSessionId"</span>,<span class="string">"new-qwertyuiop"</span>);</span><br><span class="line">cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>
<p>上面的删除是我们自己可控的；但是也存在一些我们不可控或者说无意识情况下的删除操作：</p>
<ul>
<li>如果maxAge是负值，则cookie在浏览器关闭时被删除</li>
<li>持久化cookie在到达失效日期时会被删除</li>
<li>浏览器中的 cookie 数量达到上限，那么 cookie 会被删除以为新建的 cookie 创建空间。</li>
</ul>
<p>其实很多情况下，我们关注的都是后者。关于数量上限后面会说到。</p>
<h3 id="从请求中获取Cookie"><a href="#从请求中获取Cookie" class="headerlink" title="从请求中获取Cookie"></a>从请求中获取Cookie</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br></pre></td></tr></table></figure>
<h3 id="Cookie同源与跨域"><a href="#Cookie同源与跨域" class="headerlink" title="Cookie同源与跨域"></a>Cookie同源与跨域</h3><p>我们知道浏览器的同源策略：</p>
<blockquote>
<p>URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。浏览器的同源策略，限制了来自不同源的”document”或脚本，对当前”document”读取或设置某些属性。 </p>
</blockquote>
<p>对于Cookie来说，Cookie的同源只关注域名，是忽略协议和端口的。所以一般情况下，<a href="https://localhost:80/和http://localhost:8080/的Cookie是共享的。" target="_blank" rel="noopener">https://localhost:80/和http://localhost:8080/的Cookie是共享的。</a></p>
<p>Cookie是不可跨域的；在没有经过任何处理的情况下，二级域名不同也是不行的。(wenku.baidu.com和baike.baidu.com)。</p>
<h3 id="Cookie数量-amp-大小限制及处理策略"><a href="#Cookie数量-amp-大小限制及处理策略" class="headerlink" title="Cookie数量&amp;大小限制及处理策略"></a>Cookie数量&amp;大小限制及处理策略</h3><table>
<thead>
<tr>
<th></th>
<th>IE6.0</th>
<th>IE7.0/8.0</th>
<th>Opera</th>
<th>FF</th>
<th>Safari</th>
<th>Chrome</th>
</tr>
</thead>
<tbody>
<tr>
<td>个数/个</td>
<td>20/域</td>
<td>50/域</td>
<td>30/域</td>
<td>50/域</td>
<td>无限制</td>
<td>53/域</td>
</tr>
<tr>
<td>大小/Byte</td>
<td>4095</td>
<td>4095</td>
<td>4096</td>
<td>4097</td>
<td>4097</td>
<td>4097</td>
</tr>
</tbody>
</table>
<p><code>注：数据来自网络，仅供参考</code></p>
<p>因为浏览器对于Cookie在数量上是有限制的，如果超过了自然会有一些剔除策略。在这篇文章中<a href="https://www.nczonline.net/blog/2008/05/17/browser-cookie-restrictions/" target="_blank" rel="noopener">Browser cookie restrictions</a>提到的剔除策略如下：</p>
<blockquote>
<p>The least recently used (LRU) approach automatically kicks out the oldest cookie when the cookie limit has been reached in order to allow the newest cookie some space. Internet Explorer and Opera use this approach.</p>
</blockquote>
<p>最近最少使用（LRU）方法：在达到cookie限制时自动地剔除最老的cookie，以便腾出空间给许最新的cookie。Internet Explorer和Opera使用这种方法。</p>
<blockquote>
<p>Firefox does something strange: it seems to randomly decide which cookies to keep although the last cookie set is always kept. There doesn’t seem to be any scheme it’s following at all. The takeaway? Don’t go above the cookie limit in Firefox.</p>
</blockquote>
<p>Firefox决定随机删除Cookie集中的一个Cookie，并没有什么章法。所以最好不要超过Firefox中的Cookie限制。</p>
<p>超过大小长度的话就是直接被截取丢弃；</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Cookie机制弥补了HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。</p>
<p>与Cookie不同的是，session是以服务端保存状态的。</p>
<h3 id="session机制原理"><a href="#session机制原理" class="headerlink" title="session机制原理"></a>session机制原理</h3><p>当客户端请求创建一个session的时候，服务器会先检查这个客户端的请求里是否已包含了一个session标识 - sessionId，</p>
<ul>
<li>如果已包含这个sessionId，则说明以前已经为此客户端创建过session，服务器就按照sessionId把这个session检索出来使用（如果检索不到，可能会新建一个）</li>
<li>如果客户端请求不包含sessionId，则为此客户端创建一个session并且生成一个与此session相关联的sessionId</li>
</ul>
<p>sessionId的值一般是一个既不会重复，又不容易被仿造的字符串，这个sessionId将被在本次响应中返回给客户端保存。保存sessionId的方式大多情况下用的是cookie。</p>
<h3 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h3><p>HttpSession和Cookie一样，都是javax.servlet.http下面的；Cookie是一个类，它描述了Cookie的很多内部细节。而HttpSession是一个接口，它为session的实现提供了一些行为约束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpSession</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回session的创建时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCreationTime</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个sessionId,唯一标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回客户端最后一次发送与该 session 会话相关的请求的时间</span></span><br><span class="line"><span class="comment">     *自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastAccessedTime</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前session所在的ServletContext</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxInactiveInterval</span><span class="params">(<span class="keyword">int</span> interval)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 Servlet 容器在客户端访问时保持 session</span></span><br><span class="line"><span class="comment">     * 会话打开的最大时间间隔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxInactiveInterval</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpSessionContext <span class="title">getSessionContext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回在该 session会话中具有指定名称的对象，</span></span><br><span class="line"><span class="comment">     * 如果没有指定名称的对象，则返回 null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 String 对象的枚举，String 对象包含所有绑定到该 session</span></span><br><span class="line"><span class="comment">     * 会话的对象的名称。</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getAttributeNames</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String[] getValueNames();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putValue</span><span class="params">(String name, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeValue</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指示该 session 会话无效，并解除绑定到它上面的任何对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果客户端不知道该 session 会话，或者如果客户选择不参入该</span></span><br><span class="line"><span class="comment">     * session 会话，则该方法返回 true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNew</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建session"><a href="#创建session" class="headerlink" title="创建session"></a>创建session</h3><p>创建session的方式是通过request来创建；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建Session对象</span></span><br><span class="line">HttpSession session = request.getSession(); </span><br><span class="line"><span class="comment">// 2、创建Session对象</span></span><br><span class="line">HttpSession session = request.getSession(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>这两种是一样的；如果session不存在，就新建一个；如果是false的话，标识如果不存在就返回null；</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>session的生命周期指的是从Servlet容器创建session对象到销毁的过程。Servlet容器会依据session对象设置的存活时间，在达到session时间后将session对象销毁。session生成后，只要用户继续访问，服务器就会更新session的最后访问时间，并维护该session。</p>
<p>之前在单进程应用中，session我一般是存在内存中的，不会做持久化操作或者说使用三方的服务来存session信息，如redis。但是在分布式场景下，这种存在本机内存中的方式显然是不适用的，因为session无法共享。这个后面说。</p>
<h3 id="session的有效期"><a href="#session的有效期" class="headerlink" title="session的有效期"></a>session的有效期</h3><p>session一般在内存中存放，内存空间本身大小就有一定的局限性，因此session需要采用一种过期删除的机制来确保session信息不会一直累积，来防止内存溢出的发生。</p>
<p>session的超时时间可以通过maxInactiveInterval属性来设置。</p>
<p>如果我们想让session失效的话，也可以当通过调用session的invalidate()来完成。</p>
<h3 id="分布式session"><a href="#分布式session" class="headerlink" title="分布式session"></a>分布式session</h3><p>首先是为什么会有这样的概念出现？</p>
<p>先考虑这样一个问题，现在我的应用需要部署在3台机器上。是不是出现这样一种情况，我第一次登陆，请求去了机器1，然后再机器1上创建了一个session；但是我第二次访问时，请求被路由到机器2了，但是机器2上并没有我的session信息，所以得重新登录。当然这种可以通过nginx的IP HASH负载策略来解决。对于同一个IP请求都会去同一个机器。</p>
<p>但是业务发展的越来越大，拆分的越来越多，机器数不断增加；很显然那种方案就不行了。那么这个时候就需要考虑是不是应该将session信息放在一个独立的机器上，所以分布式session要解决的问题其实就是分布式环境下的session共享的问题。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/13/163562469179fe66?w=1160&amp;h=798&amp;f=png&amp;s=44700" alt=""></p>
<p>上图中的关于session独立部署的方式有很多种，可以是一个独立的数据库服务，也可以是一个缓存服务(redis，目前比较常用的一种方式，即使用Redis来作为session缓存服务器)。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/icelin/p/3974935.html" target="_blank" rel="noopener">https://www.cnblogs.com/icelin/p/3974935.html</a></li>
<li><a href="https://www.nczonline.net/blog/2008/05/17/browser-cookie-restrictions/" target="_blank" rel="noopener">https://www.nczonline.net/blog/2008/05/17/browser-cookie-restrictions/</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/topic-session-cookie/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/spring-aop-advice/">聊一聊 AOP：Advice 源码解析</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T05:22:10.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/spring-aop-advice/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/aop/" title="aop">aop</a>,
  
    <a href="/tags/聊一聊/" title="聊一聊">聊一聊</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<blockquote>
<p>在第一篇中的例子和概念介绍中我们对 Advice 有了一个初步的认知。在Spring AOP中，Advice的作用就是用来描述 Spring AOP 围绕方法调用而注入的切面行为。</p>
</blockquote>
<p>本篇文章将从源码的角度来看一看 <code>Advice</code> 到底是什么样的？又是怎么完成通知的？</p>
<h2 id="Advice-接口"><a href="#Advice-接口" class="headerlink" title="Advice 接口"></a>Advice 接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.aopalliance.aop;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tag interface for Advice. Implementations can be any type</span></span><br><span class="line"><span class="comment"> * of advice, such as Interceptors.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> $Id: Advice.java,v 1.1 2004/03/19 17:02:16 johnsonr Exp $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Advice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Advice</code> 接口的定义是在 <code>org.aopalliance.aop</code> 包下面的；从上面的代码中我们可以知道，<code>Advice</code> 接口并没有提供任何的方法；类似的接口定义还有<code>java</code> 中的如<code>Serializable</code>接口，这类接口一般称之为标识接口；标识接口对实现它的类没有任何的语义要求,仅仅是充当一个标示的作用,用来表明实现它的类属于一个特定的类型（从这种标识性角度来说，和注解其实挺像的）；</p>
<p><code>Spring AOP</code>中通过定义和使用这样一个统一的接口，为的就是能够为切面增强的织入功能做更多的细化和扩展。下面就对常见的三个<code>Advice</code>进行分析。</p>
<h2 id="BeforeAdvice"><a href="#BeforeAdvice" class="headerlink" title="BeforeAdvice"></a>BeforeAdvice</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeforeAdvice</span> <span class="keyword">extends</span> <span class="title">Advice</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口也是一个标识接口。看下 <code>BeforeAdvice</code> 的继承关系：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/22/1642834fc63bae1d?w=1644&amp;h=250&amp;f=png&amp;s=77901" alt=""></p>
<p><code>MethodBeforeAdvice</code> 是 <code>BeforeAdvice</code> 为待增强的目标方法设置的前置增强接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodBeforeAdvice</span> <span class="keyword">extends</span> <span class="title">BeforeAdvice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">    Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MethodBeforeAdvice</code> 中提供了一个回调函数 <code>before(…)</code> ；</p>
<p>作为回调函数，<code>before</code> 方法的实现在 <code>Advice</code> 中被配置到目标方法后，会在调用目标方法时被回调。来看下<code>before</code>方法的几个参数：</p>
<ul>
<li>Method method ：（ method being invoked）这个参数是目标方法的反射对象；</li>
<li>Object[] args ：（arguments to the method）目标方法的输入参数；</li>
<li>Object target ：（target of the method invocation）方法调用的目标</li>
</ul>
<h2 id="AspectJMethodBeforeAdvice"><a href="#AspectJMethodBeforeAdvice" class="headerlink" title="AspectJMethodBeforeAdvice"></a>AspectJMethodBeforeAdvice</h2><p><code>AspectJMethodBeforeAdvice</code> 继承了 <code>AbstractAspectJAdvice</code> 抽象类，并实现了 <code>MethodBeforeAdvice</code> 接口。从 <code>AspectJMethodBeforeAdvice</code> 类中代码可以得知，<code>AspectJMethodBeforeAdvice</code> 重写 <code>before</code> 方法的实现是 通过调用父类的 <code>invokeAdviceMethod</code> 方法完成的。也就是说<code>Spring AOP</code> 的<code>Advice</code>包装了<code>AspectJ</code>的<code>before</code>方法。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642a5ea16c25b2d?w=1578&amp;h=618&amp;f=png&amp;s=128780" alt=""></p>
<p>Spring AOP的实现后面再说，我们先自己来实现一个简单的通知。</p>
<h2 id="自定义-Advice实现-MethodBeforeAdvice"><a href="#自定义-Advice实现-MethodBeforeAdvice" class="headerlink" title="自定义 Advice实现 MethodBeforeAdvice"></a>自定义 Advice实现 MethodBeforeAdvice</h2><p>定义我们自己的 <code>GlmapperBeforeMethodAdvice</code> ；这里实现 <code>MethodBeforeAdvice</code> 接口，然后重写 <code>before</code> 这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 自定义的 GlmapperBeforeMethodAdvice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: glmapper@leishu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/6/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperBeforeMethodAdvice</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class"><span class="title">MethodBeforeAdvice</span>,<span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER =</span><br><span class="line">    LoggerFactory.getLogger(GlmapperBeforeMethodAdvice.class.getSimpleName());</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"invoke BeforeAdvice successfully..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result=invocation.proceed();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，有了这个 <code>GlmapperBeforeMethodAdvice</code> ，再来看看怎么用它；同样本篇文章所使用的案例均使用前一篇博客中的那个脚手架来完成。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--我们的目标类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"goodsService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.service.impl.GoodsServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--我们自定义的Advice--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"glmapperBeforeMethodAdvice"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.Advice.GlmapperBeforeMethodAdvice"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 声明切入点adviser --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"adviser"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.RegexpMethodPointcutAdvisor"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里使用我们自定义的advice--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advice"</span> <span class="attr">ref</span>=<span class="string">"glmapperBeforeMethodAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- pattern指定queryAll方法作为切入点； \. 这个是转义使用--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pattern"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">value</span>=<span class="string">"com\.glmapper\.framerwork\.service\.impl\.GoodsServiceImpl\.queryAll"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义代理对象 返回实例是目标对象 target属性指定的goodsService对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"proxyService"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"goodsService"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--源码内固定的属性private String[] interceptorNames;  --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">value</span>&gt;</span>adviser<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>客户端部分，通过SpringContextUtil来拿代理对象；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/initPage"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">initPage</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">		HttpServletResponse response, ModelAndView view)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取代理bean</span></span><br><span class="line">    GoodsService proxyService= (GoodsService) SpringContextUtil.getBean(<span class="string">"proxyService"</span>);</span><br><span class="line">    <span class="comment">//调用</span></span><br><span class="line">    List&lt;Goods&gt; goods = proxyService.queryAll(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    view.addObject(<span class="string">"goodsList"</span>, goods);</span><br><span class="line">    view.setViewName(<span class="string">"goodslist"</span>);</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志输出满足我们的期望（如下）：<br><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642abd5c1097135?w=1516&amp;h=62&amp;f=png&amp;s=26032" alt=""></p>
<p>同样的，在<code>GlmapperBeforeMethodAdvice</code>基础上再实现 <code>AfterReturningAdvice </code>接口，重写<code>afterReturning</code>方法，就能实现后置通知。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[]</span></span></span><br><span class="line"><span class="function"><span class="params">args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"invoke AfterAdvice successfully..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方式在<a href="https://juejin.im/post/5b1ca657f265da6e5a205c45" target="_blank" rel="noopener">聊一聊 AOP ：表现形式与基础概念</a>中有说道。</p>
<h2 id="Advice-在-Aop-中的实现原理"><a href="#Advice-在-Aop-中的实现原理" class="headerlink" title="Advice 在 Aop 中的实现原理"></a>Advice 在 Aop 中的实现原理</h2><p>这里感觉没什么好说的，上面的案例其实就是Spring提供给我们使用的接口。因为MethodBeforeAdvice等都是继承自 AbstractAspectJAdvice 这个抽象类；我们就来看下这个抽象类里面的一些核心逻辑吧。我们按照AspectJMethodBeforeAdvice这里这个类里面before提供的线索来一步步分析。</p>
<p>首先在AspectJMethodBeforeAdvice里before方法中调用的是这个逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoke the advice method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> jpMatch the JoinPointMatch that matched this execution join point</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnValue the return value from the method execution (may be null)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ex the exception thrown by the method execution (may be null)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the invocation result</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable in case of invocation failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeAdviceMethod</span><span class="params">(JoinPointMatch jpMatch, Object</span></span></span><br><span class="line"><span class="function"><span class="params">returnValue, Throwable ex)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> invokeAdviceMethodWithGivenArgs(argBinding(getJoinPoint(),</span><br><span class="line">	jpMatch, returnValue, ex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 argBinding 方法的作用是获取方法执行连接点上的参数，并将一组参数输出给Advice方法。</p>
<p>继续来看invokeAdviceMethodWithGivenArgs这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeAdviceMethodWithGivenArgs</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">Throwable </span>&#123;</span><br><span class="line">    <span class="comment">//保存一份参数副本</span></span><br><span class="line">    Object[] actualArgs = args;</span><br><span class="line">    <span class="comment">//验证下参数是否不存在</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdviceMethod.getParameterTypes().length == <span class="number">0</span>) &#123;</span><br><span class="line">    	actualArgs = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//设置下方法的访问权限</span></span><br><span class="line">    	ReflectionUtils.makeAccessible(<span class="keyword">this</span>.aspectJAdviceMethod);</span><br><span class="line">    	<span class="comment">// invoke执行；这里先通过aspectInstanceFactory对像拿到我们的目标对象实例，然后再进行invoke调用执行</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.aspectJAdviceMethod.invoke(<span class="keyword">this</span>.aspectInstanceFactory.getAspectInstance(), actualArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">"Mismatch on arguments to advice method ["</span> +</span><br><span class="line">    			<span class="keyword">this</span>.aspectJAdviceMethod + <span class="string">"]; pointcut expression ["</span> +</span><br><span class="line">    			<span class="keyword">this</span>.pointcut.getPointcutExpression() + <span class="string">"]"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">    	<span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码其实就是通过反射的方式执行了我们的目标方法。我们再回过头来看下我们的目标方法到底在哪里去进行增强的；这里我们通过配置文件来看：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 代理对象 返回实例是目标对象 target属性指定的AOPservice对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"proxyService"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"goodsService"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--源码内固定的属性private String[] interceptorNames;  --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>adviser<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>代理对象proxyService实现上是ProxyFactoryBean产生的；这里就不在阐述BeanFactory和FactoryBean的区别了。</p>
<p>从上面的配置文件我们可以简单的了解到，代理对象实际上是我们目标对象+adviser共同组成；而在adviser里面又包括了我们的通知。</p>
<p>ProxyFactoryBean继承了FactoryBean，我们知道FactoryBean也是用来生成bean的，但是它生成的bean是通过其getObject方法来获取的。OK，那我们来看下ProxyFactoryBean的getObject方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a proxy. Invoked when clients obtain beans from this factory bean.</span></span><br><span class="line"><span class="comment"> * Create an instance of the AOP proxy to be returned by this factory.</span></span><br><span class="line"><span class="comment"> * The instance will be cached for a singleton, and create on each call to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> getObject()&#125; for a proxy.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a fresh AOP proxy reflecting the current state of this factory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">//初始化Advisor链</span></span><br><span class="line">    initializeAdvisorChain();</span><br><span class="line">    <span class="comment">//如果是单例，则获取单例对象</span></span><br><span class="line">    <span class="keyword">if</span> (isSingleton()) &#123;</span><br><span class="line">    	<span class="keyword">return</span> getSingletonInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span> (<span class="keyword">this</span>.targetName == <span class="keyword">null</span>) &#123;</span><br><span class="line">    		logger.warn(<span class="string">"Using non-singleton proxies with singleton targets is often undesirable. "</span> +</span><br><span class="line">    				<span class="string">"Enable prototype proxies by setting the 'targetName' property."</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> newPrototypeInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>返回一个代理。当客户端从这个工厂bean获取bean时调用。创建该工厂返回的AOP代理的一个实例。该实例将被缓存为一个单例，并在每次调用时创建。</p>
</blockquote>
<p>initializeAdvisorChain：创建 advisor（拦截器）链。每次添加新的 prototype 实例时，源自 BeanFactory 的 Advisor 都将被刷新。通过工厂 API 以编程方式添加的拦截器不受此类更改的影响。（译注）；其实就是根据我们配置的interceptorNames来初始化我们的advisor（拦截器）链，用来增强我们的目标调用方法。</p>
<p>下面是getSingletonInstance这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the singleton instance of this class's proxy object,</span></span><br><span class="line"><span class="comment"> * lazily creating it if it hasn't been created already.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the shared singleton proxy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Object <span class="title">getSingletonInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.singletonInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//创建目标对象的代理</span></span><br><span class="line">    	<span class="keyword">this</span>.targetSource = freshTargetSource();</span><br><span class="line">    	<span class="keyword">if</span> (<span class="keyword">this</span>.autodetectInterfaces &amp;&amp; getProxiedInterfaces().length == <span class="number">0</span> &amp;&amp; !isProxyTargetClass()) &#123;</span><br><span class="line">        	<span class="comment">// Rely on AOP infrastructure to tell us what interfaces to proxy.</span></span><br><span class="line">        	<span class="comment">//获取目标类</span></span><br><span class="line">        	Class&lt;?&gt; targetClass = getTargetClass();</span><br><span class="line">        	<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">        		<span class="keyword">throw</span> <span class="keyword">new</span> FactoryBeanNotInitializedException(<span class="string">"Cannot determine target class for proxy"</span>);</span><br><span class="line">        	&#125;</span><br><span class="line">        	setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, <span class="keyword">this</span>.proxyClassLoader));</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// Initialize the shared singleton instance.</span></span><br><span class="line">    	<span class="keyword">super</span>.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">    	<span class="keyword">this</span>.singletonInstance = getProxy(createAopProxy());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.singletonInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码最核心的是getProxy这个方法，这里方式有两个方式，一个是cglib，另外一种是jdk动态代理：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642c20eec4d6c09?w=1536&amp;h=506&amp;f=png&amp;s=201462" alt=""></p>
<p>这里我们以默认的动态代理的方式来说：(<code>org.springframework.aop.framework.JdkDynamicAopProxy类中</code>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    	logger.debug(<span class="string">"Creating JDK dynamic proxy: target source is "</span> +</span><br><span class="line">    	<span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt;[] proxiedInterfaces =</span><br><span class="line">    AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised);</span><br><span class="line">    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法返回的就是指定接口的代理类实例，该接口将方法调用分派给指定的调用处理程序。</p>
<p>到此整个AOP代理生成逻辑就完了。</p>
<p>总结一下就是我们的代理类中其实包括了我们AOP增强的那部分逻辑的，这个其实从上面的配置文件中就很清楚的可以看出来；所以从Adivce介个角度来说，它其实会被抱在advisor中，然后在被传递到代理对象中，代理对象除了拥有我们目标对象的能力之外，还包括了Adivce的能力；通过这种方式就实现了增强。</p>
<p>关于Advice就到这里了，下一章会来单独说一下 PointCut 。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/spring-aop-advice/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/spring-aop-base/">聊一聊 AOP ：表现形式与基础概念</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T05:20:06.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/spring-aop-base/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/aop/" title="aop">aop</a>,
  
    <a href="/tags/聊一聊/" title="聊一聊">聊一聊</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<blockquote>
<p>aop 终于提上日程来写一写了。</p>
</blockquote>
<h2 id="系列目录"><a href="#系列目录" class="headerlink" title="系列目录"></a>系列目录</h2><p>本系列分为 上、中、下三篇。上篇主要是介绍如果使用 AOP ，提供了demo和配置方式说明；中篇来对实现 AOP 的技术原理进行分析；下篇主要针对Spring中对于AOP的实现进行源码分析。</p>
<ul>
<li><a href="">从一个例子说起</a><ul>
<li><a href="">基于代理的方式</a> </li>
<li><a href="">纯POJO切面 配置方式</a></li>
<li><a href="">AspectJ 注解方式</a></li>
<li><a href="">AspectJ XML 配置方式</a></li>
<li><a href="">表达式说明</a>  </li>
</ul>
</li>
<li><a href="">基础概念</a><ul>
<li><a href="">AOP概念</a></li>
<li><a href="">Target Object</a></li>
<li><a href="">织入（Weave</a></li>
<li><a href="">Proxy</a></li>
<li><a href="">Introduction</a></li>
<li><a href="">Aspect</a></li>
<li><a href="">Joinpoint</a></li>
<li><a href="">Pointcut</a></li>
<li><a href="">Advice</a><ul>
<li><a href="">概念</a></li>
<li><a href="">分类</a></li>
</ul>
</li>
<li><a href="">关系</a></li>
</ul>
</li>
<li><a href="">一些坑</a></li>
</ul>
<h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p>项目地址：<a href="https://github.com/glmapper/glmapper-ssm-parent" target="_blank" rel="noopener">glmapper-ssm-parent</a></p>
<p>这个项目里面包含了下面几种 AOP 实现方式的所有代码，有兴趣的同学可以fork跑一下。这个demo中列举了4中方式的实现：</p>
<ul>
<li>基于代码的方式</li>
<li>基于纯POJO类的方式</li>
<li>基于Aspect注解的方式</li>
<li>基于注入式Aspect的方式</li>
</ul>
<p>目前我们经常用到的是<strong>基于Aspect注解的方式</strong>的方式。下面来一个个了解下不同方式的表现形式。</p>
<h2 id="基于代理的方式"><a href="#基于代理的方式" class="headerlink" title="基于代理的方式"></a>基于代理的方式</h2><p>这种方式看起来很好理解，但是配置起来相当麻烦；小伙伴们可以参考项目来看，这里只贴出比较关键的流程代码。</p>
<h3 id="1、首先定义一个接口：GoodsService"><a href="#1、首先定义一个接口：GoodsService" class="headerlink" title="1、首先定义一个接口：GoodsService"></a>1、首先定义一个接口：GoodsService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GoodsService</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询所有商品信息</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> offset 查询起始位置</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> limit 查询条数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">List&lt;Goods&gt; <span class="title">queryAll</span><span class="params">(<span class="keyword">int</span> offset,<span class="keyword">int</span> limit)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、GoodsService-实现类"><a href="#2、GoodsService-实现类" class="headerlink" title="2、GoodsService 实现类"></a>2、GoodsService 实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"goodsService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsServiceImpl</span> <span class="keyword">implements</span> <span class="title">GoodsService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span> </span><br><span class="line">	<span class="keyword">private</span> GoodsDao goodsDao;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Goods&gt; <span class="title">queryAll</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"执行了queryAll方法"</span>);</span><br><span class="line">		List&lt;Goods&gt; list = <span class="keyword">new</span> ArrayList&lt;Goods&gt;();</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、定义一个通知类-LoggerHelper，该类继承-MethodBeforeAdvice和-AfterReturningAdvice。"><a href="#3、定义一个通知类-LoggerHelper，该类继承-MethodBeforeAdvice和-AfterReturningAdvice。" class="headerlink" title="3、定义一个通知类 LoggerHelper，该类继承 MethodBeforeAdvice和 AfterReturningAdvice。"></a>3、定义一个通知类 LoggerHelper，该类继承 MethodBeforeAdvice和 AfterReturningAdvice。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通知类 LoggerHelper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerHelper</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span>,</span></span><br><span class="line"><span class="class"><span class="title">AfterReturningAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(LoggerHelper.class);</span><br><span class="line">    <span class="comment">//MethodBeforeAdvice的before方法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"before current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//AfterReturningAdvice的afterReturning方法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object o, Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">    Object[] objects, Object o1)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"afterReturning current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、重点，这个配置需要关注下。这个项目里面我是配置在applicationContext-xml文件中的。"><a href="#4、重点，这个配置需要关注下。这个项目里面我是配置在applicationContext-xml文件中的。" class="headerlink" title="4、重点，这个配置需要关注下。这个项目里面我是配置在applicationContext.xml文件中的。"></a>4、重点，这个配置需要关注下。这个项目里面我是配置在applicationContext.xml文件中的。</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义被代理者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"goodsServiceImpl"</span> <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.service.impl.GoodsServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义通知内容，也就是切入点执行前后需要做的事情 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loggerHelper"</span> <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.aspect.LoggerHelper"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义切入点位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loggerPointcut"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.JdkRegexpMethodPointcut"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">".*query.*"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使切入点与通知相关联，完成切面配置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 从这里可以帮助我们理解Advisor，advice和pointcut之间的关系--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--adivce和pointcut是Advisor的两个属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loggerHelperAdvisor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.DefaultPointcutAdvisor"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advice"</span> <span class="attr">ref</span>=<span class="string">"loggerHelper"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pointcut"</span> <span class="attr">ref</span>=<span class="string">"loggerPointcut"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 设置代理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"proxy"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 代理的对象 ，也就是目标类--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span> <span class="attr">ref</span>=<span class="string">"goodsServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 使用切面 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span> <span class="attr">value</span>=<span class="string">"loggerHelperAdvisor"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 代理接口，商品接口 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span> <span class="attr">value</span>=<span class="string">"com.glmapper.framerwork.service.GoodsService"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="5、使用：注解注入方式"><a href="#5、使用：注解注入方式" class="headerlink" title="5、使用：注解注入方式"></a>5、使用：注解注入方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/buy"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line">    <span class="comment">//因为我们已经在配置文件中配置了proxy，</span></span><br><span class="line">    <span class="comment">//所以这里可以直接注入拿到我们的代理类</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GoodsService proxy;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/initPage"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">initPage</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">    	HttpServletResponse response, ModelAndView view)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里使用proxy执行了*query*,</span></span><br><span class="line">    List&lt;Goods&gt; goods = proxy.queryAll(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    view.addObject(<span class="string">"goodsList"</span>, goods);</span><br><span class="line">    view.setViewName(<span class="string">"goodslist"</span>);</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6、使用：工具类方式手动获取bean"><a href="#6、使用：工具类方式手动获取bean" class="headerlink" title="6、使用：工具类方式手动获取bean"></a>6、使用：工具类方式手动获取bean</h3><p>这个方式是通过一个SpringContextUtil工具类来获取代理对象的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/initPage&quot;)</span><br><span class="line">public ModelAndView initPage(HttpServletRequest request,</span><br><span class="line">	HttpServletResponse response, ModelAndView view) &#123;</span><br><span class="line">    //这里通过工具类来拿，效果一样的。</span><br><span class="line">    GoodsService proxy= (GoodsService) SpringContextUtil.getBean(&quot;proxy&quot;);</span><br><span class="line">    List&lt;Goods&gt; goods = proxy.queryAll(10,10);</span><br><span class="line">    view.addObject(&quot;goodsList&quot;, goods);</span><br><span class="line">    view.setViewName(&quot;goodslist&quot;);</span><br><span class="line">    return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="7、SpringContextUtil-类的定义"><a href="#7、SpringContextUtil-类的定义" class="headerlink" title="7、SpringContextUtil 类的定义"></a>7、SpringContextUtil 类的定义</h3><p>这个还是有点坑的，首先SpringContextUtil是继承ApplicationContextAware这个接口，我们希望能够SpringContextUtil可以被Spring容器直接管理，所以，需要使用 @Component 标注。标注了之后最关键的是它得能够被我们配置的注入扫描扫到（亲自踩的坑，我把它放在一个扫不到的包下面，一直debug都是null；差点砸电脑…）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringContextUtil</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring应用上下文环境</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现ApplicationContextAware接口的回调方法，设置上下文环境</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationContext</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        SpringContextUtil.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ApplicationContext</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取对象</span></span><br><span class="line"><span class="comment">     * 这里重写了bean方法，起主要作用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Object 一个以所给名字注册的bean的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8、运行结果"><a href="#8、运行结果" class="headerlink" title="8、运行结果"></a>8、运行结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">21:04:47.940 [http-nio-8080-exec-7] INFO </span><br><span class="line">c.g.framerwork.aspect.LoggerHelper - before current</span><br><span class="line">time:1529413487940</span><br><span class="line"></span><br><span class="line">执行了queryAll方法</span><br><span class="line"></span><br><span class="line">21:04:47.940 [http-nio-8080-exec-7] INFO </span><br><span class="line">c.g.framerwork.aspect.LoggerHelper - afterReturning current</span><br><span class="line">time:1529413487940</span><br></pre></td></tr></table></figure>
<p>上面就是最最经典的方式，就是通过代理的方式来实现AOP的过程。</p>
<h2 id="纯POJO切面-aop-config"><a href="#纯POJO切面-aop-config" class="headerlink" title="纯POJO切面 aop:config"></a>纯POJO切面 <a href="aop:config" target="_blank" rel="noopener">aop:config</a></h2><p>注意这里和LoggerHelper的区别，这里的LoggerAspect并没有继承任何接口或者抽象类。</p>
<h3 id="1、POJO-类定义"><a href="#1、POJO-类定义" class="headerlink" title="1、POJO 类定义"></a>1、POJO 类定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: [描述文本]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="guolei.sgl@antfin.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/6/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER =</span><br><span class="line">    LoggerFactory.getLogger(LoggerHelper.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"before current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"afterReturning current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义通知内容，也就是切入点执行前后需要做的事情 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loggerAspect"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.aspect.LoggerAspect"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"loggerAspect"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"loggerPointCut"</span>  <span class="attr">expression</span>=</span></span><br><span class="line"><span class="tag">    	"<span class="attr">execution</span>(* <span class="attr">com.glmapper.framerwork.service.impl.</span>*<span class="attr">.</span>*(<span class="attr">..</span>)) " /&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!-- 定义 Advice --&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!-- 前置通知 --&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"loggerPointCut"</span> <span class="attr">method</span>=<span class="string">"before"</span> /&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!-- 后置通知 --&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut-ref</span>=<span class="string">"loggerPointCut"</span></span></span><br><span class="line"><span class="tag">    	<span class="attr">method</span>=<span class="string">"afterReturning"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意这里LoggerAspect中的before和afterReturning如果有参数，这里需要处理下，否则会报 <strong>0 formal unbound in pointcut</strong> 异常。</p>
<h2 id="AspectJ-注解驱动方式"><a href="#AspectJ-注解驱动方式" class="headerlink" title="@AspectJ 注解驱动方式"></a>@AspectJ 注解驱动方式</h2><p>这种方式是最简单的一种实现，直接使用 @Aspect 注解标注我们的切面类即可。</p>
<h3 id="1、定义切面类，并使用-Aspect-进行标注"><a href="#1、定义切面类，并使用-Aspect-进行标注" class="headerlink" title="1、定义切面类，并使用 @Aspect 进行标注"></a>1、定义切面类，并使用 @Aspect 进行标注</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 使用Aspect注解驱动的方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="guolei.sgl@antfin.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/6/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerAspectInject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(LoggerAspectInject.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.glmapper.framerwork.service.impl.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"before current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AfterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"afterReturning current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、使用方式1：配置文件方式声明-bean"><a href="#2、使用方式1：配置文件方式声明-bean" class="headerlink" title="2、使用方式1：配置文件方式声明 bean"></a>2、使用方式1：配置文件方式声明 bean</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义通知内容，也就是切入点执行前后需要做的事情 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loggerAspectInject"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.aspect.LoggerAspectInject"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义被代理者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"goodsServiceImpl"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.service.impl.GoodsServiceImpl"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3、客户端使用："><a href="#3、客户端使用：" class="headerlink" title="3、客户端使用："></a>3、客户端使用：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/buy"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/initPage"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">initPage</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">    		HttpServletResponse response, ModelAndView view)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过SpringContextUtil手动获取 代理bean</span></span><br><span class="line">    	GoodsService goodsService=(GoodsService)</span><br><span class="line">    	SpringContextUtil.getBean(<span class="string">"goodsServiceImpl"</span>);</span><br><span class="line">    </span><br><span class="line">    	List&lt;Goods&gt; goods = goodsService.queryAll(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    	view.addObject(<span class="string">"goodsList"</span>, goods);</span><br><span class="line">    	view.setViewName(<span class="string">"goodslist"</span>);</span><br><span class="line">    	<span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、使用方式2：使用-component注解托管给IOC"><a href="#4、使用方式2：使用-component注解托管给IOC" class="headerlink" title="4、使用方式2：使用@component注解托管给IOC"></a>4、使用方式2：使用@component注解托管给IOC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">//这里加上了Component注解，就不需要在xml中配置了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerAspectInject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER =</span><br><span class="line">    LoggerFactory.getLogger(LoggerAspectInject.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.glmapper.framerwork.service.impl.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"before current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AfterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"afterReturning current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5、客户端代码："><a href="#5、客户端代码：" class="headerlink" title="5、客户端代码："></a>5、客户端代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/buy"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line">    <span class="comment">//直接注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GoodsService goodsService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/initPage"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">initPage</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">    		HttpServletResponse response, ModelAndView view)</span> </span>&#123;</span><br><span class="line">    	</span><br><span class="line">    	List&lt;Goods&gt; goods = goodsService.queryAll(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    	view.addObject(<span class="string">"goodsList"</span>, goods);</span><br><span class="line">    	view.setViewName(<span class="string">"goodslist"</span>);</span><br><span class="line">    	<span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6、比较完整的一个LoggerAspectInject，在实际工程中可以直接参考"><a href="#6、比较完整的一个LoggerAspectInject，在实际工程中可以直接参考" class="headerlink" title="6、比较完整的一个LoggerAspectInject，在实际工程中可以直接参考"></a>6、比较完整的一个LoggerAspectInject，在实际工程中可以直接参考</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: aop</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="henugl@1992.163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: glmapper@磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/6/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerAspectInject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER= LoggerFactory.getLogger(LoggerAspectInject.class);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.glmapper.book.web.controller.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"cutIn()"</span>)   <span class="comment">// 定义Pointcut，名称即下面的标识"aroundAdvice</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint poin)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"环绕通知"</span>);</span><br><span class="line">        Object object = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            object = poin.proceed();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 advise</span></span><br><span class="line">    <span class="comment">//这个方法只是一个标识，相当于在配置文件中定义了pointcut的id,此方法没有返回值和参数</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterAdvice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置返回 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关于命名切入点</strong>：上面的例子中cutIn方法可以被称之为命名切入点，命名切入点可以被其他切入点引用，而匿名切入点是不可以的。只有@AspectJ支持命名切入点，而Schema风格不支持命名切入点。<br>如下所示，@AspectJ使用如下方式引用命名切入点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.glmapper.book.web.controller.*.*(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//引入命名切入点</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"前置通知"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注入式-AspectJ-切面"><a href="#注入式-AspectJ-切面" class="headerlink" title="注入式 AspectJ 切面"></a>注入式 AspectJ 切面</h2><p>这种方式我感觉是第二种和第三种的结合的一种方式。</p>
<h3 id="1、定义切面类"><a href="#1、定义切面类" class="headerlink" title="1、定义切面类"></a>1、定义切面类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@description</span>: 注入式 也是一种通过XML方式配置的方式</span></span><br><span class="line"><span class="comment">* <span class="doctag">@email</span>: &lt;a href="guolei.sgl@antfin.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span>: 18/6/20</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerAspectHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(LoggerAspectHelper.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调动方法前执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> point</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"before current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在调用方法前后执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> point</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"around current time:"</span>+System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">if</span>(point.getArgs().length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> point.proceed(point.getArgs());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> point.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在调用方法之后执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> point</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint point)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"after current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> point</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doThrowing</span><span class="params">(JoinPoint point, Throwable ex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"throwing current time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、XML-配置"><a href="#2、XML-配置" class="headerlink" title="2、XML 配置"></a>2、XML 配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loggerAspectHelper"</span>    </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.glmapper.framerwork.aspect.LoggerAspectHelper"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"configAspect"</span> <span class="attr">ref</span>=<span class="string">"loggerAspectHelper"</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--配置com.glmapper.framerwork.service.imp</span></span><br><span class="line"><span class="comment">    	包下所有类或接口的所有方法 --&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"cutIn"</span> <span class="attr">expression</span>=</span></span><br><span class="line"><span class="tag">    	"<span class="attr">execution</span>(* <span class="attr">com.glmapper.framerwork.service.impl.</span>*<span class="attr">.</span>*(<span class="attr">..</span>))" /&gt;</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="tag">&lt;<span class="name">aop:before</span>   <span class="attr">pointcut-ref</span>=<span class="string">"cutIn"</span> <span class="attr">method</span>=<span class="string">"doBefore"</span> /&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">aop:after</span>    <span class="attr">pointcut-ref</span>=<span class="string">"cutIn"</span> <span class="attr">method</span>=<span class="string">"doAfter"</span> /&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">aop:around</span>   <span class="attr">pointcut-ref</span>=<span class="string">"cutIn"</span> <span class="attr">method</span>=<span class="string">"doAround"</span> /&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut-ref</span>=<span class="string">"cutIn"</span> </span></span><br><span class="line"><span class="tag">    	    <span class="attr">method</span>=<span class="string">"doThrowing"</span> <span class="attr">throwing</span>=<span class="string">"ex"</span> /&gt;</span></span><br><span class="line">    	</span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3、结果"><a href="#3、结果" class="headerlink" title="3、结果"></a>3、结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">23:39:48.756 [http-nio-8080-exec-4] INFO  c.g.f.aspect.LoggerAspectHelper</span><br><span class="line">- before current time:1529509188756</span><br><span class="line">23:39:48.757 [http-nio-8080-exec-4] INFO  c.g.f.aspect.LoggerAspectHelper</span><br><span class="line">- around current time:1529509188757</span><br><span class="line">excute queryAll method...</span><br><span class="line">23:39:48.757 [http-nio-8080-exec-4] INFO  c.g.f.aspect.LoggerAspectHelper</span><br><span class="line">- after current time:1529509188757</span><br></pre></td></tr></table></figure>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><hr>
<p>从上面的例子中我们都是使用一些正则表达式来指定我们的切入点的。在实际的使用中，不仅仅是execution，还有其他很多种类型的表达式。下面就列举一些：</p>
<h3 id="1、execution"><a href="#1、execution" class="headerlink" title="1、execution"></a>1、execution</h3><p>用于匹配方法执行的连接点;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.glmapper.book.web.controller.*.*(..))</span><br></pre></td></tr></table></figure>
<ul>
<li>execution（）表达式的主体；</li>
<li>第一个 “*” 符号表示返回值的类型任意；</li>
<li>com.glmapper.book.web.controller       AOP所切的服务的包名，即，我们的业务部分</li>
<li>包名后面的”.”    表示当前包及子包</li>
<li>第二个”*”    表示类名，即所有类</li>
<li>.*(..) 表示任何方法名，括号表示参数，两个点表示任何参数类型</li>
</ul>
<h2 id="2、within"><a href="#2、within" class="headerlink" title="2、within"></a>2、within</h2><p>用于匹配指定类型内的方法执行;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果在com.glmapper.book.web.controller包或其下的任何子包中</span></span><br><span class="line"><span class="comment">//定义了该类型，则在Web层中有一个连接点。</span></span><br><span class="line">within(com.glmapper.book.web.controller..*)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.glmapper.book.web.controller..*)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>@within：用于匹配所以持有指定注解类型内的方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 注解定义</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="henugl@1992.163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: glmapper@磊叔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/6/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD,ElementType.FIELD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AuthAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何目标对象对应的类型持有AuthAnnotation注解的类方法；必须是在目标对象上声明这个注解，在接口上声明的对它不起作用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@within</span>(com.glmapper.book.common.annotaion.AuthAnnotation)</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有被@AdviceAnnotation标注的类都将匹配</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@within(com.glmapper.book.common.annotaion.AuthAnnotation)"</span>) </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3、this"><a href="#3、this" class="headerlink" title="3、this"></a>3、this</h3><p>用于匹配当前AOP代理对象类型的执行方法；注意是AOP代理对象的类型匹配，这样就可能包括引入接口也类型匹配；this中使用的表达式必须是类型全限定名，不支持通配符；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前目标对象（非AOP对象）实现了 UserService 接口的任何方法</span></span><br><span class="line"><span class="keyword">this</span>(com.glmapper.book.web.service.UserService)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于向通知方法中传入代理对象的引用。</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"cutIn() &amp;&amp; this(proxy)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">(ProceedingJoinPoint poin,Object proxy)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"前置通知"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、target"><a href="#4、target" class="headerlink" title="4、target"></a>4、target</h3><p>用于匹配当前目标对象类型的执行方法；注意是目标对象的类型匹配，这样就不包括引入接口也类型匹配；target中使用的表达式必须是类型全限定名，不支持通配符；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前目标对象（非AOP对象）实现了 UserService 接口的任何方法</span></span><br><span class="line">target(com.glmapper.book.web.service.UserService)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于向通知方法中传入代理对象的引用。</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"cutIn() &amp;&amp; target(proxy)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">(ProceedingJoinPoint poin,Object proxy)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"前置通知"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>@target：用于匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解；任何目标对象持有Secure注解的类方法；这个和@within一样必须是在目标对象上声明这个注解，在接口上声明的对它同样不起作用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@target</span>(com.glmapper.book.common.annotaion.AuthAnnotation)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@target(com.glmapper.book.common.annotaion.AuthAnnotation)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="5、args"><a href="#5、args" class="headerlink" title="5、args"></a>5、args</h3><p>用于匹配当前执行的方法传入的参数为指定类型的执行方法；参数类型列表中的参数必须是类型全限定名，通配符不支持；args属于动态切入点，这种切入点开销非常大，非特殊情况最好不要使用；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任何一个以接受“传入参数类型为java.io.Serializable”开头，</span></span><br><span class="line"><span class="comment">//且其后可跟任意个任意类型的参数的方法执行，</span></span><br><span class="line"><span class="comment">//args指定的参数类型是在运行时动态匹配的</span></span><br><span class="line">args (java.io.Serializable,..)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于将参数传入到通知方法中。</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"cutIn() &amp;&amp; args(age,username)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvide</span><span class="params">(JoinPoint point, <span class="keyword">int</span> age, String username)</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@args：用于匹配当前执行的方法传入的参数持有指定注解的执行；任何一个只接受一个参数的方法，且方法运行时传入的参数持有注解AuthAnnotation；动态切入点，类似于arg指示符；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@args</span> (com.glmapper.book.common.annotaion.AuthAnnotation)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"@args(com.glmapper.book.common.annotaion.AuthAnnotation)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvide</span><span class="params">(JoinPoint point)</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6、-annotation"><a href="#6、-annotation" class="headerlink" title="6、@annotation"></a>6、@annotation</h3><p>使用“@annotation(注解类型)”匹配当前执行方法持有指定注解的方法；注解类型也必须是全限定类型名；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前执行方法上持有注解 AuthAnnotation将被匹配</span></span><br><span class="line"><span class="meta">@annotation</span>(com.glmapper.book.common.annotaion.AuthAnnotation)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配连接点被它参数指定的AuthAnnotation注解的方法。</span></span><br><span class="line"><span class="comment">//也就是说，所有被指定注解标注的方法都将匹配。</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.glmapper.book.common.annotaion.AuthAnnotation)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>还有一种是bean的方式，没用过。有兴趣可以看看。</p>
</blockquote>
<p>例子在下面说到的基础概念部分对应给出。</p>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>基础概念部分主要将 AOP 中的一些概念点捋一捋，这部分主要参考了官网上的一些解释。</p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p><code>AOP(Aspect-Oriented Programming)</code>， 即 <strong>面向切面编程</strong>, 它与 <code>OOP</code>( <code>Object-Oriented Programming</code>, 面向对象编程) 相辅相成, 提供了与 <code>OOP</code> 不同的抽象软件结构的视角。在 <code>OOP</code> 中,我们以类(class)作为我们的基本单元, 而 <code>AOP</code> 中的基本单元是 <strong>Aspect(切面)</strong>。</p>
<p><strong>横切关注点</strong>(<code>Cross Cutting Concern</code>)：独立服务，如系统日志。如果不是独立服务（就是与业务耦合比较强的服务）就不能横切了。通常这种独立服务需要遍布系统各个角落，遍布在业务流程之中。</p>
<h2 id="Target-Object"><a href="#Target-Object" class="headerlink" title="Target Object"></a>Target Object</h2><p>目标对象。织入 advice 的目标对象。 目标对象也被称为 <code>advised object</code>。<br>因为 Spring AOP 使用运行时代理的方式来实现 aspect, 因此 adviced object 总是一个代理对象(proxied object)；注意， adviced object 指的不是原来的类, 而是织入 advice 后所产生的代理类。</p>
<h2 id="织入（Weave）"><a href="#织入（Weave）" class="headerlink" title="织入（Weave）"></a>织入（Weave）</h2><p>即<code>Advice</code>应用在<code>JoinPoint</code>的过程，这个过程叫织入。从另外一个角度老说就是将 <code>aspect</code> 和其他对象连接起来, 并创建 <code>adviced object</code> 的过程。</p>
<p>根据不同的实现技术， <code>AOP</code>织入有三种方式:</p>
<ul>
<li>编译器织入，这要求有特殊的<code>Java</code>编译器</li>
<li>类装载期织入， 这需要有特殊的类装载器</li>
<li>动态代理织入, 在运行期为目标类添加增强( <code>Advice</code> )生成子类的方式。</li>
</ul>
<p>Spring 采用动态代理织入, 而AspectJ采用编译器织入和类装载期</p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>Spring AOP默认使用代理的是标准的JDK动态代理。这使得任何接口（或一组接口）都可以代理。</p>
<p>Spring AOP也可以使用CGLIB代理。如果业务对象不实现接口，则默认使用CGLIB。对接口编程而不是对类编程是一种很好的做法；业务类通常会实现一个或多个业务接口。在一些特殊的情况下，即需要通知的接口上没有声明的方法，或者需要将代理对象传递给具体类型的方法，有可能强制使用CGLIB。</p>
<h2 id="Introductions"><a href="#Introductions" class="headerlink" title="Introductions"></a>Introductions</h2><p>我们知道Java语言本身并非是动态的，就是我们的类一旦编译完成，就很难再为他添加新的功能。但是在一开始给出的例子中，虽然我们没有向对象中添加新的方法，但是已经向其中添加了新的功能。这种属于向现有的方法添加新的功能，那能不能为一个对象添加新的方法呢？答案肯定是可以的，使用introduction就能够实现。</p>
<p>introduction：动态为某个类增加或减少方法。为一个类型添加额外的方法或字段。Spring AOP 允许我们为 <code>目标对象</code> 引入新的接口(和对应的实现)。</p>
<h2 id="Aspect"><a href="#Aspect" class="headerlink" title="Aspect"></a>Aspect</h2><p>切面：通知和切入点的结合。</p>
<p>切面实现了cross-cutting（横切）功能。最常见的是logging模块、方法执行耗时模块，这样，程序按功能被分为好几层，如果按传统的继承的话，商业模型继承日志模块的话需要插入修改的地方太多，而通过创建一个切面就可以使用AOP来实现相同的功能了，我们可以针对不同的需求做出不同的切面。</p>
<p>而将散落于各个业务对象之中的Cross-cutting concerns 收集起来，设计各个独立可重用的对象，这些对象称之为Aspect；在上面的例子中我们根据不同的配置方式，定义了四种不同形式的切面。</p>
<h2 id="Joinpoint"><a href="#Joinpoint" class="headerlink" title="Joinpoint"></a>Joinpoint</h2><p>Aspect 在应用程序执行时加入业务流程的点或时机称之为 Joinpoint ，具体来说，就是 Advice 在应用程序中被呼叫执行的时机，这个时机可能是某个方法被呼叫之前或之后（或两者都有），或是某个异常发生的时候。</p>
<h3 id="Joinpoint-amp-ProceedingJoinPoint"><a href="#Joinpoint-amp-ProceedingJoinPoint" class="headerlink" title="Joinpoint &amp; ProceedingJoinPoint"></a>Joinpoint &amp; ProceedingJoinPoint</h3><p>环绕通知 = 前置+目标方法执行+后置通知，proceed方法就是用于启动目标方法执行的。</p>
<p>环绕通知 ProceedingJoinPoint 执行 proceed 方法 的作用是让目标方法执行 ，这 也是环绕通知和前置、后置通知方法的一个最大区别。</p>
<p>Proceedingjoinpoint 继承了 JoinPoint 。是在JoinPoint的基础上暴露出 proceed 这个方法。proceed很重要，这个是aop代理链执行的方法；暴露出这个方法，就能支持<a href="aop:around" target="_blank" rel="noopener">aop:around</a> 这种切面（其他的几种切面只需要用到JoinPoint，这跟切面类型有关）， 能决定是否走代理链还是走自己拦截的其他逻辑。</p>
<p>在环绕通知的方法中是需要返回一个Object类型对象的，如果把环绕通知的方法返回类型是void，将会导致一些无法预估的情况，比如：404。</p>
<h2 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h2><p>匹配 <code>join points</code>的谓词。<code>Advice</code>与切入点表达式相关联, 并在切入点匹配的任何连接点上运行。（例如，具有特定名称的方法的执行）。由切入点表达式匹配的连接点的概念是<code>AOP</code>的核心，<code>Spring</code>默认使用<code>AspectJ</code>切入点表达式语言。</p>
<p>在 <code>Spring</code> 中, 所有的方法都可以认为是<code>Joinpoint</code>, 但是我们并不希望在所有的方法上都添加 <code>Advice</code>, 而 <code>Pointcut</code> 的作用就是提供一组规则(使用 <code>AspectJ pointcut expression language</code> 来描述) 来匹配<code>Joinpoint</code>, 给满足规则的<code>Joinpoint</code> 添加 <code>Advice</code>。</p>
<h3 id="Pointcut-和-Joinpoint"><a href="#Pointcut-和-Joinpoint" class="headerlink" title="Pointcut 和 Joinpoint"></a>Pointcut 和 Joinpoint</h3><p>在<code>Spring AOP</code> 中, 所有的方法执行都是 <code>join point</code>。 而 <code>point cut</code> 是一个描述信息，它修饰的是 <code>join point</code>， 通过 <code>point cut</code>，我们就可以确定哪些 <code>join point</code> 可以被织入<code>Advice</code>。 因此<code>join point</code> 和 <code>point cut</code>本质上就是两个不同维度上的东西。</p>
<p><code>advice</code> 是在 <code>join point</code> 上执行的, 而 <code>point cut</code> 规定了哪些 <code>join point</code> 可以执行哪些 <code>advice</code>。</p>
<h2 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Advice 是我们切面功能的实现，它是切点的真正执行的地方。比如像前面例子中打印时间的几个方法（被@Before等注解标注的方法都是一个通知）；Advice 在 Jointpoint 处插入代码到应用程序中。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>BeforeAdvice，AfterAdvice，区别在于Advice在目标方法之前调用还是之后调用，Throw Advice 表示当目标发生异常时调用Advice。</p>
<ul>
<li>before advice： 在 join point 前被执行的 advice. 虽然 before advice 是在 join point 前被执行, 但是它并不能够阻止 join     point 的执行, 除非发生了异常(即我们在 before advice 代码中, 不能人为地决定是否继续执行 join point 中的代码)</li>
<li>after return advice： 在一个 join point 正常返回后执行的 advice</li>
<li>after throwing advice： 当一个 join point 抛出异常后执行的 advice</li>
<li>after(final) advice： 无论一个 join point 是正常退出还是发生了异常, 都会被执行的 advice.</li>
<li>around advice：在 join point 前和 joint point 退出后都执行的 advice. 这个是最常用的 advice.</li>
</ul>
<h2 id="Advice、JoinPoint、PointCut-关系"><a href="#Advice、JoinPoint、PointCut-关系" class="headerlink" title="Advice、JoinPoint、PointCut 关系"></a>Advice、JoinPoint、PointCut 关系</h2><p><img src="https://user-gold-cdn.xitu.io/2018/6/21/1641e065ec1ad2e7?w=712&amp;h=148&amp;f=jpeg&amp;s=22970" alt=""></p>
<p>下面这张图是在网上一位大佬的博客里发现的，可以帮助我们更好的理解这些概念之间的关系。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/21/1641e0a1e65715e4?w=581&amp;h=405&amp;f=jpeg&amp;s=32663" alt="图片源自网络"></p>
<p>上面是对于AOP中涉及到的一些基本概念及它们之间的关系做了简单的梳理。</p>
<h2 id="一些坑"><a href="#一些坑" class="headerlink" title="一些坑"></a>一些坑</h2><p>在调试程序过程中出现的一些问题记录</p>
<h3 id="1、使用AOP拦截controller层的服务成功，但是页面报错404"><a href="#1、使用AOP拦截controller层的服务成功，但是页面报错404" class="headerlink" title="1、使用AOP拦截controller层的服务成功，但是页面报错404"></a>1、使用AOP拦截controller层的服务成功，但是页面报错404</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint poin)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"环绕通知"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是再使用环绕通知时，需要给方法一个返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"cutIn()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint poin)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"环绕通知"</span>);</span><br><span class="line">    <span class="keyword">return</span> poin.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、0-formal-unbound-in-pointcut"><a href="#2、0-formal-unbound-in-pointcut" class="headerlink" title="2、0 formal unbound in pointcut"></a>2、0 formal unbound in pointcut</h3><p>在spring 4.x中 提供了aop注解方式 带参数的方式。看下面例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(value = <span class="string">"execution(* com.glmapper.framerwork.service.impl.*(int,int)) &amp;&amp; args(i,j)"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cutIn</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Before</span>(value=<span class="string">"cutIn(i, j)"</span>,argNames = <span class="string">"i,j"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">( <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"---------begins with "</span> + i + <span class="string">"-"</span> +j);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如说这里，Before中有两个int类型的参数，如果此时我们在使用时没有给其指定参数，那么就会抛出：<strong>Caused by: java.lang.IllegalArgumentException: error at ::0 formal unbound in pointcut</strong> 异常信息。</p>
<p><code>本来是想放在一篇里面的，但是实在太长了，就分开吧；周末更新下</code></p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/spring-aop-base/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/topic-resttemplate/">聊一聊 RestTemplate</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T04:24:19.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/topic-resttemplate/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/web/" title="web">web</a>,
  
    <a href="/tags/聊一聊/" title="聊一聊">聊一聊</a>,
  
    <a href="/tags/restful/" title="restful">restful</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<blockquote>
<p>最近这段时间用了下 RestTemplate 这个类，抽点时间总结下一些东西，希望对大家有所帮助。</p>
</blockquote>
<p>从 3.0 版本开始，Spring 提供了 RestTemplate 作为用于访问 Rest 服务的客户端，RestTemplate 提供了多种便捷访问远程 Http 服务的方法，能够大大提高客户端的编写效率。</p>
<p>本篇文章将从 RestTemplate 提供的 API 入手，先来了解下 RestTemplate 的具体使用，然后再对其中涉及到的几个核心类进行分析，最后再来分析下 RestTemplate 执行的整个流程，篇幅比较长，建议先码为快！</p>
<h2 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h2><p>在平时的使用中，我们通常都是使用包装好的getForObject/getForEntity，postForObject/postForEntity/postForLocation，put以及delete。</p>
<h3 id="get-请求处理"><a href="#get-请求处理" class="headerlink" title="get 请求处理"></a>get 请求处理</h3><p>getForEntity方法的返回值是一个ResponseEntity<t>，ResponseEntity<t>是Spring对HTTP请求响应的封装，包括了几个重要的元素，如响应码、contentType、contentLength、响应消息体等。</t></t></p>
<ul>
<li>url：调用的服务的地址</li>
<li>responseType：返回的body类型</li>
<li>uriVariables：有两种形式:<ul>
<li>可以用一个数字做占位符，最后是一个可变长度的参数，来一一替换前面的占位符<br><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682a71d3436f37?w=2110&amp;h=188&amp;f=png&amp;s=69713" alt=""></li>
<li>也可以前面使用name={name}这种形式，最后一个参数是一个map，map的key即为前边占位符的名字，map的value为参数值<br><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682a77dd355749?w=2084&amp;h=196&amp;f=png&amp;s=69867" alt=""></li>
</ul>
</li>
</ul>
<h4 id="responseType-测试案例"><a href="#responseType-测试案例" class="headerlink" title="responseType 测试案例"></a>responseType 测试案例</h4><p>定义的一个controller资源：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682a97f48fb171?w=1262&amp;h=282&amp;f=png&amp;s=54017" alt=""><br>这里分别使用不同的 responseType 进行测试：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682a93da364cf1?w=1536&amp;h=498&amp;f=png&amp;s=134357" alt=""></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getForEntity(responseType=Map.class):&#123;glmapper=hello glmapper&#125;</span><br><span class="line">getForEntity(responseType=String.class):&#123;&quot;glmapper&quot;:&quot;hello glmapper&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="uriVariables-测试案例"><a href="#uriVariables-测试案例" class="headerlink" title="uriVariables 测试案例"></a>uriVariables 测试案例</h4><p>先来看下非map方式的，两个controller，两种不同方式的参数获取（本质上是一样的）<br><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682ab556c128fc?w=1412&amp;h=272&amp;f=png&amp;s=70152" alt=""></p>
<ul>
<li>使用占位符的方式：</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682abcc1d8c3ca?w=1504&amp;h=240&amp;f=png&amp;s=69526" alt=""></p>
<ul>
<li>使用 map 的方式：</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682ac3e84dbb0a?w=1504&amp;h=276&amp;f=png&amp;s=66893" alt=""></p>
<h3 id="getForObject"><a href="#getForObject" class="headerlink" title="getForObject"></a>getForObject</h3><p>getForObject 函数实际上是对 getForEntity 函数的进一步封装，如果只关注返回的消息体的内容，对其他信息都不关注，那么就可以使用 getForObject。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682ad954b5df90?w=1148&amp;h=278&amp;f=png&amp;s=46924" alt=""></p>
<p>这里调用就比getForEntity要简单一点了，可以直接拿到对象：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682ae0804d0692?w=1504&amp;h=146&amp;f=png&amp;s=37689" alt=""></p>
<p>getForObject 的几个重载方法和 getForEntity 基本是一样的。</p>
<h3 id="post-请求处理"><a href="#post-请求处理" class="headerlink" title="post 请求处理"></a>post 请求处理</h3><p>在RestTemplate中，POST请求可以通过如下三个方法来发起：postForEntity，postForObject，postForLocation。</p>
<h4 id="postForEntity-案例"><a href="#postForEntity-案例" class="headerlink" title="postForEntity 案例"></a>postForEntity 案例</h4><p><img src="https://user-gold-cdn.xitu.io/2018/10/18/1668778ea595c23b?w=1212&amp;h=232&amp;f=png&amp;s=49938" alt=""><br>调用获取：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/18/16687792c19ca889?w=1588&amp;h=286&amp;f=png&amp;s=74538" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postForEntity(URI url, <span class="meta">@Nullable</span> Object request, Class&lt;T&gt; responseType)</span><br></pre></td></tr></table></figure>
<ul>
<li>方法的第一参数表示要调用的服务的地址</li>
<li>方法的第二个参数表示上传的参数</li>
<li>方法的第三个参数表示返回的消息体的数据类型</li>
</ul>
<h4 id="postForObject-案例"><a href="#postForObject-案例" class="headerlink" title="postForObject 案例"></a>postForObject 案例</h4><p>和 getForObject 相对应，只关注返回的消息体。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877ade7c3795c?w=1556&amp;h=228&amp;f=png&amp;s=67804" alt=""></p>
<h4 id="postForLocation-案例"><a href="#postForLocation-案例" class="headerlink" title="postForLocation 案例"></a>postForLocation 案例</h4><p>postForLocation也是提交新资源，提交成功之后，返回新资源的URI，postForLocation的参数和前面两种的参数基本一致，只不过该方法的返回值为Uri，这个只需要服务提供者返回一个Uri即可，该Uri表示新资源的位置。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877b5de7b3e06?w=1522&amp;h=324&amp;f=png&amp;s=88249" alt=""></p>
<p>这里有点坑，我们需要把这个uri添加到response的header中，不然后面拿到的是null。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877b96ded6304?w=1414&amp;h=194&amp;f=png&amp;s=39251" alt=""></p>
<h3 id="exchange"><a href="#exchange" class="headerlink" title="exchange"></a>exchange</h3><p>exchange 方法和上述这些方法差别在于需要多一个请求类型的参数：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877c1ee29bf31?w=1556&amp;h=194&amp;f=png&amp;s=50603" alt=""></p>
<h2 id="AsyncRestTemplate-异步客户端"><a href="#AsyncRestTemplate-异步客户端" class="headerlink" title="AsyncRestTemplate 异步客户端"></a>AsyncRestTemplate 异步客户端</h2><p>RestTemplate的异步实现方式。所涉及到的API和RestTemplate基本一致。区别在于RestTemplate直接返回结果，而AsyncRestTemplate返回的是ListenableFuture。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877cd10d2bb0e?w=1372&amp;h=716&amp;f=png&amp;s=139753" alt=""></p>
<h2 id="RestTemplate-拦截器"><a href="#RestTemplate-拦截器" class="headerlink" title="RestTemplate 拦截器"></a>RestTemplate 拦截器</h2><p>Spring提供了ClientHttpRequestInterceptor和AsyncClientHttpRequestInterceptor两个接口，分别可以对RestTemplate和AsyncRestTemplate发起的请求进行拦截，并在其被发送至服务端之前修改请求或是增强相应的信息。</p>
<ul>
<li><p>ClientHttpRequestInterceptor 拦截 RestTemplate<br><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877d579c56a0c?w=1380&amp;h=368&amp;f=png&amp;s=83172" alt=""></p>
</li>
<li><p>AsyncClientHttpRequestInterceptor 拦截AsyncRestTemplate<br><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877e0ff73a952?w=1548&amp;h=366&amp;f=png&amp;s=93632" alt=""></p>
</li>
</ul>
<p>设置拦截器就是通过提供的 setInterceptors 设置即可：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/18/166877ef7ccd132e?w=1368&amp;h=492&amp;f=png&amp;s=112979" alt=""></p>
<h2 id="自定义-ResponseErrorHandler"><a href="#自定义-ResponseErrorHandler" class="headerlink" title="自定义 ResponseErrorHandler"></a>自定义 ResponseErrorHandler</h2><p>ResponseErrorHandler 接口定义了当response发生错误时需要进行的操作。这里我们自定义一个CustomResponseErrorHandler，当返回的code不是200时，就表示执行出错了。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668fe76528a5659?w=1560&amp;h=630&amp;f=png&amp;s=146140" alt=""></p>
<p>设置 ResponseErrorHandler：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668fe8f603b0760?w=1574&amp;h=338&amp;f=png&amp;s=117473" alt=""></p>
<p>执行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668fe97d6c85821?w=2672&amp;h=348&amp;f=png&amp;s=173962" alt=""></p>
<h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><p>下面来梳理下 RestTemplate 中请求处理的流程。下图中 XXXX 表示我们调用的 API 方法。大体流程就是：api 内部做一些请求相关的处理封装，然后交给 execute 方法执行，最后真正处理则是在 doExecute 方法中完成。<br><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668f78ce0e92b1e?w=294&amp;h=248&amp;f=png&amp;s=5157" alt=""></p>
<p>下面以 getForEntity 方法的执行过程来分析：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668f7c60711d002?w=1452&amp;h=248&amp;f=png&amp;s=68902" alt=""></p>
<p>getForEntity 方法：</p>
<ul>
<li>基于给定响应类型，返回一个请求回调实现，准备请求。</li>
<li>基于给定响应类型，返回 ResponseEntity 的响应提取器。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668f7e5d410b82e?w=1570&amp;h=246&amp;f=png&amp;s=66950" alt=""><br>execute 方法：</p>
<ul>
<li>这个方法里面是对url进行urlencode编码处理的，统一转为URL。这里我们也可以手动把参数进行网络编码。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668f8294bc82e81?w=1516&amp;h=886&amp;f=png&amp;s=207580" alt=""><br>doExecute是请求真正处理的方法，这里来重点看下这个方法的执行过程：</p>
<ul>
<li>createRequest</li>
<li>doWithRequest</li>
<li>execute</li>
<li>handleResponse</li>
</ul>
<h4 id="1、createRequest"><a href="#1、createRequest" class="headerlink" title="1、createRequest"></a>1、createRequest</h4><p>这个方法的作用就是创建一个 ClientHttpRequest 对象。RestTemplate集成了 HttpAccessor这个抽象类，创建ClientHttpRequest的过程就是在其父类HttpAccessor中通过默认的 ClientHttpRequestFactory 实现类 SimpleClientHttpRequestFactory 完成具体的请求创建。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668f8a70f4e1664?w=1462&amp;h=370&amp;f=png&amp;s=91033" alt=""></p>
<ul>
<li><p>1、创建 java.net.HttpURLConnection 对象</p>
</li>
<li><p>2、设置 connection，包括 connectTimeout、setDoInput 等。</p>
</li>
<li><p>3、bufferRequestBody 用于标志是否使用缓存流的形式，默认是 true。缺点是当发送大量数据时，比如 put/post，存在内存消耗严重。该值可以通过 SimpleClientHttpRequestFactory#setBufferRequestBody来修改。</p>
</li>
</ul>
<blockquote>
<p>不同版本的变更还是比较大的，大家在阅读源码时，还是从最新的代码来看。</p>
</blockquote>
<h4 id="2、doWithRequest"><a href="#2、doWithRequest" class="headerlink" title="2、doWithRequest"></a>2、doWithRequest</h4><p>RequestCallback 封装了请求体和请求头对象。这里会遍历所有的 HttpMessageConverter，解析成所有支持的MediaType，放在allSupportedMediaTypes中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getHeaders().setAccept(allSupportedMediaTypes);</span><br></pre></td></tr></table></figure>
<p>RestTemplate中对应了两个内部类的实现：</p>
<ul>
<li><p>AcceptHeaderRequestCallback.doWithRequest的处理。<br>发送请求时，Http头部需要设置Accept字段，该字段表明了发送请求的这方接受的媒体类型（消息格式），也是响应端要返回的信息的媒体类型（消息格式）。<br>根据postForEntity方法的第三个参数responseType，程序将选择适合的解析器XXXConverter，并依据该解析器找出所有支持的媒体类型。</p>
<ul>
<li>HttpEntityRequestCallback.doWithRequest的处理。<br>如果是POST请求并且消息体存在时，除了设置Accept字段，还可能需要设置Content-Type字段，该字段表明了所发送请求的媒体类型（消息格式），也是响应端接受的媒体类型（消息格式）。<br>根据postForEntity方法的第二个参数request，程序将选择适合的解析器XXXConverter，将请求消息写入输出流。</li>
</ul>
</li>
</ul>
<h4 id="3、execute"><a href="#3、execute" class="headerlink" title="3、execute"></a>3、execute</h4><p>这里会把请求头/体封装到connect，然后发送请求。跟踪 execute 方法执行，定位到SimpleBufferingClientHttpRequest#executeInternal方法：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668fdccb7601b1f?w=1570&amp;h=612&amp;f=png&amp;s=177702" alt=""><br>这里是使用实例 SimpleBufferingClientHttpRequest 封装请求体和请求头。从代码中可以看到：</p>
<ul>
<li>delete 时通过前面设置的 DoOutput参数和是否可以设置输出流来判断是否需要发送请求体如果是 delete 请求，那么很明显 DoOutput = false，不会有封装请求体的过程，即不执行FileCopyUtils.copy(bufferedOutput, this.connection.getOutputStream())。</li>
</ul>
<h4 id="4、handleResponse"><a href="#4、handleResponse" class="headerlink" title="4、handleResponse"></a>4、handleResponse</h4><p>最后就是 response 的解析了，从代码来看，主要还是 Error 的解析。这里的ErrorHandler我们前面也提到，可以通过实现 ResponseErrorHandler 来自定义 异常处理。<br><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668fe3ae92b7ead?w=1532&amp;h=502&amp;f=png&amp;s=109859" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇先介绍了RestTemplate的API使用，挑了几个介绍了下，更多使用细节还是要针对不同的场景来决定。接着对拦截器，异步RestTemplate以及错误处理器做了简单的介绍并给出了案例。最后分析了下RestTemplate的执行流程，篇幅原因执行流程部分只是大概捋了捋，其中还是很多细节有时间再补充，这部分主要就是看底层是如何通信的，已经请求参数的传递等。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/topic-resttemplate/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/spring-extention-namespacehandler/">聊一聊 Spring 中的扩展机制(二) - NamespaceHandler</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T04:20:21.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/spring-extention-namespacehandler/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/聊一聊/" title="聊一聊">聊一聊</a>,
  
    <a href="/tags/spring-扩展机制/" title="spring 扩展机制">spring 扩展机制</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>前一篇 <a href="https://juejin.im/post/5b7964d6f265da43412866c7" target="_blank" rel="noopener">聊一聊 Spring 中的扩展机制（一）</a> 中聊到了<code>ApplicationListener</code>、<code>ApplicationContextAware</code>、<code>BeanFactoryAware</code>三种机制。本篇将介绍 <code>NamespaceHandler</code> 的扩展使用。</p>
<p>相信很多小伙伴对于这几个类都不陌生，基本基于<code>java</code>实现的<code>RPC</code>框架都会使用，比如 <a href="https://github.com/apache/incubator-dubbo" target="_blank" rel="noopener">Dubbo</a> , <a href="https://github.com/alipay/sofa-rpc" target="_blank" rel="noopener">SOFARpc</a> 等。本文先从几个小<code>demo</code>入手，了解下基本的概念和编程流程，然后分析下 <code>SOFARpc</code> 中是如何使用的。</p>
<h2 id="NamespaceHandler"><a href="#NamespaceHandler" class="headerlink" title="NamespaceHandler"></a>NamespaceHandler</h2><p><code>NamespaceHandler</code> 是 <code>Spring</code> 提供的 命名空间处理器。下面这张图中，除了乱入的本篇 <code>demo</code> 中涉及到的 <code>BridgeNameSpaceHandler</code> 之外，其他均为 <code>Spring</code> 自身提供的。<br><img src="https://user-gold-cdn.xitu.io/2018/8/26/1657680c24505dbe?w=2376&amp;h=488&amp;f=png&amp;s=307869" alt=""><br>因为这里我只引入了 <code>bean</code> 和 <code>context</code> 依赖，所以这也仅仅是一部分。图中我们常用的应该算是 <code>AopNamespaceHandler</code>。</p>
<p>我们使用基于<code>xml</code>的<code>spring</code>配置时，可能需要配置如<code>&lt;aop:config /&gt;</code>这样的标签，在配置这个标签之前，通常我们需要引入这个<code>aop</code>所在的命名空间：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string"> http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于AOP 可以了解下 <a href="https://juejin.im/post/5b1ca657f265da6e5a205c45" target="_blank" rel="noopener">聊一聊 AOP ：表现形式与基础概念</a>，这里不过多解释，下面就按照 <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#xml-custom" target="_blank" rel="noopener">官方文档的流程</a> 来写一个自定义<code>xml</code>，最终效果如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bridge:application</span> <span class="attr">id</span>=<span class="string">"bridgeTestApplication"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">name</span>=<span class="string">"bridgeTestApplication"</span>  </span></span><br><span class="line"><span class="tag">                    <span class="attr">version</span>=<span class="string">"1.0"</span> </span></span><br><span class="line"><span class="tag">                    <span class="attr">organization</span>=<span class="string">"bridge.glmapper.com"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">owner</span>=<span class="string">"leishu@glmapper"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="1、定义-xsd-文件"><a href="#1、定义-xsd-文件" class="headerlink" title="1、定义 xsd 文件"></a>1、定义 xsd 文件</h3><p>关于 <code>xsd</code> 文件的语法规则不在本篇范围之内，有兴趣的同学可以自行<code>google</code>。<br>下面这个文件很简单，定义的<code>element</code> name 为<code>application</code>，对应于 <code>bridge:application</code>中的<code>application</code>。<code>attribute</code>就是上面效果展示中对应的几个属性名。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:schema</span> <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:beans</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:tool</span>=<span class="string">"http://www.springframework.org/schema/tool"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns</span>=<span class="string">"http://bridge.glmapper.com/schema/bridge"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetNamespace</span>=<span class="string">"http://bridge.glmapper.com/schema/bridge"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:import</span> <span class="attr">namespace</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:complexType</span> <span class="attr">name</span>=<span class="string">"applicationType"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"xsd:ID"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"xsd:string"</span> <span class="attr">use</span>=<span class="string">"required"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">"version"</span> <span class="attr">type</span>=<span class="string">"xsd:string"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">"owner"</span> <span class="attr">type</span>=<span class="string">"xsd:string"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">"organization"</span> <span class="attr">type</span>=<span class="string">"xsd:string"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">"application"</span> <span class="attr">type</span>=<span class="string">"applicationType"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:schema</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2、编写-NamespaceHandler"><a href="#2、编写-NamespaceHandler" class="headerlink" title="2、编写 NamespaceHandler"></a>2、编写 NamespaceHandler</h3><blockquote>
<p>In addition to the schema, we need a NamespaceHandler that will parse all elements of this specific namespace Spring encounters while parsing configuration files.</p>
</blockquote>
<p>用编写的这个 <code>NamespaceHandler</code> 来解析配置文件。</p>
<p>具体说来<code>NamespaceHandler</code>会根据<code>schema</code>和节点名找到某个<code>BeanDefinitionParser</code>，然后由<code>BeanDefinitionParser</code>完成具体的解析工作。</p>
<p><code>Spring</code>提供了默认实现类<code>NamespaceHandlerSupport</code>和<code>AbstractSingleBeanDefinitionParser</code>，最简单的方式就是去继承这两个类。</p>
<p>这里通过继承 <code>NamespaceHandlerSupport</code> 这个抽象类来完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"application"</span>, </span><br><span class="line">        <span class="keyword">new</span> ApplicationBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里实际上只是注册了一个解析器，具体的 <code>BeanDefinitionParser</code> 才是将 <code>XML</code>元素映射到特定<code>bean</code>的。</p>
<h3 id="3、编写-BeanDefinitionParser"><a href="#3、编写-BeanDefinitionParser" class="headerlink" title="3、编写 BeanDefinitionParser"></a>3、编写 BeanDefinitionParser</h3><p>这里直接通过实现<code>BeanDefinitionParser</code>接口的方式定义我们的<code>BeanDefinitionParser</code>实现类。关于<code>AbstractSingleBeanDefinitionParser</code> 的使用在 <code>SPFARpc</code> 中会涉及到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//beanDefinition</span></span><br><span class="line">        RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">        beanDefinition.setBeanClass(ApplicationConfig.class);</span><br><span class="line">        beanDefinition.setLazyInit(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//解析id</span></span><br><span class="line">        String id = element.getAttribute(<span class="string">"id"</span>);</span><br><span class="line">        beanDefinition.getPropertyValues().add(<span class="string">"id"</span>, id);</span><br><span class="line">        <span class="comment">//解析name</span></span><br><span class="line">        beanDefinition.getPropertyValues().add(<span class="string">"name"</span>,</span><br><span class="line">        element.getAttribute(<span class="string">"name"</span>));</span><br><span class="line">        <span class="comment">//解析version</span></span><br><span class="line">        beanDefinition.getPropertyValues().add(<span class="string">"version"</span>,</span><br><span class="line">        element.getAttribute(<span class="string">"version"</span>));</span><br><span class="line">        <span class="comment">//owner</span></span><br><span class="line">        beanDefinition.getPropertyValues().add(<span class="string">"owner"</span>,</span><br><span class="line">        element.getAttribute(<span class="string">"owner"</span>));</span><br><span class="line">        <span class="comment">//organization</span></span><br><span class="line">        beanDefinition.getPropertyValues().add(<span class="string">"organization"</span>,</span><br><span class="line">        element.getAttribute(<span class="string">"organization"</span>));</span><br><span class="line">    </span><br><span class="line">        parserContext.getRegistry().registerBeanDefinition(id, beanDefinition);</span><br><span class="line">        <span class="keyword">return</span> beanDefinition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们需要了解的是开始解析自定义标签的时候，是通过<code>BeanDefinitionParserDelegate-&gt;parseCustomElement</code>方法来处理的，如下图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/26/16576a988554f2e9?w=2046&amp;h=568&amp;f=png&amp;s=172310" alt=""></p>
<p>通过<code>ele</code>元素拿到当前<code>namespaceUri</code>，也就是在<code>xsd</code>中定义的命名空间，接着委托给 <code>DefaultNamespaceResolver</code> 得到具体的<code>handler</code>（<code>BridgenamspaceHandler</code>） ,<br>然后执行<code>parse</code> 解析。</p>
<h3 id="4、配置-spring-handlers-和-spring-schmas"><a href="#4、配置-spring-handlers-和-spring-schmas" class="headerlink" title="4、配置 spring.handlers 和 spring.schmas"></a>4、配置 spring.handlers 和 spring.schmas</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http\://bridge.glmapper.com/schema/bridge=</span><br><span class="line">com.glmapper.extention.namespacehandler.BridgeNamespaceHandler</span><br><span class="line"></span><br><span class="line">http\://bridge.glmapper.com/schema/bridge.xsd=META-INF/bridge.xsd</span><br></pre></td></tr></table></figure>
<p>配置这个其实是为了让<code>Spring</code>在解析<code>xml</code>的时候能够感知到我们的自定义元素，我们需要把<code>NamespaceHandler</code>和<code>xsd</code>文件放到位于META-INF目录下的<code>spring.handlers</code> 和 <code>spring.schmas</code>文件中。这样就可以在<code>spring</code>配置文件中使用我们自定义的标签了。如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:bridge</span>=<span class="string">"http://bridge.glmapper.com/schema/bridge"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://bridge.glmapper.com/schema/bridge</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://bridge.glmapper.com/schema/bridge.xsd"</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">    <span class="tag">&lt;<span class="name">bridge:application</span> <span class="attr">id</span>=<span class="string">"bridgeTestApplication"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">name</span>=<span class="string">"bridgeTestApplication"</span>  </span></span><br><span class="line"><span class="tag">                    <span class="attr">version</span>=<span class="string">"1.0"</span> </span></span><br><span class="line"><span class="tag">                    <span class="attr">organization</span>=<span class="string">"bridge.glmapper.com"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">owner</span>=<span class="string">"leishu@glmapper"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>验证下从容器中获取我们的<code>bean</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span></span><br><span class="line">    ClassPathXmlApplicationContext(<span class="string">"classpath:bean.xml"</span>);</span><br><span class="line">    </span><br><span class="line">    ApplicationConfig applicationConfig = (ApplicationConfig)</span><br><span class="line">    applicationContext.getBean(<span class="string">"bridgeTestApplication"</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"applicationConfig = "</span>+applicationConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">applicationConfig = ApplicationConfig &#123;</span><br><span class="line">    id=bridgeTestApplication, </span><br><span class="line">    name=&apos;bridgeTestApplication&apos;, </span><br><span class="line">    version=&apos;1.0&apos;, </span><br><span class="line">    owner=&apos;leishu@glmapper&apos;, </span><br><span class="line">    organization=&apos;bridge.glmapper.com&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>整体来看，如果我们要实现自己的 <code>xml</code> 标签，仅需完成以下几步即可：</p>
<ul>
<li>1、定义 xsd 文件</li>
<li>2、编写 NamespaceHandler </li>
<li>3、编写 BeanDefinitionParser</li>
<li>4、配置 spring.handlers 和 spring.schmas</li>
</ul>
<h2 id="SOFARpc-中使用分析"><a href="#SOFARpc-中使用分析" class="headerlink" title="SOFARpc 中使用分析"></a>SOFARpc 中使用分析</h2><p><code>SOFARpc</code> 中的 <code>rpc.xsd</code> 文件是集成在 <code>sofaboot.xsd</code> 文件中的，详细可见：<a href="https://github.com/alipay/sofa-boot" target="_blank" rel="noopener">sofa-boot</a></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/26/16576c06a6b70603?w=1172&amp;h=420&amp;f=png&amp;s=60454" alt=""></p>
<blockquote>
<p><code>xsd</code> 文件这里不贴了，有点长 </p>
</blockquote>
<h3 id="spring-handlers-和-spring-schmas"><a href="#spring-handlers-和-spring-schmas" class="headerlink" title="spring.handlers 和 spring.schmas"></a>spring.handlers 和 spring.schmas</h3><p>先看下 <code>spring.handlers</code> 和 <code>spring.schmas</code> 配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http\:<span class="comment">//sofastack.io/schema/sofaboot=</span></span><br><span class="line">com.alipay.sofa.infra.config.spring.namespace.handler.SofaBootNamespaceHandler</span><br><span class="line"></span><br><span class="line">http\:<span class="comment">//sofastack.io/schema/sofaboot.xsd=</span></span><br><span class="line">META-INF/com/alipay/sofa/infra/config/spring/namespace/schema/sofaboot.xsd</span><br><span class="line"></span><br><span class="line">http\:<span class="comment">//sofastack.io/schema/rpc.xsd=</span></span><br><span class="line">META-INF/com/alipay/sofa/infra/config/spring/namespace/schema/rpc.xsd</span><br></pre></td></tr></table></figure>
<p>从 <code>spring.handlers</code>找到 <code>NamespaceHandler</code> : <code>SofaBootNamespaceHandler</code>。</p>
<h3 id="SofaBootNamespaceHandler"><a href="#SofaBootNamespaceHandler" class="headerlink" title="SofaBootNamespaceHandler"></a>SofaBootNamespaceHandler</h3><p>源码如下，这里看出来，并不是像上面我们自己写的那种方式那样，会有一个 <code>BeanDefinitionParser</code>。这里其实设计的很巧妙，通过<code>spi</code>的方式来载入具体的<code>BeanDefinitionParser</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaBootNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServiceLoader&lt;SofaBootTagNameSupport&gt; serviceLoaderSofaBoot =</span><br><span class="line">        ServiceLoader.load(SofaBootTagNameSupport.class);</span><br><span class="line">        <span class="comment">//SOFABoot</span></span><br><span class="line">        <span class="keyword">for</span> (SofaBootTagNameSupport tagNameSupport : serviceLoaderSofaBoot) &#123;</span><br><span class="line">            <span class="keyword">this</span>.registerTagParser(tagNameSupport);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerTagParser</span><span class="params">(SofaBootTagNameSupport tagNameSupport)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(tagNameSupport <span class="keyword">instanceof</span> BeanDefinitionParser)) &#123;</span><br><span class="line">            <span class="comment">// log</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String tagName = tagNameSupport.supportTagName();</span><br><span class="line">        registerBeanDefinitionParser(tagName, (BeanDefinitionParser)</span><br><span class="line">        tagNameSupport);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看出有 <code>ReferenceDefinitionParser</code> 和 <code>ServiceDefinitionParser</code> 两个解析类，分别对应服务引用和服务暴露。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/26/16576cfad71411d6?w=2626&amp;h=702&amp;f=png&amp;s=279969" alt=""></p>
<p>下面以<code>ReferenceDefinitionParser</code>为例，先看下它的类图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/26/16576da5390f9128?w=1514&amp;h=904&amp;f=png&amp;s=90864" alt=""></p>
<p>解析工作都是在 <code>AbstractContractDefinitionParser</code> 类中完成， <code>ReferenceDefinitionParser</code> 自己只是做了一些特殊处理【jvm-first，jvm服务】。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇通过 <code>NamespaceHandler</code> 了解了如何去编写我们自定义的xml标签，从<code>NamespaceHandler</code>的角度可以很好的理解一些 <code>RPC</code> 框架中最基础的基于<code>xml</code> 方式的服务引用和暴露的实现思路。另外通过分析 <code>SOFARpc</code> ，也了解了在实际的工程组件中对于<code>NamespaceHandler</code>的扩展使用。</p>
<p>本文代码：<a href="https://github.com/glmapper/glmapper-spring-extention" target="_blank" rel="noopener">glmapper-spring-extention</a></p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/spring-extention-namespacehandler/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/spring-extention-one/">聊一聊 Spring 中的扩展机制（一）</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T04:16:06.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/spring-extention-one/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/聊一聊/" title="聊一聊">聊一聊</a>,
  
    <a href="/tags/spring-事件机制/" title="spring 事件机制">spring 事件机制</a>,
  
    <a href="/tags/spring-扩展机制/" title="spring 扩展机制">spring 扩展机制</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<blockquote>
<p>之前 Spring 源码系列文章中大多是底层源码的分析，通过源码可以让我们能够清晰的了解 Spring 到底是什么，而不是停留于表面的认知。比如当我们要使用 @Autowired 注解时，可以拿到我们想要的 bean ,但是为什么可以是值得思考的。– 关于阅读源码</p>
</blockquote>
<p>Spring源码的阅读结合日常的使用，可以帮助我们更好的掌握这个庞大的技术体系，实际的开发工作中有很多地方可以借鉴它的一些思想来帮助我们更好的实现自己的业务逻辑。本篇将以扩展点为切入点，来了解下在Spring生命周期中扩展Spring中的Bean功能。</p>
<h2 id="ApplicationListener-扩展"><a href="#ApplicationListener-扩展" class="headerlink" title="ApplicationListener 扩展"></a>ApplicationListener 扩展</h2><p><code>ApplicationListener</code> 其实是 <code>spring</code> 事件通知机制中核心概念；在java的事件机制中，一般会有三个概念：</p>
<ul>
<li>event object : 事件对象</li>
<li>event source ：事件源，产生事件的地方</li>
<li>event listener ：监听事件并处理</li>
</ul>
<p><code>ApplicationListener</code> 继承自 <code>java.util.EventListener</code> ，提供了对于<code>Spring</code>中事件机制的扩展。</p>
<p><code>ApplicationListener</code> 在实际的业务场景中使用的非常多，比如我一般喜欢在容器初始化完成之后来做一些资源载入或者一些组件的初始化。这里的容器指的就是<code>Ioc</code>容器，对应的事件是<code>ContextRefreshedEvent</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartApplicationListener</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class"><span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent</span></span></span><br><span class="line"><span class="function"><span class="params">    contextRefreshedEvent)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//初始化资源文件</span></span><br><span class="line">       <span class="comment">//初始化组件 如：cache</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码会在容器刷新完成之后来做一些事情。下面通过自定义事件来看看怎么使用，在看具体的<code>demo</code>之前，先来了解下一些关注点。</p>
<p>日常工作了，如果要使用 <code>Spring</code> 事件传播机制，我们需要关注的点有以下几点：</p>
<ul>
<li>事件类，这个用来描述事件本身一些属性，一般继承<code>ApplicationEvent</code></li>
<li>监听类，用来监听具体的事件并作出响应。需要实现 <code>ApplicationListener</code> 接口</li>
<li>事件发布类，需要通过这个类将时间发布出去，这样才能被监听者监听到，需要实现<code>ApplicationContextAware</code>接口。</li>
<li>将事件类和监听类交给<code>Spring</code>容器。</li>
</ul>
<p>那么下面就按照这个思路来看下<code>demo</code>的具体实现。</p>
<h3 id="事件类：UserRegisterEvent"><a href="#事件类：UserRegisterEvent" class="headerlink" title="事件类：UserRegisterEvent"></a>事件类：UserRegisterEvent</h3><p><code>UserRegisterEvent</code> ，用户注册事件；这里作为事件对象，继承自 <code>ApplicationEvent</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 用户注册事件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/7/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRegisterEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserRegisterEvent</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserRegisterEvent</span><span class="params">(Object o, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(o);</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事件发布类：UserService"><a href="#事件发布类：UserService" class="headerlink" title="事件发布类：UserService"></a>事件发布类：UserService</h3><p>用户注册服务，这里需要在用户注册时将注册事件发布出去，所以通过实现<code>ApplicationEventPublisherAware</code>接口，使<code>UserService</code>具有事件发布能力。</p>
<blockquote>
<p>ApplicationEventPublisherAware:发布事件，也就是把某个事件告诉的所有与这个事件相关的监听器。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 用户注册服务，实现ApplicationEventPublisherAware接口</span></span><br><span class="line"><span class="comment"> ，表明本身具有事件发布能力</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/7/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher</span></span></span><br><span class="line"><span class="function"><span class="params">    applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用户："</span> + name + <span class="string">" 已注册！"</span>);</span><br><span class="line">        applicationEventPublisher.publishEvent(<span class="keyword">new</span> UserRegisterEvent(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>UserService</code>实际上是作为事件源存在的，通过<code>register</code>将用户注册事件传播出去。那么下面就是需要定义如何来监听这个事件，并且将事件进行消费处理掉，这里就是通过<code>ApplicationListener</code>来完成。</p>
<h3 id="监听类：BonusServerListener"><a href="#监听类：BonusServerListener" class="headerlink" title="监听类：BonusServerListener"></a>监听类：BonusServerListener</h3><p>当用户触发注册操作时，向积分服务发送消息，为用户初始化积分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: BonusServerListener</span></span><br><span class="line"><span class="comment"> 积分处理，当用户注册时，给当前用户增加初始化积分</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/7/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BonusServerListener</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class"><span class="title">ApplicationListener</span>&lt;<span class="title">UserRegisterEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(UserRegisterEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"积分服务接到通知，给 "</span> + event.getSource() +</span><br><span class="line">        <span class="string">" 增加积分..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注册到容器中"><a href="#注册到容器中" class="headerlink" title="注册到容器中"></a>注册到容器中</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.glmapper.extention.UserService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bonusServerListener"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.glmapper.extention.BonusServerListener"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="客户端类"><a href="#客户端类" class="headerlink" title="客户端类"></a>客户端类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 客户端类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/7/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context =<span class="keyword">new</span> </span><br><span class="line">        ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        UserService userService = (UserService)</span><br><span class="line">        context.getBean(<span class="string">"userService"</span>);</span><br><span class="line">        <span class="comment">//注册事件触发</span></span><br><span class="line">        userService.register(<span class="string">"glmapper"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端类中，注册一个<code>name</code>为<code>glmapper</code>的用户，执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户：glmapper 已注册！</span><br><span class="line">积分服务接到通知，给 glmapper 增加积分...</span><br></pre></td></tr></table></figure>
<p>现在来考虑另外一个问题，增加一个功能，用户注册之后给用户发一个邮件。这个其实就是增加一个监听类就可以，前提是这个监听者是监听当前事件的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 邮件服务监听器，当监听到用户的注册行为时，</span></span><br><span class="line"><span class="comment">    给用户发送邮件通知</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/7/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailServerListener</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class"><span class="title">ApplicationListener</span>&lt;<span class="title">UserRegisterEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(UserRegisterEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"邮件服务接到通知，给 "</span> + event.getSource() +</span><br><span class="line">        <span class="string">" 发送邮件..."</span>);</span><br></pre></td></tr></table></figure>
<p>这里如果将<code>UserRegisterEvent</code>换成<code>UserLoginEvent</code>，那么邮件服务将不会有任何行为。</p>
<p>增加发送邮件监听类之后的执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用户：glmapper 已注册！</span><br><span class="line">邮件服务接到通知，给 glmapper 发送邮件...</span><br><span class="line">积分服务接到通知，给 glmapper 增加积分...</span><br></pre></td></tr></table></figure></p>
<p><code>Spring</code> 的事件传播机制是基于观察者模式（<code>Observer</code>）实现的，它可以将 <code>Spring Bean</code>的改变定义为事件 <code>ApplicationEvent</code>，通过 <code>ApplicationListener</code> 监听 <code>ApplicationEvent</code> 事件，一旦<code>Spring Bean</code> 使用 <code>ApplicationContext.publishEvent( ApplicationEvent event )</code>发布事件后，<code>Spring</code> 容器会通知注册在 容器中所有 <code>ApplicationListener</code> 接口的实现类，最后 <code>ApplicationListener</code> 接口实现类判断是否处理刚发布出来的 <code>ApplicationEvent</code> 事件。</p>
<h2 id="ApplicationContextAware-扩展"><a href="#ApplicationContextAware-扩展" class="headerlink" title="ApplicationContextAware 扩展"></a>ApplicationContextAware 扩展</h2><p><code>ApplicationContextAware</code>中只有一个<code>setApplicationContext</code>方法。实现了<code>ApplicationContextAware</code>接口的类，可以在该<code>Bean</code>被加载的过程中获取<code>Spring</code>的应用上下文<code>ApplicationContext</code>，通过<code>ApplicationContext</code>可以获取<br><code>Spring</code>容器内的很多信息。</p>
<p>这种一般在需要手动获取<code>Bean</code>的注入实例对象时会使用到。下面通过一个简单的<code>demo</code>来了解下。</p>
<p><code>GlmapperApplicationContext</code> 持有<code>ApplicationContext</code>对象，通过实现 <code>ApplicationContextAware</code>接口来给<code>ApplicationContext</code>做赋值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: GlmapperApplicationContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/7/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperApplicationContext</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class"><span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  ApplicationContext applicationContext;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext</span></span></span><br><span class="line"><span class="function"><span class="params">    applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.applicationContext=applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationContext <span class="title">getApplicationContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要手动获取的<code>bean</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: HelloService</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/7/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Glmapper"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在配置文件中进行配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloService"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"com.glmapper.extention.applicationcontextaware.HelloService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"glmapperApplicationContext"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"com.glmapper.extention.applicationcontextaware.GlmapperApplicationContext"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>客户端类调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span></span><br><span class="line">        ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        </span><br><span class="line">        HelloService helloService = (HelloService)</span><br><span class="line">        context.getBean(<span class="string">"helloService"</span>);</span><br><span class="line">        helloService.sayHello();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里通过实现ApplicationContextAware接口的类来完成bean的获取</span></span><br><span class="line">        GlmapperApplicationContext glmapperApplicationContext =</span><br><span class="line">        (GlmapperApplicationContext) context.getBean(<span class="string">"glmapperApplicationContext"</span>);</span><br><span class="line">        </span><br><span class="line">        ApplicationContext applicationContext =</span><br><span class="line">        glmapperApplicationContext.getApplicationContext();</span><br><span class="line">        </span><br><span class="line">        HelloService glmapperHelloService = (HelloService)</span><br><span class="line">        applicationContext.getBean(<span class="string">"helloService"</span>);</span><br><span class="line">        </span><br><span class="line">        glmapperHelloService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BeanFactoryAware-扩展"><a href="#BeanFactoryAware-扩展" class="headerlink" title="BeanFactoryAware 扩展"></a>BeanFactoryAware 扩展</h2><p>我们知道<code>BeanFactory</code>是整个<code>Ioc</code>容器最顶层的接口，它规定了容器的基本行为。实现<code>BeanFactoryAware</code>接口就表明当前类具体<code>BeanFactory</code>的能力。</p>
<p><code>BeanFactoryAware</code>接口中只有一个<code>setBeanFactory</code>方法。实现了<code>BeanFactoryAware</code>接口的类，可以在该<code>Bean</code>被加载的过程中获取加载该<code>Bean</code>的<code>BeanFactory</code>，同时也可以获取这个<code>BeanFactory</code>中加载的其它<code>Bean</code>。</p>
<p>来想一个问题，我们为什么需要通过<code>BeanFactory</code>的<code>getBean</code>来获取<code>Bean</code>呢？Spring已经提供了很多便捷的注入方式，那么通过<code>BeanFactory</code>的<code>getBean</code>来获取<code>Bean</code>有什么好处呢？来看一个场景。</p>
<p>现在有一个<code>HelloService</code>，这个<code>HelloService</code>就是打招呼，我们需要通过不同的语言来实现打招呼，比如用中文，用英文。一般的做法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//英文打招呼实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperHelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Glmapper"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中文打招呼实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeishuHelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"你好，磊叔"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端类来调用务必会出现下面的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (condition==&quot;英文&quot;)&#123;</span><br><span class="line">    glmapperHelloService.sayHello();</span><br><span class="line">&#125;</span><br><span class="line">if (condition==&quot;中文&quot;)&#123;</span><br><span class="line">    leishuHelloService.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有一天，老板说我们要做国际化，要实现全球所有的语言来问候。你是说好的，还是控制不住要动手呢？</p>
<p>那么有没有什么方式可以动态的去决定我的客户端类到底去调用哪一种语言实现，而不是用过if-else方式来罗列呢？是的，对于这些需要动态的去获取对象的场景，<code>BeanFactoryAware</code>就可以很好的搞定。OK，来看代码改造：</p>
<p>引入<code>BeanFactoryAware</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 实现BeanFactoryAware ，让当前bean本身具有 BeanFactory 的能力</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实现 BeanFactoηAware 接口的 bean 可以直接访问 Spring 容器，被容器创建以后，</span></span><br><span class="line"><span class="comment"> * 它会拥有一个指向 Spring</span></span><br><span class="line"><span class="comment"> 容器的引用，可以利用该bean根据传入参数动态获取被spring工厂加载的bean</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: &lt;a href="glmapper_2018@163.com"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guolei.sgl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18/7/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperBeanFactory</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">    BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory=beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供一个execute 方法来实现不同业务实现类的调度器方案。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String beanName)</span></span>&#123;</span><br><span class="line">        HelloService helloService=(HelloService)</span><br><span class="line">        beanFactory.getBean(beanName);</span><br><span class="line">        helloService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里为了逻辑方便理解，再加入一个<code>HelloFacade</code> 类,这个类的作用就是持有一个<code>BeanFactoryAware</code>的实例对象，然后通过<code>HelloFacade</code>实例对象的方法来屏蔽底层<code>BeanFactoryAware</code>实例的实现细节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloFacade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GlmapperBeanFactory glmapperBeanFactory;</span><br><span class="line">    <span class="comment">//调用glmapperBeanFactory的execute方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String beanName)</span></span>&#123;</span><br><span class="line">        glmapperBeanFactory.execute(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGlmapperBeanFactory</span><span class="params">(GlmapperBeanFactory beanFactory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.glmapperBeanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span></span><br><span class="line">        ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        </span><br><span class="line">        HelloFacade helloFacade = (HelloFacade)</span><br><span class="line">        context.getBean(<span class="string">"helloFacade"</span>);</span><br><span class="line"></span><br><span class="line">        GlmapperBeanFactory glmapperBeanFactory = (GlmapperBeanFactory)</span><br><span class="line">        context.getBean(<span class="string">"glmapperBeanFactory"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里其实可以不通过set方法注入到helloFacade中，</span></span><br><span class="line">        <span class="comment">//可以在helloFacade中通过autowired</span></span><br><span class="line">        <span class="comment">//注入；这里在使用main方法来执行验证，所以就手动set进入了</span></span><br><span class="line">        helloFacade.setGlmapperBeanFactory(glmapperBeanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个只需要传入不同HelloService的实现类的beanName，</span></span><br><span class="line">        <span class="comment">//就可以执行不同的业务逻辑</span></span><br><span class="line">        helloFacade.sayHello(<span class="string">"glmapperHelloService"</span>);</span><br><span class="line">        helloFacade.sayHello(<span class="string">"leishuHelloService"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在调用者（客户端）类中，只需要通过一个<code>beanName</code>就可以实现不同实现类的切换，而不是通过一堆if-else来判断。另外有的小伙伴可能会说，程序怎么知道用哪个<code>beanName</code>呢？其实这个也很简单，这个参数我们可以通过一些途径来拼接得到，比如使用一个<code>prefix</code>用来指定语言，<code>prefix</code>+<code>HelloService</code>就可以确定唯一的<code>beanName</code>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本来想着在一篇文章里面把扩展点都写一下的，但是实在太长了。后面差不多还有两篇。本系列中所有的<code>demo</code>可以在<code>github</code>获取，也欢迎小伙伴把能够想到的扩展点pr过来。</p>
<ul>
<li><a href="https://github.com/glmapper/glmapper-spring-extention" target="_blank" rel="noopener">glmapper-spring-extention</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/spring-extention-one/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
    </div>
    
      <div id="page-nav" class="pagination">
	<span class="page-number current">1</span>
      </div>
    
  </section>

</div>

</div>

</section>
</div>


    <!-- BEGIN PRE-FOOTER -->
    <div class="pre-footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN BOTTOM ABOUT BLOCK -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>About Us</h2>
            <p>Computer Lab is a software development and marketing company based in Brooklyn, New York. <br><br> Computer Lab was founded in 2015, and is focused on so on and so forth.</p>
          </div>
          <!-- END BOTTOM ABOUT BLOCK -->

          <!-- BEGIN BOTTOM CONTACTS -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>Contact</h2>
            <address class="margin-bottom-40">
              140 Metropolitan Avenue<br>
              5th Floor<br>
              Brooklyn, NY 11249<br>
              Phone: 716-472-4484<br>
              Email: <a href="mailto:ptsteadman@gmail.com">ptsteadman@gmail.com</a><br>
            </address>
          </div>
          <!-- END BOTTOM CONTACTS -->

	
          <!-- BEGIN TWITTER BLOCK --> 
          <div class="col-md-4 col-sm-6 pre-footer-col">

	  <a data-tweet-limit="1" class="twitter-timeline" href="https://twitter.com/computerlab_" data-widget-id="678830341331820544">Tweets by @computerlab_</a>

	  <script>!function(d,s,id){var
	  js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

          </div>
          <!-- END TWITTER BLOCK -->
	
        </div>
      </div>
    </div>
    <!-- END PRE-FOOTER -->

    <!-- BEGIN FOOTER -->
    <div class="footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN COPYRIGHT -->
          <div class="col-md-6 col-sm-6 padding-top-10">
                  &copy; 2020 glmapper<br>
 <a href="javascript:;">Privacy Policy</a> | <a href="javascript:;">Terms of Service</a>
          </div>
          <!-- END COPYRIGHT -->
	  <!-- BEGIN SOCIAL -->
<div class="col-md-6 col-sm-6">
  <ul class="social-footer list-unstyled list-inline pull-right">
    
      <li><a href="https://github.com/ptsteadman"><i class="fa fa-github"></i></a></li>
    
      <li><a href="https://twitter.com/ptsteadman"><i class="fa fa-twitter"></i></a></li>
    
      <li><a href="https://www.facebook.com/ptsteadman"><i class="fa fa-facebook"></i></a></li>
    
      <li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li>
    
      <li><a href="https://linkedin.com/in/ptsteadman"><i class="fa fa-linkedin"></i></a></li>
    
      <li><a href="http://stackoverflow.com/users/2480493/patrick-steadman"><i class="fa fa-stackoverflow"></i></a></li>
    
  </ul>  
</div>
<!-- END SOCIAL -->

        </div>
      </div>
    </div>
    <!-- END FOOTER -->

  <!-- BEGIN CORE PLUGINS (REQUIRED FOR ALL PAGES) -->
<!--[if lt IE 9]>
<script src="/metronic/assets/plugins/respond.min.js"></script>
<![endif]--> 
<script src="/metronic/assets/plugins/jquery.min.js"></script>
<script src="/metronic/assets/plugins/jquery-migrate.min.js"></script>
<script src="/metronic/assets/plugins/bootstrap/js/bootstrap.min.js"></script>
<script src="/metronic/assets/corporate/scripts/back-to-top.js"></script>
<script src="/metronic/assets/plugins/owl.carousel/owl.carousel.min.js"></script>
<script src="/metronic/assets/corporate/scripts/layout.js"></script>
<script src="/js/wow.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script type="text/javascript">
    jQuery(document).ready(function() {
        Layout.init();    
        Layout.initOWL();
        Layout.initTwitter();
        Layout.initFixHeaderWithPreHeader(); /* Switch On Header Fixing (only if you have pre-header) */
        Layout.initNavScrolling(); 
	new WOW().init();
    });
</script>
<!-- END CORE PLUGINS -->

<!-- BEGIN PAGE-SPECIFIC PLUGINS --> 







<!-- END PAGE-SPECIFIC PLUGINS --> 

<!-- BEGIN INTEGRATIONS -->





<!-- END INTEGRATIONS -->

</body>
</html>
