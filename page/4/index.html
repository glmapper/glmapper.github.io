<!DOCTYPE html>
<!--[if IE 8]> <html lang="en" class="ie8 no-js"> <![endif]-->
<!--[if IE 9]> <html lang="en" class="ie9 no-js"> <![endif]-->
<!--[if !IE]><!-->
<html lang="en">
<!--<![endif]-->
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>glmapper</title>

  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <meta name="description" content="从平凡的世界中全身而退">
<meta property="og:type" content="website">
<meta property="og:title" content="glmapper">
<meta property="og:url" content="http://www.glmapper.com/page/4/index.html">
<meta property="og:site_name" content="glmapper">
<meta property="og:description" content="从平凡的世界中全身而退">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="glmapper">
<meta name="twitter:description" content="从平凡的世界中全身而退">
  
    <link rel="alternative" href="/atom.xml" title="glmapper" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
    
  <meta content="{{ title }}" name="description">
  <meta content="{{ title }}" name="keywords">
  <meta content="{{ title }}" name="author">

  <link href="http://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700|PT+Sans+Narrow|Source+Sans+Pro:200,300,400,600,700,900&amp;subset=all" rel="stylesheet" type="text/css">

  <!-- Global styles START -->   
  <link rel="stylesheet" href="/metronic/assets/plugins/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/bootstrap/css/bootstrap.min.css">
  <!-- Global styles END --> 
   
  <!-- Page level plugin styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/animate.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/owl.carousel/assets/owl.carousel.css">
  <!-- Page level plugin styles END -->

  <!-- Theme styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/components.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/slider.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/portfolio.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style-responsive.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/themes/red.css">
  <link rel="stylesheet" href="/css/theme-styles.css">
  <!-- Theme styles END -->
</head>
</html>
<body class="corporate">
  <!-- BEGIN TOP BAR -->
<div class="pre-header">
  <div class="container">
    <div class="row">
      <!-- BEGIN TOP BAR LEFT PART -->
      <div class="col-md-6 col-sm-6 col-xs-9 additional-shop-info">
	<ul class="list-unstyled list-inline">
	  <li><i class="fa fa-phone"></i><span>716-472-4484</span></li>
	  <li><i class="fa fa-envelope-o"></i><span>ptsteadman@gmail.com</span></li>
	</ul>
      </div>
      <!-- END TOP BAR LEFT PART -->
      <!-- BEGIN TOP BAR MENU -->
      <div class="col-md-6 col-sm-6 col-xs-3 additional-nav">
	<ul class="list-unstyled list-inline pull-right">
	  <li><a href="/login">Log In</a></li>
	</ul>
      </div>
      <!-- END TOP BAR MENU -->
    </div>
  </div>        
</div>
<!-- END TOP BAR -->
<!-- BEGIN HEADER -->
<div class="header">
  <div class="container">
    <!--<a class="site-logo" href="/" id="logo">glmapper</a>-->

    <a class="site-logo" href="/">
      <img src="/metronic/assets/corporate/img/logos/logo-corp-red.png" alt="Metronic FrontEnd">
    </a>

    <a href="javascript:void(0);" class="mobi-toggler"><i class="fa fa-bars"></i></a>

    <!-- BEGIN NAVIGATION -->
    <div class="header-navigation pull-right font-transform-inherit">
      <ul>
	
	<li class="">
	  <a href="/">Home</a>
	</li>
	
	<li class="">
	  <a href="/projects/">Projects</a>
	</li>
	
	<li class="">
	  <a href="/archives/">Blog</a>
	</li>
	
	<li class="">
	  <a href="/contact/">Contact</a>
	</li>
	
	<li class="">
	  <a href="/about/">About</a>
	</li>
	
	<!-- BEGIN TOP SEARCH -->
	<li class="menu-search">
	  <span class="sep"></span>
	  <i class="fa fa-search search-btn"></i>
	  <div class="search-box">
	    <form action="#">
	      <div class="input-group">
		<input type="text" placeholder="Search" class="form-control st-default-search-input">
		<span class="input-group-btn">
		  <button class="btn btn-primary" type="submit">Search</button>
		</span>
	      </div>
	    </form>
	  </div> 
	</li>
	<!-- END TOP SEARCH -->
      </ul>
    </div>
    <!-- END NAVIGATION -->
  </div>
</div>
<!-- Header END -->

  
  <div class="container">
    <ul class="breadcrumb">
      <li class="active">Home</li>
    </ul>
  <div id="main">
    <div class="row">

<div class="col-xs-12 blog-posts">


  <section class="archives-wrap">
    <div class="archives">
      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2019/08/19/base-java-generics/">聊一聊-JAVA 泛型中的通配符 T，E，K，V，？</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2019-08-19T07:20:35.000Z" itemprop="datePublished">2019/08/19</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2019/08/19/base-java-generics/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/java/" title="java">java</a>,
  
    <a href="/tags/泛型/" title="泛型">泛型</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许开发者在编译时检测到非法的类型。</p>
<p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<h2 id="泛型带来的好处"><a href="#泛型带来的好处" class="headerlink" title="泛型带来的好处"></a>泛型带来的好处</h2><p>在没有泛型的情况的下，通过对类型 Object 的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是本身就是一个安全隐患。</p>
<p>那么泛型的好处就是在编译的时候能够检查类型安全，并且所有的强制转换都是自动和隐式的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperGeneric</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">this</span>.t = t; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 不指定类型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noSpecifyType</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GlmapperGeneric glmapperGeneric = <span class="keyword">new</span> GlmapperGeneric();</span><br><span class="line">    glmapperGeneric.set(<span class="string">"test"</span>);</span><br><span class="line">    <span class="comment">// 需要强制类型转换</span></span><br><span class="line">    String test = (String) glmapperGeneric.get();</span><br><span class="line">    System.out.println(test);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 指定类型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specifyType</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GlmapperGeneric&lt;String&gt; glmapperGeneric = <span class="keyword">new</span> GlmapperGeneric();</span><br><span class="line">    glmapperGeneric.set(<span class="string">"test"</span>);</span><br><span class="line">    <span class="comment">// 不需要强制类型转换</span></span><br><span class="line">    String test = glmapperGeneric.get();</span><br><span class="line">    System.out.println(test);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码中的 specifyType 方法中 省去了强制转换，可以在编译时候检查类型安全，可以用在类，方法，接口上。</p>
<h2 id="泛型中通配符"><a href="#泛型中通配符" class="headerlink" title="泛型中通配符"></a>泛型中通配符</h2><p>我们在定义泛型类，泛型方法，泛型接口的时候经常会碰见很多不同的通配符，比如 T，E，K，V 等等，这些通配符又都是什么意思呢？</p>
<h3 id="常用的-T，E，K，V，？"><a href="#常用的-T，E，K，V，？" class="headerlink" title="常用的 T，E，K，V，？"></a>常用的 T，E，K，V，？</h3><p>本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。<strong>通常情况下，T，E，K，V，？ 是这样约定的：</strong></p>
<ul>
<li>？ 表示不确定的 java 类型</li>
<li>T (type) 表示具体的一个java类型</li>
<li>K V (key value) 分别代表java键值中的Key Value</li>
<li>E (element) 代表Element</li>
</ul>
<h3 id="？-无界通配符"><a href="#？-无界通配符" class="headerlink" title="？ 无界通配符"></a>？ <strong>无界通配符</strong></h3><p>先从一个小例子看起，原文在 <a href="https://codeday.me/bug/20180113/116421.html" target="_blank" rel="noopener">这里</a> 。</p>
<p>我有一个父类 Animal 和几个子类，如狗、猫等，现在我需要一个动物的列表，我的第一个想法是像这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Animal&gt; listAnimals</span><br></pre></td></tr></table></figure>
<p>但是老板的想法确实这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Animal&gt; listAnimals</span><br></pre></td></tr></table></figure>
<p>为什么要使用通配符而不是简单的泛型呢？通配符其实在声明局部变量时是没有什么意义的，但是当你为一个方法声明一个参数时，它是非常重要的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countLegs</span> <span class="params">(List&lt;? extends Animal &gt; animals )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( Animal animal : animals )</span><br><span class="line">    &#123;</span><br><span class="line">        retVal += animal.countLegs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countLegs1</span> <span class="params">(List&lt; Animal &gt; animals )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( Animal animal : animals )</span><br><span class="line">    &#123;</span><br><span class="line">        retVal += animal.countLegs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Dog&gt; dogs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> 	<span class="comment">// 不会报错</span></span><br><span class="line">    countLegs( dogs );</span><br><span class="line">	<span class="comment">// 报错</span></span><br><span class="line">    countLegs1(dogs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用 countLegs1 时，就会飘红，提示的错误信息如下：</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/generics/generics-1.jpg" alt=""></p>
<p>所以，对于不确定或者不关心实际要操作的类型，可以使用无限制通配符（尖括号里一个问号，即 &lt;?&gt; ），表示可以持有任何类型。像 countLegs 方法中，限定了上届，但是不关心具体类型是什么，所以对于传入的 Animal 的所有子类都可以支持，并且不会报错。而 countLegs1 就不行。</p>
<h3 id="上界通配符-lt-extends-E-gt"><a href="#上界通配符-lt-extends-E-gt" class="headerlink" title="上界通配符 &lt; ? extends E&gt;"></a>上界通配符 &lt; ? extends E&gt;</h3><blockquote>
<p>上届：用 extends 关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。</p>
</blockquote>
<p>在类型参数中使用 extends 表示这个泛型中的参数必须是 E 或者 E 的子类，这样有两个好处：</p>
<ul>
<li>如果传入的类型不是 E 或者 E 的子类，编译不成功</li>
<li>泛型中可以使用 E 的方法，要不然还得强转成 E 才能使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;K extends A, E extends B&gt; <span class="function">E <span class="title">test</span><span class="params">(K arg1, E arg2)</span></span>&#123;</span><br><span class="line">    E result = arg2;</span><br><span class="line">    arg2.compareTo(arg1);</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>类型参数列表中如果有多个类型参数上限，用逗号分开</p>
</blockquote>
<h3 id="下界通配符-lt-super-E-gt"><a href="#下界通配符-lt-super-E-gt" class="headerlink" title="下界通配符 &lt; ? super E&gt;"></a>下界通配符 &lt; ? super E&gt;</h3><blockquote>
<p>下界: 用 super 进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object</p>
</blockquote>
<p>在类型参数中使用 super 表示这个泛型中的参数必须是 E 或者 E 的父类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dst, List&lt;T&gt; src)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T t : src) &#123;</span><br><span class="line">        dst.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Dog&gt; dogs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Animal&gt; animals = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> Test3().test(animals,dogs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Dog 是 Animal 的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dst 类型 “大于等于” src 的类型，这里的“大于等于”是指 dst 表示的范围比 src 要大，因此装得下 dst 的容器也就能装 src 。</p>
<h3 id="？-和-T-的区别"><a href="#？-和-T-的区别" class="headerlink" title="？ 和 T 的区别"></a>？ 和 T 的区别</h3><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/generics/generics-2.jpg" alt=""></p>
<p>？和 T 都表示不确定的类型，区别在于我们可以对 T 进行操作，但是对 ？ 不行，比如如下这种 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以</span></span><br><span class="line">T t = operate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以</span></span><br><span class="line">？ car = operate();</span><br></pre></td></tr></table></figure>
<p>简单总结下：</p>
<p>T 是一个 确定的 类型，通常用于泛型类和泛型方法的定义，？是一个 不确定 的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。</p>
<h4 id="区别1：通过-T-来-确保-泛型参数的一致性"><a href="#区别1：通过-T-来-确保-泛型参数的一致性" class="headerlink" title="区别1：通过 T 来 确保 泛型参数的一致性"></a>区别1：通过 T 来 确保 泛型参数的一致性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 T 来 确保 泛型参数的一致性</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="keyword">void</span></span><br><span class="line">test(List&lt;T&gt; dest, List&lt;T&gt; src)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span></span><br><span class="line">test(List&lt;? extends Number&gt; dest, List&lt;? extends Number&gt; src)</span><br></pre></td></tr></table></figure>
<p>像下面的代码中，约定的 T 是 Number 的子类才可以，但是申明时是用的 String ，所以就会飘红报错。</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/generics/generics-3.jpg" alt=""></p>
<p>不能保证两个 List 具有相同的元素类型的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GlmapperGeneric&lt;String&gt; glmapperGeneric = new GlmapperGeneric&lt;&gt;();</span><br><span class="line">List&lt;String&gt; dest = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Number&gt; src = new ArrayList&lt;&gt;();</span><br><span class="line">glmapperGeneric.testNon(dest,src);</span><br></pre></td></tr></table></figure>
<p>上面的代码在编译器并不会报错，但是当进入到 testNon 方法内部操作时（比如赋值），对于 dest 和 src 而言，就还是需要进行类型转换。</p>
<h4 id="区别2：类型参数可以多重限定而通配符不行"><a href="#区别2：类型参数可以多重限定而通配符不行" class="headerlink" title="区别2：类型参数可以多重限定而通配符不行"></a>区别2：类型参数可以多重限定而通配符不行</h4><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/generics/generics-4.jpg" alt=""></p>
<p>使用 &amp; 符号设定多重边界（Multi Bounds)，指定泛型类型 T 必须是 MultiLimitInterfaceA 和 MultiLimitInterfaceB 的共有子类型，此时变量 t 就具有了所有限定的方法和属性。对于通配符来说，因为它不是一个确定的类型，所以不能进行多重限定。</p>
<h4 id="区别3：通配符可以使用超类限定而类型参数不行"><a href="#区别3：通配符可以使用超类限定而类型参数不行" class="headerlink" title="区别3：通配符可以使用超类限定而类型参数不行"></a>区别3：通配符可以使用超类限定而类型参数不行</h4><p>类型参数 T 只具有 一种 类型限定方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T extends A</span><br></pre></td></tr></table></figure>
<p>但是通配符 ? 可以进行 两种限定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? extends A</span><br><span class="line">? <span class="keyword">super</span> A</span><br></pre></td></tr></table></figure>
<h2 id="Class-lt-T-gt-和-Class-lt-gt-区别"><a href="#Class-lt-T-gt-和-Class-lt-gt-区别" class="headerlink" title="Class&lt;T&gt; 和 Class&lt;?&gt; 区别"></a><code>Class&lt;T&gt;</code> 和 <code>Class&lt;?&gt;</code> 区别</h2><p>前面介绍了 ？ 和 T 的区别，那么对于，<code>Class&lt;T&gt;</code> 和 <code>&lt;Class&lt;?&gt;</code> 又有什么区别呢？<br><code>Class&lt;T&gt;</code> 和 <code>Class&lt;?&gt;</code></p>
<p>最常见的是在反射场景下的使用，这里以用一段发射的代码来说明下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过反射的方式生成  multiLimit </span></span><br><span class="line"><span class="comment">// 对象，这里比较明显的是，我们需要使用强制类型转换</span></span><br><span class="line">MultiLimit multiLimit = (MultiLimit)</span><br><span class="line">Class.forName(<span class="string">"com.glmapper.bridge.boot.generic.MultiLimit"</span>).newInstance();</span><br></pre></td></tr></table></figure>
<p>对于上述代码，在运行期，如果反射的类型不是 MultiLimit 类，那么一定会报 java.lang.ClassCastException 错误。</p>
<p>对于这种情况，则可以使用下面的代码来代替，使得在在编译期就能直接 检查到类型的问题：</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/generics/generics-5.jpg" alt=""></p>
<p><code>Class&lt;T&gt;</code> 在实例化的时候，T 要替换成具体类。<code>Class&lt;?&gt;</code> 它是个通配泛型，? 可以代表任何类型，所以主要用于声明时的限制情况。比如，我们可以这样做申明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; clazz;</span><br><span class="line"><span class="comment">// 不可以，因为 T 需要指定类型</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;T&gt; clazzT;</span><br></pre></td></tr></table></figure>
<p>所以当不知道定声明什么类型的 Class 的时候可以定义一 个Class&lt;?&gt;。</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/generics/generics-6.jpg" alt=""></p>
<p>那如果也想 <code>public Class&lt;T&gt; clazzT;</code> 这样的话，就必须让当前的类也指定 T ，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; clazz;</span><br><span class="line">    <span class="comment">// 不会报错</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;T&gt; clazzT;</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文零碎整理了下 JAVA 泛型中的一些点，不是很全，仅供参考。如果文中有不当的地方，欢迎指正。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.toutiao.com/a6694132392728199683" target="_blank" rel="noopener">JAVA泛型通配符T，E，K，V区别，网友回复：一文秒懂</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2019/08/19/base-java-generics/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2019/08/01/seiri-shell-record/">shell 脚本简单归纳和实践</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2019-08-01T14:14:25.000Z" itemprop="datePublished">2019/08/01</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2019/08/01/seiri-shell-record/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/linux/" title="linux">linux</a>,
  
    <a href="/tags/shell/" title="shell">shell</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<h2 id="if-条件-OPTION"><a href="#if-条件-OPTION" class="headerlink" title="if 条件 OPTION"></a>if 条件 OPTION</h2><table>
<thead>
<tr>
<th>OPTION</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>[-a file]</td>
<td>如果file存在则为真 ，也可以表示为 and: 条件与<br>if [ -z “condition1” -a -z “condition2” ]</td>
</tr>
<tr>
<td>[-b file]</td>
<td>如果file存在且是一个<strong>块</strong>特殊文件则为真</td>
</tr>
<tr>
<td>[-c file]</td>
<td>如果file存在且是一个<strong>字</strong>特殊文件则为真</td>
</tr>
<tr>
<td>[-d file]</td>
<td>如果 file 文件存在且是一个目录则为真，d前的!是逻辑非 <br>#表示目录不存在，则执行后面的 then 操作 <br>if [ ! -d lcd_path/par_date ]</td>
</tr>
<tr>
<td>[-e file]</td>
<td>如果 file文件存在则为真</td>
</tr>
<tr>
<td>[-f file]</td>
<td>如果 file 存在且是一个普通文件则为真</td>
</tr>
<tr>
<td>[-g file]</td>
<td>如果 file 存在且已经设置了SGID则为真（SUID 是 Set User ID, SGID 是 Set Group ID的意思）</td>
</tr>
<tr>
<td>[-h file]</td>
<td>如果 file 存在且是一个符号连接则为真</td>
</tr>
<tr>
<td>[-k file]</td>
<td>如果 file 存在且已经设置粘制位则为真</td>
</tr>
<tr>
<td>[-p file]</td>
<td>如果file存在且是一个名字管道（F如果O）则为真。管道是linux里面进程间通信的一种方式，<br>其他的还有像信号（signal）、信号量、消息队列、共享内存、套接字（socket）等</td>
</tr>
<tr>
<td>[-r file]</td>
<td>如果file存在且是可读的则为真</td>
</tr>
<tr>
<td>[-s file]</td>
<td>如果file存在且大小不为0则为真</td>
</tr>
<tr>
<td>[-t FD]</td>
<td>如果文件描述符FD打开且指向一个终端则为真</td>
</tr>
<tr>
<td>[-u file]</td>
<td>如果file存在且设置了SUID（set userID）则为真</td>
</tr>
<tr>
<td>[-w file</td>
<td>如果file存在且是可写的则为真</td>
</tr>
<tr>
<td>[-x file]</td>
<td>如果file存在且是可执行的则为真</td>
</tr>
<tr>
<td>[-O file]</td>
<td>如果file存在且属有效用户ID则为真</td>
</tr>
<tr>
<td>[-G file]</td>
<td>如果file存在且属有效用户组则为真</td>
</tr>
<tr>
<td>[-L file]</td>
<td>如果file存在且是一个符号连接则为真</td>
</tr>
<tr>
<td>[-N file]</td>
<td>如果file存在and has been mod如果ied since it was last read则为真</td>
</tr>
<tr>
<td>[-S file]</td>
<td>如果file存在且是一个套接字则为真</td>
</tr>
<tr>
<td>[-o optionname]</td>
<td>如果shell选项“optionname”开启则为真</td>
</tr>
<tr>
<td>[-z string]</td>
<td>“string”的长度为零则为真</td>
</tr>
<tr>
<td>[-n string] or [string]</td>
<td>“string”的长度为非零non-zero则为真</td>
</tr>
</tbody>
</table>
<p><a name="hMvnK"></a></p>
<h2 id="if-基本判断"><a href="#if-基本判断" class="headerlink" title="if 基本判断"></a>if 基本判断</h2><ul>
<li>[file1 –nt file2] 如果file1 has been changed more recently than file2或者file1 exists and file2 does not则为真 </li>
<li>[file1 –ot file2] 如果file1比file2要老，或者file2存在且file1不存在则为真 </li>
<li>[file1 –ef file2] 如果file1和file2指向相同的设备和节点号则为真 </li>
<li>[sting1==string2] 如果2个字符串相同。“=”may be used instead of “==”for strict posix compliance则为真 </li>
<li>[string1!=string2] 如果字符串不相等则为真 </li>
<li>[string1&lt;string2] 如果“string1”sorts before“string2”lexicographically in the current locale则为真 </li>
<li>[arg1 OP arg2]  “OP”is one of –eq,-ne,-lt,-le,-gt or –ge</li>
</ul>
<h2 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h2><ul>
<li><strong># 号截取，删除左边字符，保留右边字符。 （非贪婪匹配）</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var=http://www.glmapper.com</span><br><span class="line"><span class="comment"># # 号是运算符，*/ 表示从左边开始删除第一个 / 号及左边的所有字符,即删除 http://</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var#*//&#125;</span></span><br><span class="line"><span class="comment">#结果 www.glmapper.com</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>## 号截取，删除左边字符，保留右边字符。</strong>（贪婪匹配）<em>**</em></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var=http://www.glmapper.com</span><br><span class="line"><span class="comment"># ##*/ 表示从左边开始删除最后（最右边）一个 / 号及左边的所有字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var##*//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果 www.glmapper.com</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>%号截取，删除右边字符，保留左边字符 </strong>（非贪婪匹配）<em>**</em></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var=http://www.glmapper.com</span><br><span class="line"><span class="comment"># %/* 表示从右边开始，删除第一个 / 号及右边的字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var%/*&#125;</span></span><br><span class="line"><span class="comment"># 结果是：http:/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>%% 号截取，删除右边字符，保留左边字符  </strong>（贪婪匹配）<em>**</em></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var=http://www.glmapper.com</span><br><span class="line"><span class="comment"># %%/* 表示从右边开始，删除最后（最左边）一个 / 号及右边的字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var%%/*&#125;</span></span><br><span class="line"><span class="comment"># 结果 ：http:</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>从左边第几个字符开始，及字符的个数</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var=http://www.glmapper.com</span><br><span class="line"><span class="comment"># 其中的 0 表示左边第一个字符开始，5 表示字符的总个数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:0:5&#125;</span></span><br><span class="line"><span class="comment"># 结果 http:</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>从左边第几个字符开始，一直到结束</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var=http://www.glmapper.com</span><br><span class="line"><span class="comment"># 其中的 7 表示左边第8个字符开始，一直到结束。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:7&#125;</span></span><br><span class="line"><span class="comment"># 结果 www.glmapper.com</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>从右边第几个字符开始，及字符的个数</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var=http://www.glmapper.com</span><br><span class="line"><span class="comment"># 其中的 0-3 表示右边算起第3个字符开始，3 表示字符的个数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:0-3:3&#125;</span></span><br><span class="line"><span class="comment"># 结果 com</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>从右边第几个字符开始，一直到结束</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var=http://www.glmapper.com</span><br><span class="line"><span class="comment"># 表示从右边第 3 个字符开始，一直到结束</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:0-3&#125;</span></span><br><span class="line"><span class="comment"># 结果 com</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>左边的第一个字符是用 0 表示，右边的第一个字符用 0-1 表示</p>
</blockquote>
<p><a name="j4jqy"></a></p>
<h2 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h2><p><a name="N5taV"></a></p>
<h3 id="basename-命令简介"><a href="#basename-命令简介" class="headerlink" title="basename 命令简介"></a>basename 命令简介</h3><p>去除文件名的目录部分和后缀部分。basename 命令读取 String 参数，删除以 /(斜杠) 结尾的前缀以及任何指定的 Suffix 参数，并将剩余的基本文件名称写至标准输出。basename 和 dirname 命令通常用于 shell 脚本中的命令<strong>替换来指定和指定的输入文件名称有所差异的输出文件名称。</strong><br>**<br>基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">basename NAME [SUFFIX]</span><br><span class="line">basename OPTION</span><br></pre></td></tr></table></figure>
<p><a name="rCZMr"></a></p>
<h3 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">basename /usr/bin/sort</span><br><span class="line"><span class="comment"># 返回 sort</span></span><br><span class="line"></span><br><span class="line">basename /usr/bin/sort/glmapper.txt</span><br><span class="line"><span class="comment"># 返回 glmapper.txt</span></span><br></pre></td></tr></table></figure>
<p><a name="pjCcq"></a></p>
<h3 id="创建基本文件名称的规则"><a href="#创建基本文件名称的规则" class="headerlink" title="创建基本文件名称的规则"></a>创建基本文件名称的规则</h3><ul>
<li>如果 String 参数是 //(双斜杠) 或如果 String 参数包含的都是斜杠字符，则将字符串更改为单个 /(斜杠)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">basename //usr//bin//sort//glmapper.txt</span><br><span class="line"><span class="comment"># 返回 glmapper.txt</span></span><br><span class="line"></span><br><span class="line">basename ////</span><br><span class="line"><span class="comment"># 返回 /</span></span><br></pre></td></tr></table></figure>
<ul>
<li>从指定字符串除去任何拖尾的 / 字符。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">basename /usr/bin/sort/</span><br><span class="line"><span class="comment"># 返回 sort</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果在 String 参数中剩余任何 / 字符，则除去字符串的前缀直到（包含）最后一个 / 字符。</li>
<li>如果指定 Suffix 参数，且它和字符串中的剩余的字符相同，则不修改此字符串</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">basename /usr/bin/sort/glmapper.txt glmapper.txt </span><br><span class="line"><span class="comment"># 返回glmapper.txt </span></span><br><span class="line"></span><br><span class="line">basename /usr/bin/sort/glmapper.txt .txt </span><br><span class="line"><span class="comment"># 返回 glmapper</span></span><br></pre></td></tr></table></figure>
<p><a name="EBlrQ"></a></p>
<h2 id="shell-查看当前目录下文件的个数"><a href="#shell-查看当前目录下文件的个数" class="headerlink" title="shell 查看当前目录下文件的个数"></a>shell 查看当前目录下文件的个数</h2><p>测试准备，test 目录下有 test1、test2 两个文件夹和一个 1.txt 文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="built_in">test</span></span><br><span class="line">├── 1.txt</span><br><span class="line">├── test1</span><br><span class="line">│   └── test1_1.txt</span><br><span class="line">└── test2</span><br></pre></td></tr></table></figure>
<ul>
<li>查看当前目录下文件的个数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">test</span> ls -l | grep <span class="string">"^-"</span> | wc -l</span><br><span class="line">   1 <span class="comment"># 1.txt</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看当前目录下文件的个数，包括子目录里的</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">test</span> ls -lR| grep <span class="string">"^-"</span> | wc -l</span><br><span class="line">   2 <span class="comment"># 1.txt  test1_1.txt</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看某目录下文件夹（目录）的个数，包括子目录里的</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">test</span> ls -lR| grep <span class="string">"^d"</span> | wc -l</span><br><span class="line">	 2 <span class="comment"># test1 test2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>说明：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、ls -l ：长列表输出该目录下文件信息(注意这里的文件,不同于一般的文件,可能是目录、链接、设备文件等)</span><br><span class="line">2、grep <span class="string">"^-"</span> ：这里将长列表输出信息过滤一部分,只保留一般文件,如果只保留目录就是 ^d</span><br><span class="line">3、wc -l ： 统计输出信息的行数,已经过滤得只剩一般文件了,统计结果就是一般文件信息的行数,</span><br><span class="line">					又一行信息对应一个文件,也就是文件的个数</span><br></pre></td></tr></table></figure>
<p><a name="cOjDe"></a></p>
<h2 id="利用简单的命令组合实现配置文件的获取"><a href="#利用简单的命令组合实现配置文件的获取" class="headerlink" title="利用简单的命令组合实现配置文件的获取"></a>利用简单的命令组合实现配置文件的获取</h2><p>测试准备，在 1.txt 中 增加两个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name=glmapper</span><br><span class="line">age=26</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /Users/guolei/logs/<span class="built_in">test</span>/1.txt | sed <span class="string">'s|[[:blank:]]||g'</span> | grep <span class="string">"^name="</span> | cut -d= -f2</span><br><span class="line"><span class="comment"># 返回 glmapper </span></span><br><span class="line"></span><br><span class="line">cat /Users/guolei/logs/<span class="built_in">test</span>/1.txt | sed <span class="string">'s|[[:blank:]]||g'</span> | grep <span class="string">"^age="</span> | cut -d= -f2</span><br><span class="line"><span class="comment"># 返回 26</span></span><br></pre></td></tr></table></figure>
<p><a name="ok2lo"></a></p>
<h2 id="函数封装与返回"><a href="#函数封装与返回" class="headerlink" title="函数封装与返回"></a>函数封装与返回</h2><p>以上面的解析配置文件为例，将其封装成一个函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> load_param()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"># 接受的第一个参数是文件地址</span></span><br><span class="line">    <span class="built_in">local</span> properties_file=<span class="variable">$1</span></span><br><span class="line">    <span class="comment"># 接受的第二个参数是属性名</span></span><br><span class="line">    <span class="built_in">local</span> param=<span class="variable">$2</span></span><br><span class="line">    RESULT=`cat <span class="variable">$properties_file</span> | sed <span class="string">'s|[[:blank:]]||g'</span> | grep <span class="string">"^<span class="variable">$param</span>="</span> | cut -d= -f2`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用函数并且获取返回值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">load_param 1.txt name</span><br><span class="line">PROP_VAL=<span class="variable">$RESULT</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PROP_VAL</span></span><br><span class="line"><span class="comment"># 返回 glmapper</span></span><br></pre></td></tr></table></figure>
<p><a name="QhWTo"></a></p>
<h2 id="shell-实现日志文件的归档处理"><a href="#shell-实现日志文件的归档处理" class="headerlink" title="shell 实现日志文件的归档处理"></a>shell 实现日志文件的归档处理</h2><p>日志归档简单来说就是，每次希望启动，会将前一次程序运行产生的日志和本地运行产生的日志隔离开来，归档结果就是产生类似于如下的日志文件：</p>
<ul>
<li>stdout.log.20170909</li>
<li>stdout.log.20170709</li>
<li>stdout</li>
</ul>
<p>所以日志文件的归档在生产脚本中是必须要考虑的，否则就到导致每次产生的文件都会被写入同一份日志文件中。下面是实践过程中归纳的一个日志归档函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># archive log</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">archive_log</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> FILE_STDOUT_LOG=<span class="variable">$LOG_ROOT</span>/stdout.log</span><br><span class="line">    <span class="built_in">local</span> FILE_STDERR_LOG=<span class="variable">$LOG_ROOT</span>/stderr.log</span><br><span class="line">    <span class="keyword">if</span> [ ! -e <span class="variable">$LOG_ROOT</span> ] ; <span class="keyword">then</span></span><br><span class="line">        mkdir -p <span class="variable">$LOG_ROOT</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    NOW=`date +%Y%m%d.%H%M%S`</span><br><span class="line">    <span class="comment"># scroll SOFABoot STDOUT log</span></span><br><span class="line">    <span class="keyword">if</span> [ -e <span class="variable">$FILE_STDOUT_LOG</span> ] ; <span class="keyword">then</span></span><br><span class="line">        mv <span class="variable">$FILE_STDOUT_LOG</span> <span class="variable">$FILE_STDOUT_LOG</span>.<span class="variable">$NOW</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># scroll SOFABoot STDERR log</span></span><br><span class="line">    <span class="keyword">if</span> [ -e <span class="variable">$FILE_STDERR_LOG</span> ] ; <span class="keyword">then</span></span><br><span class="line">        mv <span class="variable">$FILE_STDERR_LOG</span> <span class="variable">$FILE_STDERR_LOG</span>.<span class="variable">$NOW</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    FILE_STDOUT_LOG_GLOBAL=<span class="variable">$FILE_STDOUT_LOG</span>;</span><br><span class="line">    FILE_STDERR_LOG_GLOBAL=<span class="variable">$FILE_STDERR_LOG</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="ctqA0"></a></p>
<h2 id="一个简单的-SOFABoot-启动脚本"><a href="#一个简单的-SOFABoot-启动脚本" class="headerlink" title="一个简单的 SOFABoot 启动脚本"></a>一个简单的 SOFABoot 启动脚本</h2><p>deploy.sh  简单的启动脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LOG_ROOT= <span class="variable">$1</span>;</span><br><span class="line">APP_PATH= <span class="variable">$2</span>;</span><br><span class="line"><span class="comment"># 检查 JAVA_HOME</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$JAVA_HOME</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"JAVA_HOME not set, exit"</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 使用前面的那个日志归档函数</span></span><br><span class="line">archive_log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 java 程序</span></span><br><span class="line">java -jar <span class="variable">$APP_PATH</span> &gt;&gt; <span class="variable">$FILE_STDOUT_LOG_GLOBAL</span> 2&gt;&gt; <span class="variable">$FILE_STDOUT_LOG_GLOBAL</span> &amp;</span><br></pre></td></tr></table></figure>
<p>运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh deploy.sh ./logs app.jar</span><br></pre></td></tr></table></figure>
<p><a name="B97pL"></a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文记录日常中常遇到的 shell 命令，基础知识部分零碎的参考了网上一些同学的博客，在此做了归纳。也欢迎大家指正。如果你有比较骚气的操作，也欢迎评论席留言，我会验证后更新到文章中来。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2019/08/01/seiri-shell-record/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2019/07/23/maven-debug/">一个 maven 插件打包问题的排查</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2019-07-23T11:12:48.000Z" itemprop="datePublished">2019/07/23</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2019/07/23/maven-debug/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/java/" title="java">java</a>,
  
    <a href="/tags/maven/" title="maven">maven</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>最近研究 <a href="https://github.com/sofastack/sofa-ark" target="_blank" rel="noopener">sofa-ark</a> 的插件机制时，发现当执行完 <code>maven clean install -DskipTests</code> 时，打在 target 目录下的 <code>xxx.jar</code> 与安装到本地仓库的 <code>xxx.jar</code> 大小不一致。</p>
<ul>
<li><p>target 目录下的插件大小<br>  <img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-one.jpg" alt=""></p>
</li>
<li><p>.m2 下的插件大小</p>
<p>  <img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-two.jpg" alt=""></p>
</li>
</ul>
<p>其实一开始看到这种现象也是懵逼，同一个工程，同一次命令执行，但是得到的两个 jar 包大小差距巨大。那么对于这种问题，我想到的有两点：</p>
<ul>
<li>debug 打包插件执行过程</li>
<li>了解 maven 插件的生命周期</li>
</ul>
<h2 id="debug-打包插件执行过程"><a href="#debug-打包插件执行过程" class="headerlink" title="debug 打包插件执行过程"></a>debug 打包插件执行过程</h2><p>这里需要借助 IDEA 中的远程 debug 能力来完成。目前有两个工程，一个是我们的主工程，工程名为上面截图中的 mq-client-ark-plugin ，另一个是打包插件的源码工程，如下图所示：</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-three.jpg" alt=""></p>
<p>那么下面就一步一步来完成远程 <code>debug</code> 的配置。</p>
<h3 id="1、使用-mvnDebug-命令开启-debug-模式"><a href="#1、使用-mvnDebug-命令开启-debug-模式" class="headerlink" title="1、使用 mvnDebug 命令开启 debug 模式"></a>1、使用 mvnDebug 命令开启 debug 模式</h3><p>在主工程 <code>mq-client-ark-plugin</code> 的根目录下执行  <code>mvnDebug install</code>（当然除了 <code>install</code> 之外，也可以是 <code>compile</code>、<code>package</code>、<code>test</code>、<code>deploy</code> 等）。</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-four.jpg" alt=""></p>
<p>当执行完 <code>mvnDebug install</code> 后，可以看到这个阻塞监听 8000 端口了。</p>
<h3 id="2、源码工程配置远程-debug"><a href="#2、源码工程配置远程-debug" class="headerlink" title="2、源码工程配置远程 debug"></a>2、源码工程配置远程 debug</h3><p>在 <code>idea</code> 主界面找下下图的工具菜单，选择 <code>Edit Configurations...</code><br><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-five.jpg" alt=""><br>打开配置面板之后，左上角 <code>+</code> 选择 <code>Remote</code><br><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-six.jpg" alt=""><br>填写相关远程 debug 参数</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-seven.jpg" alt=""></p>
<ul>
<li><code>Host</code> : 远程目标主机地址，因为之前 主工程也是本地启动的，所以这里就是 <code>localhost</code></li>
<li><code>Port</code> : 远程目标主机开启的远程 <code>debug</code> 端口</li>
<li>开启远程 <code>debug</code> 参数：<code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000</code></li>
</ul>
<p>配置完成之后，执行 <code>debug</code> ，可以看下已经连接到了目标机器：</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-eight.jpg" alt=""></p>
<p>在来看主工程这里，在源码工程没有执行上面的 <code>debug</code> 按钮之前，一直都是阻塞的，执行之后 <code>maven</code> 执行的生命周期开始了:<br><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-nine.jpg" alt=""></p>
<p>如上图，因为在源码工程中打了断点，所以当执行到 <code>sofa-ark-maven-plugin</code> 插件时阻塞了。</p>
<h2 id="从-maven-执行的生命周期找出问题根源"><a href="#从-maven-执行的生命周期找出问题根源" class="headerlink" title="从 maven 执行的生命周期找出问题根源"></a>从 maven 执行的生命周期找出问题根源</h2><p>上面已经搞定了对目标插件源码的 <code>debug</code> 模式的开启，那么下面就是对插件代码进行 <code>debug</code> 操作。节省篇幅，这里直接将断点放在目标代码行位置：</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-ten.jpg" alt=""></p>
<p>分析这段代码</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-11.jpg" alt=""></p>
<ul>
<li>1、获取到项目的 <code>Artifact</code> ,此时 <code>Artifact</code> 的 <code>file</code> 为：<br><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-12.jpg" alt=""></li>
<li>2、重新设置的 <code>File</code></li>
<li>3、重新设置了 <code>artifact</code></li>
</ul>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-13.jpg" alt=""></p>
<p>如果单从上面 <code>debug</code> 来看，其实很难解释开篇的那个问题。那么这里在回过头来看下 主工程的 <code>maven</code> 执行日志：</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/maven-pack/maven-pack-14.jpg" alt=""></p>
<p>如上图中圈红的部分，代表 <code>maven install</code> 所经历的所有阶段。可以看到 <code>sofa-ark-plugin-maven-plugin</code> 是在  <code>maven-install-plugin</code> 后面，那这意味着什么呢？</p>
<p><strong>我们知道在 target 目录下得到的 xxx.jar 是打包阶段的产物，而 .m2 下面的是 install 的产物。</strong></p>
<blockquote>
<p>当然这里没有涉及到 <code>deploy</code> ，<code>deploy</code> 是 <code>install</code> 之后的操作，比如发布到远程仓库。</p>
</blockquote>
<p>现在再来看，因为 <code>sofa-ark-plugin-maven-plugin</code> 在执行 <code>install</code> 插件之前将 目标文件给替换了，所以导致打包生成的 <code>target</code> 目录下的 <code>xxx.jar</code> 和 安装到本地仓库的 <code>xxx.jar</code> 不一致。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文记录了日常的一个问题排查过程，包括两个小点，一个是如何去 debug maven 的插件，另外一个是简单了解下 maven 打包的生命周期。</p>
<blockquote>
<p>关于 maven 打包的生命周期的代码没有具体研究过，不过这里可以大概猜测下，就是 maven 在执行命令时，有个类似于中央控制器的东西，通过解析 maven 命令得到一个 LifeCycle 或者 一个 Pipeline （LifeCycle 或者 Pipeline 实际上就是组装了一系列的插件）。然后 LifeCycle 或者 Pipeline 启动执行，遍历插件，依次执行插件的 execute 方法。</p>
</blockquote>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2019/07/23/maven-debug/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2019/06/30/topic-jar-manifest-intro/">聊一聊 JAR 文件和 MANIFEST.MF</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2019-06-30T01:54:03.000Z" itemprop="datePublished">2019/06/30</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2019/06/30/topic-jar-manifest-intro/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/java/" title="java">java</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>在 JAVA 语言这个圈子里面摸爬滚打，除了对于语言层面和框架层面的学习之外，有一些东西它一直存在，但是确没有对它们有足够的重视，因为都觉得它是理所当然，比如 JAR 是个什么？</p>
<p>提到 JAR，最先可能想到的就是依赖，比如 fastjson.jar ，它可以作为依赖在项目中来引用，但是不能通过 java -jar 来执行，这种就是非可执行的 JAR。另外一种，比如我们项目打包之后生成的 JAR （当然也可能是 war），我们可以通过 java -jar 来运行程序，我们把它称之为可执行的 JAR。</p>
<p>JAR 作用大体可以分为以下几种：</p>
<ul>
<li>用于发布和使用类库</li>
<li>作为应用程序和扩展的构建单元</li>
<li>作为组件、applet 或者插件程序的部署单位</li>
<li>用于打包与组件相关联的辅助资源</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>JAR 文件是一种归档文件，以 ZIP 格式构建，以 .jar 为文件扩展名。用户可以使用 JDK 自带的 jar 命令创建或提取 JAR 文件。也可以使用其他 zip 压缩工具，不过压缩时 zip 文件头里的条目顺序很重要，因为 MANIFEST 文件常需放在首位。JAR 文件内的文件名是 Unicode 文本。</p>
<p>JAR 文件（Java 归档，英语：Java Archive）是一种软件包文件格式，通常用于聚合大量的 Java 类文件、相关的元数据和资源（文本、图片等）文件到一个文件，以便分发 Java 平台应用软件或库。</p>
<blockquote>
<p>以上来自维基百科 </p>
</blockquote>
<p>JAR 文件格式提供了许多优势和功能，其中很多是传统的压缩格式如 ZIP 或者 TAR 所没有提供的。它们包括：</p>
<ul>
<li>安全性：可以对 JAR 文件内容加上数字化签名。这样，能够识别签名的工具就可以有选择地为您授予软件安全特权，这是其他文件做不到的，它还可以检测代码是否被篡改过。</li>
<li>减少下载时间：如果一个 applet 捆绑到一个 JAR 文件中，那么浏览器就可以在一个 HTTP 事务中下载这个 applet 的类文件和相关的资源，而不是对每一个文件打开一个新连接。</li>
<li>压缩：JAR 格式允许您压缩文件以提高存储效率。</li>
<li>传输平台扩展。Java 扩展框架 (Java Extensions Framework) 提供了向 Java 核心平台添加功能的方法，这些扩展是用 JAR 文件打包的 (Java 3D 和 JavaMail 就是由 Sun 开发的扩展例子 )。</li>
<li>包密封：存储在 JAR 文件中的包可以选择进行 密封，以增强版本一致性和安全性。密封一个包意味着包中的所有类都必须在同一 JAR 文件中找到。</li>
<li>包版本控制：一个 JAR 文件可以包含有关它所包含的文件的数据，如厂商和版本信息。</li>
<li>可移植性：处理 JAR 文件的机制是 Java 平台核心 API 的标准部分。</li>
</ul>
<h2 id="JAR-文件格式"><a href="#JAR-文件格式" class="headerlink" title="JAR 文件格式"></a>JAR 文件格式</h2><p>这里分别给出两个 JAR 的解压之后的示例</p>
<h3 id="普通的-JAR-解压之后的文件目录"><a href="#普通的-JAR-解压之后的文件目录" class="headerlink" title="普通的 JAR 解压之后的文件目录"></a>普通的 JAR 解压之后的文件目录</h3><p>以 fastjson 为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── META-INF</span><br><span class="line">│   ├── LICENSE.txt</span><br><span class="line">│   ├── MANIFEST.MF</span><br><span class="line">│   ├── NOTICE.txt</span><br><span class="line">│   ├── maven</span><br><span class="line">│   │   └── com.alibaba</span><br><span class="line">│   │       └── fastjson</span><br><span class="line">│   │           ├── pom.properties</span><br><span class="line">│   │           └── pom.xml</span><br><span class="line">│   └── services</span><br><span class="line">│       ├── javax.ws.rs.ext.MessageBodyReader</span><br><span class="line">│       ├── javax.ws.rs.ext.MessageBodyWriter</span><br><span class="line">│       ├── javax.ws.rs.ext.Providers</span><br><span class="line">│       └── org.glassfish.jersey.internal.spi.AutoDiscoverable</span><br><span class="line">└── com</span><br><span class="line">    └── alibaba</span><br><span class="line">        └── fastjson</span><br><span class="line">            ├── JSON.class</span><br><span class="line">            ├── JSONArray.class</span><br><span class="line">            ├── JSONAware.class</span><br><span class="line">            ├── JSONException.class</span><br><span class="line">            ├── JSONObject.class</span><br><span class="line">            ....省略</span><br></pre></td></tr></table></figure></p>
<h3 id="可执行的-jar-以-SpringBoot-的-FAT-JAR-为例）"><a href="#可执行的-jar-以-SpringBoot-的-FAT-JAR-为例）" class="headerlink" title="可执行的 jar (以 SpringBoot 的 FAT JAR 为例）"></a>可执行的 jar (以 SpringBoot 的 FAT JAR 为例）</h3><p>这个 jar 是从 start.spring.io 上下载下来的一个最简单的 demo 打包来的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">├── BOOT-INF</span><br><span class="line">│   ├── classes</span><br><span class="line">│   │   ├── application.properties</span><br><span class="line">│   │   └── com</span><br><span class="line">│   │       └── example   # 应用的.class 文件目录</span><br><span class="line">│   │           └── demo</span><br><span class="line">│   │               └── DemoApplication.class</span><br><span class="line">│   └── lib # 这里存放的是应用的 Maven 依赖的jar包文件</span><br><span class="line">│       ├── javax.annotation-api-1.3.2.jar</span><br><span class="line">│       ├── jul-to-slf4j-1.7.26.jar</span><br><span class="line">│       ├── log4j-api-2.11.2.jar</span><br><span class="line">│       ├── log4j-to-slf4j-2.11.2.jar</span><br><span class="line">│       ├── logback-classic-1.2.3.jar</span><br><span class="line">│       ├── logback-core-1.2.3.jar</span><br><span class="line">│       ├── slf4j-api-1.7.26.jar</span><br><span class="line">│       ├── snakeyaml-1.23.jar</span><br><span class="line">│       ├── spring-aop-5.1.8.RELEASE.jar</span><br><span class="line">│       ├── spring-beans-5.1.8.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-2.1.6.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-autoconfigure-2.1.6.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-2.1.6.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-logging-2.1.6.RELEASE.jar</span><br><span class="line">│       ├── spring-context-5.1.8.RELEASE.jar</span><br><span class="line">│       ├── spring-core-5.1.8.RELEASE.jar</span><br><span class="line">│       ├── spring-expression-5.1.8.RELEASE.jar</span><br><span class="line">│       └── spring-jcl-5.1.8.RELEASE.jar</span><br><span class="line">├── META-INF</span><br><span class="line">│   ├── MANIFEST.MF</span><br><span class="line">│   └── maven</span><br><span class="line">│       └── com.example</span><br><span class="line">│           └── demo</span><br><span class="line">│               ├── pom.properties</span><br><span class="line">│               └── pom.xml</span><br><span class="line">└── org</span><br><span class="line">    └── springframework</span><br><span class="line">        └── boot</span><br><span class="line">            └── loader #存放的是 Spring boot loader 的 class 文件</span><br><span class="line">                ├── ExecutableArchiveLauncher.class</span><br><span class="line">                ├── JarLauncher.class</span><br><span class="line">                ├── LaunchedURLClassLoader$UseFastConnectionExceptionsEnumeration.class</span><br><span class="line">                ├── LaunchedURLClassLoader.class</span><br><span class="line">                ├── Launcher.class</span><br><span class="line">                ├── MainMethodRunner.class</span><br><span class="line">                ├── PropertiesLauncher$1.class</span><br><span class="line">                ├── PropertiesLauncher$ArchiveEntryFilter.class</span><br><span class="line">                ├── PropertiesLauncher$PrefixMatchingArchiveFilter.class</span><br><span class="line">                ├── PropertiesLauncher.class</span><br><span class="line">                ├── WarLauncher.class</span><br><span class="line">                ├── archive</span><br><span class="line">                │   ├── Archive$Entry.class</span><br><span class="line">                │   ├── ...</span><br><span class="line">                ├── data</span><br><span class="line">                │   ├── RandomAccessData.class</span><br><span class="line">                │   ├── ...</span><br><span class="line">                ├── jar</span><br><span class="line">                │   ├── AsciiBytes.class</span><br><span class="line">                │   ├── ...</span><br><span class="line">                └── util</span><br><span class="line">                    └── SystemPropertyUtils.class</span><br></pre></td></tr></table></figure>
<h2 id="META-INF"><a href="#META-INF" class="headerlink" title="META-INF"></a>META-INF</h2><p>大多数 JAR 文件包含一个 META-INF 目录，它用于存储包和扩展的配置数据，如安全性和版本信息。Java 2 平台（标准版【J2SE】）识别并解释 META-INF 目录中的下述文件和目录，以便配置应用程序、扩展和类装载器：</p>
<ul>
<li>MANIFEST.MF：这个 manifest 文件定义了与扩展和包相关的数据。</li>
<li>通过 MAVEN 插件打包进来的文件比如：<ul>
<li>maven</li>
<li>services ： 存储所有服务提供程序配置文件</li>
</ul>
</li>
<li>其他的还有一些不常看到的：<ul>
<li>INDEX.LIST ：这个文件由 jar工具的新选项 -i生成，它包含在应用程序或者扩展中定义的包的位置信息。它是 JarIndex 实现的一部分，并由类装载器用于加速类装载过程。 </li>
<li>.SF：这是 JAR 文件的签名文件</li>
<li>.DSA：与签名文件相关联的签名程序块文件，它存储了用于签名 JAR 文件的公共签名。</li>
<li>LICENSE.txt ：证书信息</li>
<li>NOTICE.txt ： 公告信息</li>
</ul>
</li>
</ul>
<h2 id="可执行的-JAR"><a href="#可执行的-JAR" class="headerlink" title="可执行的 JAR"></a>可执行的 JAR</h2><p> 可以执行的 JAR 与 普通的 JAR 最直接的区别就是能否通过 java -jar 来执行。</p>
<blockquote>
<p>一个 可执行的 jar文件是一个自包含的 Java 应用程序，它存储在特别配置的 JAR 文件中，可以由 JVM 直接执行它而无需事先提取文件或者设置类路径。要运行存储在非可执行的 JAR 中的应用程序，必须将它加入到您的类路径中，并用名字调用应用程序的主类。但是使用可执行的 JAR 文件，我们可以不用提取它或者知道主要入口点就可以运行一个应用程序。可执行 JAR 有助于方便发布和执行 Java 应用程序</p>
</blockquote>
<p> 一个可执行的 JAR 必须通过 menifest 文件的头引用它所需要的所有其他从属 JAR。如果使用了 -jar选项，那么环境变量 CLASSPATH 和在命令行中指定的所有类路径都被 JVM 所忽略。</p>
<h3 id="MANIFEST-MF-文件"><a href="#MANIFEST-MF-文件" class="headerlink" title="MANIFEST.MF 文件"></a>MANIFEST.MF 文件</h3><p>当我们用 JAR 命令打完包后，会在根目录下面创建 META-INF 目录，该目录下面会有一些对该 JAR 包信息的描述，其中肯定会有一个 MANIFEST.MF 文件，该文件包含了该 JAR 包的版本、创建人和类搜索路径等信息。</p>
<ul>
<li><p>FASTJSON jar 中的 MANIFEST.MF 文件</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0              # 用来定义manifest文件的版本</span><br><span class="line">Archiver-Version: Plexus Archiver  # 详见 http://codehaus-plexus.github.io/plexus-archiver/</span><br><span class="line">Built-By: wenshao                  # 构建者</span><br><span class="line">Created-By: Apache Maven 3.5.0  #  # 声明该文件的生成者，一般该属性是由 jar 命令行工具生成的</span><br><span class="line">Build-Jdk: 1.8.0_162               # 基于构建的 JDK 版本</span><br></pre></td></tr></table></figure>
</li>
<li><p>SpringBoot demo 的 MANIFEST.MF 文件</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Implementation-Title: demo                     # 定义了扩展实现的标题</span><br><span class="line">Implementation-Version: 0.0.1-SNAPSHOT         # 定义扩展实现的版本</span><br><span class="line">Start-Class: com.example.demo.DemoApplication  # 启动类</span><br><span class="line">Spring-Boot-Classes: BOOT-INF/classes/         # 编译之后的 class 文件目录</span><br><span class="line">Spring-Boot-Lib: BOOT-INF/lib/                 # 当前工程依赖的 jar 包目录</span><br><span class="line">Build-Jdk-Spec: 1.8                            # 指定的 JDK 版本</span><br><span class="line">Spring-Boot-Version: 2.1.6.RELEASE             # SpringBoot 版本</span><br><span class="line">Created-By: Maven Archiver 3.4.0             </span><br><span class="line">Main-Class: org.springframework.boot.loader.JarLauncher  # Main 函数</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在 Java 平台中， MANIFEST 文件是 JAR 归档中所包含的特殊文件，MANIFEST 文件被用来定义扩展或文件打包相关数据。</p>
<p>MANIFEST 文件作为一个元数据文件，它包含了不同部分中的 k-v 对数据。</p>
<p>如果一个 JAR 文件被当作可执行文件，则其中的 MANIFEST 文件需要指出该程序的主类文件，如上面案例中的 SpringBoot demo 的那个 jar 中的MANIFEST 文件所示 </p>
<h3 id="MANIFEST-作用"><a href="#MANIFEST-作用" class="headerlink" title="MANIFEST 作用"></a>MANIFEST 作用</h3><p>从 MANIFEST 文件中提供的信息大概可以了解到其基本作用</p>
<ul>
<li>JAR 包基本信息描述</li>
<li>Main-Class 指定程序的入口，这样可以直接用java -jar xxx.jar来运行程序</li>
<li>Class-Path 指定jar包的依赖关系，class loader会依据这个路径来搜索class</li>
</ul>
<h3 id="获取-MANIFEST-MF"><a href="#获取-MANIFEST-MF" class="headerlink" title="获取 MANIFEST.MF"></a>获取 MANIFEST.MF</h3><p>JDK 中提供了可以获取 jar 包中 MANIFEST.MF 文件信息的工具，可以通过 java.util.jar 这个类库来获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JarFile jar = <span class="keyword">new</span> JarFile(<span class="keyword">new</span> File(<span class="string">"/Users/glmapper/Documents/test/demo/target/demo-0.0.1-SNAPSHOT.jar"</span>));</span><br><span class="line">Manifest manifest = jar.getManifest();</span><br><span class="line">Attributes mainAttributes = manifest.getMainAttributes();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Object, Object&gt; attrEntry : mainAttributes.entrySet())&#123;</span><br><span class="line">    System.out.println(<span class="string">"main\t"</span>+attrEntry.getKey()+<span class="string">":"</span>+attrEntry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;String, Attributes&gt; entries = manifest.getEntries();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, Attributes&gt; entry : entries.entrySet()) &#123;</span><br><span class="line">    Attributes values = entry.getValue();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; attrEntry : values.entrySet()) &#123;</span><br><span class="line">        System.out.println(attrEntry.getKey() + <span class="string">":"</span> + attrEntry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main	Implementation-Title:demo</span><br><span class="line">main	Implementation-Version:0.0.1-SNAPSHOT</span><br><span class="line">main	Start-Class:com.example.demo.DemoApplication</span><br><span class="line">main	Spring-Boot-Classes:BOOT-INF/classes/</span><br><span class="line">main	Spring-Boot-Lib:BOOT-INF/lib/</span><br><span class="line">main	Build-Jdk-Spec:1.8</span><br><span class="line">main	Spring-Boot-Version:2.1.6.RELEASE</span><br><span class="line">main	Created-By:Maven Archiver 3.4.0</span><br><span class="line">main	Manifest-Version:1.0</span><br><span class="line">main	Main-Class:org.springframework.boot.loader.JarLauncher</span><br></pre></td></tr></table></figure></p>
<h2 id="Jar-文件和-Manifest-在-java-中的定义"><a href="#Jar-文件和-Manifest-在-java-中的定义" class="headerlink" title="Jar 文件和 Manifest 在 java 中的定义"></a>Jar 文件和 Manifest 在 java 中的定义</h2><p>下面为 JarFile 的定义，从代码就可以看出，前面我们所介绍的 Jar 是以 ZIP 格式构建一种归档文件，因为它是 ZipFile 的子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JarFile</span> <span class="keyword">extends</span> <span class="title">ZipFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SoftReference&lt;Manifest&gt; manRef;</span><br><span class="line">    <span class="keyword">private</span> JarEntry manEntry;</span><br><span class="line">    <span class="keyword">private</span> JarVerifier jv;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> jvInitialized;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> verify;</span><br><span class="line">    <span class="comment">//指示是否存在Class-Path属性（仅当hasCheckedSpecialAttributes为true时才有效）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasClassPathAttribute;</span><br><span class="line">    <span class="comment">// 如果清单检查特殊属性，则为 true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> hasCheckedSpecialAttributes;</span><br><span class="line">    <span class="comment">// 在SharedSecrets中设置JavaUtilJarAccess</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SharedSecrets.setJavaUtilJarAccess(<span class="keyword">new</span> JavaUtilJarAccessImpl());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The JAR manifest file name.（JAR清单文件名）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MANIFEST_NAME = <span class="string">"META-INF/MANIFEST.MF"</span>;</span><br><span class="line">    <span class="comment">// 省略其他</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是 Manifest 类的定义，用来描述 JAR 的 清单文件。从其属性中也很好的观察到，其存储的就是 K-V 键值对数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manifest</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// manifest main attributes</span></span><br><span class="line">    <span class="keyword">private</span> Attributes attr = <span class="keyword">new</span> Attributes();</span><br><span class="line">    <span class="comment">// manifest entries</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Attributes&gt; entries = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 省略其他</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>JAR 格式远远超出了一种压缩格式，它有许多可以改进效率、安全性和组织 Java 应用程序的功能。因为这些功能已经建立在核心平台 – 包括编译器和类装载器 – 中了，所以开发人员可以利用 JAR 文件格式的能力简化和改进开发和部署过程。</p>
<h2 id="附：常见的-jar工具用法"><a href="#附：常见的-jar工具用法" class="headerlink" title="附：常见的 jar工具用法"></a>附：常见的 jar工具用法</h2><table>
<thead>
<tr>
<th style="text-align:left">功能</th>
<th style="text-align:left">命令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">用一个单独的文件创建一个 JAR 文件</td>
<td style="text-align:left">jar cf jar-file input-file…</td>
</tr>
<tr>
<td style="text-align:left">用一个目录创建一个 JAR 文件</td>
<td style="text-align:left">jar cf jar-file dir-name</td>
</tr>
<tr>
<td style="text-align:left">创建一个未压缩的 JAR 文件</td>
<td style="text-align:left">jar cf0 jar-file dir-name</td>
</tr>
<tr>
<td style="text-align:left">更新一个 JAR 文件</td>
<td style="text-align:left">jar uf jar-file input-file…</td>
</tr>
<tr>
<td style="text-align:left">查看一个 JAR 文件的内容</td>
<td style="text-align:left">jar tf jar-file</td>
</tr>
<tr>
<td style="text-align:left">提取一个 JAR 文件的内容</td>
<td style="text-align:left">jar xf jar-file</td>
</tr>
<tr>
<td style="text-align:left">从一个 JAR 文件中提取特定的文件</td>
<td style="text-align:left">jar xf jar-file archived-file…</td>
</tr>
<tr>
<td style="text-align:left">运行一个打包为可执行 JAR 文件的应用程序</td>
<td style="text-align:left">java -jar app.jar</td>
</tr>
</tbody>
</table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-jar/index.html" target="_blank" rel="noopener">JAR 文件揭密</a></li>
<li><a href="https://zh.wikipedia.org/wiki/JAR_(%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F" target="_blank" rel="noopener">JAR</a>)</li>
<li><a href="https://docs.oracle.com/javase/6/docs/technotes/guides/jar/jar.html" target="_blank" rel="noopener">JAR File Specification</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2019/06/30/topic-jar-manifest-intro/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2019/04/29/cas-several-qa/">并发编程-关于 CAS 的几个问题</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2019-04-29T02:25:57.000Z" itemprop="datePublished">2019/04/29</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2019/04/29/cas-several-qa/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/java/" title="java">java</a>,
  
    <a href="/tags/cas/" title="cas">cas</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<h2 id="CAS-相关基础知识"><a href="#CAS-相关基础知识" class="headerlink" title="CAS 相关基础知识"></a>CAS 相关基础知识</h2><p>CAS的全称是Compare And Swap ,即比较交换。CAS 中一般会设计到3个参数:</p>
<ul>
<li>内存值 V</li>
<li>旧的预期值A</li>
<li>要修改的新值B</li>
</ul>
<p>当且仅当预期值 A 和内存值 V 相同时，将内存值V修改为 B，否则什么都不做。</p>
<blockquote>
<p>这里关于 CPU 指令对于 CAS 的支持不深入研究,有兴趣的可以自行了解。</p>
</blockquote>
<h2 id="CAS-几个问题"><a href="#CAS-几个问题" class="headerlink" title="CAS 几个问题"></a>CAS 几个问题</h2><p>很多书籍和文章中都有提出它存在的几个问题：</p>
<ul>
<li>1、循环时间长开销很大</li>
<li>2、只能保证一个共享变量的原子操作</li>
<li>3、ABA 问题</li>
</ul>
<p>下面就这三个问题展开来聊一下。</p>
<h3 id="1、关于“循环时间长开销很大”的疑惑与验证"><a href="#1、关于“循环时间长开销很大”的疑惑与验证" class="headerlink" title="1、关于“循环时间长开销很大”的疑惑与验证"></a>1、关于“循环时间长开销很大”的疑惑与验证</h3><p>自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的开销。但是真的是这样吗？到底多大的并发量才造成 CAS 的自旋次数会增加呢？另外，对于当前的机器及JDK，在无锁，无CAS 的情况下，是否对于结果的影响是真的那么明显呢？对于这个问题，下面做了一个简单的测试，但是测试结果也只是针对在我本地环境下，各位看官可以拉一下代码，在自己电脑上 run 一下，把机器信息、JDK版本以及测试结果留言到评论区。</p>
<blockquote>
<p>本文案例可以这里获取：<a href="https://github.com/glmapper/glmapper-blog-samples/tree/master/glmapper-blog-sample-cas" target="_blank" rel="noopener">glmapper-blog-sample-cas</a></p>
</blockquote>
<p>这里我是用了一个很简单的案例，就是整数自增。使用了两种方式去测试的，一种是无锁，也不用 CAS 操作，另外一种是基于 CAS 的方式。（关于加锁的方式没有验证，有时间再补充吧~）</p>
<h4 id="计数器类"><a href="#计数器类" class="headerlink" title="计数器类"></a>计数器类</h4><p>计数器里面有两个方法，一种是CAS 自旋方式，一种是直接自增。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> AtomicInteger safeCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> unsafe = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 使用自旋的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">safeCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = safeCount.get();</span><br><span class="line">            <span class="keyword">boolean</span> success = safeCount.compareAndSet(i,++i);</span><br><span class="line">            <span class="keyword">if</span> (success)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 普通方式自增</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsafeCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        unsafe++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="模拟并发"><a href="#模拟并发" class="headerlink" title="模拟并发"></a>模拟并发</h4><p>这里我们模拟使用 1000 个线程，执行 30 次来看下结果，包括总耗时和结果的正确性。</p>
<ul>
<li><p>CAS 方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testSafe</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 实例化一个 Counter 计数器对象</span></span><br><span class="line">    Counter counter = <span class="keyword">new</span> Counter();</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(testCounts);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ;i &lt; testCounts;i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="comment">// 调用 safeCount 方法</span></span><br><span class="line">                counter. safeCount();</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    <span class="comment">// 结束时间</span></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    safeTotalCostTime += (end-start);</span><br><span class="line">    <span class="keyword">return</span> counter.safeCount.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>普通方式</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testUnSafe</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 实例化一个 Counter 计数器对象</span></span><br><span class="line">    Counter counter = <span class="keyword">new</span> Counter();</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(testCounts);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt; testCounts;i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">// 调用 unsafeCount 方法</span></span><br><span class="line">            counter.unsafeCount();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    <span class="comment">// 结束时间</span></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    unsafeTotalCostTime += (end-start);</span><br><span class="line">    <span class="keyword">return</span> counter.unsafe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>main 方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    // 执行 300 次</span><br><span class="line">    for (int i =0 ;i&lt; 300;i++)&#123;</span><br><span class="line">        // 普通方式</span><br><span class="line">        int unSafeResult = testUnSafe();</span><br><span class="line">        // cas 方式</span><br><span class="line">        int safeResult = testSafe();</span><br><span class="line">        // 结果验证，若果正确就将成功次数增加</span><br><span class="line">        if (unSafeResult == testCounts)&#123;</span><br><span class="line">            totalUnSafeCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 同上</span><br><span class="line">        if (safeResult == testCounts)&#123;</span><br><span class="line">            totalSafeCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;test count = &quot; + testCounts);</span><br><span class="line">    System.out.println(&quot;非安全计数器正确个数 = &quot; + totalUnSafeCount);</span><br><span class="line">    System.out.println(&quot;非安全计数器耗时 = &quot; + unsafeTotalCostTime);</span><br><span class="line">    System.out.println(&quot;安全计数器正确个数 = &quot; + totalSafeCount);</span><br><span class="line">    System.out.println(&quot;安全计数器耗时 = &quot; + safeTotalCostTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我的机器信息如下：</p>
<ul>
<li>MacBook Pro (Retina, 15-inch, Mid 2015)</li>
<li>处理器：2.2 GHz Intel Core i7</li>
<li>内存：16 GB 1600 MHz DDR3</li>
</ul>
<p>下面是一些测试数据。</p>
<h4 id="1000-线程数-300-次数"><a href="#1000-线程数-300-次数" class="headerlink" title="1000(线程数) * 300(次数)"></a>1000(线程数) * 300(次数)</h4><p>测试结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test count = 1000</span><br><span class="line">非安全计数器正确个数 = 300</span><br><span class="line">非安全计数器耗时 = 27193</span><br><span class="line">安全计数器正确个数 = 300</span><br><span class="line">安全计数器耗时 = 26337</span><br></pre></td></tr></table></figure></p>
<p>居然发现不使用 CAS 的方式居然比使用自旋 CAS 的耗时要高出将近 1s。另外一个意外的点，我尝试了好几次，不使用 CAS 的情况得到的结果正确率基本也是 4 个 9  以上的比率，极少数会出现计算结果错误的情况。</p>
<h4 id="3000-线程数-30-次数"><a href="#3000-线程数-30-次数" class="headerlink" title="3000(线程数) * 30(次数)"></a>3000(线程数) * 30(次数)</h4><p>测试结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test count = 3000</span><br><span class="line">非安全计数器正确个数 = 30</span><br><span class="line">非安全计数器耗时 = 7816</span><br><span class="line">安全计数器正确个数 = 30</span><br><span class="line">安全计数器耗时 = 8073</span><br></pre></td></tr></table></figure></p>
<p>这里看到在耗时上已经很接近了。这里需要考虑另外一个可能影响的点是，因为 testUnSafe 是 testSafe 之前执行的，“JVM 和 机器本身热身” 影响耗时虽然很小，但是也存在一定的影响。</p>
<h4 id="5000-线程数-30-次数"><a href="#5000-线程数-30-次数" class="headerlink" title="5000(线程数) * 30(次数)"></a>5000(线程数) * 30(次数)</h4><p>测试结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test count = 5000</span><br><span class="line">非安全计数器正确个数 = 30</span><br><span class="line">非安全计数器耗时 = 23213</span><br><span class="line">安全计数器正确个数 = 30</span><br><span class="line">安全计数器耗时 = 14161</span><br></pre></td></tr></table></figure></p>
<p>随着并发量的增加，这里奇怪的是，普通自增方式所消耗的时间要高于CAS方式消耗的时间将近 8-9s 。</p>
<p>当尝试 10000 次时，是的你没猜错，抛出了 OOM 。但是从执行的结果来看，并没有说随着并发量的增大，普通方式错误的概率会增加，也没有出现预想的 CAS 方式的耗时要比 普通模式耗时多。</p>
<blockquote>
<p>由于测试样本数据比较单一，对于测试结果没法做结论，欢迎大家将各自机器的结果提供出来，以供参考。另外就是，最近看到很多面试的同学，如果有被问道这个问题，还是需要谨慎考虑下。关于是否“打脸”还是“被打脸”还需要更多的测试结果。</p>
</blockquote>
<h3 id="CAS-到底是怎么操作的"><a href="#CAS-到底是怎么操作的" class="headerlink" title="CAS 到底是怎么操作的"></a>CAS 到底是怎么操作的</h3><ul>
<li>CPU 指令</li>
<li>Unsafe 类 </li>
</ul>
<h3 id="2、ABA-问题的简单复现"><a href="#2、ABA-问题的简单复现" class="headerlink" title="2、ABA 问题的简单复现"></a>2、ABA 问题的简单复现</h3><p>网上关于 CAS 讨论另外一个点就是 CAS 中的 ABA 问题，相信大多数同学在面试时如果被问到 CAS ，那么 ABA 问题也会被问到，然后接着就是怎么避免这个问题，是的套路就是这么一环扣一环的。</p>
<p>我相信 90% 以上的开发人员在实际的工程中是没有遇到过这个问题的，即使遇到过，在特定的情况下也是不会影响到计算结果。但是既然这个问题会被反复提到，那就一定有它导致 bug 的场景，找了一个案例供大家参考：<a href="https://blog.csdn.net/wufaliang003/article/details/78797203" target="_blank" rel="noopener">CAS下ABA问题及优化方案</a> 。</p>
<p>这里先不去考虑怎么去规避这个问题，我们想怎么去通过简单的模拟先来复现这个 ABA 问题。其实这个也很简单，如果你对线程交叉、顺序执行了解的话。</p>
<h3 id="如何实现多线程的交叉执行"><a href="#如何实现多线程的交叉执行" class="headerlink" title="如何实现多线程的交叉执行"></a>如何实现多线程的交叉执行</h3><p>这个点实际上也是一个在面试过程中很常见的一个基础问题，我在提供的代码中给了三种实现方式，有兴趣的同学可以拉代码看下。</p>
<p>下面以 lock 的方式来模拟下这个场景，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionAlternateTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计数器</span></span><br><span class="line">    <span class="keyword">public</span> AtomicInteger safeCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// lock</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// condition 1/2/3 用于三个线程触发执行的条件</span></span><br><span class="line">    Condition c1 = lock.newCondition();</span><br><span class="line">    Condition c2 = lock.newCondition();</span><br><span class="line">    Condition c3 = lock.newCondition();</span><br><span class="line">    <span class="comment">// 模拟并发执行</span></span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 线程1 ，A </span></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (count % <span class="number">3</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            safeCount.compareAndSet(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"thread1:"</span>+safeCount.get());</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 唤醒条件2</span></span><br><span class="line">            c2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">     <span class="comment">// 线程2 ，B </span></span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (count % <span class="number">3</span> != <span class="number">1</span>)&#123;</span><br><span class="line">                c2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            safeCount.compareAndSet(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">"thread2:"</span>+safeCount.get());</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 唤醒条件3</span></span><br><span class="line">            c3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 线程2 ，A</span></span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (count % <span class="number">3</span> != <span class="number">2</span>)&#123;</span><br><span class="line">                c3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            safeCount.compareAndSet(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"thread3:"</span>+safeCount.get());</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 唤醒条件1</span></span><br><span class="line">            c1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 启动启动线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        t3.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ConditionAlternateTest test = <span class="keyword">new</span> ConditionAlternateTest();</span><br><span class="line">        test.threadStart();</span><br><span class="line">        test.countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread1:<span class="number">1</span></span><br><span class="line">thread2:<span class="number">0</span></span><br><span class="line">thread3:<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>上面线程交叉的案例实际上并不是严格意义上的 ABA 问题的复现，这里仅是模拟下产生的一个最简单的过程。如果大家有好的案例，也可以分享一下。</p>
<h3 id="ABA-问题解决"><a href="#ABA-问题解决" class="headerlink" title="ABA 问题解决"></a>ABA 问题解决</h3><p>常见实践：“版本号”的比对，一个数据一个版本，版本变化，即使值相同，也不应该修改成功。</p>
<p>java 中提供了 AtomicStampedReference 这个类来解决这个 ABA 问题。<br>AtomicStampedReference 原子类是一个带有时间戳的对象引用，在每次修改后，AtomicStampedReference 不仅会设置新值而且还会记录更改的时间。当 AtomicStampedReference 设置对象值时，对象值以及时间戳都必须满足期望值才能写入成功，这也就解决了反复读写时，无法预知值是否已被修改的窘境。</p>
<p>实现代码这里就不贴了，基于前面的代码改造，下面贴一下运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread1,第一次修改;值为=1</span><br><span class="line">thread2,已经改回为原始值;值为=0</span><br><span class="line">thread3,第二次修改;值为=1</span><br></pre></td></tr></table></figure></p>
<h3 id="3、只能保证一个共享变量的原子操作"><a href="#3、只能保证一个共享变量的原子操作" class="headerlink" title="3、只能保证一个共享变量的原子操作"></a>3、只能保证一个共享变量的原子操作</h3><p>当对一个共享变量执行操作时，我们可以使用 CAS 的方式来保证原子操作，但是对于对多个变量操作时，循环 CAS 就无法保证操作的原子性了，那么这种场景下，我们就需要使用加锁的方式来解决。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2019/04/29/cas-several-qa/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2019/04/13/springboot/springboot-series-event/">SpringBoot 源码系列-事件机制详解</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2019-04-13T14:55:41.000Z" itemprop="datePublished">2019/04/13</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2019/04/13/springboot/springboot-series-event/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/springboot/" title="springboot">springboot</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<blockquote>
<p>微信公众号：<strong><a href="#jump_10">glmapper工作室</a></strong><br>掘金专栏：<a href="https://juejin.im/user/58fcc0768d6d810058965a06" target="_blank" rel="noopener">glmapper</a><br>微          博：<a href="https://weibo.com/u/2412872703" target="_blank" rel="noopener">疯狂的石头_henu</a><br>欢迎关注，一起学习、一起分享</p>
</blockquote>
<p>在这篇文章中<a href="https://juejin.im/post/5b7964d6f265da43412866c7" target="_blank" rel="noopener">聊一聊 Spring 中的扩展机制（一）</a>中对<code>Spring</code>中的事件机制进行了分析。那么对于 <code>SpringBoot</code> 来说，它在 <code>Spring</code> 的基础上又做了哪些拓展呢？本篇将来聊一聊 <code>SpringBoot</code> 中的事件。</p>
<p>在 SpringBoot 的启动过程中，会通过 SPI 机制去加载 spring.factories 下面的一些类，这里面就包括了事件相关的类。</p>
<ul>
<li><p>SpringApplicationRunListener</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Run Listeners</span><br><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">org.springframework.boot.context.event.EventPublishingRunListener</span><br></pre></td></tr></table></figure>
</li>
<li><p>ApplicationListener</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.ClearCachesApplicationListener,\</span><br><span class="line">org.springframework.boot.builder.ParentContextCloserApplicationListener,\</span><br><span class="line">org.springframework.boot.context.FileEncodingApplicationListener,\</span><br><span class="line">org.springframework.boot.context.config.AnsiOutputApplicationListener,\</span><br><span class="line">org.springframework.boot.context.config.ConfigFileApplicationListener,\</span><br><span class="line">org.springframework.boot.context.config.DelegatingApplicationListener,\</span><br><span class="line">org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\</span><br><span class="line">org.springframework.boot.context.logging.LoggingApplicationListener,\</span><br><span class="line">org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener</span><br></pre></td></tr></table></figure>
<p><code>SpringApplicationRunListener</code> 类是 <code>SpringBoot</code> 中新增的类。<code>SpringApplication</code> 类 中使用它们来间接调用 <code>ApplicationListener</code>。另外还有一个新增的类是<code>SpringApplicationRunListeners</code>，<code>SpringApplicationRunListeners</code> 中包含了多个 <code>SpringApplicationRunListener</code>。</p>
<h2 id="SpringApplicationRunListener"><a href="#SpringApplicationRunListener" class="headerlink" title="SpringApplicationRunListener"></a>SpringApplicationRunListener</h2><p><code>SpringApplicationRunListener</code> 接口规定了 <code>SpringBoot</code> 的生命周期，在各个生命周期广播相应的事件，调用实际的 <code>ApplicationListener</code> 类。通过对 <code>SpringApplicationRunListener</code> 的分析，也可以对 <code>SpringBoot</code> 的整个启动过程的理解会有很大帮助。</p>
<p>先来看下<code>SpringApplicationRunListener</code> 接口的代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpringApplicationRunListener</span> </span>&#123;</span><br><span class="line">	<span class="comment">//当run方法首次启动时立即调用。可用于非常早期的初始化。</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//在准备好环境后，但在创建ApplicationContext之前调用。</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span></span>;</span><br><span class="line">	<span class="comment">//在创建和准备好ApplicationContext之后，但在加载源之前调用。</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line">	<span class="comment">//在加载应用程序上下文后但刷新之前调用</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line">	<span class="comment">//上下文已刷新，应用程序已启动，但尚未调用commandlinerunner和applicationrunner。</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">started</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line">	<span class="comment">//在运行方法完成之前立即调用，此时应用程序上下文已刷新，</span></span><br><span class="line">	<span class="comment">//并且所有commandlinerunner和applicationrunner都已调用。</span></span><br><span class="line">	<span class="comment">//2.0 才有</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">running</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line">	<span class="comment">//在运行应用程序时发生故障时调用。2.0 才有</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SpringApplicationRunListeners"><a href="#SpringApplicationRunListeners" class="headerlink" title="SpringApplicationRunListeners"></a>SpringApplicationRunListeners</h2><p>上面提到，<code>SpringApplicationRunListeners</code> 是<code>SpringApplicationRunListener</code>的集合，里面包括了很多<code>SpringApplicationRunListener</code>实例；<code>SpringApplication</code> 类实际上使用的是 <code>SpringApplicationRunListeners</code> 类，与 <code>SpringApplicationRunListener</code> 生命周期相同，调用各个周期的 <code>SpringApplicationRunListener</code> 。然后广播相应的事件到 <code>ApplicationListener</code>。</p>
<blockquote>
<p>代码详见：<a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/SpringApplicationRunListeners.java" target="_blank" rel="noopener">SpringApplicationRunListeners</a>.</p>
</blockquote>
<h3 id="EventPublishingRunListener"><a href="#EventPublishingRunListener" class="headerlink" title="EventPublishingRunListener"></a>EventPublishingRunListener</h3><p><code>EventPublishingRunListener</code> 类是 <code>SpringApplicationRunListener</code>接口的实现类 ，它具有广播事件的功能。其内部使用 <code>ApplicationEventMulticaster</code>在实际刷新上下文之前发布事件。下面来看下 <code>EventPublishingRunListener</code> 类生命周期对应的事件。</p>
<h3 id="ApplicationStartingEvent"><a href="#ApplicationStartingEvent" class="headerlink" title="ApplicationStartingEvent"></a>ApplicationStartingEvent</h3><p><code>ApplicationStartingEvent</code> 是 <code>SpringBoot</code> 启动开始的时候执行的事件，在该事件中可以获取到 <code>SpringApplication</code> 对象，可做一些执行前的设置，对应的调用方法是 <code>starting()</code>。</p>
<h3 id="ApplicationEnvironmentPreparedEvent"><a href="#ApplicationEnvironmentPreparedEvent" class="headerlink" title="ApplicationEnvironmentPreparedEvent"></a>ApplicationEnvironmentPreparedEvent</h3><p><code>ApplicationEnvironmentPreparedEvent</code> 是<code>SpringBoot</code> 对应 <code>Enviroment</code> 已经准备完毕时执行的事件，此时上下文 <code>context</code> 还没有创建。在该监听中获取到 <code>ConfigurableEnvironment</code> 后可以对配置信息做操作，例如：修改默认的配置信息，增加额外的配置信息等。对应的生命周期方法是 <code>environmentPrepared(environment)</code>；<code>SpringCloud</code> 中，引导上下文就是在这时初始化的。</p>
<h3 id="ApplicationContextInitializedEvent"><a href="#ApplicationContextInitializedEvent" class="headerlink" title="ApplicationContextInitializedEvent"></a>ApplicationContextInitializedEvent</h3><p>当 <code>SpringApplication</code> 启动并且准备好 <code>ApplicationContext</code>，并且在加载任何 <code>bean</code> 定义之前调用了 <code>ApplicationContextInitializers</code> 时发布的事件。对应的生命周期方法是<code>contextPrepared()</code></p>
<h3 id="ApplicationPreparedEvent"><a href="#ApplicationPreparedEvent" class="headerlink" title="ApplicationPreparedEvent"></a>ApplicationPreparedEvent</h3><p><code>ApplicationPreparedEvent</code> 是<code>SpringBoot</code>上下文 <code>context</code> 创建完成是发布的事件；但此时 <code>spring</code> 中的 <code>bean</code> 还没有完全加载完成。这里可以将上下文传递出去做一些额外的操作。但是在该监听器中是无法获取自定义 <code>bean</code> 并进行操作的。对应的生命周期方法是 <code>contextLoaded()</code>。</p>
<h3 id="ApplicationStartedEvent"><a href="#ApplicationStartedEvent" class="headerlink" title="ApplicationStartedEvent"></a>ApplicationStartedEvent</h3><p>这个事件是在 2.0 版本才引入的；具体发布是在应用程序上下文刷新之后，调用任何 <code>ApplicationRunner</code> 和 <code>CommandLineRunner</code> 运行程序之前。</p>
<h3 id="ApplicationReadyEvent"><a href="#ApplicationReadyEvent" class="headerlink" title="ApplicationReadyEvent"></a>ApplicationReadyEvent</h3><p>这个和 <code>ApplicationStartedEvent</code> 很类似，也是在应用程序上下文刷新之后之后调用，区别在于此时<code>ApplicationRunner</code> 和 <code>CommandLineRunner</code>已经完成调用了，也意味着 <code>SpringBoot</code> 加载已经完成。</p>
<h3 id="ApplicationFailedEvent"><a href="#ApplicationFailedEvent" class="headerlink" title="ApplicationFailedEvent"></a>ApplicationFailedEvent</h3><p><code>SpringBoot</code> 启动异常时执行的事件，在异常发生时，最好是添加虚拟机对应的钩子进行资源的回收与释放，能友善的处理异常信息。</p>
<h3 id="demo-及各个事件的执行顺序"><a href="#demo-及各个事件的执行顺序" class="headerlink" title="demo 及各个事件的执行顺序"></a>demo 及各个事件的执行顺序</h3><p>下面的各个事件对应的demo及打印出来的执行顺序。</p>
<ul>
<li><p>GlmapperApplicationStartingEventListener</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperApplicationStartingEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationStartingEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationStartingEvent applicationStartingEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"execute ApplicationStartingEvent ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>GlmapperApplicationEnvironmentPreparedEvent</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperApplicationEnvironmentPreparedEvent</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEnvironmentPreparedEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEnvironmentPreparedEvent applicationEnvironmentPreparedEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"execute ApplicationEnvironmentPreparedEvent ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>GlmapperApplicationContextInitializedEvent</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperApplicationContextInitializedEvent</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationContextInitializedEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationContextInitializedEvent applicationContextInitializedEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"execute applicationContextInitializedEvent ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>GlmapperApplicationPreparedEvent</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class GlmapperApplicationPreparedEvent implements ApplicationListener&lt;ApplicationPreparedEvent&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(ApplicationPreparedEvent applicationPreparedEvent) &#123;</span><br><span class="line">        System.out.println(&quot;execute ApplicationPreparedEvent ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>GlmapperApplicationStartedEvent</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperApplicationStartedEvent</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationStartedEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationStartedEvent applicationStartedEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"execute ApplicationStartedEvent ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>GlmapperApplicationReadyEvent</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperApplicationReadyEvent</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationReadyEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationReadyEvent applicationReadyEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"execute ApplicationReadyEvent ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行结果</li>
</ul>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-one.jpg" alt=""></p>
<h2 id="SpringBoot-中的事件体系"><a href="#SpringBoot-中的事件体系" class="headerlink" title="SpringBoot 中的事件体系"></a>SpringBoot 中的事件体系</h2><p>这里围绕 <code>SpringApplicationRunListener</code> 这个类来说。在实现类 <code>EventPublishingRunListener</code> 中，事件发布有两种模式：</p>
<ul>
<li>通过 <code>SimpleApplicationEventMulticaster</code> 进行事件广播</li>
<li>所有监听器交给相应的 <code>Context</code></li>
</ul>
<p>所以<code>EventPublishingRunListener</code> 不仅负责发布事件，而且在合适的时机将 <code>SpringApplication</code> 所获取的监听器和应用上下文作关联。</p>
<h3 id="SimpleApplicationEventMulticaster"><a href="#SimpleApplicationEventMulticaster" class="headerlink" title="SimpleApplicationEventMulticaster"></a>SimpleApplicationEventMulticaster</h3><p><code>SimpleApplicationEventMulticaster</code>是 <code>Spring</code> 默认的事件广播器。来看下它是怎么工作的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, @Nullable ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">        Executor executor = getTaskExecutor();</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 异步的</span></span><br><span class="line">            executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码段可以看出，它是通过遍历注册的每个监听器，并启动来调用每个监听器的 <code>onApplicationEvent</code> 方法。</p>
<p>下面再来看下 <code>SimpleApplicationEventMulticaster</code> 的类集成结构：<br><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-two.jpg" alt=""><br>这里的 <code>AbstractApplicationContext</code> 下面来聊，这个类实际上就负责了事件体系的初始化工作。</p>
<h3 id="事件体系的初始化"><a href="#事件体系的初始化" class="headerlink" title="事件体系的初始化"></a>事件体系的初始化</h3><p>事件体系的初始化对应在 <code>SpringBoot</code>启动过程的 <code>refreshContext</code>这个方法；<code>refreshContext</code>具体调用 AbstractApplicationContext.refresh()方法，最后调用 initApplicationEventMulticaster() 来完成事件体系的初始化,代码如下：</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-three.jpg" alt=""></p>
<p>用户可以为容器定义一个自定义的事件广播器，只要实现 <code>ApplicationEventMulticaster</code> 就可以了，<code>Spring</code> 会通过 反射的机制将其注册成容器的事件广播器，如果没有找到配置的外部事件广播器，<code>Spring</code> 就是默认使用 <code>SimpleApplicationEventMulticaster</code> 作为事件广播器。</p>
<h3 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h3><p>事件注册是在事件体系初始化完成之后做的事情，也是在 <code>AbstractApplicationContext.refresh()</code> 方法中进行调用的。</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-four.jpg" alt=""><br>这里干了三件事：</p>
<ul>
<li>首先注册静态指定的 <code>listeners</code>；这里包括我们自定义的那些监听器。</li>
<li>调用 <code>DefaultListableBeanFactory</code> 中 <code>getBeanNamesForType</code> 得到自定义的 <code>ApplicationListener</code> <code>bean</code> 进行事件注册。</li>
<li>广播早期的事件。</li>
</ul>
<h3 id="事件广播"><a href="#事件广播" class="headerlink" title="事件广播"></a>事件广播</h3><p>事件发布伴随着 <code>SpringBoot</code> 启动的整个生命周期。不同阶段对应发布不同的事件，上面我们已经对各个事件进行了分析，下面就具体看下发布事件的实现：</p>
<blockquote>
<p>org.springframework.context.support.AbstractApplicationContext#publishEvent<br><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-five.jpg" alt=""></p>
</blockquote>
<blockquote>
<p>earlyApplicationEvents 中的事件是广播器未建立的时候保存通知信息，一旦容器建立完成，以后都是直接通知。</p>
</blockquote>
<p>广播事件最终还是通过调用 <code>ApplicationEventMulticaster</code> 的 <code>multicastEvent</code> 来实现。而 <code>multicastEvent</code> 也就就是事件执行的方法。</p>
<h3 id="事件执行"><a href="#事件执行" class="headerlink" title="事件执行"></a>事件执行</h3><p>上面 <code>SimpleApplicationEventMulticaster</code> 小节已经初步介绍了 <code>multicastEvent</code> 这个方法。补充一点， 如果有可用的 <code>taskExecutor</code> 会使用并发的模式执行事件，但是实际上 <code>SimpleApplicationEventMulticaster</code> 并没有提供线程池实现，默认请况下是使用同步的方式执行事件（<code>org.springframework.core.task.SyncTaskExecutor</code>），所以如果需要异步配置的话，需要自己去实现线程池。</p>
<h2 id="SpringBoot-启动过程中的事件阶段"><a href="#SpringBoot-启动过程中的事件阶段" class="headerlink" title="SpringBoot 启动过程中的事件阶段"></a>SpringBoot 启动过程中的事件阶段</h2><p>这里回到 <code>SpringApplication</code>的<code>run</code>方法，看下 <code>SpringBoot</code> 在启动过程中，各个事件阶段做了哪些事情。</p>
<h3 id="starting-gt-ApplicationStartingEvent"><a href="#starting-gt-ApplicationStartingEvent" class="headerlink" title="starting -&gt; ApplicationStartingEvent"></a>starting -&gt; ApplicationStartingEvent</h3><p>这里 <code>debug</code> 到 <code>starting</code> 方法，追踪到 <code>multicastEvent</code>，这里 <code>type</code>为 <code>ApplicationStartingEvent</code>；对应的事件如下：<br><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-six.jpg" alt=""></p>
<ul>
<li>LoggerApplicationListener：配置日志系统。使用<code>logging.config</code>环境变量指定的配置或者缺省配置</li>
<li>BackgroundPreinitializer：尽早触发一些耗时的初始化任务，使用一个后台线程</li>
<li>DelegatingApplicationListener：监听到事件后转发给环境变量<code>context.listener.classes</code>指定的那些事件监听器</li>
<li>LiquibaseServiceLocatorApplicationListener：使用一个可以和 <code>SpringBoot</code> 可执行<code>jar</code>包配合工作的版本替换 <code>liquibase ServiceLocator</code></li>
</ul>
<h3 id="listeners-environmentPrepared-gt-ApplicationEnvironmentPreparedEvent"><a href="#listeners-environmentPrepared-gt-ApplicationEnvironmentPreparedEvent" class="headerlink" title="listeners.environmentPrepared-&gt;ApplicationEnvironmentPreparedEvent"></a>listeners.environmentPrepared-&gt;ApplicationEnvironmentPreparedEvent</h3><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-seven.jpg" alt=""></p>
<ul>
<li>AnsiOutputApplicationListener：根据<code>spring.output.ansi.enabled</code>参数配置<code>AnsiOutput</code></li>
<li><p>ConfigFileApplicationListener：<code>EnvironmentPostProcessor</code>，从常见的那些约定的位置读取配置文件，比如从以下目录读取<code>application.properties</code>,<code>application.yml</code>等配置文件：</p>
<ul>
<li>classpath:</li>
<li>file:.</li>
<li>classpath:config</li>
<li><p>file:./config/</p>
<p>也可以配置成从其他指定的位置读取配置文件。</p>
</li>
</ul>
</li>
<li>ClasspathLoggingApplicationListener：对环境就绪事件<code>ApplicationEnvironmentPreparedEvent</code>/应用失败事<code>件ApplicationFailedEvent</code>做出响应，往日志<code>DEBUG</code>级别输出<code>TCCL(thread context class loader)</code>的 <code>classpath</code>。</li>
<li>FileEncodingApplicationListener：如果系统文件编码和环境变量中指定的不同则终止应用启动。具体的方法是比较系统属性<code>file.encoding</code>和环境变量<code>spring.mandatory-file-encoding</code>是否相等(大小写不敏感)。</li>
</ul>
<h3 id="listeners-contextPrepared-gt-ApplicationContextInitializedEvent"><a href="#listeners-contextPrepared-gt-ApplicationContextInitializedEvent" class="headerlink" title="listeners.contextPrepared-&gt;ApplicationContextInitializedEvent"></a>listeners.contextPrepared-&gt;ApplicationContextInitializedEvent</h3><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-eight.jpg" alt=""></p>
<p>相关监听器参考上面的描述。</p>
<h3 id="listeners-contextLoaded-gt-ApplicationPreparedEvent"><a href="#listeners-contextLoaded-gt-ApplicationPreparedEvent" class="headerlink" title="listeners.contextLoaded-&gt;ApplicationPreparedEvent"></a>listeners.contextLoaded-&gt;ApplicationPreparedEvent</h3><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-12.jpg" alt=""></p>
<p>相关监听器参考上面的描述。</p>
<h3 id="refresh-gt-ContextRefreshedEvent"><a href="#refresh-gt-ContextRefreshedEvent" class="headerlink" title="refresh-&gt;ContextRefreshedEvent"></a>refresh-&gt;ContextRefreshedEvent</h3><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-nine.jpg" alt=""></p>
<ul>
<li>ConditionEvaluationReportLoggingListener：实际上实现的是 <code>ApplicationContextInitializer</code>接口，其目的是将 <code>ConditionEvaluationReport</code> 写入到日志，使用<code>DEBUG</code>级别输出。程序崩溃报告会触发一个消息输出，建议用户使用调试模式显示报告。它是在应用初始化时绑定一个<code>ConditionEvaluationReportListener</code>事件监听器，然后相应的事件发生时输出<code>ConditionEvaluationReport</code>报告。</li>
<li>ClearCachesApplicationListener：应用上下文加载完成后对缓存做清除工作，响应事件<code>ContextRefreshedEvent</code>。</li>
<li>SharedMetadataReaderFactoryContextInitializer：　向<code>context</code>注册了一个<code>BeanFactoryPostProcessor</code>：<code>CachingMetadataReaderFactoryPostProcessor</code>实例。</li>
<li>ResourceUrlProvider：<code>handling mappings</code>处理</li>
</ul>
<h3 id="started-gt-ApplicationStartedEvent"><a href="#started-gt-ApplicationStartedEvent" class="headerlink" title="started-&gt;ApplicationStartedEvent"></a>started-&gt;ApplicationStartedEvent</h3><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-ten.jpg" alt=""><br>相关监听器参考上面的描述。</p>
<h3 id="running-gt-ApplicationReadyEvent"><a href="#running-gt-ApplicationReadyEvent" class="headerlink" title="running-&gt;ApplicationReadyEvent"></a>running-&gt;ApplicationReadyEvent</h3><p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-11.jpg" alt=""><br>相关监听器参考上面的描述。</p>
<h3 id="BackgroundPreinitializer-amp-DelegatingApplicationListener"><a href="#BackgroundPreinitializer-amp-DelegatingApplicationListener" class="headerlink" title="BackgroundPreinitializer&amp;DelegatingApplicationListener"></a>BackgroundPreinitializer&amp;DelegatingApplicationListener</h3><p>这两个贯穿了整个过程，这里拎出来单独解释下：</p>
<ul>
<li>BackgroundPreinitializer：对于一些耗时的任务使用一个后台线程尽早触发它们开始执行初始化，这是<code>SpringBoot</code>的缺省行为。这些初始化动作也可以叫做预初始化。可以通过设置系统属性<code>spring.backgroundpreinitializer.ignore</code>为<code>true</code>可以禁用该机制。该机制被禁用时，相应的初始化任务会发生在前台线程。</li>
<li>DelegatingApplicationListener：监听应用事件，并将这些应用事件广播给环境属性<code>context.listener.classes</code>指定的那些监听器。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到此，<code>SpringBoot</code> 中的事件相关的东西就结束了。本文从<code>SpringApplicationRunListener</code>这个类说起，接着介绍 <code>SpringBoot</code> 启动过程的事件以及事件的生命周期。最后介绍了 <code>SpringBoot</code>中的内置的这些 监听器在启动过程中对应的各个阶段。</p>
<p>新年伊始，祝大家新年快乐！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/andy_zhang2007/article/details/84105284" target="_blank" rel="noopener">https://blog.csdn.net/andy_zhang2007/article/details/84105284</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2019/04/13/springboot/springboot-series-event/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2019/04/13/zookeeper-client-curator/">ZooKeeper 客户端之 Curator</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2019-04-13T14:09:30.000Z" itemprop="datePublished">2019/04/13</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2019/04/13/zookeeper-client-curator/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/zookeeper/" title="zookeeper">zookeeper</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<blockquote>
<p>原文链接：<a href="http://www.glmapper.com/2019/04/13/zookeeper-client-curator/">ZooKeeper 客户端之 Curator</a></p>
</blockquote>
<p>ZooKeeper 是一个分布式的、开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现。它是集群的管理者，监视着集群中各个节点的状态，根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p>
<p>Curator 是 Netflix 公司开源的一套  Zookeeper 客户端框架，解决了很多 Zookeeper 客户端非常底层的细节开发工作，包括连接重连、反复注册 Watcher 和 NodeExistsException 异常等等。Curator 包含了几个包：</p>
<ul>
<li>curator-framework：对 Zookeeper 的底层 api 的一些封装</li>
<li>curator-client：提供一些客户端的操作，例如重试策略等</li>
<li>curator-recipes：封装了一些高级特性，如：Cache 事件监听、选举、分布式锁、分布式计数器、分布式Barrier 等</li>
</ul>
<h2 id="Curator-和-zookeeper-的版本问题"><a href="#Curator-和-zookeeper-的版本问题" class="headerlink" title="Curator 和 zookeeper 的版本问题"></a>Curator 和 zookeeper 的版本问题</h2><p>目前 Curator 有 2.x.x 和 3.x.x 两个系列的版本，支持不同版本的 Zookeeper。其中Curator 2.x.x 兼容 Zookeeper的 3.4.x 和 3.5.x。而 Curator 3.x.x 只兼容 Zookeeper 3.5.x，并且提供了一些诸如动态重新配置、watch删除等新特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Curator 2.x.x - compatible with both ZooKeeper 3.4.x and ZooKeeper 3.5.x</span><br><span class="line">Curator 3.x.x - compatible only with ZooKeeper 3.5.x and includes support for new</span><br></pre></td></tr></table></figure>
<p>如果跨版本会有兼容性问题，很有可能导致节点操作失败，当时在使用的时候就踩了这个坑，抛了如下的异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KeeperErrorCode = Unimplemented for /***</span><br></pre></td></tr></table></figure>
<h2 id="Curator-API"><a href="#Curator-API" class="headerlink" title="Curator   API"></a>Curator   API</h2><p>这里就不对比与原生 API 的区别了，Curator 的 API 直接通过 org.apache.curator.framework.CuratorFramework 接口来看，并结合相应的案例进行使用，以备后用。</p>
<blockquote>
<p>为了可以直观的看到 Zookeeper 的节点信息，可以考虑弄一个 zk 的管控界面，常见的有 zkui 和 zkweb。</p>
<p>zkui：<a href="https://github.com/DeemOpen/zkui" target="_blank" rel="noopener">https://github.com/DeemOpen/zkui</a></p>
<p>zkweb：<a href="https://github.com/zhitom/zkweb" target="_blank" rel="noopener">https://github.com/zhitom/zkweb</a></p>
<p>我用的 zkweb ，虽然界面上看起来没有 zkui 精简，但是在层次展示和一些细节上感觉比 zkui 好一点</p>
</blockquote>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>之前写的一个在 <a href="http://www.glmapper.com/2019/03/04/zk-on-linux">Linux 上安装部署 Zookeeper</a> 的笔记，其他操作系统请自行谷歌教程吧。</p>
<p>本文案例工程已经同步到了 github，<a href="https://github.com/glmapper/glmapper-blog-samples" target="_blank" rel="noopener">传送门</a>。</p>
<blockquote>
<p>PS : 目前还没有看过Curator的具体源码，所以不会涉及到任何源码解析、实现原理的东西；本篇主要是实际使用时的一些记录，以备后用。如果文中错误之处，希望各位指出。</p>
</blockquote>
<h2 id="Curator-客户端的初始化和初始化时机"><a href="#Curator-客户端的初始化和初始化时机" class="headerlink" title="Curator 客户端的初始化和初始化时机"></a>Curator 客户端的初始化和初始化时机</h2><p>在实际的工程中，Zookeeper 客户端的初始化会在程序启动期间完成。</p>
<h3 id="初始化时机"><a href="#初始化时机" class="headerlink" title="初始化时机"></a>初始化时机</h3><p>在 Spring 或者 SpringBoot 工程中最常见的就是绑定到容器启动的生命周期或者应用启动的生命周期中：</p>
<ul>
<li>监听 ContextRefreshedEvent 事件，在容器刷新完成之后初始化 Zookeeper</li>
<li>监听 ApplicationReadyEvent/ApplicationStartedEvent 事件，初始化 Zookeeper 客户端</li>
</ul>
<p>除了上面的方式之外，还有一种常见的是绑定到 bean 的生命周期中</p>
<ul>
<li>实现 InitializingBean 接口 ，在 afterPropertiesSet 中完成 Zookeeper 客户端初始化</li>
</ul>
<blockquote>
<p>关于 SpringBoot中的事件机制可以参考之前写过的一篇文章：<a href="https://juejin.im/post/5c2af8915188252a94130422#heading-8" target="_blank" rel="noopener">SpringBoot-SpringBoot中的事件机制</a>。</p>
</blockquote>
<h3 id="Curator-初始化"><a href="#Curator-初始化" class="headerlink" title="Curator 初始化"></a>Curator 初始化</h3><p>这里使用 InitializingBean 的这种方式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperCuratorClient</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CuratorFramework curatorClient;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;glmapper.zookeeper.address:localhost:2181&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String           connectString;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;glmapper.zookeeper.baseSleepTimeMs:1000&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>              baseSleepTimeMs;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;glmapper.zookeeper.maxRetries:3&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>              maxRetries;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;glmapper.zookeeper.sessionTimeoutMs:6000&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>              sessionTimeoutMs;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;glmapper.zookeeper.connectionTimeoutMs:6000&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>              connectionTimeoutMs;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// custom policy</span></span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(baseSleepTimeMs, maxRetries);</span><br><span class="line">        <span class="comment">// to build curatorClient</span></span><br><span class="line">        curatorClient = CuratorFrameworkFactory.builder().connectString(connectString)</span><br><span class="line">                .sessionTimeoutMs(sessionTimeoutMs).connectionTimeoutMs(connectionTimeoutMs)</span><br><span class="line">                .retryPolicy(retryPolicy).build();</span><br><span class="line">        curatorClient.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CuratorFramework <span class="title">getCuratorClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curatorClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>glmapper.zookeeper.xxx 是本例中需要在配置文件中配置的 zookeeper 的一些参数，参数解释如下：</p>
<ul>
<li>baseSleepTimeMs：重试之间等待的初始时间</li>
<li>maxRetries：最大重试次数</li>
<li>connectString：要连接的服务器列表</li>
<li>sessionTimeoutMs：session 超时时间</li>
<li>connectionTimeoutMs：连接超时时间</li>
</ul>
<p>另外，Curator 客户端初始化时还需要指定重试策略，RetryPolicy 接口是 Curator 中重试连接(当zookeeper失去连接时使用)策略的顶级接口，其类继承体系如下图所示：</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/zookeeper/curator-classes.jpg" alt=""></p>
<ul>
<li>RetryOneTime：只重连一次</li>
<li>RetryNTime：指定重连的次数N</li>
<li>RetryUtilElapsed：指定最大重连超时时间和重连时间间隔，间歇性重连直到超时或者链接成功</li>
<li>ExponentialBackoffRetry：基于 “backoff”方式重连，和 RetryUtilElapsed 的区别是重连的时间间隔是动态的。</li>
<li>BoundedExponentialBackoffRetry： 同 ExponentialBackoffRetry的区别是增加了最大重试次数的控制</li>
</ul>
<p>除上述之外，在一些场景中，需要对不同的业务进行隔离，这种情况下，可以通过设置 namespace 来解决，namespace 实际上就是指定zookeeper的根路径，设置之后，后面的所有操作都会基于该根目录。</p>
<h2 id="Curator-基础-API-使用"><a href="#Curator-基础-API-使用" class="headerlink" title="Curator 基础 API 使用"></a>Curator 基础 API 使用</h2><h3 id="检查节点是否存在"><a href="#检查节点是否存在" class="headerlink" title="检查节点是否存在"></a>检查节点是否存在</h3><p>checkExists 方法返回的是一个 ExistsBuilder 构造器，这个构建器将返回一个 Stat 对象，就像调用了 org.apache.zookeeper.ZooKeeper.exists()一样。null 表示它不存在，而实际的 Stat 对象表示存在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkNodeExist</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Stat stat = curatorClient.checkExists().forPath(path);</span><br><span class="line">    <span class="keyword">if</span> (stat != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"path = "</span>+path +<span class="string">" has bean exist."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议在实际的应用中，操作节点时对所需操作的节点进行 checkExists。</p>
<h3 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h3><ul>
<li><p>非递归方式创建节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.create().forPath(&quot;/glmapper&quot;);</span><br><span class="line">curatorClient.create().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure>
<p>先创建/glmapper，然后再在/glmapper 下面创建 /test ，如果直接使用 /glmapper/test 没有先创建 /glmapper 时，会抛出异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.zookeeper.KeeperException$NoNodeException: KeeperErrorCode = NoNode for /glmapper/test</span><br></pre></td></tr></table></figure>
<p>如果需要在创建节点时指定节点中数据，则可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.create().forPath(&quot;/glmapper&quot;,&quot;data&quot;.getBytes());</span><br></pre></td></tr></table></figure>
<p>指定节点类型(EPHEMERAL 临时节点)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.create().withMode(CreateMode.EPHEMERAL).forPath(&quot;/glmapper&quot;,&quot;data&quot;.getBytes());</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归方式创建节点</p>
<p>递归方式创建节点有两个方法，creatingParentsIfNeeded 和 creatingParentContainersIfNeeded。在新版本的 zookeeper 这两个递归创建方法会有区别； creatingParentContainersIfNeeded() 以容器模式递归创建节点，如果旧版本 zookeeper，此方法等于creatingParentsIfNeeded()。</p>
<p>在非递归方式情况下，如果直接创建 /glmapper/test 会报错，那么在递归的方式下则是可以的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.create().creatingParentContainersIfNeeded().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure>
<p>在递归调用中，如果不指定 CreateMode，则默认<code>PERSISTENT</code>，如果指定为临时节点，则最终节点会是临时节点，父节点仍旧是<code>PERSISTENT</code></p>
</li>
</ul>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><ul>
<li><p>非递归删除节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.delete().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure>
<p>指定具体版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.delete().withVersion(-1).forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure>
<p>使用 guaranteed 方式删除，guaranteed 会保证在session有效的情况下，后台持续进行该节点的删除操作，直到删除掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.delete().guaranteed().withVersion(-1).forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归删除当前节点及其子节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.delete().deletingChildrenIfNeeded().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="获取节点数据"><a href="#获取节点数据" class="headerlink" title="获取节点数据"></a>获取节点数据</h3><p>获取节点数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte[] data = curatorClient.getData().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure>
<p>根据配置的压缩提供程序对数据进行解压缩处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte[] data = curatorClient.getData().decompressed().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure>
<p>读取数据并获得Stat信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stat stat = new Stat();</span><br><span class="line">byte[] data = curatorClient.getData().storingStatIn(stat).forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="更新节点数据"><a href="#更新节点数据" class="headerlink" title="更新节点数据"></a>更新节点数据</h3><p>设置指定值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.setData().forPath(&quot;/glmapper/test&quot;,&quot;newData&quot;.getBytes());</span><br></pre></td></tr></table></figure>
<p>设置数据并使用配置的压缩提供程序压缩数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.setData().compressed().forPath(&quot;/glmapper/test&quot;,&quot;newData&quot;.getBytes());</span><br></pre></td></tr></table></figure>
<p>设置数据，并指定版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.setData().withVersion(-1).forPath(&quot;/glmapper/test&quot;,&quot;newData&quot;.getBytes());</span><br></pre></td></tr></table></figure>
<h3 id="获取子列表"><a href="#获取子列表" class="headerlink" title="获取子列表"></a>获取子列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; childrenList = curatorClient.getChildren().forPath(&quot;/glmapper&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>Curator 也对 Zookeeper 典型场景之事件监听进行封装，这部分能力实在 curator-recipes 包下的。</p>
<h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><p>在使用不同的方法时会有不同的事件发生</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CuratorEventType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Corresponds to &#123;@link CuratorFramework#create()&#125;</span></span><br><span class="line">    CREATE,</span><br><span class="line">    <span class="comment">//Corresponds to &#123;@link CuratorFramework#delete()&#125;</span></span><br><span class="line">    DELETE,</span><br><span class="line">		<span class="comment">//Corresponds to &#123;@link CuratorFramework#checkExists()&#125;</span></span><br><span class="line">    EXISTS,</span><br><span class="line">		<span class="comment">//Corresponds to &#123;@link CuratorFramework#getData()&#125;</span></span><br><span class="line">    GET_DATA,</span><br><span class="line">		<span class="comment">//Corresponds to &#123;@link CuratorFramework#setData()&#125;</span></span><br><span class="line">    SET_DATA,</span><br><span class="line">		<span class="comment">//Corresponds to &#123;@link CuratorFramework#getChildren()&#125;</span></span><br><span class="line">    CHILDREN,</span><br><span class="line">		<span class="comment">//Corresponds to &#123;@link CuratorFramework#sync(String, Object)&#125;</span></span><br><span class="line">    SYNC,</span><br><span class="line">		<span class="comment">//Corresponds to &#123;@link CuratorFramework#getACL()&#125;</span></span><br><span class="line">    GET_ACL,</span><br><span class="line">		<span class="comment">//Corresponds to &#123;@link CuratorFramework#setACL()&#125;</span></span><br><span class="line">    SET_ACL,</span><br><span class="line">		<span class="comment">//Corresponds to &#123;@link Watchable#usingWatcher(Watcher)&#125; or &#123;@link Watchable#watched()&#125;</span></span><br><span class="line">    WATCHED,</span><br><span class="line">		<span class="comment">//Event sent when client is being closed</span></span><br><span class="line">    CLOSING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><h4 id="一次性监听方式：Watcher"><a href="#一次性监听方式：Watcher" class="headerlink" title="一次性监听方式：Watcher"></a>一次性监听方式：Watcher</h4><p>利用 Watcher 来对节点进行监听操作，可以典型业务场景需要使用可考虑，但一般情况不推荐使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">byte</span>[] data = curatorClient.getData().usingWatcher(<span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"监听器 watchedEvent："</span> + watchedEvent);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;).forPath(<span class="string">"/glmapper/test"</span>);</span><br><span class="line">System.out.println(<span class="string">"监听节点内容："</span> + <span class="keyword">new</span> String(data));</span><br><span class="line"><span class="comment">// 第一次变更节点数据</span></span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test"</span>,<span class="string">"newData"</span>.getBytes());</span><br><span class="line"><span class="comment">// 第二次变更节点数据</span></span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test"</span>,<span class="string">"newChangedData"</span>.getBytes());</span><br></pre></td></tr></table></figure>
<p>上面这段代码对 /glmapper/test 节点注册了一个 Watcher 监听事件，并且返回当前节点的内容。后面进行两次数据变更，实际上第二次变更时，监听已经失效，无法再次获得节点变动事件了。测试中控制台输出的信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">监听节点内容：data</span><br><span class="line">watchedEvent：WatchedEvent state:SyncConnected type:NodeDataChanged path:/glmapper/test</span><br></pre></td></tr></table></figure>
<h4 id="CuratorListener-方式"><a href="#CuratorListener-方式" class="headerlink" title="CuratorListener 方式"></a>CuratorListener 方式</h4><p>CuratorListener 监听，此监听主要针对 background 通知和错误通知。使用此监听器之后，调用inBackground 方法会异步获得监听，对于节点的创建或修改则不会触发监听事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CuratorListener listener = <span class="keyword">new</span> CuratorListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eventReceived</span><span class="params">(CuratorFramework client, CuratorEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"event : "</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="comment">// 绑定监听器</span></span><br><span class="line">curatorClient.getCuratorListenable().addListener(listener);</span><br><span class="line"><span class="comment">// 异步获取节点数据</span></span><br><span class="line">curatorClient.getData().inBackground().forPath(<span class="string">"/glmapper/test"</span>);</span><br><span class="line"><span class="comment">// 更新节点数据</span></span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test"</span>,<span class="string">"newData"</span>.getBytes());</span><br></pre></td></tr></table></figure>
<p>测试中控制台输出的信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">event : CuratorEventImpl&#123;type=GET_DATA, resultCode=0, path=&apos;/glmapper/test&apos;, name=&apos;null&apos;, children=null, context=null, stat=5867,5867,1555140974671,1555140974671,0,0,0,0,4,0,5867</span><br><span class="line">, data=[100, 97, 116, 97], watchedEvent=null, aclList=null&#125;</span><br></pre></td></tr></table></figure>
<p>这里只触发了一次监听回调，就是 getData 。</p>
<h4 id="Curator-引入的-Cache-事件监听机制"><a href="#Curator-引入的-Cache-事件监听机制" class="headerlink" title="Curator 引入的 Cache 事件监听机制"></a>Curator 引入的 Cache 事件监听机制</h4><p>Curator 引入了 Cache 来实现对 Zookeeper 服务端事件监听，Cache 事件监听可以理解为一个本地缓存视图与远程 Zookeeper 视图的对比过程。Cache 提供了反复注册的功能。Cache 分为两类注册类型：节点监听和子节点监听。</p>
<ul>
<li><p>NodeCache</p>
<p>监听数据节点本身的变化。对节点的监听需要配合回调函数来进行处理接收到监听事件之后的业务处理。NodeCache 通过 NodeCacheListener 来完成后续处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String path = <span class="string">"/glmapper/test"</span>;</span><br><span class="line"><span class="keyword">final</span> NodeCache nodeCache = <span class="keyword">new</span> NodeCache(curatorClient,path);</span><br><span class="line"><span class="comment">//如果设置为true则在首次启动时就会缓存节点内容到Cache中。 nodeCache.start(true);</span></span><br><span class="line">nodeCache.start();</span><br><span class="line">nodeCache.getListenable().addListener(<span class="keyword">new</span> NodeCacheListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"触发监听回调，当前节点数据为："</span> + <span class="keyword">new</span> String(nodeCache.getCurrentData().getData()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">curatorClient.setData().forPath(path,<span class="string">"1"</span>.getBytes());</span><br><span class="line">curatorClient.setData().forPath(path,<span class="string">"2"</span>.getBytes());</span><br><span class="line">curatorClient.setData().forPath(path,<span class="string">"3"</span>.getBytes());</span><br><span class="line">curatorClient.setData().forPath(path,<span class="string">"4"</span>.getBytes());</span><br><span class="line">curatorClient.setData().forPath(path,<span class="string">"5"</span>.getBytes());</span><br><span class="line">curatorClient.setData().forPath(path,<span class="string">"6"</span>.getBytes());</span><br></pre></td></tr></table></figure>
<p>注意：在测试过程中，nodeCache.start()，NodeCache 在先后多次修改监听节点的内容时，出现了丢失事件现象，在用例执行的5次中，仅一次监听到了全部事件；如果 nodeCache.start(true)，NodeCache 在先后多次修改监听节点的内容时，不会出现丢失现象。</p>
<blockquote>
<p>NodeCache不仅可以监听节点内容变化，还可以监听指定节点是否存在。如果原本节点不存在，那么Cache就会在节点被创建时触发监听事件，如果该节点被删除，就无法再触发监听事件。</p>
</blockquote>
</li>
<li><p>PathChildrenCache</p>
<p>PathChildrenCache 不会对二级子节点进行监听，只会对子节点进行监听。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">String path = <span class="string">"/glmapper"</span>;</span><br><span class="line">PathChildrenCache pathChildrenCache = <span class="keyword">new</span> PathChildrenCache(curatorClient,path,<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 如果设置为true则在首次启动时就会缓存节点内容到Cache中。 nodeCache.start(true);</span></span><br><span class="line">pathChildrenCache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);</span><br><span class="line">pathChildrenCache.getListenable().addListener(<span class="keyword">new</span> PathChildrenCacheListener() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework curatorFramework, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"-----------------------------"</span>);</span><br><span class="line">    System.out.println(<span class="string">"event:"</span>  + event.getType());</span><br><span class="line">    <span class="keyword">if</span> (event.getData()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      System.out.println(<span class="string">"path:"</span> + event.getData().getPath());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"-----------------------------"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">zookeeperCuratorClient.createNode(<span class="string">"/glmapper/test"</span>,<span class="string">"data"</span>.getBytes(),CreateMode.PERSISTENT);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test"</span>,<span class="string">"1"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test"</span>,<span class="string">"2"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">zookeeperCuratorClient.createNode(<span class="string">"/glmapper/test/second"</span>,<span class="string">"data"</span>.getBytes(),CreateMode.PERSISTENT);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test/second"</span>,<span class="string">"1"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test/second"</span>,<span class="string">"2"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>注意：在测试过程中发现，如果连续两个操作之间不进行一定时间的间隔，会导致无法监听到下一次事件。因此只会监听子节点，所以对二级子节点 /second 下面的操作是监听不到的。测试中控制台输出的信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------</span><br><span class="line">event:CHILD_ADDED</span><br><span class="line">path:/glmapper/test</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:INITIALIZED</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:CHILD_UPDATED</span><br><span class="line">path:/glmapper/test</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:CHILD_UPDATED</span><br><span class="line">path:/glmapper/test</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>
</li>
<li><p>TreeCache</p>
<p>TreeCache 使用一个内部类<code>TreeNode</code>来维护这个一个树结构。并将这个树结构与ZK节点进行了映射。所以TreeCache 可以监听当前节点下所有节点的事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String path = <span class="string">"/glmapper"</span>;</span><br><span class="line">TreeCache treeCache = <span class="keyword">new</span> TreeCache(curatorClient,path);</span><br><span class="line">treeCache.getListenable().addListener((client,event)-&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"-----------------------------"</span>);</span><br><span class="line">    System.out.println(<span class="string">"event:"</span>  + event.getType());</span><br><span class="line">    <span class="keyword">if</span> (event.getData()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      System.out.println(<span class="string">"path:"</span> + event.getData().getPath());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"-----------------------------"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">treeCache.start();</span><br><span class="line">zookeeperCuratorClient.createNode(<span class="string">"/glmapper/test"</span>,<span class="string">"data"</span>.getBytes(),CreateMode.PERSISTENT);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test"</span>,<span class="string">"1"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test"</span>,<span class="string">"2"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">zookeeperCuratorClient.createNode(<span class="string">"/glmapper/test/second"</span>,<span class="string">"data"</span>.getBytes(),CreateMode.PERSISTENT);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test/second"</span>,<span class="string">"1"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">curatorClient.setData().forPath(<span class="string">"/glmapper/test/second"</span>,<span class="string">"2"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>测试中控制台输出的信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------</span><br><span class="line">event:NODE_ADDED</span><br><span class="line">path:/glmapper</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:NODE_ADDED</span><br><span class="line">path:/glmapper/test</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:NODE_UPDATED</span><br><span class="line">path:/glmapper/test</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:NODE_UPDATED</span><br><span class="line">path:/glmapper/test</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:NODE_ADDED</span><br><span class="line">path:/glmapper/test/second</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:NODE_UPDATED</span><br><span class="line">path:/glmapper/test/second</span><br><span class="line">-----------------------------</span><br><span class="line">-----------------------------</span><br><span class="line">event:NODE_UPDATED</span><br><span class="line">path:/glmapper/test/second</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h2><p> CuratorFramework 的实例包含 inTransaction( ) 接口方法，调用此方法开启一个 ZooKeeper 事务。 可以复合create、 setData、 check、and/or delete 等操作然后调用 commit() 作为一个原子操作提交。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启事务  </span></span><br><span class="line">CuratorTransaction curatorTransaction = curatorClient.inTransaction();</span><br><span class="line">Collection&lt;CuratorTransactionResult&gt; commit = </span><br><span class="line">  <span class="comment">// 操作1 </span></span><br><span class="line">curatorTransaction.create().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">"/glmapper/transaction"</span>)</span><br><span class="line">  .and()</span><br><span class="line">  <span class="comment">// 操作2 </span></span><br><span class="line">  .delete().forPath(<span class="string">"/glmapper/test"</span>)</span><br><span class="line">  .and()</span><br><span class="line">  <span class="comment">// 操作3</span></span><br><span class="line">  .setData().forPath(<span class="string">"/glmapper/transaction"</span>, <span class="string">"data"</span>.getBytes())</span><br><span class="line">  .and()</span><br><span class="line">  <span class="comment">// 提交事务</span></span><br><span class="line">  .commit();</span><br><span class="line">Iterator&lt;CuratorTransactionResult&gt; iterator = commit.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">  CuratorTransactionResult next = iterator.next();</span><br><span class="line">  System.out.println(next.getForPath());</span><br><span class="line">  System.out.println(next.getResultPath());</span><br><span class="line">  System.out.println(next.getType());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里debug看了下Collection<curatortransactionresult>信息，面板如下：</curatortransactionresult></p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/zookeeper/curator-demo.jpg" alt=""></p>
<h2 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h2><p>前面提到的增删改查都是同步的，但是 Curator 也提供了异步接口，引入了 BackgroundCallback 接口用于处理异步接口调用之后服务端返回的结果信息。BackgroundCallback 接口中一个重要的回调值为 CuratorEvent，里面包含事件类型、响应吗和节点的详细信息。</p>
<p>在使用上也是非常简单的，只需要带上 inBackground() 就行，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curatorClient.getData().inBackground().forPath(<span class="string">"/glmapper/test"</span>);</span><br></pre></td></tr></table></figure>
<p>通过查看 inBackground 方法定义可以看到，inBackground 支持自定义线程池来处理返回结果之后的业务逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">inBackground</span><span class="params">(BackgroundCallback callback, Executor executor)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里就不贴代码了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要围绕 Curator 的基本 API 进行了学习记录，对于原理及源码部分没有涉及。这部分如果有时间在慢慢研究吧。另外像分布式锁、分布式自增序列等实现停留在理论阶段，没有实践，不敢妄论，用到再码吧。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.cnblogs.com/felixzh/p/5869212.html" target="_blank" rel="noopener">http://www.cnblogs.com/felixzh/p/5869212.html</a></li>
<li><a href="https://my.oschina.net/roccn/blog/918209" target="_blank" rel="noopener">https://my.oschina.net/roccn/blog/918209</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2019/04/13/zookeeper-client-curator/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2019/03/07/springboot/springboot-series-kafka-introduction/">SpringBoot 实践系列-Kafka简介&amp;集成SpringBoot</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2019-03-06T16:08:19.000Z" itemprop="datePublished">2019/03/07</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2019/03/07/springboot/springboot-series-kafka-introduction/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/springboot/" title="springboot">springboot</a>,
  
    <a href="/tags/kafka/" title="kafka">kafka</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<blockquote>
<p> 近期在做 SOFA 与 SpringCloud 的集成，希望通过一系列的 DEMO 工程去帮助大家更好的使用 SOFA 和 SpringCloud；同时也希望大家一起来参与共建和 star。</p>
<p>GitHub传送门：<a href="https://github.com/alipay/spring-cloud-sofastack-samples/issues/1" target="_blank" rel="noopener">spring-cloud-sofastack-samples</a></p>
</blockquote>
<h2 id="Kafka-简介"><a href="#Kafka-简介" class="headerlink" title="Kafka 简介"></a>Kafka 简介</h2><blockquote>
<p>官方网站：<a href="https://kafka.apache.org/" target="_blank" rel="noopener">https://kafka.apache.org/</a></p>
</blockquote>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootkafka/boot-kafka.jpg" alt="img"></p>
<h3 id="功能提供"><a href="#功能提供" class="headerlink" title="功能提供"></a>功能提供</h3><p>Apache Kafka™ 是 一个分布式数据流平台，从官方文档的解释来看，其职能大体如下：</p>
<ul>
<li>Publish and subscribe to streams of records, similar to a message queue or enterprise messaging system。发布和订阅数据流，与消息队列或企业级消息系统很像。</li>
<li>Store streams of records in a fault-tolerant durable way。具有很强容灾性的存储数据流</li>
<li>Process streams of records as they occur。及时的处理数据流。</li>
</ul>
<p>作为一个后端司机，大多数情况下都是把 Kafka 作为一个分布式消息队列来使用的，分布式消息队列可以提供应用解耦、流量消峰、消息分发等功能，已经是大型互联网服务架构不可缺少的基础设置了。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="topic-和-partition"><a href="#topic-和-partition" class="headerlink" title="topic 和 partition"></a>topic 和 partition</h4><p>Kafka 对数据提供的核心抽象，topic 是发布的数据流的类别或名称。topic 在 Kafka 中，支持多订阅者； 也就是说，topic 可以有零个、一个或多个消费者订阅写到相应 topic 的数据。对应每一个 topic，Kafka 集群会维护像一个如下这样的分区的日志：<br><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootkafka/boot-kafka-topic.jpg" alt="img"><br>每个 Partition 都是一个有序的、不可变的并且不断被附加的记录序列，也就是一个结构化提交日志（commit log）。为了保证唯一标性识 Partition 中的每个数据记录，Partition 中的记录每个都会被分配一个叫做偏移（offset）顺序的ID号。通过一个可配置的保留期，Kafka 集群会保留所有被发布的数据，不管它们是不是已经被消费者处理。例如，如果保留期设置为两天，则在发布记录后的两天内，数据都可以被消费，之后它将被丢弃以释放空间。 Kafka 的性能是不为因为数据量大小而受影响的，因此长时间存储数据并不成问题。</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootkafka/boot-kafka-producers.jpg" alt="img"><br>事实上，在每个消费者上保留的唯一元数据是消费者在日志中的偏移位置，这个偏移由消费者控制：通常消费者会在读取记录时线性地提高其偏移值（offset++），但实际上，由于偏移位置由消费者控制，它可以以任何顺序来处理数据记录。 例如，消费者可以重置为较旧的偏移量以重新处理来自过去的数据，或者跳过之前的记录，并从“现在”开始消费。 这种特征的组合意味着 Kafka 消费者非常轻量级，随意的开启和关闭并不会对其他的消费者有大的影响。</p>
<p>日志中的 Partition 有几个目的：</p>
<ul>
<li>保证日志的扩展性，topic 的大小不受单个服务器大小的限制。每个单独的 Partition 大小必须小于托管它的服务器磁盘大小，但 topic 可能有很多 Partition，因此它可以处理任意数量的海量数据。</li>
<li>作为并行处理的单位 (<a href="https://www.zhihu.com/question/28925721/answer/139861200" target="_blank" rel="noopener">知乎-Partition</a>：Kafka可以将主题划分为多个分区（Partition），会根据分区规则选择把消息存储到哪个分区中，只要如果分区规则设置的合理，那么所有的消息将会被均匀的分布到不同的分区中，这样就实现了负载均衡和水平扩展。另外，多个订阅者可以从一个或者多个分区中同时消费数据，以支撑海量数据处理能力)</li>
</ul>
<h4 id="kafka中的topic为什么要进行分区"><a href="#kafka中的topic为什么要进行分区" class="headerlink" title="kafka中的topic为什么要进行分区"></a>kafka中的topic为什么要进行分区</h4><blockquote>
<p>原贴：<a href="https://www.zhihu.com/question/28925721" target="_blank" rel="noopener">kafka中的topic为什么要进行分区</a> ，由于不能转载，此处不摘抄原文~</p>
</blockquote>
<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>生产者将数据发布到他们选择的 topic ， 生产者负责选择要吧数据分配给 topic 中哪个 Partition。这可以通过循环方式（round-robin）简单地平衡负载，或者可以根据某些语义进行分区（例如基于数据中的某些关键字）来完成。</p>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>消费者们使用消费群组(<em>consumer group</em> )名称来标注自己，几个消费者共享一个 group，每一个发布到 topic 的数据会被传递到每个消费群组(<em>consumer group</em> )中的一个消费者实例。 消费者实例可以在不同的进程中或不同的机器上。</p>
<p>如果所有的消费者实例具有相同的 consumer group，则记录将在所有的消费者实例上有效地负载平衡</p>
<p>如果所有的消费者实例都有不同的 consumer group，那么每个记录将被广播给所有的消费者进程，每个数据都发到了所有的消费者。</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootkafka/boot-kafka-consume-group.jpg" alt="img"></p>
<blockquote>
<p>上图解释源自<a href="http://ifeve.com/kafka-introduction/" target="_blank" rel="noopener">《Kafka 官方文档》 介绍</a>：</p>
<p>如上图，一个两个服务器节点的Kafka集群， 托管着4个分区(P0-P3)，分为两个消费者群. 消费者群A有2个消费者实例，消费者群B有4个. 然而，更常见的是，我们发现主题具有少量的消费者群，每个消费者群代表一个“逻辑订户”。每个组由许多消费者实例组成，保证可扩展性和容错能力。这可以说是“发布-订阅”语义，但用户是一组消费者而不是单个进程。 在Kafka中实现消费的方式，是通过将日志中的分区均分到消费者实例上，以便每个实例在任何时间都是“相应大小的一块”分区的唯一消费者。维护消费者组成员资格的过程，由卡夫卡协议动态处理。 如果新的实例加入组，他们将从组中的其他成员接管一些分区; 如果一个实例消失，其分区将被分发到剩余的实例。 Kafka仅提供单个<em>分区内</em>的记录的顺序，而不是主题中的不同分区之间的总顺序。 每个分区排序结合按键分区，足以满足大多数应用程序的需求。 但是，如果您需要使用总顺序，则可以通过仅具有一个分区的主题来实现，尽管这仅意味着每个消费者组只有一个消费者进程。</p>
</blockquote>
<h3 id="Kafka-作为消息系统"><a href="#Kafka-作为消息系统" class="headerlink" title="Kafka 作为消息系统"></a>Kafka 作为消息系统</h3><p>消息系统传统上有两种模式: <a href="http://en.wikipedia.org/wiki/Message_queue" target="_blank" rel="noopener">队列</a>和<a href="http://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" target="_blank" rel="noopener">发布-订阅</a>。 </p>
<ul>
<li>队列模式中，消费者池可以从服务器读取，每条记录只会被某一个消费者消费<ul>
<li>允许在多个消费者实例上分配数据处理，但是一旦数据被消费之后，数据就没有了</li>
</ul>
</li>
<li>发布订阅模式中，记录将广播给所有消费者<ul>
<li>允许将数据广播到多个进程，但无法缩放和扩容，因为每个消息都发送给每个订阅用户</li>
</ul>
</li>
</ul>
<blockquote>
<p>本篇只介绍 Kafka 作为消息队列的一些基本概念，更多介绍请参考<a href="https://kafka.apache.org/intro" target="_blank" rel="noopener">官方文档</a>。</p>
</blockquote>
<h2 id="Kafka-安装"><a href="#Kafka-安装" class="headerlink" title="Kafka 安装"></a>Kafka 安装</h2><p>这里来看下如何安装 kafka，下载地址：<a href="https://kafka.apache.org/downloads。本篇使用的版本是" target="_blank" rel="noopener">https://kafka.apache.org/downloads。本篇使用的版本是</a> <strong>kafka_2.12-1.1.1</strong>。</p>
<ul>
<li><p>获取包文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; wget http://mirrors.shu.edu.cn/apache/kafka/1.1.1/kafka_2.12-1.1.1.tgz</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压压缩包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; tar -zxvf kafka_2.12-1.1.1.tgz</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cd kafka_2.12-1.1.1/config</span><br><span class="line">&gt; vim server.properties</span><br></pre></td></tr></table></figure>
<p>我这里主要修改项包括以下几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># The id of the broker. This must be set to a unique integer for each broker.</span><br><span class="line">broker.id=0</span><br><span class="line"></span><br><span class="line">listeners=PLAINTEXT://192.168.0.1:9092</span><br><span class="line"></span><br><span class="line">advertised.listeners=PLAINTEXT://192.168.0.1:9092</span><br><span class="line"># zookeeper 地址，可以多个</span><br><span class="line">zookeeper.connect=192.168.0.6:2181</span><br></pre></td></tr></table></figure>
<p>  Kafka 服务启动需要依赖 Zookeeper ，所以在配置文件中需要指定 Zookeeper 集群地址。Kafka 自己的安装包中解压之后是包括 Zookeeper 的，可以通过以下的方式来启动一个单节点 Zookeeper 实例：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; sh zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里我是指定了之前部署的一台ZK机器，所以可以直接将ZK地址指到已部署好的地址。Zookeeper 安装可以参考： <a href="http://www.glmapper.com/2019/03/04/zk-on-linux/">Linux 下安装 Zookeeper</a> </p>
</blockquote>
<p>  通过上述操作，下面就可以直接来启动Kafka 服务了：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; sh kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="SpringBoot-集成-Kafka"><a href="#SpringBoot-集成-Kafka" class="headerlink" title="SpringBoot 集成 Kafka"></a>SpringBoot 集成 Kafka</h2><h3 id="构建一个简单的-Kafka-Producer-工具依赖"><a href="#构建一个简单的-Kafka-Producer-工具依赖" class="headerlink" title="构建一个简单的 Kafka Producer 工具依赖"></a>构建一个简单的 Kafka Producer 工具依赖</h3><ul>
<li>依赖引入</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="comment">&lt;!--$NO-MVN-MAN-VER$--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>producer</li>
</ul>
<p>为了可以把 Kafka 封装已提供给其他模块使用，大家可以将 Kafka 的生产端工具类使用 SpringBoot 的自动配置机制进行包装，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaProducerAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KafkaSender <span class="title">kafkaSender</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KafkaSender(kafkaTemplate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>KafkaSender</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaSender</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KafkaSender</span><span class="params">(KafkaTemplate&lt;String, String&gt; kafkaTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kafkaTemplate = kafkaTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * send message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String topic, String message)</span> </span>&#123;</span><br><span class="line">        kafkaTemplate.send(topic, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>自动配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">io.sofastack.cloud.core.kafka.configuration.KafkaProducerAutoConfiguration</span><br></pre></td></tr></table></figure>
<p>工程模块如下：</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootkafka/boot-kafka-demo-one.jpg" alt=""></p>
<h3 id="案例测试"><a href="#案例测试" class="headerlink" title="案例测试"></a>案例测试</h3><p>在测试工程中引入依赖，这个依赖就是上面工程打包来的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.sofastack.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofastack-cloud-core-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>在 resources 目录下新建 application.properties 配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#============== kafka ===================</span><br><span class="line"># 指定kafka 代理地址，可以多个,这里的192.168.0.1是上面Kafka 启动配置文件中对应的</span><br><span class="line"># 注：网上一些帖子中说 Kafka 这里的配置只能是主机名，不支持 ip，没有验证过，</span><br><span class="line"># 如果您在验证时出现问题，可以尝试本机绑定下 host</span><br><span class="line">spring.kafka.bootstrap-servers= 192.168.0.1:9092</span><br><span class="line">#=============== provider  =======================</span><br><span class="line">spring.kafka.producer.retries=0</span><br><span class="line"># 每次批量发送消息的数量</span><br><span class="line">spring.kafka.producer.batch-size=16384</span><br><span class="line">spring.kafka.producer.buffer-memory=33554432</span><br><span class="line"># 指定消息key和消息体的编解码方式</span><br><span class="line">spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line">spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line">#=============== consumer  =======================</span><br><span class="line"># 指定默认消费者group id</span><br><span class="line">spring.kafka.consumer.group-id=test-consumer-group</span><br><span class="line">spring.kafka.consumer.auto-offset-reset=earliest</span><br><span class="line">spring.kafka.consumer.enable-auto-commit=true</span><br><span class="line">spring.kafka.consumer.auto-commit-interval=100ms</span><br><span class="line"># 指定消息key和消息体的编解码方式</span><br><span class="line">spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line">spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line">spring.application.name=kafka-test</span><br><span class="line">logging.path=./logs</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动类中模拟发送消息</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:application-kafka.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext run = SpringApplication.run(ProviderApplication.class, args);</span><br><span class="line">        <span class="comment">// 这里通过容器获取，正常使用情况下，可以直接使用 Autowired 注入</span></span><br><span class="line">        KafkaSender bean = run.getBean(KafkaSender.class);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//调用消息发送类中的消息发送方法</span></span><br><span class="line">            bean.sendMessage(KafkaContants.TRADE_TOPIC, <span class="string">"send a test message"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编写消费者，在 SpringBoot 工程中，消费者实现非常简单</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaReceiver</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 配置监听的主体，groupId 和配置文件中的保持一致</span></span><br><span class="line">    <span class="meta">@KafkaListener</span>(topics = &#123; KafkaContants.TRADE_TOPIC &#125;, groupId = <span class="string">"test-consumer-group"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(ConsumerRecord&lt;?, ?&gt; record)</span> </span>&#123;</span><br><span class="line">        Optional&lt;?&gt; kafkaMessage = Optional.ofNullable(record.value());</span><br><span class="line">        <span class="keyword">if</span> (kafkaMessage.isPresent()) &#123;</span><br><span class="line">            Object message = kafkaMessage.get();</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动工程后，可以在控制台看下消费者打印的信息：</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootkafka/boot-kafka-demo-two.jpg" alt=""></p>
<p>这里保持应用正常运行，再通过服务端来手动发送消息，看下是当前消费者能够正确监听到对应的 topic 并消费。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; sh kafka-console-producer.sh --broker-list 192.168.0.1:9092 --topic trading</span><br></pre></td></tr></table></figure></p>
<p>执行上述命令之后，命令行将会等待输入，这里输入先后输入 glmapper 和 sofa :</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootkafka/boot-kafka-demo-three.jpg" alt=""></p>
<p>然后再看下应用程序控制台输入结果如下：</p>
<p><img src="https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootkafka/boot-kafka-demo-four.jpg" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://kafka.apache.org/intro" target="_blank" rel="noopener">Introduction</a></li>
<li><a href="http://ifeve.com/kafka-introduction/#more-32041" target="_blank" rel="noopener">《Kafka 官方文档》介绍</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2019/03/07/springboot/springboot-series-kafka-introduction/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2019/03/04/zookeeper-on-linux/">Linux 下安装 Zookeeper</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2019-03-04T12:29:18.000Z" itemprop="datePublished">2019/03/04</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2019/03/04/zookeeper-on-linux/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/linux/" title="linux">linux</a>,
  
    <a href="/tags/zookeeper/" title="zookeeper">zookeeper</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<h2 id="安装-Zookeeper"><a href="#安装-Zookeeper" class="headerlink" title="安装 Zookeeper"></a>安装 Zookeeper</h2><p>目前 Curator 有 2.x.x 和 3.x.x 两个系列的版本，支持不同版本的 Zookeeper。其中 Curator 2.x.x 兼容 Zookeeper的 3.4.x 和 3.5.x。而 Curator 3.x.x 只兼容 Zookeeper 3.5.x。</p>
<blockquote>
<p>Curator 2.x.x - compatible with both ZooKeeper 3.4.x and ZooKeeper 3.5.x<br>Curator 3.x.x - compatible only with ZooKeeper 3.5.x and includes support for new</p>
</blockquote>
<p>选择使用 3.4.x 版本 Zookeeper。</p>
<ul>
<li><a href="http://apache.fayea.com/zookeeper/" target="_blank" rel="noopener">下载 Zookeeper</a> ，选择相应的版本，这里以 3.4.13 版本为例：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> wget http://apache.fayea.com/zookeeper/zookeeper-3.4.13/zookeeper-3.4.13.tar.gz</span></span><br></pre></td></tr></table></figure>
<p>执行上述命令进行下载，下载完成之后对文件进行解压。</p>
<ul>
<li><p>解压文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> tar -zxvf zookeeper-3.4.13.tar.gz</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据和日志目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> zookeeper-3.4.13</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mkdir data</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mkdir logs</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件修改<br>首先将默认的 zoo_sample.cfg 命名为 zoo.cfg</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> conf</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cp zoo_sample.cfg zoo.cfg</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>编辑 zoo.cfg ， 将数据目录和日志目录路径修改为上述步骤中创建的两个文件夹：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置dataDir 和 dataLogDir</span></span><br><span class="line">dataDir=/home/admin/server/zookeeper-3.4.13/data</span><br><span class="line">dataLogDir=/home/admin/server/zookeeper-3.4.13/logs</span><br></pre></td></tr></table></figure>
<ul>
<li>启动 zookeeper<br>到你安装的zookeeper的bin目录下，如：/home/admin/server/zookeeper-3.4.13/bin<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> /home/admin/server/zookeeper-3.4.13/bin</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>执行 start 启动</p>
<pre><code class="shell"><span class="meta">&gt;</span><span class="bash"> zkServer.sh start</span>
</code></pre>
<p>上述是简单的在 linux 环境下安装配置 Zookeeper 的过程，对于在实际的生成环境，请根据自己项目需求进行更加细化的配置。</p>
<h2 id="安装-Zookeeper-可视化工具"><a href="#安装-Zookeeper-可视化工具" class="headerlink" title="安装 Zookeeper 可视化工具"></a>安装 Zookeeper 可视化工具</h2><p>为了可以直观的看到 zookeeper 的节点信息，可以考虑部署一个 zookeeper 的管控界面，常见的有 zkui 和 zkweb。</p>
<ul>
<li><a href="https://github.com/DeemOpen/zkui" target="_blank" rel="noopener">zkui</a></li>
<li><a href="https://github.com/zhitom/zkweb" target="_blank" rel="noopener">zkweb</a></li>
</ul>
<p>zkui 界面更加简单一点，zkweb 在一些细节展示上更加有优势，这里推荐使用  zkweb。具体部署方式见官方文档。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2019/03/04/zookeeper-on-linux/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2019/01/19/springboot/springcloud-gateway-predicate-project/">SpringCloud-网关 Gateway 入门体验</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2019-01-18T16:21:33.000Z" itemprop="datePublished">2019/01/19</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2019/01/19/springboot/springcloud-gateway-predicate-project/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/Gateway/" title="Gateway">Gateway</a>,
  
    <a href="/tags/网关/" title="网关">网关</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>网关服务核心是将进入的请求正确合理的路由到下层具体的服务进行业务处理，从它的功能来看，网关服务的核心就是路由信息的构建。</p>
<p>Spring Cloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Netflix Zuul，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全、监控、埋点和限流等。下面是官方提供的一个工作原理图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/e9d92479a1dbcdf618d33918468b30c2c8b.jpg" alt=""></p>
<p>客户端发送请求到 Spring Cloud Gateway，Gateway Handler Mapping 确定请求与路由匹配，则会将请求交给Gateway Web Handler 处理。在代理前后可以执行多个过滤器。最后代理到具体的服务。</p>
<h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><ul>
<li>Route：Gateway 中的基本元素，它有自己的 ID、URI 、 Predicate 集合和 Filter 集合</li>
<li>Predicate：判断请求的 Url 是否匹配当前的 Route</li>
<li>Filter ：匹配通过之后对请求和响应的处理及修饰</li>
</ul>
<p>Spring-Cloud-Gateway 构建路由的数据流向：</p>
<p><img src="https://oscimg.oschina.net/oscnet/2d7cd3c3fd3452d70112893a4c175943ae0.jpg" alt=""></p>
<p>RouteDefinition 模型是对 Route 模型中 route 的定义以及描述，Spring-Cloud-Gateway 最终会通过RouteDefinition 来构建起 Route 实例信息。其中 RouteDefinition 代码包含两个数组分别是PredicateDefinition，FilterDefinition。</p>
<h3 id="内置的-Predicate"><a href="#内置的-Predicate" class="headerlink" title="内置的 Predicate"></a>内置的 Predicate</h3><p>Spring Cloud Gateway 是通过 Spring WebFlux 的 <code>HandlerMapping</code> 做为底层支持来匹配到转发路由，Spring Cloud Gateway 内置了很多 Predicates 工厂，这些 Predicates 工厂通过不同的 HTTP 请求参数来匹配，多个 Predicates 工厂可以组合使用。下面是内置的Predicates：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>After Route Predicate Factory</td>
<td>此谓词匹配当前日期时间之后发生的请求。</td>
</tr>
<tr>
<td>Before Route Predicate Factory</td>
<td>此谓词匹配在当前日期时间之前发生的请求。</td>
</tr>
<tr>
<td>Between Route Predicate Factory</td>
<td>此谓词匹配datetime1之后和datetime2之前发生的请求。 datetime2参数必须在datetime1之后。</td>
</tr>
<tr>
<td>Cookie Route Predicate Factory</td>
<td>Cookie Route Predicate Factory有两个参数，cookie名称和正则表达式。此谓词匹配具有给定名称且值与正则表达式匹配的cookie。</td>
</tr>
<tr>
<td>Header Route Predicate Factory</td>
<td>Header Route Predicate Factory有两个参数，标题名称和正则表达式。与具有给定名称且值与正则表达式匹配的标头匹配。</td>
</tr>
<tr>
<td>Host Route Predicate Factory</td>
<td>Host Route Predicate Factory采用一个参数：主机名模式。该模式是一种Ant样式模式“.”作为分隔符。此谓词匹配与模式匹配的Host标头。</td>
</tr>
<tr>
<td>Method Route Predicate Factory</td>
<td>Method Route Predicate Factory采用一个参数：要匹配的HTTP方法。</td>
</tr>
<tr>
<td>Path Route Predicate Factory</td>
<td>匹配请求的path</td>
</tr>
<tr>
<td>Query Route Predicate Factory</td>
<td>Query Route Predicate Factory有两个参数：一个必需的参数和一个可选的正则表达式。</td>
</tr>
<tr>
<td>RemoteAddr Route Predicate Factory</td>
<td>RemoteAddr Route Predicate Factory采用CIDR符号（IPv4或IPv6）字符串的列表（最小值为1），例如， 192.168.0.1/16（其中192.168.0.1是IP地址，16是子网掩码）。</td>
</tr>
</tbody>
</table>
<h2 id="工程代码"><a href="#工程代码" class="headerlink" title="工程代码"></a>工程代码</h2><p>本篇将通过一个简单的 gateway 工程来演示如何使用上面的 Predicate 来实现路由。</p>
<h3 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h3><p>这里新建一个 <a href="https://github.com/glmapper/glmapper-cloud-parent" target="_blank" rel="noopener">glmapper-cloud-gateway</a> 工程，具体细节如下</p>
<h3 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h3><p>首先在当前工程的pom文件中引入spring cloud gateway 的依赖：spring-cloud-starter-gateway</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件部分，除了常规的端口，应用名之外；关于spring cloud 的路由规则也可以通过配置文件进行配置，下面先以最简单的 path的方式来演示，最终达到的目标是，当输入：<a href="http://localhost:8866/gateway" target="_blank" rel="noopener">http://localhost:8866/gateway</a> 时，请求信息将会被路由到 <a href="http://localhost:8086/hello" target="_blank" rel="noopener">http://localhost:8086/hello</a>(这个是一个eureka client，对外提供rest服务，工程详见<a href="https://github.com/glmapper/glmapper-cloud-parent/tree/master/glmapper-eureka-provider" target="_blank" rel="noopener">glmapper-eureka-provider</a>)。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span>   <span class="comment">#eureka server 的地址</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8866</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">glmapper-cloud-gateway</span>  <span class="comment">#应用名</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://localhost:8086/hello</span>   <span class="comment">#目标地址</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Path=/gateway</span>   <span class="comment">#路由规则</span></span><br></pre></td></tr></table></figure>
<h3 id="启动应用-amp-验证"><a href="#启动应用-amp-验证" class="headerlink" title="启动应用&amp;验证"></a>启动应用&amp;验证</h3><p>这里直接启动这个工程，SpringCloud Gateway 不需要额外的注解来开启网关服务，所以这里省略启动类的代码。先后启动 glmapper-eureka-server 、glmapper-eureka-provider、glmapper-cloud-gateway。</p>
<p>在浏览器中输入：<a href="http://localhost:8866/gateway" target="_blank" rel="noopener">http://localhost:8866/gateway</a> ，输出的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Glmapper! Now Port is 8086 And hostname is HelloGlmapperService</span><br></pre></td></tr></table></figure>
<p>这里输出的实际上是  <a href="http://localhost:8086/hello" target="_blank" rel="noopener">http://localhost:8086/hello</a> 提供的资源，说明我们的路由规则已经生效。</p>
<h2 id="内置-Predicate-规则配置"><a href="#内置-Predicate-规则配置" class="headerlink" title="内置 Predicate 规则配置"></a>内置 Predicate 规则配置</h2><p>上面已经罗列了所有的 spring cloud gateway 一些内置的 Predicate  ，下面将来使用这些规则来演示下。</p>
<h3 id="时间匹配"><a href="#时间匹配" class="headerlink" title="时间匹配"></a>时间匹配</h3><p>Predicate 支持设置一个时间，在请求进行转发的时候，可以通过判断在这个时间之前或者之后进行转发。在上面的列表中可以看出，基于时间的匹配支持某时间节点之前、之后，还支持介于两个时间之间的某个时间段内的匹配。基于某个时间段内的匹配规则常见的场景是限时抢购。</p>
<ul>
<li>After Route Predicate</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span>    			 <span class="comment">#自定义的路由ID</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://www.glmapper.com</span> <span class="comment">#目标服务地址</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">After=2019-01-10T00:00:00+08:00[Asia/Shanghai]</span> <span class="comment">#通过时间匹配 2019年1月10日</span></span><br></pre></td></tr></table></figure>
<p>After Route Predicate 是指在这个时间之后的请求都转发到目标地址。请求时间在 2019年1月10日日00点00分00秒之后的所有请求都转发到地址 <a href="http://www.glmapper.com。+08:00是指时间和UTC时间相差八个小时，时间地区为" target="_blank" rel="noopener">http://www.glmapper.com。+08:00是指时间和UTC时间相差八个小时，时间地区为</a> Asia/Shanghai。</p>
<ul>
<li>Before Route Predicate</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span>    			 <span class="comment">#自定义的路由ID</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://www.glmapper.com</span> <span class="comment">#目标服务地址</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Before=2019-01-10T00:00:00+08:00[Asia/Shanghai]</span> <span class="comment">#通过时间匹配 2019年1月10日</span></span><br></pre></td></tr></table></figure>
<p>Before Route Predicate 与 After Route Predicate 刚好相反，在某个时间之前的请求的请求都进行转发。</p>
<ul>
<li>Between Route Predicate</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">       - id:</span> <span class="string">glmapper</span>					<span class="comment">#自定义的路由ID</span></span><br><span class="line">       	<span class="attr">uri:</span> <span class="attr">http://www.glmapper.com</span>	<span class="comment">#目标服务地址</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">         -</span> <span class="string">Between=2019-01-10T00:00:00+08:00[Asia/Shanghai],</span> <span class="number">2019</span><span class="bullet">-01</span><span class="bullet">-10</span><span class="attr">T06:00:00+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure>
<p>在2019年1月10 零点至6点之间的请求将会被路由到 <a href="http://www.glmapper.com">http://www.glmapper.com</a> ，其他的请求将不会被路由。</p>
<h3 id="Cookie-或者-Header"><a href="#Cookie-或者-Header" class="headerlink" title="Cookie 或者 Header"></a>Cookie 或者 Header</h3><ul>
<li>Cookie Route Predicate</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://localhost:8086/hello</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Cookie=name,glmapper</span></span><br></pre></td></tr></table></figure>
<p>这里，如果我的请求信息中存在 cookie name 为 glmapper，值匹配到 glmapper 的串，那么请求将会被路由。</p>
<p><img src="https://oscimg.oschina.net/oscnet/05fc182cf12e602fa1e7e467c83d7b31da3.jpg" alt="cookie"></p>
<blockquote>
<p>PS：这里在配置的时候要注意下 routes 后面格式缩进，否则会抛出一些异常，如：</p>
<pre><code>Property: spring.cloud.gateway.routes[0].uri
Value: null
Reason: 不能为null
Property: spring.cloud.gateway.routes[0].predicates
Value: []
Reason: 不能为空
</code></pre></blockquote>
<p>当cookie的值不满足时，访问时404</p>
<p><img src="https://oscimg.oschina.net/oscnet/680e41ff99bcc15910217ba1ec40812d9a6.jpg" alt="cookie404"></p>
<ul>
<li>Header Route Predicate</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">glmapper-cloud-gateway</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://localhost:8086/hello</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br></pre></td></tr></table></figure>
<p>上面这段配置用于配置 Header 中 X-Request-Id值数字的请求：</p>
<p><img src="https://oscimg.oschina.net/oscnet/2a88bdad6acd7902f2415089e943b3390f0.jpg" alt="header"></p>
<p>同样，如果是非数字的话将会返回 404。</p>
<h3 id="域名匹配"><a href="#域名匹配" class="headerlink" title="域名匹配"></a>域名匹配</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">glmapper-cloud-gateway</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://localhost:8086/hello</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Host=**.glmapper.com</span></span><br></pre></td></tr></table></figure>
<p>上面这段配置用于匹配 host 为 xxx.glmapper.com 域名的请求：</p>
<p><img src="https://oscimg.oschina.net/oscnet/b2b68159505c906007107ecd2195bcb7326.jpg" alt="host"></p>
<p>关于其他的内置 Predicate 均可在官方文档中有实例参考，这里就不一一罗列了。</p>
<h3 id="组合匹配"><a href="#组合匹配" class="headerlink" title="组合匹配"></a>组合匹配</h3><p>最后我们来将上面的一些进行组合，假设我需要在 <code>2019.1.10 0点至2019.1.10 6点之间，cookie中带有name=glmapper，header 的 X-Request-Id 为数字，域名是 xx.glmapper.com ，path为 /gateway ，请求方式为GET，参数名为queryParam</code> 的请求路由到 <a href="http://localhost:8086/hello。那么具体配置如下" target="_blank" rel="noopener">http://localhost:8086/hello。那么具体配置如下</a></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">glmapper-cloud-gateway</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">glmapper</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://localhost:8086/hello</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Host=**.glmapper.com</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Path=/gateway</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Method=GET</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Header=X-Request-Id,\d+</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Query=queryParam</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Cookie=name,glmapper</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Between=2019-01-10T00:00:00+08:00[Asia/Shanghai],</span> <span class="number">2019</span><span class="bullet">-01</span><span class="bullet">-10</span><span class="attr">T06:00:00+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure>
<p>还是通过curl 命令来执行以下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/d78beeac5d4959ba1ade7577c0e54ba9489.jpg" alt="composite"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.0.2.RELEASE/single/spring-cloud-gateway.html#gateway-starter" target="_blank" rel="noopener">Spring Cloud Gateway</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2019/01/19/springboot/springcloud-gateway-predicate-project/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
    </div>
    
      <div id="page-nav" class="pagination">
	<a class="extend prev" rel="prev" href="/page/3/">Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/5/">Next</a>
      </div>
    
  </section>

</div>

</div>

  </div>
  </div>



    <!-- BEGIN PRE-FOOTER -->
    <div class="pre-footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN BOTTOM ABOUT BLOCK -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>About Us</h2>
            <p>Computer Lab is a software development and marketing company based in Brooklyn, New York. <br><br> Computer Lab was founded in 2015, and is focused on so on and so forth.</p>
          </div>
          <!-- END BOTTOM ABOUT BLOCK -->

          <!-- BEGIN BOTTOM CONTACTS -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>Contact</h2>
            <address class="margin-bottom-40">
              140 Metropolitan Avenue<br>
              5th Floor<br>
              Brooklyn, NY 11249<br>
              Phone: 716-472-4484<br>
              Email: <a href="mailto:ptsteadman@gmail.com">ptsteadman@gmail.com</a><br>
            </address>
          </div>
          <!-- END BOTTOM CONTACTS -->

	
          <!-- BEGIN TWITTER BLOCK --> 
          <div class="col-md-4 col-sm-6 pre-footer-col">

	  <a data-tweet-limit="1" class="twitter-timeline" href="https://twitter.com/computerlab_" data-widget-id="678830341331820544">Tweets by @computerlab_</a>

	  <script>!function(d,s,id){var
	  js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

          </div>
          <!-- END TWITTER BLOCK -->
	
        </div>
      </div>
    </div>
    <!-- END PRE-FOOTER -->

    <!-- BEGIN FOOTER -->
    <div class="footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN COPYRIGHT -->
          <div class="col-md-6 col-sm-6 padding-top-10">
                  &copy; 2020 glmapper<br>
 <a href="javascript:;">Privacy Policy</a> | <a href="javascript:;">Terms of Service</a>
          </div>
          <!-- END COPYRIGHT -->
	  <!-- BEGIN SOCIAL -->
<div class="col-md-6 col-sm-6">
  <ul class="social-footer list-unstyled list-inline pull-right">
    
      <li><a href="https://github.com/ptsteadman"><i class="fa fa-github"></i></a></li>
    
      <li><a href="https://twitter.com/ptsteadman"><i class="fa fa-twitter"></i></a></li>
    
      <li><a href="https://www.facebook.com/ptsteadman"><i class="fa fa-facebook"></i></a></li>
    
      <li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li>
    
      <li><a href="https://linkedin.com/in/ptsteadman"><i class="fa fa-linkedin"></i></a></li>
    
      <li><a href="http://stackoverflow.com/users/2480493/patrick-steadman"><i class="fa fa-stackoverflow"></i></a></li>
    
  </ul>  
</div>
<!-- END SOCIAL -->

        </div>
      </div>
    </div>
    <!-- END FOOTER -->

  <!-- BEGIN CORE PLUGINS (REQUIRED FOR ALL PAGES) -->
<!--[if lt IE 9]>
<script src="/metronic/assets/plugins/respond.min.js"></script>
<![endif]--> 
<script src="/metronic/assets/plugins/jquery.min.js"></script>
<script src="/metronic/assets/plugins/jquery-migrate.min.js"></script>
<script src="/metronic/assets/plugins/bootstrap/js/bootstrap.min.js"></script>
<script src="/metronic/assets/corporate/scripts/back-to-top.js"></script>
<script src="/metronic/assets/plugins/owl.carousel/owl.carousel.min.js"></script>
<script src="/metronic/assets/corporate/scripts/layout.js"></script>
<script src="/js/wow.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script type="text/javascript">
    jQuery(document).ready(function() {
        Layout.init();    
        Layout.initOWL();
        Layout.initTwitter();
        Layout.initFixHeaderWithPreHeader(); /* Switch On Header Fixing (only if you have pre-header) */
        Layout.initNavScrolling(); 
	new WOW().init();
    });
</script>
<!-- END CORE PLUGINS -->

<!-- BEGIN PAGE-SPECIFIC PLUGINS --> 







<!-- END PAGE-SPECIFIC PLUGINS --> 

<!-- BEGIN INTEGRATIONS -->





<!-- END INTEGRATIONS -->

</body>
</html>
