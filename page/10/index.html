<!DOCTYPE html>
<!--[if IE 8]> <html lang="en" class="ie8 no-js"> <![endif]-->
<!--[if IE 9]> <html lang="en" class="ie9 no-js"> <![endif]-->
<!--[if !IE]><!-->
<html lang="en">
<!--<![endif]-->
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>glmapper</title>

  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <meta name="description" content="从平凡的世界中全身而退">
<meta property="og:type" content="website">
<meta property="og:title" content="glmapper">
<meta property="og:url" content="http://www.glmapper.com/page/10/index.html">
<meta property="og:site_name" content="glmapper">
<meta property="og:description" content="从平凡的世界中全身而退">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="glmapper">
<meta name="twitter:description" content="从平凡的世界中全身而退">
  
    <link rel="alternative" href="/atom.xml" title="glmapper" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
    
  <meta content="{{ title }}" name="description">
  <meta content="{{ title }}" name="keywords">
  <meta content="{{ title }}" name="author">

  <link href="http://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700|PT+Sans+Narrow|Source+Sans+Pro:200,300,400,600,700,900&amp;subset=all" rel="stylesheet" type="text/css">

  <!-- Global styles START -->   
  <link rel="stylesheet" href="/metronic/assets/plugins/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/bootstrap/css/bootstrap.min.css">
  <!-- Global styles END --> 
   
  <!-- Page level plugin styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/animate.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/owl.carousel/assets/owl.carousel.css">
  <!-- Page level plugin styles END -->

  <!-- Theme styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/components.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/slider.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/portfolio.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style-responsive.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/themes/red.css">
  <link rel="stylesheet" href="/css/theme-styles.css">
  <!-- Theme styles END -->
</head>
</html>
<body class="corporate">
  <!-- BEGIN TOP BAR -->
<div class="pre-header">
  <div class="container">
    <div class="row">
      <!-- BEGIN TOP BAR LEFT PART -->
      <div class="col-md-6 col-sm-6 col-xs-9 additional-shop-info">
	<ul class="list-unstyled list-inline">
	  <li><i class="fa fa-phone"></i><span>716-472-4484</span></li>
	  <li><i class="fa fa-envelope-o"></i><span>ptsteadman@gmail.com</span></li>
	</ul>
      </div>
      <!-- END TOP BAR LEFT PART -->
      <!-- BEGIN TOP BAR MENU -->
      <div class="col-md-6 col-sm-6 col-xs-3 additional-nav">
	<ul class="list-unstyled list-inline pull-right">
	  <li><a href="/login">Log In</a></li>
	</ul>
      </div>
      <!-- END TOP BAR MENU -->
    </div>
  </div>        
</div>
<!-- END TOP BAR -->
<!-- BEGIN HEADER -->
<div class="header">
  <div class="container">
    <!--<a class="site-logo" href="/" id="logo">glmapper</a>-->

    <a class="site-logo" href="/">
      <img src="/metronic/assets/corporate/img/logos/logo-corp-red.png" alt="Metronic FrontEnd">
    </a>

    <a href="javascript:void(0);" class="mobi-toggler"><i class="fa fa-bars"></i></a>

    <!-- BEGIN NAVIGATION -->
    <div class="header-navigation pull-right font-transform-inherit">
      <ul>
	
	<li class="">
	  <a href="/">Home</a>
	</li>
	
	<li class="">
	  <a href="/projects/">Projects</a>
	</li>
	
	<li class="">
	  <a href="/archives/">Blog</a>
	</li>
	
	<li class="">
	  <a href="/contact/">Contact</a>
	</li>
	
	<li class="">
	  <a href="/about/">About</a>
	</li>
	
	<!-- BEGIN TOP SEARCH -->
	<li class="menu-search">
	  <span class="sep"></span>
	  <i class="fa fa-search search-btn"></i>
	  <div class="search-box">
	    <form action="#">
	      <div class="input-group">
		<input type="text" placeholder="Search" class="form-control st-default-search-input">
		<span class="input-group-btn">
		  <button class="btn btn-primary" type="submit">Search</button>
		</span>
	      </div>
	    </form>
	  </div> 
	</li>
	<!-- END TOP SEARCH -->
      </ul>
    </div>
    <!-- END NAVIGATION -->
  </div>
</div>
<!-- Header END -->

  
  <div class="container">
    <ul class="breadcrumb">
      <li class="active">Home</li>
    </ul>
  <div id="main">
    <div class="row">

<div class="col-xs-12 blog-posts">


  <section class="archives-wrap">
    <div class="archives">
      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/java-base-hashmap/">从源码来聊一聊hashmap</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T05:51:51.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/java-base-hashmap/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/java/" title="java">java</a>,
  
    <a href="/tags/hash/" title="hash">hash</a>,
  
    <a href="/tags/map/" title="map">map</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p><code>HashMap为什么会是面试中的常客呢？我觉得有以下几点原因：</code><br><br><code>* 考察你阅读源码的能力</code><br><br><code>* 是否了解内部数据结构</code><br><br><code>* 是否了解其存储和查询逻辑</code><br><br><code>* 对非线程安全情况下的使用考虑</code><br><br>前段时间一同事面试蚂蚁金服，就被问到了这个问题；其实很多情况下都是从hashMap,hashTable,ConcurrentHahMap三者之间的关系衍生而出，当然也有直接就针对hashMap原理直接进行考察的。实际上本质都一样，就是为了考察你是否对集合中这些常用集合的原理、实现和使用场景是否清楚。一方面是我们开发中用的多，当然用的人也就多，但是用的好的人却不多（我也用的多，用的也不好）。所以就借此机会（强行蹭一波）再来捋一捋这个HashMap。<br>本文基于jdk1.7.0_80；jdk 1.8之后略有改动，这个后面细说。</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt;</span><br><span class="line">    extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>
<p>hashMap实现了Map、Cloneable、Serializable三个接口，并且继承了AbstractMap这个抽象类。hashTable继承的是Dictionary这个类，同时也实现了Map、Cloneable、Serializable三个接口。</p>
<h2 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h2><ul>
<li>DEFAULT_INITIAL_CAPACITY 默认初始容量 16 （hashtable 是11） 常量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * The default initial capacity - MUST be a power of two.</span><br><span class="line">    * 默认初始容量-必须是2的幂。</span><br><span class="line">    */</span><br><span class="line">   static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br></pre></td></tr></table></figure>
<ul>
<li>MAXIMUM_CAPACITY 默认最大容量 常量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * The maximum capacity, used if a higher value is implicitly specified</span><br><span class="line">     * by either of the constructors with arguments.</span><br><span class="line">     * MUST be a power of two &lt;= 1&lt;&lt;30.</span><br><span class="line">     *如果有一个更大的值被用于构造HashMap,则使用最大值</span><br><span class="line">     */</span><br><span class="line">    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br></pre></td></tr></table></figure>
<ul>
<li>DEFAULT_LOAD_FACTOR 负载因子(默认0.75) 常量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * The load factor used when none specified in constructor.</span><br><span class="line">     * 加载因子，如果构造函数中没有指定，则使用默认的</span><br><span class="line">     */</span><br><span class="line">    static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br></pre></td></tr></table></figure>
<ul>
<li>EMPTY_TABLE 默认的空表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * An empty table instance to share when the table is not inflated.</span><br><span class="line">     * 当表不膨胀时共享的空表实例。</span><br><span class="line">     */</span><br><span class="line">    static final Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>table 表，必要时调整大小。长度必须是两个幂。<br>这个也是hashmap中的核心的存储结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * The table, resized as necessary. Length MUST Always be a power of two.</span><br><span class="line">     */</span><br><span class="line">    transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>size 表示HashMap中存放KV的数量（为链表/树中的KV的总和）</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * The number of key-value mappings contained in this map.</span><br><span class="line">     */</span><br><span class="line">    transient int size;</span><br></pre></td></tr></table></figure>
<ul>
<li>threshold 扩容变量，表示当HashMap的size大于threshold时会执行resize操作。<br>threshold=capacity*loadFactor</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * The next size value at which to resize (capacity * load factor).</span><br><span class="line">     * @serial</span><br><span class="line">     */</span><br><span class="line">    // If table == EMPTY_TABLE then this is the initial capacity at which the</span><br><span class="line">    // table will be created when inflated.</span><br><span class="line">    int threshold;</span><br></pre></td></tr></table></figure>
<ul>
<li>loadFactor 负载因子 负载因子用来衡量HashMap满的程度。loadFactor的默认值为0.75f。计算HashMap的实时装载因子的方法为：size/capacity，而不是占用桶的数量去除以capacity。（桶的概念后续介绍）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The load factor for the hash table.</span><br><span class="line"> *</span><br><span class="line"> * @serial</span><br><span class="line"> */</span><br><span class="line">final float loadFactor;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>modCount<br>这个HashMap的结构修改的次数是那些改变HashMap中的映射数量或修改其内部结构(例如rehash)的那些。这个字段用于使迭代器对HashMap失败快速的集合视图。(见ConcurrentModificationException)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * The number of times this HashMap has been structurally modified</span><br><span class="line">     * Structural modifications are those that change the number of mappings in</span><br><span class="line">     * the HashMap or otherwise modify its internal structure (e.g.,</span><br><span class="line">     * rehash).  This field is used to make iterators on Collection-views of</span><br><span class="line">     * the HashMap fail-fast.  (See ConcurrentModificationException).</span><br><span class="line">     */</span><br><span class="line">    transient int modCount;</span><br></pre></td></tr></table></figure>
</li>
<li><p>hashSeed 与此实例相关联的随机值，用于哈希键的散列代码，使散列冲突更难找到。如果0，那么替代哈希是禁用的。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * A randomizing value associated with this instance that is applied to</span><br><span class="line">     * hash code of keys to make hash collisions harder to find. If 0 then</span><br><span class="line">     * alternative hashing is disabled.</span><br><span class="line">     */</span><br><span class="line">    transient int hashSeed = 0;</span><br></pre></td></tr></table></figure>
<h2 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;</span><br></pre></td></tr></table></figure>
<p>hashmap中是通过使用一个继承自Map中内部类Entry的Entry静态内部类来存储每一个K-V值的。看下具体代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final K key; //键对象</span><br><span class="line">        V value;     //值对象</span><br><span class="line">        Entry&lt;K,V&gt; next; //指向链表中下一个Entry对象，可为null，表示当前Entry对象在链表尾部</span><br><span class="line">        int hash;    //键对象的hash值</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 构造对象</span><br><span class="line">         */</span><br><span class="line">        Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">        * 获取key</span><br><span class="line">        */</span><br><span class="line">        public final K getKey() &#123;</span><br><span class="line">            return key;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">        * 获取value</span><br><span class="line">        */</span><br><span class="line">        public final V getValue() &#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">        * 设置value，这里返回的是oldValue(这个不太明白，哪位大佬清楚的可以留言解释下，非常感谢)</span><br><span class="line">        */</span><br><span class="line">        public final V setValue(V newValue) &#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">        * 重写equals方法</span><br><span class="line">        */</span><br><span class="line">        public final boolean equals(Object o) &#123;</span><br><span class="line">            if (!(o instanceof Map.Entry))</span><br><span class="line">                return false;</span><br><span class="line">            Map.Entry e = (Map.Entry)o;</span><br><span class="line">            Object k1 = getKey();</span><br><span class="line">            Object k2 = e.getKey();</span><br><span class="line">            if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">                Object v1 = getValue();</span><br><span class="line">                Object v2 = e.getValue();</span><br><span class="line">                if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">        * 重写hashCode方法</span><br><span class="line">        */</span><br><span class="line">        public final int hashCode() &#123;</span><br><span class="line">            return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final String toString() &#123;</span><br><span class="line">            return getKey() + &quot;=&quot; + getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * This method is invoked whenever the value in an entry is</span><br><span class="line">         * overwritten by an invocation of put(k,v) for a key k that&apos;s already</span><br><span class="line">         * in the HashMap.</span><br><span class="line">         */</span><br><span class="line">        void recordAccess(HashMap&lt;K,V&gt; m) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * This method is invoked whenever the entry is</span><br><span class="line">         * removed from the table.</span><br><span class="line">         */</span><br><span class="line">        void recordRemoval(HashMap&lt;K,V&gt; m) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>HashMap是一个用于存储Key-Value键值对的集合，每一个键值对也叫做Entry。这些个键值对（Entry）分散存储在一个数组当中，这个数组就是HashMap的主干（也就是上面的table–桶）。<br>看一张图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/3/1601ad77555ecaac?w=557&amp;h=426&amp;f=jpeg&amp;s=31339" alt=""><br>hashmap初始化时各个空间的默认值为null，当插入元素时（具体插入下面分析），根据key值来计算出具体的索引位置，如果重复，则使用尾插入法进行插入后面链表中。</p>
<ul>
<li>尾插法<br><br>之前我是通过插入17条数据来试验的（具体数据数目随意，越大重复的几率越高）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		HashMap&lt;String, Object&gt; map=new HashMap&lt;&gt;();</span><br><span class="line">		for (int i = 0; i &lt; 170; i++) &#123;</span><br><span class="line">			map.put(&quot;key&quot;+i, i);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(map);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/3/1601ada6b59da9f2?w=607&amp;h=358&amp;f=jpeg&amp;s=25069" alt=""><br>通过断点查看next，可以得出我们上面的结论：<br><br>1.索引冲突时会使用链表来存储；<br>2.插入链表的方式是从尾部开始插入的（官方的解释是一般情况下，后来插入的数据被使用的频次较高），这样的话有利于查找。</p>
<h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><p>我们平时在开发是最常用的hashMap中的方法无非就是先创建一个HashMap对象，然后存，接着取；对应的方法就是：</p>
<ul>
<li>构造函数</li>
<li>put函数</li>
<li>get函数</li>
</ul>
<p><strong>构造函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span><br><span class="line">    * capacity and load factor.</span><br><span class="line">    *</span><br><span class="line">    * @param  initialCapacity the initial capacity 指定的初始化容量大小</span><br><span class="line">    * @param  loadFactor      the load factor 指定的负载因子</span><br><span class="line">    * @throws IllegalArgumentException if the initial capacity is negative</span><br><span class="line">    *         or the load factor is nonpositive</span><br><span class="line">    */</span><br><span class="line">   public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">       //如果初始化容量小于0，则抛出异常</span><br><span class="line">       if (initialCapacity &lt; 0)</span><br><span class="line">           throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       //如果初始化容量大于最大容量，则使用默认最大容量</span><br><span class="line">       if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">      //如果负载因子小于0或者非数值类型，则抛出异常</span><br><span class="line">       if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">           throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                              loadFactor);</span><br><span class="line">       //初始化负载因子</span><br><span class="line">       this.loadFactor = loadFactor;</span><br><span class="line">       //初始化threshold</span><br><span class="line">       threshold = initialCapacity;</span><br><span class="line">       //这个初始化方法是个空方法，应该是意在HashMap的子类中由使用者自行重写该方法的具体实现</span><br><span class="line">       init();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>另外两个构造方法实际上都是对上面这个构造方法的调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//只制定默认容量</span><br><span class="line"> public HashMap(int initialCapacity) &#123;</span><br><span class="line">        this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"> //使用HashMap默认的容量大小和负载因子</span><br><span class="line"> public HashMap() &#123;</span><br><span class="line">        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>还有一个是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,</span><br><span class="line">                      DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line"></span><br><span class="line">        putAllForCreate(m);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>构造一个映射关系与指定 Map 相同的新 HashMap。所创建的 HashMap 具有默认加载因子 (0.75) 和足以容纳指定 Map 中映射关系的初始容量。</p>
<p><strong>put方法</strong><br><br><br>首先，我们都知道hashmap中的key是允许为null的，这一点也是面试中最常问到的点。那我先看下为什么可以存null作为key值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        //如果table是空的</span><br><span class="line">        if (table == EMPTY_TABLE) &#123;</span><br><span class="line">            //inflate：扩容/膨胀的意思</span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果key为null 此处敲下桌子，为什么可以存null？</span><br><span class="line">        if (key == null)</span><br><span class="line">            //执行putForNullKey方法，这个方法的作用是如果key为null，就将当前的k-v存放到table[0],即第一个桶。</span><br><span class="line">            return putForNullKey(value);</span><br><span class="line">        //对key进行一次hash运算，获取hash值</span><br><span class="line">        int hash = hash(key);</span><br><span class="line">        //根据key值得hash值和表的长度来计算索引位置</span><br><span class="line">        int i = indexFor(hash, table.length);</span><br><span class="line">        //移动数据，插入数据</span><br><span class="line">        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                //上面Entry中的setValue中也有提到，返回的都是旧的数据</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>hash方法：<br>检索对象哈希代码，并将附加哈希函数应用于结果哈希，该哈希函数防止质量差的哈希函数。 这是至关重要的，因为HashMap使用两个长度的哈希表，否则会碰到hashCode的冲突，这些hashCodes在低位上没有区别。 注意：空键总是映射到散列0，因此索引为0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    final int hash(Object k) &#123;</span><br><span class="line">        int h = hashSeed;</span><br><span class="line">        if (0 != h &amp;&amp; k instanceof String) &#123;</span><br><span class="line">            return sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">        //这个函数确保在每个比特位置上仅以恒定倍数不同</span><br><span class="line">        //的散列码具有有限数量的冲突（在默认加载因子下大约为8）。</span><br><span class="line">        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>冲突具体过程描述：</p>
<ul>
<li>一个空的hashmap表<br><img src="https://user-gold-cdn.xitu.io/2017/12/3/1601b0c8971b8e73?w=459&amp;h=49&amp;f=jpeg&amp;s=4597" alt=""></li>
<li>插入元素，通过hash计算得出索引为3，因为当前3的位置没有元素，因此直接插入进去即可<br><img src="https://user-gold-cdn.xitu.io/2017/12/3/1601b0cb48ff45e3?w=456&amp;h=50&amp;f=jpeg&amp;s=4759" alt=""></li>
<li>再次插入元素，通过hash计算得出索引还是3，发生冲突，则将当前新插入的元素放在原来的已有的元素位置，并将其next指向原来已经存在的元素。<br><img src="https://user-gold-cdn.xitu.io/2017/12/3/1601b0cd89818439?w=467&amp;h=137&amp;f=jpeg&amp;s=10000" alt=""><br><strong>get方法</strong><br><br><br>返回指定键映射到的值;如果此映射不包含键映射，则返回null。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">       //和存null key一样，取的时候也是从table[0]取</span><br><span class="line">       if (key == null)</span><br><span class="line">           return getForNullKey();</span><br><span class="line">       //获取entry</span><br><span class="line">       Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">       return null == entry ? null : entry.getValue();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>getEntry方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">       //size等于0，说明当前hashMap中没有元素，直接返回null（每个entry默认值为null）</span><br><span class="line">       if (size == 0) &#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">       //根据key值计算hash值</span><br><span class="line">       int hash = (key == null) ? 0 : hash(key);</span><br><span class="line">       //通过hash值获取到索引位置，找到对应的桶链进行遍历查找</span><br><span class="line">       for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">            e != null;</span><br><span class="line">            e = e.next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           //如果找到则返回，如果没有链表指针移动到下一个节点继续查找。</span><br><span class="line">           if (e.hash == hash &amp;&amp;</span><br><span class="line">               ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">               return e;</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><p>在前面提到过threshold，扩容变量，表示当HashMap的size大于threshold时会执行resize操作。其计算方式是：threshold=capacity*loadFactor。<br>从上面的式子中我们可以得知hashmap的扩容时机是<strong>当前当前size的值超过容量乘以负载因子时就会触发扩容</strong>。来看下源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">        //如果当前size超过threshold 并且满足桶索引位置不为null的情况下，扩容</span><br><span class="line">        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</span><br><span class="line">           //扩容之后为原来的两倍</span><br><span class="line">            resize(2 * table.length);</span><br><span class="line">            //重新计算hash值</span><br><span class="line">            hash = (null != key) ? hash(key) : 0;</span><br><span class="line">            //重写计算索引</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line">        //执行具体的插入操作</span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">        //先取到当前桶的entry</span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        //将新的数据插入到table[bucketIndex]，再将之前的entry通过链表简介到table[bucketIndex]的next指向；前面的图已经进行了描述。</span><br><span class="line">        table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，扩容并不是在hashmap满了之后才进行的，看下面断点：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/3/1601b56fe116d600?w=845&amp;h=319&amp;f=jpeg&amp;s=35941" alt=""><br>通过默认构造函数new了一个map对象出来，通过for循环插入12条数据，断点到执行结束，我们看到当前table的容量是16，扩容变量threshold为12（16x0.75），现在我们将12改为13.<br><img src="https://user-gold-cdn.xitu.io/2017/12/3/1601b598042d70f2?w=750&amp;h=279&amp;f=jpeg&amp;s=26666" alt=""><br>此时13还是小于16的，但是还是触发了hashmap 的扩容。当前table容量为32（扩容为了之前的两倍），threshold为24（32x0.75），通过这两种图我们得知：</p>
<ul>
<li>每次扩容之后的容量为原有容量的两倍（2n）</li>
<li>触发扩容并不是因为当前hashmap对象已经满了，而是通过threhold扩容变量来控制触发时机的。</li>
<li><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2>本文就单纯的扒了一波源码，并对源码中的注释并结合自己的理解进行了翻译，通过断点调试简单的介绍了尾插法在hashmap的应用。最后通过几张图描述了下hashmap发生索引冲突时的解决方案。hashmap在面试时真的是可深可浅，但是源码的阅读还是很有必要的，下面推荐两篇博客给大家。</li>
<li>1.关于hashmap与hashtable的具体对比可以参考这个博客：<br><br><a href="http://mp.weixin.qq.com/s/wnvpPOQvCgE5vgdnoMpGYw" target="_blank" rel="noopener">HashMap和HashTable到底哪不同？</a><br></li>
<li>2.关于为什么hashmap中的容量必须是2的幂，这篇博客大家可以看下：<br><br><a href="https://juejin.im/post/5a215783f265da431d3c7bba" target="_blank" rel="noopener">什么是hashmap？</a></li>
<li>3.关于hashmap非线程安全的解释<br><br><a href="https://www.cnblogs.com/alexlo/p/4955391.html" target="_blank" rel="noopener">并发安全问题之HashMap</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/java-base-hashmap/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/java-base-one/">一个朋友圈泛型问题引发的“案子”</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T05:50:38.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/java-base-one/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/java/" title="java">java</a>,
  
    <a href="/tags/泛型/" title="泛型">泛型</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>昨天朋友圈问了一个问题：<br>对于下面的list，何如在list添加一个Integer型整数？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure></p>
<p>有这样几种回答：</p>
<ul>
<li>1.不知道（非专业回答）</li>
<li>2.硬塞（非专业回答）</li>
<li>3.把String 改成Integer再添加（违背了问题初衷）</li>
<li>4.把String改成Object，可以加任意类型（违背了问题初衷）</li>
<li>5.String换成通配符</li>
<li>6.反射</li>
</ul>
<p>对于1、2就不说了，属于搞事情的！3、4、5三种方式违背了问题的初衷，如果可以改，那我们直接new三个ArrayList就可以了。6反射，这个是无限接近的，那么这个和反射有什么关系呢？下来看下下面几个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		ArrayList list=new ArrayList();</span><br><span class="line">		</span><br><span class="line">		ArrayList&lt;String&gt; str_list=new ArrayList&lt;String&gt;();</span><br><span class="line">		</span><br><span class="line">		ArrayList&lt;Integer&gt; int_list=new ArrayList&lt;Integer&gt;();</span><br><span class="line">		</span><br><span class="line">		ArrayList&lt;Object&gt; obj_list=new ArrayList&lt;Object&gt;();</span><br><span class="line">		//对象比较</span><br><span class="line">		System.out.println(list == str_list);</span><br><span class="line">		System.out.println(list == int_list);</span><br><span class="line">		System.out.println(list == obj_list);</span><br><span class="line">		</span><br><span class="line">		//对象的运行时class比较</span><br><span class="line">		System.out.println(list.getClass() == str_list.getClass());</span><br><span class="line">		System.out.println(list.getClass() == int_list.getClass());</span><br><span class="line">		System.out.println(list.getClass() == obj_list.getClass());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure></p>
<p>其实上面三个很容易理解，不同对象在内存中的地址肯定是不同的，因此均为false;下面三个均为true?是的，确实为true,这就引出了朋友圈的那个问题。为什么不同的三个对象，他们的getClass是一样的，不应该是有三个不同的hashCode吗？这个其实就是<strong>泛型编译时和运行时的问题</strong>。<br>对于泛型来说，<strong>泛型只在编译阶段有效，编译之后，集合的泛型是去泛型化的；原因：由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的</strong>。<br>因此：java集合中的泛型，是来约束用户的错误输入的，只在编译时有效；<br>在回到问题最初，我们怎么才能将一个Integer对像放入上面定义的list中呢？既然集合中的泛型是编译时有效的，那我我们就可以通过绕过编译的方式进行插入。那么如何绕过编译时的校验呢？答案就是用反射；我们知道JAVA反射机制是指：<br><strong>“在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</strong><br>OK，再来看程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      ArrayList&lt;String&gt; str_list=new ArrayList&lt;String&gt;();</span><br><span class="line">//获取类信息</span><br><span class="line">Class c=str_list.getClass();</span><br><span class="line">//获取add方法</span><br><span class="line">Method m=c.getMethod(&quot;add&quot;, Object.class);</span><br><span class="line">//运行时调用add方法</span><br><span class="line">m.invoke(str_list, 20);</span><br><span class="line">//输出当前str_list</span><br><span class="line">System.out.println(str_list);</span><br></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[20]</span><br></pre></td></tr></table></figure></p>
<p>从结果可以看出，我们完成了在list中添加Integer的任务。<br>【泛型、反射、编译时、运行时】</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/java-base-one/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/alg-one/">算法-排序算法思想及实现</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T05:49:17.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/alg-one/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/算法/" title="算法">算法</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p><code>排序算法主要有：插入排序，选择排序，冒泡排序，希尔排序，归并排序，快速排序，堆排序。这里的排序指的是内部排序，也就是基于内存的排序，基于内存的排序是基于大O模型的，可以使用大O模型来衡量算法的性能</code><br>摘自我自己的博客园：<a href="http://www.cnblogs.com/myadmin/p/5821158.html" target="_blank" rel="noopener">http://www.cnblogs.com/myadmin/p/5821158.html</a> 中的部分排序算法。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>基本思想：每一步都将一个待排数据按其大小插入到已经排序的数据中的适当位置，直到全部插入完毕。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始：4 3 1 2</span><br><span class="line">1)	3 4 1 2</span><br><span class="line">2)	1 3 4 2</span><br><span class="line">3)	1 2 3 4</span><br></pre></td></tr></table></figure>
<p>核心代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 插入排序</span><br><span class="line">     */</span><br><span class="line">    public static int[] insertSort(int[] arr) &#123;</span><br><span class="line">        for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            int index = i;// index当前扫描到的元素下标</span><br><span class="line">            int temp = arr[i];</span><br><span class="line">            // 寻找插入的位置</span><br><span class="line">            while (index &gt; 0 &amp;&amp; temp &lt; arr[index - 1]) &#123;</span><br><span class="line">                arr[index] = arr[index - 1];</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[index] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>基本思想：从所有序列中先找到最小的，然后放到第一个位置。之后再看剩余元素中最小的，放到第二个位置……以此类推，就可以完成整个的排序工作了。可以很清楚的发现，选择排序是固定位置，找元素。相比于插入排序的固定元素找位置，是两种思维方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3 2 1 4 6 5</span><br><span class="line"></span><br><span class="line">初始化索引位置为0 </span><br><span class="line">寻找最小值所在位置交换：1 2 3 4 6 5</span><br><span class="line"></span><br><span class="line">初始化索引位置为1</span><br><span class="line">寻找最小值所在位置交换：1 2 3 4 6 5</span><br><span class="line"></span><br><span class="line">依次类推！</span><br></pre></td></tr></table></figure>
<p>核心代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 选择排序</span><br><span class="line">     */</span><br><span class="line">    public static int[] selectSort(int[] arr) &#123;</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            int minVal = arr[i];</span><br><span class="line">            int index = i;</span><br><span class="line">            for (int j = i + 1; j &lt; arr.length; j++) &#123;// 找到最小元素</span><br><span class="line">                if (arr[j] &lt; minVal) &#123;</span><br><span class="line">                    minVal = arr[j];</span><br><span class="line">                    index = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[index] = arr[i];</span><br><span class="line">            arr[i] = minVal;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>基本思想：原理是临近的数字两两进行比较,按照从小到大或者从大到小的顺序进行交换。<br>核心代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 冒泡排序</span><br><span class="line">     * </span><br><span class="line">     * @param arr</span><br><span class="line">     *            输入的待排数组</span><br><span class="line">     * @return 返回排序号的数组</span><br><span class="line">     */</span><br><span class="line">    public static int[] bubbleSort(int[] arr) &#123;</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">                if (arr[j - 1] &gt; arr[j]) &#123;</span><br><span class="line">                    int temp = arr[j - 1];</span><br><span class="line">                    arr[j - 1] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>基本思想：先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量 =1( &lt; …&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。（下图来自百度图片）</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/11/28/160006ad381ba442?w=430&amp;h=403&amp;f=png&amp;s=199830" alt=""></p>
<p>核心代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 希尔排序</span><br><span class="line"> * </span><br><span class="line"> * @author sgl</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">public class ShellSort &#123;</span><br><span class="line"></span><br><span class="line">    public static int[] shellSort(int[] arr) &#123;</span><br><span class="line">        int step = arr.length / 2;// 初始步长</span><br><span class="line"></span><br><span class="line">        while (1 &lt;= step) &#123;</span><br><span class="line">            for (int i = step; i &lt; arr.length; i++) &#123;</span><br><span class="line">                if (arr[i] &lt; arr[i - step]) &#123;</span><br><span class="line">                    int temp = arr[i];</span><br><span class="line">                    arr[i] = arr[i - step];</span><br><span class="line">                    arr[i - step] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step = step / 2;</span><br><span class="line">            for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">                System.out.print(arr[i]+&quot;,&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>基本思想：将待排序序列R[0…n-1]看成是n个长度为1的有序序列，将相邻的有序表成对归并，得到n/2个长度为2的有序表；将这些有序序列再次归并，得到n/4个长度为4的有序序列；如此反复进行下去，最后得到一个长度为n的有序序列。<br>归并排序其实要做两件事：<br>（1）“分解”——将序列每次折半划分。<br>（2）“合并”——将划分后的序列段两两合并后排序。</p>
<p>核心代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public static int[] sort(int[] nums, int low, int high) &#123;</span><br><span class="line">        int mid = (low + high) / 2;</span><br><span class="line">        if (low &lt; high) &#123;</span><br><span class="line">            sort(nums, low, mid);// 左边</span><br><span class="line">            sort(nums, mid + 1, high);// 右边</span><br><span class="line">            merge(nums, low, mid, high);// 左右归并</span><br><span class="line">        &#125;</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void merge(int[] nums, int low, int mid, int high)           &#123;</span><br><span class="line">        int[] temp = new int[high - low + 1];</span><br><span class="line">        int i = low;// 左指针</span><br><span class="line">        int j = mid + 1;// 右指针</span><br><span class="line">        int k = 0;</span><br><span class="line">        // 把较小的数先移到新数组中</span><br><span class="line">        while (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">            if (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">                temp[k++] = nums[i++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                temp[k++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 把左边剩余的数移入数组</span><br><span class="line">        while (i &lt;= mid) &#123;</span><br><span class="line">            temp[k++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        // 把右边边剩余的数移入数组</span><br><span class="line">        while (j &lt;= high) &#123;</span><br><span class="line">            temp[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        // 把新数组中的数覆盖nums数组</span><br><span class="line">        for (int k2 = 0; k2 &lt; temp.length; k2++) &#123;</span><br><span class="line">            nums[k2 + low] = temp[k2];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>基本思想：快速排序采用的思想是分治思想。<br>快速排序是找出一个元素（理论上可以随便找一个）作为基准,然后对数组进行分区操作,使基准左边元素的值都不大于基准值,基准右边的元素值 都不小于基准值，如此作为基准的元素调整到排序后的正确位置。递归快速排序，将其他n-1个元素也调整到排序后的正确位置。最后每个元素都是在排序后的正 确位置，排序完成。所以快速排序算法的核心算法是分区操作，即如何调整基准的位置以及调整返回基准的最终位置以便分治递归。</p>
<p>核心代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 快速排序</span><br><span class="line"> * </span><br><span class="line"> * @author sgl</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">public class QuickSort &#123;</span><br><span class="line">    static void quicksort(int n[], int left, int right) &#123;</span><br><span class="line">        int dp;</span><br><span class="line">        if (left &lt; right) &#123;</span><br><span class="line">            dp = partition(n, left, right);</span><br><span class="line">            quicksort(n, left, dp - 1);</span><br><span class="line">            quicksort(n, dp + 1, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int partition(int n[], int left, int right) &#123;</span><br><span class="line">        int pivot = n[left];</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            while (left &lt; right &amp;&amp; n[right] &gt;= pivot)</span><br><span class="line">                right--;</span><br><span class="line">            if (left &lt; right)</span><br><span class="line">                n[left++] = n[right];</span><br><span class="line">            while (left &lt; right &amp;&amp; n[left] &lt;= pivot)</span><br><span class="line">                left++;</span><br><span class="line">            if (left &lt; right)</span><br><span class="line">                n[right--] = n[left];</span><br><span class="line">        &#125;</span><br><span class="line">        n[left] = pivot;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/alg-one/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/project-frame-maven-ssm/">基于maven构建多模块化的SSM框架</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T05:48:13.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/project-frame-maven-ssm/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/maven/" title="maven">maven</a>,
  
    <a href="/tags/ssm/" title="ssm">ssm</a>,
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/mybatis/" title="mybatis">mybatis</a>,
  
    <a href="/tags/web/" title="web">web</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>之前写过一篇SSM的框架整合；<a href="https://juejin.im/post/59f3ef5c51882534aa0691b2" target="_blank" rel="noopener">项目开发框架-SSM</a>；对SSM中的一些点进行了学习记录,那篇文章也是基于maven来创建的，那么为什么又要搞一篇呢？以我当前公司项目A来说，A项目包括前台、后台子项目【前台用于对外，后台用于管理】，如果按照前一篇文章的那种方式来进行，我们就需要建立两个单独的框架来进行开发，一样的拥有一套从dmo实体类包，util包，dao包，service包以及controller包，这种结构非常的紧凑和独立，但是问题在于，我们前后台使用的是同一个库，dmo、util、dao以及service中都会存在大量重复的代码，很多基础方法无法公用；另外一个原因是，我们还需要包装一些接口向外提供服务【不局限于我们自己的这两个系统】，这样一来，我们又需要再去抽离一次service，非常不方便。因此就使用maven来构建多模块项目，对于util、dao、rpc服务接口以及service进行模块化分离，这样一来，这些模块就可以对我们自己的前后台以及外部提供一些公关的服务，避免了大量的代码重复，也方便管理。</p>
<p><code>Maven多模块项目，通过合理的模块拆分，实现代码的复用，便于维护和管理。尤其是一些开源框架，也是采用多模块的方式，提供插件集成，用户可以根据需要配置指定的模块。</code></p>
<h1 id="构建多模块化项目"><a href="#构建多模块化项目" class="headerlink" title="构建多模块化项目"></a>构建多模块化项目</h1><p><code>基于maven构建多模块化项目主要依赖于maven可以实现父子项目的关系，子项目可以父项目的依赖Jar包，这样也方便我们去共同管理jar依赖，但是由于一个项目中毕竟会有很多人进行协同开发，在此过程中如果没有很好的约束，对于这种多模块化来说，解决jar包的冲突也很繁琐。</code></p>
<h2 id="新建一个父工程"><a href="#新建一个父工程" class="headerlink" title="新建一个父工程"></a>新建一个父工程</h2><p>1.创建maven项目</p>
<ul>
<li>step1:(新建maven项目)<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd33922055090e?w=522&amp;h=495&amp;f=jpeg&amp;s=27781" alt=""></li>
<li>step2:(勾选创建一个简单工程)<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd339da27c69e2?w=647&amp;h=349&amp;f=jpeg&amp;s=25698" alt=""></li>
<li>step3:(填写工程配置：主要是打包方式要选择pom方式)<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd33a64043c613?w=646&amp;h=609&amp;f=jpeg&amp;s=41840" alt=""><br>点击finish，父项目就创建成功了！<br>2.创建子项目</li>
<li>step1:(右击父项目-&gt;maven-&gt;New Maven Model Project)<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd345841f4595f?w=779&amp;h=549&amp;f=jpeg&amp;s=71841" alt=""></li>
<li>step2:<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd3469ac355dd4?w=641&amp;h=580&amp;f=jpeg&amp;s=37396" alt=""></li>
<li>step3:(一般情况下，我们项目中的util、dao、service都是可以直接分出来的，这里我们选择quickstart来构建,用于生产后面的jar包提供服务。我们的web子项目选择webapp来构建，用于配置文件、jsp文件/ftl/html/js/css等界面资源文件维护)<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd346f632a56de?w=648&amp;h=580&amp;f=jpeg&amp;s=57047" alt=""><br>点击finish，完成子模块的构建！构建之后的项目结构为：<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd34b0b69a6b8f?w=283&amp;h=242&amp;f=jpeg&amp;s=10977" alt=""><br>此时，我们的父模块中已经有了子模块的项目标识，新建的dao模块中不包括webapp此类的文件夹。那么这时就可以将我们的数据访问相关的类和接口都放在这个子模块中，如果其他项目需要使用，我们直接引入就行，引入方式如下（下面截图是从service模块引入dao模块的，这里的groupId，artifactId，version我们可以在dao的pom文件中直接复制使用）：<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd34f0c9671a6d?w=562&amp;h=82&amp;f=jpeg&amp;s=7070" alt=""><br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd34fdf62d1288?w=735&amp;h=289&amp;f=jpeg&amp;s=33325" alt=""><br>（上面新建的过程只作为演示而用，下面的引入和上面的新建项目并非一个项目）<br>其他的模块构建和dao的构建过程是一样的，这里就不一一构建了。源码地址在下面，解压之后，以maven项目方式导入，修改下数据库配置文件应该就可以直接运行了（当前项目基于jdk1.7写的，有的小伙伴如果用1.8的话，应该会出现jsp无法编译的一个错误）；源码附件中还有一个setting文件,阿里的，个人觉得用起来很不错，也推荐给大家!</li>
</ul>
<p>源码地址：<a href="http://download.csdn.net/download/sinat_25518349/10124726" target="_blank" rel="noopener">http://download.csdn.net/download/sinat_25518349/10124726</a><br>【这个是csdn的地址，现在资源上传还必需要选择C币，小伙伴如果没有csdn账户或者C币不足，可以在文章留言区留言，留下邮箱，我发给你们】</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/project-frame-maven-ssm/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/glmapper-bird-two/">多态、接口和抽象类</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T05:47:17.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/glmapper-bird-two/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/java/" title="java">java</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p><code>面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。</code></p>
<p><strong>多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）</strong></p>
<h2 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h2><ul>
<li><p>静态绑定和动态绑定<br><strong>这里所谓的绑定，即一个方法的调用与方法所在的类（方法主体）关联起来。</strong></p>
<p><strong>静态绑定（前期绑定）</strong>：即在程序执行前，即编译的时候已经实现了该方法与所在类的绑定，像C就是静态绑定。<br>  java中只有static，final，private和构造方法是静态绑定，其他的都属于动态绑定，而private的方法其实也是final方法（隐式），而构造               方法其实是一个static方法（隐式），所以可以看出把方法声明为final，第一可以让他不被重写，第二也可以关闭它的动态绑定。</p>
<p><strong>动态绑定（后期绑定）</strong>：运行时根据对象的类型进行绑定，java中的大多数方法都是属于动态绑定，也就是实现多态的基础。<br>  java实现了后期绑定，则必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。 也就是说，编译的时候该方法不与所在类绑定，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。java里实现动态绑定的是JVM.</p>
</li>
</ul>
<p><strong>动态绑定是实现多态的技术，是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</strong></p>
<h2 id="多态的作用"><a href="#多态的作用" class="headerlink" title="多态的作用"></a>多态的作用</h2><p>消除类型之间的耦合关系。即：把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。</p>
<h2 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h2><p>一、要有继承；<br>二、要有重写；<br>三、父类引用指向子类对象。</p>
<h2 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h2><p>1.可替换性（substitutability）。多态对已存在代码具有可替换性。<br>2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。<br>3.接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。<br>4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。<br>5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。</p>
<h2 id="多态的实现方式"><a href="#多态的实现方式" class="headerlink" title="多态的实现方式"></a>多态的实现方式</h2><p>Java中多态的实现方式：</p>
<ul>
<li>接口实现</li>
<li>继承父类进行方法重写</li>
<li>同一个类中进行方法重载。<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2>无论工作还是学习中，笔都是我们经常用到的工具。但是笔的种类又非常的繁多，铅笔、签字笔、水笔、毛笔、钢笔…。现在我们要对“笔”进行抽象，抽象成一个抽象父类“Pen”</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.demo.base;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 抽象父类：笔</span><br><span class="line"> * @author glmapper</span><br><span class="line"> */</span><br><span class="line">public abstract class Pen &#123;</span><br><span class="line">	//笔的长度</span><br><span class="line">	private int length;</span><br><span class="line">	//颜色</span><br><span class="line">	private String color;</span><br><span class="line">	//类型</span><br><span class="line">	private String type;</span><br><span class="line">	//价格</span><br><span class="line">	private double price;</span><br><span class="line">	</span><br><span class="line">	//写字</span><br><span class="line">	public abstract void write(String cnt);</span><br><span class="line">	</span><br><span class="line">	public int getLength() &#123;</span><br><span class="line">		return length;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setLength(int length) &#123;</span><br><span class="line">		this.length = length;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getColor() &#123;</span><br><span class="line">		return color;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setColor(String color) &#123;</span><br><span class="line">		this.color = color;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getType() &#123;</span><br><span class="line">		return type;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setType(String type) &#123;</span><br><span class="line">		this.type = type;</span><br><span class="line">	&#125;</span><br><span class="line">	public double getPrice() &#123;</span><br><span class="line">		return price;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setPrice(double price) &#123;</span><br><span class="line">		this.price = price;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在有两个子类，分别是：铅笔和钢笔。</p>
<p>铅笔类，继承父类Pen，并重写write方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.demo.base;</span><br><span class="line">/**</span><br><span class="line"> * 铅笔类 继承父类 笔（满足必要条件一：有继承【其实如果是接口的话，implement实现也是可以的】）</span><br><span class="line"> * @author glmapper</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Pencil extends Pen&#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 父类的抽象方法委托子类具体实现：覆盖</span><br><span class="line">	 */</span><br><span class="line">	 //满足必要条件二：要有重写【当然，如果是对于write有重载也是可以的，不同的概念而已】</span><br><span class="line">	@Override</span><br><span class="line">	public void write(String cnt) &#123;</span><br><span class="line">		System.out.println(&quot;这是一只铅笔写的内容，内容是：&quot;+cnt);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>钢笔类，继承父类Pen，并重写write方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.demo.base;</span><br><span class="line">/**</span><br><span class="line"> * 钢笔类 继承父类 笔</span><br><span class="line"> * @author 17070738</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Fountainpen extends Pen&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void write(String cnt) &#123;</span><br><span class="line">		System.out.println(&quot;这是一支钢笔写的内容，内容是：&quot;+cnt);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.demo.base;</span><br><span class="line"></span><br><span class="line">public class MainTest &#123;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">	/*	Pen pen= new Pencil();*/</span><br><span class="line">	    //必要条件三：父类引用指向子类对象。</span><br><span class="line">		Pen pen= new Fountainpen();</span><br><span class="line">		pen.write(&quot;我是一支笔&quot;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：这是一支钢笔写的内容，内容是：我是一支笔</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>可替换性：多态对笔Pen类工作，对其他任何子类，如铅笔、钢笔，也同样工作。<br>可扩充性：在实现了铅笔、钢笔的多态基础上，很容易增添“笔”类的多态性。</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>一个Java接口，就是一些方法特征的集合。【本文角度并非是java基础角度来说，主要是以设计模式中的应用为背景，因此对于相关定义及用法请自行学习。<a href="http://www.runoob.com/java/java-interfaces.html】" target="_blank" rel="noopener">http://www.runoob.com/java/java-interfaces.html】</a><br>我们在平时的工作中，提到接口，一般会含有两种不同的含义，</p>
<ul>
<li>指的是java接口，这是一种java语言中存在的结构，有特定的语法和结构</li>
<li>指一个类所具有的方法特征的集合，是一种逻辑上的抽象。</li>
</ul>
<p>前者叫做“java接口”，后者叫着“接口”。例如：java.lang.Runnable就是一个java接口。</p>
<h2 id="为什么使用接口"><a href="#为什么使用接口" class="headerlink" title="为什么使用接口"></a>为什么使用接口</h2><p>我们考虑一下，假如没有接口会怎么样呢？一个类总归是可以通过继承来进行扩展的，这难道不足以我们的实际应用吗？<br>一个对象需要知道其他的一些对象，并且与其他的对象发生相互的作用，这是因为这些对象需要借住于其他对象的行为以便于完成一项工作。这些关于其他对象的知识，以及对其他对象行为的调用，都是使用硬代码写在类里面的，可插入性几乎为0。如：钢笔中需要钢笔水，钢笔水有不同的颜色：<br>钢笔水类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.demo.base;</span><br><span class="line">/**</span><br><span class="line"> * 钢笔墨水</span><br><span class="line"> * @author glmapper</span><br><span class="line"> */</span><br><span class="line">public class PenInk &#123;</span><br><span class="line">	//墨水颜色</span><br><span class="line">	private String inkColor;</span><br><span class="line"></span><br><span class="line">	public String getInkColor() &#123;</span><br><span class="line">		return inkColor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setInkColor(String inkColor) &#123;</span><br><span class="line">		this.inkColor = inkColor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public PenInk(String inkColor) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.inkColor = inkColor;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>钢笔中持有一个墨水类的对象引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.demo.base;</span><br><span class="line">/**</span><br><span class="line"> * 钢笔类 继承父类 笔</span><br><span class="line"> * @author 17070738</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Fountainpen extends Pen&#123;</span><br><span class="line">    //引用持有</span><br><span class="line">	PenInk ink =new PenInk(&quot;black&quot;);</span><br><span class="line">	@Override</span><br><span class="line">	public void write(String cnt) &#123;</span><br><span class="line">		System.out.println(&quot;钢笔墨水颜色是：&quot;+ink.getInkColor());</span><br><span class="line">		System.out.println(&quot;这是一支钢笔写的内容，内容是：&quot;+cnt);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这种时候，我们需要换一种颜色怎么办呢？就必须要对Fountainpen中的代码进行修改，将创建PenInk对象时的inkColor属性进行更改；现在假如我们有一个具体的类，提供某种使用硬代码写在类中的行为；<br>现在，要提供一些类似的行为，并且可以实现动态的可插入，也就是说，要能够动态的决定使用哪一种实现。一种方案就是为这个类提供一个抽象父类，且声明出子类要提供的行为，然后让这个具体类继承自这个抽象父类。同时，为这个抽象父类提供另外一个具体的子类，这个子类以不同的方法实现了父类所声明的行为。客户端可以动态的决定使用哪一个具体的子类，这是否可以提供可插入性呢？<br>改进之后的代码：<br>子类1：黑色墨水<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.demo.base;</span><br><span class="line">/**</span><br><span class="line"> * 黑色墨水</span><br><span class="line"> * @author glmapper</span><br><span class="line"> */</span><br><span class="line">public class BlackInk extends PenInk&#123;</span><br><span class="line"></span><br><span class="line">	public BlackInk() &#123;</span><br><span class="line">		super(&quot;black&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>子类2：蓝色墨水</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.demo.base;</span><br><span class="line">/**</span><br><span class="line"> * 蓝色墨水</span><br><span class="line"> * @author glmapper</span><br><span class="line"> */</span><br><span class="line">public class BlueInk extends PenInk&#123;</span><br><span class="line"></span><br><span class="line">	public BlueInk() &#123;</span><br><span class="line">		super(&quot;blue&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>钢笔类引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.demo.base;</span><br><span class="line">/**</span><br><span class="line"> * 钢笔类 继承父类 笔</span><br><span class="line"> * @author 17070738</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Fountainpen extends Pen&#123;</span><br><span class="line">	PenInk ink ;</span><br><span class="line">	//通过构造函数初始化PenInk ，PenInk由具体子类来实现</span><br><span class="line">	public Fountainpen(PenInk ink) &#123;</span><br><span class="line">		this.ink = ink;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void write(String cnt) &#123;</span><br><span class="line">		System.out.println(&quot;钢笔墨水颜色是：&quot;+ink.getInkColor());</span><br><span class="line">		System.out.println(&quot;这是一支钢笔写的内容，内容是：&quot;+cnt);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		/**</span><br><span class="line">		 * 使用黑色墨水子类</span><br><span class="line">		 */</span><br><span class="line">		Pen pen= new Fountainpen(new BlackInk());</span><br><span class="line">		pen.write(&quot;我是一支笔&quot;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看出，确实可以在简单的情况下提供了动态可插入性。</p>
<p>但是由于java语言是一个单继承的语言，换言之，一个类只能有一个超类，因此，在很多情况下，这个具体类可能已经有了一个超类，这个时候，要给他加上一个新的超类是不可能的。如果硬要做的话，就只好把这个新的超类加到已有的超类上面，形成超超类的情况，如果这个超超类的位置也已经被占用了，就只好继续向上移动，直到移动到类等级结构的最顶端。这样一来，对一个具体类的可插入性设计，就变成了对整个等级结构中所有类的修改。这种还是假设这些超类是我们可以控制的，如果某些超类是由一些软件商提供的，我们无法修改，怎么办呢？因此，假设没有接口，可插入性就没有了保证。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>java接口（以及java抽象类）用来声明一个新的类型。<br>java设计师应当主要使用java接口和抽象类而不是具体类进行变量的类型声明、参数的类型声明、方法的返还类型声明，以及数据类型的转换等。当然，一个更好的做法是仅仅使用java接口，而不要使用抽象java类来做到上面这些。在理想的情况下，一个具体java类应当只实现java接口和抽象类中声明过的方法，而不应该给出多余的方法。</p>
<ul>
<li>类型等级结构<br>java接口（以及抽象类）一般用来作为一个类型的等级结构的起点<br>java的类型是以类型等级结构的方式组织起来的，在一个类型等级结构里面，一个类型可以有一系列的超类型，这时这个类型叫做其超类型的子类型。子类型的关系是传递性：类型甲是类型乙的子类型，类型乙是类型丙的子类型，那么类型甲就是类型丙的子类型。</li>
<li>混合类型<br>如果一个类已经有一个主要的超类型，那么通过实现一个接口，这个类可以拥有另一个次要的超类型。这种次要的超类型就叫做混合类型。例如：在java中，<br><img src="https://user-gold-cdn.xitu.io/2017/11/17/15fc7f7b4eacb5bd?w=569&amp;h=60&amp;f=png&amp;s=4293" alt=""></li>
</ul>
<p>TreeMap类有多个类型，它的主要类型是AbstractMap,这是一种java的聚集；而Cloneable接口则给出了一个次要类型，这个类型说明当前类的对象是可以被克隆；同时Serializable也是一个次要类型，它表明当前类的对象是可以被序列化的。而NavigableMap继承了SortedMap,因为之前说到过，子类型是可以传递的，因此对于TreeMap来说，SortedMap（或者说NavigableMap）表明这个聚集类是可以排序的。</p>
<h2 id="接口的一些用法"><a href="#接口的一些用法" class="headerlink" title="接口的一些用法"></a>接口的一些用法</h2><ul>
<li><p>单接口方法：接口中只有一个方法；java语言中有很多但方法接口的使用，Runnalble接口中的run（）方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface Runnable &#123;</span><br><span class="line">    /**</span><br><span class="line">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span><br><span class="line">     * to create a thread, starting the thread causes the object&apos;s</span><br><span class="line">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span><br><span class="line">     * thread.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span><br><span class="line">     * take any action whatsoever.</span><br><span class="line">     *</span><br><span class="line">     * @see     java.lang.Thread#run()</span><br><span class="line">     */</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>标识接口：没有任何方法和属性的接口；标识接口不对实现它的类有任何语义上的要求，仅仅是表明实现该接口的类属于一个特定的类型。上面说到的Serializable接口就是一种标识接口。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>常量接口：用java接口来声明一些常量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.glmapper.demo.base;</span><br><span class="line"></span><br><span class="line">public interface MyConstants &#123;</span><br><span class="line">	public static final String USER_NAME=&quot;admin&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样一来，凡是实现这个接口的类都会自动继承这些常量，并且都可以像使用自己的常量一样，不需要再用MyConstants.USER_NAME来使用。</p>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>在java语言里面，类有两种，一种是具体类，一种是抽象类。在上面给出的代码中，使用absract修饰的类为抽象类。没有被abstract修饰的类是具体类。抽象类通常代表一个抽象概念，它提供一个继承的出发点。而具体类则不同，具体类可以被实例化，应当给出一个有逻辑实现的对象模板。由于抽象类不可以被实例化，因此一个程序员设计一个新的抽象类，一定是用来被继承的。（不建议使用具体类来进行相关的继承）。</p>
<h2 id="关于代码重构"><a href="#关于代码重构" class="headerlink" title="关于代码重构"></a>关于代码重构</h2><p>假设有两个具体类，类A和类B，类B是类A的子类，那么一个比较简单的方案应该是建立一个抽象类（或者java接口），暂定为C，然后让类A和类B成为抽象类C的子类【没有使用UML的方式来绘制，请见谅哈】。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/11/17/15fc8d2c928e38c6?w=627&amp;h=207&amp;f=png&amp;s=61903" alt=""><br>上面其实就是里氏替换原则，后面会具体介绍到的。这种重构之后，我们需要做的就是如何处理类A和类B的共同代码和共同数据。下面给出相关准则。</p>
<ul>
<li>抽象类应当拥有尽可能多的共同代码</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2017/11/17/15fc8dfab440eee6?w=793&amp;h=538&amp;f=png&amp;s=188139" alt=""><br>在一个继承等级结构中，共同的代码应当尽量向结构的顶层移动，将重复的代码从子类中抽离，放在抽象父类中，提高代码的复用率。这样做的另外一个好处是，在代码发生改变时，我们只需要修改一个地方【因为共同代码均在父类中】。</p>
<ul>
<li>抽象类应当拥有尽可能少的数据<br>数据的移动方向是从抽象类到具体类，也就是从继承等级的顶层到底层的移动。我们知道，一个对象的数据不论是否使用都会占用资源，因此数据应当尽量放到具体类或者继承等级结构的低端。</li>
</ul>
<h2 id="Has-A-与Is-A"><a href="#Has-A-与Is-A" class="headerlink" title="Has - A 与Is -A"></a>Has - A 与Is -A</h2><p>当一个类是另外一个类的角色时【我  有一个 玩具】，这种关系就不应当使用继承来描述了，这个将会在后面说到的“合成/聚合复用原则”来描述。<br>Has - A: 我有一只笔（聚合）<br>Is - A:钢笔是一种笔（继承）</p>
<h2 id="关于子类扩展父类的责任"><a href="#关于子类扩展父类的责任" class="headerlink" title="关于子类扩展父类的责任"></a>关于子类扩展父类的责任</h2><p>子类应当扩展父类的职责，而不是置换掉或者覆盖掉超类的职责。如果一个子类需要将继承自父类的责任取消或者置换后才能使用的话，就很有可能说明这个子类根本不属于当前父类的子类，存在设计上的缺陷。</p>
<p>最后，说明下，我们在平时的工作中会经常使用的工具类，再次特地申明一下，我们也尽可能少的去从工具类进行继承扩展。</p>
<p>参考：</p>
<ul>
<li>《Java与模式》电子工业出版社出版，作者：阎宏。</li>
<li><a href="http://www.runoob.com/java/java-interfaces.html" target="_blank" rel="noopener">http://www.runoob.com/java/java-interfaces.html</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/glmapper-bird-two/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/glmapper-bird-one/">面向对象的四大基础特性</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T05:46:32.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/glmapper-bird-one/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/java/" title="java">java</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>按照之前的学习规划，开始进行第一部分的学习。那么今天就重新认识一下JAVA中的四大特性：抽象、封装、继承、多态</p>
<h1 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h1><p>学习面向对象，抽象还是很重要的。面向对象最接近我们人类的思维，你的抽象能力就是你对万物万事总结和归纳的能力。关于抽象，就是从具体事物抽出、概括出它们共同的方面、本质属性与关系等，而将个别的、非本质的方面、属性与关系舍弃，这种思维过程，称为抽象。在JAVA中表现就是使用abstract来修饰类，被abstract修饰的类成为抽象类，一般是为了为子类提供一些共有的属性和行为，不同的子类根据自身的特性再进行具体的行为实现。</p>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>封装是面向对象的重要原则，就是把对象的属性和行为（方法）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节；在java中，对于对象的内部属性一般用private来实现隐藏，并通过set和get方法对外提供访问接口。封装实际上是一种信息隐藏技术的实现方式。</p>
<ul>
<li>对象的数据封装特性彻底消除了传统结构方法中数据与操作分离所带来的种种问题，提高了程序的可复用性和可维护性，降低了程序员保持数据与操作内容的负担。</li>
<li>对象的数据封装特性还可以把对象的私有数据和公共数据分离开，保护了私有数据，减少了可能的模块间干扰，达到降低程序复杂性、提高可控性的目的。</li>
</ul>
<p>例如：对于客观存在的人这个对象进行属性和行为抽象【此处仅仅是部分抽象】；使用private关键字来修饰人的属性，并通过对应的set和get方法对外界提供访问入口；在行为方面，通过public关键字来修饰，对外提供具体的行为描述。外界对象并不知道“人”这个对象在内部发生了什么，仅仅是通过提供的方法来获得具体的描述信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 人</span><br><span class="line"> * @author glmapper</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Person &#123;</span><br><span class="line">	//姓名</span><br><span class="line">	private String name;</span><br><span class="line">	//年龄</span><br><span class="line">	private int age;</span><br><span class="line">	//性别</span><br><span class="line">	private String sex;</span><br><span class="line">	//身高</span><br><span class="line">	private float high;</span><br><span class="line">	//体重</span><br><span class="line">	private float weight;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	public int getAge() &#123;</span><br><span class="line">		return age;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setAge(int age) &#123;</span><br><span class="line">		this.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getSex() &#123;</span><br><span class="line">		return sex;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setSex(String sex) &#123;</span><br><span class="line">		this.sex = sex;</span><br><span class="line">	&#125;</span><br><span class="line">	public float getHigh() &#123;</span><br><span class="line">		return high;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setHigh(float high) &#123;</span><br><span class="line">		this.high = high;</span><br><span class="line">	&#125;</span><br><span class="line">	public float getWeight() &#123;</span><br><span class="line">		return weight;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setWeight(float weight) &#123;</span><br><span class="line">		this.weight = weight;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	public void eat()&#123;</span><br><span class="line">		System.out.println(&quot;吃东西&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void walk()&#123;</span><br><span class="line">		System.out.println(&quot;走路&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void study()&#123;</span><br><span class="line">		System.out.println(&quot;学习&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承是面向对象最显著的一个特性，是从已有的类中派生出新的类，我们把它称之为子类，子类继承父类的属性和行为，并能根据自己的需求扩展出新的属性和行为，提高了代码的可复用性。 </p>
<ul>
<li>提高了代码的复用性。</li>
<li>让类与类之间产生了关系，给第三个特征多态提供了前提。</li>
</ul>
<p>Java的继承通过extends关键字来实现，实现继承的类被称为子类，被继承的类称为父类(有的也称其为基类、超类)，父类和子类的关系，是一种一般和特殊的关系；子类扩展父类，将可以获得父类的全部属性和方法。</p>
<p>男人是人的一种，男人的特征是有胡子，因此也有剪胡子的行为【有胡子和剪胡子并非依赖关系；一个是属性，一个是行为】；但是男人继承了人这个父类，因此，男人也具有例如姓名、性别、身高、体重等属性，同时也具有父类人具有的吃饭、走路和学习的行为。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 男人</span><br><span class="line"> * @author glmapper</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Man extends Person&#123;</span><br><span class="line">	//胡子</span><br><span class="line">	private String  goatee;</span><br><span class="line">	</span><br><span class="line">	public String getGoatee() &#123;</span><br><span class="line">		return goatee;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setGoatee(String goatee) &#123;</span><br><span class="line">		this.goatee = goatee;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void shaved()&#123;</span><br><span class="line">		System.out.println(&quot;剪胡子&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重写父类的方法：<br>大部分的时候，子类总是以父类为基础，额外添加新的属性和方法。但有一种情况例外：子类需要重写父类的方法。例如男人吃东西比较快，女人吃东西比较慢，因此对于eat方法来说，Man可以覆盖父类的eat方法，来描述Man本身的特点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void eat()&#123;</span><br><span class="line">	System.out.println(&quot;快速的吃东西&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当子父类中出现相同方法时，会先运行子类中的方法。<br>重写的特点：方法名一样，访问修饰符权限不小于父类，返回类型一致，参数列表一致。</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）<br>实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。从语言特点上来说，Java引用变量有两个类型：一个是编译时类型，一个是运行时类型。编译时的类型由声明该变量时使用的类型决定，运行时的类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，就会出现所谓的多态（Polymorphism）。<br>封装和继承都是为Java语言的多态提供了支撑；多态存在的三个必要条件：</p>
<ul>
<li>要有继承；</li>
<li>要有重写；</li>
<li>父类引用指向子类对象。</li>
</ul>
<p>具体的实现方式就是：接口实现，继承父类进行方法重写，同一个类中进行方法重载。</p>
<p>下一篇在说类和接口的时候再用具体的例子来描述覆盖、重载。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/glmapper-bird-one/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/glmapper-bird-overall/">菜鸟成长系列-概述</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T05:44:00.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/glmapper-bird-overall/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/规划/" title="规划">规划</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为渣硕一枚，毕业时一线互联网公司招聘基本没有参与过，等回过神准备参加，春招都快结束了【17年毕业】；跌跌撞撞面了几家公司，虽然被虐，但是基本上都给了Offer，几番比较之后到了苏宁，选择做一枚金融码农。虽然网上关于在苏宁做IT有着不同的看法，有好有坏，褒贬不一，但就我而言，作为新人，苏宁还是给我提供了不错的工作和学习环境【入职快4个月了】。<br>言归正传，作为一个初入职场的新人，面对很多复杂的业务场景，不同的开源技术的使用，一开始确实有点“慌”，但是随着慢慢的渗入，从能够将一个项目成功跑起来，到对着详设给代码加注释，到自己去画某一条业务线的流程图，到第一次独立完成一个需求，再到不断的去发现现有框架或者业务逻辑中的问题并去尝试优化；这个过程还是很“吃鸡”的。技术始终是来支撑业务的，熟悉产品很重要，只有深入了解了某一个业务，然后拓展出与其他业务的关系，这样才可以发现问题，找到切入点去做具体的代码优化和业务优化。所以人人都是产品经理这句话很中肯，特别是程序员，要学会和产品经理“讨价还价”。</p>
<h1 id="为什么要写"><a href="#为什么要写" class="headerlink" title="为什么要写"></a>为什么要写</h1><p>为什么要写，最开始的想法就是把自己工作中的问题和坑记录下来，以便于自己不会再调到坑里面去。但是后来发现跑偏了，在没有具体深入了解的情况下开始“借鉴”+“总结”。后来再去看，该不会的还是不会，这就很无奈。<br>网上有很多什么“JAVA学习路线一览”、“数据库学习路线一览”，“Spring学习路线一览”。。。，实话实说，尝试过，但是都失败了，走不下去。比如说我想学习java集合，然后就去看，去总结，然后就会发现，线程安全和不安全在集合里面的比较很多，然后就去看线程安全相关，然后再走，就会发现从这个坑跳到了另外一个坑，一方面是没有足够的时间去研究，另一方面没有把自己的思维放进去，结果就是学到的还是很碎的东西。因此放弃别人的成功之路，回来走自己的独木桥。结合自己之前的一些技术积累和实际工作的需求，来整合。<br>看了很多，却发现深入的不多。一开始想的是从java的Object开始写，但是当我去尝试一次之后就放弃了【其实从java基础类库学还是很不错的】；我觉得不适合我这种不按套路出牌的人，因此就给自己定了一个框，在框里学。这个框是什么呢？就是设计模式。<br>无论是java基础类库的设计还是Spring体系的设计基本都离不开设计模式的使用，为什么说不从Object开始，不从Spring的启动开始就是因为当我顺着一条线开始走的时候，就会牵扯出无数条线，直到不知道去往哪一条开始。只有当前站在顶层去看整体的时候，才会对全局有一个把握，才能直到不同分支的关系，才能更好的学抓细节。</p>
<h1 id="写什么"><a href="#写什么" class="headerlink" title="写什么"></a>写什么</h1><p>我的想法是以设计模式为主线来贯穿，开始重新学习。【从java语言的角度】<br>设计模式中基本上都是围绕六种设计原则来约束的，再利用JAVA中提供抽象、继承、多态提供的机制来进行具体的实现。顺着这个思路简单罗列下我自己的学习路线：<br>因为需要使用JAVA，那么就必须先要对抽象、继承和多态有一个比较清楚的理解，因此第一部分将会从java语言本身的特色来学习，主要包括：</p>
<ul>
<li>1.抽象，继承，多态的理解</li>
<li>2.类和接口</li>
<li>3.面向接口编程的理解<br>OK，到此就收，第一部分就把后面设计模式中我们需要用的方式的基础定了个基调。<br>第二部分就直接进入设计模式范畴之内：</li>
<li>1.设计原则</li>
<li>2.创建型</li>
<li>3.结构型</li>
<li>4.行为型<br>在学习某个具体的设计模式的时候会结合java语言中某些类库来讨论，穿插学习；<br>第二部分之后，对于设计模式、设计模式在java中的应用、Spring的顶层设计以及java中的一些类库会有一个大体的掌握。这个部分会需要很长时间，会涉及到的知识点会很多，有点慌。<br>第三部分开始数据结构，为什么是数据结构而不是并发或者数据库呢。一方面在java中很多关于并发的问题都会涉及到集合的使用，集合内部就依赖于不同的数据结构；数据库方面，如果都不清楚数据库是怎么存数据的，就不可能知道怎么去优化；如果都不知道数据库中的数据的存储结构是什么，又怎么能知道数据是怎么存的呢？<br>上面三个部分结束之后，关于java差不多也就结束了。那么作为一个程序员，对于网络理解和开源技术的使用才是真正快速解决实际问题和吃饭问题的根本。<br>spring、mybatis、redis，struts2,hibernate,以及相关rpc框架。<br>关于java虚拟机这个东西不会单独的写了，感觉写不出来，等有了实际的经验积累之后再去谈吧。。。<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1>其实我们每个人每天都会有想法，好坏不说，要去试试，这篇文章写完之后我也不知道自己能走到哪个部分，但是还是回去尝试走一走。我也不知道这种学习的“野路子”适合不适合，但是就现在【2017.11.5 11:59】看，我觉得对我是可以的。</li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/glmapper-bird-overall/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/project-frame-ssm/">项目开发框架-SSM</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T05:41:24.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/project-frame-ssm/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/ssm/" title="ssm">ssm</a>,
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/mybatis/" title="mybatis">mybatis</a>,
  
    <a href="/tags/web/" title="web">web</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<h1 id="1-Spring"><a href="#1-Spring" class="headerlink" title="1.Spring"></a>1.Spring</h1><p>无需多言，作为开源届数一数二的典例，项目开发中无处不在；<br>核心IOC容器，用来装载bean（java中的类）-用Spring的IOC容器来管理Bean的生命周期，有了这样一种机制，我们就可以不用在代码中去重复的做new操作。<br>aop，面向切面编程，spring中最主要的是用于事务方面的使用。</p>
<h1 id="2-Spring-MVC"><a href="#2-Spring-MVC" class="headerlink" title="2.Spring MVC"></a>2.Spring MVC</h1><p>作用于web层，相当于controller，与struts中的action一样，都是用来处理用户请求的。同时，相比于struts2来说，更加细粒度，它是基于方法层面的，而struts是基于类层面的。<br><img src="https://user-gold-cdn.xitu.io/2017/10/28/ab2648fd768293a6fa61959ba1dbbc40" alt=""></p>
<h1 id="3-MyBatis"><a href="#3-MyBatis" class="headerlink" title="3.MyBatis"></a>3.MyBatis</h1><p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。[来自：<a href="http://www.mybatis.org/mybatis-3/zh/index.html]" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/zh/index.html]</a></p>
<p><strong>他人总结</strong></p>
<ul>
<li>Hibernate功能强大，数据库无关性好，O/R映射能力强，如果你对Hibernate相当精通，而且对Hibernate进行了适当的封装，那么你的项目整个持久层代码会相当简单，需要写的代码很少，开发速度很快，非常爽。 </li>
<li>Hibernate的缺点就是学习门槛不低，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡取得平衡，以及怎样用好Hibernate方面需要你的经验和能力都很强才行。 </li>
<li>MYBATIS入门简单，即学即用，提供了数据库查询的自动对象绑定功能，而且延续了很好的SQL使用经验，对于没有那么高的对象模型要求的项目来说，相当完美。 </li>
<li>MYBATIS的缺点就是框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。<h1 id="4-SSM框架整合"><a href="#4-SSM框架整合" class="headerlink" title="4.SSM框架整合"></a>4.SSM框架整合</h1>本项目将以购物为背景，主要包括商品信息及库存【因为想顺便学习一下事务的处理】、订单信息。下面将从数据库创建、项目结构说明、配置文件、业务代码等方面进行一步步说明。<h2 id="4-1-数据库创建"><a href="#4-1-数据库创建" class="headerlink" title="4.1 数据库创建"></a>4.1 数据库创建</h2>1.商品表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `goods` (</span><br><span class="line">  `goods_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;商品ID&apos;,</span><br><span class="line">  `goodsname` varchar(100) NOT NULL COMMENT &apos;商品名称&apos;,</span><br><span class="line">  `number` int(11) NOT NULL COMMENT &apos;商品库存&apos;,</span><br><span class="line">   PRIMARY KEY (`goods_id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8 COMMENT=&apos;商品表&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>初始化表数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `goods` (`goods_id`, `goodsname`, `number`)</span><br><span class="line">VALUES (1001, &apos;SN卫衣&apos;, 15)</span><br></pre></td></tr></table></figure></p>
<p>2.订单表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `orderinfo` (</span><br><span class="line">  `order_id` varchar(20) NOT NULL COMMENT &apos;订单编号&apos;,</span><br><span class="line">  `goods_id` bigint(18) NOT NULL COMMENT &apos;商品ID&apos;,</span><br><span class="line">  `user_id` bigint(10) NOT NULL COMMENT &apos;用户ID&apos;,</span><br><span class="line">  `order_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &apos;下单时间&apos; ,</span><br><span class="line">   PRIMARY KEY (`order_id`),</span><br><span class="line">   INDEX `idx_order_id` (`order_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;订单表&apos;</span><br></pre></td></tr></table></figure></p>
<p>OK，至此表结构及初始化数据构建完成，下面说下基于Mavan的项目结构。</p>
<h2 id="项目结构说明"><a href="#项目结构说明" class="headerlink" title="项目结构说明"></a>项目结构说明</h2><p>因为项目是使用maven来管理jar包的，先来贴一下，pom.xml的配置</p>
<ul>
<li>pom.xml<br>为了避免学习小伙伴崇尚拿来主义【也就是去除了xmlns之类的东西】，这里只放项目依赖的jar包的dependencies；本案例将本着“需则用”的原则，避免在网上看到的各种乱七八糟的依赖都丢进来的情况，造成资源浪费和干扰阅读。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">		&lt;!-- 单元测试 --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 1.日志 slf4j--&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;1.1.1&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 2.数据库连接驱动 --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;5.1.37&lt;/version&gt;</span><br><span class="line">			&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!-- 2.数据库连接池 --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;c3p0&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;c3p0&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;0.9.1.2&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 3.MyBatis 以及 spring-mybatis --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 4.Servlet 相关依赖 --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;taglibs&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;standard&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;1.1.2&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;jstl&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;jstl&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;2.5.4&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 5.Spring --&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;!-- 5.1 Spring核心 ：core bean context --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!-- 5.2 Spring jdbc依赖，事务依赖 --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-tx&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!-- 5.3 Spring web依赖&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!-- 5.4 Spring test --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 6.redis客户端:Jedis【不使用的话可以直接去除】 --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;protostuff-core&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;1.0.8&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;protostuff-runtime&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;1.0.8&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 7.工具类 --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;3.2&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">	&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>*项目结构图</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/28/2c7ad9c13a987f35dec09b1aa58d8eb8" alt=""><br><em>src/test/java：用于junit的测试类
</em>src/main/java:<br>   dao:数据库处理<br>   service:业务处理<br>   enums:项目枚举<br>   mapper:dao中方法对应mybatis映射文件，Sql就在这里面<br>   web：控制器，controller<br>   entity:项目中的实体类，如：商品类和订单类</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li>jdbc.properties<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://serverName:port/dbname?useUnicode=true&amp;characterEncoding=utf8</span><br><span class="line">jdbc.username=[填写自己的数据库用户名]</span><br><span class="line">jdbc.password=[填写自己的数据库登录密码]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>logback.xml<br>这里直接用的是控制台输出，如果是生产环境，可以根据具体的需求进行配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;configuration debug=&quot;true&quot;&gt;</span><br><span class="line">	&lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">	 ch.qos.logback.classic.encoder.PatternLayoutEncoder --&gt;</span><br><span class="line">		&lt;encoder&gt;</span><br><span class="line">			&lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;</span><br><span class="line">		&lt;/encoder&gt;</span><br><span class="line">	&lt;/appender&gt;</span><br><span class="line">	&lt;root level=&quot;debug&quot;&gt;</span><br><span class="line">		&lt;appender-ref ref=&quot;STDOUT&quot; /&gt;</span><br><span class="line">	&lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>mybatis-config<br>这里主要是MyBaties全局配置文件的配置，可以将一些类的别名、主键自增配置、驼峰命名规则配置等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">	&lt;!-- 配置全局属性 --&gt;</span><br><span class="line">	&lt;settings&gt;</span><br><span class="line">		&lt;!-- 使用jdbc的getGeneratedKeys获取数据库自增主键值 --&gt;</span><br><span class="line">		&lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot; /&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 使用列别名替换列名 默认:true --&gt;</span><br><span class="line">		&lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot; /&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 开启驼峰命名转换:Table&#123;create_time&#125; -&gt; Entity&#123;createTime&#125; --&gt;</span><br><span class="line">		&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">	&lt;/settings&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>spring 相关配置文件<br>为了更加清晰的了解spring各个组件的作用，这里将数据源的配置、事务配置和视图解析器的配置分开来。<br><strong>spring-dao.xml</strong><br>这里面主要就是spring配置整合mybatis的具体过程，具体包括：<br>1.引入数据库配置文件<br>2.配置数据源【数据库连接池】<br>3.配置SqlSessionFactory对象<br>4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 1.配置数据库相关参数properties的属性：$&#123;url&#125; --&gt;</span><br><span class="line">&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 2.数据库连接池 --&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">	&lt;!-- 配置连接池属性 --&gt;</span><br><span class="line">	&lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- c3p0连接池的私有属性 --&gt;</span><br><span class="line">	&lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot; /&gt;</span><br><span class="line">	&lt;!-- 关闭连接后不自动commit --&gt;</span><br><span class="line">	&lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">	&lt;!-- 获取连接超时时间 --&gt;</span><br><span class="line">	&lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot; /&gt;</span><br><span class="line">	&lt;!-- 当获取连接失败重试次数 --&gt;</span><br><span class="line">	&lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 3.配置SqlSessionFactory对象 --&gt;</span><br><span class="line">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">	&lt;!-- 注入数据库连接池 --&gt;</span><br><span class="line">	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">	&lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;</span><br><span class="line">	&lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot; /&gt;</span><br><span class="line">	&lt;!-- 扫描entity包 使用别名 --&gt;</span><br><span class="line">	&lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.glmapper.framerwork.entity&quot; /&gt;</span><br><span class="line">	&lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt;</span><br><span class="line">	&lt;property name=&quot;mapperLocations&quot; value=&quot;com.glmapper.framerwork.mapper/*.xml&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt;</span><br><span class="line">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">	&lt;!-- 注入sqlSessionFactory --&gt;</span><br><span class="line">	&lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt;</span><br><span class="line">	&lt;!-- 给出需要扫描Dao接口包 --&gt;</span><br><span class="line">	&lt;property name=&quot;basePackage&quot; value=&quot;com.glmapper.framerwork.dao&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>spring-service<br>实际的开发过程中事务一般都是在service层进行操作。因此用一个单独的spring-service.xml来进行事务的相关的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   &lt;!-- 扫描service包下所有使用注解的类型 --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.glmapper.framerwork.service&quot; /&gt;</span><br><span class="line">&lt;!-- 配置事务管理器 --&gt;</span><br><span class="line">&lt;bean id=&quot;transactionManager&quot;</span><br><span class="line">	class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">	&lt;!-- 注入数据库连接池 --&gt;</span><br><span class="line">	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 配置基于注解的声明式事务 --&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>spring-web.xml<br>配置SpringMVC；需要说明一下，一般我们在实际的开发过程中，会配置json2map解析。这里没有用到就不贴出来，读者可以自行网上搜索一波。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 1.开启SpringMVC注解模式 --&gt;</span><br><span class="line">&lt;mvc:annotation-driven /&gt;</span><br><span class="line">&lt;!-- 2.静态资源默认servlet配置</span><br><span class="line">	(1)加入对静态资源的处理：js,css,图片等</span><br><span class="line">	(2)允许使用&quot;/&quot;做整体映射</span><br><span class="line"> --&gt;</span><br><span class="line"> &lt;mvc:default-servlet-handler/&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;!-- 3.配置视图解析器ViewResolver --&gt;</span><br><span class="line"> &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line"> 	&lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;</span><br><span class="line"> 	&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;</span><br><span class="line"> 	&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;</span><br><span class="line"> &lt;/bean&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;!-- 4.扫描web相关的bean --&gt;</span><br><span class="line"> &lt;context:component-scan base-package=&quot;com.glmapper.framerwork.web&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>web.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 编码过滤器 --&gt;  </span><br><span class="line">    &lt;filter&gt;  </span><br><span class="line">        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;  </span><br><span class="line">        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;  </span><br><span class="line">        &lt;async-supported&gt;true&lt;/async-supported&gt;  </span><br><span class="line">        &lt;init-param&gt;  </span><br><span class="line">            &lt;param-name&gt;encoding&lt;/param-name&gt;  </span><br><span class="line">            &lt;param-value&gt;UTF-8&lt;/param-value&gt;  </span><br><span class="line">        &lt;/init-param&gt;  </span><br><span class="line">    &lt;/filter&gt;  </span><br><span class="line">    &lt;filter-mapping&gt;  </span><br><span class="line">        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;  </span><br><span class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  </span><br><span class="line">    &lt;/filter-mapping&gt;  </span><br><span class="line">     &lt;!-- Spring监听器 --&gt;  </span><br><span class="line">    &lt;listener&gt;  </span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  </span><br><span class="line">    &lt;/listener&gt;  </span><br><span class="line">    &lt;!-- 防止Spring内存溢出监听器 --&gt;  </span><br><span class="line">    &lt;listener&gt;  </span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt;  </span><br><span class="line">    &lt;/listener&gt; </span><br><span class="line">&lt;!-- 配置DispatcherServlet --&gt;</span><br><span class="line">	&lt;servlet&gt;</span><br><span class="line">		&lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;</span><br><span class="line">		&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">		&lt;!-- 配置springMVC需要加载的配置文件</span><br><span class="line">			spring-dao.xml,spring-service.xml,spring-web.xml</span><br><span class="line">			Mybatis - &gt; spring -&gt; springmvc</span><br><span class="line">		 --&gt;</span><br><span class="line">		&lt;init-param&gt;</span><br><span class="line">			&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">			&lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt;</span><br><span class="line">		&lt;/init-param&gt;</span><br><span class="line">	&lt;/servlet&gt;</span><br><span class="line">	&lt;servlet-mapping&gt;</span><br><span class="line">		&lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;</span><br><span class="line">		&lt;!-- 默认匹配所有的请求 --&gt;</span><br><span class="line">		&lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">	&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>至此，所有的配置文件结束，下面将进行具体的代码环节</p>
<h2 id="业务代码"><a href="#业务代码" class="headerlink" title="业务代码"></a>业务代码</h2><p>这里mapper中的xml文件就不贴了，自行脑补。。。。</p>
<ul>
<li>实体类：包括商品和订单</li>
</ul>
<p><strong>商品类</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 商品信息类</span><br><span class="line"> * @author glmapper</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Goods &#123;</span><br><span class="line">	private long goodsId;// 商品ID</span><br><span class="line">	private String goodsName;// 商品名称</span><br><span class="line">	private int number;// 商品库存</span><br><span class="line"></span><br><span class="line">	public long getGoodsId() &#123;</span><br><span class="line">		return goodsId;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setGoodsId(long goodsId) &#123;</span><br><span class="line">		this.goodsId = goodsId;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getGoodsName() &#123;</span><br><span class="line">		return goodsName;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setGoodsName(String goodsName) &#123;</span><br><span class="line">		this.goodsName = goodsName;</span><br><span class="line">	&#125;</span><br><span class="line">	public int getNumber() &#123;</span><br><span class="line">		return number;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setNumber(int number) &#123;</span><br><span class="line">		this.number = number;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>订单类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 订单信息类</span><br><span class="line"> * @author glmapper</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class OrderInfo &#123;</span><br><span class="line">	private String orderId;//订单ID</span><br><span class="line">	private long goodsId;//商品ID</span><br><span class="line">	private long userId;//用户ID</span><br><span class="line">	private Date orderTime;//下单时间</span><br><span class="line">	public String getOrderId() &#123;</span><br><span class="line">		return orderId;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setOrderId(String orderId) &#123;</span><br><span class="line">		this.orderId = orderId;</span><br><span class="line">	&#125;</span><br><span class="line">	public long getGoodsId() &#123;</span><br><span class="line">		return goodsId;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setGoodsId(long goodsId) &#123;</span><br><span class="line">		this.goodsId = goodsId;</span><br><span class="line">	&#125;</span><br><span class="line">	public long getUserId() &#123;</span><br><span class="line">		return userId;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setUserId(long userId) &#123;</span><br><span class="line">		this.userId = userId;</span><br><span class="line">	&#125;</span><br><span class="line">	public Date getOrderTime() &#123;</span><br><span class="line">		return orderTime;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setOrderTime(Date orderTime) &#123;</span><br><span class="line">		this.orderTime = orderTime;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>商品dao</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public interface GoodsDao &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 通过ID查询单件商品信息</span><br><span class="line">	 * </span><br><span class="line">	 * @param id</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	Goods queryById(long id);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 查询所有商品信息</span><br><span class="line">	 * </span><br><span class="line">	 * @param offset 查询起始位置</span><br><span class="line">	 * @param limit 查询条数</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	List&lt;Goods&gt; queryAll(@Param(&quot;offset&quot;) int offset, @Param(&quot;limit&quot;) int limit);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 减少商品库存</span><br><span class="line">	 * </span><br><span class="line">	 * @param bookId</span><br><span class="line">	 * @return 如果影响行数等于&gt;1，表示更新的记录行数</span><br><span class="line">	 */</span><br><span class="line">	int reduceNumber(long goodsId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>订单dao</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface OrderInfoDao &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 插入订单记录</span><br><span class="line">	 * </span><br><span class="line">	 * @param OrderInfo orderInfo</span><br><span class="line">	 * @return 插入的行数</span><br><span class="line">	 */</span><br><span class="line">	int insertOrderInfo(OrderInfo orderInfo);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 通过主键查询订单记录，返回订单实体 </span><br><span class="line">	 * @param orderId</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	OrderInfo queryByOrderId(String orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下单服务接口orderService</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">@Service(&quot;orderService&quot;)</span><br><span class="line">public class OrderServiceImpl implements OrderService &#123;</span><br><span class="line">	//log生成器</span><br><span class="line">	private Logger logger = LoggerFactory.getLogger(OrderServiceImpl.class);</span><br><span class="line">	</span><br><span class="line">	// 注入dao依赖【商品dao，订单dao】</span><br><span class="line">	@Autowired</span><br><span class="line">	private GoodsDao goodsDao;</span><br><span class="line">	@Autowired</span><br><span class="line">	private OrderInfoDao orderInfoDao;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public Goods getById(long goodsId) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return goodsDao.queryById(goodsId);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public List&lt;Goods&gt; getList(int offset,int limit) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return goodsDao.queryAll(offset, limit);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	@Transactional</span><br><span class="line">	public OrderInfo buyGoods(long goodsId, long userId) &#123;</span><br><span class="line">		//扣减库存，插入订单 =一个事务  如果失败则执行回滚</span><br><span class="line">		try &#123;</span><br><span class="line">			// 减库存</span><br><span class="line">			int update = goodsDao.reduceNumber(goodsId);</span><br><span class="line">			if (update &lt;= 0) &#123;// 库存不足</span><br><span class="line">				throw new NoNumberException(&quot;no number&quot;);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				// 执行预约操作</span><br><span class="line">				OrderInfo orderInfo=new OrderInfo();</span><br><span class="line">				orderInfo.setGoodsId(goodsId);</span><br><span class="line">				orderInfo.setUserId(userId);</span><br><span class="line">				orderInfo.setOrderTime(new Date());</span><br><span class="line">				String orderId=getRandomOrderId(goodsId);</span><br><span class="line">				orderInfo.setOrderId(orderId);</span><br><span class="line">				int insert = orderInfoDao.insertOrderInfo(orderInfo);</span><br><span class="line">				if (insert &lt;= 0) &#123;// 重复预约</span><br><span class="line">					throw new RepeatAppointException(&quot;repeat appoint&quot;);</span><br><span class="line">				&#125; else &#123;// 预约成功</span><br><span class="line">					return orderInfo;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			//这里可以丰富下具体的返回信息</span><br><span class="line">			logger.error(&quot;下单失败&quot;);</span><br><span class="line">		&#125; </span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private String getRandomOrderId(long goodsId) &#123;</span><br><span class="line">		SimpleDateFormat dateFormater = new SimpleDateFormat(&quot;yyyyMMddhhmmss&quot;);</span><br><span class="line">		String prefix=dateFormater.format(new Date());</span><br><span class="line">		String goodsIdStr=goodsId+&quot;&quot;;</span><br><span class="line">		String temp=&quot;&quot;;</span><br><span class="line">		for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">			Random random=new Random(goodsIdStr.length()-1);</span><br><span class="line">			temp+=goodsIdStr.charAt(random.nextInt());</span><br><span class="line">		&#125;</span><br><span class="line">		return prefix+temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>OK，至此所有核心代码及配置文件罗列完毕；【mapper中的xml和具体的controller就不贴了，相信大家对这个也不陌生。本文主要意图在于梳理下自己学习中的一些点，SSM框架在实际的应用开发中还会有很多其他的开源技术结合进来，如：quartz,redis等。当前本文的列子就是一个空壳子，以备参考吧】</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/project-frame-ssm/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/java-thread-base/">JAVA基础知识系列---进程、线程安全</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T05:39:42.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/java-thread-base/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/java/" title="java">java</a>,
  
    <a href="/tags/线程/" title="线程">线程</a>,
  
    <a href="/tags/thread/" title="thread">thread</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<h2 id="1-1-临界区"><a href="#1-1-临界区" class="headerlink" title="1.1 临界区"></a>1.1 临界区</h2><p>保证在某一时刻只有一个线程能访问数据的简便方法，在任意时刻只允许一个线程对资源进行访问。如果有多个线程试图同时访问临界区，那么在有一个线程进入后，其他所有试图访问临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操作共享资源的目的</p>
<h2 id="1-2-互斥量"><a href="#1-2-互斥量" class="headerlink" title="1.2 互斥量"></a>1.2 互斥量</h2><p>互斥量和临界区很相似，只能拥有互斥对象的线程才能具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下次共享资源都不会同时被多个线程所访问。当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后可以访问资源。互斥量比临界区复杂，因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。</p>
<h2 id="1-3-管程-信号量"><a href="#1-3-管程-信号量" class="headerlink" title="1.3 管程/信号量"></a>1.3 管程/信号量</h2><p>管程和信号量是同一个概念。指一个互斥独占锁定的对象或称为互斥体。在给定的时间，仅有一个线程可以获得管程。当一个线程需要锁定，他必须进入管程。所有其他的试图进入已经锁定的管程的线程必须挂起直到第一个线程退出管程。这些其他的线程被称为等待线程。一个拥有管程的线程如果愿意的话可以再次进入相同的管程（可重入性）</p>
<h2 id="1-4-CAS操作"><a href="#1-4-CAS操作" class="headerlink" title="1.4 CAS操作"></a>1.4 CAS操作</h2><p>CAS操作（compare  and swap）CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则返回V。这是一种乐观锁的思路，它相信在它修改之前，没有其它线程去修改它；而Synchronized是一种悲观锁，它认为在它修改之前，一定会有其它线程去修改它，悲观锁效率很低。下面来看一下AtomicInteger是如何利用CAS实现原子性操作的。</p>
<h2 id="1-5-重排序"><a href="#1-5-重排序" class="headerlink" title="1.5 重排序"></a>1.5 重排序</h2><p>编译器和处理器为了提高性能，而在程序执行时会对程序进行重排序。他的出现是为了提高程序的并发度。从而提高性能；但是对于多线程程序，重排序可能会导致程序执行的结果不是我们需要的结果，重排序分为编译器和处理器俩个方面。而处理器重排序包括指令级重排序和内存重排序。</p>
<h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>在java中，所有的变量（实例字段，静态字段，构成数组的元素，不包括局部变量和方法参数）都存储在主内存中，内个线程都有自己的工作内存，线程的工作内存保存被线程使用到的变量的主内存副本拷贝。线程对变量的所有操作都必须在工作内存中进行，为不能直接读写主内存的变量。不同线程之间也不恩能够直接访问对方工作内存中的变量，线程间比变量值的传递通过主内存来完成。</p>
<h2 id="JAVA中线程安全相关关键字及类"><a href="#JAVA中线程安全相关关键字及类" class="headerlink" title="JAVA中线程安全相关关键字及类"></a>JAVA中线程安全相关关键字及类</h2><p>主要包括：synchronized，Volitile，ThreadLocal，Lock，Condition</p>
<h2 id="2-1-Volitile"><a href="#2-1-Volitile" class="headerlink" title="2.1 Volitile"></a>2.1 Volitile</h2><p>作用：</p>
<p>1）保证了心智能立即存储到主内存才，每次使用前立即从主内存中刷新</p>
<p>2）禁止指令重排序优化</p>
<p>Volitile关键字不能保证在多线程环境下对共享数据的操作的正确性，可以使用在自己状态改变之后需要立即通知所有线程的情况下，只保证可见性，不保证原子性。即通过刷新变量值确保可见性。</p>
<p>Java中synchronized和final也能保证可见性</p>
<p>synchronized：同步快通过变量锁定前必须清空工作内存中的变量值，重新从主内存中读取变量值，解锁前必须把变量值同步回主内存来确保可见性。</p>
<p>final:被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把this引用传递进去，那么在其他线程中就能看见final字段的值，无需同步就可以被其他线程正确访问。</p>
<h2 id="2-2-synchronized"><a href="#2-2-synchronized" class="headerlink" title="2.2 synchronized"></a>2.2 synchronized</h2><p>把代码块声明为synchronized，有俩个作用，通常是指改代码具有原子性和可见性。如果没有同步机制提供的这种可见性，线程看到的共享比那里可能是修改前的值或不一致的值，这将引发许多严重问题。</p>
<p>原理：当对象获取锁是，他首先是自己的高速缓存无效，这样就可以保证直接从主内存中装入变量，同样在对象释放锁之前，他会刷新其高速缓存，强制使已做的任何更改都出现在主内存中，这样会保证在同一个锁上同步的俩个线程看到在synchronized块内修改的变量的相同值。</p>
<p>synchronized释放由JVM自己管理。</p>
<p>存在的问题：</p>
<p>1）无法中断一个正在等待获得锁的线程</p>
<p>2）无法通过投票得到锁，如果不想等待下去，也就没法得到锁</p>
<p>3）同步还需要锁的释放只能在与获得锁所在的堆栈帧相同的堆栈中进行，多数情况下，这没问题（而且与一场处理交互的很好），但是，确实存在一些非块结构的锁定更适合情况。</p>
<h2 id="2-3-Lock"><a href="#2-3-Lock" class="headerlink" title="2.3 Lock"></a>2.3 Lock</h2><p>Lock是有JAVA编写而成的，在java这个层面是无关JVM实现的。包括：ReentrantLock，ReadWriteLock。其本质都依赖于AbstractQueueSynchronized类。Lock提供了很多锁的方式，尝试锁，中断锁等。释放锁的过程由JAVA开发人员自己管理。</p>
<p>就性能而言，对于资源冲突不多的情况下synchronized更加合理，但如果资源访问冲突多的情况下，synchronized的性能会快速下降，而Lock可以保持平衡。</p>
<h2 id="2-4-condition"><a href="#2-4-condition" class="headerlink" title="2.4 condition"></a>2.4 condition</h2><p>Condition将Object监视器方法（wait，notify,notifyall）分解成截然不同的对象，以便通过这些对象与任意Lock实现组合使用，为每个对象提供多个等待set(wait-set),，其中Lock替代了synchronized方法和语句的使用，condition替代了Object监视器方法的使用。Condition实例实质上被你绑定到一个锁上。要为特定Lock实例获得Condition实例，请使用其newCondition（）方法。</p>
<h2 id="2-5-ThreadLock"><a href="#2-5-ThreadLock" class="headerlink" title="2.5 ThreadLock"></a>2.5 ThreadLock</h2><p>线程局部变量。</p>
<p>变量是同一个，但是每个线程都使用同一个初始值，也就是使用同一个变量的一个新的副本，这种情况下TreadLocal就非常有用。</p>
<p>应用场景：当很多线程需要多次使用同一个对象，并且需要该对象具有相同初始值的时候，最适合使用TreadLocal。</p>
<p>事实上，从本质上讲，就是每个线程都维持一个MAP，而这个map的key就是TreadLocal,而值就是我们set的那个值，每次线程在get的时候，都从自己的变量中取值，既然从自己的变量中取值，那就肯定不存在线程安全的问题。总体来讲，TreadLocal这个变量的状态根本没有发生变化。它仅仅是充当了一个key的角色，另外提供给每一个线程一个初始值。如果允许的话，我们自己就能实现一个这样的功能，只不过恰好JDK就已经帮助我们做了这个事情。</p>
<p>使用TreadLocal维护变量时，TreadLocal为每个使用该变量的线程提供独立地变量副本，所以每一个线程都可以独立地改变自己的副本，而不会英语其他线程所对应的副本。从线程的角度看，目标变量对象是线程的本地变量，这也是类名中Local所需要表达的意思。</p>
<p>TreadLocal的四个方法：</p>
<p>void set(Object val),设置当前线程的线程局部变量的值</p>
<p>Object get（）返回当前线程所对用的线程局部变量。</p>
<p>void remove() 将当前线程局部变量的值删除，目的是为了减少内存的占用，线程结束后，局部变量自动被GC</p>
<p>Object  initValue() 返回该线程局部变量的初始值，使用protected修饰，显然是为了让子类覆盖而设计的。</p>
<h2 id="线程安全的实现方式"><a href="#线程安全的实现方式" class="headerlink" title="线程安全的实现方式"></a>线程安全的实现方式</h2><h2 id="3-1-互斥同步"><a href="#3-1-互斥同步" class="headerlink" title="3.1 互斥同步"></a>3.1 互斥同步</h2><p>在多线程访问的时候，保证同一时间只有一条线程使用。</p>
<p>临界区，互斥量，管程都是同步的一种手段。</p>
<p>java中最基本的互斥同步手段是synchronized，编译之后会形成monitorenter和monitorexit这俩个字节码指令，这俩个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象，还有一个锁的计数器，来记录加锁的次数，加锁几次就要同样解锁几次才能恢复到无锁状态。</p>
<p>java的线程是映射到操作系统的原生线程之上的，不管阻塞还是唤醒都需要操作系统的帮助完成，都需要从用户态转换到核心态，这是很耗费时间的，是java语言中的一个重量级的操作，虽然虚拟机本身会做一点优化的操作，比如通知操作系统阻塞之前会加一段自旋等待的过程，避免频繁切换到核心态。</p>
<h2 id="3-2-非阻塞同步"><a href="#3-2-非阻塞同步" class="headerlink" title="3.2 非阻塞同步"></a>3.2 非阻塞同步</h2><p>互斥和同步最主要的问题就是阻塞和唤醒所带来的性能的问题，所以这通常叫阻塞同步（悲观的并发策略）.随着硬件指令集的发展，我们有另外的选择：基于冲突检测的乐观并发策略，通俗讲就是先操作，如果没有其他线程争用共享的数据，操作就成功，如果有，则进行其他的补偿（最常见的就是不断的重试）。这种乐观的并发策略许多实现都不需要把线程先挂起，这种同步操作被称为非阻塞同步。</p>
<h2 id="3-3-无同步"><a href="#3-3-无同步" class="headerlink" title="3.3 无同步"></a>3.3 无同步</h2><p>部分代码天生就是线程安全的，不需要同步。</p>
<p>1）可重入代码：纯代码，具有不依赖存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入，不调用非可重入的方法等特征，它的返回结果是可以预测的。</p>
<p>2）线程本地存储：把共享数据的可见性范围限制在同一个线程之内，这样就无需同步也能保证线程之间不出现数据争用问题。可以通过java.lang.TreadLocal类来实现线程本地存储的功能。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/java-thread-base/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/10/topic-servlet/">聊一聊 Web 核心 - Servlet</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-10T05:38:37.000Z" itemprop="datePublished">2018/11/10</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/10/topic-servlet/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/web/" title="web">web</a>,
  
    <a href="/tags/servlet/" title="servlet">servlet</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>Servlet实际上是ServerApplet–小服务程序或服务连接器，用Java编写的服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容。与常用的协议，如DNS，TCP/IP，HTTP类似，Servlet是作为一整套规范存在的；同时作为J2EE标准的一部分，定义了javaweb开发的标准。Servlet制定了java处理WEB请求的一系列标准，我们只需要按照标准规定的去做就可以了。<br>实际上，无论是Struts2的FilterDispatcher还是SpringMvc的DispatcherServlet,其底层都是通过实现Sevlet或者Servlet类型的扩展【如：GenericServlet】来实现的。</p>
<h1 id="1-Servlet接口"><a href="#1-Servlet接口" class="headerlink" title="1.Servlet接口"></a>1.Servlet接口</h1><p>下图为Servlet3.1中的结构图：<br><img src="https://user-gold-cdn.xitu.io/2017/9/17/f082e8b42bd73aacc90e1a79ba99596f" alt=""><br>因为Servlet是以规范的方式存在的，实际上就是定义一系列规范接口。在Servlet接口中，主要包括以下几个接口：<br><img src="https://user-gold-cdn.xitu.io/2017/9/17/6c96aac1646cea4a19aaf7a2a8da0fcc" alt=""></p>
<ul>
<li>1)init方法是在容器启动时被容器调用，且只会被调用一次；</li>
<li>2)getServletConfig方法用于获取ServletConfig；</li>
<li>3)service方法用于处理一个具体的请求</li>
<li>4)getServletInfo方法用于获取Servlet相关的信息：版权等。</li>
<li>5)destroy方法用来销毁一个Servlet，和init一样，只会被调用一次，一般在服务器关闭时用于释放一些资源。</li>
</ul>
<p>init方法调用时会接受一个ServletConfig类型的参数，用于初始化Servlet，由容器传入。ServletConfig，顾名思义，其包含了Serlvet的配置信息。通常情况下，我们在web.xml文件中定义Serlvet时，会通过init-param标签来进行参数配置。在Springmvc的配置中，通常通过以下方式来配置参数：<br><img src="https://user-gold-cdn.xitu.io/2017/9/17/1379ebb6b6e2849e1243f5b4a2445816" alt=""></p>
<h1 id="2-ServletConfig接口"><a href="#2-ServletConfig接口" class="headerlink" title="2.ServletConfig接口"></a>2.ServletConfig接口</h1><p><img src="https://user-gold-cdn.xitu.io/2017/9/17/651a24ed98cc74708ff03856a2bd5faf" alt=""><br>1)getServletName用于获取Servlet的名字，也就是我们在web.xml中定义的servlet-name<br>2)getServletContext返回ServletContext，代表我们当前应用本身<br>3)getInitParameter用于获取init-param配置的参数<br>4)getInitParameterNames用于获取所有init-param配置名字的集合<br>ServletContext和ServletConfig最常见的使用就是传递初始化参数。来看下spring中的contextConfigServlet的参数配置<br><img src="https://user-gold-cdn.xitu.io/2017/9/17/303a290e03736b0aa1a0a4ce3b935de8" alt=""><br>通过context-param配置的contextConfigLocation配置到了ServletContext中，再通过Servlet下的init-param配置的contextConfigLocation配置到ServletConfig中,在Servlet中可以通过getInitParameter方法获取具体的信息。</p>
<h1 id="3-GenericServlet"><a href="#3-GenericServlet" class="headerlink" title="3.GenericServlet"></a>3.GenericServlet</h1><p>GenericServlet是Servlet的默认实现，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package javax.servlet;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.Enumeration;</span><br><span class="line">import java.util.ResourceBundle;</span><br><span class="line">public abstract class GenericServlet</span><br><span class="line">  implements Servlet, ServletConfig, Serializable</span><br><span class="line">&#123;</span><br><span class="line">  private static final String LSTRING_FILE = &quot;javax.servlet.LocalStrings&quot;;</span><br><span class="line">  private static ResourceBundle lStrings = ResourceBundle.getBundle(&quot;javax.servlet.LocalStrings&quot;);</span><br><span class="line">  private transient ServletConfig config;</span><br><span class="line">  public void destroy()</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  public String getInitParameter(String name)</span><br><span class="line">  &#123;</span><br><span class="line">    ServletConfig sc = getServletConfig();</span><br><span class="line">    if (sc == null) &#123;</span><br><span class="line">      throw new IllegalStateException(lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    return sc.getInitParameter(name);</span><br><span class="line">  &#125;</span><br><span class="line">  public Enumeration getInitParameterNames()</span><br><span class="line">  &#123;</span><br><span class="line">    ServletConfig sc = getServletConfig();</span><br><span class="line">    if (sc == null) &#123;</span><br><span class="line">      throw new IllegalStateException(lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    return sc.getInitParameterNames();</span><br><span class="line">  &#125;</span><br><span class="line">  public ServletConfig getServletConfig()</span><br><span class="line">  &#123;</span><br><span class="line">    return this.config;</span><br><span class="line">  &#125;</span><br><span class="line">  public ServletContext getServletContext()</span><br><span class="line">  &#123;</span><br><span class="line">    ServletConfig sc = getServletConfig();</span><br><span class="line">    if (sc == null) &#123;</span><br><span class="line">      throw new IllegalStateException(lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    return sc.getServletContext();</span><br><span class="line">  &#125;</span><br><span class="line">  public String getServletInfo()</span><br><span class="line">  &#123;</span><br><span class="line">    return &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  public void init(ServletConfig config)</span><br><span class="line">    throws ServletException</span><br><span class="line">  &#123;</span><br><span class="line">    this.config = config;</span><br><span class="line">    init();</span><br><span class="line">  &#125;</span><br><span class="line">  public void init()</span><br><span class="line">    throws ServletException</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  public void log(String msg)</span><br><span class="line">  &#123;</span><br><span class="line">    getServletContext().log(getServletName() + &quot;: &quot; + msg);</span><br><span class="line">  &#125;</span><br><span class="line">  public void log(String message, Throwable t)</span><br><span class="line">  &#123;</span><br><span class="line">    getServletContext().log(getServletName() + &quot;: &quot; + message, t);</span><br><span class="line">  &#125;</span><br><span class="line">  public abstract void service(ServletRequest paramServletRequest, ServletResponse paramServletResponse)</span><br><span class="line">    throws ServletException, IOException;</span><br><span class="line">  public String getServletName()</span><br><span class="line">  &#123;</span><br><span class="line">    ServletConfig sc = getServletConfig();</span><br><span class="line">    if (sc == null) &#123;</span><br><span class="line">      throw new IllegalStateException(lStrings.getString(&quot;err.servlet_config_not_initialized&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    return sc.getServletName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从其继承和实现关系来看，GenericServlet主要做了3件事：<br>1.实现了ServletConfig接口，这样我们就可以直接调用ServletConfig里面的方法；<br>  GenericServlet实现了ServletConfig，可以在需要的时候直接调用ServletConfig中的方法，不需要再先获取ServletConfig对象；比如，获取ServletContext的时候可以直接调用getServletContext,而无需调用getServletConfig().getServletContext(),但是实际上，其底层的内部实现还是在内部还是进行了getServletConfig().getServletContext()的调用。<br><img src="https://user-gold-cdn.xitu.io/2017/9/17/dd8a5129f647e5294c4b2f19a1e7de8f" alt=""><br>2.提供了无参的init方法<br>     GenericServlet实现了Servlet的init（ServletConfig config）方法，在里面将config设置给了其内部变量config，然后调用了无参的init方法；此方法可以在子类中通过覆盖它来完成初始化工作。<br><img src="https://user-gold-cdn.xitu.io/2017/9/17/272a1795528bfa56e7f579f2d3fe97fd" alt=""><br>这种方式具有的有点包括以下几点：<br>    a.config设置为内部属性，这样可以在ServletConfig的接口方法中直接调用Config的相应方法来执行；<br>    b.我们在写Serlvet的时候可以不用再关心Config，只需要执行自己的初始化逻辑即可<br>    c.在重写init方法时，不需要再调用super.init(config)。<br>3.提供了Log方法<br>    GenericServlet提供了2个log方法，一个用于记录日志，一个用于记录异常。其具体的实现是通过传给ServletConfig的日志实现的。<br> GenericServlet是与具体协议无关的。</p>
<h1 id="4-HttpServlet"><a href="#4-HttpServlet" class="headerlink" title="4.HttpServlet"></a>4.HttpServlet</h1><p>HttpServlet是基于Http协议实现的Servlet的基类，写Servlet时直接继承HttpServlet即可,不需要再重头实现Servlet接口，SpringMvc中的dispatcherServlet就是HttpServlet的子类。 HttpServlet是与Http协议相关的，HttpServlet处理请求主要是通过重写父类的service方法来完成具体的请求处理的。在service方法中首先是将ServletRequest和ServletResponse转换成HttpServletRequest和HttpServletResponse，然后根据请求的不同路由到不同的处理过程中去【处理方法就是我们常见的doXXX的方法。最常见的就是doGet和doPost】<br><img src="https://user-gold-cdn.xitu.io/2017/9/17/8e5566839bf5ace1b9bd42bd06110460" alt=""></p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/10/topic-servlet/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
    </div>
    
      <div id="page-nav" class="pagination">
	<a class="extend prev" rel="prev" href="/page/9/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/11/">Next</a>
      </div>
    
  </section>

</div>

</div>

  </div>
  </div>



    <!-- BEGIN PRE-FOOTER -->
    <div class="pre-footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN BOTTOM ABOUT BLOCK -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>About Us</h2>
            <p>Computer Lab is a software development and marketing company based in Brooklyn, New York. <br><br> Computer Lab was founded in 2015, and is focused on so on and so forth.</p>
          </div>
          <!-- END BOTTOM ABOUT BLOCK -->

          <!-- BEGIN BOTTOM CONTACTS -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>Contact</h2>
            <address class="margin-bottom-40">
              140 Metropolitan Avenue<br>
              5th Floor<br>
              Brooklyn, NY 11249<br>
              Phone: 716-472-4484<br>
              Email: <a href="mailto:ptsteadman@gmail.com">ptsteadman@gmail.com</a><br>
            </address>
          </div>
          <!-- END BOTTOM CONTACTS -->

	
          <!-- BEGIN TWITTER BLOCK --> 
          <div class="col-md-4 col-sm-6 pre-footer-col">

	  <a data-tweet-limit="1" class="twitter-timeline" href="https://twitter.com/computerlab_" data-widget-id="678830341331820544">Tweets by @computerlab_</a>

	  <script>!function(d,s,id){var
	  js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

          </div>
          <!-- END TWITTER BLOCK -->
	
        </div>
      </div>
    </div>
    <!-- END PRE-FOOTER -->

    <!-- BEGIN FOOTER -->
    <div class="footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN COPYRIGHT -->
          <div class="col-md-6 col-sm-6 padding-top-10">
                  &copy; 2020 glmapper<br>
 <a href="javascript:;">Privacy Policy</a> | <a href="javascript:;">Terms of Service</a>
          </div>
          <!-- END COPYRIGHT -->
	  <!-- BEGIN SOCIAL -->
<div class="col-md-6 col-sm-6">
  <ul class="social-footer list-unstyled list-inline pull-right">
    
      <li><a href="https://github.com/ptsteadman"><i class="fa fa-github"></i></a></li>
    
      <li><a href="https://twitter.com/ptsteadman"><i class="fa fa-twitter"></i></a></li>
    
      <li><a href="https://www.facebook.com/ptsteadman"><i class="fa fa-facebook"></i></a></li>
    
      <li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li>
    
      <li><a href="https://linkedin.com/in/ptsteadman"><i class="fa fa-linkedin"></i></a></li>
    
      <li><a href="http://stackoverflow.com/users/2480493/patrick-steadman"><i class="fa fa-stackoverflow"></i></a></li>
    
  </ul>  
</div>
<!-- END SOCIAL -->

        </div>
      </div>
    </div>
    <!-- END FOOTER -->

  <!-- BEGIN CORE PLUGINS (REQUIRED FOR ALL PAGES) -->
<!--[if lt IE 9]>
<script src="/metronic/assets/plugins/respond.min.js"></script>
<![endif]--> 
<script src="/metronic/assets/plugins/jquery.min.js"></script>
<script src="/metronic/assets/plugins/jquery-migrate.min.js"></script>
<script src="/metronic/assets/plugins/bootstrap/js/bootstrap.min.js"></script>
<script src="/metronic/assets/corporate/scripts/back-to-top.js"></script>
<script src="/metronic/assets/plugins/owl.carousel/owl.carousel.min.js"></script>
<script src="/metronic/assets/corporate/scripts/layout.js"></script>
<script src="/js/wow.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script type="text/javascript">
    jQuery(document).ready(function() {
        Layout.init();    
        Layout.initOWL();
        Layout.initTwitter();
        Layout.initFixHeaderWithPreHeader(); /* Switch On Header Fixing (only if you have pre-header) */
        Layout.initNavScrolling(); 
	new WOW().init();
    });
</script>
<!-- END CORE PLUGINS -->

<!-- BEGIN PAGE-SPECIFIC PLUGINS --> 







<!-- END PAGE-SPECIFIC PLUGINS --> 

<!-- BEGIN INTEGRATIONS -->





<!-- END INTEGRATIONS -->

</body>
</html>
