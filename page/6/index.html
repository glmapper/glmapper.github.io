<!DOCTYPE html>
<!--[if IE 8]> <html lang="en" class="ie8 no-js"> <![endif]-->
<!--[if IE 9]> <html lang="en" class="ie9 no-js"> <![endif]-->
<!--[if !IE]><!-->
<html lang="en">
<!--<![endif]-->
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>glmapper</title>

  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <meta name="description" content="从平凡的世界中全身而退">
<meta property="og:type" content="website">
<meta property="og:title" content="glmapper">
<meta property="og:url" content="http://www.glmapper.com/page/6/index.html">
<meta property="og:site_name" content="glmapper">
<meta property="og:description" content="从平凡的世界中全身而退">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="glmapper">
<meta name="twitter:description" content="从平凡的世界中全身而退">
  
    <link rel="alternative" href="/atom.xml" title="glmapper" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
    
  <meta content="{{ title }}" name="description">
  <meta content="{{ title }}" name="keywords">
  <meta content="{{ title }}" name="author">

  <link href="http://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700|PT+Sans+Narrow|Source+Sans+Pro:200,300,400,600,700,900&amp;subset=all" rel="stylesheet" type="text/css">

  <!-- Global styles START -->   
  <link rel="stylesheet" href="/metronic/assets/plugins/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/bootstrap/css/bootstrap.min.css">
  <!-- Global styles END --> 
   
  <!-- Page level plugin styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/animate.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/owl.carousel/assets/owl.carousel.css">
  <!-- Page level plugin styles END -->

  <!-- Theme styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/components.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/slider.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/portfolio.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style-responsive.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/themes/red.css">
  <link rel="stylesheet" href="/css/theme-styles.css">
  <!-- Theme styles END -->
</head>
</html>
<body class="corporate">
  <!-- BEGIN TOP BAR -->
<div class="pre-header">
  <div class="container">
    <div class="row">
      <!-- BEGIN TOP BAR LEFT PART -->
      <div class="col-md-6 col-sm-6 col-xs-9 additional-shop-info">
	<ul class="list-unstyled list-inline">
	  <li><i class="fa fa-phone"></i><span>716-472-4484</span></li>
	  <li><i class="fa fa-envelope-o"></i><span>ptsteadman@gmail.com</span></li>
	</ul>
      </div>
      <!-- END TOP BAR LEFT PART -->
      <!-- BEGIN TOP BAR MENU -->
      <div class="col-md-6 col-sm-6 col-xs-3 additional-nav">
	<ul class="list-unstyled list-inline pull-right">
	  <li><a href="/login">Log In</a></li>
	</ul>
      </div>
      <!-- END TOP BAR MENU -->
    </div>
  </div>        
</div>
<!-- END TOP BAR -->
<!-- BEGIN HEADER -->
<div class="header">
  <div class="container">
    <!--<a class="site-logo" href="/" id="logo">glmapper</a>-->

    <a class="site-logo" href="/">
      <img src="/metronic/assets/corporate/img/logos/logo-corp-red.png" alt="Metronic FrontEnd">
    </a>

    <a href="javascript:void(0);" class="mobi-toggler"><i class="fa fa-bars"></i></a>

    <!-- BEGIN NAVIGATION -->
    <div class="header-navigation pull-right font-transform-inherit">
      <ul>
	
	<li class="">
	  <a href="/">Home</a>
	</li>
	
	<li class="">
	  <a href="/projects/">Projects</a>
	</li>
	
	<li class="">
	  <a href="/archives/">Blog</a>
	</li>
	
	<li class="">
	  <a href="/contact/">Contact</a>
	</li>
	
	<li class="">
	  <a href="/about/">About</a>
	</li>
	
	<!-- BEGIN TOP SEARCH -->
	<li class="menu-search">
	  <span class="sep"></span>
	  <i class="fa fa-search search-btn"></i>
	  <div class="search-box">
	    <form action="#">
	      <div class="input-group">
		<input type="text" placeholder="Search" class="form-control st-default-search-input">
		<span class="input-group-btn">
		  <button class="btn btn-primary" type="submit">Search</button>
		</span>
	      </div>
	    </form>
	  </div> 
	</li>
	<!-- END TOP SEARCH -->
      </ul>
    </div>
    <!-- END NAVIGATION -->
  </div>
</div>
<!-- Header END -->

  
  <div class="container">
    <ul class="breadcrumb">
      <li class="active">Home</li>
    </ul>
  <div id="main">
    <div class="row">

<div class="col-xs-12 blog-posts">


  <section class="archives-wrap">
    <div class="archives">
      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/12/31/springboot/springcoud-eureka-discovery/">SpringCloud-Eureka 服务发现</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-12-30T16:06:53.000Z" itemprop="datePublished">2018/12/31</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/12/31/springboot/springcoud-eureka-discovery/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring-cloud/" title="spring cloud">spring cloud</a>,
  
    <a href="/tags/Eureka/" title="Eureka">Eureka</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>本篇将继续接着上一篇 <a href="http://www.glmapper.com/2018/12/31/springcoud-eureka-register/">SpringCloud-服务注册</a> ，通过使用 DiscoveryClient 来实现服务发现，并且消费。</p>
<p>DiscoveryClient 源自于 spring-cloud-client-discovery ，是 spring cloud 中被定义用来服务发现的公共接口，在 spring cloud 的各类服务发现组件中，都有对应的实现，如 eureka、consul、zookeeper 。它提供从服务注册中心获取服务实例信息的能力。如果我们想自己实现一个服务发现组件，集成到spring cloud 中，就完全可以通过实现此接口来完成。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table>
<thead>
<tr>
<th>类别</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>JDK<br></td>
<td>1.8.0_162<br></td>
</tr>
<tr>
<td>SOFABoot/SpringBoot<br></td>
<td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE<br></td>
</tr>
<tr>
<td>SpringCloud<br></td>
<td>Finchley.RC1<br></td>
</tr>
<tr>
<td>IDE<br></td>
<td>IDEA<br></td>
</tr>
</tbody>
</table>
<h2 id="工程背景"><a href="#工程背景" class="headerlink" title="工程背景"></a>工程背景</h2><p>本案例使用 SOFABoot 3.0.x 版本集成 SringCloud F版。工程如下：</p>
<ul>
<li>sofa-eureka-consumer-discovery     服务消费方</li>
</ul>
<p>本工程的父工程继续使用《SpringCloud-Eureka 服务注册》文中新建的父工程。</p>
<h2 id="新建-sofa-eureka-consumer-discovery"><a href="#新建-sofa-eureka-consumer-discovery" class="headerlink" title="新建 sofa-eureka-consumer-discovery"></a>新建 sofa-eureka-consumer-discovery</h2><p>这里我们通过 sofa-eureka-consumer-discovery 这个工程来手动发现服务。</p>
<p>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p>
<ul>
<li>artifactId：sofa-eureka-consumer-discovery。</li>
</ul>
<h3 id="修改-pom-文件"><a href="#修改-pom-文件" class="headerlink" title="修改 pom 文件"></a>修改 pom 文件</h3><p>引入 spring-cloud-starter-netflix-eureka-client 依赖。<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-consumer-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.port=8088</span><br><span class="line">spring.application.name=sofa-eureka-discovery</span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/</span><br></pre></td></tr></table></figure>
<h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaEurekaConsumerDiscoveryApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaEurekaConsumerDiscoveryApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="服务获取"><a href="#服务获取" class="headerlink" title="服务获取"></a>服务获取</h3><p>这里通过 DiscoveryClient 对像手动获取到 HELLOSOFASERVICE 服务对应的所有实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscoveryController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/instance"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(<span class="string">"HELLOSOFASERVICE"</span>);</span><br><span class="line">        System.out.println(<span class="string">"current service size = "</span> + discoveryClient.getServices().size());</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>( String s :  discoveryClient.getServices())&#123;</span><br><span class="line">            stringBuilder.append(<span class="string">"services="</span> + s).append(<span class="string">"\n"</span>);</span><br><span class="line">            List&lt;ServiceInstance&gt; serviceInstances =  discoveryClient.getInstances(s);</span><br><span class="line">            <span class="keyword">for</span>(ServiceInstance si : serviceInstances)&#123;</span><br><span class="line">                stringBuilder.append(<span class="string">"url="</span>).append(si.getUri()).append(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuilder.append(<span class="string">"instance num"</span>).append(<span class="string">"="</span>).append(list.size());</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动-amp-验证"><a href="#启动-amp-验证" class="headerlink" title="启动 &amp; 验证"></a>启动 &amp; 验证</h3><p>启动当前工程，在此之前确保 注册中心和服务提供工程均已正常启动。然后在浏览器中输入：http:localhost:8088/instance</p>
<p><img src="https://oscimg.oschina.net/oscnet/1f7ea4c0b3f4e1eaccc37a5cc3baba5d47e.jpg" alt="image.png"></p>
<p>可以看到获取到的实例信息与注册中心上的实例信息是匹配的。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/12/31/springboot/springcoud-eureka-discovery/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/12/31/springboot/springcoud-eureka-register/">SpringCloud-Eureka 服务注册</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-12-30T16:05:40.000Z" itemprop="datePublished">2018/12/31</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/12/31/springboot/springcoud-eureka-register/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring-cloud/" title="spring cloud">spring cloud</a>,
  
    <a href="/tags/Eureka/" title="Eureka">Eureka</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spring Cloud Netflix Eureka 是 Spring Cloud 提供的用于服务注册和发现的基础组件，在 Spring Cloud 微服务体系中承担着相当重要的角色。Eureka 作为一个开箱即用的基础组件，其屏蔽了底层 Client 和 Server 交互的细节，使得开发者能够快速入手，将更多的精力投入到业务逻辑上去。</p>
<p>Eureka 是基于 Rest 实现的，及底层客户端和服务端之间的交互是通过 Rest 服务进行交互的。Eureka 包括两个部分，即服务端可客户端。</p>
<ul>
<li>服务端：Eureka Server ,提供服务注册和发现的功能</li>
<li>客户端：Eureka Client ,将自己的信息注册到 Eureka Server ，并从 Eureka Server 中发现其他服务。</li>
</ul>
<p>Eureka 本篇将先来搭建一个服务端，以作为后续篇幅的注册中心来使用。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table>
<thead>
<tr>
<th>类别</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>JDK<br></td>
<td>1.8.0_162<br></td>
</tr>
<tr>
<td>SOFABoot/SpringBoot<br></td>
<td><a href="https://github.com/alipay/sofa-boot/releases/tag/v3.0.0" target="_blank" rel="noopener">3.0.0</a>/2.0.x.RELEASE<br></td>
</tr>
<tr>
<td>SpringCloud<br></td>
<td>Finchley.RC1<br></td>
</tr>
<tr>
<td>IDE<br></td>
<td>IDEA<br></td>
</tr>
</tbody>
</table>
<h2 id="工程背景"><a href="#工程背景" class="headerlink" title="工程背景"></a>工程背景</h2><p>本案例使用 SOFABoot 3.0.x 版本集成 SringCloud F版。工程如下：</p>
<ul>
<li>sofa-eureka-server         服务注册中心</li>
<li>sofa-eureka-provider      服务提供方</li>
<li>sofa-eureka-comsumer   服务消费方</li>
</ul>
<p>本工程都是在同一个父工程下面的，因此工程构建开始会新建一个 SOFABoot 工程作为父工程。</p>
<h2 id="新建父工程"><a href="#新建父工程" class="headerlink" title="新建父工程"></a>新建父工程</h2><p>这里父工程直接新建一个SpringBoot 工程。可以使用 IDEA 的生成，也可以通过 <a href="http://www.sofastack.tech/sofa-boot/docs/QuickStart" target="_blank" rel="noopener">SOFABoot 快速开始</a> 新建一个 SpringBoot 工程，删除 src 目录，然后修改 pom.xml 文件。</p>
<ul>
<li>gourpId : com.alipay.sofa</li>
<li>artifactId : sofa-eureka-parent</li>
</ul>
<h3 id="parent-依赖修改"><a href="#parent-依赖修改" class="headerlink" title="parent 依赖修改"></a><strong>parent 依赖修改</strong></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>替换为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofaboot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="管控-SpringCloud-依赖"><a href="#管控-SpringCloud-依赖" class="headerlink" title="管控 SpringCloud 依赖"></a>管控 SpringCloud 依赖</h3><p>在主 pom 里面加入 SpringCloud 的依赖管控。版本为 Finchley.RC1<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.RC1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="配置-SpringCloud-仓库"><a href="#配置-SpringCloud-仓库" class="headerlink" title="配置 SpringCloud 仓库"></a>配置 SpringCloud 仓库</h3><p>在主pom.xml 中添加如下配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Milestones<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>OK，到这里，父工程创建完毕。</p>
<h2 id="新建-sofa-eureka-server-center"><a href="#新建-sofa-eureka-server-center" class="headerlink" title="新建 sofa-eureka-server-center"></a>新建 sofa-eureka-server-center</h2><p>sofa-eureka-server-center 作为注册中心的服务端。</p>
<p>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p>
<ul>
<li>artifactId：sofa-eureka-server-center。</li>
</ul>
<h3 id="pom-文件修改"><a href="#pom-文件修改" class="headerlink" title="pom 文件修改"></a>pom 文件修改</h3><p>引入 spring-cloud-starter-netflix-eureka-server 依赖，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-server-center<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="新建资源文件-application-yml"><a href="#新建资源文件-application-yml" class="headerlink" title="新建资源文件 application.yml"></a>新建资源文件 application.yml</h3><p>在 /src/main/resources 目录下新建 application.yml 或者 application.properties。这里以.yml文件为例：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span>    <span class="comment">#指定服务端口</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">sofa-eureka-server</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>配置文件后面统一说明</p>
</blockquote>
<h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>在 /src/main/resources 目录下新建 com.alipay.sofa.cloud 包目录，并且在当前包路劲下新建 SofaEurekaServerApplication 类，并且类上加上 @EnableEurekaServer 注解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaEurekaServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaEurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="启动程序-amp-验证"><a href="#启动程序-amp-验证" class="headerlink" title="启动程序 &amp; 验证"></a>启动程序 &amp; 验证</h3><p>启动当前应用。并且浏览器中输入：<a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a></p>
<p><img src="https://oscimg.oschina.net/oscnet/e46c56c9b7d431b2dc113e479255fa3eff7.jpg" alt="image.png"></p>
<p>服务正常运行，界面如上图所示；此时还没有服务注册进来，因此红色框内显示 ：No instances available</p>
<h2 id="新建-sofa-eureka-provider"><a href="#新建-sofa-eureka-provider" class="headerlink" title="新建 sofa-eureka-provider"></a>新建 sofa-eureka-provider</h2><p>sofa-eureka-provider 作为服务提供方，将会向注册中心 sofa-eureka-server-center 上注册服务。</p>
<p>右击 sofa-eureka-parent 父工程 -&gt; New -&gt; Module，这里选择 Maven 工程；</p>
<ul>
<li>artifactId：sofa-eureka-provider。</li>
</ul>
<h3 id="pom-文件修改-1"><a href="#pom-文件修改-1" class="headerlink" title="pom 文件修改"></a>pom 文件修改</h3><p>引入 spring-cloud-starter-netflix-eureka-client 和 spring-boot-starter-web 依赖，如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofa-eureka-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="新建资源文件"><a href="#新建资源文件" class="headerlink" title="新建资源文件"></a>新建资源文件</h3><p>在 /src/main/resources 目录下新建 application.yml 或者 application.properties。这里以.yml文件为例：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span>  <span class="comment">#指定注册中心地址</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">HelloSOFAService</span>   <span class="comment">#服务名称</span></span><br></pre></td></tr></table></figure></p>
<h3 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h3><p>在 /src/main/resources 目录下新建 com.alipay.sofa.cloud 包目录，并且在当前包路劲下新建 SofaEurekaProviderApplication 类，并且类上加上 @EnableEurekaClient 注解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaEurekaProviderApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SofaEurekaProviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="服务提供类"><a href="#服务提供类" class="headerlink" title="服务提供类"></a>服务提供类</h3><p>这里在  com.alipay.sofa.cloud.controller 包下新建 SofaController 类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.application.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String hostname;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello SOFA! Now Port is "</span>+port +<span class="string">" And hostname is "</span> +hostname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里在接口中返回 hostname 和 port ，方便后面验证负载均衡测试使用。</p>
<h3 id="启动程序-amp-验证-1"><a href="#启动程序-amp-验证-1" class="headerlink" title="启动程序 &amp; 验证"></a>启动程序 &amp; 验证</h3><p>在启动 sofa-eureka-provider 之前，需要先启动 sofa-wureka-server-center 。两个都启动成功之后，浏览器输入：<a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a> </p>
<p><img src="https://oscimg.oschina.net/oscnet/18b13b668adc275175ae8d6bacab52895e4.jpg" alt="image1.png"></p>
<p>此时我将 sofa-eureka-provider 中的配置文件的端口修改为 8081，再注册一个。</p>
<p><img src="https://oscimg.oschina.net/oscnet/d7a8333f1eabcb09b7a38f56aec860e56f4.jpg" alt="image2.png"></p>
<p>可以看到 服务为 HELLOSOFASERVICE 的有两个服务提供方。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/12/31/springboot/springcoud-eureka-register/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/12/31/springboot/springcloud-overview/">SpringCloud 总览</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-12-30T16:00:15.000Z" itemprop="datePublished">2018/12/31</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/12/31/springboot/springcloud-overview/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring-cloud/" title="spring cloud">spring cloud</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<blockquote>
<p>本系列基于Spring Cloud <strong>Finchley SR2 &amp; SpringBoot 2.0.7.</strong>RELEASE</p>
</blockquote>
<p>Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性令牌、全局锁、leader选举、分布式session、集群状态）。分布式系统的协调导致了样板模式, 使用 Spring Cloud 开发人员可以快速地支持实现这些模式的服务和应用程序。它们可以在任何分布式环境中很好地工作，包括开发人员自己的笔记本电脑，裸机数据中心，以及Cloud Foundry等托管平台。</p>
<h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><hr>
<p>Spring Cloud专注于为典型用例提供良好的开箱即用体验，并为其他用户提供可扩展性机制。</p>
<ul>
<li>Distributed/versioned configuration       分布式/版本化配置</li>
<li>Service registration and discovery         服务注册和发现</li>
<li>Routing                                                  智能路由</li>
<li>Service-to-service calls                         service-to-service调用</li>
<li>Load balancing                                       负载均衡</li>
<li>Circuit Breakers                                      断路器</li>
<li>Global locks                                            全局锁</li>
<li>Leadership election and cluster state     leader选举和集群状态管理</li>
<li>Distributed messaging                            分布式消息</li>
</ul>
<h2 id="主要项目"><a href="#主要项目" class="headerlink" title="主要项目"></a>主要项目</h2><hr>
<table>
<thead>
<tr>
<th>项目名称<br></th>
<th>项目职能<br></th>
</tr>
</thead>
<tbody>
<tr>
<td>Spring Cloud Config<br></td>
<td>Spring Cloud 提供的分布式配置中心，为外部配置提供了客户端和服务端的支持。<br></td>
</tr>
<tr>
<td>Spring Cloud Netflix<br></td>
<td>与各种Netflix OSS组件集成（Eureka，Hystrix，Zuul，Archaius等）。<br></td>
</tr>
<tr>
<td>Spring Cloud Bus<br></td>
<td>用于将服务和服务实例与分布式消息传递连接在一起的事件总线。用于跨群集传播状态更改（例如，配置更改事件）。<br></td>
</tr>
<tr>
<td>Spring Cloud Cloudfoundry<br></td>
<td>提供应用程序与 Pivotal Cloud Foundry 集成。提供服务发现实现，还可以轻松实现受SSO和OAuth2保护的资源。<br></td>
</tr>
<tr>
<td>Spring Cloud Open Service Broker<br></td>
<td>为构建实现 Open service broker API 的服务代理提供了一个起点。    <br></td>
</tr>
<tr>
<td>Spring Cloud Cluster<br></td>
<td>提供Leadership选举，如：Zookeeper, Redis, Hazelcast, Consul等常见状态模式的抽象和实现。<br></td>
</tr>
<tr>
<td>Spring Cloud Consul<br></td>
<td>封装了Consul操作，consul 是一个服务发现与配置工具，与Docker容器可以无缝集成。<br></td>
</tr>
<tr>
<td>Spring Cloud Security<br></td>
<td>基于spring security的安全工具包，为你的应用程序添加安全控制。在Zuul代理中为负载平衡的OAuth2 rest客户端和身份验证头中继提供支持。<br></td>
</tr>
<tr>
<td>Spring Cloud Sleuth<br></td>
<td>Spring Cloud 提供的分布式链路跟踪组件，兼容zipkin、HTracer和基于日志的跟踪（ELK）<br></td>
</tr>
<tr>
<td>Spring Cloud Data Flow<br></td>
<td>大数据操作工具，作为Spring XD的替代产品，它是一个混合计算模型，结合了流数据与批量数据的处理方式。<br></td>
</tr>
<tr>
<td>Spring Cloud Stream<br></td>
<td>数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。<br></td>
</tr>
<tr>
<td>Spring Cloud CLI<br></td>
<td>基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。<br></td>
</tr>
<tr>
<td>Spring Cloud OpenFeign<br></td>
<td>一个http client客户端，致力于减少http client客户端构建的复杂性。<br></td>
</tr>
<tr>
<td>Spring Cloud Gateway<br></td>
<td>Spring Cloud 提供的网关服务组件<br></td>
</tr>
<tr>
<td>Spring Cloud Stream App Starters<br></td>
<td>Spring Cloud Stream App Starters是基于Spring Boot的Spring 集成应用程序，可提供与外部系统的集成。<br></td>
</tr>
<tr>
<td>Spring Cloud Task</td>
<td>提供云端计划任务管理、任务调度。<br></td>
</tr>
<tr>
<td>Spring Cloud Task App Starters<br></td>
<td>Spring Cloud任务应用程序启动器是SpringBoot应用程序，它可以是任何进程，包括不会永远运行的Spring批处理作业，并且在有限的数据处理周期后结束/停止。<br></td>
</tr>
<tr>
<td>Spring Cloud Zookeeper<br></td>
<td>操作Zookeeper的工具包，用于使用zookeeper方式的服务发现和配置管理。<br></td>
</tr>
<tr>
<td>Spring Cloud AWS<br></td>
<td>提供与托管的AWS集成<br></td>
</tr>
<tr>
<td>Spring Cloud Connectors<br></td>
<td>便于云端应用程序在各种PaaS平台连接到后端，如：数据库和消息代理服务。<br></td>
</tr>
<tr>
<td>Spring Cloud Starters<br></td>
<td>Spring Boot式的启动项目，为Spring Cloud提供开箱即用的依赖管理。<br></td>
</tr>
<tr>
<td>Spring Cloud Contract<br></td>
<td>Spring Cloud Contract是一个总体项目，其中包含帮助用户成功实施消费者驱动合同方法的解决方案。<br></td>
</tr>
<tr>
<td>Spring Cloud Pipelines<br></td>
<td>Spring Cloud Pipelines提供了一个固定意见的部署管道，其中包含确保您的应用程序可以零停机方式部署并轻松回滚出错的步骤。<br></td>
</tr>
<tr>
<td>Spring Cloud Function<br></td>
<td>Spring Cloud Function通过函数促进业务逻辑的实现。 它支持Serverless 提供商之间的统一编程模型，以及独立运行（本地或PaaS）的能力。<br></td>
</tr>
</tbody>
</table>
<h2 id="SpringCloud-与-SpringBoot-版本兼容关系"><a href="#SpringCloud-与-SpringBoot-版本兼容关系" class="headerlink" title="SpringCloud 与 SpringBoot 版本兼容关系"></a>SpringCloud 与 SpringBoot 版本兼容关系</h2><table>
<thead>
<tr>
<th>Release Train</th>
<th>Boot Version</th>
</tr>
</thead>
<tbody>
<tr>
<td>Greenwich<br></td>
<td>2.1.x<br></td>
</tr>
<tr>
<td>Finchley<br></td>
<td>2.0.x<br></td>
</tr>
<tr>
<td>Edgware<br></td>
<td>1.5.x<br></td>
</tr>
<tr>
<td>Dalston<br></td>
<td>1.5.x<br></td>
</tr>
</tbody>
</table>
<h2 id="SpringCloud-与子工程版本关系"><a href="#SpringCloud-与子工程版本关系" class="headerlink" title="SpringCloud 与子工程版本关系"></a>SpringCloud 与子工程版本关系</h2><table>
<thead>
<tr>
<th>Component</th>
<th>Edgware.SR5</th>
<th>Finchley.SR2</th>
<th>Finchley.BUILD-SNAPSHOT</th>
</tr>
</thead>
<tbody>
<tr>
<td>spring-cloud-aws<br></td>
<td>1.2.3.RELEASE<br></td>
<td>2.0.1.RELEASE<br></td>
<td>2.0.1.BUILD-SNAPSHOT<br></td>
</tr>
<tr>
<td>spring-cloud-bus<br></td>
<td>1.3.3.RELEASE<br></td>
<td>2.0.0.RELEASE<br></td>
<td>2.0.1.BUILD-SNAPSHOT<br></td>
</tr>
<tr>
<td>spring-cloud-cli<br></td>
<td>1.4.1.RELEASE<br></td>
<td>2.0.0.RELEASE<br></td>
<td>2.0.1.BUILD-SNAPSHOT<br></td>
</tr>
<tr>
<td>spring-cloud-commons<br></td>
<td>1.3.5.RELEASE<br></td>
<td>2.0.2.RELEASE<br></td>
<td>2.0.2.BUILD-SNAPSHOT<br></td>
</tr>
<tr>
<td>spring-cloud-contract<br></td>
<td>1.2.6.RELEASE<br></td>
<td>2.0.2.RELEASE<br></td>
<td>2.0.2.BUILD-SNAPSHOT<br></td>
</tr>
<tr>
<td>spring-cloud-config<br></td>
<td>1.4.5.RELEASE<br></td>
<td>2.0.2.RELEASE<br></td>
<td>2.0.2.BUILD-SNAPSHOT<br></td>
</tr>
<tr>
<td>spring-cloud-netflix<br></td>
<td>1.4.6.RELEASE<br></td>
<td>2.0.2.RELEASE<br></td>
<td>2.0.2.BUILD-SNAPSHOT<br></td>
</tr>
<tr>
<td>spring-cloud-security<br></td>
<td>1.2.3.RELEASE<br></td>
<td>2.0.1.RELEASE<br></td>
<td>2.0.1.BUILD-SNAPSHOT<br></td>
</tr>
<tr>
<td>spring-cloud-cloudfoundry<br></td>
<td>1.1.2.RELEASE<br></td>
<td>2.0.1.RELEASE<br></td>
<td>2.0.1.BUILD-SNAPSHOT<br></td>
</tr>
<tr>
<td>spring-cloud-consul<br></td>
<td>1.3.5.RELEASE<br></td>
<td>2.0.1.RELEASE<br></td>
<td>2.0.2.BUILD-SNAPSHOT<br></td>
</tr>
<tr>
<td>spring-cloud-sleuth<br></td>
<td>1.3.5.RELEASE<br></td>
<td>2.0.2.RELEASE<br></td>
<td>2.0.2.BUILD-SNAPSHOT<br></td>
</tr>
<tr>
<td>spring-cloud-stream<br></td>
<td>Ditmars.SR4<br></td>
<td>Elmhurst.SR1<br></td>
<td>Elmhurst.BUILD-SNAPSHOT<br></td>
</tr>
<tr>
<td>spring-cloud-zookeeper<br></td>
<td>1.2.2.RELEASE<br></td>
<td>2.0.0.RELEASE<br></td>
<td>2.0.1.BUILD-SNAPSHOT<br></td>
</tr>
<tr>
<td>spring-boot<br></td>
<td>1.5.16.RELEASE<br></td>
<td>2.0.6.RELEASE<br></td>
<td>2.0.7.BUILD-SNAPSHOT<br></td>
</tr>
<tr>
<td>spring-cloud-task<br></td>
<td>1.2.3.RELEASE<br></td>
<td>2.0.0.RELEASE<br></td>
<td>2.0.1.BUILD-SNAPSHOT<br></td>
</tr>
<tr>
<td>spring-cloud-vault<br></td>
<td>1.1.2.RELEASE<br></td>
<td>2.0.2.RELEASE<br></td>
<td>2.0.2.BUILD-SNAPSHOT<br></td>
</tr>
<tr>
<td>spring-cloud-gateway<br></td>
<td>1.0.2.RELEASE<br></td>
<td>2.0.2.RELEASE<br></td>
<td>2.0.2.BUILD-SNAPSHOT<br></td>
</tr>
<tr>
<td>spring-cloud-openfeign<br></td>
<td></td>
<td>2.0.2.RELEASE<br></td>
<td>2.0.2.BUILD-SNAPSHOT<br></td>
</tr>
<tr>
<td>spring-cloud-function<br></td>
<td>1.0.1.RELEASE<br></td>
<td>1.0.0.RELEASE<br></td>
<td>1.0.1.BUILD-SNAPSHOT<br></td>
</tr>
</tbody>
</table>
<ul>
<li>Finchley 构建并使用Spring Boot 2.0.x，与 Spring Boot 1.5.x 不兼容。</li>
<li>Dalston 和 Edgware 基于 Spring Boot 1.5.x 构建，不兼容 SpringBoot 2.0.x </li>
<li>Camden 版本迭代正式结束，Dalston 将于2018年12月结束使用，Edgware 将遵循 Spring Boot 1.5.x 的生命周期结束。</li>
<li>Camden 基于SpringBoot 1.4.x 构建，但是也会支持 1.5.x 版本</li>
<li>Brixton 和 Angel 迭代结束时间是2017年7月，Brixton 基于SpringBoot 1.3.x ，同时也支持 1.4.x 版本</li>
<li>Angel 基于 SpringBoot 1.2.x ,在某些方式不兼容 SpringBoot 1.3.x 。</li>
<li>Brixton 构建在SpringBoot 1.3.x ，不兼容 SpringBoot 1.2.x 。一些基于Angel的库和大多数应用程序可以在Brixton上正常运行，但如果OAuth2具备spring-cloud-security 1.0的特性，则需要在任何地方进行更改。x被使用(它们大多在1.3.0中被移到Spring Boot中)。</li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/12/31/springboot/springcloud-overview/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/12/23/spring-session-idresolver/">SpringSession系列-sessionId解析和Cookie读写策略</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-12-22T16:10:59.000Z" itemprop="datePublished">2018/12/23</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/12/23/spring-session-idresolver/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/session/" title="session">session</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<blockquote>
<p>首先需求在这里说明下，SpringSession的版本迭代的过程中肯定会伴随着一些类的移除和一些类的加入，目前本系列使用的版本是github上对象的master的代码流版本。如果有同学对其他版本中的一些类或者处理有疑惑，欢迎交流。</p>
</blockquote>
<p>本篇将来介绍下<code>SpringSession</code>中两种<code>sessionId</code>解析的策略，这个在之前的文章中其实是有提到过的，这里再拿出来和<code>SpringSession</code>中<code>Cookie</code>相关策略一起学习下。</p>
<h1 id="sessionId-解析策略"><a href="#sessionId-解析策略" class="headerlink" title="sessionId 解析策略"></a>sessionId 解析策略</h1><p><code>SpringSession</code>中对于<code>sessionId</code>的解析相关的策略是通过<code>HttpSessionIdResolver</code>这个接口来体现的。<code>HttpSessionIdResolver</code>有两个实现类：<br><img src="https://img-blog.csdnimg.cn/20181216224001789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzI1NTE4MzQ5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>这两个类就分别对应<code>SpringSession</code>解析<code>sessionId</code>的两种不同的实现策略。再深入了解不同策略的实现细节之前，先来看下<code>HttpSessionIdResolver</code>接口定义的一些行为有哪些。</p>
<h2 id="HttpSessionIdResolver"><a href="#HttpSessionIdResolver" class="headerlink" title="HttpSessionIdResolver"></a>HttpSessionIdResolver</h2><p><code>HttpSessionIdResolver</code>定义了<code>sessionId</code>解析策略的契约（<code>Contract</code>）。允许通过请求解析sessionId，并通过响应发送sessionId或终止会话。接口定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpSessionIdResolver</span> </span>&#123;</span><br><span class="line">	<span class="function">List&lt;String&gt; <span class="title">resolveSessionIds</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setSessionId</span><span class="params">(HttpServletRequest request, HttpServletResponse response,String sessionId)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">expireSession</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>HttpSessionIdResolver</code>中有三个方法：</p>
<ul>
<li><code>resolveSessionIds</code>：解析与当前请求相关联的<code>sessionId</code>。<code>sessionId</code>可能来自<code>Cookie</code>或请求头。</li>
<li><code>setSessionId</code>：将给定的<code>sessionId</code>发送给客户端。这个方法是在创建一个新<code>session</code>时被调用，并告知客户端新<code>sessionId</code>是什么。</li>
<li><code>expireSession</code>：指示客户端结束当前<code>session</code>。当<code>session</code>无效时调用此方法，并应通知客户端<code>sessionId</code>不再有效。比如，它可能删除一个包含<code>sessionId</code>的<code>Cookie</code>，或者设置一个<code>HTTP</code>响应头，其值为空就表示客户端不再提交<code>sessionId</code>。</li>
</ul>
<p>下面就针对上面提到的两种策略来进行详细的分析。</p>
<h2 id="基于Cookie解析sessionId"><a href="#基于Cookie解析sessionId" class="headerlink" title="基于Cookie解析sessionId"></a>基于Cookie解析sessionId</h2><p>这种策略对应的实现类是<code>CookieHttpSessionIdResolver</code>，通过从<code>Cookie</code>中获取<code>session</code>；具体来说，这个实现将允许使用<code>CookieHttpSessionIdResolver#setCookieSerializer(CookieSerializer)</code>指定<code>Cookie</code>序列化策略。默认的<code>Cookie</code>名称是“<code>SESSION</code>”。创建一个<code>session</code>时，<code>HTTP</code>响应中将会携带一个指定 <code>Cookie name</code>且<code>value</code>是<code>sessionId</code>的<code>Cookie</code>。<code>Cookie</code> 将被标记为一个 <code>session cookie</code>，<code>Cookie</code> 的 <code>domain path</code> 使用 <code>context path</code>，且被标记为<code>HttpOnly</code>，如果<code>HttpServletRequest#isSecure()</code>返回<code>true</code>，那么<code>Cookie</code>将标记为安全的。如下：</p>
<blockquote>
<p>关于<code>Cookie</code>，可以参考：<a href="http://www.glmapper.com/2018/11/10/sessionone/">聊一聊session和cookie</a>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Set-Cookie: SESSION=f81d4fae-7dec-11d0-a765-00a0c91e6bf6; Path=/context-root; Secure; HttpOnly</span><br></pre></td></tr></table></figure>
<p>这个时候，客户端应该通过在每个请求中指定相同的<code>Cookie</code>来包含<code>session</code>信息。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /messages/ HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Cookie: SESSION=f81d4fae-7dec-11d0-a765-00a0c91e6bf6</span><br></pre></td></tr></table></figure></p>
<p>当会话无效时，服务器将发送过期的<code>HTTP</code>响应<code>Cookie</code>，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Set-Cookie: SESSION=f81d4fae-7dec-11d0-a765-00a0c91e6bf6; Expires=Thur, 1 Jan 1970 00:00:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure>
<p><code>CookieHttpSessionIdResolver</code> 类的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieHttpSessionIdResolver</span> <span class="keyword">implements</span> <span class="title">HttpSessionIdResolver</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WRITTEN_SESSION_ID_ATTR = CookieHttpSessionIdResolver.class</span><br><span class="line">			.getName().concat(<span class="string">".WRITTEN_SESSION_ID_ATTR"</span>);</span><br><span class="line">	<span class="comment">// Cookie序列化策略，默认是 DefaultCookieSerializer</span></span><br><span class="line">	<span class="keyword">private</span> CookieSerializer cookieSerializer = <span class="keyword">new</span> DefaultCookieSerializer();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">resolveSessionIds</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 根据提供的cookieSerializer从请求中获取sessionId</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.cookieSerializer.readCookieValues(request);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSessionId</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">			String sessionId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (sessionId.equals(request.getAttribute(WRITTEN_SESSION_ID_ATTR))) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		request.setAttribute(WRITTEN_SESSION_ID_ATTR, sessionId);</span><br><span class="line">		<span class="comment">// 根据提供的cookieSerializer将sessionId回写到cookie中</span></span><br><span class="line">		<span class="keyword">this</span>.cookieSerializer</span><br><span class="line">				.writeCookieValue(<span class="keyword">new</span> CookieValue(request, response, sessionId));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireSession</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 这里因为是过期，所以回写的sessionId的值是“”，当请求下次进来时，就会取不到sessionId，也就意味着当前会话失效了</span></span><br><span class="line">		<span class="keyword">this</span>.cookieSerializer.writeCookieValue(<span class="keyword">new</span> CookieValue(request, response, <span class="string">""</span>));</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 指定Cookie序列化的方式</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCookieSerializer</span><span class="params">(CookieSerializer cookieSerializer)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (cookieSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"cookieSerializer cannot be null"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.cookieSerializer = cookieSerializer;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里可以看到<code>CookieHttpSessionIdResolver</code> 中的读取操作都是围绕<code>CookieSerializer</code>来完成的。<code>CookieSerializer</code> 是<code>SpringSession</code>中对于<code>Cookie</code>操作提供的一种机制。下面细说。</p>
<h2 id="基于请求头解析sessionId"><a href="#基于请求头解析sessionId" class="headerlink" title="基于请求头解析sessionId"></a>基于请求头解析sessionId</h2><p>这种策略对应的实现类是<code>HeaderHttpSessionIdResolver</code>，通过从请求头<code>header</code>中解析出<code>sessionId</code>。具体地说，这个实现将允许使用<code>HeaderHttpSessionIdResolver(String)</code>来指定头名称。还可以使用便利的工厂方法来创建使用公共头名称(例如<code>“X-Auth-Token”</code>和<code>“authenticing-info”</code>)的实例。创建会话时，<code>HTTP</code>响应将具有指定名称和<code>sessionId</code>值的响应头。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用X-Auth-Token作为headerName</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeaderHttpSessionIdResolver <span class="title">xAuthToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> HeaderHttpSessionIdResolver(HEADER_X_AUTH_TOKEN);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用Authentication-Info作为headerName</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeaderHttpSessionIdResolver <span class="title">authenticationInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> HeaderHttpSessionIdResolver(HEADER_AUTHENTICATION_INFO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HeaderHttpSessionIdResolver</code>在处理<code>sessionId</code>上相比较于<code>CookieHttpSessionIdResolver</code>来说简单很多。就是围绕<code>request.getHeader(String)</code>和<code>request.setHeader(String,String)</code><br>两个方法来玩的。</p>
<p><code>HeaderHttpSessionIdResolver</code>这种策略通常会在无线端来使用，以弥补对于无<code>Cookie</code>场景的支持。</p>
<h1 id="Cookie-序列化策略"><a href="#Cookie-序列化策略" class="headerlink" title="Cookie 序列化策略"></a>Cookie 序列化策略</h1><p>基于<code>Cookie</code>解析<code>sessionId</code>的实现类<code>CookieHttpSessionIdResolver</code> 中实际对于<code>Cookie</code>的读写操作都是通过<code>CookieSerializer</code>来完成的。<code>SpringSession</code> 提供了<code>CookieSerializer</code>接口的默认实现<code>DefaultCookieSerializer</code>，当然在实际应用中，我们也可以自己实现这个接口，然后通过<code>CookieHttpSessionIdResolver#setCookieSerializer(CookieSerializer)</code>方法来指定我们自己的实现方式。</p>
<blockquote>
<p>PS：不得不说，强大的用户扩展能力真的是<code>Spring</code>家族的优良家风。</p>
</blockquote>
<p>篇幅有限，这里就只看下两个点：</p>
<ul>
<li><code>CookieValue</code> 存在的意义是什么</li>
<li><code>DefaultCookieSerializer</code>回写<code>Cookie</code>的的具体实现，读<code>Cookie</code>在 <a href="http://www.glmapper.com/2018/11/24/springsessiontwo/">SpringSession系列-请求与响应重写</a> 这篇文章中有介绍过，这里不再赘述。</li>
<li>jvm_router的处理</li>
</ul>
<h2 id="CookieValue"><a href="#CookieValue" class="headerlink" title="CookieValue"></a>CookieValue</h2><p><code>CookieValue</code>是<code>CookieSerializer</code>中的内部类，封装了向<code>HttpServletResponse</code>写入所需的所有信息。其实<code>CookieValue</code>的存在并没有什么特殊的意义，个人觉得作者一开始只是想通过<code>CookieValue</code>的封装来简化回写<code>cookie</code>链路中的参数传递的问题，但是实际上貌似并没有什么减少多少工作量。</p>
<h2 id="Cookie-回写"><a href="#Cookie-回写" class="headerlink" title="Cookie 回写"></a>Cookie 回写</h2><p><code>Cookie</code> 回写我觉得对于分布式<code>session</code>的实现来说是必不可少的；基于标准<code>servlet</code>实现的<code>HttpSession</code>，我们在使用时实际上是不用关心回写<code>cookie</code>这个事情的，因为<code>servlet</code>容器都已经做了。但是对于分布式<code>session</code>来说，由于重写了<code>response</code>，所以需要在返回<code>response</code>时需要将当前<code>session</code>信息通过<code>cookie</code>的方式塞到<code>response</code>中返回给客户端-这就是<code>Cookie</code>回写。下面是<code>DefaultCookieSerializer</code>中回写<code>Cookie</code>的逻辑，细节在代码中通过注释标注出来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeCookieValue</span><span class="params">(CookieValue cookieValue)</span> </span>&#123;</span><br><span class="line">	HttpServletRequest request = cookieValue.getRequest();</span><br><span class="line">	HttpServletResponse response = cookieValue.getResponse();</span><br><span class="line">	StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	sb.append(<span class="keyword">this</span>.cookieName).append(<span class="string">'='</span>);</span><br><span class="line">	String value = getValue(cookieValue);</span><br><span class="line">	<span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		validateValue(value);</span><br><span class="line">		sb.append(value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> maxAge = getMaxAge(cookieValue);</span><br><span class="line">	<span class="keyword">if</span> (maxAge &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">		sb.append(<span class="string">"; Max-Age="</span>).append(cookieValue.getCookieMaxAge());</span><br><span class="line">		OffsetDateTime expires = (maxAge != <span class="number">0</span>)</span><br><span class="line">				? OffsetDateTime.now().plusSeconds(maxAge)</span><br><span class="line">				: Instant.EPOCH.atOffset(ZoneOffset.UTC);</span><br><span class="line">		sb.append(<span class="string">"; Expires="</span>)</span><br><span class="line">				.append(expires.format(DateTimeFormatter.RFC_1123_DATE_TIME));</span><br><span class="line">	&#125;</span><br><span class="line">	String domain = getDomainName(request);</span><br><span class="line">	<span class="keyword">if</span> (domain != <span class="keyword">null</span> &amp;&amp; domain.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		validateDomain(domain);</span><br><span class="line">		sb.append(<span class="string">"; Domain="</span>).append(domain);</span><br><span class="line">	&#125;</span><br><span class="line">	String path = getCookiePath(request);</span><br><span class="line">	<span class="keyword">if</span> (path != <span class="keyword">null</span> &amp;&amp; path.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		validatePath(path);</span><br><span class="line">		sb.append(<span class="string">"; Path="</span>).append(path);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (isSecureCookie(request)) &#123;</span><br><span class="line">		sb.append(<span class="string">"; Secure"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.useHttpOnlyCookie) &#123;</span><br><span class="line">		sb.append(<span class="string">"; HttpOnly"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.sameSite != <span class="keyword">null</span>) &#123;</span><br><span class="line">		sb.append(<span class="string">"; SameSite="</span>).append(<span class="keyword">this</span>.sameSite);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	response.addHeader(<span class="string">"Set-Cookie"</span>, sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这上面就是拼凑字符串，然后塞到Header里面去，最终再浏览器中显示大体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: SESSION=f81d4fae-7dec-11d0-a765-00a0c91e6bf6; Path=/context-root; Secure; HttpOnly</span><br></pre></td></tr></table></figure>
<h2 id="jvm-router的处理"><a href="#jvm-router的处理" class="headerlink" title="jvm_router的处理"></a>jvm_router的处理</h2><p>在<code>Cookie</code>的读写代码中都涉及到对于<code>jvmRoute</code>这个属性的判断及对应的处理逻辑。</p>
<p>1、读取<code>Cookie</code>中的代码片段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.jvmRoute != <span class="keyword">null</span> &amp;&amp; sessionId.endsWith(<span class="keyword">this</span>.jvmRoute)) &#123;</span><br><span class="line">	sessionId = sessionId.substring(<span class="number">0</span>,</span><br><span class="line">			sessionId.length() - <span class="keyword">this</span>.jvmRoute.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、回写<code>Cookie</code>中的代码片段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.jvmRoute != <span class="keyword">null</span>) &#123;</span><br><span class="line">	actualCookieValue = requestedCookieValue + <span class="keyword">this</span>.jvmRoute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>jvm_route</code>是<code>Nginx</code>中的一个模块，其作用是通过<code>session cookie</code>的方式来获取<code>session</code>粘性。如果在<code>cookie</code>和<code>url</code>中并没有<code>session</code>，则这只是个简单的 <code>round-robin</code> 负载均衡。其具体过程分为以下几步：</p>
<ul>
<li>1.第一个请求过来，没有带<code>session</code>信息，<code>jvm_route</code>就根据<code>round robin</code>策略发到一台<code>tomcat</code>上面。</li>
<li>2.<code>tomcat</code>添加上 <code>session</code> 信息，并返回给客户。</li>
<li>3.用户再次请求，<code>jvm_route</code>看到<code>session</code>中有后端服务器的名称，它就把请求转到对应的服务器上。</li>
</ul>
<p>从本质上来说，<code>jvm_route</code>也是解决<code>session</code>共享的一种解决方式。这种和 <a href="http://www.glmapper.com/2018/11/24/springsessionthree/">SpringSession系列-分布式Session实现方案</a> 中提到的基于<code>IP-HASH</code>的方式有点类似。那么同样，这里存在的问题是无法解决宕机后<code>session</code>数据转移的问题，既宕机就丢失。</p>
<p><code>DefaultCookieSerializer</code> 中除了<code>Cookie</code>的读写之后，还有一些细节也值得关注下，比如对<code>Cookie</code>中值的验证、<code>remember-me</code>的实现等。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://docs.spring.io/spring-session/docs/2.1.2.RELEASE/reference/html5/" target="_blank" rel="noopener">SpringSession官方文档</a></li>
<li><a href="https://blog.csdn.net/cao_j/article/details/51191764" target="_blank" rel="noopener">jvm_router原理</a></li>
<li><a href="https://github.com/glmapper/spring-session/tree/cn-spring-session" target="_blank" rel="noopener">SpringSession中文注释持续更新代码分支</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/12/23/spring-session-idresolver/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/12/16/shufa-20181216/">20181216-书法练习</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-12-16T07:30:58.000Z" itemprop="datePublished">2018/12/16</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/12/16/shufa-20181216/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/书法/" title="书法">书法</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<blockquote>
<p>春江花月夜 -张若虚<br>春江潮水连海平，海上明月共潮生。<br>滟滟随波千万里，何处春江无月明！<br>江流宛转绕芳甸，月照花林皆似霰；<br>空里流霜不觉飞，汀上白沙看不见。<br>江天一色无纤尘，皎皎空中孤月轮。<br>江畔何人初见月？江月何年初照人？<br>人生代代无穷已，江月年年只相似。<br>不知江月待何人，但见长江送流水。<br>白云一片去悠悠，青枫浦上不胜愁。<br>谁家今夜扁舟子？何处相思明月楼？<br>可怜楼上月徘徊，应照离人妆镜台。<br>玉户帘中卷不去，捣衣砧上拂还来。<br>此时相望不相闻，愿逐月华流照君。<br>鸿雁长飞光不度，鱼龙潜跃水成文。<br>昨夜闲潭梦落花，可怜春半不还家。<br>江水流春去欲尽，江潭落月复西斜。<br>斜月沉沉藏海雾，碣石潇湘无限路。<br>不知乘月几人归，落月摇情满江树。</p>
</blockquote>
<p><img src="https://github.com/glmapper/glmapper.github.io/blob/master/images/self/shufa-yb-chunjianghuayueye.jpg?raw=true" alt=""></p>
<p><img src="https://github.com/glmapper/glmapper.github.io/blob/master/images/self/shufa-rb-chunjianghuayueye.jpg?raw=true" alt=""></p>
<blockquote>
<p>闻王昌龄左迁龙标遥有此寄 -李白<br>杨花落尽子规啼，闻道龙标过五溪。<br>我寄愁心与明月，随风直到夜郎西。</p>
</blockquote>
<p><img src="https://github.com/glmapper/glmapper.github.io/blob/master/images/self/shufa-yanghualuojinziguiti.jpg?raw=true" alt=""></p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/12/16/shufa-20181216/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/12/16/spring-session-redis-map/">SpringSession系列-存储机制之Redis&amp;Map</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-12-15T17:30:38.000Z" itemprop="datePublished">2018/12/16</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/12/16/spring-session-redis-map/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/session/" title="session">session</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>在之前的文章中已经对<code>SpringSession</code>的功能结构，请求/响应重写等做了介绍。本文将继续来介绍下<code>SpringSession</code>中存储部分的设计。存储是分布式<code>session</code>中算是最核心的部分，通过引入三方的存储容器来实现<code>session</code>的存储，从而有效的解决<code>session</code>共享的问题。</p>
<h2 id="1、SpringSession存储的顶级抽象接口"><a href="#1、SpringSession存储的顶级抽象接口" class="headerlink" title="1、SpringSession存储的顶级抽象接口"></a>1、SpringSession存储的顶级抽象接口</h2><p><code>SpringSession</code>存储的顶级抽象接口是<code>org.springframework.session</code>包下的<code>SessionRepository</code>这个接口。<code>SessionRepository</code>的类图结构如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef7ce8c6b58?w=1662&amp;h=600&amp;f=png&amp;s=66844" alt=""></p>
<p>这里先来看下<code>SessionRepository</code>这个顶层接口中定义了哪些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SessionRepository</span>&lt;<span class="title">S</span> <span class="keyword">extends</span> <span class="title">Session</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个session</span></span><br><span class="line">	<span class="function">S <span class="title">createSession</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//保存session</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(S session)</span></span>;</span><br><span class="line">	<span class="comment">//通过ID查找session</span></span><br><span class="line">	<span class="function">S <span class="title">findById</span><span class="params">(String id)</span></span>;</span><br><span class="line">	<span class="comment">//通过ID删除一个session</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码来看还是很简单的，就是增删查。下面看具体实现。在2.0版本开始<code>SpringSession</code>中也提供了一个和<code>SessionRepository</code>具体相同能力的<code>ReactiveSessionRepository</code>，用于支持响应式编程模式。</p>
<h2 id="2、MapSessionRepository"><a href="#2、MapSessionRepository" class="headerlink" title="2、MapSessionRepository"></a>2、MapSessionRepository</h2><p>基于HashMap实现的基于内存存储的存储器实现，这里就主要看下对于接口中几个方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapSessionRepository</span> <span class="keyword">implements</span> <span class="title">SessionRepository</span>&lt;<span class="title">MapSession</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Integer defaultMaxInactiveInterval;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Session&gt; sessions;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到就是一个<code>Map</code>，那后面关于增删查其实就是操作这个<code>Map</code>了。</p>
<h3 id="createSession"><a href="#createSession" class="headerlink" title="createSession"></a>createSession</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MapSession <span class="title">createSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MapSession result = <span class="keyword">new</span> MapSession();</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.defaultMaxInactiveInterval != <span class="keyword">null</span>) &#123;</span><br><span class="line">		result.setMaxInactiveInterval(</span><br><span class="line">			Duration.ofSeconds(<span class="keyword">this</span>.defaultMaxInactiveInterval));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里很直接，就是<code>new</code>了一个<code>MapSession</code>，然后设置了<code>session</code>的有效期。</p>
<h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(MapSession session)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!session.getId().equals(session.getOriginalId())) &#123;</span><br><span class="line">		<span class="keyword">this</span>.sessions.remove(session.getOriginalId());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">this</span>.sessions.put(session.getId(), <span class="keyword">new</span> MapSession(session));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面先判断了<code>session</code>中的两个<code>ID</code>，一个<code>originalId</code>，一个当前<code>id</code>。<code>originalId</code>是第一次生成<code>session</code>对象时创建的，后面都不会在变化。通过源码来看，对于<code>originalId</code>，只提供了<code>get</code>方法。对于<code>id</code>呢，其实是可以通过<code>changeSessionId</code>来改变的。</p>
<p>这里的这个操作实际上是一种优化行为，及时的清除掉老的<code>session</code>数据来释放内存空间。</p>
<h3 id="findById"><a href="#findById" class="headerlink" title="findById"></a>findById</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MapSession <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">	Session saved = <span class="keyword">this</span>.sessions.get(id);</span><br><span class="line">	<span class="keyword">if</span> (saved == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (saved.isExpired()) &#123;</span><br><span class="line">		deleteById(saved.getId());</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> MapSession(saved);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个逻辑也很简单，先从<code>Map</code>中根据<code>id</code>取出<code>session</code>数据，如果没有就返回<code>null</code>，如果有则再判断下是否过期了，如果过期了就删除掉，然后返回<code>null</code>。如果查到了，并且没有过期的话，则构建一个<code>MapSession</code>返回。</p>
<p>OK，基于内存存储的实现系列就是这些了，下面继续来看其他存储的实现。</p>
<h2 id="3、FindByIndexNameSessionRepository"><a href="#3、FindByIndexNameSessionRepository" class="headerlink" title="3、FindByIndexNameSessionRepository"></a>3、FindByIndexNameSessionRepository</h2><p><code>FindByIndexNameSessionRepository</code>继承了<code>SessionRepository</code>接口，用于扩展对第三方存储的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FindByIndexNameSessionRepository</span>&lt;<span class="title">S</span> <span class="keyword">extends</span> <span class="title">Session</span>&gt;</span></span><br><span class="line"><span class="class">		<span class="keyword">extends</span> <span class="title">SessionRepository</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">		</span><br><span class="line">	String PRINCIPAL_NAME_INDEX_NAME = FindByIndexNameSessionRepository.class.getName()</span><br><span class="line">			.concat(<span class="string">".PRINCIPAL_NAME_INDEX_NAME"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function">Map&lt;String, S&gt; <span class="title">findByIndexNameAndIndexValue</span><span class="params">(String indexName, String indexValue)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Map&lt;String, S&gt; <span class="title">findByPrincipalName</span><span class="params">(String principalName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> findByIndexNameAndIndexValue(PRINCIPAL_NAME_INDEX_NAME, principalName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FindByIndexNameSessionRepository</code>添加一个单独的方法为指定用户查询所有会话。这是通过设置名为<code>FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME</code>的<code>Session</code>的属性值为指定用户的<code>username</code>来完成的。开发人员有责任确保属性被赋值，因为<code>SpringSession</code>不会在意被使用的认证机制。官方文档中给出的例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String username = <span class="string">"username"</span>;</span><br><span class="line"><span class="keyword">this</span>.session.setAttribute(</span><br><span class="line">	FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME, username);</span><br></pre></td></tr></table></figure>
<p><code>FindByIndexNameSessionRepository</code>的一些实现会提供一些钩子自动的索引其他的<code>session</code>属性。比如，很多实现都会自动的确保当前的<code>Spring Security</code>用户名称可通过索引名称<code>FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME</code>进行索引。一旦会话被索引，就可以通过下面的代码检索：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String username = <span class="string">"username"</span>;</span><br><span class="line">Map&lt;String, Session&gt; sessionIdToSession = </span><br><span class="line">	<span class="keyword">this</span>.sessionRepository.findByIndexNameAndIndexValue(</span><br><span class="line">	FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME,username);</span><br></pre></td></tr></table></figure>
<p>下图是<code>FindByIndexNameSessionRepository</code>接口的三个实现类：<br><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef0284d86a5?w=1624&amp;h=258&amp;f=png&amp;s=66960" alt="FindByIndexNameSessionRepository"></p>
<p>下面来分别分析下这三个存储的实现细节。</p>
<h3 id="3-1-RedisOperationsSessionRepository"><a href="#3-1-RedisOperationsSessionRepository" class="headerlink" title="3.1 RedisOperationsSessionRepository"></a>3.1 RedisOperationsSessionRepository</h3><p><code>RedisOperationsSessionRepository</code>的类图结构如下，<code>MessageListener</code>是<code>redis</code>消息订阅的监听接口。<br><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef029530952?w=1128&amp;h=596&amp;f=png&amp;s=67475" alt="在这里插入图片描述"></p>
<p>代码有点长，就不在这里面贴了，一些注释可以在这个 <a href="https://github.com/glmapper/spring-session/tree/cn-spring-session" target="_blank" rel="noopener">SpringSession中文分支</a> 来看。这里还是主要来看下对于那几个方法的实现。</p>
<h4 id="3-1-1-createSession"><a href="#3-1-1-createSession" class="headerlink" title="3.1.1 createSession"></a>3.1.1 createSession</h4><p>这里和<code>MapSessionRepository</code>的实现基本一样的，那区别就在于<code>Session</code>的封装模型不一样，这里是<code>RedisSession</code>，实际上<code>RedisSession</code>的实现是对<code>MapSession</code>又包了一层。下面会分析<code>RedisSession</code>这个类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisSession <span class="title">createSession</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// RedisSession,这里和MapSession区别开</span></span><br><span class="line">	RedisSession redisSession = <span class="keyword">new</span> RedisSession();</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.defaultMaxInactiveInterval != <span class="keyword">null</span>) &#123;</span><br><span class="line">		redisSession.setMaxInactiveInterval(</span><br><span class="line">				Duration.ofSeconds(<span class="keyword">this</span>.defaultMaxInactiveInterval));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> redisSession;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在看其他两个方法之前，先来看下<code>RedisSession</code>这个类。</p>
<h4 id="3-1-2-RedisSession"><a href="#3-1-2-RedisSession" class="headerlink" title="3.1.2 RedisSession"></a>3.1.2 RedisSession</h4><p>这个在模型上是对<code>MapSession</code>的扩展，增加了<code>delta</code>这个东西。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSession</span> <span class="keyword">implements</span> <span class="title">Session</span> </span>&#123;</span><br><span class="line">       <span class="comment">// MapSession 实例对象，主要存数据的地方</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> MapSession cached;</span><br><span class="line">		<span class="comment">// 原始最后访问时间</span></span><br><span class="line">		<span class="keyword">private</span> Instant originalLastAccessTime;</span><br><span class="line">		<span class="keyword">private</span> Map&lt;String, Object&gt; delta = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="comment">// 是否是新的session对象</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">boolean</span> isNew;</span><br><span class="line">		<span class="comment">// 原始主名称</span></span><br><span class="line">		<span class="keyword">private</span> String originalPrincipalName;</span><br><span class="line">		<span class="comment">// 原始sessionId</span></span><br><span class="line">		<span class="keyword">private</span> String originalSessionId;</span><br></pre></td></tr></table></figure></p>
<p><code>delta</code>是一个Map结构，那么这里面到底是放什么的呢？具体细节见 <a href="https://github.com/glmapper/spring-session/blob/cn-spring-session/spring-session-data-redis/src/main/java/org/springframework/session/data/redis/RedisOperationsSessionRepository.java" target="_blank" rel="noopener">saveDelta</a> 这个方法。<code>saveDelta</code> 这个方法会在两个地方被调用，一个是下面要说道的<code>save</code>方法，另外一个是 <code>flushImmediateIfNecessary</code> 这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushImmediateIfNecessary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (RedisOperationsSessionRepository.<span class="keyword">this</span>.redisFlushMode == RedisFlushMode.IMMEDIATE) &#123;</span><br><span class="line">		saveDelta();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>RedisFlushMode</code>提供了两种推送模式：</p>
<ul>
<li>ON_SAVE：只有在调用<code>save</code>方法时执行，在<code>web</code>环境中这样做通常是尽快提交HTTP响应</li>
<li>IMMEDIATE：只要有变更就会直接写到<code>redis</code>中，不会像<code>ON_SAVE</code>一样，在最后<code>commit</code>时一次性写入</li>
</ul>
<p>追踪<code>flushImmediateIfNecessary</code> 方法调用链如下：<br><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b2ef032721690?w=1008&amp;h=258&amp;f=png&amp;s=89571" alt="在这里插入图片描述"><br>那么到这里基本就清楚了，首先<code>save</code>这个方法，当主动调用<code>save</code>时就是将数据推到<code>redis</code>中去的，也就是<code>ON_SAVE</code>这种情况。那么对于<code>IMMEDIATE</code>这种情况，只有调用了上面的四个方法，<code>SpringSession</code> 才会将数据推送到<code>redis</code>。</p>
<p>所以<code>delta</code>里面存的是当前一些变更的 <code>key-val</code> 键值对象，而这些变更是由<code>setAttribute</code>、<code>removeAttribute</code>、<code>setMaxInactiveIntervalInSeconds</code>、<code>setLastAccessedTime</code>这四个方法触发的；比如<code>setAttribute(k,v)</code>，那么这个<code>k-&gt;v</code>就会被保存到<code>delta</code>里面。</p>
<h4 id="3-1-3-save"><a href="#3-1-3-save" class="headerlink" title="3.1.3 save"></a>3.1.3 save</h4><p>在理解了<code>saveDelta</code>方法之后再来看<code>save</code>方法就简单多了。<code>save</code> 对应的就是<code>RedisFlushMode.ON_SAVE</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(RedisSession session)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 直接调用 saveDelta推数据到redis</span></span><br><span class="line">	session.saveDelta();</span><br><span class="line">	<span class="keyword">if</span> (session.isNew()) &#123;</span><br><span class="line">	   <span class="comment">// sessionCreatedKey-&gt;channl</span></span><br><span class="line">		String sessionCreatedKey = getSessionCreatedChannel(session.getId());</span><br><span class="line">		<span class="comment">// 发布一个消息事件，新增 session，以供 MessageListener 回调处理。</span></span><br><span class="line">		<span class="keyword">this</span>.sessionRedisOperations.convertAndSend(sessionCreatedKey, session.delta);</span><br><span class="line">		session.setNew(<span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-4-findById"><a href="#3-1-4-findById" class="headerlink" title="3.1.4 findById"></a>3.1.4 findById</h4><p>查询这部分和基于<code>Map</code>的差别比较大，因为这里并不是直接操作<code>Map</code>，而是与<code>Redis</code> 进行一次交互。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisSession <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> getSession(id, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用<code>getSession</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RedisSession <span class="title">getSession</span><span class="params">(String id, <span class="keyword">boolean</span> allowExpired)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 根据ID从redis中取出数据</span></span><br><span class="line">	Map&lt;Object, Object&gt; entries = getSessionBoundHashOperations(id).entries();</span><br><span class="line">	<span class="keyword">if</span> (entries.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//转换成MapSession</span></span><br><span class="line">	MapSession loaded = loadSession(id, entries);</span><br><span class="line">	<span class="keyword">if</span> (!allowExpired &amp;&amp; loaded.isExpired()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//转换成RedisSession</span></span><br><span class="line">	RedisSession result = <span class="keyword">new</span> RedisSession(loaded);</span><br><span class="line">	result.originalLastAccessTime = loaded.getLastAccessedTime();</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>loadSession</code>中构建<code>MapSession</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MapSession <span class="title">loadSession</span><span class="params">(String id, Map&lt;Object, Object&gt; entries)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 生成MapSession实例</span></span><br><span class="line">	MapSession loaded = <span class="keyword">new</span> MapSession(id);</span><br><span class="line">	<span class="comment">//遍历数据</span></span><br><span class="line">	<span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entries.entrySet()) &#123;</span><br><span class="line">		String key = (String) entry.getKey();</span><br><span class="line">		<span class="keyword">if</span> (CREATION_TIME_ATTR.equals(key)) &#123;</span><br><span class="line">		    <span class="comment">// 设置创建时间</span></span><br><span class="line">			loaded.setCreationTime(Instant.ofEpochMilli((<span class="keyword">long</span>) entry.getValue()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (MAX_INACTIVE_ATTR.equals(key)) &#123;</span><br><span class="line">			 <span class="comment">// 设置最大有效时间</span></span><br><span class="line">			loaded.setMaxInactiveInterval(Duration.ofSeconds((<span class="keyword">int</span>) entry.getValue()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (LAST_ACCESSED_ATTR.equals(key)) &#123;</span><br><span class="line">			<span class="comment">// 设置最后访问时间</span></span><br><span class="line">			loaded.setLastAccessedTime(Instant.ofEpochMilli((<span class="keyword">long</span>) entry.getValue()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key.startsWith(SESSION_ATTR_PREFIX)) &#123;</span><br><span class="line">		<span class="comment">// 设置属性</span></span><br><span class="line">			loaded.setAttribute(key.substring(SESSION_ATTR_PREFIX.length()),</span><br><span class="line">					entry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> loaded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-5-deleteById"><a href="#3-1-5-deleteById" class="headerlink" title="3.1.5 deleteById"></a>3.1.5 deleteById</h4><p>根据<code>sessionId</code>删除<code>session</code>数据。具体过程看代码注释。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(String sessionId)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取 RedisSession</span></span><br><span class="line">	RedisSession session = getSession(sessionId, <span class="keyword">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (session == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">   <span class="comment">// 清楚当前session数据的索引</span></span><br><span class="line">	cleanupPrincipalIndex(session);</span><br><span class="line">	<span class="comment">//执行删除操作</span></span><br><span class="line">	<span class="keyword">this</span>.expirationPolicy.onDelete(session);</span><br><span class="line">	String expireKey = getExpiredKey(session.getId());</span><br><span class="line">	<span class="comment">//删除expireKey</span></span><br><span class="line">	<span class="keyword">this</span>.sessionRedisOperations.delete(expireKey);</span><br><span class="line">	<span class="comment">//session有效期设置为0</span></span><br><span class="line">	session.setMaxInactiveInterval(Duration.ZERO);</span><br><span class="line">	save(session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-1-6-onMessage"><a href="#3-1-6-onMessage" class="headerlink" title="3.1.6 onMessage"></a>3.1.6 onMessage</h4><p>最后来看下这个订阅回调处理。这里看下核心的一段逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isDeleted = channel.equals(<span class="keyword">this</span>.sessionDeletedChannel);</span><br><span class="line"><span class="comment">// Deleted 还是 Expired ？</span></span><br><span class="line"><span class="keyword">if</span> (isDeleted || channel.equals(<span class="keyword">this</span>.sessionExpiredChannel)) &#123;</span><br><span class="line">	<span class="comment">// 此处省略无关代码</span></span><br><span class="line">	<span class="comment">// Deleted</span></span><br><span class="line">	<span class="keyword">if</span> (isDeleted) &#123;</span><br><span class="line">	   <span class="comment">// 发布一个 SessionDeletedEvent 事件</span></span><br><span class="line">		handleDeleted(session);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Expired</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 发布一个 SessionExpiredEvent 事件</span></span><br><span class="line">		handleExpired(session);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-Redis-存储的一些思考"><a href="#3-2-Redis-存储的一些思考" class="headerlink" title="3.2 Redis 存储的一些思考"></a>3.2 Redis 存储的一些思考</h3><p>首先按照我们自己常规的思路来设计的话，我们会怎么来考虑这个事情。这里首先要声明下，我对 <code>Redis</code> 这个东西不是很熟，没有做过深入的研究；那如果是我来做，可能也就仅仅限于存储。</p>
<ul>
<li><code>findByIndexNameAndIndexValue</code>的设计，这个的作用是通过<code>indexName</code>和<code>indexValue</code>来返回当前用户的所有会话。但是这里需要考虑的一个事情是，通常情况下，一个用户只会关联到一个会话上面去，那这种设计很显然，我的理解是为了支持单用户多会话的场景。<ul>
<li>indexName：FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME</li>
<li>indexValue：username</li>
</ul>
</li>
<li><p>实现 <code>MessageListener</code> 接口，增加事件通知能力。通过监听这些事件，可以做一些<code>session</code>操作管控。但是实际上 <code>SpringSession</code> 中并没有做任何事情，从代码来看，<code>publishEvent</code>方法是空实现。等待回复中 <a href="https://github.com/spring-projects/spring-session/issues/1287" target="_blank" rel="noopener">#issue 1287</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ApplicationEventPublisher eventPublisher = <span class="keyword">new</span> ApplicationEventPublisher() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>RedisFlushMode</code> ，<code>SpringSession</code>中提供了两种模式的推送，一种是<code>ON_SAVE</code>，另外一种是<code>IMMEDIATE</code>。默认是<code>ON_SAVE</code>，也就是常规的在请求处理结束时进行一次<code>sessionCommit</code>操作。<code>RedisFlushMode</code> 的设计感觉是为<code>session</code>数据持久化的时机提供了另外一种思路。</p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>存储机制设计部分就一基于内存和基于<code>Redis</code>两种来分析；另外基于<code>jdbc</code>和<code>hazelcast</code>有兴趣的同学可以自己查看源码。</p>
<p>最后也欢迎访问我的个人博客：<a href="http://www.glmapper.com">www.glmapper.com</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/zyhlwzy/article/details/78062646" target="_blank" rel="noopener">https://blog.csdn.net/zyhlwzy/article/details/78062646</a></li>
<li><a href="https://docs.spring.io/spring-session/docs/2.0.0.M4/reference/html5/#api" target="_blank" rel="noopener">https://docs.spring.io/spring-session/docs/2.0.0.M4/reference/html5/#api</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/12/16/spring-session-redis-map/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/12/07/sofa-tracer-mvc-plugin/">SOFATracer 插件埋点机制详解</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-12-07T14:34:14.000Z" itemprop="datePublished">2018/12/07</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/12/07/sofa-tracer-mvc-plugin/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/SOFATracer/" title="SOFATracer">SOFATracer</a>,
  
    <a href="/tags/Disruptor/" title="Disruptor">Disruptor</a>,
  
    <a href="/tags/OpenTracing/" title="OpenTracing">OpenTracing</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<blockquote>
<p>SOFATracer 是一个用于分布式系统调用跟踪的组件，通过统一的 <code>traceId</code> 将调用链路中的各种网络调用情况以日志的方式记录下来，以达到透视化网络调用的目的。这些日志可用于故障的快速发现，服务治理等。</p>
</blockquote>
<p>从 <a href="http://www.sofastack.tech/sofa-tracer/docs/roadmap" target="_blank" rel="noopener">RoadMap</a> 和 <a href="https://github.com/alipay/sofa-tracer/pulls" target="_blank" rel="noopener">PR</a> 来看，目前 SOFATracer 已经支持了丰富的组件插件埋点。</p>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543318400761-682a9d1a-b194-4a87-9fac-9e1a38a9247e.png" alt="img"></p>
<p>目前还未支持的主要是 Dubbo、MQ 以及 Redis 等。本文将从 SOFATracer 已提供的一个插件源码来分析下 SOFATracer 插件的埋点实现。</p>
<h2 id="1-SOFATracer-插件埋点机制"><a href="#1-SOFATracer-插件埋点机制" class="headerlink" title="1 SOFATracer 插件埋点机制"></a>1 SOFATracer 插件埋点机制</h2><p>SOFATracer 插件的作用实际上就是对于不同组件进行埋点，以便于收集这些组件的链路数据。SOFATracer 埋点方式一般是通过 Filter、Interceptor 机制实现的。</p>
<p>另一个是，SOFATracer 的埋点方式并不是基于 OT-api 进行埋点的，而是基于 SOFATracer 自己的 api 进行埋点的，详见 <a href="https://github.com/alipay/sofa-tracer/issues/126" target="_blank" rel="noopener">issue#126</a>。</p>
<h3 id="1-1-Filter-or-Interceptor"><a href="#1-1-Filter-or-Interceptor" class="headerlink" title="1.1 Filter or Interceptor"></a>1.1 Filter or Interceptor</h3><p>目前已实现的插件中，像 MVC 插件是基于 Filter 进行埋点的，httpclient、resttemplate 等是基于Interceptor进行埋点的。在实现插件时，要根据不同插件的特性来选择具体的埋点方式。</p>
<p> 当然除了这两种方式之外还可以通过静态代理的方式来实现埋点。比如 sofa-tracer-datasource-plugin 插件就是将不同的数据源进行统一代理给 SmartDatasource，从而实现埋点的。</p>
<h3 id="1-2-AbstractTracer-API"><a href="#1-2-AbstractTracer-API" class="headerlink" title="1.2 AbstractTracer API"></a>1.2 AbstractTracer API</h3><p>SOFATracer 中所有的插件均需要实现自己的 Tracer 实例，如 Mvc 的 SpringMvcTracer 、HttpClient的 HttpClientTracer 等，这一点与基于 Opentracing-api 接口埋点的实现有所区别。</p>
<ul>
<li>1、基于 SOFATracer api 埋点方式插件扩展</li>
</ul>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543324415543-aba1c5fe-7cb4-46ae-9aee-2fe5441a5f98.png" alt="img"></p>
<p>AbstractTracer 是 SOFATracer 用于插件扩展使用的一个抽象类，根据插件类型不同，又可以分为 clientTracer 和 serverTracer，分别对应于：AbstractClientTracer 和 AbstractServerTracer，再通过 AbstractClientTracer 和 AbstractServerTracer 衍生出具体的组件 Tracer 实现。这种方式的好处在于，所有的插件实现均由 SOFATracer 本身来管控，对于不同的组件可以轻松的实现差异化和定制化。缺点也源于此，每增加一个组件都需要做一些重复工作。</p>
<ul>
<li>2、基于 OpenTracing-api 埋点方式插件扩展</li>
</ul>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543324680485-cdb3793c-b830-490e-832f-b58e12091f7d.png" alt="img"></p>
<p>这种埋点方式不基于 SOFATracer  自身提供的 API，而是基于 OpenTracing-api 接口。因为均遵循 OpenTracing-api 规范，所以组件和 Tracer 实现可以独立分开来维护。这样就可以对接开源的一些基于 OpenTracing-api 规范实现的组件。例如：<a href="https://github.com/opentracing-contrib" target="_blank" rel="noopener">OpenTracing API Contributions</a>。</p>
<p>SOFATracer 在后面将会在 4.0 版本中支持基于 OT-api 的埋点方式，对外部组件接入扩展提供支持。</p>
<h3 id="1-3-AbstractTracer"><a href="#1-3-AbstractTracer" class="headerlink" title="1.3 AbstractTracer"></a>1.3 AbstractTracer</h3><p>这里先来看下 AbstractTracer  这个抽象类中具体提供了哪些抽象方法，也就是对于 AbstractClientTracer 和 AbstractServerTracer 需要分别扩展哪些能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取client端 摘要日志日志名</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getClientDigestReporterLogName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取client端 摘要日志滚动策略key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getClientDigestReporterRollingKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取client端 摘要日志日志名key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getClientDigestReporterLogNameKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取client端 摘要日志编码器</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getClientDigestEncoder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 创建client端 统计日志Reporter类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> AbstractSofaTracerStatisticReporter <span class="title">generateClientStatReporter</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志日志名</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getServerDigestReporterLogName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志滚动策略key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getServerDigestReporterRollingKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志日志名key</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getServerDigestReporterLogNameKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取server端 摘要日志编码器</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getServerDigestEncoder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 创建server端 统计日志Reporter类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> AbstractSofaTracerStatisticReporter <span class="title">generateServerStatReporter</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>从  AbstractTracer 类提供的抽象方法来看，不管是 client 还是 server，在具体的 Tracer 组件实现中，都必须提供以下实现：</p>
<ul>
<li>DigestReporterLogName :当前组件摘要日志的日志名称</li>
<li>DigestReporterRollingKey : 当前组件摘要日志的滚动策略</li>
<li>SpanEncoder：对摘要日志进行编码的编码器实现</li>
<li>AbstractSofaTracerStatisticReporter : 统计日志 reporter 类的实现类。</li>
</ul>
<h2 id="2-SpringMVC-插件埋点分析"><a href="#2-SpringMVC-插件埋点分析" class="headerlink" title="2 SpringMVC 插件埋点分析"></a>2 SpringMVC 插件埋点分析</h2><p>这里我们以 SpringMVC 插件为例，来分析下如何实现一个埋点插件的。这里是官方给出的案例工程：基于 <a href="https://github.com/alipay/sofa-tracer/blob/master/tracer-samples/tracer-sample-with-springmvc" target="_blank" rel="noopener">Spring MVC 示例落地日志</a> 。</p>
<h3 id="2-1-实现-Tracer-实例"><a href="#2-1-实现-Tracer-实例" class="headerlink" title="2.1 实现 Tracer 实例"></a>2.1 实现 Tracer 实例</h3><p>SpringMvcTracer 继承了 AbstractServerTracer 类，是对 serverTracer 的扩展。</p>
<blockquote>
<p>PS：如何确定一个组件是client端还是server端呢？就是看当前组件是请求的发起方还是请求的接受方，如果是请求发起方则一般是client端，如果是请求接收方则是 server 端。那么对于 MVC 来说，是请求接受方，因此这里实现了 AbstractServerTracer 类。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcTracer</span> <span class="keyword">extends</span> <span class="title">AbstractServerTracer</span></span></span><br></pre></td></tr></table></figure>
<h4 id="2-1-1-构造函数与单例对象"><a href="#2-1-1-构造函数与单例对象" class="headerlink" title="2.1.1 构造函数与单例对象"></a>2.1.1 构造函数与单例对象</h4><p>在构造函数中，需要传入当前 Tracer 的 traceType，SpringMvcTracer 的 traceType 为 “springmvc”。这里也可以看到，tracer 实例是一个单例对象，对于其他插件也是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SpringMvcTracer springMvcTracer = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * Spring MVC Tracer Singleton</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> singleton</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SpringMvcTracer <span class="title">getSpringMvcTracerSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (springMvcTracer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SpringMvcTracer.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (springMvcTracer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                springMvcTracer = <span class="keyword">new</span> SpringMvcTracer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> springMvcTracer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SpringMvcTracer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"springmvc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-AbstractServerTracer-抽象类"><a href="#2-1-2-AbstractServerTracer-抽象类" class="headerlink" title="2.1.2 AbstractServerTracer 抽象类"></a>2.1.2 AbstractServerTracer 抽象类</h4><p>在看 SpringMvcTracer 实现之前，先来看下 AbstractServerTracer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractServerTracer</span> <span class="keyword">extends</span> <span class="title">AbstractTracer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数，子类必须提供一个构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractServerTracer</span><span class="params">(String tracerType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(tracerType, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为是server端，所以Client先关的提供了默认实现，返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getClientDigestReporterLogName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getClientDigestReporterRollingKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getClientDigestReporterLogNameKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getClientDigestEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AbstractSofaTracerStatisticReporter <span class="title">generateClientStatReporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合上面  AbstractTracer 小节中抽象方法分析，这里在 AbstractServerTracer 中将 client 对应的抽象方法提供了默认实现，也就是说如果要继承 AbstractServerTracer 类，那么就必须实现 server 对应的所有抽象方法。</p>
<h4 id="2-1-3-SpringMVCTracer-实现"><a href="#2-1-3-SpringMVCTracer-实现" class="headerlink" title="2.1.3 SpringMVCTracer 实现"></a>2.1.3 SpringMVCTracer 实现</h4><p>下面是 SpringMvcTracer 部分对 server 部分抽象方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getServerDigestReporterLogName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SpringMvcLogEnum.SPRING_MVC_DIGEST.getDefaultLogName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getServerDigestReporterRollingKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SpringMvcLogEnum.SPRING_MVC_DIGEST.getRollingKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getServerDigestReporterLogNameKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SpringMvcLogEnum.SPRING_MVC_DIGEST.getLogNameKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> SpanEncoder&lt;SofaTracerSpan&gt; <span class="title">getServerDigestEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Boolean.TRUE.toString().equalsIgnoreCase(</span><br><span class="line">        SofaTracerConfiguration.getProperty(SPRING_MVC_JSON_FORMAT_OUTPUT))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringMvcDigestJsonEncoder();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringMvcDigestEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AbstractSofaTracerStatisticReporter <span class="title">generateServerStatReporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> generateSofaMvcStatReporter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前 SOFATracer 日志名、滚动策略key等都是通过枚举类来定义的，也就是一个组件会对应这样一个枚举类，在枚举类里面定义这些常量。</p>
<h3 id="2-2-SpringMvcLogEnum-类实现"><a href="#2-2-SpringMvcLogEnum-类实现" class="headerlink" title="2.2 SpringMvcLogEnum 类实现"></a>2.2 SpringMvcLogEnum 类实现</h3><p>SpringMVC 插件中的枚举类是 SpringMvcLogEnum。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SpringMvcLogEnum &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 摘要日志相关</span></span><br><span class="line">    SPRING_MVC_DIGEST(<span class="string">"spring_mvc_digest_log_name"</span>, </span><br><span class="line">                      <span class="string">"spring-mvc-digest.log"</span>,</span><br><span class="line">                      <span class="string">"spring_mvc_digest_rolling"</span>), </span><br><span class="line">    <span class="comment">// 统计日志相关</span></span><br><span class="line">    SPRING_MVC_STAT(<span class="string">"spring_mvc_stat_log_name"</span>, </span><br><span class="line">                    <span class="string">"spring-mvc-stat.log"</span>, </span><br><span class="line">                    <span class="string">"spring_mvc_stat_rolling"</span>);</span><br><span class="line">    <span class="comment">// 省略部分代码....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 XXXLogEnum 枚举类中定义了当前组件对应的摘要日志和统计日志的日志名和滚动策略，因为 SOFATracer 目前还没有服务端的能力，链路数据不是直接上报给 server 的，因此 SOFATracer 提供了落到磁盘的能力。不同插件的链路日志也会通过 XXXLogEnum 指定的名称将链路日志输出到各个组件对应的日志目录下。</p>
<h3 id="2-3-统计日志-Reportor-实现"><a href="#2-3-统计日志-Reportor-实现" class="headerlink" title="2.3 统计日志 Reportor 实现"></a>2.3 统计日志 Reportor 实现</h3><p>SOFATracer 中统计日志打印的实现需要各个组件自己来完成，具体就是需要实现一个AbstractSofaTracerStatisticReporter 的子类，然后实现 doReportStat 这个方法。当然对于目前的实现来说，我们也会重写 print 方法。</p>
<h4 id="2-3-1-doReportStat"><a href="#2-3-1-doReportStat" class="headerlink" title="2.3.1 doReportStat"></a>2.3.1 doReportStat</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doReportStat</span><span class="params">(SofaTracerSpan sofaTracerSpan)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; tagsWithStr = sofaTracerSpan.getTagsWithStr();</span><br><span class="line">    <span class="comment">// 构建StatMapKey对象</span></span><br><span class="line">    StatMapKey statKey = <span class="keyword">new</span> StatMapKey();</span><br><span class="line">    <span class="comment">// 增加 key:当前应用名</span></span><br><span class="line">    statKey.addKey(CommonSpanTags.LOCAL_APP, tagsWithStr.get(CommonSpanTags.LOCAL_APP));</span><br><span class="line">    <span class="comment">// 增加 key:请求 url</span></span><br><span class="line">    statKey.addKey(CommonSpanTags.REQUEST_URL, tagsWithStr.get(CommonSpanTags.REQUEST_URL));</span><br><span class="line">    <span class="comment">// 增加 key:请求方法</span></span><br><span class="line">    statKey.addKey(CommonSpanTags.METHOD, tagsWithStr.get(CommonSpanTags.METHOD));</span><br><span class="line">    <span class="comment">// 压测标志</span></span><br><span class="line">    statKey.setLoadTest(TracerUtils.isLoadTest(sofaTracerSpan));</span><br><span class="line">    <span class="comment">// 请求响应码</span></span><br><span class="line">    String resultCode = tagsWithStr.get(CommonSpanTags.RESULT_CODE);</span><br><span class="line">    <span class="comment">// 请求成功标识</span></span><br><span class="line">    <span class="keyword">boolean</span> success = (resultCode != <span class="keyword">null</span> &amp;&amp; resultCode.length() &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span></span><br><span class="line">        .isHttpOrMvcSuccess(resultCode));</span><br><span class="line">    statKey.setResult(success ? <span class="string">"true"</span> : <span class="string">"false"</span>);</span><br><span class="line">    <span class="comment">//end</span></span><br><span class="line">    statKey.setEnd(TracerUtils.getLoadTestMark(sofaTracerSpan));</span><br><span class="line">    <span class="comment">//value the count and duration</span></span><br><span class="line">    <span class="keyword">long</span> duration = sofaTracerSpan.getEndTime() - sofaTracerSpan.getStartTime();</span><br><span class="line">    <span class="keyword">long</span> values[] = <span class="keyword">new</span> <span class="keyword">long</span>[] &#123; <span class="number">1</span>, duration &#125;;</span><br><span class="line">    <span class="comment">// reserve</span></span><br><span class="line">    <span class="keyword">this</span>.addStat(statKey, values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这里就是就是将统计日志添加到日志槽里，等待被消费(输出到日志)。具体可以参考：SofaTracerStatisticReporterManager.StatReporterPrinter。</p>
<h4 id="2-3-2-print"><a href="#2-3-2-print" class="headerlink" title="2.3.2 print"></a>2.3.2 print</h4><p>print 方法是实际将数据写入到磁盘的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(StatKey statKey, <span class="keyword">long</span>[] values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isClosePrint.get()) &#123;</span><br><span class="line">        <span class="comment">//关闭统计日志输出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(statKey <span class="keyword">instanceof</span> StatMapKey)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StatMapKey statMapKey = (StatMapKey) statKey;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 构建需要打印的数据串</span></span><br><span class="line">        jsonBuffer.reset();</span><br><span class="line">        jsonBuffer.appendBegin();</span><br><span class="line">        jsonBuffer.append(<span class="string">"time"</span>, Timestamp.currentTime());</span><br><span class="line">        jsonBuffer.append(<span class="string">"stat.key"</span>, <span class="keyword">this</span>.statKeySplit(statMapKey));</span><br><span class="line">        jsonBuffer.append(<span class="string">"count"</span>, values[<span class="number">0</span>]);</span><br><span class="line">        jsonBuffer.append(<span class="string">"total.cost.milliseconds"</span>, values[<span class="number">1</span>]);</span><br><span class="line">        jsonBuffer.append(<span class="string">"success"</span>, statMapKey.getResult());</span><br><span class="line">        <span class="comment">//压测</span></span><br><span class="line">        jsonBuffer.appendEnd(<span class="string">"load.test"</span>, statMapKey.getEnd());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (appender <span class="keyword">instanceof</span> LoadTestAwareAppender) &#123;</span><br><span class="line">            ((LoadTestAwareAppender) appender).append(jsonBuffer.toString(),</span><br><span class="line">                statMapKey.isLoadTest());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            appender.append(jsonBuffer.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里强制刷一次</span></span><br><span class="line">        appender.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        SelfLog.error(<span class="string">"统计日志&lt;"</span> + statTracerName + <span class="string">"&gt;输出异常"</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>print 这个方法里面就是将 statMapKey 中，也就是 doReportStat 中塞进来的数据转换成  json 格式，然后刷到磁盘。需要注意的是这里是强制 flush 了一次。如果没有重写 print 这个方法的话，则是在SofaTracerStatisticReporterManager.StatReporterPrinter 里面调用 print 方法刷到磁盘。</p>
<h3 id="2-4-数据传播格式实现"><a href="#2-4-数据传播格式实现" class="headerlink" title="2.4 数据传播格式实现"></a>2.4 数据传播格式实现</h3><p>SOFATracer 支持使用 OpenTracing 的内建格式进行上下文传播。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcHeadersCarrier</span> <span class="keyword">implements</span> <span class="title">TextMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, String&gt; headers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpringMvcHeadersCarrier</span><span class="params">(HashMap&lt;String, String&gt; headers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.headers = headers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        headers.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> headers.entrySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-自定义编码格式实现"><a href="#2-5-自定义编码格式实现" class="headerlink" title="2.5 自定义编码格式实现"></a>2.5 自定义编码格式实现</h3><p>这个决定了摘要日志打印的格式，和在统计日志里面的实现要有所区分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcDigestJsonEncoder</span> <span class="keyword">extends</span> <span class="title">AbstractDigestSpanEncoder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重写encode,对span进行编码处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(SofaTracerSpan span)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        JsonStringBuilder jsonStringBuilder = <span class="keyword">new</span> JsonStringBuilder();</span><br><span class="line">        <span class="comment">//日志打印时间</span></span><br><span class="line">        jsonStringBuilder.appendBegin(<span class="string">"time"</span>, Timestamp.format(span.getEndTime()));</span><br><span class="line">        appendSlot(jsonStringBuilder, span);</span><br><span class="line">        <span class="keyword">return</span> jsonStringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具体字段处理</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendSlot</span><span class="params">(JsonStringBuilder jsonStringBuilder, SofaTracerSpan sofaTracerSpan)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        SofaTracerSpanContext context = sofaTracerSpan.getSofaTracerSpanContext();</span><br><span class="line">        Map&lt;String, String&gt; tagWithStr = sofaTracerSpan.getTagsWithStr();</span><br><span class="line">        Map&lt;String, Number&gt; tagWithNumber = sofaTracerSpan.getTagsWithNumber();</span><br><span class="line">        <span class="comment">//当前应用名</span></span><br><span class="line">        jsonStringBuilder</span><br><span class="line">            .append(CommonSpanTags.LOCAL_APP, tagWithStr.get(CommonSpanTags.LOCAL_APP));</span><br><span class="line">        <span class="comment">//TraceId</span></span><br><span class="line">        jsonStringBuilder.append(<span class="string">"traceId"</span>, context.getTraceId());</span><br><span class="line">        <span class="comment">//RpcId</span></span><br><span class="line">        jsonStringBuilder.append(<span class="string">"spanId"</span>, context.getSpanId());</span><br><span class="line">        <span class="comment">//请求 URL</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.REQUEST_URL,</span><br><span class="line">            tagWithStr.get(CommonSpanTags.REQUEST_URL));</span><br><span class="line">        <span class="comment">//请求方法</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.METHOD, tagWithStr.get(CommonSpanTags.METHOD));</span><br><span class="line">        <span class="comment">//Http 状态码</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.RESULT_CODE,</span><br><span class="line">            tagWithStr.get(CommonSpanTags.RESULT_CODE));</span><br><span class="line">        Number requestSize = tagWithNumber.get(CommonSpanTags.REQ_SIZE);</span><br><span class="line">        <span class="comment">//Request Body 大小 单位为byte</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.REQ_SIZE,</span><br><span class="line">            (requestSize == <span class="keyword">null</span> ? <span class="number">0L</span> : requestSize.longValue()));</span><br><span class="line">        Number responseSize = tagWithNumber.get(CommonSpanTags.RESP_SIZE);</span><br><span class="line">        <span class="comment">//Response Body 大小，单位为byte</span></span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.RESP_SIZE, (responseSize == <span class="keyword">null</span> ? <span class="number">0L</span></span><br><span class="line">            : responseSize.longValue()));</span><br><span class="line">        <span class="comment">//请求耗时（MS）</span></span><br><span class="line">        jsonStringBuilder.append(<span class="string">"time.cost.milliseconds"</span>,</span><br><span class="line">            (sofaTracerSpan.getEndTime() - sofaTracerSpan.getStartTime()));</span><br><span class="line">        jsonStringBuilder.append(CommonSpanTags.CURRENT_THREAD_NAME,</span><br><span class="line">            tagWithStr.get(CommonSpanTags.CURRENT_THREAD_NAME));</span><br><span class="line">        <span class="comment">//穿透数据放在最后</span></span><br><span class="line">        jsonStringBuilder.appendEnd(<span class="string">"baggage"</span>, baggageSerialized(context));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里其实也可以看出，统计日志和摘要日志的不同点。统计日志里面核心的数据是 span 里面的 tags 数据，但是其主要作用是统计当前组件的次数。摘要日志里面除了 tags 里面的数据之外还会包括例如 traceId 和 spanId 等信息。</p>
<ul>
<li>统计日志</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"time"</span>:<span class="string">"2018-11-28 14:42:25.127"</span>,<span class="attr">"stat.key"</span>:&#123;<span class="attr">"method"</span>:<span class="string">"GET"</span>,<span class="attr">"local.app"</span>:<span class="string">"SOFATracerSpringMVC"</span>,<span class="attr">"request.url"</span>:<span class="string">"http://localhost:8080/springmvc"</span>&#125;,<span class="attr">"count"</span>:<span class="number">3</span>,<span class="attr">"total.cost.milliseconds"</span>:<span class="number">86</span>,<span class="attr">"success"</span>:<span class="string">"true"</span>,<span class="attr">"load.test"</span>:<span class="string">"F"</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>摘要日志</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"time"</span>:<span class="string">"2018-11-28 14:46:08.216"</span>,<span class="attr">"local.app"</span>:<span class="string">"SOFATracerSpringMVC"</span>,<span class="attr">"traceId"</span>:<span class="string">"0a0fe91b1543387568214100259231"</span>,<span class="attr">"spanId"</span>:<span class="string">"0.1"</span>,<span class="attr">"request.url"</span>:<span class="string">"http://localhost:8080/springmvc"</span>,<span class="attr">"method"</span>:<span class="string">"GET"</span>,<span class="attr">"result.code"</span>:<span class="string">"200"</span>,<span class="attr">"req.size.bytes"</span>:<span class="number">-1</span>,<span class="attr">"resp.size.bytes"</span>:<span class="number">0</span>,<span class="attr">"time.cost.milliseconds"</span>:<span class="number">2</span>,<span class="attr">"current.thread.name"</span>:<span class="string">"http-nio-8080-exec-2"</span>,<span class="attr">"baggage"</span>:<span class="string">""</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-请求拦截埋点"><a href="#2-6-请求拦截埋点" class="headerlink" title="2.6 请求拦截埋点"></a>2.6 请求拦截埋点</h3><p>对于基于标准 servlet 实现的组件，要实现对请求的拦截过滤，通常就是 Filter 了。sofa-tracer-springmvc-plugin 插件埋点的实现就是基于 Filter 机制完成的。</p>
<p>SpringMvcSofaTracerFilter 实现了 javax.servlet.Filter 接口，因此遵循标准的 servlet 规范的容器也可以通过此插件进行埋点。参考文档：<a href="https://github.com/alipay/sofa-tracer/tree/master/tracer-samples/tracer-sample-with-springmvc" target="_blank" rel="noopener">对于标准 servlet 容器的支持（ tomcat/jetty 等）</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcSofaTracerFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span></span><br></pre></td></tr></table></figure>
<h4 id="2-6-1-基本埋点思路"><a href="#2-6-1-基本埋点思路" class="headerlink" title="2.6.1 基本埋点思路"></a>2.6.1 基本埋点思路</h4><p>对于一个组件来说，一次处理过程一般是产生一个 span。这个span的生命周期是从接收到请求到返回响应这段过程。</p>
<p>但是这里需要考虑的问题是如何与上下游链路关联起来呢？在 Opentracing 规范中，可以在 Tracer 中 extract 出一个跨进程传递的 SpanContext 。然后通过这个 SpanContext 所携带的信息将当前节点关联到整个 tracer 链路中去。当然有提取(extract)就会有对应的注入(inject)。</p>
<p>链路的构建一般是 client-server-client-server 这种模式的，那这里就很清楚了，就是会在 client 端进行注入(inject)，然后再 server 端进行提取(extract)，反复进行，然后一直传递下去。</p>
<p> 在拿到 SpanContext 之后，此时当前的 span 就可以关联到这条链路中了，那么剩余的事情就是收集当前组件的一些数据。</p>
<p>整个过程大概分为以下几个阶段：</p>
<ul>
<li>从请求中提取 spanContext</li>
<li>构建 span，并将当前 span 存入当前 tracer上下文中（SofaTraceContext.push(span)） 。</li>
<li>设置一些信息到span中</li>
<li>返回响应</li>
<li>span结束&amp;上报</li>
</ul>
<p>下面逐一分析下这几个过程。</p>
<h4 id="2-6-2-从请求中提取-spanContext"><a href="#2-6-2-从请求中提取-spanContext" class="headerlink" title="2.6.2 从请求中提取 spanContext"></a>2.6.2 从请求中提取 spanContext</h4><p>这里的提取用到了上面我们提到的#数据传播格式实现#SpringMvcHeadersCarrier 这个类。上面分析到，因为mvc 做作为 server 端存在的，所以在 server 端就是从请求中 extract 出 SpanContext。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SofaTracerSpanContext <span class="title">getSpanContextFromRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="comment">// 获取请求头信息 </span></span><br><span class="line">    Enumeration headerNames = request.getHeaderNames();</span><br><span class="line">    <span class="keyword">while</span> (headerNames.hasMoreElements()) &#123;</span><br><span class="line">        String key = (String) headerNames.nextElement();</span><br><span class="line">        String value = request.getHeader(key);</span><br><span class="line">        headers.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿到 SofaTracer 实例对象</span></span><br><span class="line">    SofaTracer tracer = springMvcTracer.getSofaTracer();</span><br><span class="line">    <span class="comment">// 解析出 SofaTracerSpanContext（SpanContext的实现类）</span></span><br><span class="line">    SofaTracerSpanContext spanContext = (SofaTracerSpanContext) tracer.extract(</span><br><span class="line">        ExtendFormat.Builtin.B3_HTTP_HEADERS, <span class="keyword">new</span> SpringMvcHeadersCarrier(headers));</span><br><span class="line">    spanContext.setSpanId(spanContext.nextChildContextId());</span><br><span class="line">    <span class="keyword">return</span> spanContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-6-3-获取-span-amp-数据获取"><a href="#2-6-3-获取-span-amp-数据获取" class="headerlink" title="2.6.3 获取 span &amp; 数据获取"></a>2.6.3 获取 span &amp; 数据获取</h4><p>serverReceive 这个方法是在 AbstractTracer 类中提供了实现，子类不需要关注这个。在 SOFATracer 中将请求大致分为以下几个过程：</p>
<ul>
<li>客户端发送请求  clientSend      cs</li>
<li>服务端接受请求  serverReceive sr</li>
<li>服务端返回结果  serverSend     ss</li>
<li>客户端接受结果  clientReceive  cr</li>
</ul>
<p>无论是哪个插件，在请求处理周期内都可以从上述几个阶段中找到对应的处理方法。因此，SOFATracer 对这几个阶段处理进行了封装。这四个阶段实际上会产生两个 span，第一个 span 的起点是 cs，到 cr 结束；第二个 span是从 sr 开始，到 ss 结束。也就是说当执行 clientSend 和 serverReceive 时会返回一个 span 对象。来看下MVC中的实现：</p>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543395049905-22e60dd7-1b88-4d94-9b2d-39c94ce909c7.png" alt="img"></p>
<p>红色框内对应的服务端接受请求，也就是 sr 阶段，产生了一个 span 。红色框下面的这段代码是为当前这个 span 设置一些基本的信息，包括当前应用的应用名、当前请求的url、当前请求的请求方法以及请求大小。</p>
<h4 id="2-6-4-返回响应与结束-span"><a href="#2-6-4-返回响应与结束-span" class="headerlink" title="2.6.4 返回响应与结束 span"></a>2.6.4 返回响应与结束 span</h4><p>在 filter 链执行结束之后，在 finally 块中又补充了当前请求响应结果的一些信息到 span 中去。然后调用serverSend 结束当前 span。这里关于 serverSend 里面的逻辑就不展开说了，不过能够想到的是这里肯定是调用span.finish 这个方法( opentracing 规范中，span.finish 的执行标志着一个 span 的结束)，当前也会包括对于数据上报的一些逻辑处理等。</p>
<p><img src="https://cdn.nlark.com/lark/0/2018/png/97619/1543395799817-68deb1fd-e481-4230-a338-3bbf8512a8f8.png" alt="img"></p>
<h2 id="3-思路总结与插件编写流程"><a href="#3-思路总结与插件编写流程" class="headerlink" title="3 思路总结与插件编写流程"></a>3 思路总结与插件编写流程</h2><p>在第2节中以 SpringMVC 插件为例，分析了下  SOFATracer 插件埋点实现的一些细节。那么本节则从整体思路上来总结下如何编写一个 SOFATracer 的插件。</p>
<ul>
<li>1、确定所要实现的插件，然后确定以哪种方式来埋点</li>
<li>2、实现当前插件的 Tracer 实例，这里需要明确当前插件是以 client 存在还是以 server 存在。</li>
<li>3、实现一个枚举类，用来描述当前组件的日志名称和滚动策略 key 值等</li>
<li>4、实现插件摘要日志的 encoder ，实现当前组件的定制化输出</li>
<li>5、实现插件的统计日志 Reporter 实现类，通过继承 AbstractSofaTracerStatisticReporter 类并重写doReportStat。</li>
<li><p>6、定义当前插件的传播格式</p>
<p>当然最重要的还是对于要实现插件的理解，要明确我们需要收集哪些数据。</p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文先介绍了SOFATracer的埋点方式与标准OT-api 埋点方式的区别，然后对 SOFATracer 中 SpringMVC 插件的埋点实现进行了分析。希望通过本文能够让更多的同学理解埋点实现这样一个过程以及需要关注的一些点。如果有兴趣或者有什么实际的需求，欢迎来讨论。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/12/07/sofa-tracer-mvc-plugin/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/24/spring-session-solutions/">SpringSession系列-分布式Session实现方案</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-24T08:55:33.000Z" itemprop="datePublished">2018/11/24</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/24/spring-session-solutions/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/session/" title="session">session</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>上一篇文章 <a href="https://juejin.im/post/5bdd449b6fb9a04a09557a40" target="_blank" rel="noopener">SpringSession：集成SpringBoot</a> 中介绍了如何在<code>SpringBoot</code>中来集成 <code>SpringSession</code>，整个过程非常简单，同时也简单分析了下<code>SpringSession</code>的作用原理。继上一篇实践之后，本文主要来分析 <code>SpringSession</code> 的原理。</p>
<h2 id="1、从-session-的一致性方案说起"><a href="#1、从-session-的一致性方案说起" class="headerlink" title="1、从 session 的一致性方案说起"></a>1、从 session 的一致性方案说起</h2><p>关于 <code>session</code> 和<code>cookie</code> 的一些知识，大家可以参考下我之前写的一篇文章：<a href="https://juejin.im/post/5aede266f265da0ba266e0ef" target="_blank" rel="noopener">聊一聊session和cookie</a>。</p>
<p><code>Session</code>作为服务器端使用的一种记录客户端状态的机制，其对客户端是透明的；但是<code>Session</code> 的正常运作仍然需要客户端浏览器的支持。我们都知道，<code>HTTP</code>协议是无状态的，<code>Session</code>不能依据<code>HTTP</code>连接来判断是否为同一客户，因此服务器需要向客户端浏览器发送一个识别标志（<code>sessionId</code>）,这个识别标志通过是通过<code>Cookie</code>机制来完成。</p>
<h3 id="1-1、session-一致性问题的由来"><a href="#1-1、session-一致性问题的由来" class="headerlink" title="1.1、session 一致性问题的由来"></a>1.1、session 一致性问题的由来</h3><p>当用户首次访问我们的<code>Servlet</code>时，应用服务器端会给用户创建一个独立的<code>Session</code>，并且存储在内存中。这种情况在单应用服务器场景下是可以满足的（这里不讨论其一个弊端，就是内存占用给服务器带来的压力的问题）。在集群场景下，这种机制就会到来问题：</p>
<h4 id="1-1-1、单机场景"><a href="#1-1-1、单机场景" class="headerlink" title="1.1.1、单机场景"></a>1.1.1、单机场景</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/4/166dee5cad0e35b8?w=968&amp;h=250&amp;f=png&amp;s=21829" alt=""></p>
<p>因为是一台应用服务器，用户的每次请求都是由这台机器来处理，所以不会有<code>session</code>共享问题。</p>
<h4 id="1-1-2、集群场景"><a href="#1-1-2、集群场景" class="headerlink" title="1.1.2、集群场景"></a>1.1.2、集群场景</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/4/166dee88ddb7d0ee?w=960&amp;h=608&amp;f=png&amp;s=42547" alt=""></p>
<p>假设现在集群中有三台机器，（从上到下：A-&gt;B-&gt;C）。当前用户首次发起访问时，请求被分配到 A 机器处理，<code>Session</code>数据被写入 A 机器的内存中；当再次发起访问 时，请求被分配的 B 处理，但此时 B 内存中并没有当前用户的任何数据，这样就出现了<code>session</code>不一致的情况了。</p>
<h3 id="1-2、Session-一致性问题的方案"><a href="#1-2、Session-一致性问题的方案" class="headerlink" title="1.2、Session 一致性问题的方案"></a>1.2、Session 一致性问题的方案</h3><p>对于当前服务化、单元化应用盛行的时代，简单的内存型的 <code>Session</code> 已经不能够满足我们的要求了。那么我们就需要寻求一种方案来替换目前单机内存存储实现的方案。</p>
<h4 id="1-2-1-基于-IP-HASH-的实现机制"><a href="#1-2-1-基于-IP-HASH-的实现机制" class="headerlink" title="1.2.1 基于 IP-HASH 的实现机制"></a>1.2.1 基于 IP-HASH 的实现机制</h4><p>在 1.1.2 中因为我们无法知道请求会被分配到哪台机器来处理，所以会导致<code>session</code>不一致的问题出现。如果我们可以解决让每个用户的请求能够固定的打到某一台机器上，那么上面提到的问题其实也就不存在了。<code>IP-HASH</code> 就是这样一种方案。通过对请求的客户端 <code>IP</code> 进行 <code>HASH</code> 计算，并将计算结果映射到具体一台机器，这样就可以将请求固定分配到某一台机器上，从而有效的避免<code>session</code>一致性问题的出现。</p>
<p>这种方案的好处在于:</p>
<ul>
<li>不需要修改任何应用代码，0 侵入。</li>
<li>安全性高，不依赖其他三方缓存框架带来的风险</li>
<li>成本低</li>
</ul>
<p>但是问题也很明显，这种方式实际上是规避了<code>session</code>一致性问题的出现，并非是针对<code>session</code>一致性问题给出的解决方案。主要问题：</p>
<ul>
<li>基于应用内存，会给应用服务器带来一定的压力</li>
<li>服务重启会导致<code>session</code>数据丢失</li>
<li>不利于水平扩展，水平扩展也可能丢失<code>session</code></li>
<li>存在单点负载高的情况，就是多数请求经过<code>HASH</code>计算之后打到同一台机器，而其他机器处于空闲状态。</li>
</ul>
<h4 id="1-2-2-session-复制"><a href="#1-2-2-session-复制" class="headerlink" title="1.2.2 session 复制"></a>1.2.2 session 复制</h4><p>这种方式的实现原理是应用服务器创建<code>session</code>之后通过组播的方式将<code>session</code>发送到组播地址内的其他应用服务器上。这种方式相较于<code>IP-HASH</code> 的方式要靠谱一点：</p>
<ul>
<li>同样不需要更改任何业务代码</li>
<li>能够适应多种负载策略</li>
<li>机器重启或者宕机之后不怕丢失，因为有冗余备份</li>
</ul>
<p>但是这种方式也有比较大的问题：</p>
<ul>
<li>首先就是服务器之间同步<code>session</code>会占用一定的网络资源，同时<code>session</code>在不同的机器之间进行同步存在延迟。</li>
<li>还是基于内存存储，局限于机器内存容量影响，水平扩展能力差</li>
<li>服务器内存因为需要存储其他机器上的<code>session</code>数据，对内存的消耗会随着集群的规模变大而变大，可能会导致机器频繁触发<code>GC</code>。</li>
</ul>
<h4 id="1-2-3-借助三方缓存框架实现-session-集中管理"><a href="#1-2-3-借助三方缓存框架实现-session-集中管理" class="headerlink" title="1.2.3 借助三方缓存框架实现 session 集中管理"></a>1.2.3 借助三方缓存框架实现 session 集中管理</h4><p>上面两种方式都是有服务器自己来管理<code>session</code>的，主要问题还是在于对于性能和内存的影响。而这种方式的原理是将<code>session</code>托管给三方软件（如<code>redis</code>）来统一管理。这种方式可以有效的解决性能、内存占用以及水平扩展等问题。但是因为引入了三方软件，在实现复杂度、运维成本等方面会有所增加。</p>
<p>目前所接触到的分布式<code>session</code>的实现方案，大多都是基于这种方式来实现的；<code>SpringSession</code> 也不例外。</p>
<h2 id="2、SpringSession-功能结构分析"><a href="#2、SpringSession-功能结构分析" class="headerlink" title="2、SpringSession 功能结构分析"></a>2、SpringSession 功能结构分析</h2><p>前面对分布式场景下的 <code>Session</code>一致性问题进行了说明，并对解决<code>Session</code>一致性的问题的几种策略进行的分析（有点糙，网上这些知识有很多）。在了解这些背景之后，我们来看下 <code>SpringSession</code> 的实现原理。</p>
<h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p><code>Spring Session</code> 提供了用于管理用户会话信息的<code>API</code>和实现，在不依赖特定于应用程序容器的解决方案的情况下，使得支持群集会话变得更加简单。它还提供了透明的集成：</p>
<ul>
<li>允许以应用程序容器（<code>Tomcat</code>等）中立的方式替换 <code>HttpSesseion</code>，支持在 <code>headers</code>中提供 <code>session IDs</code>来使用 <code>RESTful API</code>。</li>
<li>提供在接收 <code>WebSocket</code> 消息时保持<code>HTTP</code> 会话存活的能力</li>
<li>允许以应用程序容器中立的方式替换 <code>Spring WebFlux</code> 的 <code>WebSession</code>。</li>
</ul>
<blockquote>
<p>以上来自官网文档翻译 <a href="https://github.com/spring-projects/spring-session" target="_blank" rel="noopener">Spring Session </a></p>
</blockquote>
<h3 id="2-2-模块"><a href="#2-2-模块" class="headerlink" title="2.2 模块"></a>2.2 模块</h3><p><code>Spring Session</code> 主要包括 4 个模块：</p>
<ul>
<li><code>spring-session-core</code> ：提供了 <code>Spring Session</code> 核心功能和<code>API</code></li>
<li><code>spring-session-data-redis</code>：以 <code>redis</code> 作为存储机制的 <code>SessionRepository</code> 实现</li>
<li><code>spring-session-hazelcast</code>：以 <code>Hazelcast</code> 作为存储机制的 <code>SessionRepository</code> 实现</li>
<li><code>spring-session-jdbc</code>：以关系型数据库作为存储机制的 <code>SessionRepository</code> 实现</li>
</ul>
<p>总体来说就是 核心<code>API</code>+存储实现；工程模块截图如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/4/166dec2555f6da9e?w=1070&amp;h=530&amp;f=png&amp;s=77929" alt=""></p>
<h3 id="2-3-功能结构"><a href="#2-3-功能结构" class="headerlink" title="2.3 功能结构"></a>2.3 功能结构</h3><p>SpringSession整体上可以分为三块：</p>
<ul>
<li>对于Web层的处理，这里包括对于请求的重写，自定义的filter加入到filter chain，cookie处理，http header处理等</li>
<li>公共基础封装，比如存储类的顶层抽象接口定义，自定配置，事件处理等。</li>
<li>存储部分，这部分实际上是对公共基础封装接口的实现，提供了丰富的存储实现，包括redis，内存存储，jdbc等。</li>
</ul>
<h3 id="2-4-多-session-支持"><a href="#2-4-多-session-支持" class="headerlink" title="2.4 多 session 支持"></a>2.4 多 session 支持</h3><p>对于常用的分布式session，在实现上一般会依赖于 cookie。但是在 springsession 中提供了基于header来传递jessionID的策略实现。同时在 2.0.4 版本之前，对于同一个浏览器同一个网站，springsession 支持多个<code>session</code>问题，但是在此版本之后抛弃了对于对 session 的支持。关于更多关于多session支持可以查看 SpringSession 的<a href="https://docs.spring.io/spring-session/docs/1.3.5.BUILD-SNAPSHOT/reference/html5/" target="_blank" rel="noopener">官方文档</a>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文对分布式 session 的几种实现策略进行了简单的介绍。对于分布式 session 而言，如何解决一致性问题是关键，目前我见过的绝大多数方案均是以 【借助三方缓存框架实现 session 集中管理】 这种来实现的，包括本系列文章中所要介绍的 SpringSession。</p>
<p>除分布式session一致性方式解决方案的介绍之外，作为SpringSession 的第二篇文章，在这里简单分析了下Springsession的功能模块，以便后续展开对源码的分析。</p>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/24/spring-session-solutions/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/24/spring-session-req-resp/">SpringSession系列-请求与响应重写</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-24T08:54:07.000Z" itemprop="datePublished">2018/11/24</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/24/spring-session-req-resp/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/spring/" title="spring">spring</a>,
  
    <a href="/tags/session/" title="session">session</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<p>我们知道，<code>HttpServletRequset</code>和<code>HttpServletResponse</code>是<code>Servlet</code>标准所指定的<code>Java</code>语言与<code>Web</code>容器进行交互的接口。接口本身只规定<code>java</code>语言对<code>web</code>容器进行访问的行为方式，而具体的实现是由不同的<code>web</code>容器在其内部实现的。</p>
<p>那么在运行期，当我们需要对<code>HttpServletRequset</code>和<code>HttpServletResponse</code>的默认实例进行扩展时，我们就可以继承<code>HttpServletRequestWrapper</code>和<code>HttpServletResponseWrapper</code>来实现。<br>　　<br>在 <code>SpringSession</code>中因为我们要实现不依赖容器本身的<code>getSession</code> 实现，因此需要扩展 <code>HttpServletRequset</code>，通过重写<code>getSession</code>来实现分布式<code>session</code>的能力。下面就来看下<code>SpringSession</code>中对于<code>HttpServletRequset</code>的扩展。</p>
<h2 id="1、请求重写"><a href="#1、请求重写" class="headerlink" title="1、请求重写"></a>1、请求重写</h2><p><code>SpringSession</code> 中对于请求重写，在能力上主要体现在存储方面，也就是<code>getSession</code>方法上。在 <code>SessionRepositoryFilter</code> 这个类中，是通过内部类的方式实现了对<code>HttpServletRequset</code>和<code>HttpServletResponse</code>的扩展。</p>
<h3 id="1-1-HttpServletRequset-扩展实现"><a href="#1-1-HttpServletRequset-扩展实现" class="headerlink" title="1.1 HttpServletRequset 扩展实现"></a>1.1 HttpServletRequset 扩展实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionRepositoryRequestWrapper</span></span></span><br><span class="line"><span class="class">			<span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line">	<span class="comment">// HttpServletResponse 实例</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> HttpServletResponse response;</span><br><span class="line">	<span class="comment">// ServletContext 实例</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ServletContext servletContext;</span><br><span class="line">        <span class="comment">// requestedSession session对象</span></span><br><span class="line">        <span class="keyword">private</span> S requestedSession; </span><br><span class="line">        <span class="comment">// 是否缓存 session</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> requestedSessionCached;</span><br><span class="line">	<span class="comment">// sessionId</span></span><br><span class="line">	<span class="keyword">private</span> String requestedSessionId;</span><br><span class="line">	<span class="comment">// sessionId 是否有效</span></span><br><span class="line">	<span class="keyword">private</span> Boolean requestedSessionIdValid;</span><br><span class="line">	<span class="comment">// sessionId 是否失效</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> requestedSessionInvalidated;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 省略方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SessionRepositoryRequestWrapper</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">		HttpServletResponse response, ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>(request);</span><br><span class="line">	<span class="keyword">this</span>.response = response;</span><br><span class="line">	<span class="keyword">this</span>.servletContext = servletContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方法里面将 <code>HttpServletRequest</code>、<code>HttpServletResponse</code> 以及 <code>ServletContext</code> 实例传递进来，以便于后续扩展使用。</p>
<h3 id="1-3-getSession-方法"><a href="#1-3-getSession-方法" class="headerlink" title="1.3 getSession 方法"></a>1.3 getSession 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpSessionWrapper <span class="title">getSession</span><span class="params">(<span class="keyword">boolean</span> create)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从当前请求线程中获取 session</span></span><br><span class="line">	HttpSessionWrapper currentSession = getCurrentSession();</span><br><span class="line">	<span class="comment">// 如果有直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (currentSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> currentSession;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从请求中获取 session，这里面会涉及到从缓存中拿session的过程</span></span><br><span class="line">	S requestedSession = getRequestedSession();</span><br><span class="line">	<span class="keyword">if</span> (requestedSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">	    <span class="comment">// 无效的会话id(不支持的会话存储库)请求属性名称。</span></span><br><span class="line">	    <span class="comment">// 这里看下当前的sessionId是否有效</span></span><br><span class="line">		<span class="keyword">if</span> (getAttribute(INVALID_SESSION_ID_ATTR) == <span class="keyword">null</span>) &#123;</span><br><span class="line">		    <span class="comment">// 设置当前session的最后访问时间，用于延迟session的有效期</span></span><br><span class="line">			requestedSession.setLastAccessedTime(Instant.now());</span><br><span class="line">			<span class="comment">// 将requestedSessionIdValid置为true</span></span><br><span class="line">			<span class="keyword">this</span>.requestedSessionIdValid = <span class="keyword">true</span>;</span><br><span class="line">			<span class="comment">// 包装session</span></span><br><span class="line">			currentSession = <span class="keyword">new</span> HttpSessionWrapper(requestedSession, getServletContext());</span><br><span class="line">			<span class="comment">// 不是新的session，如果是新的session则需要改变sessionId</span></span><br><span class="line">			currentSession.setNew(<span class="keyword">false</span>);</span><br><span class="line">			<span class="comment">// 将session设置到当前请求上下文</span></span><br><span class="line">			setCurrentSession(currentSession);</span><br><span class="line">			<span class="comment">// 返回session</span></span><br><span class="line">			<span class="keyword">return</span> currentSession;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 这里处理的是无效的sessionId的情况，但是当前请求线程 session有效</span></span><br><span class="line">		<span class="keyword">if</span> (SESSION_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">			SESSION_LOGGER.debug(</span><br><span class="line">					<span class="string">"No session found by id: Caching result for getSession(false) for this HttpServletRequest."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将invalidSessionId置为true</span></span><br><span class="line">		setAttribute(INVALID_SESSION_ID_ATTR, <span class="string">"true"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 是否需要创建新的session</span></span><br><span class="line">	<span class="keyword">if</span> (!create) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (SESSION_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">		SESSION_LOGGER.debug(</span><br><span class="line">				<span class="string">"A new session was created. To help you troubleshoot where the session was created we provided a StackTrace (this is not an error). You can prevent this from appearing by disabling DEBUG logging for "</span></span><br><span class="line">						+ SESSION_LOGGER_NAME,</span><br><span class="line">				<span class="keyword">new</span> RuntimeException(</span><br><span class="line">						<span class="string">"For debugging purposes only (not an error)"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建新的session</span></span><br><span class="line">	S session = SessionRepositoryFilter.<span class="keyword">this</span>.sessionRepository.createSession();</span><br><span class="line">	<span class="comment">// 设置最后访问时间，也就是指定了当前session的有效期限</span></span><br><span class="line">	session.setLastAccessedTime(Instant.now());</span><br><span class="line">	<span class="comment">// 包装下当前session</span></span><br><span class="line">	currentSession = <span class="keyword">new</span> HttpSessionWrapper(session, getServletContext());</span><br><span class="line">	<span class="comment">//设置到当前请求线程</span></span><br><span class="line">	setCurrentSession(currentSession);</span><br><span class="line">	<span class="keyword">return</span> currentSession;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码有几个点，这里单独来解释下。</p>
<ul>
<li><code>getCurrentSession</code><ul>
<li>这是为了在同一个请求过程中不需要重复的去从存储中获取session，在一个新的进来时，将当前的 session 设置到当前请求中，在后续处理过程如果需要getSession就不需要再去存储介质中再拿一次。</li>
</ul>
</li>
<li><code>getRequestedSession</code><ul>
<li>这个是根据请求信息去取<code>session</code>，这里面就包括了<code>sessionId</code>解析，从存储获取<code>session</code>对象等过程。</li>
</ul>
</li>
<li>是否创建新的<code>session</code>对象   <ul>
<li>在当前请求中和存储中都没有获取到<code>session</code>信息的情况下，这里会根据<code>create</code>参数来判断是否创建新的<code>session</code>。这里一般用户首次登录时或者<code>session</code>失效时会走到。</li>
</ul>
</li>
</ul>
<h3 id="1-4-getRequestedSession"><a href="#1-4-getRequestedSession" class="headerlink" title="1.4 getRequestedSession"></a>1.4 getRequestedSession</h3><p>根据请求信息来获取<code>session</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> S <span class="title">getRequestedSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存的请求session是否存在</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.requestedSessionCached) &#123;</span><br><span class="line">            <span class="comment">// 获取 sessionId</span></span><br><span class="line">            List&lt;String&gt; sessionIds = SessionRepositoryFilter.<span class="keyword">this</span>.httpSessionIdResolver</span><br><span class="line">            		.resolveSessionIds(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 通过sessionId来从存储中获取session</span></span><br><span class="line">            <span class="keyword">for</span> (String sessionId : sessionIds) &#123;</span><br><span class="line">            	<span class="keyword">if</span> (<span class="keyword">this</span>.requestedSessionId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            		<span class="keyword">this</span>.requestedSessionId = sessionId;</span><br><span class="line">            	&#125;</span><br><span class="line">            	S session = SessionRepositoryFilter.<span class="keyword">this</span>.sessionRepository</span><br><span class="line">            			.findById(sessionId);</span><br><span class="line">            	<span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">            		<span class="keyword">this</span>.requestedSession = session;</span><br><span class="line">            		<span class="keyword">this</span>.requestedSessionId = sessionId;</span><br><span class="line">            		<span class="keyword">break</span>;</span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.requestedSessionCached = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.requestedSession;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码还是很有意思的，这里获取<code>sessionId</code>返回的是个列表。当然这里是<code>SpringSession</code>的实现策略，因为支持<code>session</code>，所以这里以列表的形式返回的。OK，继续来看如何解析<code>sessionId</code>的：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744a467ce2ada6?w=1394&amp;h=200&amp;f=png&amp;s=80360" alt=""></p>
<p>这里可以看到<code>SpringSession</code>对于<code>sessionId</code>获取的两种策略，一种是基于<code>cookie</code>，一种是基于<code>header</code>；分别来看下具体实现。</p>
<h4 id="1-4-1-CookieHttpSessionIdResolver-获取-sessionId"><a href="#1-4-1-CookieHttpSessionIdResolver-获取-sessionId" class="headerlink" title="1.4.1 CookieHttpSessionIdResolver 获取 sessionId"></a>1.4.1 CookieHttpSessionIdResolver 获取 sessionId</h4><p><code>CookieHttpSessionIdResolver</code> 中获取<code>sessionId</code>的核心代码如下：<br><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744a7c7c05a32f?w=1360&amp;h=710&amp;f=png&amp;s=152689" alt=""><br>其实这里没啥好说的，就是读<code>cookie</code>。从<code>request</code>将<code>cookie</code>信息拿出来，然后遍历找当前<code>sessionId</code>对应的<code>cookie</code>,这里的判断也很简单， 如果是以<code>SESSION</code>开头，则表示是 <code>SessionId</code>，毕竟<code>cookie</code>是共享的，不只有<code>sessionId</code>，还有可能存储其他内容。</p>
<p>另外这里面有个 jvmRoute，这个东西实际上很少能够用到，因为大多数情况下这个值都是null。这个我们在分析<code>CookieSerializer</code>时再来解释。</p>
<h4 id="1-4-2-HeaderHttpSessionIdResolver-获取-sessionId"><a href="#1-4-2-HeaderHttpSessionIdResolver-获取-sessionId" class="headerlink" title="1.4.2 HeaderHttpSessionIdResolver 获取 sessionId"></a>1.4.2 HeaderHttpSessionIdResolver 获取 sessionId</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744b76477e1904?w=1144&amp;h=196&amp;f=png&amp;s=51550" alt=""><br>这个获取更直接粗暴，就是根据 <code>headerName</code> 从 <code>header</code> 中取值。</p>
<p>回到<code>getRequestedSession</code>，剩下的代码中核心的都是和<code>sessionRepository</code>这个有关系，这部分就会涉及到存储部分。不在本篇的分析范围之内，会在存储实现部分来分析。</p>
<h3 id="1-5-HttpSessionWrapper"><a href="#1-5-HttpSessionWrapper" class="headerlink" title="1.5 HttpSessionWrapper"></a>1.5 HttpSessionWrapper</h3><p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744bd83bd21c65?w=1436&amp;h=416&amp;f=png&amp;s=96267" alt=""></p>
<p>上面的代码中当我们拿到<code>session</code>实例是通常会包装下，那么用到的就是这个<code>HttpSessionWrapper</code>。</p>
<p><code>HttpSessionWrapper</code> 继承了 <code>HttpSessionAdapter</code>，这个<code>HttpSessionAdapter</code>就是将SpringSession 转换成一个标准<code>HttpSession</code>的适配类。<code>HttpSessionAdapter</code> 实现了标准<code>servlet</code>规范的<code>HttpSession</code>接口。</p>
<h4 id="1-5-1-HttpSessionWrapper"><a href="#1-5-1-HttpSessionWrapper" class="headerlink" title="1.5.1 HttpSessionWrapper"></a>1.5.1 HttpSessionWrapper</h4><p><code>HttpSessionWrapper</code> 重写了 <code>invalidate</code>方法。从代码来看，调用该方法产生的影响是：</p>
<ul>
<li><code>requestedSessionInvalidated</code> 置为<code>true</code>，标识当前 <code>session</code> 失效。</li>
<li>将当前请求中的<code>session</code>设置为<code>null</code>，那么在请求的后续调用中通过<code>getCurrentSession</code>将拿不到<code>session</code>信息。</li>
<li>当前缓存的 session 清楚，包括sessionId，session实例等。</li>
<li>删除存储介质中的session对象。</li>
</ul>
<h4 id="1-5-2-HttpSessionAdapter"><a href="#1-5-2-HttpSessionAdapter" class="headerlink" title="1.5.2 HttpSessionAdapter"></a>1.5.2 HttpSessionAdapter</h4><p><code>SpringSession</code>和标准<code>HttpSession</code>的配置器类。这个怎么理解呢，来看下一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getAttribute</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">	checkState();</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.session.getAttribute(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于基于容器本身实现的<code>HttpSession</code>来说，<code>getAttribute</code>的实现也是有容器本身决定。但是这里做了转换之后，<code>getAttribute</code>将会通过<code>SpringSession</code>中实现的方案来获取。其他的<code>API</code>适配也是基于此实现。</p>
<h3 id="SessionCommittingRequestDispatcher"><a href="#SessionCommittingRequestDispatcher" class="headerlink" title="SessionCommittingRequestDispatcher"></a>SessionCommittingRequestDispatcher</h3><p>实现了 <code>RequestDispatcher</code> 接口。关于<code>RequestDispatcher</code>可以参考这篇文章<a href="https://www.cnblogs.com/lulipro/p/7471987.html" target="_blank" rel="noopener">【Servlet】关于RequestDispatcher的原理</a>。<code>SessionCommittingRequestDispatcher</code>对<code>forward</code>的行为并没有改变。<br>对于<code>include</code>则是在<code>include</code>之前提交<code>session</code>。为什么这么做呢？</p>
<p> 因为<code>include</code>方法使原先的<code>Servlet</code>和转发到的<code>Servlet</code>都可以输出响应信息，即原先的<code>Servlet</code>还可以继续输出响应信息；即请求转发后，原先的<code>Servlet</code>还可以继续输出响应信息，转发到的<code>Servlet</code>对请求做出的响应将并入原先<code>Servlet</code>的响应对象中。 </p>
<p> 所以这个在<code>include</code>调用之前调用<code>commit</code>，这样可以确保被包含的<code>Servlet</code>程序不能改变响应消息的状态码和响应头。</p>
<h2 id="2-响应重写"><a href="#2-响应重写" class="headerlink" title="2 响应重写"></a>2 响应重写</h2><p>响应重写的目的是确保在请求提交时能够把session保存起来。来看下<code>SessionRepositoryResponseWrapper</code>类的实现：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744deabbf838ec?w=1140&amp;h=678&amp;f=png&amp;s=148489" alt=""><br>这里面实现还就是重写<code>onResponseCommitted</code>，也就是上面说的，在请求提交时能够通过这个回调函数将<code>session</code>保存到存储容器中。</p>
<h3 id="2-1-session-提交"><a href="#2-1-session-提交" class="headerlink" title="2.1 session 提交"></a>2.1 session 提交</h3><p>最后来看下 commitSession</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/24/16744e0fea8b3996?w=1374&amp;h=610&amp;f=png&amp;s=139692" alt=""></p>
<p>这个过程不会再去存储容器中拿<code>session</code>信息，而是直接从当前请求中拿。如果拿不到，则在回写<code>cookie</code>时会将当前<code>session</code>对应的<code>cookie</code>值设置为空，这样下次请求过来时携带的<code>sessionCookie</code>就是空，这样就会重新触发登陆。</p>
<p>如果拿到，则清空当前请求中的<code>session</code>信息，然后将<code>session</code>保存到存储容器中，并且将<code>sessionId</code>回写到<code>cookie</code>中。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇主要对<code>SpringSession</code>中重写<code>Request</code>和<code>Response</code>进行了分析。通过重写<code>Request</code>请求来将<code>session</code>的存储与存储容器关联起来，通过重写<code>Response</code>来处理<code>session</code>提交，将<code>session</code>保存到存储容器中。</p>
<p>后面我们会继续来分析<code>SpringSession</code>的源码。最近也在学习链路跟踪相关的技术，也准备写一写，有兴趣的同学可以一起讨论。</p>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><ul>
<li><a href="https://github.com/alipay" target="_blank" rel="noopener">SOFA 开源社区</a></li>
<li><a href="https://github.com/alipay/sofa-tracer" target="_blank" rel="noopener">SOFATracer</a></li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/24/spring-session-req-resp/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
	<div class="row">
  <div class="col-md-4 col-sm-4">
    
  </div>
  
    <div class="col-xs-12">
  
    
    <h2 itemprop="name">
      <a class="archive-article-title" href="/2018/11/16/sofa-boot-health-analizy/">SOFABoot 健康检查能力分析</a>
    </h2>


    <ul class="blog-info">
      <li>
      	<i class="fa fa-calendar"></i> 
        <time datetime="2018-11-16T11:10:03.000Z" itemprop="datePublished">2018/11/16</time>

      </li>
      <li><i class="fa fa-comments"></i>
        <a href="http://www.glmapper.com/2018/11/16/sofa-boot-health-analizy/#disqus_thread" class="article-comment-link">Comments</a>
      </li>
      <li>
	<i class="fa fa-tags"></i>
	
  
    <a href="/tags/SOFABoot/" title="SOFABoot">SOFABoot</a>
  


      </li>
    </ul>
    <div class="blog-item">
      
	<h2 id="Liveness-Check-amp-Readiness-Check"><a href="#Liveness-Check-amp-Readiness-Check" class="headerlink" title="Liveness Check &amp;  Readiness Check"></a>Liveness Check &amp;  Readiness Check</h2><p><code>Spring Boot</code> 提供了一个基础的健康检查的能力，中间件和应用都可以扩展来实现自己的健康检查逻辑。但是 Spring Boot 的健康检查只有 <code>Liveness Check</code> 的能力，缺少 <code>Readiness Check</code> 的能力，这样会有比较致命的问题。当一个微服务应用启动的时候，必须要先保证启动后应用是健康的，才可以将上游的流量放进来（来自于 RPC，网关，定时任务等等流量），否则就可能会导致一定时间内大量的错误发生。</p>
<p>针对 <code>Spring Boot</code> 缺少 <code>Readiness Check</code> 能力的情况，<code>SOFABoot</code> 增加了 <code>Spring Boot</code> 现有的健康检查的能力，提供了 <code>Readiness Check</code> 的能力。利用 <code>Readiness Check</code> 的能力，<code>SOFA</code> 中间件中的各个组件只有在 <code>Readiness Check</code> 通过之后，才将流量引入到应用的实例中，比如 <code>RPC</code>，只有在 <code>Readiness Check</code> 通过之后，才会向服务注册中心注册，后面来自上游应用的流量才会进入。</p>
<p>除了中间件可以利用 <code>Readiness Check</code> 的事件来控制流量的进入之外，<code>PAAS</code> 系统也可以通过访问 <code>http://localhost:8080/actuator/readiness</code> 来获取应用的 <code>Readiness Check</code> 的状况，用来控制例如负载均衡设备等等流量的进入。</p>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p><code>SOFABoot</code> 的健康检查能力需要引入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>healthcheck-sofa-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>区别于<code>SpringBoot</code>的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>详细工程科参考：<a href="https://github.com/alipay/" target="_blank" rel="noopener">sofa-boot</a></p>
</blockquote>
<h3 id="健康检查启动日志"><a href="#健康检查启动日志" class="headerlink" title="健康检查启动日志"></a>健康检查启动日志</h3><p><img src="https://user-gold-cdn.xitu.io/2018/11/16/1671b3e9d1e81110?w=1592&amp;h=322&amp;f=png&amp;s=360160" alt=""></p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>既然是个Starter，那么就先从 <strong>spring.factories</strong> 文件来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">com.alipay.sofa.healthcheck.initializer.SofaBootHealthCheckInitializer</span><br><span class="line"></span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.alipay.sofa.healthcheck.configuration.SofaBootHealthCheckAutoConfiguration</span><br></pre></td></tr></table></figure>
<h4 id="SofaBootHealthCheckInitializer"><a href="#SofaBootHealthCheckInitializer" class="headerlink" title="SofaBootHealthCheckInitializer"></a>SofaBootHealthCheckInitializer</h4><p><code>SofaBootHealthCheckInitializer</code> 实现了 <code>ApplicationContextInitializer</code> 接口。</p>
<p><code>ApplicationContextInitializer</code> 是 <code>Spring</code> 框架原有的概念，这个类的主要目的就是在            <code>ConfigurableApplicationContext</code> 类型（或者子类型）的 <code>ApplicationContext</code> 做 <code>refresh</code> 之前，允许我们                   对 <code>ConfigurableApplicationContext</code> 的实例做进一步的设置或者处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaBootHealthCheckInitializer</span> <span class="keyword">implements</span> <span class="title">ApplicationContextInitializer</span>&lt;<span class="title">ConfigurableApplicationContext</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        Environment environment = applicationContext.getEnvironment();</span><br><span class="line">        <span class="keyword">if</span> (SOFABootEnvUtils.isSpringCloudBootstrapEnvironment(environment)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// init logging.level.com.alipay.sofa.runtime argument</span></span><br><span class="line">        String healthCheckLogLevelKey = Constants.LOG_LEVEL_PREFIX</span><br><span class="line">                                        + HealthCheckConstants.SOFABOOT_HEALTH_LOG_SPACE;</span><br><span class="line">        SofaBootLogSpaceIsolationInit.initSofaBootLogger(environment, healthCheckLogLevelKey);</span><br><span class="line">      SofaBootHealthCheckLoggerFactory.getLogger(SofaBootHealthCheckInitializer.class).info(</span><br><span class="line">            <span class="string">"SOFABoot HealthCheck Starting!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SofaBootHealthCheckInitializer</code> 在 <code>initialize</code> 方法中主要做了两件事：</p>
<ul>
<li>验证当前 <code>environment</code> 是否是 <code>SpringCloud</code> 的（3.0.0 开始支持 <code>springCloud</code>，之前版本无此 <code>check</code>）</li>
<li>初始化 <code>logging.level</code> </li>
</ul>
<p>这两件事和健康检查没有什么关系，但是既然放在这个模块里面还是来看下。</p>
<h4 id="1、springCloud-环境验证"><a href="#1、springCloud-环境验证" class="headerlink" title="1、springCloud 环境验证"></a>1、springCloud 环境验证</h4><p>首先就是为什么会有这个验证。<code>SOFABoot</code> 在支持 <code>SpringcLoud</code> 时遇到一个问题，就是当在 <code>classpath</code> 中添加<code>spring-cloud-context</code> 依赖关系时,<code>org.springframework.context.ApplicationContextInitializer</code>会被调用两次。具体背景可参考 <a href="https://github.com/spring-cloud/spring-cloud-config/issues/1151" target="_blank" rel="noopener"># issue1151</a>  &amp;&amp; <a href="https://github.com/alipay/sofa-boot/issues/232" target="_blank" rel="noopener"># issue 232</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SPRING_CLOUD_MARK_NAME = <span class="string">"org.springframework.cloud.bootstrap.BootstrapConfiguration"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSpringCloudBootstrapEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">        <span class="keyword">return</span> !((ConfigurableEnvironment) environment).getPropertySources().contains(</span><br><span class="line">            SofaBootInfraConstants.SOFA_BOOTSTRAP)</span><br><span class="line">               &amp;&amp; isSpringCloud();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSpringCloud</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ClassUtils.isPresent(SPRING_CLOUD_MARK_NAME, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码是 <code>SOFABoot</code> 提供的一个用于区分 引导上下文  和 应用上下文 的方法：</p>
<ul>
<li>检验是否有<code>&quot;org.springframework.cloud.bootstrap.BootstrapConfiguration&quot;</code>这个类来判断当前是否引入了<code>spingCloud</code>的引导配置类</li>
<li>从<code>environment</code> 中获取 <code>MutablePropertySources</code> 实例，验证 <code>MutablePropertySources</code> 中是否包括 <code>sofaBootstrap</code> （ 如果当前环境是 <code>SOFA bootstrap environment</code>，则包含 <code>sofaBootstrap</code>；这个是在 <code>SofaBootstrapRunListener</code> 回调方法中设置进行的 ）</li>
</ul>
<h4 id="2、初始化-logging-level"><a href="#2、初始化-logging-level" class="headerlink" title="2、初始化 logging.level"></a>2、初始化 logging.level</h4><p>这里是处理 <code>SOFABoot</code> 日志空间隔离的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initSofaBootLogger</span><span class="params">(Environment environment, String runtimeLogLevelKey)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 logging.path 参数</span></span><br><span class="line">    String loggingPath = environment.getProperty(Constants.LOG_PATH);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(loggingPath)) &#123;</span><br><span class="line">        System.setProperty(Constants.LOG_PATH, environment.getProperty(Constants.LOG_PATH));</span><br><span class="line">        ReportUtil.report(<span class="string">"Actual "</span> + Constants.LOG_PATH + <span class="string">" is [ "</span> + loggingPath + <span class="string">" ]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for example : init logging.level.com.alipay.sofa.runtime argument</span></span><br><span class="line">    String runtimeLogLevelValue = environment.getProperty(runtimeLogLevelKey);</span><br><span class="line">    <span class="keyword">if</span> (runtimeLogLevelValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.setProperty(runtimeLogLevelKey, runtimeLogLevelValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init file.encoding</span></span><br><span class="line">    String fileEncoding = environment.getProperty(Constants.LOG_ENCODING_PROP_KEY);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(fileEncoding)) &#123;</span><br><span class="line">        System.setProperty(Constants.LOG_ENCODING_PROP_KEY, fileEncoding);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SofaBootHealthCheckAutoConfiguration"><a href="#SofaBootHealthCheckAutoConfiguration" class="headerlink" title="SofaBootHealthCheckAutoConfiguration"></a>SofaBootHealthCheckAutoConfiguration</h3><p>这个类是 <code>SOFABoot</code> 健康检查机制的自动化配置实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaBootHealthCheckAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** ReadinessCheckListener: 容器刷新之后回调 */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReadinessCheckListener <span class="title">readinessCheckListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReadinessCheckListener();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** HealthCheckerProcessor: HealthChecker处理器 */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HealthCheckerProcessor <span class="title">healthCheckerProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HealthCheckerProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** HealthCheckerProcessor: HealthIndicator处理器 */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HealthIndicatorProcessor <span class="title">healthIndicatorProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HealthIndicatorProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** AfterReadinessCheckCallbackProcessor: ReadinessCheck之后的回调处理器 */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AfterReadinessCheckCallbackProcessor <span class="title">afterReadinessCheckCallbackProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AfterReadinessCheckCallbackProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 返回 SofaBoot健康检查指标类 实例*/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SofaBootHealthIndicator <span class="title">sofaBootHealthIndicator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SofaBootHealthIndicator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(Endpoint.class)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionReadinessEndpointConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnEnabledEndpoint</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SofaBootReadinessCheckEndpoint <span class="title">sofaBootReadinessCheckEndpoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SofaBootReadinessCheckEndpoint();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(Endpoint.class)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadinessCheckExtensionConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="meta">@ConditionalOnEnabledEndpoint</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ReadinessEndpointWebExtension <span class="title">readinessEndpointWebExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReadinessEndpointWebExtension();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ReadinessCheckListener"><a href="#ReadinessCheckListener" class="headerlink" title="ReadinessCheckListener"></a>ReadinessCheckListener</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadinessCheckListener</span> <span class="keyword">implements</span> <span class="title">PriorityOrdered</span>,</span></span><br><span class="line"><span class="class">                                   <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从代码来看，<code>ReadinessCheckListener</code> 实现了 <code>ApplicationListener</code> 监听器接口，其所监听的事件对象是<code>ContextRefreshedEvent</code>，即当容器上下文刷新完成之后回调。 <code>SOFABoot</code> 中通过这个监听器来完成 <code>readniess check</code> 的处理。</p>
<p><code>onApplicationEvent</code> 回调方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// healthCheckerProcessor init</span></span><br><span class="line">    healthCheckerProcessor.init();</span><br><span class="line">    <span class="comment">// healthIndicatorProcessor init</span></span><br><span class="line">    healthIndicatorProcessor.init();</span><br><span class="line">    <span class="comment">// afterReadinessCheckCallbackProcessor init</span></span><br><span class="line">    afterReadinessCheckCallbackProcessor.init();</span><br><span class="line">    <span class="comment">// readiness health check execute</span></span><br><span class="line">    readinessHealthCheck();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化 <code>healthCheckerProcessor</code>，这个里面就是将当前所有的<code>HealthChecker</code>类型的<code>bean</code>找出来，然后放在一个<code>map</code>中，等待后面的 <code>readiness check</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否已经初始化了</span></span><br><span class="line">    <span class="keyword">if</span> (isInitiated.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// applicationContext 应用上下文不能为null</span></span><br><span class="line">        Assert.notNull(applicationContext, () -&gt; <span class="string">"Application must not be null"</span>);</span><br><span class="line">        <span class="comment">// 获取所有类型是 HealthChecker 的bean</span></span><br><span class="line">        Map&lt;String, HealthChecker&gt; beansOfType = applicationContext</span><br><span class="line">                .getBeansOfType(HealthChecker.class);</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        healthCheckers = HealthCheckUtils.sortMapAccordingToValue(beansOfType,</span><br><span class="line">                applicationContext.getAutowireCapableBeanFactory());</span><br><span class="line">        <span class="comment">// 构建日志信息，对应在健康检查日志里面打印出来的是：</span></span><br><span class="line">        <span class="comment">// ./logs/health-check/common-default.log:Found 0 HealthChecker implementation</span></span><br><span class="line">        StringBuilder healthCheckInfo = <span class="keyword">new</span> StringBuilder(<span class="number">512</span>).append(<span class="string">"Found "</span>)</span><br><span class="line">                .append(healthCheckers.size()).append(<span class="string">" HealthChecker implementation:"</span>)</span><br><span class="line">                .append(String.join(<span class="string">","</span>, healthCheckers.keySet()));</span><br><span class="line">        logger.info(healthCheckInfo.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化 <code>healthIndicatorProcessor</code>，将所有的<code>healthIndicator</code> 类型的<code>bean</code> 找出来，然后放在一个<code>map</code>中等待<code>readiness check</code>。如果想要在 <code>SOFABoot</code> 的 <code>Readiness Check</code> 里面增加一个检查项，那么可以直接扩展 <code>Spring Boot</code> 的<code>HealthIndicator</code>这个接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否已经初始化</span></span><br><span class="line">    <span class="keyword">if</span> (isInitiated.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// applicationContext 验证</span></span><br><span class="line">        Assert.notNull(applicationContext, () -&gt; <span class="string">"Application must not be null"</span>);</span><br><span class="line">        <span class="comment">// 获取所有HealthIndicator类型的bean</span></span><br><span class="line">        Map&lt;String, HealthIndicator&gt; beansOfType = applicationContext</span><br><span class="line">                .getBeansOfType(HealthIndicator.class);</span><br><span class="line">        <span class="comment">// 支持 Reactive 方式</span></span><br><span class="line">        <span class="keyword">if</span> (ClassUtils.isPresent(REACTOR_CLASS, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            applicationContext.getBeansOfType(ReactiveHealthIndicator.class).forEach(</span><br><span class="line">                    (name, indicator) -&gt; beansOfType.put(name, () -&gt; indicator.health().block()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        healthIndicators = HealthCheckUtils.sortMapAccordingToValue(beansOfType,</span><br><span class="line">                applicationContext.getAutowireCapableBeanFactory());</span><br><span class="line">        <span class="comment">// 构建日志信息</span></span><br><span class="line">        <span class="comment">// Found 2 HealthIndicator implementation:</span></span><br><span class="line">        <span class="comment">// sofaBootHealthIndicator, diskSpaceHealthIndicator</span></span><br><span class="line">        StringBuilder healthIndicatorInfo = <span class="keyword">new</span> StringBuilder(<span class="number">512</span>).append(<span class="string">"Found "</span>)</span><br><span class="line">                .append(healthIndicators.size()).append(<span class="string">" HealthIndicator implementation:"</span>)</span><br><span class="line">                .append(String.join(<span class="string">","</span>, healthIndicators.keySet()));</span><br><span class="line">        logger.info(healthIndicatorInfo.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化 <code>afterReadinessCheckCallbackProcessor</code>。如果想要在 <code>Readiness Check</code> 之后做一些事情，那么可以扩展 <code>SOFABoot</code> 的这个接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  是否已经初始化</span></span><br><span class="line">    <span class="keyword">if</span> (isInitiated.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// applicationContext 验证</span></span><br><span class="line">        Assert.notNull(applicationContext, () -&gt; <span class="string">"Application must not be null"</span>);</span><br><span class="line">        <span class="comment">// 找到所有 ReadinessCheckCallback 类型的 bean </span></span><br><span class="line">        Map&lt;String, ReadinessCheckCallback&gt; beansOfType = applicationContext</span><br><span class="line">                .getBeansOfType(ReadinessCheckCallback.class);</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        readinessCheckCallbacks = HealthCheckUtils.sortMapAccordingToValue(beansOfType,</span><br><span class="line">                applicationContext.getAutowireCapableBeanFactory());</span><br><span class="line">        <span class="comment">// 构建日志</span></span><br><span class="line">        StringBuilder applicationCallbackInfo = <span class="keyword">new</span> StringBuilder(<span class="number">512</span>).append(<span class="string">"Found "</span>)</span><br><span class="line">                .append(readinessCheckCallbacks.size())</span><br><span class="line">                .append(<span class="string">" ReadinessCheckCallback implementation: "</span>)</span><br><span class="line">                .append(String.join(<span class="string">","</span>, beansOfType.keySet()));</span><br><span class="line">        logger.info(applicationCallbackInfo.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>readinessHealthCheck</code>，前面的几个<code>init</code>方法中均是为<code>readinessHealthCheck</code>做准备的，到这里<code>SOFABoot</code>已经拿到了当前多有的<code>HealthChecker</code>、<code>HealthIndicator</code> 和 <code>ReadinessCheckCallback</code> 类型的 <code>bean</code> 信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readiness health check</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readinessHealthCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否跳过所有check,可以通过 com.alipay.sofa.healthcheck.skip.all 配置项配置决定</span></span><br><span class="line">    <span class="keyword">if</span> (skipAllCheck()) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Skip all readiness health check."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 是否跳过所有 HealthChecker 类型bean的 readinessHealthCheck,</span></span><br><span class="line">        <span class="comment">// 可以通过com.alipay.sofa.healthcheck.skip.component配置项配置</span></span><br><span class="line">        <span class="keyword">if</span> (skipComponent()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Skip HealthChecker health check."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//HealthChecker 的 readiness check</span></span><br><span class="line">            healthCheckerStatus = healthCheckerProcessor</span><br><span class="line">                .readinessHealthCheck(healthCheckerDetails);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否跳过所有HealthIndicator 类型bean的readinessHealthCheck</span></span><br><span class="line">        <span class="comment">// 可以通过 com.alipay.sofa.healthcheck.skip.indicator配置项配置</span></span><br><span class="line">        <span class="keyword">if</span> (skipIndicator()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Skip HealthIndicator health check."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//HealthIndicator 的 readiness check</span></span><br><span class="line">            healthIndicatorStatus = healthIndicatorProcessor</span><br><span class="line">                .readinessHealthCheck(healthIndicatorDetails);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ReadinessCheck 之后的回调函数，做一些后置处理</span></span><br><span class="line">    healthCallbackStatus = afterReadinessCheckCallbackProcessor</span><br><span class="line">        .afterReadinessCheckCallback(healthCallbackDetails);</span><br><span class="line">    <span class="keyword">if</span> (healthCheckerStatus &amp;&amp; healthIndicatorStatus &amp;&amp; healthCallbackStatus) &#123;</span><br><span class="line">        logger.info(<span class="string">"Readiness check result: success"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.error(<span class="string">"Readiness check result: fail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Readiness-Check-做了什么"><a href="#Readiness-Check-做了什么" class="headerlink" title="Readiness Check 做了什么"></a>Readiness Check 做了什么</h4><p>前面是 <code>SOFABoot</code> 健康检查组件处理健康检查逻辑的一个大体流程，了解到了 <code>Readiness</code> 包括检查 <code>HealthChecker</code> 类型的<code>bean</code>和<code>HealthIndicator</code> 类型的 <code>bean</code>。其中<code>HealthIndicator</code>是<code>SpringBoot</code>自己的接口 ，而 <code>HealthChecker</code> 是 <code>SOFABoot</code> 提供的接口。下面继续通过 <code>XXXProcess</code> 来看下 <code>Readiness Check</code> 到底做了什么？</p>
<h4 id="HealthCheckerProcessor"><a href="#HealthCheckerProcessor" class="headerlink" title="HealthCheckerProcessor"></a>HealthCheckerProcessor</h4><p><code>HealthChecker</code> 的健康检查处理器，<code>readinessHealthCheck</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readinessHealthCheck</span><span class="params">(Map&lt;String, Health&gt; healthMap)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(healthCheckers, <span class="string">"HealthCheckers must not be null."</span>);</span><br><span class="line">    logger.info(<span class="string">"Begin SOFABoot HealthChecker readiness check."</span>);</span><br><span class="line">    <span class="keyword">boolean</span> result = healthCheckers.entrySet().stream()</span><br><span class="line">            .map(entry -&gt; doHealthCheck(entry.getKey(), entry.getValue(), <span class="keyword">true</span>, healthMap, <span class="keyword">true</span>))</span><br><span class="line">            .reduce(<span class="keyword">true</span>, BinaryOperators.andBoolean());</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        logger.info(<span class="string">"SOFABoot HealthChecker readiness check result: success."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.error(<span class="string">"SOFABoot HealthChecker readiness check result: failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里每个<code>HealthChecker</code>又委托给<code>doHealthCheck</code>来检查</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doHealthCheck</span><span class="params">(String beanId, HealthChecker healthChecker, <span class="keyword">boolean</span> isRetry,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Map&lt;String, Health&gt; healthMap, <span class="keyword">boolean</span> isReadiness)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(healthMap, <span class="string">"HealthMap must not be null"</span>);</span><br><span class="line">    Health health;</span><br><span class="line">    <span class="keyword">boolean</span> result;</span><br><span class="line">    <span class="keyword">int</span> retryCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// check 类型  readiness ？ liveness</span></span><br><span class="line">    String checkType = isReadiness ? <span class="string">"readiness"</span> : <span class="string">"liveness"</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 Health 对象</span></span><br><span class="line">        health = healthChecker.isHealthy();</span><br><span class="line">        <span class="comment">// 获取 健康检查状态结果</span></span><br><span class="line">        result = health.getStatus().equals(Status.UP);</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            logger.info(<span class="string">"HealthChecker[&#123;&#125;] &#123;&#125; check success with &#123;&#125; retry."</span>, beanId, checkType,retryCount);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.info(<span class="string">"HealthChecker[&#123;&#125;] &#123;&#125; check fail with &#123;&#125; retry."</span>, beanId, checkType,retryCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重试 &amp;&amp; 等待</span></span><br><span class="line">        <span class="keyword">if</span> (isRetry &amp;&amp; retryCount &lt; healthChecker.getRetryCount()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                retryCount += <span class="number">1</span>;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(healthChecker.getRetryTimeInterval());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                logger</span><br><span class="line">                    .error(</span><br><span class="line">                        String</span><br><span class="line">                            .format(</span><br><span class="line">                                <span class="string">"Exception occurred while sleeping of %d retry HealthChecker[%s] %s check."</span>,</span><br><span class="line">                                retryCount, beanId, checkType), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (isRetry &amp;&amp; retryCount &lt; healthChecker.getRetryCount());</span><br><span class="line">    <span class="comment">// 将当前 实例 bean 的健康检查结果存到结果集healthMap中</span></span><br><span class="line">    healthMap.put(beanId, health);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            logger</span><br><span class="line">                .error(</span><br><span class="line">                    <span class="string">"HealthChecker[&#123;&#125;] &#123;&#125; check fail with &#123;&#125; retry; fail details:&#123;&#125;; strict mode:&#123;&#125;"</span>,</span><br><span class="line">                    beanId, checkType, retryCount,</span><br><span class="line">                    objectMapper.writeValueAsString(health.getDetails()),</span><br><span class="line">                    healthChecker.isStrictCheck());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException ex) &#123;</span><br><span class="line">        logger.error(</span><br><span class="line">            String.format(<span class="string">"Error occurred while doing HealthChecker %s check."</span>, checkType), ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回健康检查结果</span></span><br><span class="line">    <span class="keyword">return</span> !healthChecker.isStrictCheck() || result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>doHealthCheck</code> 结果需要依赖具体 <code>HealthChecker</code> 实现类的处理。通过这样一种方式可以<code>SOFABoot</code>可以很友好的实现对所以 <code>HealthChecker</code> 的健康检查。<code>HealthIndicatorProcessor</code> 的 <code>readinessHealthCheck</code> 和<code>HealthChecker</code>的基本差不多；有兴趣的可以自行阅读源码 <a href="https://github.com/alipay/sofa-boot" target="_blank" rel="noopener">Alipay-SOFABoot</a>。</p>
<h4 id="AfterReadinessCheckCallbackProcessor"><a href="#AfterReadinessCheckCallbackProcessor" class="headerlink" title="AfterReadinessCheckCallbackProcessor"></a>AfterReadinessCheckCallbackProcessor</h4><p>这个接口是 <code>SOFABoot</code> 提供的一个扩展接口， 用于在 <code>Readiness Check</code> 之后做一些事情。其实现思路和前面的<code>XXXXProcessor</code> 是一样的，对之前初始化时得到的所有的<code>ReadinessCheckCallbacks</code>实例<code>bean</code>逐一进行回调处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">afterReadinessCheckCallback</span><span class="params">(Map&lt;String, Health&gt; healthMap)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"Begin ReadinessCheckCallback readiness check"</span>);</span><br><span class="line">    Assert.notNull(readinessCheckCallbacks, <span class="string">"ReadinessCheckCallbacks must not be null."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = readinessCheckCallbacks.entrySet().stream()</span><br><span class="line">            .map(entry -&gt; doHealthCheckCallback(entry.getKey(), entry.getValue(), healthMap))</span><br><span class="line">            .reduce(<span class="keyword">true</span>, BinaryOperators.andBoolean());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        logger.info(<span class="string">"ReadinessCheckCallback readiness check result: success."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.error(<span class="string">"ReadinessCheckCallback readiness check result: failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样也是委托给了<code>doHealthCheckCallback</code>来处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doHealthCheckCallback</span><span class="params">(String beanId,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      ReadinessCheckCallback readinessCheckCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Map&lt;String, Health&gt; healthMap)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(healthMap, () -&gt; <span class="string">"HealthMap must not be null"</span>);</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    Health health = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        health = readinessCheckCallback.onHealthy(applicationContext);</span><br><span class="line">        result = health.getStatus().equals(Status.UP);</span><br><span class="line">        <span class="comment">// print log 省略</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 存入 healthMap</span></span><br><span class="line">        healthMap.put(beanId, health);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="扩展-Readiness-Check-能力"><a href="#扩展-Readiness-Check-能力" class="headerlink" title="扩展 Readiness Check 能力"></a>扩展 Readiness Check 能力</h4><p>按照上面的分析，我们可以自己来实现下这几个扩展。</p>
<h4 id="实现-HealthChecker-接口"><a href="#实现-HealthChecker-接口" class="headerlink" title="实现 HealthChecker 接口"></a>实现 HealthChecker 接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperHealthChecker</span> <span class="keyword">implements</span> <span class="title">HealthChecker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Health <span class="title">isHealthy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以检测数据库连接是否成功</span></span><br><span class="line">        <span class="comment">// 可以检测zookeeper是否启动成功</span></span><br><span class="line">        <span class="comment">// 可以检测redis客户端是否启动成功</span></span><br><span class="line">        <span class="comment">// everything you want ...</span></span><br><span class="line">        <span class="keyword">if</span>(OK)&#123;</span><br><span class="line">            <span class="keyword">return</span> Health.up().build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Health.down().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getComponentName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 组件名</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"GlmapperComponent"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRetryCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重试次数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getRetryTimeInterval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重试间隔</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStrictCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现-ReadinessCheckCallback-接口"><a href="#实现-ReadinessCheckCallback-接口" class="headerlink" title="实现 ReadinessCheckCallback 接口"></a>实现 ReadinessCheckCallback 接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperReadinessCheckCallback</span> <span class="keyword">implements</span> <span class="title">ReadinessCheckCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Health <span class="title">onHealthy</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        Object glmapperHealthChecker = applicationContext.getBean(<span class="string">"glmapperHealthChecker"</span>);</span><br><span class="line">        <span class="keyword">if</span> (glmapperHealthChecker <span class="keyword">instanceof</span> GlmapperHealthChecker)&#123;</span><br><span class="line">            <span class="keyword">return</span> Health.up().build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Health.down().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看下健康检查日志：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/16/1671b484144d1d65?w=1590&amp;h=386&amp;f=png&amp;s=475058" alt=""></p>
<p>可以看到我们自己定义的检查类型<code>ready</code>了。</p>
<p>从日志看到有一个 <code>sofaBootHealthIndicator</code>，实现了<code>HealthIndicator</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SofaBootHealthIndicator</span> <span class="keyword">implements</span> <span class="title">HealthIndicator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String    CHECK_RESULT_PREFIX = <span class="string">"Middleware"</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HealthCheckerProcessor healthCheckerProcessor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Health <span class="title">health</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Health&gt; healths = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 调用了 healthCheckerProcessor 的 livenessHealthCheck</span></span><br><span class="line">        <span class="keyword">boolean</span> checkSuccessful = healthCheckerProcessor.livenessHealthCheck(healths);</span><br><span class="line">        <span class="keyword">if</span> (checkSuccessful) &#123;</span><br><span class="line">            <span class="keyword">return</span> Health.up().withDetail(CHECK_RESULT_PREFIX, healths).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Health.down().withDetail(CHECK_RESULT_PREFIX, healths).build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>livenessHealthCheck</code> 和 <code>readinessHealthCheck</code> 两个方法都是交给 <code>doHealthCheck</code> 来处理的，没有看出来有什么区别。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文基于 <code>SOFABoot 3.0.0</code> 版本，与之前版本有一些区别。详细变更见：<a href="http://www.sofastack.tech/sofa-boot/docs/upgrade_3_x" target="_blank" rel="noopener">SOFABoot upgrade_3_x</a>。本篇文章简单介绍了 <code>SOFABoot</code> 对 <code>SpringBoot</code> 健康检查能力扩展的具体实现细节。</p>
<p>最后再来补充下 <code>liveness</code> 和 <code>readiness</code>，从字面意思来理解，<code>liveness</code>就是是否是活的，<code>readiness</code> 就是意思是否可访问的。</p>
<ul>
<li><code>readiness</code>：应用即便已经正在运行了，它仍然需要一定时间才能 提供 服务，这段时间可能用来加载数据，可能用来构建缓存，可能用来注册服务，可能用来选举 <code>Leader</code>等等。总之 <code>Readiness</code> 检查通过前是不会有流量发给应用的。目前 <code>SOFARPC</code> 就是在 <code>readiness check</code> 之后才会将所有的服务注册到注册中心去。</li>
<li><code>liveness</code>：检测应用程序是否正在运行</li>
</ul>

      
    </div>
    <br>
    <br>
    <a href="http://www.glmapper.com/2018/11/16/sofa-boot-health-analizy/" class="more">Read more <i class="icon-angle-right"></i></a>
  </div>
</div>
<hr class="blog-post-sep">

      
    </div>
    
      <div id="page-nav" class="pagination">
	<a class="extend prev" rel="prev" href="/page/5/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/7/">Next</a>
      </div>
    
  </section>

</div>

</div>

  </div>
  </div>



    <!-- BEGIN PRE-FOOTER -->
    <div class="pre-footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN BOTTOM ABOUT BLOCK -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>About Us</h2>
            <p>Computer Lab is a software development and marketing company based in Brooklyn, New York. <br><br> Computer Lab was founded in 2015, and is focused on so on and so forth.</p>
          </div>
          <!-- END BOTTOM ABOUT BLOCK -->

          <!-- BEGIN BOTTOM CONTACTS -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>Contact</h2>
            <address class="margin-bottom-40">
              140 Metropolitan Avenue<br>
              5th Floor<br>
              Brooklyn, NY 11249<br>
              Phone: 716-472-4484<br>
              Email: <a href="mailto:ptsteadman@gmail.com">ptsteadman@gmail.com</a><br>
            </address>
          </div>
          <!-- END BOTTOM CONTACTS -->

	
          <!-- BEGIN TWITTER BLOCK --> 
          <div class="col-md-4 col-sm-6 pre-footer-col">

	  <a data-tweet-limit="1" class="twitter-timeline" href="https://twitter.com/computerlab_" data-widget-id="678830341331820544">Tweets by @computerlab_</a>

	  <script>!function(d,s,id){var
	  js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

          </div>
          <!-- END TWITTER BLOCK -->
	
        </div>
      </div>
    </div>
    <!-- END PRE-FOOTER -->

    <!-- BEGIN FOOTER -->
    <div class="footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN COPYRIGHT -->
          <div class="col-md-6 col-sm-6 padding-top-10">
                  &copy; 2020 glmapper<br>
 <a href="javascript:;">Privacy Policy</a> | <a href="javascript:;">Terms of Service</a>
          </div>
          <!-- END COPYRIGHT -->
	  <!-- BEGIN SOCIAL -->
<div class="col-md-6 col-sm-6">
  <ul class="social-footer list-unstyled list-inline pull-right">
    
      <li><a href="https://github.com/ptsteadman"><i class="fa fa-github"></i></a></li>
    
      <li><a href="https://twitter.com/ptsteadman"><i class="fa fa-twitter"></i></a></li>
    
      <li><a href="https://www.facebook.com/ptsteadman"><i class="fa fa-facebook"></i></a></li>
    
      <li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li>
    
      <li><a href="https://linkedin.com/in/ptsteadman"><i class="fa fa-linkedin"></i></a></li>
    
      <li><a href="http://stackoverflow.com/users/2480493/patrick-steadman"><i class="fa fa-stackoverflow"></i></a></li>
    
  </ul>  
</div>
<!-- END SOCIAL -->

        </div>
      </div>
    </div>
    <!-- END FOOTER -->

  <!-- BEGIN CORE PLUGINS (REQUIRED FOR ALL PAGES) -->
<!--[if lt IE 9]>
<script src="/metronic/assets/plugins/respond.min.js"></script>
<![endif]--> 
<script src="/metronic/assets/plugins/jquery.min.js"></script>
<script src="/metronic/assets/plugins/jquery-migrate.min.js"></script>
<script src="/metronic/assets/plugins/bootstrap/js/bootstrap.min.js"></script>
<script src="/metronic/assets/corporate/scripts/back-to-top.js"></script>
<script src="/metronic/assets/plugins/owl.carousel/owl.carousel.min.js"></script>
<script src="/metronic/assets/corporate/scripts/layout.js"></script>
<script src="/js/wow.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script type="text/javascript">
    jQuery(document).ready(function() {
        Layout.init();    
        Layout.initOWL();
        Layout.initTwitter();
        Layout.initFixHeaderWithPreHeader(); /* Switch On Header Fixing (only if you have pre-header) */
        Layout.initNavScrolling(); 
	new WOW().init();
    });
</script>
<!-- END CORE PLUGINS -->

<!-- BEGIN PAGE-SPECIFIC PLUGINS --> 







<!-- END PAGE-SPECIFIC PLUGINS --> 

<!-- BEGIN INTEGRATIONS -->





<!-- END INTEGRATIONS -->

</body>
</html>
