{"title":"Mysql - 从一个小 case 理解 MVCC","uid":"6c139a1ec6733d215aeb28747f12a741","slug":"db/mysql-transaction-mvcc-case","date":"2022-11-12T03:23:22.000Z","updated":"2024-07-05T04:09:05.751Z","comments":true,"path":"api/articles/db/mysql-transaction-mvcc-case.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>原文链接： <a href=\"https://juejin.cn/post/7163934829984088095\">https://juejin.cn/post/7163934829984088095</a> </p></blockquote>\n<h2 id=\"从-innoDB-的一致性非锁定读说起\"><a href=\"#从-innoDB-的一致性非锁定读说起\" class=\"headerlink\" title=\"从 innoDB 的一致性非锁定读说起\"></a>从 innoDB 的一致性非锁定读说起</h2><h3 id=\"非锁定读和行快照数据\"><a href=\"#非锁定读和行快照数据\" class=\"headerlink\" title=\"非锁定读和行快照数据\"></a>非锁定读和行快照数据</h3><p>一致性的非锁定读（consistent nonlocking read）是指 InnoDB 存储引擎通过行多版本控制（multi versioning）的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行 DELETE 或 UPDATE 操作，这时读取操作不会因此去等待行上锁的释放。相反地，<strong>InnoDB 存储引擎会去读取行的一个快照数据</strong>，下图是关于快照数据的一个简单示图：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddcbc6d689cf4d6fb251f29aedf8df34~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<span id=\"more\"></span>\n\n<p>之所以称其为<strong>非锁定读</strong>，因为不需要等待访问的行上 X 锁的释放。快照数据是指该行的之前版本的数据，该实现是通过 undo 段来完成。而 undo 用来在事务中回滚数据，因此快照数据本身是没有额外的开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。因此，非锁定读机制可以极大地提高数据库的并发性。</p>\n<p>在 InnoDB 存储引擎的默认设置下，非锁定读是默认的读取方式，即读取不会占用和等待表上的锁。</p>\n<ul>\n<li>在不同事务隔离级别下，读取的方式不同，并不是在每个事务隔离级别下都是采用非锁定的一致性读</li>\n<li>即使都是使用非锁定的一致性读，对于快照数据的定义也各不相同</li>\n</ul>\n<h3 id=\"MVCC-的定义\"><a href=\"#MVCC-的定义\" class=\"headerlink\" title=\"MVCC 的定义\"></a>MVCC 的定义</h3><p>快照数据其实就是当前行数据之前的历史版本，每行记录可能有多个版本。一个行记录可能有不止一个快照数据，一般称这种技术为行多版本技术。由此带来的并发控制，称之为多版本并发控制（Multi Version Concurrency Control，MVCC）。</p>\n<h2 id=\"一些前提知识\"><a href=\"#一些前提知识\" class=\"headerlink\" title=\"一些前提知识\"></a>一些前提知识</h2><p>在开始案例分析之前，这里先简单介绍一些准备知识，如数据库级别的查看和设置，数据库事务的简单使用命令等。</p>\n<h3 id=\"数据库隔离级别的设置和查看\"><a href=\"#数据库隔离级别的设置和查看\" class=\"headerlink\" title=\"数据库隔离级别的设置和查看\"></a>数据库隔离级别的设置和查看</h3><ul>\n<li>1、查看数据库隔离级别</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select @@global.tx_isolation,@@tx_isolation;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>2、设置数据库隔离级别</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125;</span><br></pre></td></tr></table></figure>\n\n<p>设置数据库隔离级别 scope 有两种，一种是当前会话级别，另一种是全局级别，示例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 全局的</span><br><span class=\"line\">mysql&gt; set global transaction isolation level read uncommitted;</span><br><span class=\"line\">// 当前会话</span><br><span class=\"line\">mysql&gt; set session transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数据库事务的基本使用\"><a href=\"#数据库事务的基本使用\" class=\"headerlink\" title=\"数据库事务的基本使用\"></a>数据库事务的基本使用</h3><ul>\n<li>1、通过 SET AUTOCOMMIT&#x3D;0 禁止自动提交</li>\n<li>2、用 BEGIN， ROLLBACK，COMMIT 来完成事务的基本操作<ul>\n<li>BEGIN 开始事务</li>\n<li>ROLLBACK 回滚事务</li>\n<li>COMMIT 提交事务</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"事务隔离级别的案例分析\"><a href=\"#事务隔离级别的案例分析\" class=\"headerlink\" title=\"事务隔离级别的案例分析\"></a>事务隔离级别的案例分析</h2><p>前面简单介绍了非锁定读、MVCC 以及和本案例相关的一些数据库基本操作知识，下面来介绍在不同在不同事务隔离级别下，事务之间对于数据可见性和隔离性的一些基本问题。</p>\n<h3 id=\"案例说明\"><a href=\"#案例说明\" class=\"headerlink\" title=\"案例说明\"></a>案例说明</h3><p>本案例中，提供了一张 orders 表，包括 id 和 marks 两个字段，id 为主键</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from orders;</span><br><span class=\"line\">+----+-----------+</span><br><span class=\"line\">| id | marks     |</span><br><span class=\"line\">+----+-----------+</span><br><span class=\"line\">|  1 | test1 |</span><br><span class=\"line\">|  2 | test2     |</span><br><span class=\"line\">+----+-----------+</span><br></pre></td></tr></table></figure>\n\n<p>在案例中将通过开启不同的事务级别来进行测试。大致思路是：</p>\n<ul>\n<li>1、禁止事务自动提交</li>\n<li>2、将全局事务的隔离级别和会话级别的隔离级别都设置成一样的</li>\n<li>3、开启两个会话窗口，在两个会话窗口内分别开启两个事务，在事务 A 中更新 id &#x3D;x 的 mark 记录<ul>\n<li>未提交时，分别在事务 A 和 事务 B 中查询 id &#x3D;x 的记录；</li>\n<li>提交后，分别在事务 A 和 事务 B 中查询 id &#x3D;x 的记录；</li>\n</ul>\n</li>\n</ul>\n<p>其中 1和 2 用于保证条件一致，3 为需要测试的操作。</p>\n<h3 id=\"read-uncomitted\"><a href=\"#read-uncomitted\" class=\"headerlink\" title=\"read uncomitted\"></a>read uncomitted</h3><p>1、将两个会话的事务级别设置成相同的，均为 read uncommitted</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/803d4b48c0254c8cab76d61e2cfcb0fd~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>2、在事务 A 中执行更新 orders 表中 id 为 1 的记录</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51fd953967f14361b101b071b9e921bf~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>3、分别在两个事务中查询 id&#x3D;1 的记录</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90556fd0a2bc4f60bb60ae9bba29e7d7~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p><strong>现象：在事务 A 没有提交的情况下，事务 B 可以看到事务 A 中更新的记录值了，这就是脏读。此时回滚事务 A，然后再次查询：</strong></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/771744a6c0d9471092e232e33fa45690~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>所以对于 read uncommitted，不同事务之间数据都可见，没有隔离性可言。</p>\n<h3 id=\"read-comitted\"><a href=\"#read-comitted\" class=\"headerlink\" title=\"read comitted\"></a>read comitted</h3><p>将事务级别设置成 read committed，然后在事务 A 中更新 id 为 1 的记录。</p>\n<ul>\n<li>未 commit 时，事务 A 中更新的值对于事务 B 是不可见的；这也解释了事务 B 读取的快照数据。</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e91c1dca8934d43b6a31542c605e498~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<ul>\n<li>commit 之后，事务 B 中可以读取到事务 A 更新的值了。</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/548d4abfe7984c3b8957f253dd80c593~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p><strong>READ COMMITTED 事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。</strong></p>\n<h3 id=\"repeatable-read\"><a href=\"#repeatable-read\" class=\"headerlink\" title=\"repeatable read\"></a>repeatable read</h3><p>将事务级别设置成 repeatable read，然后在事务 A 中更新 id 为 1 的记录；</p>\n<ul>\n<li>事务 A commit 之前，事务 A 中更新的数据对于事务 B 是不可见的；说明事务 B 读取的快照数据。</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7910338037c400fb32bd706c81448f0~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<ul>\n<li>事务 A commit 之后，事务 B 读取的还是以前的值，并没有读取到事务 A 中更新的值。结束事务 B 之后，再次查询，事务 B 查询到的值才是最新的。</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9e98483f0aa4734b2e1922e9651bf31~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p><strong>REPEATABLE READ 事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。</strong></p>\n<h3 id=\"关于幻读\"><a href=\"#关于幻读\" class=\"headerlink\" title=\"关于幻读\"></a>关于幻读</h3><p>笔者在没有进行这个测试之前，对于幻读的意义理解是停留在类似这种描述上的：</p>\n<p>当某个事务在读取某个范围的记录的时候，另外一个事务又在该范围插入了新的记录，当前事务再次读取这个范围的记录，会产生<a href=\"https://www.zhihu.com/search?q=%E5%B9%BB%E8%A1%8C&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1523900737%7D\">幻行</a>（Phantom Data）– 《高性能MySQL》第三版</p>\n<p>首先这个描述没有问题，笔者之前的理解是：<strong>在一个事务中 连续两次查询结果不一致（前提是基于可重复读隔隔离级别下），那这句话的反意就是，在一个事务中，如果连续两次查询结果一致，就不是幻读。</strong></p>\n<p>来看下面的案例。</p>\n<h4 id=\"场景-1\"><a href=\"#场景-1\" class=\"headerlink\" title=\"场景 1\"></a>场景 1</h4><p>使用 range 查询，IS 锁场景，事务 B 中插入主键间隙之内的一条数据。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f415a1b3b8fb433f9fcb543227a15a87~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>在可重复读的隔离级别下，事务 A 满足之前提到的可重复读的情况，不满足前面 <strong>在一个事务中 连续两次查询结果不一致</strong> 的说法；那么这里对于幻读的解释实际上就是：</p>\n<p><strong>事务A 没有正常读取到最新的事务，理论上应该有 3 条数据，而实际查询出来只有 2 条，这种情况对于事务 A 来说产生了幻读？</strong></p>\n<h4 id=\"场景-2\"><a href=\"#场景-2\" class=\"headerlink\" title=\"场景 2\"></a>场景 2</h4><p>在事务 A 和事务 B 中插入同一条数据。这种情况，因为在两个事务中同时写入一条数据，当事务 A 写入 id 为 6 数据，但是没有提交事务的时候，理论上事务 B 又写入 id 为 6 的数据会被阻塞住，那么对于事务 B 来说，它就需要知道事务 A 中有同样的操作；来看案例</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e5726340e824e9b8c7178e48fadf89d~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>此时事务 B 被阻塞等待事务 A 的提交。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed1d3ee1f2904925be92fce4c9ffa2df~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>当 事务 A 提交之后，事务 B 抛出异常。再次在事务 B 中查询，理论上如果存在幻读情况，事务 B 中将读取不到 id 为 6 的记录值，经测试事务 B 中读取到了 事务 A 中 提交之后的最新数据，因此对于这种情况，事务 B 在事务开始时查询到的结果没有 6，随后又执行了一次同样的查询操作，但是返回的结果确包含了 id 为 6 的记录，因此产生幻读。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90d9414f1775406f8ef2a1c0b2bde099~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>这里相比于 case 1 ，事务 B 在查询第二次之前做了一次 insert 操作，insert 有一个潜在的规则是在插入数据之前需要读取当前最新记录数据，这也就和读提交读取最新记录是一致的，而不是读取的事务开始之前的数据了。</p>\n<h4 id=\"关于幻读的总结\"><a href=\"#关于幻读的总结\" class=\"headerlink\" title=\"关于幻读的总结\"></a>关于幻读的总结</h4><p>ANSI SQL 隔离级别标准里可重复读级别是存在幻读问题；但是 InnoDB 的可重复读级别 <strong>通过MVCC机制解决了幻读问题</strong>！所以 InnoDB 的可重复读是不存在幻读问题的（这里的幻读指的是：当某个事务在读取某个范围的记录的时候，另外一个事务又在该范围插入了新的记录，当前事务再次读取这个范围的记录，会产生<a href=\"https://www.zhihu.com/search?q=%E5%B9%BB%E8%A1%8C&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1523900737%7D\">幻行</a>（Phantom Data））。</p>\n<p>case 2 中由于触发了当前读而<strong>导致数据冲突</strong>的问题，才导致了“幻读”的情况。insert、update 等语句执行之前，会先 select，再执行 insert、update。简单说，就是先读一次，再执行更新语句。而且这个读，是读最新的数据！</p>\n<h2 id=\"关于脏读、不可重复读、幻读\"><a href=\"#关于脏读、不可重复读、幻读\" class=\"headerlink\" title=\"关于脏读、不可重复读、幻读\"></a>关于脏读、不可重复读、幻读</h2><p>上述案例中，</p>\n<ul>\n<li>在 read uncommitted 隔离级别下，事务 B 可以读取到事务 A 未提交的数据，这种情况称之为 <strong>脏读。</strong></li>\n<li>在 read committed 隔离界级别下，事务 B 可以读取到事务 A 已经提交的数据，但是在当前事务 B 处理过程之内，意味着其它事务的数据变更都会影响到事务 B 中获取到的行数据的值，这种情况称之为 <strong>不可重复读</strong>。</li>\n<li>在 repeatable-read 隔离级别下，分为两种情况：<ul>\n<li>事务 A 中仅执行两次 range 查询，事务 B 插入新数据并提交事务时，事务 A 中第二次查询不会产线幻读情况。</li>\n<li>事务 A 执行两次插入查询中间执行 insert 操作，且于事务 B 中存在锁冲突时，事务 A 会将快照读改为当前读，从而第一次查询和第二次查询结果不一致。。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.zhihu.com/question/47007926\">https://www.zhihu.com/question/47007926</a></p>\n","text":" 原文链接： https://juejin.cn/post/7163934829984088095 从 innoDB 的一致性非锁定读说起非锁定读和行快照数据一...","permalink":"/post/db/mysql-transaction-mvcc-case","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"数据库","slug":"数据库","count":1,"path":"api/categories/数据库.json"}],"tags":[{"name":"mysql","slug":"mysql","count":4,"path":"api/tags/mysql.json"},{"name":"mvcc","slug":"mvcc","count":1,"path":"api/tags/mvcc.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%8E-innoDB-%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB%E8%AF%B4%E8%B5%B7\"><span class=\"toc-text\">从 innoDB 的一致性非锁定读说起</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB%E5%92%8C%E8%A1%8C%E5%BF%AB%E7%85%A7%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">非锁定读和行快照数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#MVCC-%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">MVCC 的定义</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%BA%9B%E5%89%8D%E6%8F%90%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">一些前提知识</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E8%AE%BE%E7%BD%AE%E5%92%8C%E6%9F%A5%E7%9C%8B\"><span class=\"toc-text\">数据库隔离级别的设置和查看</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">数据库事务的基本使用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90\"><span class=\"toc-text\">事务隔离级别的案例分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A1%88%E4%BE%8B%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">案例说明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#read-uncomitted\"><span class=\"toc-text\">read uncomitted</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#read-comitted\"><span class=\"toc-text\">read comitted</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#repeatable-read\"><span class=\"toc-text\">repeatable read</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB\"><span class=\"toc-text\">关于幻读</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9C%BA%E6%99%AF-1\"><span class=\"toc-text\">场景 1</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9C%BA%E6%99%AF-2\"><span class=\"toc-text\">场景 2</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E5%B9%BB%E8%AF%BB%E7%9A%84%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">关于幻读的总结</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E8%84%8F%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E3%80%81%E5%B9%BB%E8%AF%BB\"><span class=\"toc-text\">关于脏读、不可重复读、幻读</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"New Features Of JDK - JDK9 Modular System","uid":"679bdcba368529704928bcc9f610db76","slug":"java/java-open-jdk9-module","date":"2022-12-04T07:45:44.000Z","updated":"2024-07-05T04:09:05.764Z","comments":true,"path":"api/articles/java/java-open-jdk9-module.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":null,"text":"Modular System 是 JAVA9 中提供的新特性，它从一个独立的开源项目而来，名为 Jigsaw Project。在此之前，我们对于 Java 技术...","permalink":"/post/java/java-open-jdk9-module","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[{"name":"JAVA","slug":"JAVA","count":12,"path":"api/categories/JAVA.json"}],"tags":[{"name":"openjdk","slug":"openjdk","count":1,"path":"api/tags/openjdk.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"RocketMQ Push 消费模型","uid":"58f683d88937558e07ea2c785aa7588a","slug":"mq/rocketmq/rocketmq-push-consumer-model","date":"2022-09-22T13:31:29.000Z","updated":"2024-07-05T04:09:05.794Z","comments":true,"path":"api/articles/mq/rocketmq/rocketmq-push-consumer-model.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"text":"Push 模式是指由 Server 端来控制消息的推送，即当有消息到 Server 之后，会将消息主动投递给 client(Consumer 端)。 使用 De...","permalink":"/post/mq/rocketmq/rocketmq-push-consumer-model","photos":[],"count_time":{"symbolsCount":"9.6k","symbolsTime":"9 mins."},"categories":[{"name":"RocketMQ","slug":"RocketMQ","count":2,"path":"api/categories/RocketMQ.json"}],"tags":[{"name":"RocketMQ","slug":"RocketMQ","count":3,"path":"api/tags/RocketMQ.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}