{"title":"SpringCloud-Config 配置中心原理","uid":"c052787b71e80e9cd4e175cda11073d3","slug":"springcloud/spring-cloud-config-analysis","date":"2018-12-31T15:11:33.000Z","updated":"2024-07-05T04:09:05.835Z","comments":true,"path":"api/articles/springcloud/spring-cloud-config-analysis.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"content":"<p>本篇可以配合《<a href=\"/2018/12/31/springcloud/spring-cloud-config-github\">SpringCloud-配置中心 Config</a>》来看，《<a href=\"/2018/12/31/springcloud/spring-cloud-config-github\">SpringCloud-配置中心 Config</a>》中是基于SOFABoot 来集成 Spring Cloud Config 的一个 demo 案例。</p>\n<p>在demo中，涉及到三个角色：</p>\n<ul>\n<li>配置中心服务端：为配置客户端提供对应的配置信息，配置信息的来源是配置仓库。应用启动时，会从配置仓库拉取配置信息缓存到本地仓库中。</li>\n<li>配置中心客户端：应用启动时从配置服务端拉取配置信息。</li>\n<li>配置仓库：为配置中心服务端提供配置信息存储，Spring Cloud Config 默认是使用git作为仓库的。<span id=\"more\"></span></li>\n</ul>\n<p><img src=\"https://oscimg.oschina.net/oscnet/3586089d566730b5fc6f5df08e96e5bb0b1.jpg\"></p>\n<p>整体过程：</p>\n<ul>\n<li>环境部署之前，将所需的配置信息推送到配置仓库</li>\n<li>启动配置中心服务端，将配置仓库的配置信息拉取到服务端，配置服务端对外提供REST接口</li>\n<li>启动配置客户端，客户端根据 spring.cloud.config 配置的信息去服务器拉取相应的配置</li>\n</ul>\n<h2 id=\"服务端实现\"><a href=\"#服务端实现\" class=\"headerlink\" title=\"服务端实现\"></a>服务端实现</h2><p>配置中心服务端主要做了几件事情：连接配置仓库、拉取远程配置&amp;本地缓存、对外提供API接口服务。</p>\n<h3 id=\"EnableConfigServer-及配置类\"><a href=\"#EnableConfigServer-及配置类\" class=\"headerlink\" title=\"@EnableConfigServer 及配置类\"></a>@EnableConfigServer 及配置类</h3><p>注解 EnableConfigServer 可以开启应用服务对配置中心的支持。当开启之后，配置服务器就会在启动时进行自动配置。具体对应的配置类是 ConfigServerAutoConfiguration，然后又在 ConfigServerAutoConfiguration 这个配置类中引入了其他很多配置类。如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnBean(&#123;Marker.class&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties(&#123;ConfigServerProperties.class&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Import(&#123;EnvironmentRepositoryConfiguration.class, CompositeConfiguration.class, ResourceRepositoryConfiguration.class, ConfigServerEncryptionConfiguration.class, ConfigServerMvcConfiguration.class&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConfigServerAutoConfiguration</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ConfigServerAutoConfiguration</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>EnvironmentRepositoryConfiguration： 环境变量存储相关的配置类</li>\n<li>CompositeConfiguration：组合方式的环境仓库配置类</li>\n<li>ResourceRepositoryConfiguration：资源仓库相关的配置类</li>\n<li>ConfigServerEncryptionConfiguration：加密断点相关的配置类</li>\n<li>ConfigServerMvcConfiguration：对外暴露的MVC端点控制器的配置类</li>\n</ul>\n<p>无论是 Spring Cloud 自身提供的默认实现 git ，还是 zk，或者 apollo ；基本思路都是在程序启动时将远端配置拉取到本地作为环境变量来使用，但这些是针对客户端角度来说的。Spring Cloud Config Server 因为其本身是以服务端存在，所以 Config Server 本身的实现思路也值得后面开发借鉴。</p>\n<p>对于服务端来说，其基本职责就是能够将具体存储中的配置信息先拿到，然后提供出 API 供客户端来调用。下面从ConfigServerAutoConfiguration 中 import的这些配置类来具体看下实现。</p>\n<h3 id=\"EnvironmentRepositoryConfiguration\"><a href=\"#EnvironmentRepositoryConfiguration\" class=\"headerlink\" title=\"EnvironmentRepositoryConfiguration\"></a>EnvironmentRepositoryConfiguration</h3><p>EnvironmentRepositoryConfiguration 是环境变量存储相关的配置类，它本身也提供了很多实现：</p>\n<p><img src=\"https://oscimg.oschina.net/oscnet/3b93eff5aa7978c04010c2b0bb75f7bae17.jpg\"></p>\n<p>上图中可以看到，环境配置仓库支持的有JDBC、SVN、本地文件系统、Git等等。这些对不同环境仓库的支持，在实现上基本都差不多，下面以默认提供的方式git来分析。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@Profile(&quot;git&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GitRepositoryConfiguration</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">DefaultRepositoryConfiguration</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>GitRepositoryConfiguration 集成了 DefaultRepositoryConfiguration，这也说明了 Spring Cloud Config 默认使用的是Git。不同的配置类实现都会被标注一个@Profile，可以通过这个来激活相应的配置类；具体做法是在配置服务端的 application.properties(application.yml) 中来指定：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.profile.active=git</span><br></pre></td></tr></table></figure>\n\n<p>没有设置就是默认使用 GIt。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnMissingBean(value = EnvironmentRepository.class, search = SearchStrategy.CURRENT)</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DefaultRepositoryConfiguration</span> &#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> ConfigurableEnvironment environment;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> ConfigServerProperties server;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired(required = false)</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> TransportConfigCallback customTransportConfigCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> MultipleJGitEnvironmentRepository <span class=\"title function_\">defaultEnvironmentRepository</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">\t        MultipleJGitEnvironmentRepositoryFactory gitEnvironmentRepositoryFactory,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\tMultipleJGitEnvironmentProperties environmentProperties)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> gitEnvironmentRepositoryFactory.build(environmentProperties);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>DefaultRepositoryConfiguration 的 ConditionalOnMissingBean 可以知道，如果上下文中没有 EnvironmentRepository，那么就使用 DefaultRepositoryConfiguration。</p>\n<h3 id=\"MultipleJGitEnvironmentRepository\"><a href=\"#MultipleJGitEnvironmentRepository\" class=\"headerlink\" title=\"MultipleJGitEnvironmentRepository\"></a>MultipleJGitEnvironmentRepository</h3><p>MultipleJGitEnvironmentRepository 是 Git 存储的具体实现类，下面是类图结构：<br><img src=\"https://oscimg.oschina.net/oscnet/00a410c73f4e93c55f8ce2e386e5254718e.jpg\"></p>\n<p>MultipleJGitEnvironmentRepository 的顶层接口是 EnvironmentRepository ，当然其他的实现也都是实现了这个接口的。另外一个需要关注的是 SearchPathLocator。</p>\n<ul>\n<li>EnvironmentRepository：定义了获取指定应用服务环境信息的方法，返回一个Enviroment</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">EnvironmentRepository</span> &#123;</span><br><span class=\"line\">\tEnvironment <span class=\"title function_\">findOne</span><span class=\"params\">(String application, String profile, String label)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>三个参数，application、profile、label；《<a href=\"/2018/12/31/springcloud/spring-cloud-config-github\">SpringCloud-配置中心 Config</a>》 中客户端部分有对这三个的参数的说明及使用方式，通过这三个参数可以具体定位到配置信息。</p>\n<ul>\n<li>SearchPathLocator ： 根据传入客户端应用信息，获取对应的配置环境文件的位置。代码见：<a href=\"%5Bhttps://github.com/spring-cloud/spring-cloud-config/blob/master/spring-cloud-config-server/src/main/java/org/springframework/cloud/config/server/environment/SearchPathLocator.java%5D(https://github.com/spring-cloud/spring-cloud-config/blob/master/spring-cloud-config-server/src/main/java/org/springframework/cloud/config/server/environment/SearchPathLocator.java)\">SearchPathLocator</a>。</li>\n</ul>\n<p>SearchPathLocator 中有一个内部类 Locations ，Locdations中定义了应用服务配置存储信息。</p>\n<p>除了这两个之外，还有一个 AbstractScmAccessor，这个抽象类里面定义了一些列与git存储相关的属性和方法。包括远程仓库的地址、账户、密码、ssh 私钥、本地仓库的地址等等。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>SCM : 软件配置管理</p></blockquote>\n<h3 id=\"AbstractScmEnvironmentRepository\"><a href=\"#AbstractScmEnvironmentRepository\" class=\"headerlink\" title=\"AbstractScmEnvironmentRepository\"></a>AbstractScmEnvironmentRepository</h3><p>AbstractScmEnvironmentRepository 实现了 AbstractScmAccessor 和 EnvironmentRepository ，主要就是EnvironmentRepository 中 findOne 的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Environment <span class=\"title function_\">findOne</span><span class=\"params\">(String application, String profile, String label)</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//新建了一个本地仓库作为代理仓库来使用</span></span><br><span class=\"line\">  <span class=\"type\">NativeEnvironmentRepository</span> <span class=\"variable\">delegate</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NativeEnvironmentRepository</span>(getEnvironment(),</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> <span class=\"title class_\">NativeEnvironmentProperties</span>());</span><br><span class=\"line\">    <span class=\"comment\">//获取本地仓库中指定应用的位置</span></span><br><span class=\"line\">\t\t<span class=\"type\">Locations</span> <span class=\"variable\">locations</span> <span class=\"operator\">=</span> getLocations(application, profile, label);</span><br><span class=\"line\">\t\tdelegate.setSearchLocations(locations.getLocations());</span><br><span class=\"line\">  \t<span class=\"comment\">//根据这个路径搜索应用服务的配置信息</span></span><br><span class=\"line\">\t\t<span class=\"type\">Environment</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> delegate.findOne(application, profile, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">\t\tresult.setVersion(locations.getVersion());</span><br><span class=\"line\">\t\tresult.setLabel(label);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.cleaner.clean(result, getWorkingDirectory().toURI().toString(),</span><br><span class=\"line\">\t\t\t\tgetUri());</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>getLocations 是一个模板方法，Config Server中提供了三种实现：</p>\n<p><img src=\"https://oscimg.oschina.net/oscnet/5c29f16cdb3057306c9eb7d95a19188ef36.jpg\"></p>\n<p>分别是单 Git 仓库，多 Git 仓库和 Svn 仓库实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Locations <span class=\"title function_\">getLocations</span><span class=\"params\">(String application, String profile,</span></span><br><span class=\"line\"><span class=\"params\">        String label)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (label == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        label = <span class=\"built_in\">this</span>.defaultLabel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// 获取最新的版本号</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">version</span> <span class=\"operator\">=</span> refresh(label);</span><br><span class=\"line\"><span class=\"comment\">// 根据最新的版本号返回 Locations 定位到资源的搜索路径</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Locations</span>(application, profile, label, version,</span><br><span class=\"line\">            getSearchLocations(getWorkingDirectory(), application, profile, label));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>refresh 方法做的作用就是刷新本地仓库的配置状态，这样就能保证每次都能拉取到最新的配置信息。下面来分析这个方法。</p>\n<h3 id=\"JGitEnvironmentRepository-refresh\"><a href=\"#JGitEnvironmentRepository-refresh\" class=\"headerlink\" title=\"JGitEnvironmentRepository#refresh\"></a>JGitEnvironmentRepository#refresh</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">refresh</span><span class=\"params\">(String label)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Git</span> <span class=\"variable\">git</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个git客户端</span></span><br><span class=\"line\">        git = createGitClient();</span><br><span class=\"line\">    <span class=\"comment\">// 是否需要执行 git pull</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shouldPull(git)) &#123;</span><br><span class=\"line\">            <span class=\"type\">FetchResult</span> <span class=\"variable\">fetchStatus</span> <span class=\"operator\">=</span> fetch(git, label);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (deleteUntrackedBranches &amp;&amp; fetchStatus != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                deleteUntrackedLocalBranches(fetchStatus.getTrackingRefUpdates(), git);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 获取后checkout，这样我们就可以获得任何新的分支、tag等。</span></span><br><span class=\"line\">            checkout(git, label);</span><br><span class=\"line\">            tryMerge(git, label);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 没有什么要更新，所以只是checkout和merge。</span></span><br><span class=\"line\">            <span class=\"comment\">// 合并是因为远程分支以前可能已经更新过</span></span><br><span class=\"line\">            checkout(git, label);</span><br><span class=\"line\">            tryMerge(git, label);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 返回当前的版本</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> git.getRepository().findRef(<span class=\"string\">&quot;HEAD&quot;</span>).getObjectId().getName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 异常处理</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 关闭git</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个里面基本就是通过git客户端的一些操作。先是检查远程仓库的状态，然后判断本地仓库是否要执行刷新操作。如果有状态更新，比如新的提交时，Git客户端就会执行fetch，然后再进行merge，更新到本地仓库。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>MultipleJGitEnvironmentRepository 多仓库的支持，实际上就是遍历了所有的仓库。其他仓库和单仓库是一样的。</p></blockquote>\n<h2 id=\"客户端实现\"><a href=\"#客户端实现\" class=\"headerlink\" title=\"客户端实现\"></a>客户端实现</h2><p>Spring Cloud Config Client 没有像其他组件一样提供@EnableConfigClient注解，这里没有必要去标注是一个配置客户端，只要引入了spring-cloud-config-client 依赖即可。</p>\n<p>思路也很清楚，就是在启动时从服务端把配置信息拉取到本地，然后设置到 Enviroment 中。Spring Cloud Config中有两种形式，一种是指定 url，另外一种是通过服务发现，默认是通过指定URI的方式。这里还是先从客户端的自动配置来分析。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConfigServiceBootstrapConfiguration</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> ConfigurableEnvironment environment;</span><br><span class=\"line\">  <span class=\"comment\">// 客户端配置属性</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> ConfigClientProperties <span class=\"title function_\">configClientProperties</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">ConfigClientProperties</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConfigClientProperties</span>(<span class=\"built_in\">this</span>.environment);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> client;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从远程服务器上请求对应的配置信息</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"meta\">@ConditionalOnMissingBean(ConfigServicePropertySourceLocator.class)</span></span><br><span class=\"line\">\t<span class=\"meta\">@ConditionalOnProperty(value = &quot;spring.cloud.config.enabled&quot;, matchIfMissing = true)</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> ConfigServicePropertySourceLocator <span class=\"title function_\">configServicePropertySource</span><span class=\"params\">(ConfigClientProperties properties)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">ConfigServicePropertySourceLocator</span> <span class=\"variable\">locator</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConfigServicePropertySourceLocator</span>(</span><br><span class=\"line\">\t\t\t\tproperties);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> locator;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 重试机制</span></span><br><span class=\"line\">\t<span class=\"meta\">@ConditionalOnProperty(value = &quot;spring.cloud.config.fail-fast&quot;)</span></span><br><span class=\"line\">\t<span class=\"meta\">@ConditionalOnClass(&#123; Retryable.class, Aspect.class, AopAutoConfiguration.class &#125;)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Configuration</span></span><br><span class=\"line\">\t<span class=\"meta\">@EnableRetry(proxyTargetClass = true)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Import(AopAutoConfiguration.class)</span></span><br><span class=\"line\">\t<span class=\"meta\">@EnableConfigurationProperties(RetryProperties.class)</span></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RetryConfiguration</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t\t<span class=\"meta\">@ConditionalOnMissingBean(name = &quot;configServerRetryInterceptor&quot;)</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> RetryOperationsInterceptor <span class=\"title function_\">configServerRetryInterceptor</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\tRetryProperties properties)</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> RetryInterceptorBuilder</span><br><span class=\"line\">\t\t\t\t\t.stateless()</span><br><span class=\"line\">\t\t\t\t\t.backOffOptions(properties.getInitialInterval(),</span><br><span class=\"line\">\t\t\t\t\t\t\tproperties.getMultiplier(), properties.getMaxInterval())</span><br><span class=\"line\">\t\t\t\t\t.maxAttempts(properties.getMaxAttempts()).build();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个配置类中初始化了两个bean:</p>\n<ul>\n<li>ConfigClientProperties : 对客户端的属性进行配置。</li>\n<li>ConfigServicePropertySourceLocator：从远程服务器上请求对应的配置信息，然后注册到容器的Enviroment 对象中去。</li>\n</ul>\n<p>ConfigClientProperties 中就是客户端的一些属性，如：profile、应用名、标签、远端服务地址等。没有什么特殊的逻辑。主要来看下 ConfigServicePropertySourceLocator 。</p>\n<h3 id=\"ConfigServicePropertySourceLocator\"><a href=\"#ConfigServicePropertySourceLocator\" class=\"headerlink\" title=\"ConfigServicePropertySourceLocator\"></a>ConfigServicePropertySourceLocator</h3><p>ConfigServicePropertySourceLocator 实现了 PropertySourceLocator 接口，PropertySourceLocator 接口的作用就是用来定位 PropertySource 的。直接看locate方法的实现(删除了无关代码)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@Retryable(interceptor = &quot;configServerRetryInterceptor&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> PropertySource&lt;?&gt; locate(Environment environment) &#123;</span><br><span class=\"line\">    <span class=\"type\">ConfigClientProperties</span> <span class=\"variable\">properties</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.defaultProperties.override(environment);</span><br><span class=\"line\">    <span class=\"type\">CompositePropertySource</span> <span class=\"variable\">composite</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CompositePropertySource</span>(<span class=\"string\">&quot;configService&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 实例化一个 restTemplate，用来调用服务端的 API</span></span><br><span class=\"line\">    <span class=\"type\">RestTemplate</span> <span class=\"variable\">restTemplate</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.restTemplate == <span class=\"literal\">null</span></span><br><span class=\"line\">            ? getSecureRestTemplate(properties)</span><br><span class=\"line\">            : <span class=\"built_in\">this</span>.restTemplate;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// labels ，对对应于profile 如，dev,pre,test这些</span></span><br><span class=\"line\">        String[] labels = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[] &#123; <span class=\"string\">&quot;&quot;</span> &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.hasText(properties.getLabel())) &#123;</span><br><span class=\"line\">            labels = StringUtils.commaDelimitedListToStringArray(properties.getLabel());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">state</span> <span class=\"operator\">=</span> ConfigClientStateHolder.getState();</span><br><span class=\"line\">        <span class=\"comment\">// 遍历所有的标签，循环调用获取远程配置信息</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String label : labels) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// h获取远端环境配置信息</span></span><br><span class=\"line\">            <span class=\"type\">Environment</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> getRemoteEnvironment(restTemplate, properties,</span><br><span class=\"line\">                    label.trim(), state);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (result != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                log(result);</span><br><span class=\"line\">        <span class=\"comment\">// result.getPropertySources() can be null if using xml</span></span><br><span class=\"line\">        <span class=\"comment\">//使用 xml，可能会为 null</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (result.getPropertySources() != <span class=\"literal\">null</span>) &#123; </span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (PropertySource source : result.getPropertySources()) &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">                        Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) source</span><br><span class=\"line\">                                .getSource();</span><br><span class=\"line\">                        composite.addPropertySource(</span><br><span class=\"line\">                                <span class=\"keyword\">new</span> <span class=\"title class_\">MapPropertySource</span>(source.getName(), map));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 设置客户端状态和版本号信息</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (StringUtils.hasText(result.getState())</span><br><span class=\"line\">                        || StringUtils.hasText(result.getVersion())) &#123;</span><br><span class=\"line\">                    HashMap&lt;String, Object&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">                    putValue(map, <span class=\"string\">&quot;config.client.state&quot;</span>, result.getState());</span><br><span class=\"line\">                    putValue(map, <span class=\"string\">&quot;config.client.version&quot;</span>, result.getVersion());</span><br><span class=\"line\">                    composite.addFirstPropertySource(</span><br><span class=\"line\">                            <span class=\"keyword\">new</span> <span class=\"title class_\">MapPropertySource</span>(<span class=\"string\">&quot;configClient&quot;</span>, map));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> composite;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// 如果设置了fial fast ，失败时抛出异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (properties.isFailFast()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码片段中实际从远端获取配置信息是在 getRemoteEnvironment 这个方法中，以Http 请求的方式获取。获取到配置信息之后是放在 CompositePropertySource 对象中，代码较长，逻辑也比较简单，建议直接阅读源码。</p>\n<h3 id=\"注入到-Enviroment-中\"><a href=\"#注入到-Enviroment-中\" class=\"headerlink\" title=\"注入到 Enviroment 中\"></a>注入到 Enviroment 中</h3><p>这部分操作是在 Spring Cloud Context 中的入口来完成的。具体参考<a href=\"2018/12/31/springcloud/spring-cloud-context-analysis/\">bootstrapServiceContext 创建&amp;启动</a> 。</p>\n<p>这里会通过 Spring Cloud Context 中的 PropertySourceBootstrapConfiguration 配置类将PropertySourceLocator 自定义属性值添加到引导上下文的环境当中。</p>\n<h3 id=\"基于服务发现的方式获取配置\"><a href=\"#基于服务发现的方式获取配置\" class=\"headerlink\" title=\"基于服务发现的方式获取配置\"></a>基于服务发现的方式获取配置</h3><p>前面两个小节均是基于指定 http url 的方式获取配置文件的。Spring Cloud Config 中还有一种方式就是基于服务发现的方式。其实这种方式说到底还是基于指定 http url的方式调用，只是通过服务发现找到服务端地址；当然既然有服务的发现与注册，也就会涉及到客户端与服务端之间的会话保证，及时更新可用服务列表这些功能。</p>\n<ul>\n<li>获取服务地址</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retryable(interceptor = &quot;configServerRetryInterceptor&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> List&lt;ServiceInstance&gt; <span class=\"title function_\">getConfigServerInstances</span><span class=\"params\">(String serviceId)</span> &#123;</span><br><span class=\"line\">    logger.debug(<span class=\"string\">&quot;Locating configserver (&quot;</span> + serviceId + <span class=\"string\">&quot;) via discovery&quot;</span>);</span><br><span class=\"line\">    List&lt;ServiceInstance&gt; instances = <span class=\"built_in\">this</span>.client.getInstances(serviceId);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instances.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(</span><br><span class=\"line\">                <span class=\"string\">&quot;No instances found of configserver (&quot;</span> + serviceId + <span class=\"string\">&quot;)&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    logger.debug(<span class=\"string\">&quot;Located configserver (&quot;</span> + serviceId</span><br><span class=\"line\">            + <span class=\"string\">&quot;) via discovery. No of instances found: &quot;</span> + instances.size());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instances;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过 DiscoveryClient 客户端，以指定serviceId的方式拿到服务地址。</p>\n<p>DiscoveryClientConfigServiceBootstrapConfiguration 这个自动配置类实现了 ApplicationListener，用于监听上下文刷新事件；DiscoveryClient 在具体的实现中会将上下文刷新事件进行广播，然后执行刷新操作。心跳里面也是执行的刷新操作。对应的方法是DiscoveryClientConfigServiceBootstrapConfiguration#refresh。也就是 refresh方法会根据上下文环境和心跳事件，刷新服务实例。</p>\n<h2 id=\"以-ZK-作为配置中心\"><a href=\"#以-ZK-作为配置中心\" class=\"headerlink\" title=\"以 ZK 作为配置中心\"></a>以 ZK 作为配置中心</h2><p>《<a href=\"/2018/12/31/springcloud/spring-cloud-config-zookeeper/\">SpringCloud-配置中心 spring-cloud-zk</a>》demo 中介绍了如何使用 zk 作为配置中心。以zk作为配置中心也就是配置信息将从zk中来获取；具体实现也就是实现 PropertySourceLocator 接口，在locate方法中通过zk客户端从zk服务端拉取配置信息。具体实现在ZookeeperPropertySourceLocator#locate中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> PropertySource&lt;?&gt; locate(Environment environment) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (environment <span class=\"keyword\">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略 ...</span></span><br><span class=\"line\">        <span class=\"comment\">// 获取外部配置源</span></span><br><span class=\"line\">        <span class=\"type\">PropertySource</span> <span class=\"variable\">propertySource</span> <span class=\"operator\">=</span> create(propertySourceContext);</span><br><span class=\"line\">    <span class=\"comment\">//省略 ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ..</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其他代码片段都省略了，获取 PropertySource 是在 create 方法中，create 方法返回一个 ZookeeperPropertySource 实例对象。在构造函数中，有通过zk客户端去拉取配置信息，具体逻辑在findProperties 方法中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">findProperties</span><span class=\"params\">(String path, List&lt;String&gt; children)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 省略 ... </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String child : children) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">childPath</span> <span class=\"operator\">=</span> path + <span class=\"string\">&quot;/&quot;</span> + child;</span><br><span class=\"line\">            List&lt;String&gt; childPathChildren = getChildren(childPath);</span><br><span class=\"line\">    <span class=\"comment\">// 获取节点信息</span></span><br><span class=\"line\">            <span class=\"type\">byte</span>[] bytes = getPropertyBytes(childPath);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bytes == <span class=\"literal\">null</span> || bytes.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (childPathChildren == <span class=\"literal\">null</span> || childPathChildren.isEmpty()) &#123;</span><br><span class=\"line\">                    registerKeyValue(childPath, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                registerKeyValue(childPath, <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(bytes, Charset.forName(<span class=\"string\">&quot;UTF-8&quot;</span>)));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 检查子节点，即使我们已经找到当前znode的值</span></span><br><span class=\"line\">            findProperties(childPath, childPathChildren);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception exception) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 省略 ... </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自动刷新机制\"><a href=\"#自动刷新机制\" class=\"headerlink\" title=\"自动刷新机制\"></a>自动刷新机制</h3><p>当修改配置信息之后，通过zk自身的监听机制，通知客户端。这个机制是在ZookeeperConfigAutoConfiguration自动配置类中提供。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnClass(RefreshEndpoint.class)</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZkRefreshConfiguration</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@ConditionalOnProperty(name = &quot;spring.cloud.zookeeper.config.watcher.enabled&quot;, matchIfMissing = true)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ConfigWatcher <span class=\"title function_\">configWatcher</span><span class=\"params\">(ZookeeperPropertySourceLocator locator,</span></span><br><span class=\"line\"><span class=\"params\">            CuratorFramework curator)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConfigWatcher</span>(locator.getContexts(), curator);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ConfigWatcher 实现了 Closeable、TreeCacheListener 和 ApplicationEventPublisherAware 三个接口。Tree Cache 用于观察所有节点的所有数据状态，ApplicationEventPublisherAware用户提供一个publiser，用来发布RefreshEvent 事件。Closeable 用于实现优雅关闭。</p>\n<p>所有当我们改变zk数据节点时，就是触发例如 NODE_ADDED 、NODE_REMOVED、NODE_UPDATED 等事件类型，然后publiser就会发布一个 RefreshEvent 事件，通知客户端进行配置更新操作。从而实现配置的自动刷新。</p>\n","text":"本篇可以配合《SpringCloud-配置中心 Config》来看，《SpringCloud-配置中心 Config》中是基于SOFABoot 来集成 Spri...","permalink":"/post/springcloud/spring-cloud-config-analysis","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"SpringCloud","slug":"SpringCloud","count":14,"path":"api/categories/SpringCloud.json"}],"tags":[{"name":"config","slug":"config","count":6,"path":"api/tags/config.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">服务端实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#EnableConfigServer-%E5%8F%8A%E9%85%8D%E7%BD%AE%E7%B1%BB\"><span class=\"toc-text\">@EnableConfigServer 及配置类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#EnvironmentRepositoryConfiguration\"><span class=\"toc-text\">EnvironmentRepositoryConfiguration</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#MultipleJGitEnvironmentRepository\"><span class=\"toc-text\">MultipleJGitEnvironmentRepository</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#AbstractScmEnvironmentRepository\"><span class=\"toc-text\">AbstractScmEnvironmentRepository</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JGitEnvironmentRepository-refresh\"><span class=\"toc-text\">JGitEnvironmentRepository#refresh</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">客户端实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ConfigServicePropertySourceLocator\"><span class=\"toc-text\">ConfigServicePropertySourceLocator</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E5%85%A5%E5%88%B0-Enviroment-%E4%B8%AD\"><span class=\"toc-text\">注入到 Enviroment 中</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">基于服务发现的方式获取配置</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A5-ZK-%E4%BD%9C%E4%B8%BA%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83\"><span class=\"toc-text\">以 ZK 作为配置中心</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">自动刷新机制</span></a></li></ol></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"SpringCloud-配置中心 Config Zookeeper","uid":"f57e9d19e374649b9c60d012c1470985","slug":"springcloud/spring-cloud-config-zookeeper","date":"2018-12-31T15:11:48.000Z","updated":"2024-07-05T04:09:05.836Z","comments":true,"path":"api/articles/springcloud/spring-cloud-config-zookeeper.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"text":"SpringCloud 除了config自己的client/server 这套配置中心之外，还可以集成使用 zookeeper 。本篇将演示如何使用 sprin...","permalink":"/post/springcloud/spring-cloud-config-zookeeper","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"SpringCloud","slug":"SpringCloud","count":14,"path":"api/categories/SpringCloud.json"}],"tags":[{"name":"zookeeper","slug":"zookeeper","count":3,"path":"api/tags/zookeeper.json"},{"name":"config","slug":"config","count":6,"path":"api/tags/config.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"SpringCloud-配置中心 Config Apollo","uid":"99a0b1d930b4b5c7bd120823c947d06c","slug":"springcloud/spring-cloud-config-apollo","date":"2018-12-31T15:11:23.000Z","updated":"2024-07-05T04:09:05.835Z","comments":true,"path":"api/articles/springcloud/spring-cloud-config-apollo.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"text":"Apollo（阿波罗）是携程框架部门研发的开源配置管理中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程...","permalink":"/post/springcloud/spring-cloud-config-apollo","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"SpringCloud","slug":"SpringCloud","count":14,"path":"api/categories/SpringCloud.json"}],"tags":[{"name":"config","slug":"config","count":6,"path":"api/tags/config.json"},{"name":"apollo","slug":"apollo","count":1,"path":"api/tags/apollo.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}