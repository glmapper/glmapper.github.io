{"title":"聊一聊 Mockito","uid":"9d1ebf7903ce83ad9e7fd07935406bb4","slug":"tests/test-mock-mockito","date":"2021-11-06T03:26:33.000Z","updated":"2024-07-05T04:09:05.845Z","comments":true,"path":"api/articles/tests/test-mock-mockito.json","keywords":null,"cover":[],"content":"<p>Mockito 是 mocking 框架，它让你用简洁的API做测试。而且 Mockito 简单易学，它可读性强和验证语法简洁。</p>\n<span id=\"more\"></span>\n\n<p>从一个最简单的案例看起 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testAnswer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">MockitoAnswerService</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> Mockito.mock(MockitoAnswerService.class);</span><br><span class=\"line\">    Mockito.when(service.getResult(Mockito.anyString(), Mockito.anyList(), Mockito.any(MockitoAnswerParam.class))).then(<span class=\"keyword\">new</span> <span class=\"title class_\">Answer</span>&lt;String&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> String <span class=\"title function_\">answer</span><span class=\"params\">(InvocationOnMock invocation)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">            Object[] arguments = invocation.getArguments();</span><br><span class=\"line\">            <span class=\"comment\">// 3</span></span><br><span class=\"line\">            System.out.println(arguments.length);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;MOCK_ANSWER_RESULT&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> service.getResult(<span class=\"string\">&quot;1&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(), <span class=\"keyword\">new</span> <span class=\"title class_\">MockitoAnswerParam</span>());</span><br><span class=\"line\">    Assert.assertTrue(result.equals(<span class=\"string\">&quot;MOCK_ANSWER_RESULT&quot;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从代码看，主要有这样几个关键行为：</p>\n<ul>\n<li>mock</li>\n<li>when</li>\n<li>then</li>\n<li>answer</li>\n</ul>\n<p>下面将以这几个行为作为分析的着手点。</p>\n<h1 id=\"mock-对象做了哪些事情\"><a href=\"#mock-对象做了哪些事情\" class=\"headerlink\" title=\"mock 对象做了哪些事情\"></a>mock 对象做了哪些事情</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Creates mock object of given class or interface.</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * See examples in javadoc for &#123;<span class=\"doctag\">@link</span> Mockito&#125; class</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> classToMock class or interface to mock</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> mock object</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"meta\">@CheckReturnValue</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; T <span class=\"title function_\">mock</span><span class=\"params\">(Class&lt;T&gt; classToMock)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mock(classToMock, withSettings());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接受一个 class 类型与一个 mockSettings，classToMock 就是我们需要 mock 对象的类型，而mockSettings 则记录着此次 mock 的一些信息。</p>\n<h2 id=\"mock\"><a href=\"#mock\" class=\"headerlink\" title=\"mock\"></a>mock</h2><p>Mockito 内部持有了一个 MockitoCore 对象 <em>MOCKITO_CORE，</em> mock 最后是委托给 <em>MOCKITO_CORE</em> 来处理。</p>\n<p><code>org.mockito.internal.MockitoCore #mock</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public &lt;T&gt; T mock(Class&lt;T&gt; typeToMock, MockSettings settings) &#123;</span><br><span class=\"line\">    if (!MockSettingsImpl.class.isInstance(settings)) &#123;</span><br><span class=\"line\">        throw new IllegalArgumentException(</span><br><span class=\"line\">            &quot;Unexpected implementation of &#x27;&quot;</span><br><span class=\"line\">            + settings.getClass().getCanonicalName()</span><br><span class=\"line\">            + &quot;&#x27;\\n&quot;</span><br><span class=\"line\">            + &quot;At the moment, you cannot provide your own implementations of that class.&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    MockSettingsImpl impl = MockSettingsImpl.class.cast(settings);</span><br><span class=\"line\">    MockCreationSettings&lt;T&gt; creationSettings = impl.build(typeToMock);</span><br><span class=\"line\">    // 创建 mock 对象</span><br><span class=\"line\">    T mock = createMock(creationSettings);</span><br><span class=\"line\">    mockingProgress().mockingStarted(mock, creationSettings);</span><br><span class=\"line\">    return mock;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"mock-对象的产生\"><a href=\"#mock-对象的产生\" class=\"headerlink\" title=\"mock 对象的产生\"></a>mock 对象的产生</h3><p>在MockitoCore中一是做了一下初始化工作，接着继续将 mock 对象创建交给了 MockUtil</p>\n<p>org.mockito.internal.util.MockUtil#createMock</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; T <span class=\"title function_\">createMock</span><span class=\"params\">(MockCreationSettings&lt;T&gt; settings)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MockHandler</span> <span class=\"variable\">mockHandler</span> <span class=\"operator\">=</span> createMockHandler(settings);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">spiedInstance</span> <span class=\"operator\">=</span> settings.getSpiedInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">        T mock;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (spiedInstance != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            mock =</span><br><span class=\"line\">                    mockMaker</span><br><span class=\"line\">                            .createSpy(settings, mockHandler, (T) spiedInstance)</span><br><span class=\"line\">                            .orElseGet(</span><br><span class=\"line\">                                    () -&gt; &#123;</span><br><span class=\"line\">                                        <span class=\"type\">T</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> mockMaker.createMock(settings, mockHandler);</span><br><span class=\"line\">                                        <span class=\"keyword\">new</span> <span class=\"title class_\">LenientCopyTool</span>().copyToMock(spiedInstance, instance);</span><br><span class=\"line\">                                        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">                                    &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mock = mockMaker.createMock(settings, mockHandler);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mock;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 MockUtil 中比较关键的两个处理：</p>\n<ul>\n<li>创建 MockHandler 对象，MockHandler 是一个接口，MockHandler 对象的实例是 InvocationNotifierHandler 类型，它只是负责对外的包装，内部实际起作用的是MockHandlerImpl，这个类承载了 Mockito 的主要逻辑，后面详细说明。</li>\n<li>调用 mockMaker 来创建最终的实例，MockMaker 也是一个接口，其实现为ByteBuddyMockMaker。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ByteBuddyMockMaker</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ClassCreatingMockMaker</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">ClassCreatingMockMaker</span> <span class=\"variable\">defaultByteBuddyMockMaker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SubclassByteBuddyMockMaker</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">createMock</span><span class=\"params\">(MockCreationSettings&lt;T&gt; settings, MockHandler handler)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> defaultByteBuddyMockMaker.createMock(settings, handler);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 省略其他代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，ByteBuddyMockMaker 内部用于创建 mock 对象的是 SubclassByteBuddyMockMaker。具体实现如下（为方便代码阅读，这里将一些无关代码去掉了）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">createMock</span><span class=\"params\">(MockCreationSettings&lt;T&gt; settings, MockHandler handler)</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">T</span>&gt; mockedProxyType = createMockType(settings);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">Instantiator</span> <span class=\"variable\">instantiator</span> <span class=\"operator\">=</span> Plugins.getInstantiatorProvider().getInstantiator(settings);</span><br><span class=\"line\">    <span class=\"type\">T</span> <span class=\"variable\">mockInstance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 实例化</span></span><br><span class=\"line\">        mockInstance = instantiator.newInstance(mockedProxyType);</span><br><span class=\"line\">        <span class=\"type\">MockAccess</span> <span class=\"variable\">mockAccess</span> <span class=\"operator\">=</span> (MockAccess) mockInstance;</span><br><span class=\"line\">        mockAccess.setMockitoInterceptor(<span class=\"keyword\">new</span> <span class=\"title class_\">MockMethodInterceptor</span>(handler, settings));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ensureMockIsAssignableToMockedType(settings, mockInstance);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ClassCastException cce) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ignore code</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (org.mockito.creation.instance.InstantiationException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ignore code</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以比较明确的看到，其创建了一个 mock proxy（在之前的版本是直接创建代理类的），这里通过追踪代码，最终创建的逻辑在 org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator#mockClass。这个方法内部逻辑比较多，但是核心部分就是通过 <a href=\"https://bytebuddy.net/\">https://bytebuddy.net</a> 动态生成一个代理类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ....</span></span><br><span class=\"line\">DynamicType.Builder&lt;T&gt; builder =</span><br><span class=\"line\">                byteBuddy</span><br><span class=\"line\">                        .subclass(features.mockedType)</span><br><span class=\"line\">                        .name(name)</span><br><span class=\"line\">                        .ignoreAlso(isGroovyMethod())</span><br><span class=\"line\">                        .annotateType(</span><br><span class=\"line\">                                features.stripAnnotations</span><br><span class=\"line\">                                        ? <span class=\"keyword\">new</span> <span class=\"title class_\">Annotation</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\">                                        : features.mockedType.getAnnotations())</span><br><span class=\"line\">                        .implement(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Type&gt;(features.interfaces))</span><br><span class=\"line\">                        .method(matcher)</span><br><span class=\"line\">                        .intercept(dispatcher)</span><br><span class=\"line\">                        .transform(withModifiers(SynchronizationState.PLAIN))</span><br><span class=\"line\">                        .attribute(</span><br><span class=\"line\">                                features.stripAnnotations</span><br><span class=\"line\">                                        ? MethodAttributeAppender.NoOp.INSTANCE</span><br><span class=\"line\">                                        : INCLUDING_RECEIVER)</span><br><span class=\"line\">                        .method(isHashCode())</span><br><span class=\"line\">                        .intercept(hashCode)</span><br><span class=\"line\">                        .method(isEquals())</span><br><span class=\"line\">                        .intercept(equals)</span><br><span class=\"line\">                        .serialVersionUid(<span class=\"number\">42L</span>)</span><br><span class=\"line\">                        .defineField(<span class=\"string\">&quot;mockitoInterceptor&quot;</span>, MockMethodInterceptor.class, PRIVATE)</span><br><span class=\"line\">                        .implement(MockAccess.class)</span><br><span class=\"line\">                        .intercept(FieldAccessor.ofBeanProperty());</span><br><span class=\"line\"><span class=\"comment\">//....</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> builder.make()</span><br><span class=\"line\">                .load(</span><br><span class=\"line\">                        classLoader,</span><br><span class=\"line\">                        loader.resolveStrategy(features.mockedType, classLoader, localMock))</span><br><span class=\"line\">                .getLoaded();</span><br></pre></td></tr></table></figure>\n\n<p>这里其实是 bytebuddy 动态生成类的基本动作，但是毕竟只是代码，下面是我将当前创建的 mockedProxyType 字节码写到 .class 文件得到的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class=\"line\"><span class=\"comment\">// (powered by FernFlower decompiler)</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.example.testproperties;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.testproperties.MockitoAnswerService.MockitoMock<span class=\"number\">.1791756687</span>.auxiliary.UFw2zv6r;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.testproperties.MockitoAnswerService.MockitoMock<span class=\"number\">.1791756687</span>.auxiliary.oa15uI8r;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.testproperties.MockitoAnswerService.MockitoMock<span class=\"number\">.1791756687</span>.auxiliary.vbeEWzX6;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.mockito.internal.creation.bytebuddy.MockAccess;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.mockito.internal.creation.bytebuddy.MockMethodInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.DispatcherDefaultingToRealMethod;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.ForEquals;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.ForHashCode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MockitoAnswerService$MockitoMock$1791756687</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">MockitoAnswerService</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MockAccess</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">serialVersionUID</span> <span class=\"operator\">=</span> <span class=\"number\">42L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MockMethodInterceptor mockitoInterceptor;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object var1)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ForEquals.doIdentityEquals(<span class=\"built_in\">this</span>, var1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (String)DispatcherDefaultingToRealMethod.interceptSuperCallable(<span class=\"built_in\">this</span>, <span class=\"built_in\">this</span>.mockitoInterceptor, cachedValue$oKHFaZjn$4cscpe1, <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[<span class=\"number\">0</span>], <span class=\"keyword\">new</span> <span class=\"title class_\">UFw2zv6r</span>(<span class=\"built_in\">this</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ForHashCode.doIdentityHashCode(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Object <span class=\"title function_\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> DispatcherDefaultingToRealMethod.interceptSuperCallable(<span class=\"built_in\">this</span>, <span class=\"built_in\">this</span>.mockitoInterceptor, cachedValue$oKHFaZjn$7m9oaq0, <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[<span class=\"number\">0</span>], <span class=\"keyword\">new</span> <span class=\"title class_\">oa15uI8r</span>(<span class=\"built_in\">this</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getResult</span><span class=\"params\">(String arg1, List&lt;Object&gt; arg2, MockitoAnswerParam arg3)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (String)DispatcherDefaultingToRealMethod.interceptSuperCallable(<span class=\"built_in\">this</span>, <span class=\"built_in\">this</span>.mockitoInterceptor, cachedValue$oKHFaZjn$rr3ccu3, <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[]&#123;var1, var2, var3&#125;, <span class=\"keyword\">new</span> <span class=\"title class_\">vbeEWzX6</span>(<span class=\"built_in\">this</span>, var1, var2, var3));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> MockMethodInterceptor <span class=\"title function_\">getMockitoInterceptor</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.mockitoInterceptor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setMockitoInterceptor</span><span class=\"params\">(MockMethodInterceptor var1)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.mockitoInterceptor = var1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> MockitoAnswerService$MockitoMock$<span class=\"number\">1791756687</span>() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以比较直观的看到，getResult 方法被插了拦截器，且当前类是作为目标被测试类的子类。来看下 DispatcherDefaultingToRealMethod#interceptSuperCallable 方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RuntimeType</span><br><span class=\"line\">@BindingPriority(BindingPriority.DEFAULT * 2)</span><br><span class=\"line\">public static Object interceptSuperCallable(</span><br><span class=\"line\">    @This Object mock,</span><br><span class=\"line\">    @FieldValue(&quot;mockitoInterceptor&quot;) MockMethodInterceptor interceptor,</span><br><span class=\"line\">    @Origin Method invokedMethod,</span><br><span class=\"line\">    @AllArguments Object[] arguments,</span><br><span class=\"line\">    @SuperCall(serializableProxy = true) Callable&lt;?&gt; superCall)</span><br><span class=\"line\">    throws Throwable &#123;</span><br><span class=\"line\">    if (interceptor == null) &#123;</span><br><span class=\"line\">        return superCall.call();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return interceptor.doIntercept(</span><br><span class=\"line\">        mock, invokedMethod, arguments, new RealMethod.FromCallable(superCall));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按照参数来看，cachedValue$oKHFaZjn$rr3ccu3 这坨东西居然是原始方法…。在前面那个代码中也提到，这里 interceptor 是类型为 MockMethodInterceptor 的实例，在创建字节码时就有体现这一点。所以在方法调用上，会走 doIntercept 的逻辑。</p>\n<h3 id=\"mock-方法的执行\"><a href=\"#mock-方法的执行\" class=\"headerlink\" title=\"mock 方法的执行\"></a>mock 方法的执行</h3><p>上面提到，mock 本质上时通过 byteBuddy 创建了一个被 mock 类的子类，并且未被 mock 类方法插上了拦截器。所以我们基本就可以猜测到，mock 方法的实际执行，会被 mock 对象包装过的方法及拦截器 hook 掉，从而走到预设的逻辑。下面具体分析。（下面是通过执行堆栈追踪到的具体执行逻辑,<code>org.mockito.internal.creation.bytebuddy.MockMethodInterceptor#doIntercept</code>）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object <span class=\"title function_\">doIntercept</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">            Object mock,</span></span><br><span class=\"line\"><span class=\"params\">            Method invokedMethod,</span></span><br><span class=\"line\"><span class=\"params\">            Object[] arguments,</span></span><br><span class=\"line\"><span class=\"params\">            RealMethod realMethod,</span></span><br><span class=\"line\"><span class=\"params\">            Location location)</span></span><br><span class=\"line\">            <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If the currently dispatched method is used in a hot path, typically a tight loop and if</span></span><br><span class=\"line\">        <span class=\"comment\">// the mock is not used after the currently dispatched method, the JVM might attempt a</span></span><br><span class=\"line\">        <span class=\"comment\">// garbage collection of the mock instance even before the execution of the current</span></span><br><span class=\"line\">        <span class=\"comment\">// method is completed. Since we only reference the mock weakly from hereon after to avoid</span></span><br><span class=\"line\">        <span class=\"comment\">// leaking the instance, it might therefore be garbage collected before the</span></span><br><span class=\"line\">        <span class=\"comment\">// handler.handle(...) method completes. Since the handler method expects the mock to be</span></span><br><span class=\"line\">        <span class=\"comment\">// present while a method call onto the mock is dispatched, this can lead to the problem</span></span><br><span class=\"line\">        <span class=\"comment\">// described in GitHub #1802.</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"comment\">// To avoid this problem, we distract the JVM JIT by escaping the mock instance to a thread</span></span><br><span class=\"line\">        <span class=\"comment\">// local field for the duration of the handler&#x27;s dispatch.</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"comment\">// When dropping support for Java 8, instead of this hatch we should use an explicit fence</span></span><br><span class=\"line\">        <span class=\"comment\">// https://docs.oracle.com/javase/9/docs/api/java/lang/ref/Reference.html#reachabilityFence-java.lang.Object-</span></span><br><span class=\"line\">        weakReferenceHatch.set(mock);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> handler.handle(</span><br><span class=\"line\">                    createInvocation(</span><br><span class=\"line\">                            mock,</span><br><span class=\"line\">                            invokedMethod,</span><br><span class=\"line\">                            arguments,</span><br><span class=\"line\">                            realMethod,</span><br><span class=\"line\">                            mockCreationSettings,</span><br><span class=\"line\">                            location));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            weakReferenceHatch.remove();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里在内部，有包装了一层，将原始方法及mock 对象参数等，放到了 <code>org.mockito.internal.invocation.InterceptedInvocation</code> 这个类中。这种做法还是比较常见的，使得所有的模型按照组件内部封装的模型进行转换和执行，在组件内部形成语义上的闭环。weakReferenceHatch 是一个 ThreadLocal 变量，这里就是将 mock 对象放在 ThreadLocal 中，已便于后面基于当前线程上下文的所有动作都可以共享这个 mock 对象。那最核心的执行部分就是 handler#handle(Invocation invocation)。</p>\n<p>这里的 Hander 是 MockHandler，Mockito 内部实现此接口的有三个，实际使用最多的是 MockHandlerImpl 实现方式，这里以 MockHandlerImpl 的 handle 为例。下面是代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">handle</span><span class=\"params\">(Invocation invocation)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">    <span class=\"comment\">// doAnswer 时会执行</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (invocationContainer.hasAnswersForStubbing()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// stubbing voids with doThrow() or doAnswer() style</span></span><br><span class=\"line\">            <span class=\"type\">InvocationMatcher</span> <span class=\"variable\">invocationMatcher</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                    matchersBinder.bindMatchers(</span><br><span class=\"line\">                            mockingProgress().getArgumentMatcherStorage(), invocation);</span><br><span class=\"line\">            invocationContainer.setMethodForStubbing(invocationMatcher);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"comment\">// VerificationMode 是对验证信息的封装,它是一个接口,含有 verify 函数, 例如常用的 never,times 返回的都是 Times 类型,而 Times 类型就是 VerificationMode 的一种实现。 然后,调用 mockingProgress 来缓存 mode 信息。</span></span><br><span class=\"line\">        <span class=\"type\">VerificationMode</span> <span class=\"variable\">verificationMode</span> <span class=\"operator\">=</span> mockingProgress().pullVerificationMode();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 用来匹配 when 条件</span></span><br><span class=\"line\">        <span class=\"type\">InvocationMatcher</span> <span class=\"variable\">invocationMatcher</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                matchersBinder.bindMatchers(</span><br><span class=\"line\">                        mockingProgress().getArgumentMatcherStorage(), invocation);</span><br><span class=\"line\"></span><br><span class=\"line\">        mockingProgress().validateState();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// if verificationMode is not null then someone is doing verify()</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (verificationMode != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// We need to check if verification was started on the correct mock</span></span><br><span class=\"line\">            <span class=\"comment\">// - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) &#123;</span><br><span class=\"line\">                <span class=\"type\">VerificationDataImpl</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                        <span class=\"keyword\">new</span> <span class=\"title class_\">VerificationDataImpl</span>(invocationContainer, invocationMatcher);</span><br><span class=\"line\">                verificationMode.verify(data);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// this means there is an invocation on a different mock. Re-adding verification</span></span><br><span class=\"line\">                <span class=\"comment\">// mode</span></span><br><span class=\"line\">                <span class=\"comment\">// - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)</span></span><br><span class=\"line\">                mockingProgress().verificationStarted(verificationMode);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 准备 stubbing 调用</span></span><br><span class=\"line\">        invocationContainer.setInvocationForPotentialStubbing(invocationMatcher);</span><br><span class=\"line\">        OngoingStubbingImpl&lt;T&gt; ongoingStubbing = <span class=\"keyword\">new</span> <span class=\"title class_\">OngoingStubbingImpl</span>&lt;T&gt;(invocationContainer);</span><br><span class=\"line\">        mockingProgress().reportOngoingStubbing(ongoingStubbing);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 寻找此 invocation 是否有 answer</span></span><br><span class=\"line\">        <span class=\"type\">StubbedInvocationMatcher</span> <span class=\"variable\">stubbing</span> <span class=\"operator\">=</span> invocationContainer.findAnswerFor(invocation);</span><br><span class=\"line\">        <span class=\"comment\">// TODO #793 - when completed, we should be able to get rid of the casting below</span></span><br><span class=\"line\">        notifyStubbedAnswerLookup(</span><br><span class=\"line\">                invocation,</span><br><span class=\"line\">                stubbing,</span><br><span class=\"line\">                invocationContainer.getStubbingsAscending(),</span><br><span class=\"line\">                (CreationSettings) mockSettings);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果有 answer 则进行 answer 的回调，上面的 例子中有，所以 case 执行会走到这里</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stubbing != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            stubbing.captureArgumentsFrom(invocation);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> stubbing.answer(invocation);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Needed so that we correctly isolate stubbings in some scenarios</span></span><br><span class=\"line\">                <span class=\"comment\">// see MockitoStubbedCallInAnswerTest or issue #1279</span></span><br><span class=\"line\">                mockingProgress().reportOngoingStubbing(ongoingStubbing);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> mockSettings.getDefaultAnswer().answer(invocation);</span><br><span class=\"line\">            DefaultAnswerValidator.validateReturnValueFor(invocation, ret);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Mockito uses it to redo setting invocation for potential stubbing in case of partial</span></span><br><span class=\"line\">            <span class=\"comment\">// mocks / spies.</span></span><br><span class=\"line\">            <span class=\"comment\">// Without it, the real method inside &#x27;when&#x27; might have delegated to other self method</span></span><br><span class=\"line\">            <span class=\"comment\">// and overwrite the intended stubbed method with a different one.</span></span><br><span class=\"line\">            <span class=\"comment\">// This means we would be stubbing a wrong method.</span></span><br><span class=\"line\">            <span class=\"comment\">// Typically this would led to runtime exception that validates return type with stubbed</span></span><br><span class=\"line\">            <span class=\"comment\">// method signature.</span></span><br><span class=\"line\">            invocationContainer.resetInvocationForPotentialStubbing(invocationMatcher);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里说明以下，handle 方法在 when 中会被执行一次，再后面实际调用时还会执行一次，所以一次 when(method) 到实际 mock 调用，会执行两次。这里最开始在 debug 时，每次第一次走到都没符合预期返回 then 的值，后面通过分析堆栈发展调用入口时 when 中 mock 发起，并非时后面实际测试调用发起，才解释了这个没有预期返回结果的情况。</p>\n<p>这里补充下 InvocationMatcher 的 runtime 信息</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f01c1cc1b5c04f128854f26ec5dcac91~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<h2 id=\"MockHandler\"><a href=\"#MockHandler\" class=\"headerlink\" title=\"MockHandler\"></a>MockHandler</h2><p>mockito 会为每个创建的 mock 对象创建一个 MockHandler, 它的实现类是 MockHandlerImpl。该对象主要用于处理 mock 对象的每个被拦截方法。执行每个拦截方法的时候，都会交给这个 handler 处理。</p>\n<h2 id=\"MockingProgress\"><a href=\"#MockingProgress\" class=\"headerlink\" title=\"MockingProgress\"></a>MockingProgress</h2><p>用来存放正在 mock 中的数据，如 OngoingStubbingImpl、argumentMatcherStorage、verificationMode 等。MockingProgress 的实现类是 MockingProgressImpl 。从 MockHandlerImpl#handle 的代码中可以看到，在整个执行逻辑中会平凡的出现 mockingProgress() ，mockingProgress() 是 ThreadSafeMockingProgress 中提供的静态方法，ThreadSafeMockingProgress 为不用线程分配了不同的 MockingProgress ，采用了 ThreadLocal 方式实现，保证了线程安全。</p>\n<h2 id=\"OngoingStubbingImpl\"><a href=\"#OngoingStubbingImpl\" class=\"headerlink\" title=\"OngoingStubbingImpl\"></a>OngoingStubbingImpl</h2><p>mock 方法的一个包装。会为每个 mock 对象的方法创建一个 OngoingStubbingImpl，用来监控和模拟该方法行为。如上面service.getResult(Mockito.<em>anyString</em>(), Mockito.<em>anyList</em>(), Mockito.<em>any</em>(MockitoAnswerParam.class)) 行为。一个 mock 方法对应多个 OngoingStubbingImpl，因为每调用一次 mock 方法都会创建一个 OngoingStubbingImpl 对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//see MockHandlerImpl#handle</span></span><br><span class=\"line\"></span><br><span class=\"line\">invocationContainer.setInvocationForPotentialStubbing(invocationMatcher);</span><br><span class=\"line\"><span class=\"comment\">// 这里是对上述描述的代码解释</span></span><br><span class=\"line\">OngoingStubbingImpl&lt;T&gt; ongoingStubbing = <span class=\"keyword\">new</span> <span class=\"title class_\">OngoingStubbingImpl</span>&lt;T&gt;(invocationContainer);</span><br><span class=\"line\">mockingProgress().reportOngoingStubbing(ongoingStubbing);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"mockSettings\"><a href=\"#mockSettings\" class=\"headerlink\" title=\"mockSettings\"></a>mockSettings</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>MockSettings has been introduced for two reasons. Firstly, to make it easy to add another mock setting when the demand comes. Secondly, to enable combining together different mock settings without introducing zillions of overloaded mock() methods.</p></blockquote>\n<p>引入 MockSettings 有两个原因。 首先，当有需求时，可以很容易地添加另一个模拟设置。 其次，在不引入无数重载的 mock() 方法的情况下，将不同的模拟设置组合在一起。</p>\n<p>怎么理解这个 mockSettings ？举个例子：</p>\n<p>创建具有不同 defaultAnswer 和 name 的 mock</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Foo</span> <span class=\"variable\">mock</span> <span class=\"operator\">=</span> mock(Foo.class, withSettings()</span><br><span class=\"line\">                                  .defaultAnswer(RETURNS_SMART_NULLS)</span><br><span class=\"line\">                                  .name(<span class=\"string\">&quot;cool mockie&quot;</span>)</span><br><span class=\"line\">                                  );</span><br></pre></td></tr></table></figure>\n\n<p>创建具有不同 defaultAnswer name 和 extraInterfaces 的 mock</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo mock = mock(Foo.class, withSettings()</span><br><span class=\"line\">                                  .defaultAnswer(RETURNS_SMART_NULLS)</span><br><span class=\"line\">                                  .name(&quot;cool mockie&quot;)</span><br><span class=\"line\">                                  .extraInterfaces(Bar.class));</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"什么是-extraInterfaces\"><a href=\"#什么是-extraInterfaces\" class=\"headerlink\" title=\"什么是 extraInterfaces\"></a>什么是 extraInterfaces</h3><p>指定 mock 应该实现的额外接口，可能对遗留代码或某些极端情况有用。这个神秘的功能应该偶尔使用。被测对象应该确切地知道它的合作者和依赖关系。 如果实际场景碰巧有经常这样使用它的，那往往说明你的代码可能不具备简单、干净和可读的特性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Foo</span> <span class=\"variable\">foo</span> <span class=\"operator\">=</span> mock(Foo.class, withSettings().extraInterfaces(Bar.class, Baz.class));</span><br></pre></td></tr></table></figure>\n\n<p>现在，mock 实现了额外的接口，因此可以进行以下转换：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Bar</span> <span class=\"variable\">bar</span> <span class=\"operator\">=</span> (Bar) foo;</span><br><span class=\"line\"><span class=\"type\">Baz</span> <span class=\"variable\">baz</span> <span class=\"operator\">=</span> (Baz) foo;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"什么的-name\"><a href=\"#什么的-name\" class=\"headerlink\" title=\"什么的 name\"></a>什么的 name</h3><p>当前 mock 对象的名字，没有什么实际的用处，即使 name 相同，也是不同的两个 mock 对象（可通过 hashCode 判断得出）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Foo</span> <span class=\"variable\">foo</span> <span class=\"operator\">=</span> mock(Foo.class, withSettings().name(<span class=\"string\">&quot;foo&quot;</span>));</span><br><span class=\"line\"><span class=\"type\">Foo</span> <span class=\"variable\">foo</span> <span class=\"operator\">=</span> mock(Foo.class, <span class=\"string\">&quot;foo&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>@Mock 注解 的 name 默认是 filedName 。</p>\n<h3 id=\"什么是-defaultAnswer\"><a href=\"#什么是-defaultAnswer\" class=\"headerlink\" title=\"什么是 defaultAnswer\"></a>什么是 defaultAnswer</h3><p>对 mock 对象的方法进行调用预期的设定，可以通过 thenReturn() 来指定返回值，thenThrow() 指定返回时所抛异常，通常来说这两个方法足以应对一般的需求。但有时我们需要自定义方法执行的返回结果，Answer 接口就是满足这样的需求而存在的，它可以用来处理那些 mock 对象没有 stubbing 的方法的返回值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testAnswer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">MockitoAnswerService</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> Mockito.mock(MockitoAnswerService.class);</span><br><span class=\"line\">    Mockito.when(service.getResult(Mockito.anyString(), Mockito.anyList(), Mockito.any(MockitoAnswerParam.class))).then(<span class=\"keyword\">new</span> <span class=\"title class_\">Answer</span>&lt;String&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> String <span class=\"title function_\">answer</span><span class=\"params\">(InvocationOnMock invocation)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">            Object[] arguments = invocation.getArguments();</span><br><span class=\"line\">            <span class=\"comment\">// 3</span></span><br><span class=\"line\">            System.out.println(arguments.length);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;MOCK_ANSWER_RESULT&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> service.getResult(<span class=\"string\">&quot;1&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(), <span class=\"keyword\">new</span> <span class=\"title class_\">MockitoAnswerParam</span>());</span><br><span class=\"line\">    Assert.assertTrue(result.equals(<span class=\"string\">&quot;MOCK_ANSWER_RESULT&quot;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有一些如 stubbingLookupListeners 等这里不做过多说明，详细可参考官方文档。</p>\n","text":"Mockito 是 mocking 框架，它让你用简洁的API做测试。而且 Mockito 简单易学，它可读性强和验证语法简洁。 从一个最简单的案例看起 123...","permalink":"/post/tests/test-mock-mockito","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"test","slug":"test","count":5,"path":"api/categories/test.json"}],"tags":[{"name":"test","slug":"test","count":5,"path":"api/tags/test.json"},{"name":"mock","slug":"mock","count":1,"path":"api/tags/mock.json"},{"name":"Mockito","slug":"Mockito","count":1,"path":"api/tags/Mockito.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#mock-%E5%AF%B9%E8%B1%A1%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85\"><span class=\"toc-text\">mock 对象做了哪些事情</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#mock\"><span class=\"toc-text\">mock</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#mock-%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%A7%E7%94%9F\"><span class=\"toc-text\">mock 对象的产生</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#mock-%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">mock 方法的执行</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MockHandler\"><span class=\"toc-text\">MockHandler</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MockingProgress\"><span class=\"toc-text\">MockingProgress</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#OngoingStubbingImpl\"><span class=\"toc-text\">OngoingStubbingImpl</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#mockSettings\"><span class=\"toc-text\">mockSettings</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-extraInterfaces\"><span class=\"toc-text\">什么是 extraInterfaces</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E7%9A%84-name\"><span class=\"toc-text\">什么的 name</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-defaultAnswer\"><span class=\"toc-text\">什么是 defaultAnswer</span></a></li></ol></li></ol></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"mysql 日志文件","uid":"b98b36bd5e2d6f53b8f282c8597b8e9d","slug":"middleware/middleware-mysql-log-file","date":"2021-11-08T03:30:18.000Z","updated":"2024-07-05T04:09:05.789Z","comments":true,"path":"api/articles/middleware/middleware-mysql-log-file.json","keywords":null,"cover":null,"text":"日志文件记录了影响 mysql 数据库的各种类型活动，mysql 中常见的日志文件主要包括以下 4 种： 错误日志 二进制日志 慢查询日志 查询日志 这些日志文...","permalink":"/post/middleware/middleware-mysql-log-file","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"Middleware","slug":"Middleware","count":13,"path":"api/categories/Middleware.json"}],"tags":[{"name":"mysql","slug":"mysql","count":4,"path":"api/tags/mysql.json"},{"name":"log","slug":"log","count":5,"path":"api/tags/log.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"JVM-Java 对象模型","uid":"29ce492a4d6518491078a1705c4387c8","slug":"jvm/jvm-openjdk-oop-klass","date":"2021-11-05T03:23:39.000Z","updated":"2024-07-05T04:09:05.769Z","comments":true,"path":"api/articles/jvm/jvm-openjdk-oop-klass.json","keywords":null,"cover":[],"text":"Java对象保存在堆内存中。在内存中，一个Java对象包含三部分：对象头、实例数据和对齐填充。其中对象头是一个很关键的部分，因为对象头中包含锁状态标志、线程持有...","permalink":"/post/jvm/jvm-openjdk-oop-klass","photos":[],"count_time":{"symbolsCount":"7.5k","symbolsTime":"7 mins."},"categories":[{"name":"jvm","slug":"jvm","count":6,"path":"api/categories/jvm.json"}],"tags":[{"name":"jvm","slug":"jvm","count":6,"path":"api/tags/jvm.json"},{"name":"oop-klass","slug":"oop-klass","count":1,"path":"api/tags/oop-klass.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}