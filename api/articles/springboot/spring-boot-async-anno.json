{"title":"你知道 @Async 是怎么让方法异步执行的吗？","uid":"3784314f76c771adae1123b249748729","slug":"springboot/spring-boot-async-anno","date":"2022-09-12T01:05:44.000Z","updated":"2024-07-05T04:09:05.826Z","comments":true,"path":"api/articles/springboot/spring-boot-async-anno.json","keywords":null,"cover":null,"content":"<p>在阅读本文之前，你可以通过 <a href=\"https://spring.io/guides/gs/async-method/\">Creating Asynchronous Methods</a> 指导来体验下创建异步方法的使用方式。</p>\n<p>为什么要写这篇文章，本质上对于这些 Spring 已经封装好的能力，并不需要去关注它底层到底是怎么玩的，比如 <code>@Async</code>，你肯定可以猜到对于打了这个注解的方法（或者类），在执行这个方法（或者类下所有方法）时，Spring 框架会将当前方法丢进到一个单独的线程池中去执行，以达到方法异步执行的目的。</p>\n<span id=\"more\"></span>\n\n<p>本篇文章的原始诉求来自于需要对 <code>@Async</code> 描述的方法进行 trace 埋点，当前大多数基于线程上下文传递 traceContext 的方式显然对于跨线程问题是不能满足的，需要特殊的处理；那么就需要对这些技术点进行剖析，以寻求切入点。</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><code>@Async</code> 是通过注解标记来开启方法的异步执行的；对于注解的底层实现，除了 java 原生提供那种依赖编译期植入的之外，其他的基本都差不多，即运行时通过反射等方式拦截到打了注解的类或者方法，然后执行时进行横切拦截；另外这里还有一个点就是方法异步执行，所以对于 <code>@Async</code> 的剖析，就一定绕不开两个基本的知识点，就是代理和线程池。<br>在了解到这些之后，我们来拆解下 <code>@Async</code> 的基本原理。</p>\n<h2 id=\"如何开启生效？\"><a href=\"#如何开启生效？\" class=\"headerlink\" title=\"如何开启生效？\"></a>如何开启生效？</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>The <code>@EnableAsync</code> annotation switches on Spring’s ability to run <code>@Async</code> methods in a background thread pool.</p></blockquote>\n<p>通过 @EnableAsync 来开启异步方法的能力。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Import(AsyncConfigurationSelector.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableAsync &#123;</span><br><span class=\"line\"><span class=\"comment\">// ...`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>@EnableAsync</code> 注解 Import 了 <code>AsyncConfigurationSelector</code>，这个在 SpringBoot 中是非常常见的一种写法，这里需要关注的是选择了哪个自动配置类；adviceMode 默认是 false，这里就以 ProxyAsyncConfiguration 为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@Nullable</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (adviceMode) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> PROXY:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[] &#123;ProxyAsyncConfiguration.class.getName()&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> ASPECTJ:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[] &#123;ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"AsyncAnnotationBeanPostProcessor\"><a href=\"#AsyncAnnotationBeanPostProcessor\" class=\"headerlink\" title=\"AsyncAnnotationBeanPostProcessor\"></a>AsyncAnnotationBeanPostProcessor</h3><p>在 <code>org.springframework.scheduling.annotation.ProxyAsyncConfiguration</code>中最主要的就是创建 AsyncAnnotationBeanPostProcessor，从名字看，AsyncAnnotationBeanPostProcessor 就是来处理 <code>@Async</code> 注解的；目的很明确，就是创建对应 bean 的代理对象，以便于执行方法时能够进行 AOP 拦截（具体细节可以看 <code>org.springframework.aop.framework.AbstractAdvisingBeanPostProcessor#postProcessAfterInitialization</code>这个方法）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ProxyFactory</span> <span class=\"variable\">proxyFactory</span> <span class=\"operator\">=</span> prepareProxyFactory(bean, beanName);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class=\"line\">   evaluateProxyInterfaces(bean.getClass(), proxyFactory);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">proxyFactory.addAdvisor(<span class=\"built_in\">this</span>.advisor);</span><br><span class=\"line\">customizeProxyFactory(proxyFactory);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"AnnotationAsyncExecutionInterceptor\"><a href=\"#AnnotationAsyncExecutionInterceptor\" class=\"headerlink\" title=\"AnnotationAsyncExecutionInterceptor\"></a>AnnotationAsyncExecutionInterceptor</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里涉及到 AOP 的一些基础知识，可以查阅之前写的 <a href=\"https://juejin.cn/post/6844903623101513735\">https://juejin.cn/post/6844903623101513735</a> 这篇文章</p></blockquote>\n<p>AOP 中最外层的是代理类，然后是织入器(advisor)，再接着是切面（advice he PointCut）；前面已经将创建代理对象的逻辑进行了介绍，所以接下来是织入器(advisor)和切面的创建。实际上织入器(advisor)的创建逻辑也是在 AsyncAnnotationBeanPostProcessor 中完成的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setBeanFactory</span><span class=\"params\">(BeanFactory beanFactory)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>.setBeanFactory(beanFactory);</span><br><span class=\"line\">\t<span class=\"comment\">// 创建  advisor</span></span><br><span class=\"line\">    <span class=\"type\">AsyncAnnotationAdvisor</span> <span class=\"variable\">advisor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AsyncAnnotationAdvisor</span>(<span class=\"built_in\">this</span>.executor, <span class=\"built_in\">this</span>.exceptionHandler);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.asyncAnnotationType != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        advisor.setAsyncAnnotationType(<span class=\"built_in\">this</span>.asyncAnnotationType);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    advisor.setBeanFactory(beanFactory);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.advisor = advisor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 AsyncAnnotationAdvisor 的构造函数中，会构建 Advice 和 Pointcut</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public AsyncAnnotationAdvisor(</span><br><span class=\"line\">        @Nullable Supplier&lt;Executor&gt; executor, @Nullable Supplier&lt;AsyncUncaughtExceptionHandler&gt; exceptionHandler) &#123;</span><br><span class=\"line\">\t// 省略其他代码</span><br><span class=\"line\">\t/// ...</span><br><span class=\"line\">    // 创建 advice</span><br><span class=\"line\">    this.advice = buildAdvice(executor, exceptionHandler);</span><br><span class=\"line\">    // 创建 pointcut</span><br><span class=\"line\">    this.pointcut = buildPointcut(asyncAnnotationTypes);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Advice 就是具体执行拦截的逻辑，这里的 advice 实际上 <code>AnnotationAsyncExecutionInterceptor</code>(why ? 因饰Advice 是 MethodInterceptor 的父类)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Advice <span class=\"title function_\">buildAdvice</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"meta\">@Nullable</span> Supplier&lt;Executor&gt; executor, <span class=\"meta\">@Nullable</span> Supplier&lt;AsyncUncaughtExceptionHandler&gt; exceptionHandler)</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 这里</span></span><br><span class=\"line\">    <span class=\"type\">AnnotationAsyncExecutionInterceptor</span> <span class=\"variable\">interceptor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AnnotationAsyncExecutionInterceptor</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\">    interceptor.configure(executor, exceptionHandler);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> interceptor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到这里，关于 <code>@EnableAsync</code> 是如何开启创建异步方法的逻辑基本就介绍完了；本质上还是 Spring AOP 的那套逻辑。</p>\n<h3 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h3><p>除了 adviceMode，一般情况下还会涉及到另外一个参数，即 proxyTargetClass；proxyTargetClass 在设置为 true 和 false 时，对应使用的代理机制大致如下：</p>\n<ul>\n<li><p>true</p>\n<ul>\n<li>目标对象实现了接口 – 使用 CGLIB 代理机制</li>\n<li>目标对象没有接口(只有实现类) – 使用 CGLIB 代理机制</li>\n</ul>\n</li>\n<li><p>false</p>\n<ul>\n<li>目标对象实现了接口 – 使用 JDK 动态代理机制(代理所有实现了的接口)</li>\n<li>目标对象没有接口(只有实现类) – 使用 CGLIB 代理机制</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>上一小节中，对 <code>@EnableAsync</code> 生效机制和对应的 AOP 对象创建逻辑进行了介绍；实际上 AOP 拦截到具体的方法之后的主要目的就是将执行逻辑丢到线程池中去执行。那这里就会涉及到本节的主题，即线程池。本节需要搞清楚几个问题：</p>\n<ul>\n<li>什么时候创建的线程池?</li>\n<li>创建的线程池类型是啥?</li>\n<li>方法执行任务是如何被提交的?</li>\n</ul>\n<h3 id=\"创建-AnnotationAsyncExecutionInterceptor-时初始化线程池\"><a href=\"#创建-AnnotationAsyncExecutionInterceptor-时初始化线程池\" class=\"headerlink\" title=\"创建 AnnotationAsyncExecutionInterceptor 时初始化线程池\"></a>创建 AnnotationAsyncExecutionInterceptor 时初始化线程池</h3><p>线程池的创建是在创建 AnnotationAsyncExecutionInterceptor 对象时完成，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">AnnotationAsyncExecutionInterceptor</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Executor defaultExecutor)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(defaultExecutor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在其父类 AsyncExecutionAspectSupport 中完成具体线程池创建</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.defaultExecutor = <span class=\"keyword\">new</span> <span class=\"title class_\">SingletonSupplier</span>&lt;&gt;(defaultExecutor, () -&gt; getDefaultExecutor(<span class=\"built_in\">this</span>.beanFactory));</span><br></pre></td></tr></table></figure>\n\n<p>在 getDefaultExecutor 方法中， 会先从 Spring 容器找 TaskExecutor 类型的线程池 Bean，如果找不到，会扩大范围找 Executor 类型的线程池 Bean，如果找不到，则返回 null。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里是个延迟载入的操作，即只有当异步方法被调用时，才会触发 SingletonSupplier get 操作，从而触发 getBean 的逻辑，如果你在 debug 时出现没有正常走到断点的情况，可以关注下这个场景。</p></blockquote>\n<h3 id=\"默认线程池-SimpleAsyncTaskExecutor\"><a href=\"#默认线程池-SimpleAsyncTaskExecutor\" class=\"headerlink\" title=\"默认线程池 SimpleAsyncTaskExecutor\"></a>默认线程池 SimpleAsyncTaskExecutor</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@Nullable</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> Executor <span class=\"title function_\">getDefaultExecutor</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> BeanFactory beanFactory)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Executor</span> <span class=\"variable\">defaultExecutor</span> <span class=\"operator\">=</span> <span class=\"built_in\">super</span>.getDefaultExecutor(beanFactory);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (defaultExecutor != <span class=\"literal\">null</span> ? defaultExecutor : <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleAsyncTaskExecutor</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从这段逻辑看，如果从 Spring 容器中没有找到对应的线程池 Bean，那么就创建 SimpleAsyncTaskExecutor 作为默认的线程池。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>This class also customizes the Executor by defining a new bean. Here, the method is named taskExecutor, since this is the specific method name for which Spring searches. In our case, we want to limit the number of concurrent threads to two and limit the size of the queue to 500. There are many more things you can tune. If you do not define an Executor bean, <strong>Spring creates a SimpleAsyncTaskExecutor and uses that</strong>.</p></blockquote>\n<h3 id=\"方法执行任务的提交\"><a href=\"#方法执行任务的提交\" class=\"headerlink\" title=\"方法执行任务的提交\"></a>方法执行任务的提交</h3><p>基于前面的分析，方法执行任务的提交一定是发生在拦截到 <code>@Async</code> 注解时，也就是 AnnotationAsyncExecutionInterceptor 中；通过分析代码，在其父类 AsyncExecutionInterceptor<br>中，验证了分析。下面是部分核心逻辑:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(<span class=\"keyword\">final</span> MethodInvocation invocation)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1、拿到 Method</span></span><br><span class=\"line\">    <span class=\"comment\">// 2、根据 Method 获取 executor</span></span><br><span class=\"line\">    <span class=\"type\">AsyncTaskExecutor</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span> determineAsyncExecutor(userDeclaredMethod);</span><br><span class=\"line\">    <span class=\"comment\">// 3、创建方法执行任务 task</span></span><br><span class=\"line\">    Callable&lt;Object&gt; task = () -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 4、提交 task</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> doSubmit(task, executor, invocation.getMethod().getReturnType());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>determineAsyncExecutor 中说明了， executor 是和方法对象绑定的，即每个方法都有一个自己的 executor；异步方法在第一次执行的时候创建自己的 executor，然后缓存到内存中。在 doSubmit 中，会根据 returnType 的类型进行相应的处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Object <span class=\"title function_\">doSubmit</span><span class=\"params\">(Callable&lt;Object&gt; task, AsyncTaskExecutor executor, Class&lt;?&gt; returnType)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// CompletableFuture</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (CompletableFuture.class.isAssignableFrom(returnType)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> task.call();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CompletionException</span>(ex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, executor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ListenableFuture</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ListenableFuture.class.isAssignableFrom(returnType)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((AsyncListenableTaskExecutor) executor).submitListenable(task);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Future</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Future.class.isAssignableFrom(returnType)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> executor.submit(task);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// void</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        executor.submit(task);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"如何自定义线程池\"><a href=\"#如何自定义线程池\" class=\"headerlink\" title=\"如何自定义线程池\"></a>如何自定义线程池</h2><p>SpringBoot 提供了 <code>org.springframework.scheduling.annotation.AsyncConfigurer</code> 接口让开发人员可以自定义线程池执行器；框架默认提供了一个空的实现类 AsyncConfigurerSupport，两个方法体内部都是空实现。这部分逻辑在 <code>org.springframework.scheduling.annotation.AbstractAsyncConfiguration#setConfigurers</code>体现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Collect any &#123;<span class=\"doctag\">@link</span> AsyncConfigurer&#125; beans through autowiring.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Autowired(required = false)</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">setConfigurers</span><span class=\"params\">(Collection&lt;AsyncConfigurer&gt; configurers)</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (configurers.size() &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;Only one AsyncConfigurer may exist&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">AsyncConfigurer</span> <span class=\"variable\">configurer</span> <span class=\"operator\">=</span> configurers.iterator().next();</span><br><span class=\"line\"><span class=\"comment\">// for this</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.executor = configurer::getAsyncExecutor;</span><br><span class=\"line\"><span class=\"built_in\">this</span>.exceptionHandler = configurer::getAsyncUncaughtExceptionHandler;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>AsyncConfigurer 在项目中只能有一个实现 Bean，如果超过一个，将会抛出 IllegalStateException 异常。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文通过对 <code>@Async</code> 注解的分析，和你解释了 <strong>@Async 是怎么让方法异步执行的吗？</strong> 这个问题；从分析过程中可以知道，对于绝大多数面向工程师使用的注解或者工具，本质上是离不开那些最最基本知识点的。当然，通过分析代码，一方面是可以进一步识别作者的意图，更主要的是可以看到那些意料之外的“骚操作” coding。</p>\n","text":"在阅读本文之前，你可以通过 Creating Asynchronous Methods 指导来体验下创建异步方法的使用方式。 为什么要写这篇文章，本质上对于这些...","permalink":"/post/springboot/spring-boot-async-anno","photos":[],"count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"categories":[{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/categories/SpringBoot.json"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/tags/SpringBoot.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF%E7%94%9F%E6%95%88%EF%BC%9F\"><span class=\"toc-text\">如何开启生效？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#AsyncAnnotationBeanPostProcessor\"><span class=\"toc-text\">AsyncAnnotationBeanPostProcessor</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#AnnotationAsyncExecutionInterceptor\"><span class=\"toc-text\">AnnotationAsyncExecutionInterceptor</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Tips\"><span class=\"toc-text\">Tips</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">线程池</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA-AnnotationAsyncExecutionInterceptor-%E6%97%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">创建 AnnotationAsyncExecutionInterceptor 时初始化线程池</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%BB%98%E8%AE%A4%E7%BA%BF%E7%A8%8B%E6%B1%A0-SimpleAsyncTaskExecutor\"><span class=\"toc-text\">默认线程池 SimpleAsyncTaskExecutor</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%8F%90%E4%BA%A4\"><span class=\"toc-text\">方法执行任务的提交</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">如何自定义线程池</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"浅析 SOFA 注册中心数据同步","uid":"2c6664cf4370278f829998c803443e3c","slug":"sofa/sofa-registry-sync-data","date":"2022-09-12T02:58:30.000Z","updated":"2024-07-05T04:09:05.801Z","comments":true,"path":"api/articles/sofa/sofa-registry-sync-data.json","keywords":null,"cover":[],"text":"本篇主要对 SOFARegistry 的数据同步模块进行解析，对于注册中心的概念以及 SOFARegistry 的基础架构不做过多阐述，相关介绍可以见海量数据下...","permalink":"/post/sofa/sofa-registry-sync-data","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[{"name":"SOFA","slug":"SOFA","count":9,"path":"api/categories/SOFA.json"}],"tags":[{"name":"注册中心","slug":"注册中心","count":1,"path":"api/tags/注册中心.json"},{"name":"分布式","slug":"分布式","count":6,"path":"api/tags/分布式.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"聊 一聊 maven 测试相关的插件","uid":"852e241ff76b8d8f5b786f53987404dc","slug":"maven/maven-plugin-about-test","date":"2022-07-31T03:09:51.000Z","updated":"2024-07-05T04:09:05.782Z","comments":true,"path":"api/articles/maven/maven-plugin-about-test.json","keywords":null,"cover":[],"text":"在之前的 聊一聊 maven 生命周期和 maven 插件编写 这篇文章中，简单聊了点maven 构建生命周期和如何编写一个 maven 插件。本篇文章从插件入...","permalink":"/post/maven/maven-plugin-about-test","photos":[],"count_time":{"symbolsCount":"5.9k","symbolsTime":"5 mins."},"categories":[{"name":"maven","slug":"maven","count":4,"path":"api/categories/maven.json"}],"tags":[{"name":"maven","slug":"maven","count":4,"path":"api/tags/maven.json"},{"name":"maven plugin","slug":"maven-plugin","count":3,"path":"api/tags/maven-plugin.json"},{"name":"testing","slug":"testing","count":1,"path":"api/tags/testing.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}