{"title":"SpringBoot 源码系列-Bean 的生命周期与扩展","uid":"f4c2cd21dea87d9615be25c2ed29dd31","slug":"springboot/springboot-series-bean-life","date":"2019-12-14T09:20:43.000Z","updated":"2024-07-05T04:09:05.828Z","comments":true,"path":"api/articles/springboot/springboot-series-bean-life.json","keywords":null,"cover":[],"content":"<p>继续承接上一篇 <a href=\"http://www.glmapper.com/2019/12/07/springboot-series-started/\">SpringBoot 系列-启动过程分析</a>，本篇围绕一个 bean 的生命周期，对 bean 进行一些修改和扩展。</p>\n<span id=\"more\"></span>\n\n<p>本篇将涉及到以下主要内容：</p>\n<ul>\n<li><a href=\"\">阅读之前</a></li>\n<li><a href=\"\">BeanDefinition 解析时机和过程</a><ul>\n<li><a href=\"\">invokeBeanFactoryPostProcessors 执行过程分析</a></li>\n<li><a href=\"\">invokeBeanDefinitionRegistryPostProcessors 执行过程分析</a></li>\n</ul>\n</li>\n<li><a href=\"\">BeanFactoryPostProcessor 对 BeanDefinition 的修改</a><ul>\n<li><a href=\"\">案例工程中 BeanFactoryPostProcessor 的实现</a></li>\n</ul>\n</li>\n<li><a href=\"\">通过监听 ApplicationEnvironmentPreparedEvent 事件修改属性值</a></li>\n<li><a href=\"\">@Value 注入 &amp; @Autowired 注入</a><ul>\n<li><a href=\"\">Bean 属性注入发生的时机</a></li>\n<li><a href=\"\">Bean 属性注入发生的过程</a></li>\n</ul>\n</li>\n<li><a href=\"\">Bean 的实例化过程</a><ul>\n<li><a href=\"\">BeanPostProcessor 的处理时机</a></li>\n<li><a href=\"\">使用 BeanPostProcessor 修改 Bean</a></li>\n<li><a href=\"\">使用 InitializingBean</a></li>\n<li><a href=\"\">指定 Bean 的 init-method 方法</a></li>\n</ul>\n</li>\n<li><a href=\"\">总结</a><ul>\n<li><a href=\"\">BeanFactoryPostProcessor 对于 init-method 的影响</a></li>\n<li><a href=\"\">附：案例工程地址及参考</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"阅读之前\"><a href=\"#阅读之前\" class=\"headerlink\" title=\"阅读之前\"></a>阅读之前</h2><p>下面是本篇文章的“主人公” TestBeanService ，定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestBeanService</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 依赖注入</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> InjectBeanService injectBeanService;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 属性注入</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;spring.application.name&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String appName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> injectBeanService.testInject();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>TestBeanService 里面包括两个属性，一个是 injectBeanService ，另外一个是 appName，分别通过 @Autowired 和 @Value 注入值。本篇最终希望完成的目标是能够完成了解 Bean 属性注入的过程，以及 Bean 的实例化过程；除此之外，从 Spring 扩展的角度，来对 BeanFactoryPostProcess、BeanPostProcess、ApplicationListener、InitializingBean 以及 initMethod 的执行时机和作用进行分析。</p>\n<h2 id=\"TestBeanService-被解析成-BeanDifinition-的时机与过程\"><a href=\"#TestBeanService-被解析成-BeanDifinition-的时机与过程\" class=\"headerlink\" title=\"TestBeanService 被解析成 BeanDifinition 的时机与过程\"></a>TestBeanService 被解析成 BeanDifinition 的时机与过程</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Spring 容器刷新流程非常复杂，当我们想 debug BeanDifinition 加载过程时可能没法很快找到入口，这里可以直接面向 BeanDifinition 的最终去向来 debug。我们知道 BeanFactory 接口本身是不具体注册 BeanDifinition 能力的，这个能力是由 BeanDefinitionRegistry 接口提供。那么就看下 BeanDefinitionRegistry 的 registerBeanDefinition 方法有几个具体的实现，然后在这几个实现出打上断点，执行找到具体的处理入口。</p></blockquote>\n<p>我们将断点打在 DefaultListableBeanFactory#registerBeanDefinition 这个方法入口处，debug 模式运行工程，可以看到断点进入时的情况如下图所示：</p>\n<p><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/beanlife/life-one.jpg\"></p>\n<p>这里通过执行堆栈逆向找到 BeanDifinition 的加载入口是容器刷新阶段的 invokeBeanFactoryPostProcessors 方法；这里就详细分析下 testBeanService 这个 beandifition 是怎么被注册到容器中的。</p>\n<h3 id=\"invokeBeanFactoryPostProcessors-执行过程分析\"><a href=\"#invokeBeanFactoryPostProcessors-执行过程分析\" class=\"headerlink\" title=\"invokeBeanFactoryPostProcessors 执行过程分析\"></a>invokeBeanFactoryPostProcessors 执行过程分析</h3><p>invokeBeanFactoryPostProcessors 这个方法实现非常长，但是基本处理过程很简单，存在很多重复的步骤。为了方便理解整个过程，这里还是有必要贴一下代码，代码中会详细标注所做的事情是什么，这个过程是构建 BeanFactory 非常重要一步。掌握这个过程，就可以随意玩转 BeanFactoryPostProcessor 了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">invokeBeanFactoryPostProcessors</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">\t\t\tConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class=\"line\">    Set&lt;String&gt; processedBeans = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 当前 beanFactory 是否是 BeanDefinitionRegistry 类型</span></span><br><span class=\"line\">    <span class=\"comment\">// 只有是 BeanDefinitionRegistry 类型，才具备注册 beanDefinition 的能力</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanFactory <span class=\"keyword\">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class=\"line\">        <span class=\"type\">BeanDefinitionRegistry</span> <span class=\"variable\">registry</span> <span class=\"operator\">=</span> (BeanDefinitionRegistry) beanFactory;</span><br><span class=\"line\">        <span class=\"comment\">// 普通的 BeanFactoryPostProcessor 集合</span></span><br><span class=\"line\">        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// BeanDefinitionRegistryPostProcessor 类型处理器集合</span></span><br><span class=\"line\">        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 这里 beanFactoryPostProcessors 是在 SharedMetadataReaderFactoryContextInitializer 中加进来的，是 Spring 自己的处理器</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果是 BeanDefinitionRegistryPostProcessor 类型，就加到 registryProcessors</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (postProcessor <span class=\"keyword\">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class=\"line\">                <span class=\"type\">BeanDefinitionRegistryPostProcessor</span> <span class=\"variable\">registryProcessor</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                        (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class=\"line\">                <span class=\"comment\">// 执行 BeanDefinitionRegistryPostProcessor 后置处理</span></span><br><span class=\"line\">                registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class=\"line\">                registryProcessors.add(registryProcessor);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 否则就放到 regularPostProcessors</span></span><br><span class=\"line\">                regularPostProcessors.add(postProcessor);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 不要在这里初始化 FactoryBeans：需要保留所有未初始化的常规bean，以使 beanFacotryPostProcessor 对其处理！</span></span><br><span class=\"line\">        <span class=\"comment\">// 分离实现 PriorityOrdered，Ordered和其余优先级的 BeanDefinitionRegistryPostProcessor。</span></span><br><span class=\"line\">        List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 首先，调用实现 PriorityOrdered 的 BeanDefinitionRegistryPostProcessors。</span></span><br><span class=\"line\">        String[] postProcessorNames =</span><br><span class=\"line\">                beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 遍历 BeanDefinitionRegistryPostProcessors</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 只处理实现 PriorityOrdered 接口的 BeanDefinitionRegistryPostProcessor</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 符合上述条件的 BeanDefinitionRegistryPostProcessor 放到 currentRegistryProcessors 中，供后面使用</span></span><br><span class=\"line\">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class=\"line\">                <span class=\"comment\">// 标记当前 postProcessor 已经处理过了</span></span><br><span class=\"line\">                processedBeans.add(ppName);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 排序</span></span><br><span class=\"line\">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class=\"line\">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class=\"line\">        <span class=\"comment\">// 调用 BeanDefinitionRegistryPostProcessor 后置处理器</span></span><br><span class=\"line\">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class=\"line\">        currentRegistryProcessors.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 接下来，调用实现 Ordered的BeanDefinitionRegistryPostProcessors</span></span><br><span class=\"line\">        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class=\"line\">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class=\"line\">                processedBeans.add(ppName);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class=\"line\">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class=\"line\">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class=\"line\">        currentRegistryProcessors.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 最后，调用所有其他 BeanDefinitionRegistryPostProcessor，直到不再出现（保证全部处理完）。</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">reiterate</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (reiterate) &#123;</span><br><span class=\"line\">            reiterate = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class=\"line\">                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class=\"line\">                    processedBeans.add(ppName);</span><br><span class=\"line\">                    reiterate = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class=\"line\">            registryProcessors.addAll(currentRegistryProcessors);</span><br><span class=\"line\">            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class=\"line\">            currentRegistryProcessors.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 现在，调用到目前为止已处理的所有处理器的 postProcessBeanFactory 回调。</span></span><br><span class=\"line\">        invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class=\"line\">        invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用在上下文实例中注册的工厂处理器。就是前面提到的 SharedMetadataReaderFactoryContextInitializer 中注册的</span></span><br><span class=\"line\">        invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这里再次拿到所有的 BeanFactoryPostProcessor</span></span><br><span class=\"line\">    String[] postProcessorNames =</span><br><span class=\"line\">            beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 同样将实现 PriorityOrdered、Order 和普通的 BeanFactoryPostProcessor 分离开</span></span><br><span class=\"line\">    List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    List&lt;String&gt; orderedPostProcessorNames = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    List&lt;String&gt; nonOrderedPostProcessorNames = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 跳过-已在上述第一阶段处理过</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class=\"line\">            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class=\"line\">            orderedPostProcessorNames.add(ppName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            nonOrderedPostProcessorNames.add(ppName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 首先，调用实现PriorityOrdered的BeanFactoryPostProcessors。</span></span><br><span class=\"line\">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class=\"line\">    <span class=\"comment\">// 优先执行实现 PriorityOrdered 接口的 BeanFactoryPostProcessor</span></span><br><span class=\"line\">    invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 接下来，调用实现Ordered的BeanFactoryPostProcessors。</span></span><br><span class=\"line\">    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class=\"line\">        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class=\"line\">    <span class=\"comment\">// 执行实现 Ordered 接口的 BeanFactoryPostProcessor</span></span><br><span class=\"line\">    invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 最后，调用所有其他 BeanFactoryPostProcessor</span></span><br><span class=\"line\">    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class=\"line\">        nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 执行其他没有实现任何优先级接口的 BeanFactoryPostProcessor</span></span><br><span class=\"line\">    invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class=\"line\">    <span class=\"comment\">// 清除缓存的合并 beanDefinition，因为后处理器可能已经修改了原始元数据</span></span><br><span class=\"line\">    beanFactory.clearMetadataCache();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码段中大体就是，先处理 BeanDefinitionRegistryPostProcessor 类型的 BeanFactoryPostProcessor ，然后再处理普通的 BeanFactoryPostProcessor；在这里处理过程中，会根据一些排序规则来调整各个 BeanFactoryPostProcessor 的执行顺序。</p>\n<p>这里先处理 BeanDefinitionRegistryPostProcessor 类型的 BeanFactoryPostProcessor 是一定的，因为需要在这个阶段去注册 BeanDefinition。在 classpath 下的所有 BeanDefinition 都被注册之后，再执行普通 BeanFactoryPostProcessor 的后置回调，这样就可以覆盖所有的 BeanDefinition。</p>\n<h3 id=\"invokeBeanDefinitionRegistryPostProcessors-执行过程分析\"><a href=\"#invokeBeanDefinitionRegistryPostProcessors-执行过程分析\" class=\"headerlink\" title=\"invokeBeanDefinitionRegistryPostProcessors 执行过程分析\"></a>invokeBeanDefinitionRegistryPostProcessors 执行过程分析</h3><p>在第一次调用 invokeBeanDefinitionRegistryPostProcessors 时，当前的 BeanDefinitionRegistryPostProcessor 只有一个，就是 org.springframework.context.annotation.ConfigurationClassPostProcessor 。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在 ConfigurationClassPostProcessor 类中，会解析 @Configuration、@ComponentScan、@ComponentScans、@Import 等注解。ConfigurationClassPostProcessor 实现了 BeanDefinitionRegistryPostProcessor 接口，而 BeanDefinitionRegistryPostProcessor 接口继承了 BeanFactoryPostProcessor 接口，所以 ConfigurationClassPostProcessor 中需要重写 postProcessBeanDefinitionRegistry() 方法和 postProcessBeanFactory() 方法。而 ConfigurationClassPostProcessor 类的作用就是通过这两个方法去实现的。更多细节可以参考 <a href=\"https://blog.csdn.net/qq_34436819/article/details/100944204\">ConfigurationClassPostProcessor源码解析</a> 这篇文章，写的非常 nice。</p></blockquote>\n<p>invokeBeanDefinitionRegistryPostProcessors 处理的核心过程如下：</p>\n<ul>\n<li>1、ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry：BeanDefinition 触发加载的入口</li>\n<li>2、ConfigurationClassPostProcessor#processConfigBeanDefinitions：解析配置类，在此处会解析配置类上的注解(ComponentScan扫描出的类，@Import注册的类，以及@Bean方法定义的类)</li>\n<li>3、ComponentScanAnnotationParser#parse：根据注解的属性值来过滤加载 classpath 下的 beanDefinition（默认条件就是 basePackages，默认的 basePackages 为当前启动类的根包）</li>\n<li>4、ClassPathBeanDefinitionScanner#doScan：处理 basePackages 下所以的 beanDefinition，被打了 @Service、@Compoment 等注解的类都会被解析到</li>\n<li>5、DefaultListableBeanFactory#registerBeanDefinition：将 beanDefinition 注册到 BeanFactory 中（beanDefinitionMap 中）</li>\n</ul>\n<p>那么到这里 TestBeanService 的 BeanDefinition 就被注册到 BeanFactory 中了。</p>\n<h2 id=\"BeanFactoryPostProcessor-对-BeanDefinition-的修改\"><a href=\"#BeanFactoryPostProcessor-对-BeanDefinition-的修改\" class=\"headerlink\" title=\"BeanFactoryPostProcessor 对 BeanDefinition 的修改\"></a>BeanFactoryPostProcessor 对 BeanDefinition 的修改</h2><p>在本篇文章所对应的案例工程中，也实现了一个 BeanFactoryPostProcessor ，没有实现任何排序接口。这个 TestBeanServiceBeanFactoryPostProcessor 的作用是将原来的 TestBeanService 修改为 ProxyTestBeanService。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestBeanServiceBeanFactoryPostProcessor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">BeanFactoryPostProcessor</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postProcessBeanFactory</span><span class=\"params\">(ConfigurableListableBeanFactory beanFactory)</span> <span class=\"keyword\">throws</span> BeansException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据类型拿到所有的 beanNames</span></span><br><span class=\"line\">        Iterable&lt;String&gt; beanNames = getBeanNames(beanFactory, TestBeanService.class);</span><br><span class=\"line\">        <span class=\"comment\">// 这里因为只有一个 TestBeanService ，所以只处理第一个</span></span><br><span class=\"line\">        beanNames.forEach(beanName -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;begin to execute BeanFactoryPostProcessor...&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">BeanDefinitionRegistry</span> <span class=\"variable\">beanDefinitionRegistry</span> <span class=\"operator\">=</span> (BeanDefinitionRegistry) beanFactory;</span><br><span class=\"line\">            <span class=\"comment\">// 先从工程中拿到原始 beanDefinition</span></span><br><span class=\"line\">            <span class=\"type\">BeanDefinition</span> <span class=\"variable\">beanDefinition</span> <span class=\"operator\">=</span> beanFactory.getBeanDefinition(beanName);</span><br><span class=\"line\">            <span class=\"comment\">// 这里构建一个新的 BeanDefinition，类型为 ProxyTestBeanService，ProxyTestBeanService 是 TestBeanService 的子类</span></span><br><span class=\"line\">            <span class=\"type\">RootBeanDefinition</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RootBeanDefinition</span>(ProxyTestBeanService.class);</span><br><span class=\"line\">            <span class=\"comment\">// 这里设置指定的initMethod</span></span><br><span class=\"line\">            proxy.setInitMethodName(beanDefinition.getInitMethodName());</span><br><span class=\"line\">            <span class=\"comment\">// 设置一些属性</span></span><br><span class=\"line\">            proxy.setPropertyValues(beanDefinition.getPropertyValues());</span><br><span class=\"line\">            proxy.setPrimary(beanDefinition.isPrimary());</span><br><span class=\"line\">            proxy.setRole(BeanDefinition.ROLE_APPLICATION);</span><br><span class=\"line\">            <span class=\"comment\">// 将原始 beanDefinition 移除掉</span></span><br><span class=\"line\">            beanDefinitionRegistry.removeBeanDefinition(beanName);</span><br><span class=\"line\">            <span class=\"comment\">// 将代理的新的 beanDefinition 注册进去</span></span><br><span class=\"line\">            beanDefinitionRegistry.registerBeanDefinition(beanName,proxy);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;current bean type is : &quot;</span> + proxy.getBeanClass().getTypeName());</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <a href=\"\">invokeBeanFactoryPostProcessors 执行过程分析</a>中已经分析了 BeanFactoryPostProcessor 执行的时机和过程，这里不再赘述。TestBeanServiceBeanFactoryPostProcessor 的作用就是先将原始的 TestBeanService 的 Beandefinition 从容器中移除掉，然后构建一个 ProxyTestBeanService 的 Beandefinition，然后注册到容器中，beanName 没有变，所以通过 BeanFactoryPostProcessor 可以修改最原始的 Bean 信息，也可以通过 BeanFactoryPostProcessor 来动态注册一个新的 Bean。</p>\n<h2 id=\"通过监听-ApplicationEnvironmentPreparedEvent-事件修改属性值\"><a href=\"#通过监听-ApplicationEnvironmentPreparedEvent-事件修改属性值\" class=\"headerlink\" title=\"通过监听 ApplicationEnvironmentPreparedEvent 事件修改属性值\"></a>通过监听 ApplicationEnvironmentPreparedEvent 事件修改属性值</h2><p>上面完成了对 TestBeanService 的 BeanDefinition 的修改，将 TestBeanService 对象换成了 ProxyTestBeanService。前面提到 TestBeanService 中有两个需要注入的值，一个是通过 @Autowired 注入，一个是通过 @Value 注入，先来看 @Value 注入。@Value 注入的值来自 Enviroment，这里关于 Enviroment 和配置解析及构建不多说，本篇中关注的是如何将 @Value 注入的值改变掉。</p>\n<p>ApplicationEnvironmentPreparedEvent 事件是在环境准备完成时发送的事件，此时 Enviroment 已经准备好，可以随时为容器刷新提供环境变量支持。那么既然此时容器中的 Enviroment 对象已经 ready ，说明配置的 application.properties、系统参数等均已经被解析好了，而此时目标 Bean 还没有被刷新，其内部需要被注入的属性值还没有被注入，那么此时就可以通过监听这个事件，来对 Enviroment 中已经准备好的值进行修改，以改变实际被注入的值。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChangeAppNameListener</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ApplicationListener</span>&lt;ApplicationEnvironmentPreparedEvent&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onApplicationEvent</span><span class=\"params\">(ApplicationEnvironmentPreparedEvent event)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ConfigurableEnvironment</span> <span class=\"variable\">environment</span> <span class=\"operator\">=</span> event.getEnvironment();</span><br><span class=\"line\">        <span class=\"comment\">// 获取原始 spring.application.name 的值</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">applicationName</span> <span class=\"operator\">=</span> environment.getProperty(<span class=\"string\">&quot;spring.application.name&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;origin applicationName is : &quot;</span> + applicationName);</span><br><span class=\"line\">        <span class=\"comment\">// 修改 spring.application.name</span></span><br><span class=\"line\">        <span class=\"type\">Properties</span> <span class=\"variable\">props</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Properties</span>();</span><br><span class=\"line\">        props.put(<span class=\"string\">&quot;spring.application.name&quot;</span>, <span class=\"string\">&quot;updateAppName&quot;</span>);</span><br><span class=\"line\">        environment.getPropertySources().addFirst(<span class=\"keyword\">new</span> <span class=\"title class_\">PropertiesPropertySource</span>(<span class=\"string\">&quot;decrypted_properties&quot;</span>, props));</span><br><span class=\"line\"></span><br><span class=\"line\">        applicationName = environment.getProperty(<span class=\"string\">&quot;spring.application.name&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;updated applicationName is : &quot;</span> + applicationName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Value-注入-Autowired-注入\"><a href=\"#Value-注入-Autowired-注入\" class=\"headerlink\" title=\"@Value 注入 &amp; @Autowired 注入\"></a>@Value 注入 &amp; @Autowired 注入</h2><p>在 Spring 中，无论是 @Value 注入还是 @Autowired 注入，都是由 AutowiredAnnotationBeanPostProcessor 这个后置处理器处理的。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在很多开源的框架中，其内部自定义的注解也大都是通过 BeanPostProcessor 这个后置处理器来处理的。</p></blockquote>\n<p>AutowiredAnnotationBeanPostProcessor 中有个 AutowiredFieldElement 内部类，这个内部类的作用就是注入目标 bean 的属性值的。这里就包括 @Value 的注入和 @Autowired 注入。</p>\n<h3 id=\"Bean-属性注入发生的时机\"><a href=\"#Bean-属性注入发生的时机\" class=\"headerlink\" title=\"Bean 属性注入发生的时机\"></a>Bean 属性注入发生的时机</h3><p>容器刷新及属性注入调用堆栈如下：</p>\n<p><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/beanlife/life-two.jpg\"></p>\n<p>从堆栈看出，在容器刷新的最后阶段，会通过 finishBeanFactoryInitialization 这个方法实例化所有剩余的（非延迟初始化）单例 bean；这个过程就是绝大多数 bean 实例化的过程。这个过程中会涉及到以下两个比较重要的点：1、BeanPostProcessor 处理，2、依赖注入。从上面其实也可以看出，依赖注入的发生就是通过 BeanPostProcessor 处理完成的。下图为遍历所有目标属性，依次注入属性的过程：</p>\n<p><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/beanlife/life-three.jpg\"></p>\n<h3 id=\"Bean-属性注入发生的过程\"><a href=\"#Bean-属性注入发生的过程\" class=\"headerlink\" title=\"Bean 属性注入发生的过程\"></a>Bean 属性注入发生的过程</h3><p>这里以 @Autowired 注入为例，@Value 注入和 @Autowired 注入过程基本是一样的。@Autowired 注入相比于 @Value 注入，会涉及到初始化另外一个 Bean 的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构建一个依赖描述符对象</span></span><br><span class=\"line\"><span class=\"type\">DependencyDescriptor</span> <span class=\"variable\">desc</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DependencyDescriptor</span>(field, <span class=\"built_in\">this</span>.required);</span><br><span class=\"line\"><span class=\"comment\">// 设置包含此依赖项的具体类</span></span><br><span class=\"line\">desc.setContainingClass(bean.getClass());</span><br><span class=\"line\"><span class=\"comment\">// 初始化一个注入的 beanName 集合，用于后面注册到容器中</span></span><br><span class=\"line\"><span class=\"comment\">// 这里实际上只有一个，如果有多个实例 bean 存在，则需要通过 Qualifier 指定了</span></span><br><span class=\"line\">Set&lt;String&gt; autowiredBeanNames = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashSet</span>&lt;&gt;(<span class=\"number\">1</span>);</span><br><span class=\"line\">Assert.state(beanFactory != <span class=\"literal\">null</span>, <span class=\"string\">&quot;No BeanFactory available&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">TypeConverter</span> <span class=\"variable\">typeConverter</span> <span class=\"operator\">=</span> beanFactory.getTypeConverter();</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 解析依赖，依赖注入</span></span><br><span class=\"line\">    value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (BeansException ex) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 抛出注入失败异常</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsatisfiedDependencyException</span>(<span class=\"literal\">null</span>, beanName, <span class=\"keyword\">new</span> <span class=\"title class_\">InjectionPoint</span>(field), ex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.cached) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value != <span class=\"literal\">null</span> || <span class=\"built_in\">this</span>.required) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.cachedFieldValue = desc;</span><br><span class=\"line\">            <span class=\"comment\">// 注册依赖的 bean</span></span><br><span class=\"line\">            registerDependentBeans(beanName, autowiredBeanNames);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (autowiredBeanNames.size() == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">autowiredBeanName</span> <span class=\"operator\">=</span> autowiredBeanNames.iterator().next();</span><br><span class=\"line\">                <span class=\"comment\">// 判断容器中是否存在此依赖 bean,并且校验 bean 的类型是否匹配</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (beanFactory.containsBean(autowiredBeanName) &amp;&amp;</span><br><span class=\"line\">                        beanFactory.isTypeMatch(autowiredBeanName, field.getType())) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 缓存注入值</span></span><br><span class=\"line\">                    <span class=\"built_in\">this</span>.cachedFieldValue = <span class=\"keyword\">new</span> <span class=\"title class_\">ShortcutDependencyDescriptor</span>(</span><br><span class=\"line\">                            desc, autowiredBeanName, field.getType());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 没有找到 依赖bean 实例，且 required 为 false </span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.cachedFieldValue = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.cached = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// value 为解析到的属性值，如果不为空，则通过反射设置给目标 Bean，完成属性的注入</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (value != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    ReflectionUtils.makeAccessible(field);</span><br><span class=\"line\">    field.set(bean, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>属性注入发生在 populateBean（填充 Bean）的过程，在 Bean 属性填充完成之后就是 Bean 的实例化过程。</p>\n<h2 id=\"Bean-的实例化过程\"><a href=\"#Bean-的实例化过程\" class=\"headerlink\" title=\"Bean 的实例化过程\"></a>Bean 的实例化过程</h2><p>这里截取 AbstractAutowireCapableBeanFactory#doCreateBean 方法中的一小段代码，来承接上下文：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化bean实例。</span></span><br><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">exposedObject</span> <span class=\"operator\">=</span> bean;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 填充 Bean</span></span><br><span class=\"line\">    populateBean(beanName, mbd, instanceWrapper);</span><br><span class=\"line\">    <span class=\"comment\">// 实例化 Bean</span></span><br><span class=\"line\">    exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略异常处理</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里通过代码就很好的和上一小节的内容关联起来了，即填充 Bean -&gt; 实例化 Bean 。在 Bean 的实例化阶段会涉及到两个比较重要的扩展：1、BeanPostProcessor，2、InitializingBean。</p>\n<h3 id=\"BeanPostProcessor-的处理时机\"><a href=\"#BeanPostProcessor-的处理时机\" class=\"headerlink\" title=\"BeanPostProcessor 的处理时机\"></a>BeanPostProcessor 的处理时机</h3><p>BeanPostProcessor 有两个抽象方法，一个是实例化之前调用，一个是实例化之后调用。InitializingBean 接口只有一个 afterPropertiesSet 方法，afterPropertiesSet 方法的执行介于实例化之前实例化之后调用之间。BeanPostProcessor 的处理时机是在调用 initializeBean 方法中触发的，下面为 initializeBean 方法中的部分代码片段： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">wrappedBean</span> <span class=\"operator\">=</span> bean;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mbd == <span class=\"literal\">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 实例化之前调用</span></span><br><span class=\"line\">    wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用 InitializingBean 和指定的 init-method 方法</span></span><br><span class=\"line\">    invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BeanCreationException</span>(</span><br><span class=\"line\">            (mbd != <span class=\"literal\">null</span> ? mbd.getResourceDescription() : <span class=\"literal\">null</span>),</span><br><span class=\"line\">            beanName, <span class=\"string\">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mbd == <span class=\"literal\">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 实例化之后调用</span></span><br><span class=\"line\">    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里的 bean 对象实际上已经是完整的 bean 了，postProcessBeforeInitialization 和 postProcessAfterInitialization 是相对于是否执行 InitializingBean 的 afterPropertiesSet 和执行 Bean 指定的 initMethod 方法而言的。</p></blockquote>\n<h3 id=\"使用-BeanPostProcessor-修改-Bean\"><a href=\"#使用-BeanPostProcessor-修改-Bean\" class=\"headerlink\" title=\"使用 BeanPostProcessor 修改 Bean\"></a>使用 BeanPostProcessor 修改 Bean</h3><p>从 initializeBean 方法中可以看出，了，postProcessBeforeInitialization 和 postProcessAfterInitialization 两处回调返回放回的是 wrappedBean，也就意味着我们可以在这两个方法中对容器中的原始 Bean 做一些处理，比如代理一层原始的 Bean，或者修改 Bean 中的一些属性等。</p>\n<p>在案例工程中提供了一个 TestBeanServiceProcessor ，其作用是对 TestBeanService 类型的 Bean 做一层代理，使得在执行 TestBeanService 中方法的前后做一些埋点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// TestBeanServiceProcessor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestBeanServiceProcessor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">BeanPostProcessor</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">postProcessBeforeInitialization</span><span class=\"params\">(Object bean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 bean 的类型是 TestBeanService，则将其包装成 TestBeanWrapperService 并返回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bean <span class=\"keyword\">instanceof</span> TestBeanService)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;begin to execute postProcessBeforeInitialization.&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">TestBeanWrapperService</span> <span class=\"variable\">testBeanService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TestBeanWrapperService</span>((TestBeanService)bean);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> testBeanService;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">postProcessAfterInitialization</span><span class=\"params\">(Object bean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bean <span class=\"keyword\">instanceof</span> TestBeanService)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;begin to execute postProcessAfterInitialization.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 代理类 TestBeanWrapperService，注意这里代理类也应该是 TestBeanService 类型，否在是后面使用时就会找不到 Bean 实例</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestBeanWrapperService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">TestBeanService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TestBeanService delegate;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">TestBeanWrapperService</span><span class=\"params\">(TestBeanService delegate)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.delegate = delegate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 实现对 test 方法执行前后进行拦截</span></span><br><span class=\"line\"><span class=\"comment\">     **/</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            before();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> delegate.test();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            after();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;before execute test.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">after</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;after execute test.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用-InitializingBean\"><a href=\"#使用-InitializingBean\" class=\"headerlink\" title=\"使用 InitializingBean\"></a>使用 InitializingBean</h3><p>如果一个 bean 集成了 InitializingBean 接口，那么就需要重写其 afterPropertiesSet 方法。这里感觉有点漏洞，afterPropertiesSet 动作其实早就完成了，另外因为 afterPropertiesSet  是在 postProcessAfterInitialization 方法之前调用，所以还是可以在 postProcessAfterInitialization 对属性做修改。实际使用过程中需要关注下这个点，一般情况下，我们会在 afterPropertiesSet 中做一些初始化动作，比如启动连接 Zookeeper。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestBeanService</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InitializingBean</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略其他代码</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;begin to execute afterPropertiesSet...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"指定-Bean-的-init-method-方法\"><a href=\"#指定-Bean-的-init-method-方法\" class=\"headerlink\" title=\"指定 Bean 的 init-method 方法\"></a>指定 Bean 的 init-method 方法</h3><p>init-method 方法只能通过 @Bean 或者 xml 方式指定，如果是使用 @Component 或者 @Service 注解标准的 Bean ，则可以通过 @PostConstruct 注解标注方法，对应的是 destroy-method 和 @PreDestroy 。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestBeanService</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InitializingBean</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略其他代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// init 方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;begin to execute init...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 在自动配置类或者 xml 文件中指定 initMethod</span></span><br><span class=\"line\"><span class=\"meta\">@Bean(initMethod = &quot;init&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> TestBeanService <span class=\"title function_\">testBeanService</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TestBeanService</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本篇围绕 TestBeanService 这个 Bean 展开，对其生命周期，及其生命周期各个阶段扩展点进行了介绍，包括修改注入的属性值、修改其 BeanDefinition、修改 Bean 实例等等，从扩展点的视角来洞悉一个 Bean 的生命周期。</p>\n<h3 id=\"BeanFactoryPostProcessor-对于-init-method-的影响\"><a href=\"#BeanFactoryPostProcessor-对于-init-method-的影响\" class=\"headerlink\" title=\"BeanFactoryPostProcessor 对于 init-method 的影响\"></a>BeanFactoryPostProcessor 对于 init-method 的影响</h3><p>因为 init-method 这个点是后面想起来加上去的，在实际测试过程中，发现 TestBeanService 中指定的 init 方法没有被执行（正常情况下是在 afterPropertiesSet 之后就会执行的）；对于这个 TestBeanService 在案例工程中有两处对其进行了修改，一个是修改其 BeanDefinition ，一个是修改 其 Bean 实例；最终拿到的 bean 的类型是 TestBeanWrapperService，在此之前 Bean 的类型是 ProxyTestBeanService ，无论是TestBeanWrapperService 还是 ProxyTestBeanService 都是 TestBeanService 的子类，init 方法又是 public 的，所以从这个角度来看，不可能不生效。所以基本可以排除因为访问权限问题导致。最后 debug 下面代码发现，mbd.getInitMethodName() 返回的是 null， mbd 是 RootBeanDefinition；</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>PS: BeanDefinition 中 getInitMethodName 方法是在 Spring 5.1 版本之后才有的，之前版本都是 在 AbstractBeanDefinition 这个抽象类中定义。</p></blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mbd != <span class=\"literal\">null</span> &amp;&amp; bean.getClass() != NullBean.class) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从当前 bean  的 BeanDefinition 对象中获取 initMethod 方法名</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">initMethodName</span> <span class=\"operator\">=</span> mbd.getInitMethodName();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;</span><br><span class=\"line\">            !(isInitializingBean &amp;&amp; <span class=\"string\">&quot;afterPropertiesSet&quot;</span>.equals(initMethodName)) &amp;&amp;</span><br><span class=\"line\">            !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class=\"line\">        invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>问题出在这里，在 TestBeanServiceBeanFactoryPostProcessor 处理时，没有将原始 BeanDefinition 的 initMethod 给新的 ProxyTestBeanService，所以导致后面所有基于此实例化的 bean 的 BeanDefinition 都没有 initMethod 方法。在TestBeanServiceBeanFactoryPostProcessor#postProcessBeanFactory 方法中补充设置 InitMethodName 之后问题解决。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里设置指定的initMethod</span></span><br><span class=\"line\">proxy.setInitMethodName(beanDefinition.getInitMethodName());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"附：案例工程地址及参考\"><a href=\"#附：案例工程地址及参考\" class=\"headerlink\" title=\"附：案例工程地址及参考\"></a>附：案例工程地址及参考</h3><ul>\n<li>工程地址：<a href=\"https://github.com/glmapper/glmapper-blog-samples/tree/master/glmapper-blog-bean-lifecycle\">glmapper-blog-bean-lifecycle</a></li>\n<li>参考文档：<a href=\"https://blog.csdn.net/qq_34436819/article/details/100944204\">ConfigurationClassPostProcessor源码解析</a></li>\n</ul>\n","text":"继续承接上一篇 SpringBoot 系列-启动过程分析，本篇围绕一个 bean 的生命周期，对 bean 进行一些修改和扩展。 本篇将涉及到以下主要内容： 阅...","permalink":"/post/springboot/springboot-series-bean-life","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"22 mins."},"categories":[{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/categories/SpringBoot.json"}],"tags":[{"name":"bean 生命周期","slug":"bean-生命周期","count":2,"path":"api/tags/bean-生命周期.json"},{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/tags/SpringBoot.json"},{"name":"bean 扩展机制","slug":"bean-扩展机制","count":1,"path":"api/tags/bean-扩展机制.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%98%85%E8%AF%BB%E4%B9%8B%E5%89%8D\"><span class=\"toc-text\">阅读之前</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TestBeanService-%E8%A2%AB%E8%A7%A3%E6%9E%90%E6%88%90-BeanDifinition-%E7%9A%84%E6%97%B6%E6%9C%BA%E4%B8%8E%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">TestBeanService 被解析成 BeanDifinition 的时机与过程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#invokeBeanFactoryPostProcessors-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90\"><span class=\"toc-text\">invokeBeanFactoryPostProcessors 执行过程分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#invokeBeanDefinitionRegistryPostProcessors-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90\"><span class=\"toc-text\">invokeBeanDefinitionRegistryPostProcessors 执行过程分析</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#BeanFactoryPostProcessor-%E5%AF%B9-BeanDefinition-%E7%9A%84%E4%BF%AE%E6%94%B9\"><span class=\"toc-text\">BeanFactoryPostProcessor 对 BeanDefinition 的修改</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87%E7%9B%91%E5%90%AC-ApplicationEnvironmentPreparedEvent-%E4%BA%8B%E4%BB%B6%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7%E5%80%BC\"><span class=\"toc-text\">通过监听 ApplicationEnvironmentPreparedEvent 事件修改属性值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Value-%E6%B3%A8%E5%85%A5-Autowired-%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">@Value 注入 &amp; @Autowired 注入</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Bean-%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5%E5%8F%91%E7%94%9F%E7%9A%84%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">Bean 属性注入发生的时机</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Bean-%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5%E5%8F%91%E7%94%9F%E7%9A%84%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">Bean 属性注入发生的过程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Bean-%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">Bean 的实例化过程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#BeanPostProcessor-%E7%9A%84%E5%A4%84%E7%90%86%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">BeanPostProcessor 的处理时机</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-BeanPostProcessor-%E4%BF%AE%E6%94%B9-Bean\"><span class=\"toc-text\">使用 BeanPostProcessor 修改 Bean</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-InitializingBean\"><span class=\"toc-text\">使用 InitializingBean</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%87%E5%AE%9A-Bean-%E7%9A%84-init-method-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">指定 Bean 的 init-method 方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#BeanFactoryPostProcessor-%E5%AF%B9%E4%BA%8E-init-method-%E7%9A%84%E5%BD%B1%E5%93%8D\"><span class=\"toc-text\">BeanFactoryPostProcessor 对于 init-method 的影响</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%99%84%EF%BC%9A%E6%A1%88%E4%BE%8B%E5%B7%A5%E7%A8%8B%E5%9C%B0%E5%9D%80%E5%8F%8A%E5%8F%82%E8%80%83\"><span class=\"toc-text\">附：案例工程地址及参考</span></a></li></ol></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"git ssh 配置及使用","uid":"be22db7a82eb7ce306e739c568aa9990","slug":"git/git-ssh-config","date":"2019-12-20T10:05:05.000Z","updated":"2024-07-05T04:09:05.759Z","comments":true,"path":"api/articles/git/git-ssh-config.json","keywords":null,"cover":null,"text":"配置使用 ssh 方式来提交和克隆代码大概可以分为以下几个步骤： 设置 Git 的 user name 和 email：(如果是第一次的话) 检查是否已经有 S...","permalink":"/post/git/git-ssh-config","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"git","slug":"git","count":3,"path":"api/categories/git.json"}],"tags":[{"name":"git","slug":"git","count":3,"path":"api/tags/git.json"},{"name":"ssh","slug":"ssh","count":1,"path":"api/tags/ssh.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"SpringBoot 源码系列-日志详解","uid":"f5d3246c456264d1eef61369dbcbbbab","slug":"springboot/springboot-series-log","date":"2019-12-14T09:18:07.000Z","updated":"2024-07-05T04:09:05.829Z","comments":true,"path":"api/articles/springboot/springboot-series-log.json","keywords":null,"cover":[],"text":"Spring Boot 使用 Commons Logging 进行所有内部日志记录，但保留底层日志实现。为 Java Util Logging、Log4J2 和...","permalink":"/post/springboot/springboot-series-log","photos":[],"count_time":{"symbolsCount":"30k","symbolsTime":"27 mins."},"categories":[{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/categories/SpringBoot.json"}],"tags":[{"name":"log","slug":"log","count":5,"path":"api/tags/log.json"},{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/tags/SpringBoot.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}