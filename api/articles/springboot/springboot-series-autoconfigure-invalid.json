{"title":"为什么你的 SpringBoot 自动配置失效了","uid":"0733c66f6904b8d3bf1d0aaecefb6227","slug":"springboot/springboot-series-autoconfigure-invalid","date":"2021-11-15T03:35:18.000Z","updated":"2024-07-05T04:09:05.827Z","comments":true,"path":"api/articles/springboot/springboot-series-autoconfigure-invalid.json","keywords":null,"cover":[],"content":"<p>本文源自近期项目中遇到的问题， bug 总是出现在你自以为是的地方…</p>\n<span id=\"more\"></span>\n\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>下面是一个简单复现的代码片段，在你没有阅读完本文时，如果能做出正确的判断，那恭喜你可以节省阅读本文的时间了。</p>\n<p>1、自动配置类：<code>AutoTestConfiguration</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties(TestProperties.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnProperty(prefix = &quot;test&quot;, name = &quot;enable&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AutoTestConfiguration</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@ConditionalOnMissingBean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> TestBean <span class=\"title function_\">testBean</span><span class=\"params\">(TestProperties properties)</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;this is executed.....&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TestBean</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、配置类 <code>TestProperties</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ConfigurationProperties(prefix = &quot;test&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestProperties</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"variable\">enable</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isEnable</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> enable;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setEnable</span><span class=\"params\">(<span class=\"type\">boolean</span> enable)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.enable = enable;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两个类都在 <code>root package</code> 下，可以保证能够正常被 <code>Spring</code> 扫描到；那么问题是 <code>TestBean</code> 会不会被正常创建？当然这里的结论是不会。</p>\n<p>可能有的同学会说你的 <code>TestProperties</code> 没有加 <code>@Configuration</code> 注解，<code>Spring</code> 不认识它，那真的是这样吗？很显然也不是。</p>\n<p>在排查这个问题的过程中，也有遇到其他问题，也是之前没有遇到过的；即使 <code>Spring</code> 源码我看过很多遍，但是仍然会有一些边边角角让你意想不到的地方；下面就针对这个问题，慢慢来揭开它的面纱。</p>\n<h2 id=\"EnableConfigurationProperties-注解行为\"><a href=\"#EnableConfigurationProperties-注解行为\" class=\"headerlink\" title=\"@EnableConfigurationProperties 注解行为\"></a>@EnableConfigurationProperties 注解行为</h2><p>在之前的版本中，<code>TestProperties</code> 是有被 <code>@Configuration</code> 注解标注的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span> <span class=\"comment\">// 可以被 spring 扫描</span></span><br><span class=\"line\"><span class=\"meta\">@ConfigurationProperties(prefix = &quot;test&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestProperties</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"variable\">enable</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isEnable</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> enable;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setEnable</span><span class=\"params\">(<span class=\"type\">boolean</span> enable)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.enable = enable;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>常规的思路是，当 <code>TestProperties</code> 被扫描到之后，spring env 中就会有 <code>test.enable=true</code> 的 k-v 存在，当执行 <code>AutoTestConfiguration</code> 自动配置类刷新时，<code>@ConditionalOnProperty(prefix = &quot;test&quot;, name = &quot;enable&quot;)</code> 则会生效，进而 <code>TestBean</code> 被正常创建。</p>\n<p>但事实并非如此，下面是对于此问题的验证</p>\n<h3 id=\"配置有效，AutoTestConfiguration-未刷新\"><a href=\"#配置有效，AutoTestConfiguration-未刷新\" class=\"headerlink\" title=\"配置有效，AutoTestConfiguration 未刷新\"></a>配置有效，AutoTestConfiguration 未刷新</h3><p>两个点：</p>\n<ul>\n<li>1、AutoTestConfiguration#testBean 执行会输出一个 log（用于判断 AutoTestConfiguration 是否正常刷新）</li>\n<li>监听 ApplicationReadyEvent 事件，拿 <code>test.enable</code> 值（用于判端配置是否正常加载，也就是 TestProperties 是否被正常刷新）</li>\n</ul>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Application</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ApplicationListener</span>&lt;ApplicationReadyEvent&gt; &#123;</span><br><span class=\"line\">   <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> ApplicationContext applicationContext;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">      SpringApplication.run(Application.class, args);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onApplicationEvent</span><span class=\"params\">(ApplicationReadyEvent event)</span> &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"built_in\">this</span>.applicationContext.getEnvironment().getProperty(<span class=\"string\">&quot;test.enable&quot;</span>)  + <span class=\"string\">&quot;------&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>执行得到的结果是 <code>AutoTestConfiguration#testBean</code> 没有被执行，但<code>test.enable</code> 为 true</strong>。</p>\n<p>这里说明 <code>TestProperties</code> 是有被刷新的，但是并没有对 <code>@ConditionalOnProperty</code> 起到作用，那么这里基本可以猜到是自动配置类上的 <code>@ConditionalOnProperty</code> 和 <code>@EnableConfigurationProperties</code> 的作用顺序问题。</p>\n<p>在验证顺序问题之前，我尝试在 application.properties 中增加如下配置，re run 项目：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">test.enable</span>=<span class=\"string\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>到这里我得到了另一个 bean 冲突的问题。</p>\n<h2 id=\"prefix-type\"><a href=\"#prefix-type\" class=\"headerlink\" title=\"prefix-type\"></a>prefix-type</h2><p>异常提示如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Parameter 0 of method testBean in com.glmapper.bridge.boot.config.AutoTestConfiguration required a single bean, but 2 were found:</span><br><span class=\"line\">\t- testProperties: defined in file [/Users/glmapper/Documents/project/exception-guides/target/classes/com/glmapper/bridge/boot/config/TestProperties.class]</span><br><span class=\"line\">\t- test-com.glmapper.bridge.boot.config.TestProperties: defined in null</span><br></pre></td></tr></table></figure>\n\n<p>这里出现了 <code>test-com.glmapper.bridge.boot.config.TestProperties</code> 这个 name 的 bean。我尝试在代码中去检查是否有显示给定这个 bean 名字，但是没有找到，那只有一种可能，就是这个是被 spring 自己创建的。</p>\n<p>这个过程在 spring 刷新阶段非常靠前，在排查这个问题时，还是耽误了一些时间，最后还是把问题定位一致前置到 beandefinitions 初始化才找到。</p>\n<p>这里是 <code>@EnableConfigurationProperties</code> 注解的一个行为，依赖 <code>EnableConfigurationPropertiesRegistrar</code>，源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">EnableConfigurationPropertiesRegistrar</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class=\"line\">         .getQualifiedAttributeName(EnableConfigurationPropertiesRegistrar.class, <span class=\"string\">&quot;methodValidationExcludeFilter&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerBeanDefinitions</span><span class=\"params\">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class=\"line\">      registerInfrastructureBeans(registry);</span><br><span class=\"line\">      registerMethodValidationExcludeFilter(registry);</span><br><span class=\"line\">      <span class=\"type\">ConfigurationPropertiesBeanRegistrar</span> <span class=\"variable\">beanRegistrar</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConfigurationPropertiesBeanRegistrar</span>(registry);</span><br><span class=\"line\">      <span class=\"comment\">// to register</span></span><br><span class=\"line\">      getTypes(metadata).forEach(beanRegistrar::register);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过代码比较容易看出，EnableConfigurationPropertiesRegistrar 会将目标 metadata 注册成 bean；继续 debug，找到了产生 prefix-type 格式 name 的 bean。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6341401556804dfa87df2b28fbb7e351~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>下面是 getName 的具体代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> String <span class=\"title function_\">getName</span><span class=\"params\">(Class&lt;?&gt; type, MergedAnnotation&lt;ConfigurationProperties&gt; annotation)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 拿 prefix</span></span><br><span class=\"line\">   <span class=\"type\">String</span> <span class=\"variable\">prefix</span> <span class=\"operator\">=</span> annotation.isPresent() ? annotation.getString(<span class=\"string\">&quot;prefix&quot;</span>) : <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">   <span class=\"comment\">// prefix + &quot;-&quot; + 类全限定名 </span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> (StringUtils.hasText(prefix) ? prefix + <span class=\"string\">&quot;-&quot;</span> + type.getName() : type.getName());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到这里我们先明确一个问题：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果你使用 <code>@EnableConfigurationProperties</code> 来开启配置类，那么就不要在配置类上使用@Configuration 等能够被 Spring scan 识别到的注解，以免在后续的使用中同一类型的 bean 多个实例</p></blockquote>\n<h2 id=\"ConditionalOnProperty\"><a href=\"#ConditionalOnProperty\" class=\"headerlink\" title=\"@ConditionalOnProperty\"></a>@ConditionalOnProperty</h2><p>在回到配置不生效问题上来，这里在官方 issue 是有记录的：<a href=\"https://github.com/spring-projects/spring-boot/issues/2282%E3%80%82\">https://github.com/spring-projects/spring-boot/issues/2282。</a></p>\n<p>不过这里还是通过分析代码来还原下问题产生的根本原因；这里主要从两个方面来分析：</p>\n<ul>\n<li>@ConditionalOnProperty match 值逻辑，需要明确在匹配 value 时，从哪些 PropertySource 读取的。</li>\n<li>@ConditionalOnProperty match 失败和 bean 刷新的逻辑</li>\n</ul>\n<h3 id=\"ConditionalOnProperty-match-逻辑\"><a href=\"#ConditionalOnProperty-match-逻辑\" class=\"headerlink\" title=\"@ConditionalOnProperty match 逻辑\"></a>@ConditionalOnProperty match 逻辑</h3><p>首先是 @ConditionalOnProperty 在执行计算时，匹配 value 的值来源问题，通过 debug 代码很容易就得到了所有的 source 来源，如下图：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5221bae4afd241cea4a732ce6c6d5b22~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>从 debug 看，本案例有 4 个来源（具体如上图），实际上从源码来看，source 涵盖了 spring env 所有来源：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ConfigurationPropertySourcesPropertySource &#123;name=&#x27;configurationProperties&#x27;&#125;, </span><br><span class=\"line\">StubPropertySource &#123;name=&#x27;servletConfigInitParams&#x27;&#125;, </span><br><span class=\"line\">StubPropertySource &#123;name=&#x27;servletContextInitParams&#x27;&#125;, </span><br><span class=\"line\">PropertiesPropertySource &#123;name=&#x27;systemProperties&#x27;&#125;, OriginAwareSystemEnvironmentPropertySource &#123;name=&#x27;systemEnvironment&#x27;&#125;, </span><br><span class=\"line\">RandomValuePropertySource &#123;name=&#x27;random&#x27;&#125;, </span><br><span class=\"line\">OriginTrackedMapPropertySource &#123;name=&#x27;Config resource &#x27;class path resource [application.properties]&#x27; via location &#x27;optional:classpath:/&#x27;&#x27;&#125;]</span><br></pre></td></tr></table></figure>\n<p>所以本文案例中不生效原因就是上面这些 PropertySource 都没有 test.enable，也就是 TestProperties 没被刷新，或者其在自动配置类之后才刷新。</p>\n<h3 id=\"ConditionalOnProperty-skip-逻辑\"><a href=\"#ConditionalOnProperty-skip-逻辑\" class=\"headerlink\" title=\"@ConditionalOnProperty skip 逻辑\"></a>@ConditionalOnProperty skip 逻辑</h3><p>这里主要解释 @ConditionalOnPropert 和 bean 被刷新的逻辑关系，具体实现在 ConditionEvaluator 类中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">shouldSkip</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> AnnotatedTypeMetadata metadata, <span class=\"meta\">@Nullable</span> ConfigurationPhase phase)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1、没有 Conditional 注解，则扫描时不会跳过当前 bean</span></span><br><span class=\"line\">    <span class=\"comment\">// 2、遍历 conditions 进行判断是否满足</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以对于自动配置类上的注解，Conditional 是作为当前类是否允许被刷新的前提，只有 Conditional 条件满足，才会将当前的自动配置类加入到待刷新 bean 列表中去，如果 Conditional 不满足，这个 bean 将直接被跳过，不会被放到 BeandefinitonMap 中去，也就不会有后续的刷新动作。</p>\n<p>@ConditionalOnProperty 作用时机在 BeanDefiniton 被创建之前，其执行时机要比 <code>@EnableConfigurationProperties</code> 作用要早，这也就说明了，为什么 TestProperties 中 test.enable&#x3D;true， <code>AutoTestConfiguration</code> 也不会刷新的原因了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文通过一个简单 case，对于项目中遇到的 SpringBoot 配置失效导致 bean 未被刷新问题进行了回溯，总结如下：</p>\n<ul>\n<li>Conditional 相关注解对于自动配置类来说，作用时机较早，用于决定当前自动配置类是否允许被刷新</li>\n<li>@EnableConfigurationProperties enable 的类，会默认注册一个 bean，bean 名字格式为 prefix-type</li>\n</ul>\n","text":"本文源自近期项目中遇到的问题， bug 总是出现在你自以为是的地方… 问题描述下面是一个简单复现的代码片段，在你没有阅读完本文时，如果能做出正确的判断，那恭喜你...","permalink":"/post/springboot/springboot-series-autoconfigure-invalid","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/categories/SpringBoot.json"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/tags/SpringBoot.json"},{"name":"自动配置","slug":"自动配置","count":2,"path":"api/tags/自动配置.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">问题描述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EnableConfigurationProperties-%E6%B3%A8%E8%A7%A3%E8%A1%8C%E4%B8%BA\"><span class=\"toc-text\">@EnableConfigurationProperties 注解行为</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE%E6%9C%89%E6%95%88%EF%BC%8CAutoTestConfiguration-%E6%9C%AA%E5%88%B7%E6%96%B0\"><span class=\"toc-text\">配置有效，AutoTestConfiguration 未刷新</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#prefix-type\"><span class=\"toc-text\">prefix-type</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ConditionalOnProperty\"><span class=\"toc-text\">@ConditionalOnProperty</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ConditionalOnProperty-match-%E9%80%BB%E8%BE%91\"><span class=\"toc-text\">@ConditionalOnProperty match 逻辑</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ConditionalOnProperty-skip-%E9%80%BB%E8%BE%91\"><span class=\"toc-text\">@ConditionalOnProperty skip 逻辑</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"SpringBoot Actuator 潜在的 OOM 问题","uid":"e6df084a71adfbb41be6ca4e81a75e09","slug":"springboot/springboot-series-actuator-oom","date":"2021-11-29T03:37:27.000Z","updated":"2024-07-05T04:09:05.827Z","comments":true,"path":"api/articles/springboot/springboot-series-actuator-oom.json","keywords":null,"cover":[],"text":"此问题背景产生于近期需要上线的一个功能的埋点；主要表现就是在应用启动之后的一段时间内，内存使用一直呈现递增趋势。 下图为场景复线后，本地通过 jconsole ...","permalink":"/post/springboot/springboot-series-actuator-oom","photos":[],"count_time":{"symbolsCount":"7.8k","symbolsTime":"7 mins."},"categories":[{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/categories/SpringBoot.json"}],"tags":[{"name":"OOM","slug":"OOM","count":2,"path":"api/tags/OOM.json"},{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/tags/SpringBoot.json"},{"name":"actuator","slug":"actuator","count":1,"path":"api/tags/actuator.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"git 中 merge 和 rebase 小记","uid":"fcd3e7ce113bd1990030da77cb454e76","slug":"git/git-cmd-rebase-merge","date":"2021-11-09T03:32:40.000Z","updated":"2024-07-05T04:09:05.758Z","comments":true,"path":"api/articles/git/git-cmd-rebase-merge.json","keywords":null,"cover":[],"text":"作为一线工程师的你，对于 git一定不会陌生，git 作为一个开源的分布式版本控制系统，有着广泛的用户基础。git 使用有很多可视化的工具，idea 自身也大多...","permalink":"/post/git/git-cmd-rebase-merge","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"git","slug":"git","count":3,"path":"api/categories/git.json"}],"tags":[{"name":"git","slug":"git","count":3,"path":"api/tags/git.json"},{"name":"merge","slug":"merge","count":1,"path":"api/tags/merge.json"},{"name":"rebase","slug":"rebase","count":1,"path":"api/tags/rebase.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}