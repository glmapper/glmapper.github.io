{"title":"SpringBoot 源码系列-FatJar 启动原理","uid":"ab9e1ff6883aee9623d9698a3a7669a7","slug":"springboot/springboot-series-fatjar","date":"2019-10-13T09:46:09.000Z","updated":"2024-07-05T04:09:05.828Z","comments":true,"path":"api/articles/springboot/springboot-series-fatjar.json","keywords":null,"cover":[],"content":"<p>之前有写过一篇文章来介绍 JAR 文件和 MENIFEST.MF 文件，详见：<a href=\"https://juejin.im/post/5d16cc8cf265da1b8d163237\">聊一聊 JAR 文件和 MANIFEST.MF</a>，在这篇文章中介绍了 JAR 文件的内部结构。本篇将继续延续前面的节奏，来介绍下，在 SpringBoot 中，是如何将一个 FatJar 运行起来的。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"FatJar-解压之后的文件目录\"><a href=\"#FatJar-解压之后的文件目录\" class=\"headerlink\" title=\"FatJar 解压之后的文件目录\"></a>FatJar 解压之后的文件目录</h2><p>从 <a href=\"https://start.spring.io/\">Spring 官网</a> 或者通过 Idea 创建一个新的 SpringBoot 工程，方便起见，建议什么依赖都不加，默认带入的空的 SpringBoot 工程即可。</p>\n<p>通过 maven 命令进行打包，打包成功之后得到的构建产物截图如下：</p>\n<p><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/jarlaunch/jarlaunch-one.jpg\"></p>\n<p>在前面的文章中有提到，jar 包是zip 包的一种变种，因此也可以通过 unzip 来解压</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unzip -q guides-for-jarlaunch-0.0.1-SNAPSHOT.jar -d mock</span><br></pre></td></tr></table></figure>\n<p>解压的 mock 目录，使用 tree 指令，看到整个解压之后的 FatJar 的目录结构如下（部分省略）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── BOOT-INF</span><br><span class=\"line\">│   ├── classes</span><br><span class=\"line\">│   │   ├── application.properties  # 用户-配置文件</span><br><span class=\"line\">│   │   └── com</span><br><span class=\"line\">│   │       └── glmapper</span><br><span class=\"line\">│   │           └── bridge</span><br><span class=\"line\">│   │               └── boot</span><br><span class=\"line\">│   │                   └── BootStrap.class  # 用户-启动类</span><br><span class=\"line\">│   └── lib</span><br><span class=\"line\">│       ├── jakarta.annotation-api-1.3.5.jar</span><br><span class=\"line\">│       ├── jul-to-slf4j-1.7.28.jar</span><br><span class=\"line\">│       ├── log4j-xxx.jar # 表示 log4j 相关的依赖简写</span><br><span class=\"line\">│       ├── logback-xxx.jar # 表示 logback 相关的依赖简写</span><br><span class=\"line\">│       ├── slf4j-api-1.7.28.jar</span><br><span class=\"line\">│       ├── snakeyaml-1.25.jar</span><br><span class=\"line\">│       ├── spring-xxx.jar   # 表示 spring 相关的依赖简写</span><br><span class=\"line\">├── META-INF</span><br><span class=\"line\">│   ├── MANIFEST.MF</span><br><span class=\"line\">│   └── maven</span><br><span class=\"line\">│       └── com.glmapper.bridge.boot</span><br><span class=\"line\">│           └── guides-for-jarlaunch</span><br><span class=\"line\">│               ├── pom.properties</span><br><span class=\"line\">│               └── pom.xml</span><br><span class=\"line\">└── org</span><br><span class=\"line\">    └── springframework</span><br><span class=\"line\">        └── boot</span><br><span class=\"line\">            └── loader</span><br><span class=\"line\">                ├── ExecutableArchiveLauncher.class</span><br><span class=\"line\">                ├── JarLauncher.class</span><br><span class=\"line\">                ├── LaunchedURLClassLoader$UseFastConnectionExceptionsEnumeration.class</span><br><span class=\"line\">                ├── LaunchedURLClassLoader.class</span><br><span class=\"line\">                ├── Launcher.class</span><br><span class=\"line\">                ├── MainMethodRunner.class</span><br><span class=\"line\">                ├── PropertiesLauncher$1.class</span><br><span class=\"line\">                ├── PropertiesLauncher$ArchiveEntryFilter.class</span><br><span class=\"line\">                ├── PropertiesLauncher$PrefixMatchingArchiveFilter.class</span><br><span class=\"line\">                ├── PropertiesLauncher.class</span><br><span class=\"line\">                ├── WarLauncher.class</span><br><span class=\"line\">                ├── archive</span><br><span class=\"line\">                │   ├── # 省略</span><br><span class=\"line\">                ├── data</span><br><span class=\"line\">                │   ├── # 省略</span><br><span class=\"line\">                ├── jar</span><br><span class=\"line\">                │   ├── # 省略</span><br><span class=\"line\">                └── util</span><br><span class=\"line\">                    └── SystemPropertyUtils.class</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>简单来看，FatJar 解压之后包括三个文件夹：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── BOOT-INF # 存放的是业务相关的，包括业务开发的类和配置文件，以及依赖的jar</span><br><span class=\"line\">│   ├── classes</span><br><span class=\"line\">│   └── lib</span><br><span class=\"line\">├── META-INF # 包括 MANIFEST.MF 描述文件和 maven 的构建信息</span><br><span class=\"line\">│   ├── MANIFEST.MF</span><br><span class=\"line\">│   └── maven</span><br><span class=\"line\">└── org # SpringBoot 相关的类</span><br><span class=\"line\">    └── springframework</span><br></pre></td></tr></table></figure>\n\n<p>我们平时在 debug SpringBoot 工程的启动流程时，一般都是从 SpringApplication#run 方法开始</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BootStrap</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 入口</span></span><br><span class=\"line\">        SpringApplication.run(BootStrap.class,args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于 java 程序来说，我们知道启动入口必须有 main 函数，这里看起来是符合条件的，但是有一点就是，通过 java 指令执行一个带有 main 函数的类时，是不需要有 -jar 参数的，比如新建一个 BootStrap.java 文件，内容为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BootStrap</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过 javac 编译此文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javac BootStrap.java</span><br></pre></td></tr></table></figure>\n<p>然后就可以得到编译之后的 .class 文件 BootStrap.class ，此时可以通过 java 指令直接执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java BootStrap  <span class=\"comment\"># 输出 Hello World</span></span><br></pre></td></tr></table></figure>\n\n<p>那么对于 java -jar 呢？这个其实在 <a href=\"https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html\">java 的官方文档</a> 中是有明确描述的：</p>\n<ul>\n<li>-jar filename</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Executes a program encapsulated in a JAR file. The filename argument is the name of a JAR file with a manifest that contains a line in the form Main-Class:classname that defines the class with the public static void main(String[] args) method that serves as your application’s starting point.</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>When you use the -jar option, the specified JAR file is the source of all user classes, and other class path settings are ignored.</p></blockquote>\n<p>简单说就是，java -jar 命令引导的具体启动类必须配置在 MANIFEST.MF 资源的 Main-Class 属性中。</p>\n<p>那回过头再去看下之前打包好、解压之后的文件目录，找到 &#x2F;META-INF&#x2F;MANIFEST.MF 文件，看下元数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Manifest-Version: 1.0</span><br><span class=\"line\">Implementation-Title: guides-for-jarlaunch</span><br><span class=\"line\">Implementation-Version: 0.0.1-SNAPSHOT</span><br><span class=\"line\">Start-Class: com.glmapper.bridge.boot.BootStrap</span><br><span class=\"line\">Spring-Boot-Classes: BOOT-INF/classes/</span><br><span class=\"line\">Spring-Boot-Lib: BOOT-INF/lib/</span><br><span class=\"line\">Build-Jdk-Spec: 1.8</span><br><span class=\"line\">Spring-Boot-Version: 2.2.0.RELEASE</span><br><span class=\"line\">Created-By: Maven Archiver 3.4.0</span><br><span class=\"line\"># Main-Class 在这里，指向的是 JarLauncher</span><br><span class=\"line\">Main-Class: org.springframework.boot.loader.JarLauncher</span><br></pre></td></tr></table></figure>\n\n<p>org.springframework.boot.loader.JarLauncher 类存放在 org&#x2F;springframework&#x2F;boot&#x2F;loader 下面：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">└── boot</span><br><span class=\"line\">    └── loader</span><br><span class=\"line\">        ├── ExecutableArchiveLauncher.class</span><br><span class=\"line\">        ├── JarLauncher.class  # JarLauncher</span><br><span class=\"line\">        ├── # 省略</span><br></pre></td></tr></table></figure>\n<p>这样就基本理清楚了， FatJar 中，org.springframework.boot.loader 下面的类负责引导启动 SpringBoot 工程，作为入口，BOOT-INF 中存放业务代码和依赖，META-INF 下存在元数据描述。</p>\n<h2 id=\"JarLaunch-FatJar-的启动器\"><a href=\"#JarLaunch-FatJar-的启动器\" class=\"headerlink\" title=\"JarLaunch - FatJar 的启动器\"></a>JarLaunch - FatJar 的启动器</h2><p>在分析 JarLaunch 之前，这里插一下，org.springframework.boot.loader 下的这些类是如何被打包在 FatJar 里面的</p>\n<h3 id=\"spring-boot-maven-plugin-打包-spring-boot-loader-过程\"><a href=\"#spring-boot-maven-plugin-打包-spring-boot-loader-过程\" class=\"headerlink\" title=\"spring-boot-maven-plugin 打包 spring-boot-loader 过程\"></a>spring-boot-maven-plugin 打包 spring-boot-loader 过程</h3><p>因为在新建的空的 SpringBoot 工程中并没有任何地方显示的引入或者编写相关的类。实际上，对于每个新建的 SpringBoot 工程，可以在其 pom.xml 文件中看到如下插件：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这个是 SpringBoot 官方提供的用于打包 FatJar 的插件，org.springframework.boot.loader 下的类其实就是通过这个插件打进去的；</p>\n<p>下面是此插件将 loader 相关类打入 FatJar 的一个执行流程：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>org.springframework.boot.maven#execute-&gt;<br>org.springframework.boot.maven#repackage -&gt; org.springframework.boot.loader.tools.Repackager#repackage-&gt;<br>org.springframework.boot.loader.tools.Repackager#writeLoaderClasses-&gt;<br>org.springframework.boot.loader.tools.JarWriter#writeLoaderClasses</p></blockquote>\n<p>最终的执行方法就是下面这个方法，通过注释可以看出，该方法的作用就是将 spring-boot-loader 的classes 写入到 FatJar 中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Write the required spring-boot-loader classes to the JAR.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> IOException if the classes cannot be written</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">writeLoaderClasses</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">\twriteLoaderClasses(NESTED_LOADER_JAR);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JarLaunch-基本原理\"><a href=\"#JarLaunch-基本原理\" class=\"headerlink\" title=\"JarLaunch 基本原理\"></a>JarLaunch 基本原理</h3><p>基于前面的分析，这里考虑一个问题，能否直接通过 java BootStrap 来直接运行 SpringBoot 工程呢？这样在不需要 -jar 参数和 JarLaunch 引导的情况下，直接使用最原始的 java 指令理论上是不是也可以，因为有 main 方法。</p>\n<h4 id=\"通过-java-BootStrap-方式启动\"><a href=\"#通过-java-BootStrap-方式启动\" class=\"headerlink\" title=\"通过 java BootStrap 方式启动\"></a>通过 <code>java BootStrap</code> 方式启动</h4><p>BootStrap 类的如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BootStrap</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(BootStrap.class,args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译之后，执行 <code>java com.glmapper.bridge.boot.BootStrap</code>，然后抛出异常了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: org/springframework/boot/SpringApplication</span><br><span class=\"line\">        at com.glmapper.bridge.boot.BootStrap.main(BootStrap.java:13)</span><br><span class=\"line\">Caused by: java.lang.ClassNotFoundException: org.springframework.boot.SpringApplication</span><br><span class=\"line\">        at java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class=\"line\">        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class=\"line\">        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338)</span><br><span class=\"line\">        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class=\"line\">        ... 1 more</span><br></pre></td></tr></table></figure>\n<p>从异常堆栈来看，是因为找不到 SpringApplication 这个类；这里其实还是比较好理解的，BootStrap 类中引入了 SpringApplication，但是这个类是在 BOOT-INF&#x2F;lib 下的，而 java 指令在启动时也没有指定 class path 。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里不再赘述，通过 -classpath + -Xbootclasspath 的方式尝试了下，貌似也不行，如果有通过 java 指令直接运行成功的，欢迎留言沟通。</p></blockquote>\n<h4 id=\"通过-java-JarLaunch-启动\"><a href=\"#通过-java-JarLaunch-启动\" class=\"headerlink\" title=\"通过 java JarLaunch 启动\"></a>通过 <code>java JarLaunch 启动</code></h4><p>再通过 <code>java org.springframework.boot.loader.JarLauncher</code> 方式启动，可以看到是可以的。</p>\n<p><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/jarlaunch/jarlaunch-two.jpg\"></p>\n<p>那这里基本可以猜到，JarLauncher 方式启动时，一定会通过某种方式将所需要依赖的 JAR 文件作为 BootStrap 的依赖引入进来。下面就来简单分析下 JarLauncher 启动时，作为启动引导类，它做了哪些事情。</p>\n<h4 id=\"基本原理分析\"><a href=\"#基本原理分析\" class=\"headerlink\" title=\"基本原理分析\"></a>基本原理分析</h4><p>JarLaunch 类的定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JarLauncher</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ExecutableArchiveLauncher</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// BOOT-INF/classes/</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">BOOT_INF_CLASSES</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;BOOT-INF/classes/&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// BOOT-INF/lib/</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">BOOT_INF_LIB</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;BOOT-INF/lib/&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 空构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">JarLauncher</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 带有指定 Archive 的构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"title function_\">JarLauncher</span><span class=\"params\">(Archive archive)</span> &#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">super</span>(archive);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 是否是可嵌套的对象</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isNestedArchive</span><span class=\"params\">(Archive.Entry entry)</span> &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (entry.isDirectory()) &#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">return</span> entry.getName().equals(BOOT_INF_CLASSES);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> entry.getName().startsWith(BOOT_INF_LIB);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// main 函数</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">new</span> <span class=\"title class_\">JarLauncher</span>().launch(args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过代码，我们很明显可以看到几个关键的信息点：</p>\n<ul>\n<li><code>BOOT_INF_CLASSES</code> 和 <code>BOOT_INF_LIB</code>  两个常量对应的是前面解压之后的两个文件目录</li>\n<li>JarLaunch 中包含一个 main 函数，作为启动入口</li>\n</ul>\n<p>但是单从 main 来看，只是构造了一个 JarLaunch 对象，然后执行其 launch 方法，并没有我们期望看到的构建所需依赖的地方。实际上这部分是在 JarLaunch 的父类 ExecutableArchiveLauncher 的构造函数中来完成的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ExecutableArchiveLauncher</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 构建 archive </span></span><br><span class=\"line\">    \t<span class=\"built_in\">this</span>.archive = createArchive();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 构建 Archive</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> Archive <span class=\"title function_\">createArchive</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"type\">ProtectionDomain</span> <span class=\"variable\">protectionDomain</span> <span class=\"operator\">=</span> getClass().getProtectionDomain();</span><br><span class=\"line\">    <span class=\"type\">CodeSource</span> <span class=\"variable\">codeSource</span> <span class=\"operator\">=</span> protectionDomain.getCodeSource();</span><br><span class=\"line\">    <span class=\"type\">URI</span> <span class=\"variable\">location</span> <span class=\"operator\">=</span> (codeSource != <span class=\"literal\">null</span>) ? codeSource.getLocation().toURI() : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 这里就是拿到当前的 classpath </span></span><br><span class=\"line\">    <span class=\"comment\">// /Users/xxx/Documents/test/glmapper-springboot-study-guides/guides-for-jarlaunch/target/mock/</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> (location != <span class=\"literal\">null</span>) ? location.getSchemeSpecificPart() : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;Unable to determine code source archive&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">root</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(path);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root.exists()) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;Unable to determine code source archive from &quot;</span> + root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 构建 Archive </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (root.isDirectory() ? <span class=\"keyword\">new</span> <span class=\"title class_\">ExplodedArchive</span>(root) : <span class=\"keyword\">new</span> <span class=\"title class_\">JarFileArchive</span>(root));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>PS: 关于 Archive 的概念这里由于篇幅有限，不再展开说明。</p></blockquote>\n<p>通过上面构建了一个 Archive ，然后继续执行 launch 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">launch</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注册协议，利用了 java.net.URLStreamHandler 的扩展机制，SpringBoot</span></span><br><span class=\"line\">    <span class=\"comment\">// 扩展出了一种可以解析 jar in jar 的协议</span></span><br><span class=\"line\">    JarFile.registerUrlProtocolHandler();</span><br><span class=\"line\">    <span class=\"comment\">// 通过 classpath 来构建一个 ClassLoader</span></span><br><span class=\"line\">    <span class=\"type\">ClassLoader</span> <span class=\"variable\">classLoader</span> <span class=\"operator\">=</span> createClassLoader(getClassPathArchives());</span><br><span class=\"line\">    <span class=\"comment\">// launch </span></span><br><span class=\"line\">    launch(args, getMainClass(), classLoader);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面值需要关注下 getMainClass() 方法即可，这里就是获取 MENIFEST.MF 中指定的 Start-Class ，实际上就是我们的工程里面的 BootStrap 类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> String <span class=\"title function_\">getMainClass</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从 archive 中拿到 Manifest</span></span><br><span class=\"line\">    <span class=\"type\">Manifest</span> <span class=\"variable\">manifest</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.archive.getManifest();</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">mainClass</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (manifest != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取 Start-Class</span></span><br><span class=\"line\">    \tmainClass = manifest.getMainAttributes().getValue(<span class=\"string\">&quot;Start-Class&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mainClass == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(</span><br><span class=\"line\">    \t\t\t<span class=\"string\">&quot;No &#x27;Start-Class&#x27; manifest entry specified in &quot;</span> + <span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回 mainClass</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mainClass;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终是通过构建了一个 MainMethodRunner 实例对象，然后通过反射的方式调用了 BootStrap 类中的 main 方法：</p>\n<p><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/jarlaunch/jarlaunch-three.jpg\"></p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本文主要从 JarLaunch 的角度分析了下 SpringBoot 的启动方式，对常规 java 方式和 java -jar 等启动方式进行了简单的演示；同时简单阐述了下 JarLaunch 启动的基本工作原理。对于其中 构建 Archive 、自定义协议 Handler 等未做深入探究，后面也会针对相关点再做单独分析。</p>\n","text":"之前有写过一篇文章来介绍 JAR 文件和 MENIFEST.MF 文件，详见：聊一聊 JAR 文件和 MANIFEST.MF，在这篇文章中介绍了 JAR 文件的...","permalink":"/post/springboot/springboot-series-fatjar","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/categories/SpringBoot.json"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/tags/SpringBoot.json"},{"name":"FatJar","slug":"FatJar","count":1,"path":"api/tags/FatJar.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#FatJar-%E8%A7%A3%E5%8E%8B%E4%B9%8B%E5%90%8E%E7%9A%84%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">FatJar 解压之后的文件目录</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JarLaunch-FatJar-%E7%9A%84%E5%90%AF%E5%8A%A8%E5%99%A8\"><span class=\"toc-text\">JarLaunch - FatJar 的启动器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#spring-boot-maven-plugin-%E6%89%93%E5%8C%85-spring-boot-loader-%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">spring-boot-maven-plugin 打包 spring-boot-loader 过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JarLaunch-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">JarLaunch 基本原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87-java-BootStrap-%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8\"><span class=\"toc-text\">通过 java BootStrap 方式启动</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87-java-JarLaunch-%E5%90%AF%E5%8A%A8\"><span class=\"toc-text\">通过 java JarLaunch 启动</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90\"><span class=\"toc-text\">基本原理分析</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"SpringBoot 源码系列-启动过程分析","uid":"fb1d63795354398f9ac651e5b767f565","slug":"springboot/springboot-series-started","date":"2019-12-07T09:41:01.000Z","updated":"2024-07-05T04:09:05.831Z","comments":true,"path":"api/articles/springboot/springboot-series-started.json","keywords":null,"cover":[],"text":"SpringBoot 作为目前非常流行的微服务框架，它使得构建独立的 Spring 生产级应用变得非常简单，因此受到很多互联网企业的青睐。 最近在写 SOFAT...","permalink":"/post/springboot/springboot-series-started","photos":[],"count_time":{"symbolsCount":"22k","symbolsTime":"20 mins."},"categories":[{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/categories/SpringBoot.json"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/tags/SpringBoot.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"SpringBoot 源码系列-内嵌 Tomcat 的实现原理解析","uid":"beab21777c0d79f5d1291c48820f6305","slug":"springboot/springboot-series-server-tomcat","date":"2019-10-06T09:48:43.000Z","updated":"2024-07-05T04:09:05.831Z","comments":true,"path":"api/articles/springboot/springboot-series-server-tomcat.json","keywords":null,"cover":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/tomcat-boot-one.jpg","text":"对于一个 SpringBoot web 工程来说，一个主要的依赖标志就是有 spring-boot-starter-web 这个 starter ，spring...","permalink":"/post/springboot/springboot-series-server-tomcat","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/categories/SpringBoot.json"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/tags/SpringBoot.json"},{"name":"tomcat","slug":"tomcat","count":1,"path":"api/tags/tomcat.json"},{"name":"Embedded Tomcat","slug":"Embedded-Tomcat","count":1,"path":"api/tags/Embedded-Tomcat.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}