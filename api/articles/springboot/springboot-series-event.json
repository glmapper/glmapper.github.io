{"title":"SpringBoot 源码系列-事件机制详解","uid":"7b12c81b8791d99dc46d122cdc93aac5","slug":"springboot/springboot-series-event","date":"2019-04-13T09:53:12.000Z","updated":"2024-07-05T04:09:05.828Z","comments":true,"path":"api/articles/springboot/springboot-series-event.json","keywords":null,"cover":[],"content":"<p>在这篇文章中<a href=\"https://juejin.im/post/5b7964d6f265da43412866c7\">聊一聊 Spring 中的扩展机制（一）</a>中对<code>Spring</code>中的事件机制进行了分析。那么对于 <code>SpringBoot</code> 来说，它在 <code>Spring</code> 的基础上又做了哪些拓展呢？本篇将来聊一聊 <code>SpringBoot</code> 中的事件。</p>\n<span id=\"more\"></span>\n\n<p>在 SpringBoot 的启动过程中，会通过 SPI 机制去加载 spring.factories 下面的一些类，这里面就包括了事件相关的类。</p>\n<ul>\n<li>SpringApplicationRunListener<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Run Listeners</span><br><span class=\"line\">org.springframework.boot.SpringApplicationRunListener=\\</span><br><span class=\"line\">org.springframework.boot.context.event.EventPublishingRunListener</span><br></pre></td></tr></table></figure></li>\n<li>ApplicationListener<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Application Listeners</span><br><span class=\"line\">org.springframework.context.ApplicationListener=\\</span><br><span class=\"line\">org.springframework.boot.ClearCachesApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.builder.ParentContextCloserApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.FileEncodingApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.config.AnsiOutputApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.config.ConfigFileApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.config.DelegatingApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.logging.LoggingApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p> <code>SpringApplicationRunListener</code> 类是 <code>SpringBoot</code> 中新增的类。<code>SpringApplication</code> 类 中使用它们来间接调用 <code>ApplicationListener</code>。另外还有一个新增的类是<code>SpringApplicationRunListeners</code>，<code>SpringApplicationRunListeners</code> 中包含了多个 <code>SpringApplicationRunListener</code>。</p>\n<h2 id=\"SpringApplicationRunListener\"><a href=\"#SpringApplicationRunListener\" class=\"headerlink\" title=\"SpringApplicationRunListener\"></a>SpringApplicationRunListener</h2><p> <code>SpringApplicationRunListener</code> 接口规定了 <code>SpringBoot</code> 的生命周期，在各个生命周期广播相应的事件，调用实际的 <code>ApplicationListener</code> 类。通过对 <code>SpringApplicationRunListener</code> 的分析，也可以对 <code>SpringBoot</code> 的整个启动过程的理解会有很大帮助。</p>\n<p> 先来看下<code>SpringApplicationRunListener</code> 接口的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">SpringApplicationRunListener</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//当run方法首次启动时立即调用。可用于非常早期的初始化。</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">starting</span><span class=\"params\">()</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//在准备好环境后，但在创建ApplicationContext之前调用。</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">environmentPrepared</span><span class=\"params\">(ConfigurableEnvironment environment)</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//在创建和准备好ApplicationContext之后，但在加载源之前调用。</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">contextPrepared</span><span class=\"params\">(ConfigurableApplicationContext context)</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//在加载应用程序上下文后但刷新之前调用</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">contextLoaded</span><span class=\"params\">(ConfigurableApplicationContext context)</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//上下文已刷新，应用程序已启动，但尚未调用commandlinerunner和applicationrunner。</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">started</span><span class=\"params\">(ConfigurableApplicationContext context)</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//在运行方法完成之前立即调用，此时应用程序上下文已刷新，</span></span><br><span class=\"line\">\t<span class=\"comment\">//并且所有commandlinerunner和applicationrunner都已调用。</span></span><br><span class=\"line\">\t<span class=\"comment\">//2.0 才有</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">running</span><span class=\"params\">(ConfigurableApplicationContext context)</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//在运行应用程序时发生故障时调用。2.0 才有</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">failed</span><span class=\"params\">(ConfigurableApplicationContext context, Throwable exception)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"SpringApplicationRunListeners\"><a href=\"#SpringApplicationRunListeners\" class=\"headerlink\" title=\"SpringApplicationRunListeners\"></a>SpringApplicationRunListeners</h2><p>上面提到，<code>SpringApplicationRunListeners</code> 是<code>SpringApplicationRunListener</code>的集合，里面包括了很多<code>SpringApplicationRunListener</code>实例；<code>SpringApplication</code> 类实际上使用的是 <code>SpringApplicationRunListeners</code> 类，与 <code>SpringApplicationRunListener</code> 生命周期相同，调用各个周期的 <code>SpringApplicationRunListener</code> 。然后广播相应的事件到 <code>ApplicationListener</code>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>代码详见：<a href=\"https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/SpringApplicationRunListeners.java\">SpringApplicationRunListeners</a>.</p></blockquote>\n<h3 id=\"EventPublishingRunListener\"><a href=\"#EventPublishingRunListener\" class=\"headerlink\" title=\"EventPublishingRunListener\"></a>EventPublishingRunListener</h3><p><code>EventPublishingRunListener</code> 类是 <code>SpringApplicationRunListener</code>接口的实现类 ，它具有广播事件的功能。其内部使用 <code>ApplicationEventMulticaster</code>在实际刷新上下文之前发布事件。下面来看下 <code>EventPublishingRunListener</code> 类生命周期对应的事件。</p>\n<h3 id=\"ApplicationStartingEvent\"><a href=\"#ApplicationStartingEvent\" class=\"headerlink\" title=\"ApplicationStartingEvent\"></a>ApplicationStartingEvent</h3><p><code>ApplicationStartingEvent</code> 是 <code>SpringBoot</code> 启动开始的时候执行的事件，在该事件中可以获取到 <code>SpringApplication</code> 对象，可做一些执行前的设置，对应的调用方法是 <code>starting()</code>。</p>\n<h3 id=\"ApplicationEnvironmentPreparedEvent\"><a href=\"#ApplicationEnvironmentPreparedEvent\" class=\"headerlink\" title=\"ApplicationEnvironmentPreparedEvent\"></a>ApplicationEnvironmentPreparedEvent</h3><p><code>ApplicationEnvironmentPreparedEvent</code> 是<code>SpringBoot</code> 对应 <code>Enviroment</code> 已经准备完毕时执行的事件，此时上下文 <code>context</code> 还没有创建。在该监听中获取到 <code>ConfigurableEnvironment</code> 后可以对配置信息做操作，例如：修改默认的配置信息，增加额外的配置信息等。对应的生命周期方法是 <code>environmentPrepared(environment)</code>；<code>SpringCloud</code> 中，引导上下文就是在这时初始化的。</p>\n<h3 id=\"ApplicationContextInitializedEvent\"><a href=\"#ApplicationContextInitializedEvent\" class=\"headerlink\" title=\"ApplicationContextInitializedEvent\"></a>ApplicationContextInitializedEvent</h3><p>当 <code>SpringApplication</code> 启动并且准备好 <code>ApplicationContext</code>，并且在加载任何 <code>bean</code> 定义之前调用了 <code>ApplicationContextInitializers</code> 时发布的事件。对应的生命周期方法是<code>contextPrepared()</code></p>\n<h3 id=\"ApplicationPreparedEvent\"><a href=\"#ApplicationPreparedEvent\" class=\"headerlink\" title=\"ApplicationPreparedEvent\"></a>ApplicationPreparedEvent</h3><p><code>ApplicationPreparedEvent</code> 是<code>SpringBoot</code>上下文 <code>context</code> 创建完成是发布的事件；但此时 <code>spring</code> 中的 <code>bean</code> 还没有完全加载完成。这里可以将上下文传递出去做一些额外的操作。但是在该监听器中是无法获取自定义 <code>bean</code> 并进行操作的。对应的生命周期方法是 <code>contextLoaded()</code>。</p>\n<h3 id=\"ApplicationStartedEvent\"><a href=\"#ApplicationStartedEvent\" class=\"headerlink\" title=\"ApplicationStartedEvent\"></a>ApplicationStartedEvent</h3><p>这个事件是在 2.0 版本才引入的；具体发布是在应用程序上下文刷新之后，调用任何 <code>ApplicationRunner</code> 和 <code>CommandLineRunner</code> 运行程序之前。</p>\n<h3 id=\"ApplicationReadyEvent\"><a href=\"#ApplicationReadyEvent\" class=\"headerlink\" title=\"ApplicationReadyEvent\"></a>ApplicationReadyEvent</h3><p>这个和 <code>ApplicationStartedEvent</code> 很类似，也是在应用程序上下文刷新之后之后调用，区别在于此时<code>ApplicationRunner</code> 和 <code>CommandLineRunner</code>已经完成调用了，也意味着 <code>SpringBoot</code> 加载已经完成。</p>\n<h3 id=\"ApplicationFailedEvent\"><a href=\"#ApplicationFailedEvent\" class=\"headerlink\" title=\"ApplicationFailedEvent\"></a>ApplicationFailedEvent</h3><p><code>SpringBoot</code> 启动异常时执行的事件，在异常发生时，最好是添加虚拟机对应的钩子进行资源的回收与释放，能友善的处理异常信息。</p>\n<h3 id=\"demo-及各个事件的执行顺序\"><a href=\"#demo-及各个事件的执行顺序\" class=\"headerlink\" title=\"demo 及各个事件的执行顺序\"></a>demo 及各个事件的执行顺序</h3><p>下面的各个事件对应的demo及打印出来的执行顺序。</p>\n<ul>\n<li>GlmapperApplicationStartingEventListener<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GlmapperApplicationStartingEventListener</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ApplicationListener</span>&lt;ApplicationStartingEvent&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onApplicationEvent</span><span class=\"params\">(ApplicationStartingEvent applicationStartingEvent)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;execute ApplicationStartingEvent ...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>GlmapperApplicationEnvironmentPreparedEvent</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GlmapperApplicationEnvironmentPreparedEvent</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ApplicationListener</span>&lt;ApplicationEnvironmentPreparedEvent&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onApplicationEvent</span><span class=\"params\">(ApplicationEnvironmentPreparedEvent applicationEnvironmentPreparedEvent)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;execute ApplicationEnvironmentPreparedEvent ...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>GlmapperApplicationContextInitializedEvent</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GlmapperApplicationContextInitializedEvent</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ApplicationListener</span>&lt;ApplicationContextInitializedEvent&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onApplicationEvent</span><span class=\"params\">(ApplicationContextInitializedEvent applicationContextInitializedEvent)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;execute applicationContextInitializedEvent ...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>GlmapperApplicationPreparedEvent</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class GlmapperApplicationPreparedEvent implements ApplicationListener&lt;ApplicationPreparedEvent&gt; &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onApplicationEvent(ApplicationPreparedEvent applicationPreparedEvent) &#123;</span><br><span class=\"line\">        System.out.println(&quot;execute ApplicationPreparedEvent ...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>GlmapperApplicationStartedEvent</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GlmapperApplicationStartedEvent</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ApplicationListener</span>&lt;ApplicationStartedEvent&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onApplicationEvent</span><span class=\"params\">(ApplicationStartedEvent applicationStartedEvent)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;execute ApplicationStartedEvent ...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>GlmapperApplicationReadyEvent</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GlmapperApplicationReadyEvent</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ApplicationListener</span>&lt;ApplicationReadyEvent&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onApplicationEvent</span><span class=\"params\">(ApplicationReadyEvent applicationReadyEvent)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;execute ApplicationReadyEvent ...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>执行结果</li>\n</ul>\n<p><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-one.jpg\"></p>\n<h2 id=\"SpringBoot-中的事件体系\"><a href=\"#SpringBoot-中的事件体系\" class=\"headerlink\" title=\"SpringBoot 中的事件体系\"></a>SpringBoot 中的事件体系</h2><p>这里围绕 <code>SpringApplicationRunListener</code> 这个类来说。在实现类 <code>EventPublishingRunListener</code> 中，事件发布有两种模式：</p>\n<ul>\n<li>通过 <code>SimpleApplicationEventMulticaster</code> 进行事件广播</li>\n<li>所有监听器交给相应的 <code>Context</code></li>\n</ul>\n<p>所以<code>EventPublishingRunListener</code> 不仅负责发布事件，而且在合适的时机将 <code>SpringApplication</code> 所获取的监听器和应用上下文作关联。</p>\n<h3 id=\"SimpleApplicationEventMulticaster\"><a href=\"#SimpleApplicationEventMulticaster\" class=\"headerlink\" title=\"SimpleApplicationEventMulticaster\"></a>SimpleApplicationEventMulticaster</h3><p><code>SimpleApplicationEventMulticaster</code>是 <code>Spring</code> 默认的事件广播器。来看下它是怎么工作的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">multicastEvent</span><span class=\"params\">(<span class=\"keyword\">final</span> ApplicationEvent event, <span class=\"meta\">@Nullable</span> ResolvableType eventType)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ResolvableType</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> (eventType != <span class=\"literal\">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class=\"line\">        <span class=\"type\">Executor</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span> getTaskExecutor();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (executor != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            invokeListener(listener, event);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码段可以看出，它是通过遍历注册的每个监听器，并启动来调用每个监听器的 <code>onApplicationEvent</code> 方法。</p>\n<p>下面再来看下 <code>SimpleApplicationEventMulticaster</code> 的类集成结构：<br><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-two.jpg\"><br>这里的 <code>AbstractApplicationContext</code> 下面来聊，这个类实际上就负责了事件体系的初始化工作。</p>\n<h3 id=\"事件体系的初始化\"><a href=\"#事件体系的初始化\" class=\"headerlink\" title=\"事件体系的初始化\"></a>事件体系的初始化</h3><p>事件体系的初始化对应在 <code>SpringBoot</code>启动过程的 <code>refreshContext</code>这个方法；<code>refreshContext</code>具体调用 AbstractApplicationContext.refresh()方法，最后调用 initApplicationEventMulticaster() 来完成事件体系的初始化,代码如下：</p>\n<p><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-three.jpg\"></p>\n<p>用户可以为容器定义一个自定义的事件广播器，只要实现 <code>ApplicationEventMulticaster</code> 就可以了，<code>Spring</code> 会通过 反射的机制将其注册成容器的事件广播器，如果没有找到配置的外部事件广播器，<code>Spring</code> 就是默认使用 <code>SimpleApplicationEventMulticaster</code> 作为事件广播器。</p>\n<h3 id=\"事件注册\"><a href=\"#事件注册\" class=\"headerlink\" title=\"事件注册\"></a>事件注册</h3><p>事件注册是在事件体系初始化完成之后做的事情，也是在 <code>AbstractApplicationContext.refresh()</code> 方法中进行调用的。</p>\n<p><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-four.jpg\"><br>这里干了三件事：</p>\n<ul>\n<li>首先注册静态指定的 <code>listeners</code>；这里包括我们自定义的那些监听器。</li>\n<li>调用 <code>DefaultListableBeanFactory</code> 中 <code>getBeanNamesForType</code> 得到自定义的 <code>ApplicationListener</code> <code>bean</code> 进行事件注册。</li>\n<li>广播早期的事件。</li>\n</ul>\n<h3 id=\"事件广播\"><a href=\"#事件广播\" class=\"headerlink\" title=\"事件广播\"></a>事件广播</h3><p>事件发布伴随着 <code>SpringBoot</code> 启动的整个生命周期。不同阶段对应发布不同的事件，上面我们已经对各个事件进行了分析，下面就具体看下发布事件的实现：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>org.springframework.context.support.AbstractApplicationContext#publishEvent<br><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-five.jpg\"></p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>earlyApplicationEvents 中的事件是广播器未建立的时候保存通知信息，一旦容器建立完成，以后都是直接通知。</p></blockquote>\n<p>广播事件最终还是通过调用 <code>ApplicationEventMulticaster</code> 的 <code>multicastEvent</code> 来实现。而 <code>multicastEvent</code> 也就就是事件执行的方法。</p>\n<h3 id=\"事件执行\"><a href=\"#事件执行\" class=\"headerlink\" title=\"事件执行\"></a>事件执行</h3><p>上面 <code>SimpleApplicationEventMulticaster</code> 小节已经初步介绍了 <code>multicastEvent</code> 这个方法。补充一点， 如果有可用的 <code>taskExecutor</code> 会使用并发的模式执行事件，但是实际上 <code>SimpleApplicationEventMulticaster</code> 并没有提供线程池实现，默认请况下是使用同步的方式执行事件（<code>org.springframework.core.task.SyncTaskExecutor</code>），所以如果需要异步配置的话，需要自己去实现线程池。</p>\n<h2 id=\"SpringBoot-启动过程中的事件阶段\"><a href=\"#SpringBoot-启动过程中的事件阶段\" class=\"headerlink\" title=\"SpringBoot 启动过程中的事件阶段\"></a>SpringBoot 启动过程中的事件阶段</h2><p>这里回到 <code>SpringApplication</code>的<code>run</code>方法，看下 <code>SpringBoot</code> 在启动过程中，各个事件阶段做了哪些事情。</p>\n<h3 id=\"starting-ApplicationStartingEvent\"><a href=\"#starting-ApplicationStartingEvent\" class=\"headerlink\" title=\"starting -&gt; ApplicationStartingEvent\"></a>starting -&gt; ApplicationStartingEvent</h3><p>这里 <code>debug</code> 到 <code>starting</code> 方法，追踪到 <code>multicastEvent</code>，这里 <code>type</code>为 <code>ApplicationStartingEvent</code>；对应的事件如下：<br><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-six.jpg\"></p>\n<ul>\n<li>LoggerApplicationListener：配置日志系统。使用<code>logging.config</code>环境变量指定的配置或者缺省配置</li>\n<li>BackgroundPreinitializer：尽早触发一些耗时的初始化任务，使用一个后台线程</li>\n<li>DelegatingApplicationListener：监听到事件后转发给环境变量<code>context.listener.classes</code>指定的那些事件监听器</li>\n<li>LiquibaseServiceLocatorApplicationListener：使用一个可以和 <code>SpringBoot</code> 可执行<code>jar</code>包配合工作的版本替换 <code>liquibase ServiceLocator</code></li>\n</ul>\n<h3 id=\"listeners-environmentPrepared-ApplicationEnvironmentPreparedEvent\"><a href=\"#listeners-environmentPrepared-ApplicationEnvironmentPreparedEvent\" class=\"headerlink\" title=\"listeners.environmentPrepared-&gt;ApplicationEnvironmentPreparedEvent\"></a>listeners.environmentPrepared-&gt;ApplicationEnvironmentPreparedEvent</h3><p><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-seven.jpg\"></p>\n<ul>\n<li><p>AnsiOutputApplicationListener：根据<code>spring.output.ansi.enabled</code>参数配置<code>AnsiOutput</code></p>\n</li>\n<li><p>ConfigFileApplicationListener：<code>EnvironmentPostProcessor</code>，从常见的那些约定的位置读取配置文件，比如从以下目录读取<code>application.properties</code>,<code>application.yml</code>等配置文件：</p>\n<ul>\n<li>classpath:</li>\n<li>file:.</li>\n<li>classpath:config</li>\n<li>file:.&#x2F;config&#x2F;</li>\n</ul>\n<p>  也可以配置成从其他指定的位置读取配置文件。</p>\n</li>\n<li><p>ClasspathLoggingApplicationListener：对环境就绪事件<code>ApplicationEnvironmentPreparedEvent</code>&#x2F;应用失败事<code>件ApplicationFailedEvent</code>做出响应，往日志<code>DEBUG</code>级别输出<code>TCCL(thread context class loader)</code>的 <code>classpath</code>。</p>\n</li>\n<li><p>FileEncodingApplicationListener：如果系统文件编码和环境变量中指定的不同则终止应用启动。具体的方法是比较系统属性<code>file.encoding</code>和环境变量<code>spring.mandatory-file-encoding</code>是否相等(大小写不敏感)。</p>\n</li>\n</ul>\n<h3 id=\"listeners-contextPrepared-ApplicationContextInitializedEvent\"><a href=\"#listeners-contextPrepared-ApplicationContextInitializedEvent\" class=\"headerlink\" title=\"listeners.contextPrepared-&gt;ApplicationContextInitializedEvent\"></a>listeners.contextPrepared-&gt;ApplicationContextInitializedEvent</h3><p><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-eight.jpg\"><br>相关监听器参考上面的描述。</p>\n<h3 id=\"listeners-contextLoaded-ApplicationPreparedEvent\"><a href=\"#listeners-contextLoaded-ApplicationPreparedEvent\" class=\"headerlink\" title=\"listeners.contextLoaded-&gt;ApplicationPreparedEvent\"></a>listeners.contextLoaded-&gt;ApplicationPreparedEvent</h3><p><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-12.jpg\"><br>相关监听器参考上面的描述。</p>\n<h3 id=\"refresh-ContextRefreshedEvent\"><a href=\"#refresh-ContextRefreshedEvent\" class=\"headerlink\" title=\"refresh-&gt;ContextRefreshedEvent\"></a>refresh-&gt;ContextRefreshedEvent</h3><p><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-nine.jpg\"></p>\n<ul>\n<li>ConditionEvaluationReportLoggingListener：实际上实现的是 <code>ApplicationContextInitializer</code>接口，其目的是将 <code>ConditionEvaluationReport</code> 写入到日志，使用<code>DEBUG</code>级别输出。程序崩溃报告会触发一个消息输出，建议用户使用调试模式显示报告。它是在应用初始化时绑定一个<code>ConditionEvaluationReportListener</code>事件监听器，然后相应的事件发生时输出<code>ConditionEvaluationReport</code>报告。</li>\n<li>ClearCachesApplicationListener：应用上下文加载完成后对缓存做清除工作，响应事件<code>ContextRefreshedEvent</code>。</li>\n<li>SharedMetadataReaderFactoryContextInitializer：　向<code>context</code>注册了一个<code>BeanFactoryPostProcessor</code>：<code>CachingMetadataReaderFactoryPostProcessor</code>实例。</li>\n<li>ResourceUrlProvider：<code>handling mappings</code>处理</li>\n</ul>\n<h3 id=\"started-ApplicationStartedEvent\"><a href=\"#started-ApplicationStartedEvent\" class=\"headerlink\" title=\"started-&gt;ApplicationStartedEvent\"></a>started-&gt;ApplicationStartedEvent</h3><p><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-ten.jpg\"><br>相关监听器参考上面的描述。</p>\n<h3 id=\"running-ApplicationReadyEvent\"><a href=\"#running-ApplicationReadyEvent\" class=\"headerlink\" title=\"running-&gt;ApplicationReadyEvent\"></a>running-&gt;ApplicationReadyEvent</h3><p><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/bootevents/boot-event-11.jpg\"><br>相关监听器参考上面的描述。</p>\n<h3 id=\"BackgroundPreinitializer-DelegatingApplicationListener\"><a href=\"#BackgroundPreinitializer-DelegatingApplicationListener\" class=\"headerlink\" title=\"BackgroundPreinitializer&amp;DelegatingApplicationListener\"></a>BackgroundPreinitializer&amp;DelegatingApplicationListener</h3><p>这两个贯穿了整个过程，这里拎出来单独解释下：</p>\n<ul>\n<li>BackgroundPreinitializer：对于一些耗时的任务使用一个后台线程尽早触发它们开始执行初始化，这是<code>SpringBoot</code>的缺省行为。这些初始化动作也可以叫做预初始化。可以通过设置系统属性<code>spring.backgroundpreinitializer.ignore</code>为<code>true</code>可以禁用该机制。该机制被禁用时，相应的初始化任务会发生在前台线程。</li>\n<li>DelegatingApplicationListener：监听应用事件，并将这些应用事件广播给环境属性<code>context.listener.classes</code>指定的那些监听器。</li>\n</ul>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>到此，<code>SpringBoot</code> 中的事件相关的东西就结束了。本文从<code>SpringApplicationRunListener</code>这个类说起，接着介绍 <code>SpringBoot</code> 启动过程的事件以及事件的生命周期。最后介绍了 <code>SpringBoot</code>中的内置的这些 监听器在启动过程中对应的各个阶段。</p>\n<p>新年伊始，祝大家新年快乐！</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://blog.csdn.net/andy_zhang2007/article/details/84105284\">https://blog.csdn.net/andy_zhang2007/article/details/84105284</a></li>\n</ul>\n","text":"在这篇文章中聊一聊 Spring 中的扩展机制（一）中对Spring中的事件机制进行了分析。那么对于 SpringBoot 来说，它在 Spring 的基础上又...","permalink":"/post/springboot/springboot-series-event","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/categories/SpringBoot.json"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/tags/SpringBoot.json"},{"name":"event","slug":"event","count":1,"path":"api/tags/event.json"},{"name":"事件机制","slug":"事件机制","count":1,"path":"api/tags/事件机制.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SpringApplicationRunListener\"><span class=\"toc-text\">SpringApplicationRunListener</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SpringApplicationRunListeners\"><span class=\"toc-text\">SpringApplicationRunListeners</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#EventPublishingRunListener\"><span class=\"toc-text\">EventPublishingRunListener</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ApplicationStartingEvent\"><span class=\"toc-text\">ApplicationStartingEvent</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ApplicationEnvironmentPreparedEvent\"><span class=\"toc-text\">ApplicationEnvironmentPreparedEvent</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ApplicationContextInitializedEvent\"><span class=\"toc-text\">ApplicationContextInitializedEvent</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ApplicationPreparedEvent\"><span class=\"toc-text\">ApplicationPreparedEvent</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ApplicationStartedEvent\"><span class=\"toc-text\">ApplicationStartedEvent</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ApplicationReadyEvent\"><span class=\"toc-text\">ApplicationReadyEvent</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ApplicationFailedEvent\"><span class=\"toc-text\">ApplicationFailedEvent</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#demo-%E5%8F%8A%E5%90%84%E4%B8%AA%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">demo 及各个事件的执行顺序</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SpringBoot-%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB\"><span class=\"toc-text\">SpringBoot 中的事件体系</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SimpleApplicationEventMulticaster\"><span class=\"toc-text\">SimpleApplicationEventMulticaster</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">事件体系的初始化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E6%B3%A8%E5%86%8C\"><span class=\"toc-text\">事件注册</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E5%B9%BF%E6%92%AD\"><span class=\"toc-text\">事件广播</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">事件执行</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SpringBoot-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%98%B6%E6%AE%B5\"><span class=\"toc-text\">SpringBoot 启动过程中的事件阶段</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#starting-ApplicationStartingEvent\"><span class=\"toc-text\">starting -&gt; ApplicationStartingEvent</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#listeners-environmentPrepared-ApplicationEnvironmentPreparedEvent\"><span class=\"toc-text\">listeners.environmentPrepared-&gt;ApplicationEnvironmentPreparedEvent</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#listeners-contextPrepared-ApplicationContextInitializedEvent\"><span class=\"toc-text\">listeners.contextPrepared-&gt;ApplicationContextInitializedEvent</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#listeners-contextLoaded-ApplicationPreparedEvent\"><span class=\"toc-text\">listeners.contextLoaded-&gt;ApplicationPreparedEvent</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#refresh-ContextRefreshedEvent\"><span class=\"toc-text\">refresh-&gt;ContextRefreshedEvent</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#started-ApplicationStartedEvent\"><span class=\"toc-text\">started-&gt;ApplicationStartedEvent</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#running-ApplicationReadyEvent\"><span class=\"toc-text\">running-&gt;ApplicationReadyEvent</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#BackgroundPreinitializer-DelegatingApplicationListener\"><span class=\"toc-text\">BackgroundPreinitializer&amp;DelegatingApplicationListener</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"ZooKeeper 客户端之 Curator","uid":"e185413cf7dca9c0efdf1f0b1164cf4f","slug":"middleware/middleware-zookeeper-client-curator","date":"2019-04-13T14:09:30.000Z","updated":"2024-07-05T04:09:05.790Z","comments":true,"path":"api/articles/middleware/middleware-zookeeper-client-curator.json","keywords":null,"cover":[],"text":"ZooKeeper 是一个分布式的、开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现。它是集群的管理者，监视着集群中各个节点...","permalink":"/post/middleware/middleware-zookeeper-client-curator","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"Middleware","slug":"Middleware","count":13,"path":"api/categories/Middleware.json"}],"tags":[{"name":"curator","slug":"curator","count":1,"path":"api/tags/curator.json"},{"name":"zookeeper","slug":"zookeeper","count":3,"path":"api/tags/zookeeper.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"SpringBoot 实践系列-Kafka简介&集成SpringBoot","uid":"f94d5062192ef9da77e7f3024a117b4b","slug":"springboot/springboot-series-kafka-introduction","date":"2019-03-07T09:58:54.000Z","updated":"2024-07-05T04:09:05.829Z","comments":true,"path":"api/articles/springboot/springboot-series-kafka-introduction.json","keywords":null,"cover":[],"text":" 近期在做 SOFA 与 SpringCloud 的集成，希望通过一系列的 DEMO 工程去帮助大家更好的使用 SOFA 和 SpringCloud；同时也希望...","permalink":"/post/springboot/springboot-series-kafka-introduction","photos":[],"count_time":{"symbolsCount":"7.8k","symbolsTime":"7 mins."},"categories":[{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/categories/SpringBoot.json"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/tags/SpringBoot.json"},{"name":"Kafka","slug":"Kafka","count":1,"path":"api/tags/Kafka.json"},{"name":"消息","slug":"消息","count":2,"path":"api/tags/消息.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}