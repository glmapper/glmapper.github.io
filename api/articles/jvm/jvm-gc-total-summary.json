{"title":"浅谈 JAVA 中的垃圾回收机制","uid":"75a9f38981cbb37e9f3b4b30830b22d2","slug":"jvm/jvm-gc-total-summary","date":"2024-07-01T02:59:14.000Z","updated":"2024-07-05T04:09:05.769Z","comments":true,"path":"api/articles/jvm/jvm-gc-total-summary.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"content":"<p>在现代编程语言中，垃圾回收机制（Garbage Collection）扮演着至关重要的角色，尤其在 Java 语言中更是如此。Java 作为一门广泛应用于企业级开发的编程语言，通过自动化的内存管理，极大地简化了开发者的工作。然而，垃圾回收机制的复杂性也带来了许多挑战和性能优化的需求。本文将深入探讨 Java 中的垃圾回收机制，从基础原理到具体收集器的工作方式，再到如何进行垃圾回收调优，帮助开发者更好地理解和应用这一关键技术。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"GC-要解决的问题本质是什么\"><a href=\"#GC-要解决的问题本质是什么\" class=\"headerlink\" title=\"GC 要解决的问题本质是什么\"></a>GC 要解决的问题本质是什么</h2><p>这里没有必要再和各位读者讨论什么是<strong>垃圾</strong>以及什么是<strong>垃圾回收</strong>；也相信绝大多数的 Java 开发者也都多少背过一些面试的八股文，比如如何识别<strong>垃圾</strong> ？当你提到<code>引用计数法</code>的时候，可能面试官已经预测到你要说 <code>可达性分析法</code> 了。不过这里笔者还是将 Oracle Java 官方文档关于 GC 的一段描述放在这里：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Automatic garbage collection is the process of looking at heap memory, identifying which objects are in use and which are not, and deleting the unused objects. An in use object, or a referenced object, means that some part of your program still maintains a pointer to that object. An unused object, or unreferenced object, is no longer referenced by any part of your program. So the memory used by an unreferenced object can be reclaimed.</p>\n<p>自动垃圾收集是查看堆内存、识别哪些对象正在使用、哪些未使用，并删除未使用的对象的过程。正在使用的对象或引用的对象意味着程序的某些部分仍然维护着指向该对象的指针。程序的任何部分都不再引用未使用的对象或未引用的对象。因此，未被引用的对象所使用的内存可以被回收。</p></blockquote>\n<p>从这段描述中，可以这样理解：<strong>GC 的作用是收集无效的对象（未使用的对象或未引用的对象），进而释放掉这些无效对象所占用的内存空间</strong>。那换个思路：如果物理内存空间是无限大的，那么是不是可以不需要去关注这些无效的对象？这显然是理论上的可能性。因此 GC 要解决的问题的本质是 <strong>因内存资源的稀缺性带来的如保障有足够空间来分配对象、保障不会因过多无效对象影响计算机缓存结构的访问效率以及硬件成本等问题</strong>。</p>\n<p>另外，不得不提一下，GC 技术并不是 Java 所特有的，也不是 Java 语言开发者所提出的。GC 技术早在 <em>Java</em> 语言问世前 <em>30</em> 多年就已经发展和成熟起来了， <em>Java</em> 语言所做的不过是把这项神奇的技术带到了广大程序员身边而已。笔者查阅了相关资料，<em>1960</em> 年前后诞生于 <em>MIT</em> 的 <em>Lisp</em> 语言是第一种高度依赖于动态内存分配技术的语言， <em>Lisp</em> 中几乎所有数据都以<em>“</em>表<em>”</em>的形式出现，而<em>“</em>表<em>”</em>所占用的空间则是在堆中动态分配得到的。 <em>Lisp</em> 语言先天就具有的动态内存管理特性，这也就意味着要求 <em>Lisp</em> 语言的设计者必须解决堆中每一个内存块的自动释放问题，这也就直接促使了 GC  技术初始雏形。</p>\n<p>好了，到这里，我想先抛出这篇文章所要阐述的第一个问题，即不管是 Java 还是 Lisp 语言都提及的动态内存分配技术，那么为什么动态内存分配技术必须要使用 GC 机制来兜底呢？</p>\n<h3 id=\"内存分配机制\"><a href=\"#内存分配机制\" class=\"headerlink\" title=\"内存分配机制\"></a>内存分配机制</h3><p>这里简单回顾一下内存分配的主要方式。我们知道，大多数主流的语言或运行环境都支持三种最基本的内存分配方式，它们分别是：</p>\n<ul>\n<li><p><strong>静态分配（ <em>Static Allocation</em> ）</strong>：在程序编译时确定内存的分配和大小，并且在程序整个生命周期内这部分内存不会改变。静态分配就像你在家中固定安装的一个书架，用来存放特定数量的书籍。这个书架的大小和位置在你安装好之后就不会再改变。</p>\n</li>\n<li><p><strong>自动分配（ <em>Automatic Allocation</em> ）</strong>：由编译器在函数调用时自动分配和释放内存。通常用于函数内部的局部变量，内存分配在函数调用时进行，在函数返回时释放。如：你在家中进行烹饪时，临时使用一个菜板切菜。使用完后，你会立即清洗并收好，菜板的使用是临时的，且与烹饪过程直接相关。</p>\n</li>\n<li><p><strong>动态分配（ <em>Dynamic Allocation</em> ）</strong>：在程序运行时根据需要动态分配内存，并且需要显式地释放内存。通常使用内存管理函数如 <code>malloc</code>、<code>free</code> 等。如：你在家中举办派对，根据派对人数临时租用桌椅。派对结束后，你需要联系租赁公司将桌椅归还。这种情况下，桌椅的数量和使用时间都是灵活的。</p>\n</li>\n</ul>\n<p>静态分配和自动分配不需要垃圾回收（GC）的原因在于其内存生命周期固定且由编译器自动管理。静态分配在程序启动时确定，内存始终有效，直到程序结束；自动分配用于函数内部的局部变量，函数调用时分配，结束时自动释放。这两种分配方式内存管理简单且确定，不存在内存泄漏或悬挂指针问题，因此自然而安就无需 GC 介入。而动态分配是在运行时进行内存分配，通常这些内存分配的动作是在代码中通过 <code>malloc/free</code>、<code>new/delete</code> 等关键字进行申请和释放。</p>\n<p>这就取决于编写代码的程序员的技术能力，还有就是对于代码整体的掌控能力；如果处理不当，则可能会引发下面的一些问题：</p>\n<ul>\n<li><strong>内存泄漏</strong>：当程序员分配内存但忘记释放内存时，就会发生这种情况。随着系统运行时间的拉长，这些未释放的内存块会慢慢累积，导致可用内存逐渐减少，最终可能会使应用程序或系统崩溃。</li>\n<li><strong>悬空指针</strong>：仍在使用或稍后将使用的内存会过早释放，访问此类内存空间可能会导致未定义的行为，从而导致应用程序崩溃或不可预知的结果。</li>\n<li><strong>双重释放</strong>：程序员试图取消分配已释放空间的问题，可能会损坏内存并导致不稳定的行为。</li>\n</ul>\n<p>为了省去上述手动内存管理的麻烦，大佬们钻研开发出了 GC ，即如果把内存管理交给计算机，程序员就不用去主动释放内存了。在手动内存管理中，程序员要判断哪些是不用的内存空间（垃圾）和时刻留意内存空间的寿命。通过引入 GC 机制来解决程序员在手动内存管理上所带来的一系列问题，从而大大减轻程序员的负担和编程的复杂度，让程序员告别繁琐的内存管理，把精力集中在更本质的编程工作上。这就是动态内存分配技术需要使用 GC 机制来兜底的原因。</p>\n<h2 id=\"JAVA-中的-GC-机制\"><a href=\"#JAVA-中的-GC-机制\" class=\"headerlink\" title=\"JAVA 中的 GC 机制\"></a>JAVA 中的 GC 机制</h2><p>前面介绍了GC 要解决的问题本质是什么以及动态内存分配和GC 的关系，本小节主要来看看 JAVA 中的 GC 机制。Java 中垃圾回收由 Java 虚拟机 （JVM） 负责。要了解 Java 中的垃圾回收工作原理，首先必须了解 Java 内存模型的结构。</p>\n<p><img src=\"https://vspicgo.oss-cn-shanghai.aliyuncs.com/typora/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpg\" alt=\"JAVA内存模型\"></p>\n<p>Java 的内存管理实际上就是对象的管理，其中包括对象的分配和释放，而对象的分配一般是在堆上，因此 GC 的主要工作区域是堆。</p>\n<h3 id=\"关于可达性分析和三色标记法\"><a href=\"#关于可达性分析和三色标记法\" class=\"headerlink\" title=\"关于可达性分析和三色标记法\"></a>关于可达性分析和三色标记法</h3><p>这里主要是讨论 JVM 判断对象存活的算法，常见的是引用计数法和可达性分析算法</p>\n<ul>\n<li><strong>引用计数法</strong>：给对象添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；计数器为 0 的对象就是不可能再被使用的对象。这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</li>\n<li><strong>可达性分析算法</strong>：这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</li>\n</ul>\n<p>当前主流的 JVM 实现中，已经摒弃了引用计数法，主要以可达性分析算法的实现为主，但是基本的可达性分析算法也同样存在问题，主要是 STW 时间长。</p>\n<p>可达性分析的整个过程都需要 STW，以避免对象的状态发生改变，这就导致GC停顿时长很长，大大影响应用的整体性能。为了解决上面这些问题，就引入了<code>三色标记算法</code>。</p>\n<p>三色标记算法（Tricolor Marking Algorithm）是一种基于可达性分析的垃圾回收算法。它将对象状态分为三种：白色、灰色、黑色，其中：</p>\n<ul>\n<li><p><strong>白色（White）</strong>：表示对象未被访问过，即还未进行可达性分析。</p>\n</li>\n<li><p><strong>灰色（Gray）</strong>：表示对象已被访问过，但其引用的对象尚未进行可达性分析。</p>\n</li>\n<li><p><strong>黑色（Black）</strong>：表示对象已被访问过，并且其引用的对象也已进行了可达性分析。</p>\n</li>\n</ul>\n<p>同时将标记过程可以分为三个阶段：初始标记（Initial Marking）、并发标记（Concurrent Marking）和重新标记（Remark）。三个标记阶段中，初始标记和重新标记是需要 STW ，而并发标记是不需要 STW。其中最耗时的其实就是并发标记的这个阶段，因为这个阶段需要遍历整个对象树，而三色标记把这个阶段做到了和应用线程并发执行，也就大大降低了 GC 的停顿时长。</p>\n<h3 id=\"分代-GC-的基本过程\"><a href=\"#分代-GC-的基本过程\" class=\"headerlink\" title=\"分代 GC 的基本过程\"></a>分代 GC 的基本过程</h3><p>目前 Java 中主要使用的分代垃圾回收机制，即使是 G1 以 region 概念进行的分区管理方式，也仍旧保留了分代的概念。这里主要依据是分代假说理论。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>分代假说主要思想：在大多数情况下，大部分对象的生命周期很短暂，而少部分对象的生命周期较长。</p></blockquote>\n<p>基于分代假说，GC 算法通常会针对不同代使用不同的策略。例如，年轻代常使用复制算法（Copying Algorithm）或标记-复制算法（Mark-Compact Algorithm）进行垃圾回收，而老年代则可能使用标记-清除算法（Mark and Sweep Algorithm）或标记-整理算法（Mark-Compact Algorithm）。这种分代的思想是基于实践观察和优化策略而提出的，旨在通过不同的策略和算法，针对对象的生命周期特点，提高垃圾回收的效率和性能。下面是分代垃圾回收的基本过程。</p>\n<ul>\n<li>1、任何新对象都会被分配到 eden 空间，两个 survior 空间一开始都是空的。</li>\n</ul>\n<p><img src=\"https://vspicgo.oss-cn-shanghai.aliyuncs.com/typora/image-20240626090329053.png\" alt=\"image-20240626090329053\"></p>\n<ul>\n<li>2、当 eden 空间填满时，将触发 minor GC。</li>\n</ul>\n<p><img src=\"https://vspicgo.oss-cn-shanghai.aliyuncs.com/typora/image-20240626090343993.png\" alt=\"image-20240626090343993\"></p>\n<ul>\n<li>3、引用的对象将移动到第一个 survior 空间。清除 eden 空间时，将删除未引用的对象。</li>\n</ul>\n<p><img src=\"http://vspicgo.oss-cn-shanghai.aliyuncs.com/typora/image-20240626090401934.png\" alt=\"image-20240626090401934\"></p>\n<ul>\n<li>4、在下一个minor  GC 中，eden 空间也会发生同样的事情。删除未引用的对象，并将引用的对象移动到 survior 空间。但是，在这种情况下，它们被移动到第二个 survior 空间 （S1）。此外，第一个 survior 空间 （S0） 上最后一个 minor GC 中的对象的年龄会递增并移动到 S1。将所有幸存的对象移动到 S1 后，S0 和 eden 都会被清除。此时在 survior 空间中有不同年龄的对象。</li>\n</ul>\n<p><img src=\"http://vspicgo.oss-cn-shanghai.aliyuncs.com/typora/image-20240626090417420.png\" alt=\"image-20240626090417420\"></p>\n<ul>\n<li>5、在下一个minor GC 中，重复相同的过程。然而，这一次，survior 空间发生了变化。引用的对象将移动到 S0。幸存的对象已经老化。Eden 和 S1 被清除。</li>\n</ul>\n<p><img src=\"http://vspicgo.oss-cn-shanghai.aliyuncs.com/typora/image-20240626090432508.png\" alt=\"image-20240626090432508\"></p>\n<ul>\n<li>6、在 minor GC 之后，当老化对象达到某个年龄阈值时，它们将从年轻一代提升到老一代。</li>\n</ul>\n<p><img src=\"http://vspicgo.oss-cn-shanghai.aliyuncs.com/typora/image-20240626090444135.png\" alt=\"image-20240626090444135\"></p>\n<ul>\n<li>7、随着 minor GC 的继续发生，对象将继续被提升到老年代空间。</li>\n</ul>\n<p><img src=\"http://vspicgo.oss-cn-shanghai.aliyuncs.com/typora/image-20240626090458137.png\" alt=\"image-20240626090458137\"></p>\n<ul>\n<li>8、最终，将对老年代进行 major GC 处理，以清理和压缩该空间。</li>\n</ul>\n<p><img src=\"http://vspicgo.oss-cn-shanghai.aliyuncs.com/typora/image-20240626090511416.png\" alt=\"image-20240626090511416\"></p>\n<h2 id=\"GC-调优的目标是什么？\"><a href=\"#GC-调优的目标是什么？\" class=\"headerlink\" title=\"GC 调优的目标是什么？\"></a>GC 调优的目标是什么？</h2><p>最后笔者希望和各位读者来探讨下 GC 调优的目标。在过往的经历中，或者面试者提供的简历中，关于 GC 调优的问题背景差不多可以归结如下几类：</p>\n<ul>\n<li>系统运行时出现了 OOM</li>\n<li>尖刺问题</li>\n<li>其他非堆区问题的 GC ，如 metaspace 不够，栈溢出等</li>\n</ul>\n<p>确实，这些问题有的会导致我们在线业务受损，有的则可能直接导致系统崩溃。我们的调优往往基于这些已经发生的现象进行的调整，因为 GC 调优本身就没有标准的范式，它取决于你的软硬件环境、你的业务属性、你的流量分布情况等等。这里笔者就引出本小节希望探讨的另一个话题—-<strong>调优的目的是什么？</strong></p>\n<p>这个问题很简单，一句话就是保障系统可用性，这个是终极目标；再细一点则是在有限的内存资源条件下，通过 GC 调优使得系统能够稳定长期运行。那再细一点呢？</p>\n<p>笔者认为， GC 调优的目标是更合理的使用堆内存空间，尽量减少应该 GC 带来的业务影响；进一步展开就是：在有限的内存资源限定的条件下，通过 GC 调优来提高应用程序或系统对请求的数据做出响应的速度（响应能力）以及最大化应用程序在特定时间段内的工作量（吞吐量），以使得系统能够以一种较优的姿态保持稳定长期运行。</p>\n<h3 id=\"GC-调优的一些基本思路\"><a href=\"#GC-调优的一些基本思路\" class=\"headerlink\" title=\"GC 调优的一些基本思路\"></a>GC 调优的一些基本思路</h3><p>从前一小节可以知道，在进行 GC 调优时，我们的目标是优化内存资源使用、提升响应速度、增加吞吐量，并确保系统能够稳定长期运行。为了实现这些目标，我们需要关注和调整一些关键因素，包括堆大小、吞吐量、停顿时间。</p>\n<p>![GC 性能指标三角形](&#x2F;Users&#x2F;glmapper&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240626145258548.png)</p>\n<h4 id=\"内存资源（堆内存空间）\"><a href=\"#内存资源（堆内存空间）\" class=\"headerlink\" title=\"内存资源（堆内存空间）\"></a>内存资源（堆内存空间）</h4><p>堆内存空间是 GC 调优的基础，合理设置堆大小能够平衡内存使用和 GC 频率，避免内存不足或过度分配带来的性能问题。在实际的应用中，一般会关注初始堆大小（-Xms）和最大堆大小（-Xmx），通过这两个参数可以控制应用程序在启动和运行期间的内存使用；如果你的系统对响应性能要求比较高，可以将这两个值设置为相同，以避免动态调整带来的开销和性能波动。如果是 G1，除了调整堆大小之外，region size 可能也是一个值得关注的因素。</p>\n<h4 id=\"响应速度\"><a href=\"#响应速度\" class=\"headerlink\" title=\"响应速度\"></a>响应速度</h4><p>提升应用的响应速度，从调优过程角度则是要降低 GC 带来的延迟，而这个延迟主要取决于GC 产生的停顿时间。这里可以考虑选择响应时间优先的GC 算法，如 G1;G1 中提出了一种模型叫做 Pause Prediction Model （停顿预测模型），与 CMS 最大的不同是，用户可以设定整个GC过程的期望停顿时间，参数-XX:MaxGCPauseMillis 指定一个G1收集过程目标停顿时间（默认值200ms，不是硬性条件，只是期望值）。G1根据这个模型统计计算出来的历史数据来预测本次收集需要选择的Region数量，从而尽量满足用户设定的目标停顿时间。 停顿预测模型是以衰减标准偏差为理论基础实现的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  share/vm/gc_implementation/g1/g1CollectorPolicy.hpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">get_new_prediction</span><span class=\"params\">(TruncatedSeq* seq)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">MAX2</span>(seq-&gt;<span class=\"built_in\">davg</span>() + <span class=\"built_in\">sigma</span>() * seq-&gt;<span class=\"built_in\">dsd</span>(),</span><br><span class=\"line\">                seq-&gt;<span class=\"built_in\">davg</span>() * <span class=\"built_in\">confidence_factor</span>(seq-&gt;<span class=\"built_in\">num</span>()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里不展开，有兴趣的读者可以自行研究一下 Pause Prediction Model 。</p></blockquote>\n<h4 id=\"吞吐量\"><a href=\"#吞吐量\" class=\"headerlink\" title=\"吞吐量\"></a>吞吐量</h4><p>吞吐量指的是应用在单位时间内能够处理的任务数量，优化吞吐量可以提升系统的整体效率。这里的吞吐量指的是 <strong>CPU 用于运行用户代码的时间与CPU 总消耗时间的比值</strong>，即</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>吞吐量 &#x3D; 运行用户代码时间&#x2F;（运行用户代码时间+ 垃圾收集时间）。</p></blockquote>\n<p>比如如果应用程序总运行时间为100秒，其中90秒用于处理业务逻辑，10秒用于垃圾回收，那么吞吐量为90%（90秒 &#x2F; 100秒）。</p>\n<p>当我们说 GC 吞吐量优先时，意味着我们的目标是最大化应用程序的有效工作时间，最小化垃圾回收带来的开销；一般情况下吞吐量优先的场景主要是批处理系统或者后台服务，这类服务更关注整体处理能力而非单次操作的响应时间。如果你的系统关注吞吐量，可以选择并行 GC 或者其他高吞吐量的 GC 算法，如 Parallel GC。在 GC 参数的调整上，可以 <strong>增大年轻代大小</strong>，通过增加年轻代（-Xmn）的大小，减少对象晋升到老年代的频率，降低 Full GC 的次数；此外还可以 <strong>调整并行 GC 线程数</strong>，通过增加并行 GC 的线程数来提高并行垃圾回收的效率。</p>\n<h2 id=\"JVM-GC-机制的发展展望\"><a href=\"#JVM-GC-机制的发展展望\" class=\"headerlink\" title=\"JVM GC 机制的发展展望\"></a>JVM GC 机制的发展展望</h2><p>这张图是 2019 年时 JAVA 版本的使用情况分布，还是以 JAVA 8 为主。</p>\n<p><img src=\"http://vspicgo.oss-cn-shanghai.aliyuncs.com/typora/2019-java-versions.png\" alt=\"2019-java-versions\"></p>\n<p>下面这张图是 <a href=\"https://www.azul.com/wp-content/uploads/final-2023-state-of-java-report.pdf\">State of Java 2023</a> 中关于 JAVA 目前版本使用情况的统计，从这张图可以看出，<em>版本任你发，我用Java 8</em> 的声音可能会慢慢的消失在历史的长河中。</p>\n<p><img src=\"http://vspicgo.oss-cn-shanghai.aliyuncs.com/typora/image-20240626113109379.png\" alt=\"image-20240626113109379\"></p>\n<p>从 2019 年到 2023 年，短短几年的时间，越来越多的用户选择了更好版本的 LTS 版本，这也意味着高版本中提供的各种语言特性或者机制（包括 GC）能够给用户带去更多的收益价值。从官方纰漏的 <a href=\"https://blogs.oracle.com/javamagazine/post/java-garbage-collectors-evolution\">报告</a> 中指出，从  JDK 8 到 JDK 18，经历了 10 个版本，Java 垃圾回收也经历了十次进化，包括了 2000+ 个增强功能。从这些演进中可以基本的出的结论是，Java 一直在为寻求更低的延迟、更高效的内存利用和更大的吞吐而努力；这不是三者平衡和折中的过程，而是将 GC 性能指标三角形的张力扩大的过程。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要针对 JAVA 中的垃圾回收机制进行了探讨，和其他文章不同的是，笔者没有将关注点放在某一个垃圾回收算法上，也不是针对某一个具体垃圾收集器进行展开；笔者期望从一个更加宏观的角度去解释什么需要 GC 以及 GC 的目标是什么。此外本文也对 GC 的基本过程、调优思路以及 GC 的未来发展进行了阐述，期望读者可以更加全面的理解 GC 机制。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://blogs.oracle.com/javamagazine/post/java-garbage-collectors-evolution\">https://blogs.oracle.com/javamagazine/post/java-garbage-collectors-evolution</a></li>\n<li><a href=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html\">https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html</a></li>\n<li><a href=\"https://www.azul.com/wp-content/uploads/final-2023-state-of-java-report.pdf\">https://www.azul.com/wp-content/uploads/final-2023-state-of-java-report.pdf</a></li>\n<li>《垃圾回收的算法与实现》– 中村成洋 相川光</li>\n</ul>\n","text":"在现代编程语言中，垃圾回收机制（Garbage Collection）扮演着至关重要的角色，尤其在 Java 语言中更是如此。Java 作为一门广泛应用于企业级...","permalink":"/post/jvm/jvm-gc-total-summary","photos":[],"count_time":{"symbolsCount":"7.7k","symbolsTime":"7 mins."},"categories":[{"name":"jvm","slug":"jvm","count":6,"path":"api/categories/jvm.json"}],"tags":[{"name":"gc","slug":"gc","count":3,"path":"api/tags/gc.json"},{"name":"jvm","slug":"jvm","count":6,"path":"api/tags/jvm.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#GC-%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">GC 要解决的问题本质是什么</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">内存分配机制</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JAVA-%E4%B8%AD%E7%9A%84-GC-%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">JAVA 中的 GC 机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95\"><span class=\"toc-text\">关于可达性分析和三色标记法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E4%BB%A3-GC-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">分代 GC 的基本过程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#GC-%E8%B0%83%E4%BC%98%E7%9A%84%E7%9B%AE%E6%A0%87%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">GC 调优的目标是什么？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#GC-%E8%B0%83%E4%BC%98%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">GC 调优的一些基本思路</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E8%B5%84%E6%BA%90%EF%BC%88%E5%A0%86%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%89\"><span class=\"toc-text\">内存资源（堆内存空间）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%93%8D%E5%BA%94%E9%80%9F%E5%BA%A6\"><span class=\"toc-text\">响应速度</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%9E%E5%90%90%E9%87%8F\"><span class=\"toc-text\">吞吐量</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JVM-GC-%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8F%91%E5%B1%95%E5%B1%95%E6%9C%9B\"><span class=\"toc-text\">JVM GC 机制的发展展望</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"Dubbo Metrics 基本原理及扩展 OTLP 协议","uid":"f39ea97e417100cd6078bb8210dec4a8","slug":"middleware/middleware-dubbo-metrics","date":"2024-09-09T07:43:22.000Z","updated":"2024-09-09T07:52:15.462Z","comments":true,"path":"api/articles/middleware/middleware-dubbo-metrics.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"text":" 关于 dubbo metrics 的使用可以参考dubbo-metrics 和 可观测性 Metrics Proposal 两篇文档。 dubbo 的 met...","permalink":"/post/middleware/middleware-dubbo-metrics","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"Middleware","slug":"Middleware","count":14,"path":"api/categories/Middleware.json"}],"tags":[{"name":"Dubbo","slug":"Dubbo","count":1,"path":"api/tags/Dubbo.json"},{"name":"Metrics","slug":"Metrics","count":2,"path":"api/tags/Metrics.json"},{"name":"OTLP","slug":"OTLP","count":2,"path":"api/tags/OTLP.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"win 10 部署 langchain-chatchat gpu 版","uid":"815e5fe8003f703e73f556f106d850e3","slug":"llm/langchain-chatchat-deploy","date":"2024-01-05T09:32:34.000Z","updated":"2024-12-25T09:48:28.467Z","comments":true,"path":"api/articles/llm/langchain-chatchat-deploy.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"text":"基于 ChatGLM 等大语言模型与 Langchain 等应用框架实现，开源、可离线部署的检索增强生成(RAG)大模型知识库项目。 本地环境 品牌：戴尔 op...","permalink":"/post/llm/langchain-chatchat-deploy","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"LLM","slug":"LLM","count":2,"path":"api/categories/LLM.json"}],"tags":[{"name":"langchain","slug":"langchain","count":1,"path":"api/tags/langchain.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}