{"title":"JVM-Java 对象模型","uid":"29ce492a4d6518491078a1705c4387c8","slug":"jvm/jvm-openjdk-oop-klass","date":"2021-11-05T03:23:39.000Z","updated":"2024-07-05T04:09:05.769Z","comments":true,"path":"api/articles/jvm/jvm-openjdk-oop-klass.json","keywords":null,"cover":[],"content":"<p>Java对象保存在堆内存中。在内存中，一个Java对象包含三部分：对象头、实例数据和对齐填充。其中对象头是一个很关键的部分，因为对象头中包含锁状态标志、线程持有的锁等标志。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"对象头\"><a href=\"#对象头\" class=\"headerlink\" title=\"对象头\"></a>对象头</h2><p>对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</p>\n<p>对markword的设计方式上，非常像网络协议报文头：将mark word划分为多个比特位区间，并在不同的对象状态下赋予比特位不同的含义。下图描述了在32位虚拟机上，在对象不同状态时 mark word各个比特位区间的含义。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba238127e31f4357a3551149318aa0b0~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>在JVM的内存结构中，对象保存在堆内存中，而我们在对对象进行操作时，其实操作的是对象的引用。那么对象本身在JVM中的结构是什么样的呢？本文的所有分析均基于 <a href=\"https://github.com/openjdk-mirror/jdk7u-hotspot\">HotSpot</a> 虚拟机。</p>\n<h2 id=\"Oop-Klass-模型\"><a href=\"#Oop-Klass-模型\" class=\"headerlink\" title=\"Oop-Klass 模型\"></a>Oop-Klass 模型</h2><p>HotSpot是基于 c++ 实现，而c++是一门面向对象的语言，本身是具备面向对象基本特征的，所以Java中的对象表示，最简单的做法是为每个Java类生成一个c++类与之对应。但HotSpot JVM并没有这么做，而是设计了一个<code>OOP-Klass Model</code>。OOP（<code>Ordinary Object Pointer</code>）指的是普通对象指针，而<code>Klass</code>用来描述对象实例的具体类型。</p>\n<p>为什么 HotSpot 要设计一套<code>oop-klass model</code>呢？答案是：HotSopt JVM的设计者不想让每个对象中都含有一个<code>vtable</code>（虚函数表）; 这个解释似乎可以说得通。众所周知，C++和Java都是面向对象的语言，面向对象语言有一个很重要的特性就是多态。关于多态的实现，C++和Java有着本质的区别。</p>\n<p>多态是面向对象的最主要的特性之一，是一种方法的动态绑定，实现运行时的类型决定对象的行为。多态的表现形式是父类指针或引用指向子类对象，在这个指针上调用的方法使用子类的实现版本。多态是IOC、模板模式实现的关键。</p>\n<p>在 C++ 中通过虚函数表的方式实现多态，每个包含虚函数的类都具有一个虚函数表（virtual table），在这个类对象的地址空间的最靠前的位置存有指向虚函数表的指针。在虚函数表中，按照声明顺序依次排列所有的虚函数。由于C++在运行时并不维护类型信息，所以在编译时直接在子类的虚函数表中将被子类重写的方法替换掉。</p>\n<p>在 Java 中，在运行时会维持类型信息以及类的继承体系。每一个类会在方法区中对应一个数据结构用于存放类的信息，可以通过Class对象访问这个数据结构。其中，类型信息具有superclass属性指示了其超类，以及这个类对应的方法表（其中只包含这个类定义的方法，不包括从超类继承来的）。而每一个在堆上创建的对象，都具有一个指向方法区类型信息数据结构的指针，通过这个指针可以确定对象的类型。</p>\n<h3 id=\"oop-klass-结构\"><a href=\"#oop-klass-结构\" class=\"headerlink\" title=\"oop-klass 结构\"></a>oop-klass 结构</h3><p>关于 opp-klass 模型的整体定义，在 HotSpot 的 <a href=\"https://github.com/openjdk-mirror/jdk7u-hotspot\">源码</a> 中可以找到。oops 模块可以分成两个相对独立的部分：OOP 框架和 Klass 框架。在 <a href=\"https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/oopsHierarchy.hpp\">oopsHierarchy.hpp</a> 里定义了 oop 和 klass 各自的体系。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07cef390e9de41c5831873fb634c2925~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<h3 id=\"oop-体系\"><a href=\"#oop-体系\" class=\"headerlink\" title=\"oop 体系\"></a>oop 体系</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义了oops共同基类</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">class</span>   <span class=\"title class_\">oopDesc</span>*                            oop;</span><br><span class=\"line\"><span class=\"comment\">//表示一个Java类型实例</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">class</span>   <span class=\"title class_\">instanceOopDesc</span>*            instanceOop;</span><br><span class=\"line\"><span class=\"comment\">//表示一个Java方法</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">class</span>   <span class=\"title class_\">methodOopDesc</span>*                    methodOop;</span><br><span class=\"line\"><span class=\"comment\">//表示一个Java方法中的不变信息</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">class</span>   <span class=\"title class_\">constMethodOopDesc</span>*            constMethodOop;</span><br><span class=\"line\"><span class=\"comment\">//记录性能信息的数据结构</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">class</span>   <span class=\"title class_\">methodDataOopDesc</span>*            methodDataOop;</span><br><span class=\"line\"><span class=\"comment\">//定义了数组OOPS的抽象基类</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">class</span>   <span class=\"title class_\">arrayOopDesc</span>*                    arrayOop;</span><br><span class=\"line\"><span class=\"comment\">//表示持有一个OOPS数组</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">class</span>   <span class=\"title class_\">objArrayOopDesc</span>*            objArrayOop;</span><br><span class=\"line\"><span class=\"comment\">//表示容纳基本类型的数组</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">class</span>   <span class=\"title class_\">typeArrayOopDesc</span>*            typeArrayOop;</span><br><span class=\"line\"><span class=\"comment\">//表示在Class文件中描述的常量池</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">class</span>   <span class=\"title class_\">constantPoolOopDesc</span>*            constantPoolOop;</span><br><span class=\"line\"><span class=\"comment\">//常量池告诉缓存</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">class</span>   <span class=\"title class_\">constantPoolCacheOopDesc</span>*   constantPoolCacheOop;</span><br><span class=\"line\"><span class=\"comment\">//描述一个与Java类对等的C++类</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">class</span>   <span class=\"title class_\">klassOopDesc</span>*                    klassOop;</span><br><span class=\"line\"><span class=\"comment\">//表示对象头</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">class</span>   <span class=\"title class_\">markOopDesc</span>*                    markOop;</span><br></pre></td></tr></table></figure>\n\n<p>上面列出的是整个Oops模块的组成结构，其中包含多个子模块。每一个子模块对应一个类型，每一个类型的OOP都代表一个在JVM内部使用的特定对象的类型。</p>\n<p>从上面的代码中可以看到，有一个变量opp的类型是<code>oppDesc</code> ，OOPS类的共同基类型为<code>oopDesc</code>。</p>\n<p><strong>在Java程序运行过程中，每创建一个新的对象，在JVM内部就会相应地创建一个对应类型的OOP对象。</strong> 在HotSpot中，根据JVM内部使用的对象业务类型，具有多种<code>oopDesc</code>的子类。除了<code>oppDesc</code>类型外，opp体系中还有很多<code>instanceOopDesc</code>、<code>arrayOopDesc</code> 等类型的实例，他们都是<code>oopDesc</code>的子类。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e714bd2b01a41d8bcc4a50c9e2a3b16~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>这些 OOPS 在 JVM 内部有着不同的用途，例如 <strong>，</strong> <code>instanceOopDesc </code><strong>表示类实例，</strong> <code>arrayOopDesc </code><strong>表示数组。</strong> 也就是说，<strong>当我们使用</strong><code>new</code><strong>创建一个 Java 对象实例的时候，JVM 会创建一个</strong><code>instanceOopDesc</code><strong>对象来表示这个 Java 对象。同理，当我们使用</strong><code>new</code><strong>创建一个 Java 数组实例的时候，JVM 会创建一个</strong><code>arrayOopDesc </code><strong>对象来表示这个数组对象。</strong></p>\n<hr>\n<p>在 HotSpot 中，oopDesc 类定义在 <a href=\"https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/oop.hpp\">oop.hpp</a> 中，instanceOopDesc 定义在 <a href=\"https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/instanceOop.hpp\">instanceOop.hpp</a> 中，arrayOopDesc 定义在 <a href=\"https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/arrayOop.hpp\">arrayOop.hpp</a> 中。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">oopDesc</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">VMStructs</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">volatile</span> markOop  _mark;</span><br><span class=\"line\">      <span class=\"keyword\">union</span> <span class=\"title class_\">_metadata</span> &#123;</span><br><span class=\"line\">        wideKlassOop    _klass;</span><br><span class=\"line\">        narrowOop       _compressed_klass;</span><br><span class=\"line\">      &#125; _metadata;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"comment\">// field addresses in oop</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span>*     <span class=\"title\">field_base</span><span class=\"params\">(<span class=\"type\">int</span> offset)</span>        <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\">jbyte*    <span class=\"title\">byte_field_addr</span><span class=\"params\">(<span class=\"type\">int</span> offset)</span>   <span class=\"type\">const</span></span>;</span><br><span class=\"line\">      <span class=\"function\">jchar*    <span class=\"title\">char_field_addr</span><span class=\"params\">(<span class=\"type\">int</span> offset)</span>   <span class=\"type\">const</span></span>;</span><br><span class=\"line\">      <span class=\"function\">jboolean* <span class=\"title\">bool_field_addr</span><span class=\"params\">(<span class=\"type\">int</span> offset)</span>   <span class=\"type\">const</span></span>;</span><br><span class=\"line\">      <span class=\"function\">jint*     <span class=\"title\">int_field_addr</span><span class=\"params\">(<span class=\"type\">int</span> offset)</span>    <span class=\"type\">const</span></span>;</span><br><span class=\"line\">      <span class=\"function\">jshort*   <span class=\"title\">short_field_addr</span><span class=\"params\">(<span class=\"type\">int</span> offset)</span>  <span class=\"type\">const</span></span>;</span><br><span class=\"line\">      <span class=\"function\">jlong*    <span class=\"title\">long_field_addr</span><span class=\"params\">(<span class=\"type\">int</span> offset)</span>   <span class=\"type\">const</span></span>;</span><br><span class=\"line\">      <span class=\"function\">jfloat*   <span class=\"title\">float_field_addr</span><span class=\"params\">(<span class=\"type\">int</span> offset)</span>  <span class=\"type\">const</span></span>;</span><br><span class=\"line\">      <span class=\"function\">jdouble*  <span class=\"title\">double_field_addr</span><span class=\"params\">(<span class=\"type\">int</span> offset)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">      <span class=\"function\">address*  <span class=\"title\">address_field_addr</span><span class=\"params\">(<span class=\"type\">int</span> offset)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">instanceOopDesc</span> : <span class=\"keyword\">public</span> oopDesc &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">arrayOopDesc</span> : <span class=\"keyword\">public</span> oopDesc &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过上面的源码可以看到，<code>instanceOopDesc</code>实际上就是继承了<code>oopDesc</code>，并没有增加其他的数据结构，也就是说<code>instanceOopDesc</code>中主要包含以下几部分数据：<code>markOop _mark</code>和<code>union _metadata</code> 以及一些不同类型的 <code>field</code>。</p>\n<p>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头、实例数据和对齐填充。在虚拟机内部，一个Java对象对应一个<code>instanceOopDesc</code>的对象。其中对象头包含了两部分内容：<code>_mark</code>和<code>_metadata</code>，而实例数据则保存在oopDesc中定义的各种field中。</p>\n<h4 id=\"mark\"><a href=\"#mark\" class=\"headerlink\" title=\"_mark\"></a>_mark</h4><p>文章开头我们就说过，之所以我们要写这篇文章，是因为对象头中有和锁相关的运行时数据，这些运行时数据是<code>synchronized</code>以及其他类型的锁实现的重要基础，而关于锁标记、GC分代等信息均保存在<code>_mark</code>中。因为本文主要介绍的<code>oop-klass</code>模型，在这里暂时不对对象头做展开，下一篇文章介绍。</p>\n<h4 id=\"metadata\"><a href=\"#metadata\" class=\"headerlink\" title=\"_metadata\"></a>_metadata</h4><p>前面介绍到的<code>_metadata</code>是一个共用体，其中<code>_klass</code>是普通指针，<code>_compressed_klass</code>是压缩类指针。在深入介绍之前，就要来到<code>oop-Klass</code>中的另外一个主角<code>klass</code>了。</p>\n<h3 id=\"klass-体系\"><a href=\"#klass-体系\" class=\"headerlink\" title=\"klass 体系\"></a>klass 体系</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//klassOop的一部分，用来描述语言层的类型</span></span><br><span class=\"line\"><span class=\"keyword\">class</span>  <span class=\"title class_\">Klass</span>;</span><br><span class=\"line\"><span class=\"comment\">//在虚拟机层面描述一个Java类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span>   <span class=\"title class_\">instanceKlass</span>;</span><br><span class=\"line\"><span class=\"comment\">//专有instantKlass，表示java.lang.Class的Klass</span></span><br><span class=\"line\"><span class=\"keyword\">class</span>     <span class=\"title class_\">instanceMirrorKlass</span>;</span><br><span class=\"line\"><span class=\"comment\">//专有instantKlass，表示java.lang.ref.Reference的子类的Klass</span></span><br><span class=\"line\"><span class=\"keyword\">class</span>     <span class=\"title class_\">instanceRefKlass</span>;</span><br><span class=\"line\"><span class=\"comment\">//表示methodOop的Klass</span></span><br><span class=\"line\"><span class=\"keyword\">class</span>   <span class=\"title class_\">methodKlass</span>;</span><br><span class=\"line\"><span class=\"comment\">//表示constMethodOop的Klass</span></span><br><span class=\"line\"><span class=\"keyword\">class</span>   <span class=\"title class_\">constMethodKlass</span>;</span><br><span class=\"line\"><span class=\"comment\">//表示methodDataOop的Klass</span></span><br><span class=\"line\"><span class=\"keyword\">class</span>   <span class=\"title class_\">methodDataKlass</span>;</span><br><span class=\"line\"><span class=\"comment\">//最为klass链的端点，klassKlass的Klass就是它自身</span></span><br><span class=\"line\"><span class=\"keyword\">class</span>   <span class=\"title class_\">klassKlass</span>;</span><br><span class=\"line\"><span class=\"comment\">//表示instanceKlass的Klass</span></span><br><span class=\"line\"><span class=\"keyword\">class</span>     <span class=\"title class_\">instanceKlassKlass</span>;</span><br><span class=\"line\"><span class=\"comment\">//表示arrayKlass的Klass</span></span><br><span class=\"line\"><span class=\"keyword\">class</span>     <span class=\"title class_\">arrayKlassKlass</span>;</span><br><span class=\"line\"><span class=\"comment\">//表示objArrayKlass的Klass</span></span><br><span class=\"line\"><span class=\"keyword\">class</span>       <span class=\"title class_\">objArrayKlassKlass</span>;</span><br><span class=\"line\"><span class=\"comment\">//表示typeArrayKlass的Klass</span></span><br><span class=\"line\"><span class=\"keyword\">class</span>       <span class=\"title class_\">typeArrayKlassKlass</span>;</span><br><span class=\"line\"><span class=\"comment\">//表示array类型的抽象基类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span>   <span class=\"title class_\">arrayKlass</span>;</span><br><span class=\"line\"><span class=\"comment\">//表示objArrayOop的Klass</span></span><br><span class=\"line\"><span class=\"keyword\">class</span>     <span class=\"title class_\">objArrayKlass</span>;</span><br><span class=\"line\"><span class=\"comment\">//表示typeArrayOop的Klass</span></span><br><span class=\"line\"><span class=\"keyword\">class</span>     <span class=\"title class_\">typeArrayKlass</span>;</span><br><span class=\"line\"><span class=\"comment\">//表示constantPoolOop的Klass</span></span><br><span class=\"line\"><span class=\"keyword\">class</span>   <span class=\"title class_\">constantPoolKlass</span>;</span><br><span class=\"line\"><span class=\"comment\">//表示constantPoolCacheOop的Klass</span></span><br><span class=\"line\"><span class=\"keyword\">class</span>   <span class=\"title class_\">constantPoolCacheKlass</span>;</span><br></pre></td></tr></table></figure>\n\n<p>和<code>oopDesc</code>是其他 oop 类型的父类一样，Klass 类是其他 klass 类型的父类。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af8e276810cf4833b7acec7d27a44d90~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>Klass 向 JVM 提供两个功能：</p>\n<ul>\n<li>实现语言层面的 Java 类（在 Klass 基类中已经实现）</li>\n<li>实现 Java 对象的分发功能（由 Klass 的子类提供虚函数实现）</li>\n</ul>\n<p>文章开头的时候说过：之所以设计<code>oop-klass</code>模型，是因为HotSopt JVM的设计者不想让每个对象中都含有一个虚函数表。</p>\n<p>HotSopt JVM的设计者把对象一拆为二，分为<code>klass</code>和<code>oop</code>，其中<code>oop</code>的职能主要在于表示对象的实例数据，所以其中不含有任何虚函数。而klass为了实现虚函数多态，所以提供了虚函数表。所以，关于Java的多态，其实也有虚函数的影子在。</p>\n<p><code>_metadata</code>是一个共用体，其中<code>_klass</code>是普通指针，<code>_compressed_klass</code>是压缩类指针。这两个指针都指向<code>instanceKlass</code>对象，它用来描述对象的具体类型。</p>\n<h4 id=\"instanceKlass\"><a href=\"#instanceKlass\" class=\"headerlink\" title=\"instanceKlass\"></a>instanceKlass</h4><p>JVM在运行时，需要一种用来标识Java内部类型的机制。在HotSpot中的解决方案是：为每一个已加载的Java类创建一个<code>instanceKlass</code>对象，用来在JVM层表示Java类。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//类拥有的方法列表</span></span><br><span class=\"line\">  objArrayOop     _methods;</span><br><span class=\"line\">  <span class=\"comment\">//描述方法顺序</span></span><br><span class=\"line\">  typeArrayOop    _method_ordering;</span><br><span class=\"line\">  <span class=\"comment\">//实现的接口</span></span><br><span class=\"line\">  objArrayOop     _local_interfaces;</span><br><span class=\"line\">  <span class=\"comment\">//继承的接口</span></span><br><span class=\"line\">  objArrayOop     _transitive_interfaces;</span><br><span class=\"line\">  <span class=\"comment\">//域</span></span><br><span class=\"line\">  typeArrayOop    _fields;</span><br><span class=\"line\">  <span class=\"comment\">//常量</span></span><br><span class=\"line\">  constantPoolOop _constants;</span><br><span class=\"line\">  <span class=\"comment\">//类加载器</span></span><br><span class=\"line\">  oop             _class_loader;</span><br><span class=\"line\">  <span class=\"comment\">//protected域</span></span><br><span class=\"line\">  oop             _protection_domain;</span><br><span class=\"line\">      ....</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，一个类该具有的东西，这里面基本都包含了。</p>\n<p>在JVM中，对象在内存中的基本存在形式就是oop。那么，对象所属的类，在JVM中也是一种对象，因此它们实际上也会被组织成一种oop，即klassOop。同样的，对于klassOop，也有对应的一个klass来描述，它就是klassKlass，也是klass的一个子类。klassKlass作为oop的klass链的端点。关于对象和数组的klass链大致如下图：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c054f6294609461c83c77040514d57ea~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>在这种设计下，JVM 对内存的分配和回收，都可以采用统一的方式来管理。oop-klass-klass Klass 关系如图：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b0d1f8e1b47444cb0bfc4b938dc82e6~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<h4 id=\"内存存储\"><a href=\"#内存存储\" class=\"headerlink\" title=\"内存存储\"></a>内存存储</h4><p>关于一个Java对象，他的存储是怎样的? 对象的实例（instantOopDesc)保存在堆上，对象的元数据（instantKlass）保存在方法区，对象的引用保存在栈上。</p>\n<p><strong>方法区用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong>  所谓加载的类信息，其实不就是给每一个被加载的类都创建了一个 instantKlass对象么。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Model</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Model</span><span class=\"params\">(<span class=\"type\">int</span> b)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.b = b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"type\">Model</span> <span class=\"variable\">modelA</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Model</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"type\">Model</span> <span class=\"variable\">modelB</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Model</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>存储结构如下：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d56130799e64ce18c0562354ffca6be~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>从上图中可以看到，在方法区的instantKlass中有一个<code>int a=1</code>的数据存储。在堆内存中的两个对象的oop中，分别维护着<code>int b=3</code>,<code>int b=2</code>的实例数据。和oopDesc一样，instantKlass也维护着一些<code>fields</code>，用来保存类中定义的类数据，比如<code>int a=1</code>。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个<code>instanceKlass</code>，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个<code>instanceOopDesc</code>对象，这个对象中包含了两部分信息，对象头以及元数据。对象头中有一些运行时数据，其中就包括和多线程相关的锁的信息。元数据其实维护的是指针，指向的是对象所属的类的<code>instanceKlass</code>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>本文整合自 openjdk 源码及网络相关知识，引用中已备注参考来源，如有侵权，请联系删除。感谢参考文章作者对于技术社区的知识传播。<br>原文：<a href=\"https://juejin.cn/post/7027106902425206797\">https://juejin.cn/post/7027106902425206797</a></p></blockquote>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><ul>\n<li><a href=\"http://www.voidcn.com/article/p-pzznrtkc-ez.html\">http://www.voidcn.com/article/p-pzznrtkc-ez.html</a></li>\n<li><a href=\"https://www.jianshu.com/p/b6cb4c694951\">https://www.jianshu.com/p/b6cb4c694951</a></li>\n<li><a href=\"https://blog.csdn.net/linxdcn/\">https://blog.csdn.net/linxdcn/</a></li>\n</ul>\n","text":"Java对象保存在堆内存中。在内存中，一个Java对象包含三部分：对象头、实例数据和对齐填充。其中对象头是一个很关键的部分，因为对象头中包含锁状态标志、线程持有...","permalink":"/post/jvm/jvm-openjdk-oop-klass","photos":[],"count_time":{"symbolsCount":"7.5k","symbolsTime":"7 mins."},"categories":[{"name":"jvm","slug":"jvm","count":6,"path":"api/categories/jvm.json"}],"tags":[{"name":"jvm","slug":"jvm","count":6,"path":"api/tags/jvm.json"},{"name":"oop-klass","slug":"oop-klass","count":1,"path":"api/tags/oop-klass.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E5%A4%B4\"><span class=\"toc-text\">对象头</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Oop-Klass-%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">Oop-Klass 模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#oop-klass-%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">oop-klass 结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#oop-%E4%BD%93%E7%B3%BB\"><span class=\"toc-text\">oop 体系</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#mark\"><span class=\"toc-text\">_mark</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#metadata\"><span class=\"toc-text\">_metadata</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#klass-%E4%BD%93%E7%B3%BB\"><span class=\"toc-text\">klass 体系</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#instanceKlass\"><span class=\"toc-text\">instanceKlass</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">内存存储</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">引用</span></a></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"聊一聊 Mockito","uid":"9d1ebf7903ce83ad9e7fd07935406bb4","slug":"tests/test-mock-mockito","date":"2021-11-06T03:26:33.000Z","updated":"2024-07-05T04:09:05.845Z","comments":true,"path":"api/articles/tests/test-mock-mockito.json","keywords":null,"cover":[],"text":"Mockito 是 mocking 框架，它让你用简洁的API做测试。而且 Mockito 简单易学，它可读性强和验证语法简洁。 从一个最简单的案例看起 123...","permalink":"/post/tests/test-mock-mockito","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"test","slug":"test","count":5,"path":"api/categories/test.json"}],"tags":[{"name":"test","slug":"test","count":5,"path":"api/tags/test.json"},{"name":"mock","slug":"mock","count":1,"path":"api/tags/mock.json"},{"name":"Mockito","slug":"Mockito","count":1,"path":"api/tags/Mockito.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"finalize 方法重写对 GC 的影响分析","uid":"47efb9065838ed77b0a81f4071199b1e","slug":"java/java-advance-gc-finalize","date":"2021-11-02T03:17:56.000Z","updated":"2024-07-05T04:09:05.761Z","comments":true,"path":"api/articles/java/java-advance-gc-finalize.json","keywords":null,"cover":[],"text":"关于 Object 的 finalize 方法，在日常开发中可能有超过 99% 的人都没有关注过，因为业务开发很少有重写 finalize 方法的场景；开发者对...","permalink":"/post/java/java-advance-gc-finalize","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[{"name":"SOFA","slug":"SOFA","count":9,"path":"api/categories/SOFA.json"}],"tags":[{"name":"gc","slug":"gc","count":3,"path":"api/tags/gc.json"},{"name":"ClassLoader","slug":"ClassLoader","count":4,"path":"api/tags/ClassLoader.json"},{"name":"SOFAArk","slug":"SOFAArk","count":4,"path":"api/tags/SOFAArk.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}