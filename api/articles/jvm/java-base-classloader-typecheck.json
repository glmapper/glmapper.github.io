{"title":"ClassLoader 类加载-type checking 对类加载的影响","uid":"44fd65499cadd100c61bae4110f540c9","slug":"jvm/java-base-classloader-typecheck","date":"2020-05-01T07:21:17.000Z","updated":"2024-07-05T04:09:05.768Z","comments":true,"path":"api/articles/jvm/java-base-classloader-typecheck.json","keywords":null,"cover":null,"content":"<h2 id=\"Type-Checking\"><a href=\"#Type-Checking\" class=\"headerlink\" title=\"Type Checking\"></a>Type Checking</h2><p>Type Checking (类型检测) 的作用是分析程序在编译或者运行期间，其类型表达是否一致的一个过程。举个例子：如果一个变量被声明为 int 类型，那么他就不能被赋值为实际的值（或者字符串类型、或者其他任何类型）。java 语言的类型检测分为两种：</p>\n<ul>\n<li>静态类型检测（static checking）: 问题在程序运行之前被自动找到，也就是在编译阶段完成的检查。静态类型检测更多的是关注在”类型“上。</li>\n<li>动态类型检测（dynamic checking）: 问题在运行期间被检测，动态运行检测关注的是在”值“上。</li>\n</ul>\n<span id=\"more\"></span>\n\n<p>本文主要介绍静态类型检测。java 语言在编译时会做大量的类型检测，只要你声明了一个变量的类型，编译器将会确保只有相应类型的值可以被赋值给这个变量（或者这个值的类型是变量类型的子类型）。比如，如果你声明了如下变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> x;</span><br></pre></td></tr></table></figure>\n<p>这里可以确保它只保存 int 值。但是，如果将变量声明为 List，则该变量可能包含列表的子类型，包括 ArrayList、LinkedList 等。</p>\n<h2 id=\"Type-Checking-对类加载的影响\"><a href=\"#Type-Checking-对类加载的影响\" class=\"headerlink\" title=\"Type Checking 对类加载的影响\"></a>Type Checking 对类加载的影响</h2><p>前面提到静态类型检测主要是对类型的检测，而 java 语言中，类型一致表示的是 <code>类全限定名+ClassLoader</code> 一致，所以在做类型检测时就必定会涉及到某些类的 class load 操作。下面我们就从几个方面来分析下类型检测对于类加载的影响。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在 jvm 参数中配置 <code>-verbose:class</code> 可以观察类加载过程</p></blockquote>\n<h3 id=\"方法的返回类型\"><a href=\"#方法的返回类型\" class=\"headerlink\" title=\"方法的返回类型\"></a>方法的返回类型</h3><p>在下面的例子中， Main 执行过程，check 方法没有被调用，但是该方法返回了一个非 ClassA 的类型，也就是类型 ClassB。那么类型检测就要求就提前加载 ClassA 和 ClassB 类型，加以验证，因此加载顺序如下（ClassA –&gt; ClassB –&gt; ClassC –&gt; ClassD）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClassA</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClassB</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClassA</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClassC</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClassD</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> ClassC c;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        c = <span class=\"keyword\">new</span> <span class=\"title class_\">ClassC</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ClassD</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ClassA <span class=\"title function_\">check</span><span class=\"params\">(ClassA a)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassB</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行查看类加载顺序如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Loaded com.glmapper.bridge.boot.methodreturn.Main from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class=\"line\">[Loaded sun.launcher.LauncherHelper$FXHelper from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class=\"line\">[Loaded java.lang.Class$MethodArray from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class=\"line\">[Loaded com.glmapper.bridge.boot.methodreturn.ClassA from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class=\"line\">[Loaded com.glmapper.bridge.boot.methodreturn.ClassB from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class=\"line\">[Loaded java.lang.Void from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class=\"line\">[Loaded com.glmapper.bridge.boot.methodreturn.ClassC from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class=\"line\">[Loaded com.glmapper.bridge.boot.methodreturn.ClassD from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br></pre></td></tr></table></figure>\n<p>从这里可以看到，静态域不一定会比非静态域先加载，这里就是因为静态检测提前出发了类的加载导致。</p>\n<h3 id=\"方法参数\"><a href=\"#方法参数\" class=\"headerlink\" title=\"方法参数\"></a>方法参数</h3><p>先来看下下面这段代码，大家可以想一下类加载顺序是什么样的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClassA</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClassB</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClassA</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClassC</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> ClassC c;</span><br><span class=\"line\">    <span class=\"keyword\">static</span>  &#123;</span><br><span class=\"line\">        c = <span class=\"keyword\">new</span> <span class=\"title class_\">ClassC</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Main</span> <span class=\"variable\">main</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Main</span>();</span><br><span class=\"line\">        main.m(<span class=\"keyword\">new</span> <span class=\"title class_\">ClassB</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">m</span><span class=\"params\">(ClassA a)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>按照我们惯性理解，Main 加载之后，会加载 ClassC，然后再加载 ClassA 和 ClassB。但是事实是这样吗？通过 -verbose:class 参数执行结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Loaded com.glmapper.bridge.boot.paramscheck.Main from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class=\"line\">[Loaded sun.launcher.LauncherHelper$FXHelper from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class=\"line\">[Loaded java.lang.Class$MethodArray from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class=\"line\">[Loaded com.glmapper.bridge.boot.paramscheck.ClassA from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class=\"line\">[Loaded com.glmapper.bridge.boot.paramscheck.ClassB from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class=\"line\">[Loaded java.lang.Void from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class=\"line\">[Loaded com.glmapper.bridge.boot.paramscheck.ClassC from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>但是从这里看到，Main 执行时， ClassA ，ClassB 先于 ClassC 加载了。原因是类型检测过程中，会一行行先行的看你的代码，在这个场景中，它发现有 m(ClassA a) 方法，但是代码中传入了 ClassB 这个类型，那么在真正运行 main 方法之前，在运行 Main 的 static 块之前，先行加载了 ClassA 和 ClassB 两个类型，然后验证它们之间的关系。所以看到的类加载顺序是 ClassA -&gt; ClassB -&gt; ClassC ，而非我们概念中的 ClassC -&gt; ClassA -&gt; ClassB。</p>\n<h3 id=\"变量赋值\"><a href=\"#变量赋值\" class=\"headerlink\" title=\"变量赋值\"></a>变量赋值</h3><p>最后一种场景是变量赋值，来看下面的代码片段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClassA</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClassB</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClassA</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClassC</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClassD</span> &#123;</span><br><span class=\"line\">    ClassA a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> ClassC c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        c = <span class=\"keyword\">new</span> <span class=\"title class_\">ClassC</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ClassD</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassD</span>();</span><br><span class=\"line\">        d.a = <span class=\"keyword\">new</span> <span class=\"title class_\">ClassB</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动 main 方法时，在 jvm 参数中配置 -verbose:class 来观察类型加载顺序；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Loaded com.glmapper.bridge.boot.variableassign.Main from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class=\"line\">[Loaded sun.launcher.LauncherHelper$FXHelper from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class=\"line\">[Loaded java.lang.Class$MethodArray from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class=\"line\">[Loaded com.glmapper.bridge.boot.variableassign.ClassA from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class=\"line\">[Loaded com.glmapper.bridge.boot.variableassign.ClassB from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class=\"line\">[Loaded java.lang.Void from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class=\"line\">[Loaded com.glmapper.bridge.boot.variableassign.ClassC from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class=\"line\">[Loaded com.glmapper.bridge.boot.variableassign.ClassD from file:/glmapper/Documents/glmapper/glmapper-blog-samples/glmapper-blog-sample-typecheck/target/classes/]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>是不是又有点出乎意料呢？类型检测发现 Main 中包含了 d.a &#x3D; new ClassB() 的语句，其中 d.a 的类型不是 ClassB，因此会先于 main 方法执行以及先于 Main 中的 static 块执行进行加载。 类型检测，将类型 ClassA 和 ClassB 的加载“提前”了。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本文主要介绍了静态类型检测对于 Class Loader 加载类顺序的影响，了解此逻辑对于在考虑多 class loader 场景处理问题非常有用，对于常规的类似 ClassCastExcetion, LinkageError 等异常排查有一定的意义。</p>\n","text":"Type CheckingType Checking (类型检测) 的作用是分析程序在编译或者运行期间，其类型表达是否一致的一个过程。举个例子：如果一个变量被声...","permalink":"/post/jvm/java-base-classloader-typecheck","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[{"name":"jvm","slug":"jvm","count":6,"path":"api/categories/jvm.json"}],"tags":[{"name":"typecheck","slug":"typecheck","count":1,"path":"api/tags/typecheck.json"},{"name":"classloader","slug":"classloader","count":2,"path":"api/tags/classloader.json"},{"name":"jvm","slug":"jvm","count":6,"path":"api/tags/jvm.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Type-Checking\"><span class=\"toc-text\">Type Checking</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Type-Checking-%E5%AF%B9%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%BD%B1%E5%93%8D\"><span class=\"toc-text\">Type Checking 对类加载的影响</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">方法的返回类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">方法参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">变量赋值</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"什么是中台？","uid":"753168a64d611acbfc5231c389c4fa85","slug":"solutions/solution-series-zhongtai","date":"2020-05-19T03:11:01.000Z","updated":"2024-07-05T04:09:05.812Z","comments":true,"path":"api/articles/solutions/solution-series-zhongtai.json","keywords":null,"cover":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/blogs/middleground/4.png","text":"没有XX台的时代 - 烟囱式的架构在传统IT企业，项目的架构是什么样的呢？无论项目内部的如何复杂，都可简化分为前台和后台两部分，也就是垂直的烟囱式架构（业内人士...","permalink":"/post/solutions/solution-series-zhongtai","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"解决方案","slug":"解决方案","count":5,"path":"api/categories/解决方案.json"}],"tags":[{"name":"架构","slug":"架构","count":4,"path":"api/tags/架构.json"},{"name":"中台","slug":"中台","count":1,"path":"api/tags/中台.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"【译】微服务（microservices）","uid":"5845178adf5da311babad1f01389aa66","slug":"solutions/solution-series-microservices","date":"2020-04-12T07:36:06.000Z","updated":"2024-07-05T04:09:05.811Z","comments":true,"path":"api/articles/solutions/solution-series-microservices.json","keywords":null,"cover":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/micro/service-boundle.png","text":" 原文链接：https://martinfowler.com/articles/microservices.html 目录 微服务体系结构的特征 通过服务拆分实...","permalink":"/post/solutions/solution-series-microservices","photos":[],"count_time":{"symbolsCount":"51k","symbolsTime":"47 mins."},"categories":[{"name":"解决方案","slug":"解决方案","count":5,"path":"api/categories/解决方案.json"}],"tags":[{"name":"架构","slug":"架构","count":4,"path":"api/tags/架构.json"},{"name":"微服务","slug":"微服务","count":2,"path":"api/tags/微服务.json"},{"name":"microservices","slug":"microservices","count":1,"path":"api/tags/microservices.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}