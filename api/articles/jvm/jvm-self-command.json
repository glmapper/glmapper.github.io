{"title":"JVM 性能调优监控工具","uid":"720aeef568b7f074067984fdc263021a","slug":"jvm/jvm-self-command","date":"2020-10-26T15:49:29.000Z","updated":"2024-07-05T04:09:05.769Z","comments":true,"path":"api/articles/jvm/jvm-self-command.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"content":"<p>本篇主要学习记录下工作中常用的 <code>JDK</code> 自带的一些 <code>JVM</code> 性能调优监控工具，通过了解这些工具，可以在排查问题时给予我们非常大的帮助，将一些隐藏在底下的东西拿到明面上来做分析。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"jps-Java-Virtual-Machine-Process-Status-Tool\"><a href=\"#jps-Java-Virtual-Machine-Process-Status-Tool\" class=\"headerlink\" title=\"jps(Java Virtual Machine Process Status Tool)\"></a>jps(Java Virtual Machine Process Status Tool)</h1><p><code>jps</code> 主要用来输出 <code>JVM</code> 中运行的进程状态信息。语法格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jps [options] [hostid]</span><br></pre></td></tr></table></figure>\n\n<p>如果不指定 <code>hostid</code> 就默认为当前主机或服务器，命令行参数选项说明如下：</p>\n<p><strong>-q 不输出类名、Jar名和传入main方法的参数</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ~ jps -q</span><br><span class=\"line\">42060</span><br></pre></td></tr></table></figure>\n\n<p><strong>-m 输出传入 main 方法的参数(与默认 jps 指令返回的信息相同)</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ~ jps -m</span><br><span class=\"line\">42060 TestSofaBootApplication</span><br></pre></td></tr></table></figure>\n\n<p><strong>-l 输出 main 类或 jar 的全限名</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ~ jps -l</span><br><span class=\"line\">42060 com.glmapper.bridge.boot.TestSofaBootApplication</span><br></pre></td></tr></table></figure>\n\n<p><strong>-v 输出传入 JVM 的参数</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ~ jps -v</span><br><span class=\"line\">42060 TestSofaBootApplication -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:51645,suspend=y,server=n -XX:TieredStopAtLevel=1 -Xverify:none -Dspring.output.ansi.enabled=always -Dcom.sun.management.jmxremote -Dspring.jmx.enabled=true -Dspring.liveBeansView.mbeanDomain -Dspring.application.admin.enabled=true -javaagent:/Users/xxxx/Library/Caches/JetBrains/IntelliJIdea2020.1/captureAgent/debugger-agent.jar -Dfile.encoding=UTF-8</span><br></pre></td></tr></table></figure>\n\n<p>在排查问题时，我们通过都会通过 <code>jps</code> 来看下当前机器运行的进程有哪些，通过不同的参数来快速找到我们目标进程所在的 <code>pid</code>，以便于我们后续的一系列排查操作。</p>\n<h1 id=\"jstack-Java-Stack-Trace\"><a href=\"#jstack-Java-Stack-Trace\" class=\"headerlink\" title=\"jstack(Java Stack Trace)\"></a>jstack(Java Stack Trace)</h1><p><strong>jstack</strong> 主要用来查看某个 <code>Java</code> 进程内的线程堆栈信息。如果 <code>java</code> 程序崩溃生成 <code>core</code> 文件，<code>jstack</code> 工具可以用来获得 <code>core</code> 文件的 <code>java stack</code> 和 <code>native stack</code> 的信息，从而可以轻松地知道 <code>java</code> 程序是如何崩溃和在程序何处发生问题。另外，<code>jstack</code> 工具还可以附属到正在运行的 <code>java</code> 程序中，看到当时运行的 <code>java</code> 程序的 <code>java stack</code> 和 <code>native stack</code> 的信息, 如果现在运行的 <code>java</code> 程序呈现 <code>hung</code> 的状态，<code>jstack</code> 是非常有用的。</p>\n<p>下面是 <code>jstack</code> 语法格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstack [option] pid</span><br><span class=\"line\">jstack [option] executable core</span><br><span class=\"line\">jstack [option] [server-id@]remote-hostname-or-ip</span><br></pre></td></tr></table></figure>\n\n<p><strong>不管是什么指令，我们都要学会先通过 -h 去查一下</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ~ jstack -h</span><br><span class=\"line\">Usage:</span><br><span class=\"line\">    jstack [-l] &lt;pid&gt;</span><br><span class=\"line\">        (连接到正在运行的进程)</span><br><span class=\"line\">    jstack -F [-m] [-l] &lt;pid&gt;</span><br><span class=\"line\">        (连接到挂起的进程)</span><br><span class=\"line\">    jstack [-m] [-l] &lt;executable&gt; &lt;core&gt;</span><br><span class=\"line\">        (连接到 core 文件)</span><br><span class=\"line\">    jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class=\"line\">        (连接到远程调试服务器)</span><br><span class=\"line\"></span><br><span class=\"line\">Options:</span><br><span class=\"line\">    -F  to force a thread dump. Use when jstack &lt;pid&gt; does not respond (process is hung)</span><br><span class=\"line\">    -m  to print both java and native frames (mixed mode)</span><br><span class=\"line\">    -l  long listing. Prints additional information about locks</span><br><span class=\"line\">    -h or -help to print this help message</span><br></pre></td></tr></table></figure>\n\n<p><code>Options</code> 参数说明如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">选项</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">-F</td>\n<td align=\"left\">当正常输出的请求不被响应时，强制输出线程堆栈</td>\n</tr>\n<tr>\n<td align=\"left\">-m</td>\n<td align=\"left\">如果调用到本地方法的话，可以显示 C&#x2F;C++ 的堆栈</td>\n</tr>\n<tr>\n<td align=\"left\">-l</td>\n<td align=\"left\">除堆栈外，显示关于锁的附加信息，在发生死锁时可以用 jstack -l pid 来观察锁持有情况</td>\n</tr>\n</tbody></table>\n<p>下面我们重点来聊一聊，<code>jstack</code> 中信息到底要怎么看。</p>\n<h2 id=\"jstack-堆栈信息介绍\"><a href=\"#jstack-堆栈信息介绍\" class=\"headerlink\" title=\"jstack 堆栈信息介绍\"></a>jstack 堆栈信息介绍</h2><p>下面是 <code>jstack</code> 输出的一段 <code>tacer</code> 数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;main&quot; #1 prio=5 os_prio=31 tid=0x00007fb93b802000 nid=0x2703 waiting on condition [0x0000700005e5d000]</span><br><span class=\"line\">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class=\"line\">\tat java.lang.Thread.sleep(Native Method)</span><br><span class=\"line\">\tat com.glmapper.bridge.boot.TestJstack.testWaitingOnConditionCondition(TestJstack.java:19)</span><br><span class=\"line\">\tat com.glmapper.bridge.boot.TestJstack.main(TestJstack.java:10)</span><br></pre></td></tr></table></figure>\n\n<p>通过这段数据我们大概能 <code>get</code> 到的点主要包括以下信息：</p>\n<ul>\n<li>main 线程名</li>\n<li>#1 堆栈序号，没有实际含义，可忽略</li>\n<li>prio 线程优先级</li>\n<li>os_prio 操作系统层次的优先级</li>\n<li>tid 线程标识</li>\n<li>nid 线程id</li>\n</ul>\n<h2 id=\"线程状态介绍\"><a href=\"#线程状态介绍\" class=\"headerlink\" title=\"线程状态介绍\"></a>线程状态介绍</h2><p>从上面 jstack 输出的信息可以看到线程状态相关的信息，比如</p>\n<h4 id=\"TIMED-WAITING\"><a href=\"#TIMED-WAITING\" class=\"headerlink\" title=\"TIMED_WAITING\"></a>TIMED_WAITING</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"RUNNABLE\"><a href=\"#RUNNABLE\" class=\"headerlink\" title=\"RUNNABLE\"></a>RUNNABLE</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.Thread.State: RUNNABLE</span><br></pre></td></tr></table></figure>\n\n<p>还有一些 <code>&quot;GC task thread#0 (ParallelGC)&quot; os_prio=31 tid=0x00007fcee9004000 nid=0x1f07 runnable</code> 信息，这种是 jvm 用来回收内存的，先不关注，这里主要看下 <code>java.lang.Thread.State</code>;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">State</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 当线程对象创建时存在的状态，此时线程不可能执行</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    NEW,</span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 当调用thread.start()后，线程变成为 Runnable 状态。只要得到CPU，就可以执行；</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    RUNNABLE,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果进入同步方法或同步代码块，没有获取到锁，则会进入该状态；</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    BLOCKED,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 执行thread.join()或在锁对象调用obj.wait()等情况就会进该状态，表明线程正处于等待某个资源或条件发生来唤醒自己；</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    WAITING,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 执行Thread.sleep(long)、thread.join(long)或obj.wait(long)等就会进该状态，与Waiting的区别在于Timed_Waiting的等待有时间限制；</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    TIMED_WAITING,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 终止</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    TERMINATED;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再回到上面堆栈信息，可以观察到，当状态是 TIMED_WAITING 时，堆栈中会出现 <code>waiting on condition xxxx</code> 信息，类似的还有：</p>\n<ul>\n<li>waiting on monitor entry : 在等待获取锁，一般对应 BLOCKED</li>\n<li>in Object.wait() : 获取锁后又执行obj.wait()放弃锁，一般对应 WAITING</li>\n</ul>\n<p>下面就针对这些状态举一些简单的小例子。</p>\n<h2 id=\"线程状态举例及-jstack-分析\"><a href=\"#线程状态举例及-jstack-分析\" class=\"headerlink\" title=\"线程状态举例及 jstack 分析\"></a>线程状态举例及 jstack 分析</h2><h3 id=\"waiting-on-condition\"><a href=\"#waiting-on-condition\" class=\"headerlink\" title=\"waiting on condition\"></a>waiting on condition</h3><p><strong>1、执行代码</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 产生 waiting on condition</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testWaitingOnConditionCondition</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">60000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2、执行结果</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;main&quot; #1 prio=5 os_prio=31 tid=0x00007fb93b802000 nid=0x2703 waiting on condition [0x0000700005e5d000]</span><br><span class=\"line\">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class=\"line\">\tat java.lang.Thread.sleep(Native Method)</span><br><span class=\"line\">\tat com.glmapper.bridge.boot.TestJstack.testWaitingOnConditionCondition(TestJstack.java:19)</span><br><span class=\"line\">\tat com.glmapper.bridge.boot.TestJstack.main(TestJstack.java:10)</span><br></pre></td></tr></table></figure>\n\n<p><strong>3、结果分析</strong></p>\n<p>这里就比较明显的是 main 线程中正在 sleep 方法。不过这里 TIMED_WAITING 后面的括号里还特殊表明了 <code>sleeping</code>，在一些场景下，常见的还有 parking，下面继续看例子。</p>\n<h3 id=\"waiting-on-condition-parking\"><a href=\"#waiting-on-condition-parking\" class=\"headerlink\" title=\"waiting on condition (parking)\"></a>waiting on condition (parking)</h3><p><strong>1、执行代码</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testWaitingOnConditionConditionWithParking</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 提供一个阻塞对了</span></span><br><span class=\"line\">    BlockingQueue&lt;String&gt; blockingQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayBlockingQueue</span>&lt;String&gt;(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 先加一个</span></span><br><span class=\"line\">    blockingQueue.add(<span class=\"string\">&quot;test-parking&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//继续加，这里肯定加不进去，所以会阻塞</span></span><br><span class=\"line\">        blockingQueue.put(<span class=\"string\">&quot;test-parking-xxx&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2、执行结果</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;main&quot; #1 prio=5 os_prio=31 tid=0x00007fd6d5008800 nid=0x2803 waiting on condition [0x000070000ffc1000]</span><br><span class=\"line\">   java.lang.Thread.State: WAITING (parking)</span><br><span class=\"line\">\tat sun.misc.Unsafe.park(Native Method)</span><br><span class=\"line\">\t- parking to wait for  &lt;0x000000076af3a938&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class=\"line\">\tat java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class=\"line\">\tat java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class=\"line\">\tat java.util.concurrent.ArrayBlockingQueue.put(ArrayBlockingQueue.java:353)</span><br><span class=\"line\">\tat com.glmapper.bridge.boot.TestJstack.testWaitingOnConditionConditionWithParking(TestJstack.java:113)</span><br><span class=\"line\">\tat com.glmapper.bridge.boot.TestJstack.main(TestJstack.java:13)</span><br></pre></td></tr></table></figure>\n\n<p><strong>3、结果分析</strong></p>\n<p>main 线程进入了 waiting on conditon 状态，等待某一个资源，可以看到是在 <code>a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObjec</code> 进行了等待，阻塞住了。</p>\n<h3 id=\"waiting-on-monitor-entry\"><a href=\"#waiting-on-monitor-entry\" class=\"headerlink\" title=\"waiting on monitor entry\"></a>waiting on monitor entry</h3><p><strong>1、执行代码</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 产生 waiting on monitor entry</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testWaitingOnMonitorEntry</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Thread</span> <span class=\"variable\">thread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 锁 obj 对象</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (obj)&#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">60000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Thread</span> <span class=\"variable\">thread1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 锁 obj 对象</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (obj)&#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">60000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    thread.setName(<span class=\"string\">&quot;test-thread&quot;</span>);</span><br><span class=\"line\">    thread.start();</span><br><span class=\"line\">    thread1.setName(<span class=\"string\">&quot;test-thread1&quot;</span>);</span><br><span class=\"line\">    thread1.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2、执行结果</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;test-thread1&quot; #14 prio=5 os_prio=31 tid=0x00007f9563880800 nid=0x5c03 waiting for monitor entry [0x000070000b029000]</span><br><span class=\"line\">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class=\"line\">\tat com.glmapper.bridge.boot.TestJstack$2.run(TestJstack.java:50)</span><br><span class=\"line\">\t- waiting to lock &lt;0x000000076af261d0&gt; (a java.lang.Object)</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;test-thread&quot; #13 prio=5 os_prio=31 tid=0x00007f956387f800 nid=0x5a03 waiting on condition [0x000070000af26000]</span><br><span class=\"line\">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class=\"line\">\tat java.lang.Thread.sleep(Native Method)</span><br><span class=\"line\">\tat com.glmapper.bridge.boot.TestJstack$1.run(TestJstack.java:38)</span><br><span class=\"line\">\t- locked &lt;0x000000076af261d0&gt; (a java.lang.Object)</span><br></pre></td></tr></table></figure>\n\n<p><strong>3、结果分析</strong></p>\n<p>test-thread 获取到 obj 对象上的锁，因此正在执行 sleep 操作，状态为 TIMED_WAINTING, 而 test-thread1 由于未获取到 obj 对象上的锁，因此处于BLOCKED 状态。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>test-thread1 正在 “waiting to lock &lt;0x000000076af261d0&gt;”，试图在地址为 0x000000076af261d0 所在的对象获取锁，而该锁却被 test-thread 线程占有 [locked &lt;0x000000076af261d0&gt;]。test-thread 线程正在 “waiting on condition”，说明正在等待某个条件触发，由 jstack 来看，此线程正在sleep。</p></blockquote>\n<h3 id=\"object-wait\"><a href=\"#object-wait\" class=\"headerlink\" title=\"object.wait()\"></a>object.wait()</h3><p><strong>1、执行代码</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testObjectWait</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Thread</span> <span class=\"variable\">thread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    wait();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    thread.start();</span><br><span class=\"line\">    thread.setName(<span class=\"string\">&quot;test-object-wait&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (thread) &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">30000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        thread.notify();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2、执行结果</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;test-object-wait&quot; #13 prio=5 os_prio=31 tid=0x00007fd43a809000 nid=0xa803 in Object.wait() [0x0000700010926000]</span><br><span class=\"line\">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class=\"line\">\tat java.lang.Object.wait(Native Method)</span><br><span class=\"line\">\t- waiting on &lt;0x000000076af26140&gt; (a com.glmapper.bridge.boot.TestJstack$3)</span><br><span class=\"line\">\tat java.lang.Object.wait(Object.java:502)</span><br><span class=\"line\">\tat com.glmapper.bridge.boot.TestJstack$3.run(TestJstack.java:73)</span><br><span class=\"line\">\t- locked &lt;0x000000076af26140&gt; (a com.glmapper.bridge.boot.TestJstack$3)</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;main&quot; #1 prio=5 os_prio=31 tid=0x00007fd43b001800 nid=0x2603 waiting on condition [0x000070000f2e4000]</span><br><span class=\"line\">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class=\"line\">\tat java.lang.Thread.sleep(Native Method)</span><br><span class=\"line\">\tat com.glmapper.bridge.boot.TestJstack.testObjectWait(TestJstack.java:93)</span><br><span class=\"line\">\t- locked &lt;0x000000076af26140&gt; (a com.glmapper.bridge.boot.TestJstack$3)</span><br><span class=\"line\">\tat com.glmapper.bridge.boot.TestJstack.main(TestJstack.java:10)</span><br></pre></td></tr></table></figure>\n\n<p><strong>3、结果分析</strong></p>\n<p>由于调用了 object.wait() 方法的时候放弃了锁，所以 <code>test-object-wait</code> 这个线程就出现了 Object.wait() 状态，线程的状态就是 waiting；等待 notify 来进行唤醒。由于 mian 线程在获得 <code>test-object-wait</code> 的线程锁后，调用了 Thread.sleep 方法，所以此时进入了 wating on condition 等待某一个资源，进入到 time_waiting 状态。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>一般情况我们在做问题排查时，如果系统非常慢，我们需要特别关注 <code>Blocked</code>，<code>Waiting on condition</code> 这些状态。如果系统的 cpu 负载比较高的话，则可以死循环等思路去摸查，此时要关注下 <code>Runable</code> 状态；那如果堆栈中有 <code>Deadlock</code>，那就是产生了死锁。</p>\n<h1 id=\"jstat-JVM统计监测工具\"><a href=\"#jstat-JVM统计监测工具\" class=\"headerlink\" title=\"jstat(JVM统计监测工具)\"></a>jstat(JVM统计监测工具)</h1><p><code>jstat</code> 是 JVM 统计监测工具，其语法格式如下：<br> <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br></pre></td></tr></table></figure></p>\n<p> <code>vmid</code> 是 <code>Java</code> 虚拟机 <code>ID</code>，在 <code>Linux/Unix</code> 系统上一般就是进程 <code>ID</code>。<code>interval</code> 是采样时间间隔; <code>count</code> 是采样数目。比如下面输出的是 <code>GC</code> 信息，采样时间间隔为 1000ms，采样数为 3：<br> <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ~ jstat -gc 58950 1000 3</span><br><span class=\"line\"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class=\"line\">10752.0 10752.0  0.0    0.0   65536.0   6554.0   175104.0     0.0     4480.0 785.7  384.0   75.9       0    0.000   0      0.000    0.000</span><br><span class=\"line\">10752.0 10752.0  0.0    0.0   65536.0   6554.0   175104.0     0.0     4480.0 785.7  384.0   75.9       0    0.000   0      0.000    0.000</span><br><span class=\"line\">10752.0 10752.0  0.0    0.0   65536.0   6554.0   175104.0     0.0     4480.0 785.7  384.0   75.9       0    0.000   0      0.000    0.000</span><br></pre></td></tr></table></figure></p>\n<p> 输出信息的列释义：</p>\n<ul>\n<li>S0C、S1C、S0U、S1U：Survivor 0&#x2F;1区容量（Capacity）和使用量（Used）</li>\n<li>EC、EU：Eden区容量和使用量</li>\n<li>OC、OU：年老代容量和使用量</li>\n<li>PC、PU：永久代容量和使用量</li>\n<li>YGC、YGT：年轻代 GC 次数和 GC 耗时</li>\n<li>FGC、FGCT：Full GC 次数和 Full GC耗时</li>\n<li>GCT：GC 总耗时</li>\n</ul>\n<h1 id=\"jmap-Memory-Map\"><a href=\"#jmap-Memory-Map\" class=\"headerlink\" title=\"jmap(Memory Map)\"></a>jmap(Memory Map)</h1><p><code>jmap</code> 用来查看堆内存使用状况，一般结合 <code>jhat</code> 使用。其使用语法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap [option] &lt;pid&gt;</span><br><span class=\"line\">jmap [option] &lt;executable &lt;core&gt;</span><br><span class=\"line\">jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br></pre></td></tr></table></figure>\n\n<p><code>Options</code> 参数说明如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">选项</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><none></td>\n<td align=\"left\">打印与 <code>Solaris pmap</code> 相同的信息</td>\n</tr>\n<tr>\n<td align=\"left\">-heap</td>\n<td align=\"left\">打印 <code>java</code> 堆摘要</td>\n</tr>\n<tr>\n<td align=\"left\">-histo[:live]</td>\n<td align=\"left\">打印 java 对象堆的直方图;如果指定了“live”子选项，则只计算live对象</td>\n</tr>\n<tr>\n<td align=\"left\">-clstats</td>\n<td align=\"left\">打印 classloader 统计信息</td>\n</tr>\n<tr>\n<td align=\"left\">-finalizerinfo</td>\n<td align=\"left\">打印 等待终结 对象的信息</td>\n</tr>\n<tr>\n<td align=\"left\">–dump:<dump-options> :</td>\n<td align=\"left\">以 hprof 二进制格式dump java heap</td>\n</tr>\n<tr>\n<td align=\"left\">-F</td>\n<td align=\"left\">使用 -dump:<dump-options> <pid> or -histo 强制执行</td>\n</tr>\n<tr>\n<td align=\"left\">-J<flag></td>\n<td align=\"left\">将 <flag> 直接传递给运行时系统</td>\n</tr>\n</tbody></table>\n<p>dump-options 又包括以下几个选项：</p>\n<ul>\n<li>live ： 只 dump 活动对象;如果未指定，堆中的所有对象将被dump。</li>\n<li>format&#x3D;b ： 二进制格式</li>\n<li>file&#x3D;<file> ： dump 到指定文件</li>\n</ul>\n<h2 id=\"jmap-heap\"><a href=\"#jmap-heap\" class=\"headerlink\" title=\"jmap -heap\"></a><code>jmap -heap</code></h2><p>通过指定 <code>pid</code>，可以将当前进程的 <code>heap</code> 信息打印在 <code>console</code> 上，包括使用的 <code>GC</code> 算法、堆配置参数和各代中堆内存使用情况，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jmap -heap 3493</span><br><span class=\"line\">Attaching to process ID 3493, please wait...</span><br><span class=\"line\">Debugger attached successfully.</span><br><span class=\"line\">Server compiler detected.</span><br><span class=\"line\">JVM version is 25.172-b245</span><br><span class=\"line\"></span><br><span class=\"line\">using parallel threads in the new generation.(eden 区使用的是并发线程)</span><br><span class=\"line\">using thread-local object allocation.(使用线程本地对象分配)</span><br><span class=\"line\">Concurrent Mark-Sweep GC (使用 CMS 垃圾收集器)</span><br><span class=\"line\"># 堆配置信息</span><br><span class=\"line\">Heap Configuration:</span><br><span class=\"line\">   MinHeapFreeRatio         = 40</span><br><span class=\"line\">   MaxHeapFreeRatio         = 70</span><br><span class=\"line\">   MaxHeapSize              = 2147483648 (2048.0MB)</span><br><span class=\"line\">   NewSize                  = 805306368 (768.0MB)</span><br><span class=\"line\">   MaxNewSize               = 805306368 (768.0MB)</span><br><span class=\"line\">   OldSize                  = 1342177280 (1280.0MB)</span><br><span class=\"line\">   NewRatio                 = 2</span><br><span class=\"line\">   SurvivorRatio            = 8</span><br><span class=\"line\">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class=\"line\">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class=\"line\">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class=\"line\">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class=\"line\"></span><br><span class=\"line\"># 堆使用情况</span><br><span class=\"line\">Heap Usage:</span><br><span class=\"line\">New Generation (Eden + 1 Survivor Space):</span><br><span class=\"line\">   capacity = 724828160 (691.25MB)</span><br><span class=\"line\">   used     = 35156456 (33.527809143066406MB)</span><br><span class=\"line\">   free     = 689671704 (657.7221908569336MB)</span><br><span class=\"line\">   4.850315970063856% used</span><br><span class=\"line\">Eden Space:</span><br><span class=\"line\">   capacity = 644349952 (614.5MB)</span><br><span class=\"line\">   used     = 19878008 (18.95714569091797MB)</span><br><span class=\"line\">   free     = 624471944 (595.542854309082MB)</span><br><span class=\"line\">   3.084970820328392% used</span><br><span class=\"line\">From Space:</span><br><span class=\"line\">   capacity = 80478208 (76.75MB)</span><br><span class=\"line\">   used     = 15278448 (14.570663452148438MB)</span><br><span class=\"line\">   free     = 65199760 (62.17933654785156MB)</span><br><span class=\"line\">   18.984577787815553% used</span><br><span class=\"line\">To Space:</span><br><span class=\"line\">   capacity = 80478208 (76.75MB)</span><br><span class=\"line\">   used     = 0 (0.0MB)</span><br><span class=\"line\">   free     = 80478208 (76.75MB)</span><br><span class=\"line\">   0.0% used</span><br><span class=\"line\">concurrent mark-sweep generation:</span><br><span class=\"line\">   capacity = 1342177280 (1280.0MB)</span><br><span class=\"line\">   used     = 166885296 (159.1542205810547MB)</span><br><span class=\"line\">   free     = 1175291984 (1120.8457794189453MB)</span><br><span class=\"line\">   12.433923482894897% used</span><br><span class=\"line\"></span><br><span class=\"line\">55843 interned Strings occupying 6689024 bytes.</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"jmap-clstats\"><a href=\"#jmap-clstats\" class=\"headerlink\" title=\"jmap -clstats\"></a>jmap -clstats</h2><p>通过指定 pid ，可以将当前进程的 classloader 统计信息打印在 console 上，包括类加载器名称、对象是否存活、对象地址、父类加载器、已加载的类大小等信息，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jmap -clstats  3493</span><br><span class=\"line\">Attaching to process ID 3493, please wait...</span><br><span class=\"line\">Debugger attached successfully.</span><br><span class=\"line\">Server compiler detected.</span><br><span class=\"line\">JVM version is 25.172-b245</span><br><span class=\"line\">finding class loader instances ..done.</span><br><span class=\"line\">computing per loader stat ..done.</span><br><span class=\"line\">please wait.. computing liveness.......................liveness analysis may be inaccurate ...</span><br><span class=\"line\">class_loader\tclasses\tbytes\tparent_loader\talive?\ttype</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bootstrap&gt;\t3211\t5818395\t  null  \tlive\t&lt;internal&gt;</span><br><span class=\"line\">0x00000000b150ed50\t1\t1491\t0x00000000b0020830\tdead\tsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class=\"line\">0x00000000b8715670\t1\t900\t    0x00000000b0020830\tdead\tsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class=\"line\">0x00000000cb417140\t1\t1503\t0x00000000b0020830\tdead\tsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class=\"line\">0x00000000b98b4388\t1\t1491\t  null  \tdead\tsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class=\"line\">0x00000000b5a419a0\t1\t900\t    0x00000000b0020830\tdead\tsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class=\"line\">0x00000000b358df50\t1\t1493\t0x00000000b0020830\tdead\tsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class=\"line\">0x00000000b7b277b8\t1\t1503\t0x00000000b0020830\tdead\tsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class=\"line\">0x00000000c2527c58\t1\t1505\t0x00000000b0020830\tdead\tsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class=\"line\">0x00000000b98b4580\t1\t1491\t0x00000000b0026260\tdead\tsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class=\"line\">0x00000000b9b307b8\t1\t1493\t0x00000000b0020830\tdead\tsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class=\"line\">0x00000000e236b038\t1\t900\t    0x00000000b0020830\tdead\tsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class=\"line\">0x00000000b0108400\t1\t1493\t0x00000000b0020830\tdead\tsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br><span class=\"line\">0x00000000b010bc00\t3\t7946\t0x00000000b0022f60\tlive\torg/jacoco/compass/agent/rt/internal/fastjson/util/ASMClassLoader@0x00000001000eb830</span><br><span class=\"line\">0x00000000b358e148\t1\t1493\t0x00000000b0020830\tdead\tsun/reflect/DelegatingClassLoader@0x000000010000a040</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"jmap-histo\"><a href=\"#jmap-histo\" class=\"headerlink\" title=\"jmap -histo\"></a>jmap -histo</h2><p>使用 jmap -histo pid 可以查看堆内存中的对象数目、大小统计直方图，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># jmap -histo:live 1493  带上 live 则只统计存活对象</span><br><span class=\"line\">$ jmap -histo 1493  </span><br><span class=\"line\">num     #instances         #bytes  class name</span><br><span class=\"line\">----------------------------------------------</span><br><span class=\"line\">   1:       1314509      144436976  [C</span><br><span class=\"line\">   2:       1572864       37748736  org.apache.logging.log4j.core.async.AsyncLoggerConfigDisruptor$Log4jEventWrapper</span><br><span class=\"line\">   3:         77458       32776608  [B</span><br><span class=\"line\">   4:       1061561       25477464  java.lang.String</span><br><span class=\"line\">   5:        731623       23411936  java.util.HashMap$Node</span><br><span class=\"line\">   6:         32930       22826616  [I</span><br><span class=\"line\">   7:        150340       15546784  [Ljava.util.HashMap$Node;</span><br><span class=\"line\">   8:        144895       14968208  [Ljava.lang.Object;</span><br><span class=\"line\">   9:        377379       12076128  java.util.concurrent.ConcurrentHashMap$Node</span><br><span class=\"line\">  10:        230943       11085264  java.util.HashMap</span><br><span class=\"line\">  11:         81124        3893952  java.nio.HeapByteBuffer</span><br><span class=\"line\">  12:          3396        3869944  [Ljava.util.concurrent.ConcurrentHashMap$Node;</span><br><span class=\"line\">  13:         78418        3764064  java.nio.HeapCharBuffer</span><br><span class=\"line\">  14:         75784        3031360  java.util.TreeMap$Entry</span><br><span class=\"line\">  15:         72865        2914600  java.util.LinkedHashMap$Entry</span><br><span class=\"line\">  16:        166213        2659408  java.util.HashSet</span><br><span class=\"line\">  17:         18355        2643120  com.mysql.jdbc.Field</span><br><span class=\"line\">  18:         18394        2044336  java.lang.Class</span><br><span class=\"line\">  19:         19966        1757008  java.lang.reflect.Method</span><br></pre></td></tr></table></figure>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>PS: 上图中的 [C [B 指的是 class 的对象类型，下面是常见类型的参考</p>\n<ul>\n<li>B  byte</li>\n<li>C  char</li>\n<li>D  double</li>\n<li>F  float</li>\n<li>I  int</li>\n<li>J  long</li>\n<li>Z  boolean</li>\n<li>[  数组，如 [I 表示 int[]</li>\n<li>[L+类名 其他对象，如 [Ljava.lang.Object</li>\n</ul></blockquote>\n<h2 id=\"jmap-dump\"><a href=\"#jmap-dump\" class=\"headerlink\" title=\"jmap -dump\"></a>jmap -dump</h2><p>绝大多数情况下，我们不会直接在 console 来打印分析，更常规的做法是 dump 到指定的文件，然后通过一些可视化工具来辅助分析；那执行 dump 到文件一般使用如下指令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap -dump:format=b,file=dumpFileName pid   # 语法</span><br><span class=\"line\"></span><br><span class=\"line\">$ jmap -dump:format=b,file=test-dump.bin 85716  # 举例</span><br><span class=\"line\">Dumping heap to /Users/guolei.sgl/test-dump.bin ...</span><br><span class=\"line\">Heap dump file created</span><br></pre></td></tr></table></figure>\n\n<p>对于 dump 下来的文件，可以通过 jprofile 等图形化工具来分析，如下</p>\n<p><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/jprofile.jpg\"></p>\n<p>也可以通过 jhat 查看，操作方式如下：</p>\n<p><strong>1、起 http 服务</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jhat -port 9300 test-dump.bin</span><br><span class=\"line\">Reading from test-dump.bin...</span><br><span class=\"line\">Dump file created Wed Oct 28 17:54:24 CST 2020</span><br><span class=\"line\">Snapshot read, resolving...</span><br><span class=\"line\">Resolving 1151952 objects...</span><br><span class=\"line\">Chasing references, expect 230 dots......................................................................................................................................................................................................................................</span><br><span class=\"line\">Eliminating duplicate references......................................................................................................................................................................................................................................</span><br><span class=\"line\">Snapshot resolved.</span><br><span class=\"line\">Started HTTP server on port 9300</span><br><span class=\"line\">Server is ready.</span><br></pre></td></tr></table></figure>\n\n<p><strong>2、dump 类概要信息</strong></p>\n<p>访问 localhost:9300 查看 dump 概要信息</p>\n<p><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/jvm/jhat.jpg\"></p>\n<p><strong>3、class 详情</strong></p>\n<p>点击某个类查看详细信息</p>\n<p><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/jvm/jhat-details.jpg\"></p>\n<h1 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>本文介绍了一些 JDK 自带的一些性能调优监控工具，通过对这些工具的掌握，可以使的我们在实际的开发或者运维中能够快速的去定位和解决一些问题，常见的有 OOM、内存泄漏、线程死锁、CPU 负载高等等；目前社区也有很多好用的工具，例如 <a href=\"https://arthas.aliyun.com/doc/\">Arthas</a>，<a href=\"https://www.perfma.com/\">perfma</a> 等。</p>\n","text":"本篇主要学习记录下工作中常用的 JDK 自带的一些 JVM 性能调优监控工具，通过了解这些工具，可以在排查问题时给予我们非常大的帮助，将一些隐藏在底下的东西拿到...","permalink":"/post/jvm/jvm-self-command","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"17 mins."},"categories":[{"name":"jvm","slug":"jvm","count":6,"path":"api/categories/jvm.json"}],"tags":[{"name":"jvm","slug":"jvm","count":6,"path":"api/tags/jvm.json"},{"name":"JDK","slug":"JDK","count":1,"path":"api/tags/JDK.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#jps-Java-Virtual-Machine-Process-Status-Tool\"><span class=\"toc-text\">jps(Java Virtual Machine Process Status Tool)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#jstack-Java-Stack-Trace\"><span class=\"toc-text\">jstack(Java Stack Trace)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#jstack-%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">jstack 堆栈信息介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">线程状态介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#TIMED-WAITING\"><span class=\"toc-text\">TIMED_WAITING</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#RUNNABLE\"><span class=\"toc-text\">RUNNABLE</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B8%BE%E4%BE%8B%E5%8F%8A-jstack-%E5%88%86%E6%9E%90\"><span class=\"toc-text\">线程状态举例及 jstack 分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#waiting-on-condition\"><span class=\"toc-text\">waiting on condition</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#waiting-on-condition-parking\"><span class=\"toc-text\">waiting on condition (parking)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#waiting-on-monitor-entry\"><span class=\"toc-text\">waiting on monitor entry</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#object-wait\"><span class=\"toc-text\">object.wait()</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#jstat-JVM%E7%BB%9F%E8%AE%A1%E7%9B%91%E6%B5%8B%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">jstat(JVM统计监测工具)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#jmap-Memory-Map\"><span class=\"toc-text\">jmap(Memory Map)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#jmap-heap\"><span class=\"toc-text\">jmap -heap</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#jmap-clstats\"><span class=\"toc-text\">jmap -clstats</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#jmap-histo\"><span class=\"toc-text\">jmap -histo</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#jmap-dump\"><span class=\"toc-text\">jmap -dump</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93-1\"><span class=\"toc-text\">小结</span></a></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"yum 指令","uid":"fa977817638d540050b6c44615352923","slug":"linux/linux-cmd-yum","date":"2020-10-26T15:55:22.000Z","updated":"2024-07-05T04:09:05.774Z","comments":true,"path":"api/articles/linux/linux-cmd-yum.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"text":" yum(Yellowdog Updater Modified)：是一个基于 RPM 的软件包管理器，能够从指定服务器自动下载RPM包并且安装，可以处理软件之间...","permalink":"/post/linux/linux-cmd-yum","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"Linux","slug":"Linux","count":9,"path":"api/categories/Linux.json"}],"tags":[{"name":"linux","slug":"linux","count":9,"path":"api/tags/linux.json"},{"name":"yum","slug":"yum","count":1,"path":"api/tags/yum.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"Linux Top 命令指南","uid":"3da34a407a5e481b18f31bdb1ed34b7e","slug":"linux/linux-cmd-top","date":"2020-08-10T01:53:31.000Z","updated":"2024-07-05T04:09:05.774Z","comments":true,"path":"api/articles/linux/linux-cmd-top.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":null,"text":"top 命令允许用户监视 Linux 上的进程和系统资源使用情况，它是系统管理员工具箱中最有用的工具之一，并且在每个发行版中都预装了它。与 ps 等其他命令不同...","permalink":"/post/linux/linux-cmd-top","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Linux","slug":"Linux","count":9,"path":"api/categories/Linux.json"}],"tags":[{"name":"linux","slug":"linux","count":9,"path":"api/tags/linux.json"},{"name":"top","slug":"top","count":1,"path":"api/tags/top.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}