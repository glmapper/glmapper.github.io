{"title":"JAVA 虚拟机中的动态类加载","uid":"f83619a0774898a96f9e31bd15954ca9","slug":"jvm/jvm-dynamic-load-class","date":"2020-12-11T02:59:14.000Z","updated":"2024-07-05T04:09:05.768Z","comments":true,"path":"api/articles/jvm/jvm-dynamic-load-class.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>原文连接：<a href=\"https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.18.762&rep=rep1&type=pdf\">https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.18.762&amp;rep=rep1&amp;type=pdf</a></p></blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"0-摘要\"><a href=\"#0-摘要\" class=\"headerlink\" title=\"0 摘要\"></a>0 摘要</h2><p>ClassLoader 是在 Java 平台上动态装入软件组件的强大机制，它们在以下这些特性的支持上非常有意思：</p>\n<ul>\n<li>laziness</li>\n<li>type-safe linkage</li>\n<li>user-defined extensibility</li>\n<li>multiple communicating namespaces</li>\n</ul>\n<p>本篇文章将介绍 ClassLoader 的概念，并演示它们的一些特别用途。此外，本文还讨论了<strong>如何在用户定义的动态类加载中维护类型安全</strong>。</p>\n<h2 id=\"1-介绍\"><a href=\"#1-介绍\" class=\"headerlink\" title=\"1 介绍\"></a>1 介绍</h2><p>在本文中，我们研究了 Java 虚拟机的一个重要特性：动态类加载。这就是提供 Java 平台强大功能的底层机制-在运行时安装软件组件的能力。一个典型的例子是动态下载到 web 浏览器中的 applet。虽然许多其他系统也支持某种形式的动态加载和链接，但是 Java 平台是这些系统中唯一包含以下所有特性的平台：</p>\n<ul>\n<li>Lazy loading：类是按需加载的，类加载应该被尽可能地延迟，从而减少内存的使用并改善系统响应时间。</li>\n<li>Type-safe linkage：动态类加载不能违反 Java 虚拟机的类型安全。为了保证类型安全性，动态加载必须不需要额外的运行时检查。附加的链接时间检查是可以接受的，因为这些检查只执行一次。</li>\n<li>User-definable  class loading policy：ClassLoader 对象也是 Java 中的一类对象，所以开发者完全可以控制动态类加载的行为。比如，用户定义的 ClassLoader  可以指定被加载类的远端位置，或者为从特定源加载的类分配适当的安全属性。</li>\n<li>Multiple namespaces：ClassLoader 为不同的组件提供单独的 namespaces。例如，Hotjava浏览器从不同的源将 applet 加载到单独的类加载器中。这些 applet 可能包含相同名称的类，但是 Java 虚拟机将这些类视为不同的类型（classloader 不同）。</li>\n</ul>\n<p>相比之下，现有的动态链接机制并不支持所有这些特性。尽管大多数操作系统都支持某种形式的动态链接库，但这样的机制是针对C&#x2F; c++代码的，并且不是类型安全的。Lisp、Smalltalk 和 Self 等动态语言通过附加的运行时检查(而不是链接时检查)来实现类型安全。</p>\n<p>本文的主要研究是首次对 ClassLoader 进行深入的描述，ClassLoader 是 Java 平台引入的一个概念，ClassLoader 从 JDK 1.0 版本就已经提供了，其最开始的目前是用于在 Hotjava 浏览器中动态加载 applet 类。也就是从那时起，ClassLoader 的使用得到了扩展，以处理范围更广的组件和场景。如服务器端组件(servlet)、Java平台的扩展机制、以及 javabean 组件。尽管 ClassLoader 的作用越来越重要，但相关文章中并没有对其底层机制进行充分的描述。</p>\n<p>本文的另一个研究点是通过 ClassLoader 为长期存在的类型安全问题提供了一种解决方案。JDK 的早期版本(1.0和1.1)在 ClassLoader 实现中包含一个严重的缺陷。编写不当的 ClassLoader 可能破坏 Java 虚拟机的类型安全保证。请注意，类型安全问题没有直接带来任何安全风险，因为不受信任的代码(例如下载的applet)不允许创建 ClassLoader。尽管如此，需要编写自定义 ClassLoader 的应用程序开发者可能会无意中损害类型安全。</p>\n<p>虽然这个问题已经存在一段时间了，但是这个问题在业界还没有非常普适的解决方案。例如，前面的讨论集中在类型安全性的缺乏是否是用户可定义 ClassLoader 的基本限制，以及我们是否必须限制 ClassLoader 的能力、放弃延迟类加载或在运行时引入额外的动态类型检查。我们在本文中提出的解决方案已经在 JDK 1.2 中实现，解决了类型安全问题，同时保留了 ClassLoader 的所有其他需要的特性。</p>\n<p>我们假设读者具有 Java 编程语言的基本知识。本文的其余部分组织如下：首先对 ClassLoader 进行更详细的介绍。第 3 节讨论 ClassLoader 的应用程序。第 4 节描述由于使用 ClassLoader 而可能出现的类型安全问题及其解决方案。最后给出结论。</p>\n<h2 id=\"2-关于-ClassLoader\"><a href=\"#2-关于-ClassLoader\" class=\"headerlink\" title=\"2 关于 ClassLoader\"></a>2 关于 ClassLoader</h2><p>ClassLoader 的主要作用就是支持在 java 平台上动态加载软件组件。软件分发的基本单元是 class（类）。 classes 以一种平台无关的、独立的、标准的二进制类文件格式形式分发。单个类的表示称为类文件。类文件由 Java 编译器生成，可以加载到任何 Java 虚拟机中。类文件不需要存储在实际文件中；它可以存储在内存缓冲区中，或者从网络流中获得。</p>\n<p>Java虚拟机执行存储在类文件中的字节代码。然而，字节码序列只是虚拟机执行程序所需要的一部分。类文件还包含对字段、方法和其他类名称的符号引用。例如，class C 的声明如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">f</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    \t<span class=\"type\">D</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">D</span>();</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 表示 C 的类文件包含对类 d 的符号引用。符号引用在链接时解析为实际的类类型。类类型是 Java 虚拟机中具体化的 first-class 对象。类类型在用户代码中表示为类 java.lang.Class 的对象。为了解析对类的符号引用，Java虚拟机必须加载类文件并创建类类型。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>first-class: 简而言之，这意味着对对象的使用没有任何限制。它和其它对象一样。first-class 对象是可以动态创建、销毁、传递给函数、作为值返回的实体，并且具有编程语言中其他变量具有的所有权限。<br><a href=\"https://stackoverflow.com/questions/245192/what-are-first-class-objects\">https://stackoverflow.com/questions/245192/what-are-first-class-objects</a></p></blockquote>\n<p>类类型在用户代码中表示为类java.lang.Class的对象。为了解析对类的符号引用，Java虚拟机必须加载类文件并创建类类型。</p>\n<h3 id=\"类加载概述\"><a href=\"#类加载概述\" class=\"headerlink\" title=\"类加载概述\"></a>类加载概述</h3><p>Java 虚拟机使用 classloaders 去加载类文件和创建 class 对象。classloader 也是普通的对象，可以使用 java 代码编写定义，但是它们必须是 ClassLoader 这个抽象类的子类，ClassLoader 代码如下所示（省略其他无关代码）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ClassLoader</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Class <span class=\"title function_\">loadClass</span><span class=\"params\">(String name)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> Class <span class=\"title function_\">defineClass</span><span class=\"params\">(String name, <span class=\"type\">byte</span>[] buf, <span class=\"type\">int</span> off, <span class=\"type\">int</span> len)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> Class <span class=\"title function_\">findLoadedClass</span><span class=\"params\">(String name)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> Class <span class=\"title function_\">findSystemClass</span><span class=\"params\">(String name)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上图的描述中， ClassLoader.loadClass 方法接受一个类名作为参数，并返回一个类对象，该类对象是类类型的运行时表示。关于 defineClass、findLoadedClass、findSystemClass 下面再聊。<br>在上面的案例中，假设类 C 是被 classloader L 加载的，那么 L 就是 C 的 defining loader，java 虚拟机将使用 L 去加载 C 引用的类。在虚拟机分配类 D 的对象之前，它必须解析对 D 的引用，如果还没有加载 D，虚拟机将调用 C 的类加载器 L 的 loadClass 方法来加载 D:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L.loadClass(<span class=\"string\">&quot;D&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>加载 D之后，虚拟机就可以解析了引用并创建类 D 的对象。</p>\n<h3 id=\"多-Class-Loaders\"><a href=\"#多-Class-Loaders\" class=\"headerlink\" title=\"多 Class Loaders\"></a>多 Class Loaders</h3><p>Java 应用程序可以使用几种不同类型的类装入器来管理各种软件组件。下图显示了用 Java 编写的 web 浏览器如何使用类加载器。<br><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c4b6451556e4e41902dd4bb73a0dfd2~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<p>这个示例演示了两种类型的 ClassLoader 的使用:用户定义的 ClassLoader 和 Java 虚拟机提供的系统 ClassLoader。用户定义的 ClassLoader 可用于创建来自用户定义的源的类。例如，浏览器应用程序为下载的 applet 创建类加载器。我们为 web 浏览器应用程序本身使用一个单独的类加载器，所有系统类(如java.lang.String)都被加载到系统类加载器中，Java 虚拟机直接支持系统类装入器。</p>\n<p>图中的箭头表示 ClassLoader 之间的委托关系；ClassLoader L<sub>1</sub> 可以委托另一个ClassLoader L<sub>2</sub> 代表自身去加载类 C，在这种情况下，L<sub>1</sub> 委托 C 给 L<sub>2</sub>。例如，applet 和 应用程序类 ClassLoader 将所有系统类委托给系统类 ClassLoader，因此，所有系统类在 applet 和应用程序之间共享。这是可以的，因为如果 applet 和系统代码对类型 java.lang.String 有不同的概念，就会违反类型安全性。委托 ClassLoader 加载允许我们在共享一组公共类的同时保持名称空间隔离，在 Java 虚拟机中，类类型唯一由类名和 ClassLoader 的组合决定，Applet 和应用程序 ClassLoader 委托给系统类装入器，这就保证了所有的系统类型（java.lang.String）的唯一性。另外，在 applet 1 中加载的名为 C 的类被认为是不同于 applet 2 中名为 C 的类的类型，尽管这两个类具有相同的名称，但它们是由不同的 ClassLoader 定义的。事实上，这两个类是完全不相关的。例如，它们可能有不同的方法或字段。</p>\n<p>一个 applet 中的类不能干扰另一个 applet 中的类，因为 applet 是有各自单独的 ClassLoader 中加载的，这对于保证 Java 平台安全性至关重要。同样，由于浏览器位于单独的 ClassLoader 中，因此 applet 不能访问用于实现浏览器的类，applet 只允许访问在系统类中公开的标准 Java API。</p>\n<p>Java 虚拟机通过创建应用程序 ClassLoader 并使用它加载初始的浏览器类来启动，应用程序在初始类的公共类方法 void main(String[]) 中开始执行，该方法的调用驱动所有的进一步执行，指令的执行可能导致附加类别的加载，在这个应用程序中，浏览器还为下载的 applet 创建额外的ClassLoader。</p>\n<p>垃圾收集器卸载不再引用的 applet 类，每个类对象都包含一个对其定义 ClassLoader 的引用；每个 ClassLoader 引用它定义的所有类，从垃圾收集器的角度来看，这意味着类与它们的定义 ClassLoader 是强连接的，当类的定义 ClassLoader 垃圾收集时，类将被卸载。</p>\n<h3 id=\"ClassLoader-的例子\"><a href=\"#ClassLoader-的例子\" class=\"headerlink\" title=\"ClassLoader 的例子\"></a>ClassLoader 的例子</h3><p>下面介绍一个简单的 ClassLoader 的实现。如前所述，所有用户定义的 ClassLoader 类都是 ClassLoader 的子类。ClassLoader 的子类可以覆盖loadClass 方法，从而提供用户定义的加载策略。这是一个在给定目录中查找类的自定义 ClassLoader ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>: guolei.sgl (guolei.sgl@antfin.com) 2020/12/4 7:42 下午</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FileClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClassLoader</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String directory;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">FileClassLoader</span><span class=\"params\">(String directory)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.directory = directory;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Class <span class=\"title function_\">loaderClass</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> ClassNotFoundException&#123;</span><br><span class=\"line\">        <span class=\"type\">Class</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> findLoadedClass(name);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            c = findSystemClass(name);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// keep looking</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"type\">byte</span>[] data = getClassData(directory,name);</span><br><span class=\"line\">           <span class=\"keyword\">return</span> defineClass(name,data,<span class=\"number\">0</span>,data.length);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// keep looking</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassNotFoundException</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">byte</span>[] getClassData(String directory, String name) <span class=\"keyword\">throws</span> IOException&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 省略</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>公共构造函数 FileClassLoader() 只记录目录名。在 loadClass 的 定义中，我们使用 findLoadedClass 方法检查类是否已经加载。如果findLoadedClass 返回 null，则表示该类尚未加载。然后，我们通过调用 findSystemClass 委托给系统类加载器，如果我们试图加载的类不是系统类，我们就调用 getClassData方法来读取类文件。</p>\n<p>在读入类文件之后，我们将其传递给 defineClass 方法，defineClass 方法从类文件 构造类的运行时表示（即 Class 对象）。请注意，loadClass 方法使用了 synchronized 关键字，这样也保证了多个线程加载同一个类时的线程安全性。</p>\n<h3 id=\"类的初始化和-Defining-Loaders\"><a href=\"#类的初始化和-Defining-Loaders\" class=\"headerlink\" title=\"类的初始化和 Defining Loaders\"></a>类的初始化和 Defining Loaders</h3><p>当一个 classloader 委托给另一个 classloader 时，发起 load 的 classloader 不一定是完成  class 加载并定义的 classloader，如下代码片段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">FileClassLoader</span> <span class=\"variable\">cl</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileClassLoader</span>(<span class=\"string\">&quot;/foo/bar&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">Class</span> <span class=\"variable\">stringClass</span> <span class=\"operator\">=</span> cl.loaderClass(<span class=\"string\">&quot;java.lang.String&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>FileClassLoader 类的实例将 java.lang.String 的加载委托给系统类加载器，因此，java.lang.String 是由系统类加载器加载和定义的，即使加载是由 FileClassLoader 发起的。</p>\n<p><strong>Definition 2.1：</strong> 假设 C 是 L.defineclass() 的结果，则 L defining loader C，或者等价地，L 定义 C。</p>\n<p><strong>Definition 2.2：</strong> 假设 C 是 L.loadClass() 的结果，则 L initiating loader  C，或者等价的，L 初始加载 C。</p>\n<p>在 Java 虚拟机中，每个类 C 都与它的 defining loader 永久关联，正是 C 的 defining loader 启动了 C 引用的任何类的加载。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>关于 defining loader 和 initiating loader ： 我们知道，在 java 中，类加载默认是双亲委派机制，那么基于此，来简单聊下 defining loader 和 initiating loader。</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>假设委托层次结构为 L-&gt; Lp -&gt; Lq，类在 Lp 中定义，在这种情况下：</p>\n<ul>\n<li>L 将类加载委托给 Lp</li>\n<li>Lp 将类加载委托给 Lq</li>\n<li>Lq 不会加载该类，调用将返回到 Lp</li>\n<li>Lp 将加载这个类，因为它是在 Lp 中定义的，并且调用返回到 L</li>\n</ul></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在这里，Lp 和 L 都是 initiating  class loaders(初始类加载器)，Lp 是 defining class loader</p>\n<p>类似地，如果委托等级是 L-&gt; Lp，并且类在 L 中定义</p>\n<ul>\n<li>L 成为定义和初始化类加载器。</li>\n<li>Lp 不是初始化类加载器。</li>\n</ul></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>简单地说，如果类加载器能够返回对委托链中的类实例的引用，那么它就是初始化类加载器。即初始类加载器可能会有多个，但是 defining class loader 有且只有一个。</p></blockquote>\n<h2 id=\"3-应用程序中的-Class-Loaders\"><a href=\"#3-应用程序中的-Class-Loaders\" class=\"headerlink\" title=\"3 应用程序中的 Class Loaders\"></a>3 应用程序中的 Class Loaders</h2><p>在本节中，我们将通过几个示例演示类装入器的强大功能。</p>\n<h3 id=\"重新加载类（Reloading-Classes）\"><a href=\"#重新加载类（Reloading-Classes）\" class=\"headerlink\" title=\"重新加载类（Reloading Classes）\"></a>重新加载类（Reloading Classes）</h3><p>通常需要在诸如服务器之类的长期运行的应用程序中升级软件组件，升级不得要求应用程序关闭并重新启动。<br>在 Java 平台上，此功能可以转换为重新加载已经在运行的虚拟机中加载的类的子集，它对应于模式演化问题，通常可能很难解决，一些困难如下：</p>\n<ul>\n<li>可能有一些活动对象是我们想要 reload 的类的实例，那么就需要迁移这些对象，以符合新类的模式。例如，如果类的新版本包含一组不同的实例字段，我们必须以某种方式将现有的一组实例字段值映射到新版本类中的字段。</li>\n<li>将静态字段值映射到 reload 的类版本中的一组不同的静态字段。</li>\n<li>应用程序可能正在执行一个方法，该方法可能是我们想要 reload 的类。</li>\n</ul>\n<p>在本文中，我们不讨论这些问题。但是我们将展示如何使用类加载器绕过它们，也就是通过在单独的类加载器中组织这些软件组件，开发者通常可以避免处理架构演变，那也就意味着，新类要由单独的加载器加载。</p>\n<p>图 3 说明了 Server 类如何动态地将服务请求重定向到 Server 的新版本。关键技术是将 Server 类、旧 Service  和新 Service 加载到单独的类加载器中。例如，我们可以使用上一节中介绍的 FileClassLoader 类来定义 Server。<br><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c18116090e044d5fb5a42cbae22d07d8~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Server</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object service;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">updateService</span><span class=\"params\">(String location)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">FileClassLoader</span> <span class=\"variable\">cl</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileClassLoader</span>(location);</span><br><span class=\"line\">            <span class=\"type\">Class</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> cl.loaderClass(<span class=\"string\">&quot;Service&quot;</span>);</span><br><span class=\"line\">            service = c.newInstance();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// ignore</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// ignore</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InstantiationException e)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// ignore</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">processRequest</span><span class=\"params\">(String args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Class</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> service.getClass();</span><br><span class=\"line\">            <span class=\"type\">Method</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> c.getMethod(<span class=\"string\">&quot;run&quot;</span>,String.class);</span><br><span class=\"line\">            m.invoke(service,args);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException e)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// ignore</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InvocationTargetException e)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// ignore</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// ignore</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Server.processRequest 方法将所有传入请求重定向到存储在私有字段中的 service 对象。它使用 Java 核心反射 API 调用 service 对象上的“run”方法。另外，Server.updateService 方法允许动态加载 Service 类的新版本以替换现有的 Service 对象。updateService 的调用者提供新类文件的位置。进一步的请求将被重定向到 Service 引用的新对象。为了重新加载，Server 直接引用 Service 类:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Server</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Service service;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">updateService</span><span class=\"params\">(String location)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">FileClassLoader</span> <span class=\"variable\">cl</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileClassLoader</span>(location);</span><br><span class=\"line\">            <span class=\"type\">Class</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> cl.loaderClass(<span class=\"string\">&quot;Service&quot;</span>);</span><br><span class=\"line\">            service = (Service) c.newInstance();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// ignore</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// ignore</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InstantiationException e)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// ignore</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ..</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一旦 Server 类将符号引用解析为 Service 类，它将包含到该类类型的强链接（hard linke），无法更改已解析的引用，这对于从类加载器返回的新版本的 Service，Server.updateService 方法最后一行中的类型转换将失败。</p>\n<p>反射允许 Server 类在没有直接引用的情况下使用 Service 类。或者，Server 和 Service 可以共享一个公共接口或超类:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Server</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ServiceInterface service;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">updateService</span><span class=\"params\">(String location)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">FileClassLoader</span> <span class=\"variable\">cl</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileClassLoader</span>(location);</span><br><span class=\"line\">            <span class=\"type\">Class</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> cl.loaderClass(<span class=\"string\">&quot;Service&quot;</span>);</span><br><span class=\"line\">            service = (ServiceInterface) c.newInstance();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InstantiationException e)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">processRequest</span><span class=\"params\">(String args)</span> &#123;</span><br><span class=\"line\">        service.run(args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Service</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ServiceInterface</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(String args)</span>&#123;</span><br><span class=\"line\">        System.out.println(args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过接口进行分派通常比反射更有效，不能重新加载接口类型本身，因为 Server 类只能引用一个 ServiceInterface 类型，getServiceClass 方法每次都必须返回一个实现相同 ServiceInterface 的类。</p>\n<p>在我们调用 updateService 方法之后，所有未来的请求将由新的 Server 处理。然而，旧的 Server 类可能还没有完成对一些早期请求的处理。因此，两个 Server 类可能会共存一段时间，直到完成对旧类的所有使用，删除对旧类的所有引用，卸载旧类为止。</p>\n<h3 id=\"检测-Classes-Files（Instrumenting-Classes-Files）\"><a href=\"#检测-Classes-Files（Instrumenting-Classes-Files）\" class=\"headerlink\" title=\"检测 Classes Files（Instrumenting Classes Files）\"></a>检测 Classes Files（Instrumenting Classes Files）</h3><p>类加载器可以在进行 defineClass 调用之前检测类文件。例如，在 FileClassLoader 的例子中，我们可以插入一个调用来检测类文件的内容:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">byte</span>[] data = getClassData(directory,name);</span><br><span class=\"line\">    <span class=\"comment\">// 检测 classFile</span></span><br><span class=\"line\">    <span class=\"type\">byte</span>[] newdata = instrumentClassFile(data);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defineClass(name,newdata,<span class=\"number\">0</span>,newdata.length);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// keep looking</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassNotFoundException</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>根据 Java 虚拟机规范，instrumented 类文件必须有效。虚拟机会将所有常规检查（例如运行字节码验证程序）应用于已检测的类文件，只要遵守类文件格式，程序员在修改类文件时就具有很大的自由度。例如，instrumented 类文件可能在现有方法，新字段或新方法中包含新的字节码指令，也可以删除现有方法，但是生成的类文件可能不会与其他类链接。</p>\n<p>instrumented 的类文件必须定义一个与原始类文件名称相同的类。 loadClass 方法应返回其名称与作为参数传入的名称相匹配的类对象。 </p>\n<p>类加载器只能检测其定义的类，而不能委派给其他加载器的类。所有用户定义的类加载器应首先委托给系统类加载器，因此不能通过类加载器来</p>\n<p>instrument 系统类。用户定义的类加载器无法通过尝试自己定义系统类来绕过此限制。例如，如果类加载器定义了自己的 String 类，则无法将该类的对象传递给需要标准 String 对象的 Java API。虚拟机将捕获并报告这些类型错误。</p>\n<p>在许多情况下，类文件检测都是有用的。例如，一个已检测的类文件可能包含性能分析钩子，这些性能钩子方法计算特定方法的执行次数。通过用对某些类的引用替换对那些类的有资源意识的版本的引用，可以监视和控制资源分配。可以使用类加载器来实现参数化的类，为参数类型的每个不同调用扩展和定制类文件中的代码。</p>\n<h2 id=\"4-维护类型安全链接\"><a href=\"#4-维护类型安全链接\" class=\"headerlink\" title=\"4 维护类型安全链接\"></a>4 维护类型安全链接</h2><p>到目前为止提供的示例已经证明了多个委托类加载器的用处。但是，正如我们将看到的，要确保在存在类加载器的情况下进行类型安全的链接需要特别注意。 Java编程语言依赖于基于名称的静态类型。在编译时，每种静态类类型都对应一个类名称。在运行时，类加载器会引入多个名称空间。运行时类类型不仅由其名称单独确定，还由一对：其类名称及其定义的类加载器确定。因此，用户定义的类加载器引入的名称空间可能与Java编译器管理的名称空间不一致，从而危害类型安全。</p>\n<h3 id=\"时间命名空间一致性（Temporal-Namespace-Consistency）\"><a href=\"#时间命名空间一致性（Temporal-Namespace-Consistency）\" class=\"headerlink\" title=\"时间命名空间一致性（Temporal Namespace Consistency）\"></a>时间命名空间一致性（Temporal Namespace Consistency）</h3><p>oadClass 方法可能会在不同时间为给定名称返回不同的类类型。为了维护类型安全，虚拟机必须能够始终为给定的类名和加载器获得相同的类类型。例如，考虑以下代码中对类X的两个引用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">f</span><span class=\"params\">(X x)</span>&#123;...&#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">g</span><span class=\"params\">()</span>&#123;f(<span class=\"keyword\">new</span> <span class=\"title class_\">x</span>());&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果 C 的类加载器将 X 的两次出现映射到不同的类类型，则 g 内部对 f 的方法调用的类型安全性将受到损害。虚拟机不能相信任何用户定义的loadClass 方法会对给定的名称一致地返回相同的类型，所以它在内部维护一个已加载的类缓存。被加载的类缓存将类名和初始加载器映射到类类型。当虚拟机从 loadClass 方法获得一个类后，它执行以下操作:</p>\n<ul>\n<li>将根据传递给 loadClass 方法的名称检查类的真实名称。如果 loadClass 返回的类没有所请求的名称，则会引发错误。</li>\n<li>如果名称匹配，则将生成的类缓存在已加载的类缓存中。虚拟机永远不会在同一类加载器上多次调用具有相同名称的 loadClass 方法</li>\n</ul>\n<h3 id=\"委托类加载命名空间一致性（Namespace-Consistency-among-Delegating-Loaders）\"><a href=\"#委托类加载命名空间一致性（Namespace-Consistency-among-Delegating-Loaders）\" class=\"headerlink\" title=\"委托类加载命名空间一致性（Namespace Consistency among Delegating Loaders）\"></a>委托类加载命名空间一致性（Namespace Consistency among Delegating Loaders）</h3><p>我们现在描述委派类装入器可能产生的类型安全问题</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>Notation 4.1：下面会会用 &lt;C, L<sup>d</sup>&gt; L<sup>i</sup> 这样一个符号来代表一个类类型，其中 C 表示类名，L<sup>d</sup>  表示类的 defining loader，L<sup>i</sup>  表示 loading loader。如果我们不关心 defining loader 时，我们使用 C L<sup>i</sup>  这个符号去表示 L<sup>i</sup>  是 C 的初始化加载器。当我们不关心初始化加载器时，我们使用指定的 &lt;C, L<sup>d</sup>&gt; 去表示 C 是被 L<sup>d</sup>定义的。</strong></p></blockquote>\n<p>如果 L<sup>1</sup> 委托 L<sup>2</sup> 去加载 C，则 C:L<sup>1</sup> &#x3D; C:L<sup>2</sup><br>现在我们将给出一个演示类型安全问题的示例。为了明确涉及到哪些类装入器，我们在通常出现类名的地方使用了上述表示法。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef181d2377e44ec7b5cc4ed088711981~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<p>C 由 L<sub>1</sub> 定义。结果，L<sub>1</sub> 用于启动 C.f 内部引用的 Spoofed 和 Delegated 类的加载。 L 定义 Spoofed。但是，L<sub>1</sub> 将 Delegated 的加载委托给 L<sub>2</sub>，然后由 L<sub>2</sub> 定义 Delegated。由于 Delegated 由 L<sub>2</sub> 定义，因此 Delegated.g 将使用 L 来启动 Spoofed 的加载。碰巧的是，L<sub>2</sub>定义了另一种 Spoofed 类型。C 期望 &lt;Spoofed，L<sub>1</sub>&gt;的实例由 Delegated.g 返回。但是，Delegated.g 实际上返回&lt;Spoofed，L<sub>2</sub>&gt; 的实例，这是一个完全不同的类。</p>\n<p>这是 L<sub>1</sub> 和 L<sub>2</sub> 的命名空间之间的不一致。如果未发现这种不一致，则可以使用委派的类加载器将一种类型伪造为另一种类型。若要了解这种类型的安全问题如何导致不良行为，请假设以下两个版本的“Spoofed”定义如下：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0caf8b03acfb417abcbf2b2451f5d7c4~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<p>现在，类&lt;C，L<sub>1</sub>&gt;可以显示&lt;Spoofed，L<sub>2</sub>&gt;实例的私有字段，并从整数值伪造一个指针：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47a59e4a90fd4dd5a4c6cb952ed14652~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<p>我们可以在&lt;Spoofed，L<sub>2</sub>&gt;实例中访问私有字段秘密值，因为该字段在&lt;Spoofed，L<sub>1</sub>&gt;中声明为公共字段。我们还能够在&lt;Spoofed，L<sub>1</sub>&gt;实例中将整数字段伪造为整数数组，并取消引用从该整数伪造的指针。<br>类型安全问题的根本原因是虚拟机没有考虑到类类型是由类名和定义加载器确定的。相反，虚拟机依赖于Java编程语言的概念，即在类型检查期间只使用类名作为类型。这个问题已经得到纠正，如下所述。</p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>类型安全问题的一个直接解决方案是在Java虚拟机中统一使用类名及其定义加载器来表示类类型。但是，确定定义加载器的唯一方法是通过初始加载器实际加载类。在前一节的例子中，在确定 C.f 对 Delegated.g 的调用是否是类型安全的之前，我们必须首先在 L<sub>1</sub>和L<sub>2</sub>中都加载 Spoofed，然后查看是否获得相同的定义加载程序。这种方法的缺点是它牺牲了类的延迟加载性质。</p>\n<p>我们的解决方案保留了简单方法的类型安全性，但避免了急切的类加载。关键思想是维护一组加载器约束，在类加载发生时动态更新这些约束。在上面的例子中，我们没有在 L <sub>1</sub>和 L<sub>2</sub> 中加载 Spoofed，而是简单地记录了一个约束:Spoofed:L<sub>1</sub>&#x3D;Spoofed:L<sub>2</sub>。如果 Spoofed 稍后被 L<sub>1</sub>或 L <sub>2</sub>加载，我们将需要验证现有的加载器约束集不会被违反。如果约束  Spoofed:L<sub>1</sub>&#x3D;Spoofed:L<sub>2</sub>是在 L<sub>1</sub> 和 L<sub>2</sub>加载 Spoofed 之后引入的，会怎么样?现在施加约束并撤消以前的类加载已经太晚了。</p>\n<p>因此，我们必须同时考虑加载的类缓存和加载器约束设置。我们需要保持不变：加载的类缓存中的每个条目都满足加载器的所有约束。保持不变式如下:</p>\n<ul>\n<li>每次将一个新条目添加到已加载的类缓存中时，我们都要验证没有违反任何现有的加载器约束。如果不能在不违反现有加载器约束的情况下将新条目添加到加载的类缓存中，则类加载失败。</li>\n<li>每次添加新的加载器约束时，我们都要验证缓存中加载的所有类是否满足新的约束。如果一个新的加载器约束不能被所有加载的类满足，那么触发添加新的加载器约束的操作将失败。</li>\n</ul>\n<p>让我们看看如何将这些检查应用到前面的示例中。C.f 方法的第一行使虚拟机生成约束 Spoofed:L<sub>1</sub>&#x3D;Spoofed:L<sub>2</sub>。如果 L<sub>1</sub>和 L<sub>2</sub> 在我们生成这个约束时已经加载了 Spoofed 类，那么一个异常将立即在程序中引发。否则，约束将被成功记录。假设 Delegated.g 首先加载 Spoofed:L<sub>2</sub>，当稍后C.f 尝试加载 Spoofed:L<sub>1</sub> 时，将引发一个异常。</p>\n<h4 id=\"约束规则\"><a href=\"#约束规则\" class=\"headerlink\" title=\"约束规则\"></a>约束规则</h4><p>现在我们声明生成约束的规则。这些对应于一个类类型可能被另一个类引用的情况。当在不同的加载器中定义两个这样的类时，名称空间之间可能存在不一致。</p>\n<ul>\n<li>如果 &lt;C, L<sub>1</sub>&gt; 引用了一个字段 ： T filedname, 这个字段是在 &lt;D,L<sub>2</sub>&gt;  中被申明，那我们就产生了这样一个约束：T:L<sub>1</sub> &#x3D; T:L<sub>2</sub></li>\n<li>如果 &lt;C, L<sub>1</sub>&gt; 引用了一个方法 ：T0 methodname(T1 ,….., Tn)； 这个方法在  &lt;D,L<sub>2</sub>&gt;  中被申明，那我们就产生了一个约束：T0:L<sub>1</sub> &#x3D; T0:L<sub>2</sub>,…, Tn:L<sub>1</sub> &#x3D; Tn:L<sub>2</sub>。</li>\n<li>如果 &lt;C, L<sub>1</sub>&gt; 重写了一个方法：T0 methodname(T1 ,….., Tn)；这个方法在  &lt;D,L<sub>2</sub>&gt;  中被申明，那我们就产生了一个约束：T0:L<sub>1</sub> &#x3D; T0:L<sub>2</sub>,…, Tn:L<sub>1</sub> &#x3D; Tn:L<sub>2</sub>。</li>\n</ul>\n<p>约束集{T:L<sub>1</sub>&#x3D; T:L<sub>2</sub>, T:L<sub>2</sub> &#x3D; T:L<sub>3</sub>}表示在 L<sub>1</sub>和 L<sub>2</sub>、L <sub>2</sub>和 L<sub>3</sub> 中，T 必须以相同的类类型加载。即使在程序执行过程中，T 从未被 L<sub>2</sub> 加载，L <sub>1</sub>和 L<sub>2</sub> 也无法加载不同版本的 T。如果违反了加载程序约束，则将抛出 java.lang.LinkageError 异常。当相应的类加载器被垃圾回收时，加载器约束将从约束集中删除。</p>\n<h4 id=\"替代解决方案\"><a href=\"#替代解决方案\" class=\"headerlink\" title=\"替代解决方案\"></a>替代解决方案</h4><p>另外一种与前不同的替代方案是，建议方法重写也应该基于动态类型，而不是基于静态(基于名称)类型。这种方案是从链接时间开始统一地使用类型的动态概念。下面的代码说明了该模型和前面提到的模型之间的差异:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class&lt;Super,L1&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">f</span><span class=\"params\">(Spoofed x)</span>&#123;... code1....&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/276c04b81a464c7da46131ebd4d270aa~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<p>假设 L<sub>1</sub> 和 L<sub>2</sub> 定义了不同版本的 Spoofed。Saraswat 认为 Super 和 Sub 中的 f 方法具有不同的类型签名 :Super.f 方法参数类型是&lt;Spoofed,L<sub>1</sub>&gt;, 而 Sub.f 方法参数类型是 &lt;Spoofed,L<sub>2</sub>&gt;。这样的话，Sub.f 在这个模型下就没有办法去 override Super.f 方法。</p>\n<p>在我们前面设定的模型中，如果 Main 是被 L<sub>2</sub> 加载的，当 f 被调用时，就会产生 linkageError 异常。这个行为和替代模型是非常相似的：在替代模型中会产生 NoSuchMethodError。</p>\n<p>在我们的模型中，当 Main 由 L<sub>1</sub>加载时，方法上的差异变得明显，当 Main 由 L <sub>1</sub>加载时，对f的调用将调用 code2。当代码 2 尝试访问 Spoofed 的任何字段或方法时，将引发 linkageError。<br>我们认为，在这种情况下失败比静默运行本不应该执行的代码更好。程序员在编写上面的 Super 和 Sub 类时，期望 Sub.f 确实根据 Java 编程语言的语义覆盖了 Super.f。这些期望在替代模型的提议中被违反了。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>我们已经提出了Java平台中的类加载器的概念。类加载器结合了四个理想的功能：延迟加载，类型安全的链接，多个名称空间和用户可扩展性。特别是类型安全，需要特别注意。我们已经展示了如何在不限制类加载器功能的情况下保持类型安全。类加载器是一种简单而强大的机制，已被证明在管理软件组件方面非常有价值。</p>\n","text":" 原文连接：https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.18.762&rep=rep1&...","permalink":"/post/jvm/jvm-dynamic-load-class","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"jvm","slug":"jvm","count":6,"path":"api/categories/jvm.json"}],"tags":[{"name":"classloader","slug":"classloader","count":2,"path":"api/tags/classloader.json"},{"name":"jvm","slug":"jvm","count":6,"path":"api/tags/jvm.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0-%E6%91%98%E8%A6%81\"><span class=\"toc-text\">0 摘要</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">1 介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%85%B3%E4%BA%8E-ClassLoader\"><span class=\"toc-text\">2 关于 ClassLoader</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">类加载概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A-Class-Loaders\"><span class=\"toc-text\">多 Class Loaders</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ClassLoader-%E7%9A%84%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">ClassLoader 的例子</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C-Defining-Loaders\"><span class=\"toc-text\">类的初始化和 Defining Loaders</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84-Class-Loaders\"><span class=\"toc-text\">3 应用程序中的 Class Loaders</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD%E7%B1%BB%EF%BC%88Reloading-Classes%EF%BC%89\"><span class=\"toc-text\">重新加载类（Reloading Classes）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A3%80%E6%B5%8B-Classes-Files%EF%BC%88Instrumenting-Classes-Files%EF%BC%89\"><span class=\"toc-text\">检测 Classes Files（Instrumenting Classes Files）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E7%BB%B4%E6%8A%A4%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">4 维护类型安全链接</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%B6%E9%97%B4%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88Temporal-Namespace-Consistency%EF%BC%89\"><span class=\"toc-text\">时间命名空间一致性（Temporal Namespace Consistency）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A7%94%E6%89%98%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88Namespace-Consistency-among-Delegating-Loaders%EF%BC%89\"><span class=\"toc-text\">委托类加载命名空间一致性（Namespace Consistency among Delegating Loaders）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">解决方案</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BA%A6%E6%9D%9F%E8%A7%84%E5%88%99\"><span class=\"toc-text\">约束规则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9B%BF%E4%BB%A3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">替代解决方案</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E8%AE%BA\"><span class=\"toc-text\">结论</span></a></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"Linux 中的 namespace","uid":"7831cd475225b7056a3087c302042c96","slug":"linux/linux-concept-namespace","date":"2020-12-12T15:30:20.000Z","updated":"2024-07-05T04:09:05.774Z","comments":true,"path":"api/articles/linux/linux-concept-namespace.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":null,"text":"基本介绍namespace 是 Linux 内核用来隔离内核资源的方式。通过 namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也...","permalink":"/post/linux/linux-concept-namespace","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"Linux","slug":"Linux","count":9,"path":"api/categories/Linux.json"}],"tags":[{"name":"linux","slug":"linux","count":9,"path":"api/tags/linux.json"},{"name":"namespace","slug":"namespace","count":1,"path":"api/tags/namespace.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"maven 中 repository 是如何工作的","uid":"576894077f580ac3b5f04a4d2847ddda","slug":"maven/maven-repository","date":"2020-12-06T15:25:12.000Z","updated":"2024-07-05T04:09:05.783Z","comments":true,"path":"api/articles/maven/maven-repository.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":null,"text":"本文中，我们将来看下如何在 maven 项目中定义和解决依赖关系，然后深入研究 maven 存储库如何使这些依赖关系可供使用的。 什么是 maven 依赖项？关...","permalink":"/post/maven/maven-repository","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"maven","slug":"maven","count":4,"path":"api/categories/maven.json"}],"tags":[{"name":"maven","slug":"maven","count":4,"path":"api/tags/maven.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}