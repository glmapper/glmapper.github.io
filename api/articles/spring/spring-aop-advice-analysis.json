{"title":"聊一聊 AOP：Advice 源码解析","uid":"633ee0890ad90f5dbecf1b679aef9739","slug":"spring/spring-aop-advice-analysis","date":"2018-06-23T10:41:25.000Z","updated":"2024-07-05T04:09:05.815Z","comments":true,"path":"api/articles/spring/spring-aop-advice-analysis.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>原文：<a href=\"https://juejin.cn/post/6844903624250769421\">https://juejin.cn/post/6844903624250769421</a></p></blockquote>\n<p>在第一篇中的例子和概念介绍中我们对 Advice 有了一个初步的认知。在 Spring AOP 中，Advice 的作用就是用来描述 Spring AOP 围绕方法调用而注入的切面行为。本篇文章将从源码的角度来看一看 <code>Advice</code> 到底是什么样的？又是怎么完成通知的？</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Advice-接口\"><a href=\"#Advice-接口\" class=\"headerlink\" title=\"Advice 接口\"></a>Advice 接口</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.aopalliance.aop;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Tag interface for Advice. Implementations can be any type</span></span><br><span class=\"line\"><span class=\"comment\"> * of advice, such as Interceptors.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Rod Johnson</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@version</span> $Id: Advice.java,v 1.1 2004/03/19 17:02:16 johnsonr Exp $</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Advice</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Advice</code> 接口的定义是在 <code>org.aopalliance.aop</code> 包下面的；从上面的代码中我们可以知道，<code>Advice</code> 接口并没有提供任何的方法；类似的接口定义还有<code>java</code> 中的如<code>Serializable</code>接口，这类接口一般称之为标识接口；标识接口对实现它的类没有任何的语义要求,仅仅是充当一个标示的作用,用来表明实现它的类属于一个特定的类型（从这种标识性角度来说，和注解其实挺像的）；</p>\n<p><code>Spring AOP</code>中通过定义和使用这样一个统一的接口，为的就是能够为切面增强的织入功能做更多的细化和扩展。下面就对常见的三个<code>Advice</code>进行分析。</p>\n<h2 id=\"BeforeAdvice\"><a href=\"#BeforeAdvice\" class=\"headerlink\" title=\"BeforeAdvice\"></a>BeforeAdvice</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">BeforeAdvice</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Advice</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个接口也是一个标识接口。看下 <code>BeforeAdvice</code> 的继承关系：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/22/1642834fc63bae1d~tplv-t2oaga2asx-image.image\"></p>\n<p><code>MethodBeforeAdvice</code> 是 <code>BeforeAdvice</code> 为待增强的目标方法设置的前置增强接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MethodBeforeAdvice</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BeforeAdvice</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">(Method method, Object[] args, Object target)</span> <span class=\"keyword\">throws</span></span><br><span class=\"line\">    Throwable;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>MethodBeforeAdvice</code> 中提供了一个回调函数 <code>before(...)</code> ；</p>\n<p>作为回调函数，<code>before</code> 方法的实现在 <code>Advice</code> 中被配置到目标方法后，会在调用目标方法时被回调。来看下<code>before</code>方法的几个参数：</p>\n<ul>\n<li>Method method ：（ method being invoked）这个参数是目标方法的反射对象；</li>\n<li>Object[] args ：（arguments to the method）目标方法的输入参数；</li>\n<li>Object target ：（target of the method invocation）方法调用的目标</li>\n</ul>\n<h2 id=\"AspectJMethodBeforeAdvice\"><a href=\"#AspectJMethodBeforeAdvice\" class=\"headerlink\" title=\"AspectJMethodBeforeAdvice\"></a>AspectJMethodBeforeAdvice</h2><p><code>AspectJMethodBeforeAdvice</code> 继承了 <code>AbstractAspectJAdvice</code> 抽象类，并实现了 <code>MethodBeforeAdvice</code> 接口。从 <code>AspectJMethodBeforeAdvice</code> 类中代码可以得知，<code>AspectJMethodBeforeAdvice</code> 重写 <code>before</code> 方法的实现是 通过调用父类的 <code>invokeAdviceMethod</code> 方法完成的。也就是说<code>Spring AOP</code> 的<code>Advice</code>包装了<code>AspectJ</code>的<code>before</code>方法。</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/23/1642a5ea16c25b2d~tplv-t2oaga2asx-image.image\"></p>\n<p>Spring AOP的实现后面再说，我们先自己来实现一个简单的通知。</p>\n<h2 id=\"自定义-Advice实现-MethodBeforeAdvice\"><a href=\"#自定义-Advice实现-MethodBeforeAdvice\" class=\"headerlink\" title=\"自定义 Advice实现 MethodBeforeAdvice\"></a>自定义 Advice实现 MethodBeforeAdvice</h2><p>定义我们自己的 <code>GlmapperBeforeMethodAdvice</code> ；这里实现 <code>MethodBeforeAdvice</code> 接口，然后重写 <code>before</code> 这个方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>: 自定义的 GlmapperBeforeMethodAdvice</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@email</span>: &lt;a href=&quot;glmapper_2018@163.com&quot;&gt;&lt;/a&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>: glmapper@leishu</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span>: 18/6/23</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GlmapperBeforeMethodAdvice</span> <span class=\"keyword\">implements</span></span><br><span class=\"line\"><span class=\"title class_\">MethodBeforeAdvice</span>,MethodInterceptor &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">LOGGER</span> <span class=\"operator\">=</span></span><br><span class=\"line\">    LoggerFactory.getLogger(GlmapperBeforeMethodAdvice.class.getSimpleName());</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">(Method method, Object[] args, Object target)</span> </span><br><span class=\"line\">    <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        LOGGER.info(<span class=\"string\">&quot;invoke BeforeAdvice successfully...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(MethodInvocation invocation)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        Object result=invocation.proceed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>OK，有了这个 <code>GlmapperBeforeMethodAdvice</code> ，再来看看怎么用它；同样本篇文章所使用的案例均使用前一篇博客中的那个脚手架来完成。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--我们的目标类--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;goodsService&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.glmapper.framerwork.service.impl.GoodsServiceImpl&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--我们自定义的Advice--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;glmapperBeforeMethodAdvice&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.glmapper.framerwork.Advice.GlmapperBeforeMethodAdvice&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 声明切入点adviser --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;adviser&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.aop.support.RegexpMethodPointcutAdvisor&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--这里使用我们自定义的advice--&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;advice&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;glmapperBeforeMethodAdvice&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- pattern指定queryAll方法作为切入点； \\. 这个是转义使用--&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;pattern&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">\t    <span class=\"attr\">value</span>=<span class=\"string\">&quot;com\\.glmapper\\.framerwork\\.service\\.impl\\.GoodsServiceImpl\\.queryAll&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 定义代理对象 返回实例是目标对象 target属性指定的goodsService对象--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;proxyService&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;target&quot;</span>&gt;</span></span><br><span class=\"line\">\t    <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">&quot;goodsService&quot;</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--源码内固定的属性private String[] interceptorNames;  --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;interceptorNames&quot;</span>&gt;</span></span><br><span class=\"line\">\t    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>adviser<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>客户端部分，通过SpringContextUtil来拿代理对象；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/initPage&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title function_\">initPage</span><span class=\"params\">(HttpServletRequest request,</span></span><br><span class=\"line\"><span class=\"params\">\t\tHttpServletResponse response, ModelAndView view)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取代理bean</span></span><br><span class=\"line\">    GoodsService proxyService= (GoodsService) SpringContextUtil.getBean(<span class=\"string\">&quot;proxyService&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//调用</span></span><br><span class=\"line\">    List&lt;Goods&gt; goods = proxyService.queryAll(<span class=\"number\">10</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">    view.addObject(<span class=\"string\">&quot;goodsList&quot;</span>, goods);</span><br><span class=\"line\">    view.setViewName(<span class=\"string\">&quot;goodslist&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> view;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>日志输出满足我们的期望（如下）：<br><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/23/1642abd5c1097135~tplv-t2oaga2asx-image.image\"></p>\n<p>同样的，在<code>GlmapperBeforeMethodAdvice</code>基础上再实现 <code>AfterReturningAdvice </code>接口，重写<code>afterReturning</code>方法，就能实现后置通知。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">afterReturning</span><span class=\"params\">(Object returnValue, Method method, Object[]</span></span><br><span class=\"line\"><span class=\"params\">args, Object target)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">    LOGGER.info(<span class=\"string\">&quot;invoke AfterAdvice successfully...&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方式在<a href=\"https://juejin.im/post/6844903623101513735\">聊一聊 AOP ：表现形式与基础概念</a>中有说道。</p>\n<h2 id=\"Advice-在-Aop-中的实现原理\"><a href=\"#Advice-在-Aop-中的实现原理\" class=\"headerlink\" title=\"Advice 在 Aop 中的实现原理\"></a>Advice 在 Aop 中的实现原理</h2><p>这里感觉没什么好说的，上面的案例其实就是Spring提供给我们使用的接口。因为MethodBeforeAdvice等都是继承自 AbstractAspectJAdvice 这个抽象类；我们就来看下这个抽象类里面的一些核心逻辑吧。我们按照AspectJMethodBeforeAdvice这里这个类里面before提供的线索来一步步分析。</p>\n<p>首先在AspectJMethodBeforeAdvice里before方法中调用的是这个逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Invoke the advice method.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> jpMatch the JoinPointMatch that matched this execution join point</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> returnValue the return value from the method execution (may be null)</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> ex the exception thrown by the method execution (may be null)</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the invocation result</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> Throwable in case of invocation failure</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> Object <span class=\"title function_\">invokeAdviceMethod</span><span class=\"params\">(JoinPointMatch jpMatch, Object</span></span><br><span class=\"line\"><span class=\"params\">returnValue, Throwable ex)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> invokeAdviceMethodWithGivenArgs(argBinding(getJoinPoint(),</span><br><span class=\"line\">\tjpMatch, returnValue, ex));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里 argBinding 方法的作用是获取方法执行连接点上的参数，并将一组参数输出给Advice方法。</p>\n<p>继续来看invokeAdviceMethodWithGivenArgs这个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Object <span class=\"title function_\">invokeAdviceMethodWithGivenArgs</span><span class=\"params\">(Object[] args)</span> <span class=\"keyword\">throws</span></span><br><span class=\"line\">Throwable &#123;</span><br><span class=\"line\">    <span class=\"comment\">//保存一份参数副本</span></span><br><span class=\"line\">    Object[] actualArgs = args;</span><br><span class=\"line\">    <span class=\"comment\">//验证下参数是否不存在</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.aspectJAdviceMethod.getParameterTypes().length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    \tactualArgs = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//设置下方法的访问权限</span></span><br><span class=\"line\">    \tReflectionUtils.makeAccessible(<span class=\"built_in\">this</span>.aspectJAdviceMethod);</span><br><span class=\"line\">    \t<span class=\"comment\">// invoke执行；这里先通过aspectInstanceFactory对像拿到我们的目标对象实例，然后再进行invoke调用执行</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.aspectJAdviceMethod.invoke(<span class=\"built_in\">this</span>.aspectInstanceFactory.getAspectInstance(), actualArgs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AopInvocationException</span>(<span class=\"string\">&quot;Mismatch on arguments to advice method [&quot;</span> +</span><br><span class=\"line\">    \t\t\t<span class=\"built_in\">this</span>.aspectJAdviceMethod + <span class=\"string\">&quot;]; pointcut expression [&quot;</span> +</span><br><span class=\"line\">    \t\t\t<span class=\"built_in\">this</span>.pointcut.getPointcutExpression() + <span class=\"string\">&quot;]&quot;</span>, ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (InvocationTargetException ex) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">throw</span> ex.getTargetException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这段代码其实就是通过反射的方式执行了我们的目标方法。我们再回过头来看下我们的目标方法到底在哪里去进行增强的；这里我们通过配置文件来看：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 代理对象 返回实例是目标对象 target属性指定的AOPservice对象--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;proxyService&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;target&quot;</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">&quot;goodsService&quot;</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--源码内固定的属性private String[] interceptorNames;  --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;interceptorNames&quot;</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>adviser<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>代理对象proxyService实现上是ProxyFactoryBean产生的；这里就不在阐述BeanFactory和FactoryBean的区别了。</p>\n<p>从上面的配置文件我们可以简单的了解到，代理对象实际上是我们目标对象+adviser共同组成；而在adviser里面又包括了我们的通知。</p>\n<p>ProxyFactoryBean继承了FactoryBean，我们知道FactoryBean也是用来生成bean的，但是它生成的bean是通过其getObject方法来获取的。OK，那我们来看下ProxyFactoryBean的getObject方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Return a proxy. Invoked when clients obtain beans from this factory bean.</span></span><br><span class=\"line\"><span class=\"comment\"> * Create an instance of the AOP proxy to be returned by this factory.</span></span><br><span class=\"line\"><span class=\"comment\"> * The instance will be cached for a singleton, and create on each call to</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> getObject()&#125; for a proxy.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> a fresh AOP proxy reflecting the current state of this factory</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">getObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> BeansException &#123;</span><br><span class=\"line\">    <span class=\"comment\">//初始化Advisor链</span></span><br><span class=\"line\">    initializeAdvisorChain();</span><br><span class=\"line\">    <span class=\"comment\">//如果是单例，则获取单例对象</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isSingleton()) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> getSingletonInstance();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.targetName == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    \t\tlogger.warn(<span class=\"string\">&quot;Using non-singleton proxies with singleton targets is often undesirable. &quot;</span> +</span><br><span class=\"line\">    \t\t\t\t<span class=\"string\">&quot;Enable prototype proxies by setting the &#x27;targetName&#x27; property.&quot;</span>);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> newPrototypeInstance();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>返回一个代理。当客户端从这个工厂bean获取bean时调用。创建该工厂返回的AOP代理的一个实例。该实例将被缓存为一个单例，并在每次调用时创建。</p></blockquote>\n<p>initializeAdvisorChain：创建 advisor（拦截器）链。每次添加新的 prototype 实例时，源自 BeanFactory 的 Advisor 都将被刷新。通过工厂 API 以编程方式添加的拦截器不受此类更改的影响。（译注）；其实就是根据我们配置的interceptorNames来初始化我们的advisor（拦截器）链，用来增强我们的目标调用方法。</p>\n<p>下面是getSingletonInstance这个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Return the singleton instance of this class&#x27;s proxy object,</span></span><br><span class=\"line\"><span class=\"comment\"> * lazily creating it if it hasn&#x27;t been created already.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the shared singleton proxy</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">synchronized</span> Object <span class=\"title function_\">getSingletonInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.singletonInstance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建目标对象的代理</span></span><br><span class=\"line\">    \t<span class=\"built_in\">this</span>.targetSource = freshTargetSource();</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.autodetectInterfaces &amp;&amp; getProxiedInterfaces().length == <span class=\"number\">0</span> &amp;&amp; !isProxyTargetClass()) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// Rely on AOP infrastructure to tell us what interfaces to proxy.</span></span><br><span class=\"line\">        \t<span class=\"comment\">//获取目标类</span></span><br><span class=\"line\">        \tClass&lt;?&gt; targetClass = getTargetClass();</span><br><span class=\"line\">        \t<span class=\"keyword\">if</span> (targetClass == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        \t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FactoryBeanNotInitializedException</span>(<span class=\"string\">&quot;Cannot determine target class for proxy&quot;</span>);</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        \tsetInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, <span class=\"built_in\">this</span>.proxyClassLoader));</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"comment\">// Initialize the shared singleton instance.</span></span><br><span class=\"line\">    \t<span class=\"built_in\">super</span>.setFrozen(<span class=\"built_in\">this</span>.freezeProxy);</span><br><span class=\"line\">    \t<span class=\"built_in\">this</span>.singletonInstance = getProxy(createAopProxy());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.singletonInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码最核心的是getProxy这个方法，这里方式有两个方式，一个是cglib，另外一种是jdk动态代理：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/23/1642c20eec4d6c09~tplv-t2oaga2asx-image.image\"></p>\n<p>这里我们以默认的动态代理的方式来说：(<code>org.springframework.aop.framework.JdkDynamicAopProxy类中</code>)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">getProxy</span><span class=\"params\">(ClassLoader classLoader)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">    \tlogger.debug(<span class=\"string\">&quot;Creating JDK dynamic proxy: target source is &quot;</span> +</span><br><span class=\"line\">    \t<span class=\"built_in\">this</span>.advised.getTargetSource());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Class&lt;?&gt;[] proxiedInterfaces =</span><br><span class=\"line\">    AopProxyUtils.completeProxiedInterfaces(<span class=\"built_in\">this</span>.advised);</span><br><span class=\"line\">    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法返回的就是指定接口的代理类实例，该接口将方法调用分派给指定的调用处理程序。到此整个AOP代理生成逻辑就完了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>代理类中其实包括了 AOP 增强的那部分逻辑的，这个其实从上面的配置文件中就很清楚的可以看出来；所以从 Adivce 这个角度来说，它其实会被包在 advisor 中，然后在被传递到代理对象中，代理对象除了拥有我们目标对象的能力之外，还包括了 Adivce 的能力；通过这种方式就实现了增强。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>关于 Advice 就到这里了，下一章会来单独说一下 PointCut 。</p></blockquote>\n","text":" 原文：https://juejin.cn/post/6844903624250769421 在第一篇中的例子和概念介绍中我们对 Advice 有了一个初步的认...","permalink":"/post/spring/spring-aop-advice-analysis","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"spring","slug":"spring","count":15,"path":"api/categories/spring.json"}],"tags":[{"name":"spring","slug":"spring","count":11,"path":"api/tags/spring.json"},{"name":"aop","slug":"aop","count":3,"path":"api/tags/aop.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Advice-%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">Advice 接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#BeforeAdvice\"><span class=\"toc-text\">BeforeAdvice</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#AspectJMethodBeforeAdvice\"><span class=\"toc-text\">AspectJMethodBeforeAdvice</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89-Advice%E5%AE%9E%E7%8E%B0-MethodBeforeAdvice\"><span class=\"toc-text\">自定义 Advice实现 MethodBeforeAdvice</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Advice-%E5%9C%A8-Aop-%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Advice 在 Aop 中的实现原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"Google Guava 在实际场景中的应用封装","uid":"007bfdf0af7a404de7413e60d2f769a0","slug":"middleware/middleware-cache-guava-practice","date":"2018-06-24T16:30:32.000Z","updated":"2024-07-05T04:09:05.788Z","comments":true,"path":"api/articles/middleware/middleware-cache-guava-practice.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"text":" 原文：https://juejin.cn/post/6844903624519188487 毕竟西湖六月中，风光不与四时同。 接天莲叶无穷碧，映日荷花别样红。...","permalink":"/post/middleware/middleware-cache-guava-practice","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"Middleware","slug":"Middleware","count":14,"path":"api/categories/Middleware.json"}],"tags":[{"name":"cache","slug":"cache","count":2,"path":"api/tags/cache.json"},{"name":"guava","slug":"guava","count":1,"path":"api/tags/guava.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"聊一聊 AOP ：表现形式与基础概念","uid":"740732400e76d891c8b7f2d184b75bcc","slug":"spring/spring-aop-form-concept","date":"2018-06-20T16:43:21.000Z","updated":"2024-07-05T04:09:05.815Z","comments":true,"path":"api/articles/spring/spring-aop-form-concept.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"text":" 原文：https://juejin.cn/post/6844903623101513735 aop 终于提上日程来写一写了。 本系列分为 上、中、下三篇。上篇...","permalink":"/post/spring/spring-aop-form-concept","photos":[],"count_time":{"symbolsCount":"23k","symbolsTime":"21 mins."},"categories":[{"name":"spring","slug":"spring","count":15,"path":"api/categories/spring.json"}],"tags":[{"name":"spring","slug":"spring","count":11,"path":"api/tags/spring.json"},{"name":"aop","slug":"aop","count":3,"path":"api/tags/aop.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}