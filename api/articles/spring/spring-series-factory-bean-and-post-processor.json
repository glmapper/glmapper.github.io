{"title":"聊一聊 BeanPostProcessor 不生效","uid":"8d3c27cae87c9531596050d409b7764c","slug":"spring/spring-series-factory-bean-and-post-processor","date":"2020-06-21T02:52:12.000Z","updated":"2024-07-05T04:09:05.817Z","comments":true,"path":"api/articles/spring/spring-series-factory-bean-and-post-processor.json","keywords":null,"cover":[],"content":"<p>关于 BeanPostProcessor 各位一定不陌生，在 <a href=\"http://www.glmapper.com/2019/12/14/springboot-series-bean-life/\">SpringBoot 源码系列-Bean 的生命周期与扩展</a> 这篇文章中，我有介绍过 bean 的创建流程及相关扩展，就有提到 BeanPostProcessor，包括它的作用时机及如何使用，这篇文章提到的这种属于比较常规的流程，因此在绝大多数场景下，都是符合我们认知的。但是最近在排查一个问题时，发现在某些场景下，BeanPostProcessor 不生效了…</p>\n<span id=\"more\"></span>\n\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>代码详见：<a href=\"https://github.com/glmapper/glmapper-spring-extention/tree/master/extention-FactoryBean\">extention-FactoryBean</a>; clone 之后可以直接运行 DemoApplication 即可，可以观察到 控制台不输出 GlmapperBeanPostProcessor 里面 print out 的字符串。</p></blockquote>\n<p>运行代码，即可观察到具体的执行现场；代码里除了 <code>BeanPostProcessor</code> 之外，另外一个是 <code>FactoryBean</code>，也就是本篇所要聊的重点：<code>FactoryBean getObjectType</code> 为 <code>null</code> 时导致 <code>bean</code> 提前初始化，从而使得作用与目标 <code>bean</code> 的 <code>BeanPostProcessors</code> 都失效了。</p>\n<p>下面将基于这个问题，展开进行分析。</p>\n<h2 id=\"bean-生命周期\"><a href=\"#bean-生命周期\" class=\"headerlink\" title=\"bean 生命周期\"></a>bean 生命周期</h2><p>先来看下 <code>ApplicationContext</code> 和 <code>bean</code> 生命周期(仅列出部分关键流程)：<br><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/beanlife/bean%20init.png\"></p>\n<p>从流程中可以看到：<code>BeanPostProcessor</code> 的注册是在 <code>ApplicationContext</code> 生命周期中完成的，故而当 <code>bean</code> 创建时，如果相应拦截器 <code>BeanPostProcessor</code> 还没有注册，那么其就不会起作用，这个可能有以下两种原因：</p>\n<ul>\n<li>1、<code>bean</code> 本身是一个 <code>BeanPostProcessor</code> ，且实现了 <code>PriorityOrdered</code> 或者 <code>Ordered</code> 接口</li>\n<li>2、<code>bean</code> 由于某种原因，被提前初始化了，初始化的时候相应拦截器 <code>BeanPostProcessor</code> 还没有注册</li>\n</ul>\n<p>关于第一个其实很好理解，不再赘述，本篇主要基于第二个原因进行说明。</p>\n<h2 id=\"bean-由于某种原因，被提前初始化了，初始化的时候相应拦截器-BeanPostProcessor-还没有注册\"><a href=\"#bean-由于某种原因，被提前初始化了，初始化的时候相应拦截器-BeanPostProcessor-还没有注册\" class=\"headerlink\" title=\"bean 由于某种原因，被提前初始化了，初始化的时候相应拦截器 BeanPostProcessor 还没有注册\"></a>bean 由于某种原因，被提前初始化了，初始化的时候相应拦截器 BeanPostProcessor 还没有注册</h2><p><code>bean</code> 被提前初始化的情况就比较多了，归纳下来都能符合同一个规律：在 创建所有 <code>non-lazy-init bean</code> 这一步之前，也即在创建 <code>BeanFactoryPostProcessor</code> 或者 <code>BeanPostProcessor</code> 的过程中，引发了 <code>bean</code> 的创建，导致其被提前初始化，大体可以分为两种情形：</p>\n<ul>\n<li>用户自定义的 <code>BeanFactoryPostProcessor</code> 或者 <code>BeanPostProcessor</code> 中会通过构造函数、属性注入等方式引用到目标 <code>bean</code> 导致其被提前创建</li>\n<li>在上述过程中由于 <code>Spring</code> 自身对 <code>FactoryBean</code> 的 <code>typeCheck</code>(类型检测) 机制导致目标 <code>bean</code> 被提前创建</li>\n</ul>\n<p>对于第一种情形，比较简单，这个通常是用户的配置导致的，比如我的 <code>TestBeanFactoryPostProcessor</code> 中通过属性注入了目标 <code>bean</code> 导致了其被提前创建，最终拦截器失效(如果去掉相应 <code>TestBeanFactoryPostProcessor</code> 配置，可以看到拦截器是能够成功的 )。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>简单代码如下，作用在 <code>TestFacade</code> 上的 <code>BeanFactoryPostProcessor</code> 可能会由于 <code>TestFacade</code> 的提前被创建而失效</p></blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestBeanFactoryPostProcessor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">BeanFactoryPostProcessor</span> &#123;</span><br><span class=\"line\">    @<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestFacade testFacade;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postProcessBeanFactory</span><span class=\"params\">(ConfigurableListableBeanFactory beanFactory)</span> <span class=\"keyword\">throws</span> BeansException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如何找到 <code>bean</code> 被提前初始化的时机呢？可以在 <code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])</code> 打一个条件断点，通过 <code>beanName</code> 进行匹配，然后顺着 <code>debug</code> 堆栈往回找，就能够看到是在哪里导致了 <code>bean</code> 被提前创建。</p></blockquote>\n<p>对于第二种情形，其实也是通过上述方法先找到被提前创建的源头，只不过这种情形更加隐晦，也更加复杂，这里我们单独在下面的部分中来分析。</p>\n<h2 id=\"关于-isTypeMatch\"><a href=\"#关于-isTypeMatch\" class=\"headerlink\" title=\"关于 isTypeMatch\"></a>关于 isTypeMatch</h2><p>从 Spring 2.x 版本开始，<code>BeanFactory</code> 中就已经有 <code>isTypeMatch</code> 这个方法了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Check whether the bean with the given name matches the specified type.</span></span><br><span class=\"line\"><span class=\"comment\">* More specifically, check whether a &#123;<span class=\"doctag\">@link</span> #getBean&#125; call for the given name</span></span><br><span class=\"line\"><span class=\"comment\">* would return an object that is assignable to the specified target type.</span></span><br><span class=\"line\"><span class=\"comment\">* &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class=\"line\"><span class=\"comment\">* Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> name the name of the bean to query</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> typeToMatch the type to match against (as a &#123;<span class=\"doctag\">@code</span> Class&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> true&#125; if the bean type matches,</span></span><br><span class=\"line\"><span class=\"comment\">* &#123;<span class=\"doctag\">@code</span> false&#125; if it doesn&#x27;t match or cannot be determined yet</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@since</span> 2.0.1</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@see</span> #getBean</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@see</span> #getType</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">isTypeMatch</span><span class=\"params\">(String name, <span class=\"meta\">@Nullable</span> Class&lt;?&gt; typeToMatch)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException;</span><br></pre></td></tr></table></figure>\n\n<p>从方法注释可以简单了解到，<code>isTypeMatch</code> 的作用就是：判断 <code>JavaBean</code> 是否匹配指定的类型。他包括两个参数：</p>\n<ul>\n<li><p>name：容器中定义的 <code>JavaBean</code> 的名称。</p>\n</li>\n<li><p>typeToMatch：要匹配的目标类型。<br>回到案例，我们需要关注的是 <code>isTypeMatch</code> 和我们前面提到的 <strong><code>FactoryBean getObjectType</code> 为 <code>null</code> 时导致 <code>bean</code> 提前初始化，从而使得作用与目标 <code>bean</code> 的 <code>BeanPostProcessors</code> 都失效了</strong>。有什么关系呢？这里有两个比较关键的信息：</p>\n</li>\n<li><p>1、FactoryBean getObjectType 为 null</p>\n</li>\n<li><p>2、目标 bean 的 BeanPostProcessors 都失效了</p>\n</li>\n</ul>\n<p>其实大概能够猜到的是，<code>FactoryBean getObjectType</code> 为 <code>null</code> 时，导致了 当前 <code>bean</code> 被提前初始化，而此时 <code>bean</code> 的 <code>BeanPostProcessors</code> 还没有被注册到当前 <code>bean</code> ，从而导致了目标 <code>bean</code> 的 <code>BeanPostProcessors</code> 都失效。 这个也是本篇的结论，但是还是需要来看看具体原因的细节是什么样的。</p>\n<p>我们知道，在 <code>Spring</code> 中，当进行 <code>byType</code> (除了用户主动配置 <code>byType</code> 注入以外，使用 <code>@autowired</code> 以及 <code>@Bean</code> 中的方法参数时等都使用的是 <code>byType</code> 注入) 注入时，会通过 <code>org.springframework.beans.factory.ListableBeanFactory#getBeanNamesForType(java.lang.Class&lt;?&gt;, boolean, boolean)</code> 来寻找相应类型的 <code>bean</code> 。</p>\n<p>针对 <code>FactoryBean</code> 而言，当判断其类型时，会先创建一个简单的(非完整的，仅仅是调用构造函数) <code>bean</code> ，调用其 <code>getObjectType()</code> ，如果发现返回为 <code>null</code>，那么就会再创造完整的 <code>bean</code> ，然后再通过 <code>getObjectType()</code> 获取类型进行匹配。</p>\n<h2 id=\"详细分析\"><a href=\"#详细分析\" class=\"headerlink\" title=\"详细分析\"></a>详细分析</h2><p>基于上面提到的点，结合本案例，来 <code>debug</code> 看下 <code>FactoryBean</code> <code>typeCheck</code>(类型检测) 机制导致的 <code>BeanPostProcessor</code> 不生效的原因。<br><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/beanlife/exe-stack.jpg\"><br>这里主要还是看下 isTypeMatch 方法执行是如何触发 bean 提前初始化的。</p>\n<h3 id=\"isTypeMatch-方法\"><a href=\"#isTypeMatch-方法\" class=\"headerlink\" title=\"isTypeMatch 方法\"></a>isTypeMatch 方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isTypeMatch</span><span class=\"params\">(String name, ResolvableType typeToMatch)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">beanName</span> <span class=\"operator\">=</span> transformedBeanName(name);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Check manually registered singletons.</span></span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">beanInstance</span> <span class=\"operator\">=</span> getSingleton(beanName, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 常规情况下，这里 beanInstance 是不为 null 的，但是对于提前加载的 beanInstance == null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanInstance != <span class=\"literal\">null</span> &amp;&amp; beanInstance.getClass() != NullBean.class) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断类型是不是 FactoryBean</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (beanInstance <span class=\"keyword\">instanceof</span> FactoryBean) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 返回给定名称是否为工厂解除引用(以工厂解除引用前缀开始)。 &amp;xxxx </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 这里拿 FactoryBean#getObjectType</span></span><br><span class=\"line\">                Class&lt;?&gt; type = getTypeForFactoryBean((FactoryBean&lt;?&gt;) beanInstance);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> (type != <span class=\"literal\">null</span> &amp;&amp; typeToMatch.isAssignableFrom(type));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 实例类型是否匹配</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> typeToMatch.isInstance(beanInstance);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 处理泛型和代理</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (typeToMatch.isInstance(beanInstance)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 直接匹配暴露实例?</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (typeToMatch.hasGenerics() &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 泛型可能只匹配目标类，而不匹配代理…</span></span><br><span class=\"line\">                <span class=\"type\">RootBeanDefinition</span> <span class=\"variable\">mbd</span> <span class=\"operator\">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class=\"line\">                Class&lt;?&gt; targetType = mbd.getTargetType();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (targetType != <span class=\"literal\">null</span> &amp;&amp; targetType != ClassUtils.getUserClass(beanInstance) &amp;&amp;</span><br><span class=\"line\">                        typeToMatch.isAssignableFrom(targetType)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 还要检查原始类匹配，确保它在代理上暴露。</span></span><br><span class=\"line\">                    Class&lt;?&gt; classToMatch = typeToMatch.resolve();</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> (classToMatch == <span class=\"literal\">null</span> || classToMatch.isInstance(beanInstance));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当前 beanName 的 bean 没有被注册过</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (containsSingleton(beanName) &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// null instance registered</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 没有找到单例实例-&gt;检查bean定义。</span></span><br><span class=\"line\">    <span class=\"type\">BeanFactory</span> <span class=\"variable\">parentBeanFactory</span> <span class=\"operator\">=</span> getParentBeanFactory();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parentBeanFactory != <span class=\"literal\">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在这个 factory 中没有找到 bean definition -&gt; 委托 parent。</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> parentBeanFactory.isTypeMatch(originalBeanName(name), typeToMatch);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 检索相应的 bean 定义。</span></span><br><span class=\"line\">    <span class=\"type\">RootBeanDefinition</span> <span class=\"variable\">mbd</span> <span class=\"operator\">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class=\"line\"></span><br><span class=\"line\">    Class&lt;?&gt; classToMatch = typeToMatch.resolve();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (classToMatch == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        classToMatch = FactoryBean.class;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Class&lt;?&gt;[] typesToMatch = (FactoryBean.class == classToMatch ?</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>&lt;?&gt;[] &#123;classToMatch&#125; : <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>&lt;?&gt;[] &#123;FactoryBean.class, classToMatch&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check decorated bean definition, if any: We assume it&#x27;ll be easier</span></span><br><span class=\"line\">    <span class=\"comment\">// to determine the decorated bean&#x27;s type than the proxy&#x27;s type.</span></span><br><span class=\"line\">    <span class=\"comment\">// 检查修饰 bean definition(如果有的话):我们假设确定修饰 bean 的类型比确定代理的类型更容易。</span></span><br><span class=\"line\">    <span class=\"type\">BeanDefinitionHolder</span> <span class=\"variable\">dbd</span> <span class=\"operator\">=</span> mbd.getDecoratedDefinition();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dbd != <span class=\"literal\">null</span> &amp;&amp; !BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class=\"line\">        <span class=\"type\">RootBeanDefinition</span> <span class=\"variable\">tbd</span> <span class=\"operator\">=</span> getMergedBeanDefinition(dbd.getBeanName(), dbd.getBeanDefinition(), mbd);</span><br><span class=\"line\">        <span class=\"comment\">// 预测指定bean的最终bean类型(已处理bean实例的)。由&#123;@link #getType&#125;和&#123;@link #isTypeMatch&#125;调用。不需要专门处理factorybean，因为它只应该操作原始bean类型。</span></span><br><span class=\"line\">        <span class=\"comment\">// 这个实现过于简单，因为它不能处理工厂方法和实例化 awarebeanpostprocessors。对于标准bean，它只能正确地预测bean类型。要在子类中重写，应用更复杂的类型检测。</span></span><br><span class=\"line\">        Class&lt;?&gt; targetClass = predictBeanType(dbd.getBeanName(), tbd, typesToMatch);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (targetClass != <span class=\"literal\">null</span> &amp;&amp; !FactoryBean.class.isAssignableFrom(targetClass)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> typeToMatch.isAssignableFrom(targetClass);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 推断出 beanType</span></span><br><span class=\"line\">    Class&lt;?&gt; beanType = predictBeanType(beanName, mbd, typesToMatch);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanType == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 检查 bean class 是否是 FactoryBean 类型。本案例就是在这被处理到 返回 false 的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FactoryBean.class.isAssignableFrom(beanType)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; beanInstance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果它是FactoryBean，我们希望看到它创建了什么（getObject），而不是工厂类。</span></span><br><span class=\"line\">            beanType = getTypeForFactoryBean(beanName, mbd);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (beanType == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 省略 ........</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"getTypeForFactoryBean-方法\"><a href=\"#getTypeForFactoryBean-方法\" class=\"headerlink\" title=\"getTypeForFactoryBean 方法\"></a>getTypeForFactoryBean 方法</h3><p>这个步骤会向尝试从 <code>FactoryBean</code> 的 <code>getObjectType</code> 方法去获取类型，如果拿不到，则调用父类的进行初始化 <code>bean</code> 操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 省略 其他...</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (fb != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 尝试从实例的这个早期阶段获取 FactoryBean 的对象类型。这里调用的就是 FactoryBean#getObjectType 方法</span></span><br><span class=\"line\">    Class&lt;?&gt; result = getTypeForFactoryBean(fb);</span><br><span class=\"line\">    <span class=\"comment\">// 本案例中这里返回的是 null, 所以会走到 else</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里的意思就是没有通过 FactoryBean#getObjectType 快速获取到类型</span></span><br><span class=\"line\">        <span class=\"comment\">// 将执行实例当前实例，然后再获取</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.getTypeForFactoryBean(beanName, mbd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 省略 其他...</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"AbstractBeanFactory-getTypeForFactoryBean\"><a href=\"#AbstractBeanFactory-getTypeForFactoryBean\" class=\"headerlink\" title=\"AbstractBeanFactory#getTypeForFactoryBean\"></a>AbstractBeanFactory#getTypeForFactoryBean</h3><p>调用父类的 <code>getTypeForFactoryBean</code> 方法，执行 <code>bean</code> 的初始化</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Nullable</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; getTypeForFactoryBean(String beanName, RootBeanDefinition mbd) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mbd.isSingleton()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里开始执行 doGetBean，之前的文章里面有提到，bean 实例化的入口就是 getBean 的时候</span></span><br><span class=\"line\">        FactoryBean&lt;?&gt; factoryBean = doGetBean(FACTORY_BEAN_PREFIX + beanName, FactoryBean.class, <span class=\"literal\">null</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getTypeForFactoryBean(factoryBean);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (BeanCreationException ex) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 省略日志打印部分</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>doGetBean</code> 中执行链路中，会在 <code>initializeBean</code> 时给当前 <code>bean</code> 注册 <code>BeanPostProcessor</code>，（<code>applyBeanPostProcessorsBeforeInitialization</code> 方法中) ，这里可以比较清晰的看到 <code>BeanPostProcessor</code> 没有作用于 目标 <code>bean</code> 的。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>doGetBean -&gt; createBean -&gt; initializeBean -&gt; applyBeanPostProcessorsBeforeInitialization</p></blockquote>\n<p><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/beanlife/no-processors.jpg\"></p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>在本篇的案例中，其实比较明显的可以看到测试工程中 <code>GlmapperFactoryBean</code> 的 <code>getObjectType</code> 返回是为 <code>null</code> 的，也正是因为这个原因导致了 <code>BeanPostProcessor</code> 失效。那么如何在实际的开发过程中来规避呢？</p>\n<ul>\n<li>1、FactoryBean 的 getObjectType() 不要返回 null</li>\n<li>2、定义 BeanPostProcessor 时，需要特别注意 order</li>\n<li>3、在 创建所有 non-lazy-init bean 之前的 getBeanNamesForType 调用，尽量将 eagerInit 传为 false。</li>\n</ul>\n<p>关于第三点，前面提到过 <code>getBeanNamesForType</code> 的调用会触发类型检查，但其实这个方法还有些参数，参考如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] getBeanNamesForType(Class&lt;?&gt; type, <span class=\"type\">boolean</span> includeNonSingletons, <span class=\"type\">boolean</span> allowEagerInit);</span><br></pre></td></tr></table></figure>\n<p>这里有个很重要的参数 <code>allowEagerInit</code> ，可以看到 <code>spring</code> 的注释中对其有非常详细的解释：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* <span class=\"meta\">@param</span> allowEagerInit whether to initialize lazy-init singletons and</span><br><span class=\"line\">* objects created by <span class=\"title function_\">FactoryBeans</span> <span class=\"params\">(or by factory methods with a</span></span><br><span class=\"line\"><span class=\"params\">* <span class=\"string\">&quot;factory-bean&quot;</span> reference)</span> <span class=\"keyword\">for</span> the type check. Note that FactoryBeans need to be</span><br><span class=\"line\">* eagerly initialized to determine their type: So be aware that passing in <span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\">* <span class=\"keyword\">for</span> <span class=\"built_in\">this</span> flag will initialize FactoryBeans and <span class=\"string\">&quot;factory-bean&quot;</span> references.</span><br></pre></td></tr></table></figure>\n\n<p>简单来说这个参数能够控制是否允许 <code>FactoryBean</code> 的提前创建，如果是 <code>false</code>，那么也不会引发上述的 类型检测 。可以看到在 <code>Spring</code> 中在获取 <code>BeanFactoryPostProcessor</code> 以及 <code>BeanPostProcessor</code> 时，也都是传入 <code>false</code> 的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] postProcessorNames =</span><br><span class=\"line\">        beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">String[] postProcessorNames = </span><br><span class=\"line\">    beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>当然在一些 <code>@Bean</code> 的方法参数注入、<code>@Autowire</code> 注入等场景下，这个默认都是 <code>true</code> 的，无法改变；但针对平时编码过程中，如果是在比较早期的调用中，可根据情况，尽量传入 <code>false</code>。</p>\n","text":"关于 BeanPostProcessor 各位一定不陌生，在 SpringBoot 源码系列-Bean 的生命周期与扩展 这篇文章中，我有介绍过 bean 的创...","permalink":"/post/spring/spring-series-factory-bean-and-post-processor","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"spring","slug":"spring","count":15,"path":"api/categories/spring.json"}],"tags":[{"name":"BeanPostProcessor","slug":"BeanPostProcessor","count":1,"path":"api/tags/BeanPostProcessor.json"},{"name":"bean 生命周期","slug":"bean-生命周期","count":2,"path":"api/tags/bean-生命周期.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">问题描述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">bean 生命周期</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bean-%E7%94%B1%E4%BA%8E%E6%9F%90%E7%A7%8D%E5%8E%9F%E5%9B%A0%EF%BC%8C%E8%A2%AB%E6%8F%90%E5%89%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%97%B6%E5%80%99%E7%9B%B8%E5%BA%94%E6%8B%A6%E6%88%AA%E5%99%A8-BeanPostProcessor-%E8%BF%98%E6%B2%A1%E6%9C%89%E6%B3%A8%E5%86%8C\"><span class=\"toc-text\">bean 由于某种原因，被提前初始化了，初始化的时候相应拦截器 BeanPostProcessor 还没有注册</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E-isTypeMatch\"><span class=\"toc-text\">关于 isTypeMatch</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90\"><span class=\"toc-text\">详细分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#isTypeMatch-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">isTypeMatch 方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#getTypeForFactoryBean-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">getTypeForFactoryBean 方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#AbstractBeanFactory-getTypeForFactoryBean\"><span class=\"toc-text\">AbstractBeanFactory#getTypeForFactoryBean</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"Linux Top 命令指南","uid":"3da34a407a5e481b18f31bdb1ed34b7e","slug":"linux/linux-cmd-top","date":"2020-08-10T01:53:31.000Z","updated":"2024-07-05T04:09:05.774Z","comments":true,"path":"api/articles/linux/linux-cmd-top.json","keywords":null,"cover":null,"text":"top 命令允许用户监视 Linux 上的进程和系统资源使用情况，它是系统管理员工具箱中最有用的工具之一，并且在每个发行版中都预装了它。与 ps 等其他命令不同...","permalink":"/post/linux/linux-cmd-top","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Linux","slug":"Linux","count":9,"path":"api/categories/Linux.json"}],"tags":[{"name":"linux","slug":"linux","count":9,"path":"api/tags/linux.json"},{"name":"top","slug":"top","count":1,"path":"api/tags/top.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"解决方案系列-集群选主(基于DB)","uid":"a1ba8e53214d9964ec5cbb3342aa4377","slug":"solutions/solution-series-cluster-selector","date":"2020-05-29T10:12:42.000Z","updated":"2024-07-05T04:09:05.810Z","comments":true,"path":"api/articles/solutions/solution-series-cluster-selector.json","keywords":null,"cover":[],"text":"一个业务量很小的系统，所有的代码都放在一个项目中，部署在一台服务器上。所有的服务都由这台服务器提供，这就是常说的单机模式；我们知道单机模式的缺点是：1、处理能力...","permalink":"/post/solutions/solution-series-cluster-selector","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"解决方案","slug":"解决方案","count":5,"path":"api/categories/解决方案.json"}],"tags":[{"name":"架构","slug":"架构","count":4,"path":"api/tags/架构.json"},{"name":"Mysql","slug":"Mysql","count":1,"path":"api/tags/Mysql.json"},{"name":"集群选主","slug":"集群选主","count":1,"path":"api/tags/集群选主.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}