{"title":"SpringAop 代理模式及 AopContext 问题小记","uid":"36de71f48064befd8223d8b0f7b379a4","slug":"spring/spring-proxy-aopcontext","date":"2021-07-17T08:17:04.000Z","updated":"2024-07-05T04:09:05.817Z","comments":true,"path":"api/articles/spring/spring-proxy-aopcontext.json","keywords":null,"cover":[],"content":"<p>AOP 称为面向切面编程，其底层原理就是动态代理；JAVA 中比较常见的动态代理有两种，分别是 JDK 动态代理和 CGLIB 动态代理，这点从 Spring Aop 的 AopProxy 的实现就可以得出验证。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AopProxy</span><br><span class=\"line\">    --- JdkDynamicAopProxy</span><br><span class=\"line\">    --- CglibAopProxy</span><br></pre></td></tr></table></figure>\n\n<p>Spring 作为 Java 应用领域最牛 X 的基础框架产品，在对于一些版本变更导致的兼容性问题的处理上一直被诟病，对于这两种代理方式的选择上，Spring 不同版本存在一定的差异，这也是本文产生的一个原因。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"从一个异常说起\"><a href=\"#从一个异常说起\" class=\"headerlink\" title=\"从一个异常说起\"></a>从一个异常说起</h2><p>本来是打算写个 AOP demo 来验证下 AopContext 在跨线程场景下丢失 proxy 对象问题的，由于在 pom 中指定依赖了 spring-aop 版本（5.1.2），而工程 spring-boot 版本使用是 2.4.2，启动时就抛出了如下的异常（仅截取了后 3 段 casuse by）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name <span class=\"string\">&#x27;jdkServiceImpl&#x27;</span> defined <span class=\"keyword\">in</span> file [/Users/sgl/Documents/projects/github/aop-guides/target/classes/com/glmapper/bridge/boot/jdk/JdkServiceImpl.class]: Initialization of bean failed; nested exception is org.springframework.aop.framework.AopConfigException: Unexpected AOP exception; nested exception is java.lang.IllegalStateException: Unable to load cache item</span><br><span class=\"line\">\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:617)</span><br><span class=\"line\">\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:531)</span><br><span class=\"line\">\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean<span class=\"variable\">$0</span>(AbstractBeanFactory.java:335)</span><br><span class=\"line\">\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)</span><br><span class=\"line\">\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333)</span><br><span class=\"line\">\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208)</span><br><span class=\"line\">\tat org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276)</span><br><span class=\"line\">\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1380)</span><br><span class=\"line\">\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1300)</span><br><span class=\"line\">\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor<span class=\"variable\">$AutowiredFieldElement</span>.inject(AutowiredAnnotationBeanPostProcessor.java:640)</span><br><span class=\"line\">\t... 46 more</span><br><span class=\"line\">Caused by: org.springframework.aop.framework.AopConfigException: Unexpected AOP exception; nested exception is java.lang.IllegalStateException: Unable to load cache item</span><br><span class=\"line\">\tat org.springframework.aop.framework.CglibAopProxy.getProxy(CglibAopProxy.java:214)</span><br><span class=\"line\">\tat org.springframework.aop.framework.ProxyFactory.getProxy(ProxyFactory.java:110)</span><br><span class=\"line\">\tat org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.createProxy(AbstractAutoProxyCreator.java:473)</span><br><span class=\"line\">\tat org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.wrapIfNecessary(AbstractAutoProxyCreator.java:352)</span><br><span class=\"line\">\tat org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(AbstractAutoProxyCreator.java:301)</span><br><span class=\"line\">\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:444)</span><br><span class=\"line\">\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792)</span><br><span class=\"line\">\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:609)</span><br><span class=\"line\">\t... 55 more</span><br><span class=\"line\">Caused by: java.lang.IllegalStateException: Unable to load cache item</span><br><span class=\"line\">\tat org.springframework.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:79)</span><br><span class=\"line\">\tat org.springframework.cglib.core.internal.LoadingCache.get(LoadingCache.java:34)</span><br><span class=\"line\">\tat org.springframework.cglib.core.AbstractClassGenerator<span class=\"variable\">$ClassLoaderData</span>.get(AbstractClassGenerator.java:134)</span><br><span class=\"line\">\tat org.springframework.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:319)</span><br><span class=\"line\">\tat org.springframework.cglib.proxy.Enhancer.createHelper(Enhancer.java:572)</span><br><span class=\"line\">\tat org.springframework.cglib.proxy.Enhancer.createClass(Enhancer.java:419)</span><br><span class=\"line\">\tat org.springframework.aop.framework.ObjenesisCglibAopProxy.createProxyClassAndInstance(ObjenesisCglibAopProxy.java:58)</span><br><span class=\"line\">\tat org.springframework.aop.framework.CglibAopProxy.getProxy(CglibAopProxy.java:205)</span><br><span class=\"line\">\t... 62 more</span><br><span class=\"line\">Caused by: java.lang.VerifyError: Stack map does not match the one at exception handler 9</span><br><span class=\"line\">Exception Details:</span><br><span class=\"line\">  Location:</span><br><span class=\"line\">    com/glmapper/bridge/boot/jdk/JdkServiceImpl$$EnhancerBySpringCGLIB$<span class=\"variable\">$3045df64</span>.&lt;init&gt;()V @9: athrow</span><br><span class=\"line\">  Reason:</span><br><span class=\"line\">    Current frame<span class=\"string\">&#x27;s flags are not assignable to stack map frame&#x27;</span>s.</span><br><span class=\"line\">  Current Frame:</span><br><span class=\"line\">    bci: @0</span><br><span class=\"line\">    flags: &#123; flagThisUninit &#125;</span><br><span class=\"line\">    locals: &#123; uninitializedThis &#125;</span><br><span class=\"line\">    stack: &#123; <span class=\"string\">&#x27;java/lang/RuntimeException&#x27;</span> &#125;</span><br><span class=\"line\">  Stackmap Frame:</span><br><span class=\"line\">    bci: @9</span><br><span class=\"line\">    flags: &#123; &#125;</span><br><span class=\"line\">    locals: &#123; &#125;</span><br><span class=\"line\">    stack: &#123; <span class=\"string\">&#x27;java/lang/Throwable&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>看到这个异常有点莫名其妙，然后尝试通过关键字去网上搜了下，确实找到了一个非常类似的 case <a href=\"https://stackoverflow.com/questions/60601994/unexpected-aop-exception-nested-exception-is-java-lang-illegalstateexception-u\">Unexpected AOP exception; nested exception is java.lang.IllegalStateException: Unable to load cache item</a>。从问题描述来看，大致有以下几个方向：</p>\n<ul>\n<li>1、spring boot devtools 热部署导致</li>\n<li>2、CGLIB 或 Objenesis 不理解 Java 13 字节代码</li>\n<li>3、依赖问题</li>\n</ul>\n<p>在我的 demo 中，1 和 2 都是未涉及的，所以将专注点放在 3 上面。一开始尝试 <code>Stack map does not match the one at exception handler 9</code> 全局查找，尝试找到产生堆栈的代码片段，实际上是没有在代码中找到的；随后翻看了 openjdk 的源码才找到。<strong>另一个比较疑惑的问题在于：这个异常产生仅当通过 run test unit 的时候才会有，正常通过启动工程并发起调用并不会出现</strong>。当我把 Spring Aop 版本切换到 5.3.3 时，run test unit 也可以正常被执行。</p>\n<p>图1：spring-aop 版本为 5.3.3, Class.forName 正常执行到下一行</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75ea7642a9724e358e25e0673e733e4e~tplv-k3u1fbpfcp-watermark.image\"></p>\n<p>图2：spring-aop 版本为 5.1.2</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61f0a50cd8e84637bfe7c5b2ba476b5d~tplv-k3u1fbpfcp-watermark.image\"></p>\n<p>执行直接报错<br><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b88cef96f3b743e08ab0ae4c455904df~tplv-k3u1fbpfcp-watermark.image\"></p>\n<p>其实堆栈来看，两者并无差异。到这里不打算继续深究原因，回到 VerifyError 异常：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>当 “verifier” 检测到 classfile 虽然格式良好，但包含某种内部不一致或安全问题时抛出。</p></blockquote>\n<p>加上产生的条件：在 springboot 测试场景下，使用低于管控版本的 spring aop 从而导致该问题；合理规避吧…</p>\n<h2 id=\"Spring-aop-动态代理机制在不同版本中的差异\"><a href=\"#Spring-aop-动态代理机制在不同版本中的差异\" class=\"headerlink\" title=\"Spring aop 动态代理机制在不同版本中的差异\"></a>Spring aop 动态代理机制在不同版本中的差异</h2><p>这里仅作为备忘点介绍一下，大多数情况下在使用的时候并不会关注到。</p>\n<ul>\n<li>1、Spring 5.x 版本开始，AOP 默认依旧使用 JDK 动态代理，并非网上说的默认改成了 CGLIB。</li>\n<li>2、SpringBoot 2.x 开始，由于使用 JDK 动态代理可能导致的类型转化异常问题，默认使用 CGLIB。</li>\n<li>3、SpringBoot 2.x 中，如果需要默认使用 JDK 动态代理可以通过配置项 <code>spring.aop.proxy-target-class=false</code> 来进行修改，proxyTargetClass 配置已无效。</li>\n</ul>\n<p>相关论证可以见：AopAutoConfiguration、@EnableAspectJAutoProxy 及官方文档说明。</p>\n<h2 id=\"AopContext\"><a href=\"#AopContext\" class=\"headerlink\" title=\"AopContext\"></a>AopContext</h2><p>关于 AopContext 可能部分开发者对其是陌生的；但是有这样一种场景一定是你遇到过的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JdkServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">JdkService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"meta\">@Metrics(name = &quot;helloJdk&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">helloJdk</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// invoke inner</span></span><br><span class=\"line\">        inner();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Metrics(name = &quot;inner&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">inner</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;this is Jdk inner method&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当你写了一个自定义注解，然后通过 aop 去拦截时，对于类内部方法之间的调用无法拦截，如上代码片段，在 helloJdk 中调用 inner，同样打上了 @Metrics 注解，实际上 inner 的调用是不会被 aop 拦截到的；原因在于，这里的 inner 调用实际上等同于 <code>this.inner()</code>，而当前的 this 对象是 JdkServiceImpl 对象本身，并非代理类，所以切不到是正常的。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bd32ccc640d4eeea2c5531bc5a52036~tplv-k3u1fbpfcp-watermark.image\"></p>\n<p>那这里其实就可能通过 AopContext 来辅助一下，这里有个前提条件，通过注解添加配置（加在类上）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableAspectJAutoProxy(proxyTargetClass = true, exposeProxy = true)</span></span><br></pre></td></tr></table></figure>\n\n<p>或通过 xml 配置文件添加配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:aspectj-autoproxy</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">expose-proxy</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>否则会抛出如下错误：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Cannot find current proxy: Set ‘exposeProxy’ property on Advised to ‘true’ to make it available.</p></blockquote>\n<p>原因在于，当 exposeProxy 为 true 时，才会将当前 proxy 对象塞到 AopContext 中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.advised.exposeProxy) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Make invocation available if necessary.</span></span><br><span class=\"line\">\toldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class=\"line\">\tsetProxyContext = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AopContext 的实现很简单，就是在内部维护了一个 ThreadLocal：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Object&gt; currentProxy = <span class=\"keyword\">new</span> <span class=\"title class_\">NamedThreadLocal</span>&lt;&gt;(<span class=\"string\">&quot;Current AOP proxy&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>所以在使用这个工具类的时候，还需要关注另一个问题，就是当在跨线程，或者使用线程池的情况下，需要手动将 proxy 透传到新的线程中，否则，即使开始 exposeProxy &#x3D; true，同样也会出现 Cannot find current proxy: Set ‘exposeProxy’ 报错。</p>\n","text":"AOP 称为面向切面编程，其底层原理就是动态代理；JAVA 中比较常见的动态代理有两种，分别是 JDK 动态代理和 CGLIB 动态代理，这点从 Spring ...","permalink":"/post/spring/spring-proxy-aopcontext","photos":[],"count_time":{"symbolsCount":"7.5k","symbolsTime":"7 mins."},"categories":[{"name":"spring","slug":"spring","count":15,"path":"api/categories/spring.json"}],"tags":[{"name":"spring","slug":"spring","count":11,"path":"api/tags/spring.json"},{"name":"aop","slug":"aop","count":3,"path":"api/tags/aop.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%BC%82%E5%B8%B8%E8%AF%B4%E8%B5%B7\"><span class=\"toc-text\">从一个异常说起</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spring-aop-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E4%B8%AD%E7%9A%84%E5%B7%AE%E5%BC%82\"><span class=\"toc-text\">Spring aop 动态代理机制在不同版本中的差异</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#AopContext\"><span class=\"toc-text\">AopContext</span></a></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"使用 docker 部署 kafka 集群","uid":"d753fae6fcae22e0a4f351ebed82c72a","slug":"docker/docker-compose-kakfa-install","date":"2021-07-23T13:47:16.000Z","updated":"2024-07-05T04:09:05.756Z","comments":true,"path":"api/articles/docker/docker-compose-kakfa-install.json","keywords":null,"cover":null,"text":" 参考文档：https://github.com/wurstmeister/kafka-docker 在你的文件系统中找个目录，然后新建一个 docker-co...","permalink":"/post/docker/docker-compose-kakfa-install","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"docker","slug":"docker","count":2,"path":"api/categories/docker.json"}],"tags":[{"name":"docker","slug":"docker","count":2,"path":"api/tags/docker.json"},{"name":"kafka","slug":"kafka","count":1,"path":"api/tags/kafka.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"你知道 Junit 是怎么跑的吗？","uid":"0092fc26e9bf86d6199cb316ea25f766","slug":"tests/test-junit-run-principle","date":"2021-07-02T13:47:16.000Z","updated":"2024-07-05T04:09:05.845Z","comments":true,"path":"api/articles/tests/test-junit-run-principle.json","keywords":null,"cover":[],"text":"Junit 是由 Kent Beck 和 Erich Gamma 于 1995 年底着手编写的框架，自此以后，Junit 框架日益普及，现在已经成为单元测试 J...","permalink":"/post/tests/test-junit-run-principle","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"test","slug":"test","count":5,"path":"api/categories/test.json"}],"tags":[{"name":"test","slug":"test","count":5,"path":"api/tags/test.json"},{"name":"junit","slug":"junit","count":2,"path":"api/tags/junit.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}