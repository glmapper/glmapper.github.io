{"title":"1 分钟快速上手 Spring Cache","uid":"e9b917f0ab2ca1b9d25a2dd79ca6610e","slug":"spring/spring-cache-quick-start","date":"2022-02-21T03:43:24.000Z","updated":"2024-07-05T04:09:05.815Z","comments":true,"path":"api/articles/spring/spring-cache-quick-start.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"content":"<p>如果你现在有一个现成的工程，你想给你工程的某个接口增加缓存，再不可以分布式缓存的情况下，你可以通过以下两步完成 <code>Spring Cache</code> 接入:</p>\n<span id=\"more\"></span>\n\n<p>1、引用依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-cache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>2、给你需要增加缓存的接口或者方法加上注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@CacheConfig(cacheNames = &quot;myCache&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyCacheService</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@CachePut(key = &quot;#key&quot;, unless=&quot;#result == null&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">save</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Cacheable(key = &quot;#key&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">find</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当你完成这两步时，支持 <code>local</code> 缓存的方案已经完成了。</p>\n<h2 id=\"基本使用（默认配置）\"><a href=\"#基本使用（默认配置）\" class=\"headerlink\" title=\"基本使用（默认配置）\"></a>基本使用（默认配置）</h2><p>快速开始部分，我们仅引入了一个依赖，然后对需要缓存的接口加了注解，其他什么配置都没有，所以这种方式使用的都是 <code>Spring Cache</code> 的默认配置。<code>Spring Cache</code> 的默认配置类是 <code>CacheProperties</code>，简单看下有哪些配置属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>子属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>type</td>\n<td></td>\n<td>缓存类型，根据环境自动检测（auto-detected）</td>\n</tr>\n<tr>\n<td>cacheNames</td>\n<td></td>\n<td>如果底层缓存管理器支持的话，要创建的以逗号分隔的缓存名称列表。通常，这将禁用动态创建额外缓存的能力。</td>\n</tr>\n<tr>\n<td>caffeine</td>\n<td>spec：是创建缓存规范，具体见 CaffeineSpec 类</td>\n<td>Caffeine 作为缓存</td>\n</tr>\n<tr>\n<td>couchbase</td>\n<td>expiration：描述过期时间，默认情况下，内部 entries 不会过期</td>\n<td>Couchbase 作为缓存</td>\n</tr>\n<tr>\n<td>ehcache</td>\n<td>config： 用于创建 ehcache 所提供的配置文件</td>\n<td>EhCache 作为缓存</td>\n</tr>\n<tr>\n<td>infinispan</td>\n<td>config：用于创建 Infinispan 所提供的配置文件</td>\n<td>Infinispan 作为缓存</td>\n</tr>\n<tr>\n<td>jcache</td>\n<td>config：用于初始化缓存管理器的配置文件的位置。配置文件依赖于底层缓存实现。</td>\n<td>Jcache 作为缓存</td>\n</tr>\n<tr>\n<td>provider：CachingProvider 实现的完全限定名，用于检索符合JSR-107的缓存管理器。仅当类路径上有多个JSR-107实现可用时才需要。</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>redis</td>\n<td>timeToLive：缓存过期时间</td>\n<td>Redis 作为缓存</td>\n</tr>\n<tr>\n<td>cacheNullValues：是否允许缓存 null 值</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>keyPrefix：key 前缀</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>useKeyPrefix：写入时是否使用 前缀</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>enableStatistics：是否开启缓存指标统计能力</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p><code>Spring Cache</code> 没有使用上表中的缓存，上表中所提到的缓存类型是在指定 <code>type</code> 时，对应所需的配置，默认情况下，在没有明确指定 <code>type</code> 时，使用的是 <code>SIMPLE</code>，<code>CacheType</code> 所有枚举类型如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">CacheType</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Generic caching using &#x27;Cache&#x27; beans from the context.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tGENERIC,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * JCache (JSR-107) backed caching.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tJCACHE,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * EhCache backed caching.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tEHCACHE,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Hazelcast backed caching.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tHAZELCAST,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Infinispan backed caching.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tINFINISPAN,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Couchbase backed caching.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tCOUCHBASE,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Redis backed caching.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tREDIS,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Caffeine backed caching.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tCAFFEINE,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Simple in-memory caching.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tSIMPLE,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * No caching.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tNONE</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>SIMPLE</code> 对应的缓存器是基于内存的，其底层存储基于 <code>ConcurrentHashMap</code>。</p>\n<h2 id=\"使用-redis-作为缓存\"><a href=\"#使用-redis-作为缓存\" class=\"headerlink\" title=\"使用 redis 作为缓存\"></a>使用 redis 作为缓存</h2><p>上述快速开始部分实现缓存存储是基于内存的，对于单体应用解决小流量接口缓存问题不大，但是在分布式环境和大流量接口场景下，是不行的。下面来对快速开始部分进行改造，实现目前常用的基于 <code>Spring Cache + Redis</code> 的方案。</p>\n<p>1、引入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：网上一些时间较久的文章使用的是 <code>spring-boot-starter-redis</code>，这个依赖在 <code>Spring Boot 1.4</code> 版本之后被弃用了，改为使用 <code>spring-boot-starter-data-redis</code> 了，官方有明确说明，详见：<a href=\"https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-redis\">https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-redis</a></p>\n<p>2、指定 <code>cache type</code> 为 <code>redis</code></p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring.cache.type</span>=<span class=\"string\">redis</span></span><br></pre></td></tr></table></figure>\n\n<p>完成 1-2 时，就完成了基于 <code>redis</code> 默认配置的集成，此时连接的 <code>redis</code> 地址是 <code>localshot:6379</code>；当然也可以通过配置文件来定制 <code>redis</code> 的配置，</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#redis配置</span></span><br><span class=\"line\"><span class=\"comment\">#Redis数据库索引（缓存将使用此索引编号的数据库）</span></span><br><span class=\"line\"><span class=\"attr\">spring.redis.database</span>=<span class=\"string\">0</span></span><br><span class=\"line\"><span class=\"comment\">#Redis服务器地址  </span></span><br><span class=\"line\"><span class=\"attr\">spring.redis.host</span>=<span class=\"string\">localhost </span></span><br><span class=\"line\"><span class=\"comment\">#Redis服务器连接端口</span></span><br><span class=\"line\"><span class=\"attr\">spring.redis.port</span>=<span class=\"string\">6379 </span></span><br><span class=\"line\"><span class=\"comment\">#Redis服务器连接密码（默认为空）  </span></span><br><span class=\"line\"><span class=\"attr\">spring.redis.password</span>=<span class=\"string\"></span></span><br><span class=\"line\"><span class=\"comment\">#连接超时时间 毫秒（默认2000）</span></span><br><span class=\"line\"><span class=\"comment\">#请求redis服务的超时时间,这里注意设置成0时取默认时间2000</span></span><br><span class=\"line\"><span class=\"attr\">spring.redis.timeout</span>=<span class=\"string\">2000</span></span><br><span class=\"line\"><span class=\"comment\">#连接池最大连接数（使用负值表示没有限制）  </span></span><br><span class=\"line\"><span class=\"comment\">#建议为业务期望QPS/一个连接的QPS,例如50000/1000=50</span></span><br><span class=\"line\"><span class=\"comment\">#一次命令时间(borrow|return resource+Jedis执行命令+网络延迟)的平均耗时约为1ms,一个连接的QPS大约是1000</span></span><br><span class=\"line\"><span class=\"attr\">spring.redis.pool.max-active</span>=<span class=\"string\">50 </span></span><br><span class=\"line\"><span class=\"comment\">#连接池中的最大空闲连接 </span></span><br><span class=\"line\"><span class=\"comment\">#建议和最大连接数一致,这样做的好处是连接数从不减少,从而避免了连接池伸缩产生的性能开销。</span></span><br><span class=\"line\"><span class=\"attr\">spring.redis.pool.max-idle</span>=<span class=\"string\">50</span></span><br><span class=\"line\"><span class=\"comment\">#连接池中的最小空闲连接  </span></span><br><span class=\"line\"><span class=\"comment\">#建议为0，在无请求的状况下从不创建链接</span></span><br><span class=\"line\"><span class=\"attr\">spring.redis.pool.min-idle</span>=<span class=\"string\">0 </span></span><br><span class=\"line\"><span class=\"comment\">#连接池最大阻塞等待时间 毫秒（-1表示没有限制）  </span></span><br><span class=\"line\"><span class=\"comment\">#建议不要为-1，连接池占满后无法获取连接时将在该时间内阻塞等待，超时后将抛出异常。</span></span><br><span class=\"line\"><span class=\"attr\">spring.redis.pool.max-wait</span>=<span class=\"string\">2000</span></span><br></pre></td></tr></table></figure>\n\n<p>此外，还可以通过创建缓存配置文件类可以设置缓存各项参数，比如缓存key 的过期时间，使用 key 前缀等，如下：</p>\n<h3 id=\"定义缓存过期时间\"><a href=\"#定义缓存过期时间\" class=\"headerlink\" title=\"定义缓存过期时间\"></a>定义缓存过期时间</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> RedisCacheConfiguration <span class=\"title function_\">cacheConfiguration</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class=\"line\">    <span class=\"comment\">// 过期时间</span></span><br><span class=\"line\">    .entryTtl(Duration.ofMinutes(<span class=\"number\">60</span>)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自定义-key-前缀\"><a href=\"#自定义-key-前缀\" class=\"headerlink\" title=\"自定义 key 前缀\"></a>自定义 key 前缀</h3><p>key 前缀默认是 cacheName，比如你的 key 是 test，你的 cacheName 是 myCache，则默认情况下存入的 key 为：”myCache::test”, 如果需要调整，可以通过如下方式调整</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> RedisCacheConfiguration <span class=\"title function_\">cacheConfiguration</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class=\"line\">    <span class=\"comment\">// 增加前缀</span></span><br><span class=\"line\">     .prefixCacheNameWith(<span class=\"string\">&quot;my-prefix::&quot;</span>)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改之后，key 为 <code>&quot;my-prefix::myCache::glmapper&quot;</code>。</p>\n<p>除了这些 redis 配置之外，通过 @CacheConfig 注解可以看到，还有 keyGenerator、cacheManager 和 cacheResolver，这些也可以通过自己实现来完成定制化。</p>\n<h2 id=\"自定义-KeyGenerator\"><a href=\"#自定义-KeyGenerator\" class=\"headerlink\" title=\"自定义 KeyGenerator\"></a>自定义 KeyGenerator</h2><p>顾名思义，keyGenerator 是用来生成 key 的，如上面例子中的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Cacheable(key = &quot;#key&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">find</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的 key 是通过 Spel 表达式从参数中获取的，当 Spel 表达式不能满足我们需求时，则可以使用自定义缓存 key 来实现，只需指定 KeyGenerator 接口的实现类的 bean 名称即可，如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyKeyGenerator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">KeyGenerator</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">generate</span><span class=\"params\">(Object target, Method method, Object... params)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> params[<span class=\"number\">0</span>] + <span class=\"string\">&quot;-glmapper&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时存储的 key 为：<code>&quot;my-prefix::myCache::glmapper-glmapper&quot;</code>。</p>\n<p>需要注意的是，keyGenerator 和 key 不能同时存在，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Cacheable(key = &quot;#key&quot;, keyGenerator = &quot;myKeyGenerator&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">find</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;execute find...&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.mockDao.find(key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果同时存在，则会抛出如下异常：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Both &#x27;key&#x27; and &#x27;keyGenerator&#x27; attributes have been set. These attributes are mutually exclusive: either set the SpEL expression used tocompute the key at runtime or set the name of the KeyGenerator bean to use.</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自定义-CachManager\"><a href=\"#自定义-CachManager\" class=\"headerlink\" title=\"自定义 CachManager\"></a>自定义 CachManager</h2><p>自定义 CacheManager 就是实现 CacheManager 接口即可，一般情况下，如果我们需要自定义 RedisConnectionFactory 和 RedisCacheConfiguration 的话，会用到自定义 CacheManager</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean(name = &quot;myCacheManager&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CacheManager <span class=\"title function_\">myCacheManager</span><span class=\"params\">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">RedisCacheConfiguration</span> <span class=\"variable\">defaultConfiguration</span> <span class=\"operator\">=</span> RedisCacheConfiguration</span><br><span class=\"line\">    .defaultCacheConfig()</span><br><span class=\"line\">    .disableCachingNullValues()</span><br><span class=\"line\">    .entryTtl(Duration</span><br><span class=\"line\">              .ofSeconds(<span class=\"number\">600L</span>))</span><br><span class=\"line\">    .serializeKeysWith(SerializationPair.fromSerializer(<span class=\"keyword\">new</span> <span class=\"title class_\">StringRedisSerializer</span>()))</span><br><span class=\"line\">    .serializeValuesWith(</span><br><span class=\"line\">    SerializationPair.fromSerializer(<span class=\"keyword\">new</span> <span class=\"title class_\">GenericJackson2JsonRedisSerializer</span>()));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> RedisCacheManager.builder(redisConnectionFactory)</span><br><span class=\"line\">    .cacheDefaults(defaultConfiguration)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>使用时，可以指定具体的 cacheManager</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Cacheable(keyGenerator = &quot;myKeyGenerator&quot;, cacheManager = &quot;myCacheManager&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">find</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;execute find...&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.mockDao.find(key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自定义CacheResolver\"><a href=\"#自定义CacheResolver\" class=\"headerlink\" title=\"自定义CacheResolver\"></a>自定义CacheResolver</h2><p>CacheResolver 是缓存解析器，默认的 Cache 解析实现类是<code>org.springframework.cache.interceptor.SimpleCacheResolver</code>，自定义 Cache 解析器需要实现CacheResolver 接口，使用方式和前面自定义 KeyGenerator 类似，即在注解属性 cacheResolver 配置自定义Bean名称。</p>\n<p>CacheResolver 解析器的目的是从 CacheOperationInvocationContext 中解析出 Cache，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyCacheResolver</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CacheResolver</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CacheManager cacheManager;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyCacheResolver</span><span class=\"params\">(CacheManager cacheManager)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.cacheManager = cacheManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Collection&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Cache</span>&gt; resolveCaches(CacheOperationInvocationContext&lt;?&gt; context) &#123;</span><br><span class=\"line\">        <span class=\"type\">Cacheable</span> <span class=\"variable\">annotation</span> <span class=\"operator\">=</span> context.getMethod().getAnnotation(Cacheable.class);</span><br><span class=\"line\">        <span class=\"type\">BasicOperation</span> <span class=\"variable\">operation</span> <span class=\"operator\">=</span> context.getOperation();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (operation <span class=\"keyword\">instanceof</span> CacheableOperation) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// do something</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Collection&lt;Cache&gt; ret = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 根据注解 或 方法得到的 cacheName 去 getCache，再返回不同的过期时间的 Cache</span></span><br><span class=\"line\">        String[] cacheNames = annotation.cacheNames();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String cacheName : cacheNames) &#123;</span><br><span class=\"line\">            ret.add(cacheManager.getCache(cacheName));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"条件缓存-condition-和-unless\"><a href=\"#条件缓存-condition-和-unless\" class=\"headerlink\" title=\"条件缓存 condition 和 unless\"></a>条件缓存 condition 和 unless</h2><p>最后再来关注下常见的条件缓存问题；有时候，一些值不适合缓存，可以使用 @Cacheable 的 condition 属性判读那些数据不缓存，它接收的是一个 Spel 表达式，该表达式的值是 true 或 false；true，数据被缓存，false不被缓存。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Cacheable(key = &quot;#key&quot;, condition = &quot;#key.startsWith(&#x27;glmapper::&#x27;)&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">find</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;execute find...&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.mockDao.find(key);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>key 必须是 <code>&quot;glmapper::&quot;</code> 开头的才允许缓存。</p>\n<p>@Cacheable#unless 一般是对结果条件判读是否进行缓存使用的，这个示例使用的是入参作为判断条件，各位可以自己写一个根据结果进行缓存的示例，切记满足条件是不缓存。Spel #result变量代表返回值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@CachePut(unless=&quot;#result == null&quot;, keyGenerator = &quot;myKeyGenerator&quot;)</span><br><span class=\"line\">public String save(String model) &#123;</span><br><span class=\"line\">    System.out.println(&quot;execute save...&quot;);</span><br><span class=\"line\">    this.mockDao.save(model, model);</span><br><span class=\"line\">    return model;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果返回结果是 null，则不缓存。</p>\n<h2 id=\"beforeInvocation-可能导致潜在的缓存不一致问题\"><a href=\"#beforeInvocation-可能导致潜在的缓存不一致问题\" class=\"headerlink\" title=\"beforeInvocation 可能导致潜在的缓存不一致问题\"></a>beforeInvocation 可能导致潜在的缓存不一致问题</h2><p>beforeInvocation 是 CacheEvict 注解的属性，默认值为false，表示在调用方法之后进行缓存清理；如果设置true，表示在调用方法之前进行缓存清理。一般情况下推荐使用默认配置即可，如果设置成 true，有两种可能导致一致性问题：</p>\n<ul>\n<li>在清理之后，执行方法执行，并发设置缓存。</li>\n<li>注解的方法本身内部如果调用了填充缓存的方法。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>整体来看，Spring Cache 的上手难度不算大，其提供的注解能够覆盖大多数使用 cache 的场景，对于业务逻辑基本无侵入性。同时，Spring 也秉持了其一贯的作风，就是提供灵活的扩展机制，使得你可以自由的定制自己的各种功能。</p>\n<p>本篇简单介绍 Spring Cache 的基本使用方式，下面将会从源码进行分析 Spring Cache 的基本工作原理 </p>\n<h2 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><p>如果你对 spring 事务模块比较熟悉的话，那么理解 Spring Cache 会简单很多，在官方文档中就有提到这个观点，Spring Cache 的实现从框架 API 抽象层面来看，和事物基本一样的，都是通过 AOP 来实现，以达到最小化业务侵入。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Similar to the <a href=\"https://docs.spring.io/spring-framework/docs/5.1.8.RELEASE/spring-framework-reference/data-access.html#transaction\">transaction</a> support, the caching abstraction allows consistent use of various caching solutions with minimal impact on the code.</p></blockquote>\n<p>本篇将从注解解析、执行拦截、方法执行过程对 Spring Cache 基本原理进行分析。</p>\n<h2 id=\"注解解析\"><a href=\"#注解解析\" class=\"headerlink\" title=\"注解解析\"></a>注解解析</h2><p>在<a href=\"https://juejin.cn/post/7067090649245286408\">1 分钟快速上手 Spring Cache</a>中，需要关注几个注解：@CacheConfig，@CachePut，@Cacheable，@CacheEvict，此外也需要关注这些注解的属性；这里我们来看下这些注解是如何被解析，如何生效的。</p>\n<h3 id=\"CacheConfig\"><a href=\"#CacheConfig\" class=\"headerlink\" title=\"@CacheConfig\"></a>@CacheConfig</h3><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>含义</th>\n<th>案例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cacheNames&#x2F;value</td>\n<td>缓存的名称</td>\n<td>例如： @CachePut(value&#x3D;”mycache”) @CachePut(cacheNames&#x3D;{”cache1”,”cache2”}</td>\n</tr>\n<tr>\n<td>keyGenerator</td>\n<td>key 生成器</td>\n<td></td>\n</tr>\n<tr>\n<td>cacheManager</td>\n<td>缓存管理器</td>\n<td></td>\n</tr>\n<tr>\n<td>cacheResolver</td>\n<td>用于拦截方法调用的缓存实例</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"CachePut\"><a href=\"#CachePut\" class=\"headerlink\" title=\"@CachePut\"></a>@CachePut</h3><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>含义</th>\n<th>案例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cacheNames&#x2F;value</td>\n<td>缓存的名称</td>\n<td>例如： @CachePut(value&#x3D;”mycache”) @CachePut(value&#x3D;{”cache1”,”cache2”}</td>\n</tr>\n<tr>\n<td>key</td>\n<td>缓存的 key</td>\n<td>例如： @CachePut(value&#x3D;”testcache”,key&#x3D;”#userName”)</td>\n</tr>\n<tr>\n<td>condition</td>\n<td>缓存的条件</td>\n<td>例如： @CachePut(value&#x3D;”testcache”,condition&#x3D;”#userName.length()&gt;2”)</td>\n</tr>\n</tbody></table>\n<h3 id=\"Cacheable\"><a href=\"#Cacheable\" class=\"headerlink\" title=\"@Cacheable\"></a>@Cacheable</h3><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>含义</th>\n<th>案例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cacheNames&#x2F;value</td>\n<td>缓存的名称</td>\n<td>每一个缓存名称代表一个缓存对象。当一个方法填写多个缓存名称时将创建多个缓存对象。当多个方法使用同一缓存名称时相同参数的缓存会被覆盖。所以通常情况我们使用“包名+类名+方法名”或者使用接口的RequestMapping作为缓存名称防止命名重复引起的问题。单缓存名称：@Cacheable(value&#x3D;”mycache”) 多缓存名称：@Cacheable(value&#x3D;{”cache1”,”cache2”}</td>\n</tr>\n<tr>\n<td>key</td>\n<td>缓存的 key</td>\n<td>key标记了缓存对象下的每一条缓存。如果不指定key则系统自动按照方法的所有入参生成key，也就是说相同的入参值将会返回同样的缓存结果。如果指定key则要按照 SpEL 表达式编写使用的入参列表。如下列无论方法存在多少个入参，只要userName值一致，则会返回相同的缓存结果。@Cacheable(value&#x3D;”testcache”,key&#x3D;”#userName”)</td>\n</tr>\n<tr>\n<td>condition</td>\n<td>缓存的条件</td>\n<td>满足条件后方法结果才会被缓存。不填写则认为无条件全部缓存。条件使用 SpEL表达式编写，返回 true 或者 false，只有为 true 才进行缓存如下例，只有用户名长度大于2时参会进行缓存 @Cacheable(value&#x3D;”testcache”,condition&#x3D;”#userName.length()&gt;2”)</td>\n</tr>\n</tbody></table>\n<h3 id=\"CacheEvict\"><a href=\"#CacheEvict\" class=\"headerlink\" title=\"@CacheEvict\"></a>@CacheEvict</h3><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>含义</th>\n<th>案例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cacheNames&#x2F;value</td>\n<td>缓存的名称</td>\n<td>删除指定名称的缓存对象。必须与下面的其中一个参数配合使用例如： @CacheEvict(value&#x3D;”mycache”) 或者 @CacheEvict(value&#x3D;{”cache1”,”cache2”}</td>\n</tr>\n<tr>\n<td>key</td>\n<td>缓存的 key</td>\n<td>删除指定key的缓存对象例如： @CacheEvict(value&#x3D;”testcache”,key&#x3D;”#userName”)</td>\n</tr>\n<tr>\n<td>condition</td>\n<td>缓存的条件</td>\n<td>删除指定条件的缓存对象例如： @CacheEvict(value&#x3D;”testcache”,condition&#x3D;”#userName.length()&gt;2”)</td>\n</tr>\n<tr>\n<td>allEntries</td>\n<td>方法执行后清空所有缓存</td>\n<td>缺省为 false，如果指定为 true，则方法调用后将立即清空所有缓存。例如： @CacheEvict(value&#x3D;”testcache”,allEntries&#x3D;true)</td>\n</tr>\n<tr>\n<td>beforeInvocation</td>\n<td>方法执行前清空所有缓存</td>\n<td>缺省为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存。例如： @CacheEvict(value&#x3D;”testcache”，beforeInvocation&#x3D;true)</td>\n</tr>\n</tbody></table>\n<h3 id=\"属性解析\"><a href=\"#属性解析\" class=\"headerlink\" title=\"属性解析\"></a>属性解析</h3><p>Spring Cache 生效需要通过 @EnableCaching 注解来开启，这种做法和在 Spring 项目中非常常见；通过 @EnableCaching ，导入 <code>CachingConfigurationSelector</code> 类，进而根据EnableCaching 的值选择应该使用 AbstractCachingConfiguration 的哪个实现。Spring Cache 对业务接口拦截有两种模式，PROXY 和 ASPECTJ，默认情况下是 PROXY。每个模式提供一个<br>Configuration，如 PROXY 对应的是 ProxyCachingConfiguration。这里已 ProxyCachingConfiguration 为例，ProxyCachingConfiguration 中会声明 BeanFactoryCacheOperationSourceAdvisor、CacheOperationSource 和 CacheInterceptor 三个 bean。其中 CacheOperationSource 会绑定一个 parser，用来解析注解。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SpringCacheAnnotationParser</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CacheAnnotationParser</span>, Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Set&lt;Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Annotation</span>&gt;&gt; CACHE_OPERATION_ANNOTATIONS = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashSet</span>&lt;&gt;(<span class=\"number\">8</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 这里即为我们前面所提到的四个注解</span></span><br><span class=\"line\">   <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">      CACHE_OPERATION_ANNOTATIONS.add(Cacheable.class);</span><br><span class=\"line\">      CACHE_OPERATION_ANNOTATIONS.add(CacheEvict.class);</span><br><span class=\"line\">      CACHE_OPERATION_ANNOTATIONS.add(CachePut.class);</span><br><span class=\"line\">      CACHE_OPERATION_ANNOTATIONS.add(Caching.class);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// ... 省略其他代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以 @CachePut 为例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> CacheOperation <span class=\"title function_\">parsePutAnnotation</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">      AnnotatedElement ae, DefaultCacheConfig defaultConfig, CachePut cachePut)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   CachePutOperation.<span class=\"type\">Builder</span> <span class=\"variable\">builder</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CachePutOperation</span>.Builder();</span><br><span class=\"line\"></span><br><span class=\"line\">   builder.setName(ae.toString());</span><br><span class=\"line\">   builder.setCacheNames(cachePut.cacheNames());</span><br><span class=\"line\">   builder.setCondition(cachePut.condition());</span><br><span class=\"line\">   builder.setUnless(cachePut.unless());</span><br><span class=\"line\">   builder.setKey(cachePut.key());</span><br><span class=\"line\">   builder.setKeyGenerator(cachePut.keyGenerator());</span><br><span class=\"line\">   builder.setCacheManager(cachePut.cacheManager());</span><br><span class=\"line\">   builder.setCacheResolver(cachePut.cacheResolver());</span><br><span class=\"line\"></span><br><span class=\"line\">   defaultConfig.applyDefault(builder);</span><br><span class=\"line\">   <span class=\"type\">CachePutOperation</span> <span class=\"variable\">op</span> <span class=\"operator\">=</span> builder.build();</span><br><span class=\"line\">   validateCacheOperation(ae, op);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> op;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每个注解解析之后会对应一个 CacheOperation；@CachePut 对应的是 CachePutOperation，CachePutOperation 主要是来描述缓存 “put” 这个操作，实际执行缓存动作的并不是这个 CachePutOperation。</p>\n<h2 id=\"执行拦截\"><a href=\"#执行拦截\" class=\"headerlink\" title=\"执行拦截\"></a>执行拦截</h2><p>所有 Spring Cache 切面入口是 CacheInterceptor 这个类</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/517bdcb96d714ebf9a65bb6cc0d19dd6~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>上图是我用例执行的一个堆栈信息，拦截到的注解是 @CachePut。CacheAspectSupport 是 CacheInterceptor 的父类，它包括了执行拦截的所有核心逻辑。有兴趣的可以自己阅读代码，不是很复杂。</p>\n<h2 id=\"方法执行\"><a href=\"#方法执行\" class=\"headerlink\" title=\"方法执行\"></a>方法执行</h2><p>拦截到方法之后就是执行具体的动作，前面提到所有的执行动作都是在 CacheAspectSupport 中，以 @CachePut 为例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 收集 @CachePuts</span></span><br><span class=\"line\">collectPutRequests(contexts.get(CachePutOperation.class), cacheValue, cachePutRequests);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 处理任何已收集的 put 请求，无论是来自 @CachePut 还是 @Cacheable</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (CachePutRequest cachePutRequest : cachePutRequests) &#123;</span><br><span class=\"line\">   cachePutRequest.apply(cacheValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>apply 中执行具体的 put 动作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">apply</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Object result)</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.context.canPutToCache(result)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (Cache cache : <span class=\"built_in\">this</span>.context.getCaches()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 将 key result ，写入到 cache 中</span></span><br><span class=\"line\">         doPut(cache, <span class=\"built_in\">this</span>.key, result);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了这些常规流程之外，Sring Cache 也提供了对于异常场景的关注，可以通过子定义 CacheErrorHandler 来完成对异常场景的处理。</p>\n<h2 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这种接口+实现分离的设计带来的好处是，我们可以做到存储平台无关，对于后续的存储迁移和替换会非常方便。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-caching.html#boot-features-caching-provider-simple\">https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-caching.html#boot-features-caching-provider-simple</a></li>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/5.1.8.RELEASE/spring-framework-reference/integration.html#cache\">https://docs.spring.io/spring-framework/docs/5.1.8.RELEASE/spring-framework-reference/integration.html#cache</a></li>\n</ul>\n","text":"如果你现在有一个现成的工程，你想给你工程的某个接口增加缓存，再不可以分布式缓存的情况下，你可以通过以下两步完成 Spring Cache 接入: 1、引用依赖 ...","permalink":"/post/spring/spring-cache-quick-start","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"spring","slug":"spring","count":15,"path":"api/categories/spring.json"}],"tags":[{"name":"spring","slug":"spring","count":11,"path":"api/tags/spring.json"},{"name":"cache","slug":"cache","count":2,"path":"api/tags/cache.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%88%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%EF%BC%89\"><span class=\"toc-text\">基本使用（默认配置）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-redis-%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">使用 redis 作为缓存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">定义缓存过期时间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89-key-%E5%89%8D%E7%BC%80\"><span class=\"toc-text\">自定义 key 前缀</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89-KeyGenerator\"><span class=\"toc-text\">自定义 KeyGenerator</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89-CachManager\"><span class=\"toc-text\">自定义 CachManager</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89CacheResolver\"><span class=\"toc-text\">自定义CacheResolver</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9D%A1%E4%BB%B6%E7%BC%93%E5%AD%98-condition-%E5%92%8C-unless\"><span class=\"toc-text\">条件缓存 condition 和 unless</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#beforeInvocation-%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E6%BD%9C%E5%9C%A8%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">beforeInvocation 可能导致潜在的缓存不一致问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">基本原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">注解解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CacheConfig\"><span class=\"toc-text\">@CacheConfig</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CachePut\"><span class=\"toc-text\">@CachePut</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Cacheable\"><span class=\"toc-text\">@Cacheable</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CacheEvict\"><span class=\"toc-text\">@CacheEvict</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%9E%E6%80%A7%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">属性解析</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C%E6%8B%A6%E6%88%AA\"><span class=\"toc-text\">执行拦截</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">方法执行</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-1\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"Spring Cloud Alibaba Nacos Config 是如何读取配置的？","uid":"e7fa060367ba032c738d6cb91dbbf7a2","slug":"springcloud/spring-cloud-config-nacos-config-locator","date":"2022-03-13T03:45:39.000Z","updated":"2024-07-05T04:09:05.836Z","comments":true,"path":"api/articles/springcloud/spring-cloud-config-nacos-config-locator.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"text":"nacos 配置最高级别的隔离是 namespace，其后是 group；如果有配置隔离的诉求，建议优先使用 namespace 进行隔离。因为对于 share...","permalink":"/post/springcloud/spring-cloud-config-nacos-config-locator","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"SpringCloud","slug":"SpringCloud","count":14,"path":"api/categories/SpringCloud.json"}],"tags":[{"name":"nacos","slug":"nacos","count":2,"path":"api/tags/nacos.json"},{"name":"config","slug":"config","count":6,"path":"api/tags/config.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"2021 年终总结-磊叔的 Work Life Balance","uid":"9bcb128fa947131484c11ffd6af6a280","slug":"share/shares-2021","date":"2021-12-27T03:40:31.000Z","updated":"2024-07-05T04:09:05.797Z","comments":true,"path":"api/articles/share/shares-2021.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"text":" 生活，在喜怒哀乐间走走停停。不知道会遇见什么，只知道阳光这么好，别辜负了今天 抓了一把花生米，开了一罐啤酒，打开新买的台式机，用上被新同事“嫌弃”声音太大的机...","permalink":"/post/share/shares-2021","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"experience","slug":"experience","count":2,"path":"api/categories/experience.json"}],"tags":[{"name":"SOFA","slug":"SOFA","count":2,"path":"api/tags/SOFA.json"},{"name":"杭州","slug":"杭州","count":1,"path":"api/tags/杭州.json"},{"name":"合肥","slug":"合肥","count":1,"path":"api/tags/合肥.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}