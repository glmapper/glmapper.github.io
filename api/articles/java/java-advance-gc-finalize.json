{"title":"finalize 方法重写对 GC 的影响分析","uid":"47efb9065838ed77b0a81f4071199b1e","slug":"java/java-advance-gc-finalize","date":"2021-11-02T03:17:56.000Z","updated":"2024-07-05T04:09:05.761Z","comments":true,"path":"api/articles/java/java-advance-gc-finalize.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"content":"<p>关于 Object 的 finalize 方法，在日常开发中可能有超过 99% 的人都没有关注过，因为业务开发很少有重写 finalize 方法的场景；开发者对于 finalize 的认知大多在是“面试八股文”中，而且也不乏见到将 finalize、finally 以及 final 放在一块比较的 case，面试官可能是出于对初学者 java 基本语言知识的考量，但是这真的有意义吗？</p>\n<span id=\"more\"></span>\n\n\n<p>本文将用一个非常简单的 case 来直观的看下，finalize 方法重写带来的影响。</p>\n<h2 id=\"finalize-方法是什么\"><a href=\"#finalize-方法是什么\" class=\"headerlink\" title=\"finalize 方法是什么\"></a>finalize 方法是什么</h2><p>下面我们直接来看下 finalize 的代码注释。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* Called by the garbage collector on an object when garbage collection</span><br><span class=\"line\">* determines that there are no more references to the object.</span><br><span class=\"line\">* A subclass overrides the &#123;@code finalize&#125; method to dispose of</span><br><span class=\"line\">* system resources or to perform other cleanup.</span><br></pre></td></tr></table></figure>\n\n<p>finalize 是 java 的顶级父类 Object 中的一些方法，默认情况下 finalize 方法是空实现；其调时机是：当前对象没有任何引用时，执行 GC 时被调用。子类可以重写了 finalize 方法去释放系统资源或执行其他清理。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* The general contract of &#123;@code finalize&#125; is that it is invoked</span><br><span class=\"line\">* if and when the Java&amp;trade; virtual</span><br><span class=\"line\">* machine has determined that there is no longer any</span><br><span class=\"line\">* means by which this object can be accessed by any thread that has</span><br><span class=\"line\">* not yet died, except as a result of an action taken by the</span><br><span class=\"line\">* finalization of some other object or class which is ready to be</span><br><span class=\"line\">* finalized. The &#123;@code finalize&#125; method may take any action, including</span><br><span class=\"line\">* making this object available again to other threads; the usual purpose</span><br><span class=\"line\">* of &#123;@code finalize&#125;, however, is to perform cleanup actions before</span><br><span class=\"line\">* the object is irrevocably discarded. For example, the finalize method</span><br><span class=\"line\">* for an object that represents an input/output connection might perform</span><br><span class=\"line\">* explicit I/O transactions to break the connection before the object is</span><br><span class=\"line\">* permanently discarded.</span><br></pre></td></tr></table></figure>\n\n<p>finalizer 方法的调用时机由 JavaTM 开发商决定：简单说就是要确定对象的任何方法都不（再）会被调用时，再调用其 finalize 方法。除非一些其他的已经准备好被终止的对象或类将调用 finalize 方法，包括在其终止动作之中（即调用对象的 finalize 方法，此时该对象的 finalize 方法将是最后被调用的方法，在这之后，对象的任何方法都不（再）会被调用。finalize 方法中可以执行任何操作，包括再次使该对象可用于其它线程（重新初始化）；但是 finalize 的通常目的是在对象（一定）不再被需要时（对象将被丢弃）之前执行清除操作。例如，表示input&#x2F;output 连接的对象的 finalize 方法可能会在对象被永久丢弃之前执行显式 I&#x2F;O 事务来中断连接。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* The Java programming language does not guarantee which thread will</span><br><span class=\"line\">* invoke the &#123;@code finalize&#125; method for any given object. It is</span><br><span class=\"line\">* guaranteed, however, that the thread that invokes finalize will not</span><br><span class=\"line\">* be holding any user-visible synchronization locks when finalize is</span><br><span class=\"line\">* invoked. If an uncaught exception is thrown by the finalize method,</span><br><span class=\"line\">* the exception is ignored and finalization of that object terminates.</span><br></pre></td></tr></table></figure>\n\n<p>java 语言不对任何对象的 finalize 方法调用发生的线程做限制，即任何线程都可以调用对象的 finalize 方法，然而，调用 finalize 方法的线程将不能持有任何用户可见的线程同步锁。当 finalize 方法被调用时，如果 finalize 方法抛出异常，且异常未被捕获时，异常将被忽略，finalize 方法将中止。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* After the &#123;@code finalize&#125; method has been invoked for an object, no</span><br><span class=\"line\">* further action is taken until the Java virtual machine has again</span><br><span class=\"line\">* determined that there is no longer any means by which this object can</span><br><span class=\"line\">* be accessed by any thread that has not yet died, including possible</span><br><span class=\"line\">* actions by other objects or classes which are ready to be finalized,</span><br><span class=\"line\">* at which point the object may be discarded.</span><br></pre></td></tr></table></figure>\n\n<p>当对象的 finalize 方法被调用后，不会再有基于该对象的方法调用，直到 JVM 再次进行回收动作时该对象将被释放，占用的内存将被回收。</p>\n<p>另外，任何对象的 finalize 方法只会被 JVM 调用一次。finalize（）方法引发的任何异常都会导致该对象的终止被暂停，否则被忽略。</p>\n<h2 id=\"finalize-方法重写对-GC-的影响\"><a href=\"#finalize-方法重写对-GC-的影响\" class=\"headerlink\" title=\"finalize 方法重写对 GC 的影响\"></a>finalize 方法重写对 GC 的影响</h2><p>这里丢一个简单的例子，TestMain 类重写了 finalize 方法，并且在 finalize 方法中已创建的对象总数 COUNT 做减操作，并且没隔 100000 次输出下当前 COUNT。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestMain</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">AtomicInteger</span> <span class=\"variable\">COUNT</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">TestMain</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        COUNT.incrementAndGet();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 重写 finalize 方法测试</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Throwable</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        COUNT.decrementAndGet();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String args[])</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span> ;; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">TestMain</span> <span class=\"variable\">item</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TestMain</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((i % <span class=\"number\">100000</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                System.out.format(<span class=\"string\">&quot;creating %d objects, current %d are alive.%n&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[] &#123;i, COUNT.get() &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行环境：MacOS 10.14.6</p>\n<p>JVM 参数：-XX:+PrintGCDetails -Xms200M -Xmx200M -Xmn100M</p>\n<p>执行这段代码，可以在控制台观察，会出现以下几个阶段:</p>\n<h3 id=\"阶段一：第一次执行-GC-的时候\"><a href=\"#阶段一：第一次执行-GC-的时候\" class=\"headerlink\" title=\"阶段一：第一次执行 GC 的时候\"></a>阶段一：第一次执行 GC 的时候</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">creating 0 objects, current 1 are alive.</span><br><span class=\"line\">creating 100000 objects, current 100001 are alive.</span><br><span class=\"line\">creating 200000 objects, current 200001 are alive.</span><br><span class=\"line\">creating 300000 objects, current 300001 are alive.</span><br><span class=\"line\">creating 400000 objects, current 400001 are alive.</span><br><span class=\"line\">creating 500000 objects, current 500001 are alive.</span><br><span class=\"line\">creating 600000 objects, current 600001 are alive.</span><br><span class=\"line\">creating 700000 objects, current 700001 are alive.</span><br><span class=\"line\">creating 800000 objects, current 800001 are alive.</span><br><span class=\"line\">creating 900000 objects, current 900001 are alive.</span><br><span class=\"line\">creating 1000000 objects, current 1000001 are alive.</span><br><span class=\"line\">creating 1100000 objects, current 1100001 are alive.</span><br><span class=\"line\">creating 1200000 objects, current 1200001 are alive.</span><br><span class=\"line\">// ygc 失败，下面直接进行 fgc 了</span><br><span class=\"line\">[GC (Allocation Failure) [PSYoungGen: 76800K-&gt;12800K(89600K)] 76800K-&gt;71066K(192000K), 0.3839994 secs] [Times: user=1.87 sys=0.07, real=0.38 secs] </span><br><span class=\"line\">// 执行 fgc</span><br><span class=\"line\">[Full GC (Ergonomics) [PSYoungGen: 12800K-&gt;0K(89600K)] [ParOldGen: 58266K-&gt;70801K(102400K)] 71066K-&gt;70801K(192000K), [Metaspace: 3696K-&gt;3696K(1056768K)], 1.3266229 secs] [Times: user=4.89 sys=0.17, real=1.33 secs]</span><br><span class=\"line\">creating 1300000 objects, current 1296221 are alive.</span><br></pre></td></tr></table></figure>\n\n<p>看下 GC 之后，COUNT 中统计的存活的对象数还是有很多。</p>\n<h3 id=\"阶段二：频繁-fgc\"><a href=\"#阶段二：频繁-fgc\" class=\"headerlink\" title=\"阶段二：频繁 fgc\"></a>阶段二：频繁 fgc</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">creating 3200000 objects, current 3132405 are alive.</span><br><span class=\"line\">creating 3300000 objects, current 3230808 are alive.</span><br><span class=\"line\">[Full GC (Ergonomics) [PSYoungGen: 76800K-&gt;75818K(89600K)] [ParOldGen: 102171K-&gt;102028K(102400K)] 178971K-&gt;177846K(192000K), [Metaspace: 3716K-&gt;3716K(1056768K)], 0.8383374 secs] [Times: user=4.93 sys=0.09, real=0.84 secs] </span><br><span class=\"line\">[Full GC (Ergonomics) [PSYoungGen: 76800K-&gt;76768K(89600K)] [ParOldGen: 102028K-&gt;102028K(102400K)] 178828K-&gt;178797K(192000K), [Metaspace: 3716K-&gt;3716K(1056768K)], 0.3276008 secs] [Times: user=2.24 sys=0.01, real=0.33 secs] </span><br><span class=\"line\">[Full GC (Ergonomics) [PSYoungGen: 76800K-&gt;76784K(89600K)] [ParOldGen: 102028K-&gt;102028K(102400K)] 178828K-&gt;178813K(192000K), [Metaspace: 3716K-&gt;3716K(1056768K)], 0.2876044 secs] [Times: user=1.74 sys=0.03, real=0.29 secs] </span><br><span class=\"line\">[Full GC (Ergonomics) [PSYoungGen: 76800K-&gt;76775K(89600K)] [ParOldGen: 102028K-&gt;102028K(102400K)] 178828K-&gt;178803K(192000K), [Metaspace: 3716K-&gt;3716K(1056768K)], 0.2761930 secs] [Times: user=1.74 sys=0.02, real=0.28 secs] </span><br><span class=\"line\">[Full GC (Ergonomics) [PSYoungGen: 76800K-&gt;76778K(89600K)] [ParOldGen: 102028K-&gt;102028K(102400K)] 178828K-&gt;178806K(192000K), [Metaspace: 3716K-&gt;3716K(1056768K)], 0.3522859 secs] [Times: user=1.67 sys=0.02, real=0.35 secs] </span><br><span class=\"line\">[Full GC (Ergonomics) [PSYoungGen: 76800K-&gt;76786K(89600K)] [ParOldGen: 102028K-&gt;102028K(102400K)] 178828K-&gt;178814K(192000K), [Metaspace: 3716K-&gt;3716K(1056768K)], 0.2609472 secs] [Times: user=1.36 sys=0.02, real=0.26 secs] </span><br><span class=\"line\">[Full GC (Ergonomics) [PSYoungGen: 76800K-&gt;76793K(89600K)] [ParOldGen: 102028K-&gt;102028K(102400K)] 178828K-&gt;178821K(192000K), [Metaspace: 3716K-&gt;3716K(1056768K)], 0.2691448 secs] [Times: user=1.28 sys=0.01, real=0.27 secs] </span><br><span class=\"line\">[Full GC (Ergonomics) [PSYoungGen: 76800K-&gt;76787K(89600K)] [ParOldGen: 102028K-&gt;102028K(102400K)] 178828K-&gt;178816K(192000K), [Metaspace: 3716K-&gt;3716K(1056768K)], 0.2254074 secs] [Times: user=1.37 sys=0.01, real=0.22 secs] </span><br><span class=\"line\">[Full GC (Ergonomics) [PSYoungGen: 76800K-&gt;76779K(89600K)] [ParOldGen: 102028K-&gt;102028K(102400K)] 178828K-&gt;178808K(192000K), [Metaspace: 3716K-&gt;3716K(1056768K)], 0.2670959 secs] [Times: user=1.77 sys=0.02, real=0.27 secs] </span><br><span class=\"line\">[Full GC (Ergonomics) [PSYoungGen: 76800K-&gt;76778K(89600K)] [ParOldGen: 102028K-&gt;102028K(102400K)] 178828K-&gt;178807K(192000K), [Metaspace: 3716K-&gt;3716K(1056768K)], 0.2704234 secs] [Times: user=1.71 sys=0.02, real=0.27 secs] </span><br><span class=\"line\">[Full GC (Ergonomics) [PSYoungGen: 76800K-&gt;76785K(89600K)] [ParOldGen: 102028K-&gt;102028K(102400K)] 178828K-&gt;178813K(192000K), [Metaspace: 3716K-&gt;3716K(1056768K)], 0.3302090 secs] [Times: user=1.84 sys=0.02, real=0.33 secs] </span><br></pre></td></tr></table></figure>\n\n<p>差不多在 330 万次时，就开始持续有 fgc 的情况了；可以看到各个数据区都被占满了。</p>\n<h3 id=\"阶段三：OOM\"><a href=\"#阶段三：OOM\" class=\"headerlink\" title=\"阶段三：OOM\"></a>阶段三：OOM</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Full GC (Ergonomics) [PSYoungGen: 76800K-&gt;76784K(89600K)] [ParOldGen: 102028K-&gt;101994K(102400K)] 178828K-&gt;178778K(192000K), [Metaspace: 3716K-&gt;3716K(1056768K)], 0.4323213 secs] [Times: user=2.13 sys=0.04, real=0.43 secs] </span><br><span class=\"line\">[Full GC (Ergonomics) Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class=\"line\">[PSYoungGen: 76799K-&gt;76697K(89600K)] [ParOldGen: 101994K-&gt;101994K(102400K)] 178793K-&gt;178691K(192000K), [Metaspace: 3720K-&gt;3720K(1056768K)], 0.3325707 secs] [Times: user=1.70 sys=0.02, real=0.33 secs] </span><br><span class=\"line\">Heap</span><br><span class=\"line\"> PSYoungGen      total 89600K, used 76800K [0x00000007b9c00000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class=\"line\">  eden space 76800K, 100% used [0x00000007b9c00000,0x00000007be700000,0x00000007be700000)</span><br><span class=\"line\">  from space 12800K, 0% used [0x00000007be700000,0x00000007be700000,0x00000007bf380000)</span><br><span class=\"line\">  to   space 12800K, 0% used [0x00000007bf380000,0x00000007bf380000,0x00000007c0000000)</span><br><span class=\"line\"> ParOldGen       total 102400K, used 101994K [0x00000007b3800000, 0x00000007b9c00000, 0x00000007b9c00000)</span><br><span class=\"line\">  object space 102400K, 99% used [0x00000007b3800000,0x00000007b9b9a8e0,0x00000007b9c00000)</span><br><span class=\"line\"> Metaspace       used 3751K, capacity 4670K, committed 4864K, reserved 1056768K</span><br><span class=\"line\">  class space    used 404K, capacity 434K, committed 512K, reserved 1048576K</span><br><span class=\"line\">\tat java.lang.ref.Finalizer.register(Finalizer.java:87)</span><br><span class=\"line\">\tat java.lang.Object.&lt;init&gt;(Object.java:37)</span><br><span class=\"line\">\tat com.glmapper.bridge.boot.finalize.TestMain.&lt;init&gt;(TestMain.java:13)</span><br><span class=\"line\">\tat com.glmapper.bridge.boot.finalize.TestMain.main(TestMain.java:28)</span><br></pre></td></tr></table></figure>\n\n<p>在创建了 330 万个对象后就抛出 java.lang.OutOfMemoryError: GC overhead limitt exceeded 异常退出了。从我工程测试日志中看到，基本全都都是 fgc（只有一次 ygc），从代码看，这些对象并没有什么特殊，代码层面也没有引用，但是 JVM 就直接使用代价更高的 Full GC 来清理老生代和持久代的空间了。所以 why ?</p>\n<p>那作为对比，我们把代码中重写 finalize 的代码逻辑去掉再跑一次：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">creating 111000000 objects </span><br><span class=\"line\">[GC (Allocation Failure) [PSYoungGen: 99328K-&gt;0K(100864K)] 100161K-&gt;833K(203264K), 0.0008235 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class=\"line\">creating 112000000 objects </span><br><span class=\"line\">creating 113000000 objects </span><br><span class=\"line\">creating 114000000 objects </span><br><span class=\"line\">creating 115000000 objects </span><br><span class=\"line\">creating 116000000 objects </span><br><span class=\"line\">creating 117000000 objects </span><br><span class=\"line\">[GC (Allocation Failure) [PSYoungGen: 99328K-&gt;0K(100864K)] 100161K-&gt;833K(203264K), 0.0005181 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class=\"line\">creating 118000000 objects </span><br><span class=\"line\">creating 119000000 objects </span><br><span class=\"line\">creating 120000000 objects </span><br><span class=\"line\">creating 121000000 objects </span><br><span class=\"line\">creating 122000000 objects </span><br><span class=\"line\">creating 123000000 objects </span><br><span class=\"line\">creating 124000000 objects </span><br><span class=\"line\">[GC (Allocation Failure) [PSYoungGen: 99328K-&gt;0K(100864K)] 100161K-&gt;833K(203264K), 0.0004161 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class=\"line\">creating 125000000 objects </span><br><span class=\"line\">creating 126000000 objects </span><br><span class=\"line\">creating 127000000 objects </span><br><span class=\"line\">creating 128000000 objects </span><br><span class=\"line\">creating 129000000 objects </span><br><span class=\"line\">creating 130000000 objects </span><br><span class=\"line\">[GC (Allocation Failure) [PSYoungGen: 99328K-&gt;32K(101376K)] 100161K-&gt;865K(203776K), 0.0004908 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class=\"line\">creating 131000000 objects </span><br><span class=\"line\">creating 132000000 objects </span><br><span class=\"line\">creating 133000000 objects </span><br><span class=\"line\">creating 134000000 objects </span><br><span class=\"line\">creating 135000000 objects </span><br><span class=\"line\">creating 136000000 objects</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，在创建 13600 万对象时仍然可以继续跑，并且通过 GC 日志看，也只有 ygc , 没有一次 fgc。所以这个和重写 finalize 时的差距还是非常大的。那么下面就来分析下具体原因。</p>\n<h2 id=\"GC-影响分析\"><a href=\"#GC-影响分析\" class=\"headerlink\" title=\"GC 影响分析\"></a>GC 影响分析</h2><p>这里思路很简单，首先我们要知道是什么对象导致了 OOM，要找出来。</p>\n<h3 id=\"找到占用空间的元凶\"><a href=\"#找到占用空间的元凶\" class=\"headerlink\" title=\"找到占用空间的元凶\"></a>找到占用空间的元凶</h3><p>在启动参数中加上 -XX:+HeapDumpOnOutOfMemoryError 参数，重新执行一次，在出现 OOM 时会执行一次 heap dump</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class=\"line\">Dumping heap to java_pid88685.hprof ...</span><br><span class=\"line\">Heap dump file created [320504328 bytes in 3.050 secs]</span><br></pre></td></tr></table></figure>\n\n<p>通过分析工具（我使用的是 Jprofile 2）,看到都是 Finalizer 这个类的对象实例</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/367ff72d7c504747be0173841e1d4cab~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>在我的测试代码中，非常明确没有创建 Finalizer 对象的逻辑，那为什么会有这么多 Finalizer 对象实例呢？其实从上面 OOM 堆栈那里已经可以看出些端倪了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class space    used 404K, capacity 434K, committed 512K, reserved 1048576K</span><br><span class=\"line\">\tat java.lang.ref.Finalizer.register(Finalizer.java:87)</span><br><span class=\"line\">    at java.lang.Object.&lt;init&gt;(Object.java:37)</span><br><span class=\"line\">    at com.glmapper.bridge.boot.finalize.TestMain.&lt;init&gt;(TestMain.java:13)</span><br><span class=\"line\">    at com.glmapper.bridge.boot.finalize.TestMain.main(TestMain.java:28)</span><br></pre></td></tr></table></figure>\n\n<p>在堆栈中看到了 Finalizer.register 这样一个方法执行，把断点打在这里：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bea36e8c1604a7b90a39968b38185b2~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>对于重写 finalize 方法的类，在创建其实例时，会同时创建一个 Finalizer 实例，这些所有的 Finalizer 实例又会为 Finalizer 类所引用，由于存在这么一个引用链关系存在，所以整个的这些对象都是存活的；所以当 Eden 区满了之后，此时所有的对象还是存活的，所以并不会被回收掉，继而只能将他们进一步放到 Suvivor 区去，但是由于这些对象不会被释放，引用一直存在，所以 Suvivor 区也很快被占满，既然这些对象被放到老年代，直到存入元数据空间，最后 OOM；所以前面提到的，不是 JVM 不使用 ygc ，而是基于既定规则下，ygc 并不能将这些存活的对象回收掉。关于引用链通过 Jprofile 也可以直观的得到结论</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/151002a959944a4a9aa11816da88bf18~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<h3 id=\"如何被回收的？\"><a href=\"#如何被回收的？\" class=\"headerlink\" title=\"如何被回收的？\"></a>如何被回收的？</h3><p>那是不是就一直没法被回收呢？其实也不是，我们看到在执行了 fgc 之后，还是有一些对象被回收掉的。那就是说，这些被引用的对象，还是有可能被释放的；那其实就看这个对象什么时候从下面这个队列中被弹出。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static ReferenceQueue&lt;Object&gt; queue = new ReferenceQueue&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>被弹出的对象在下一次 GC 的时候就会被认为已经没有任何引用从而被回收掉。</p>\n<h3 id=\"Finalizer-线程-FinalizerThread\"><a href=\"#Finalizer-线程-FinalizerThread\" class=\"headerlink\" title=\"Finalizer 线程: FinalizerThread\"></a>Finalizer 线程: FinalizerThread</h3><p>FinalizerThread 的职责非常简单，就是不停的循环等待 ReferenceQueue 中的新增对象，然后弹出这个对象，调用它的 finalize() 方法，将该引用从 Finalizer 类中移除，因此下次 GC 再执行的时候，这个 Finalizer 实例以及它引用的那个对象就可以回垃圾回收掉了。</p>\n<p>finalize() 方法的调用会比你创建新对象要早得多，因此大多数时候，Finalizer 线程能够赶在下次 GC 带来更多的 Finalizer 对象前清空这个队列。</p>\n<p>既然如此，那为什么会出现 OOM 呢？因为 Finalizer 线程和主线程相比它的优先级要低。这意味着分配给它的CPU 时间更少，因此它的处理速度没法赶上新对象创建的速度。这就是问题的根源——对象创建的速度要比Finalizer 线程调用 finalize() 结束它们的速度要快，这导致最后堆中所有可用的空间都被耗尽了，结果就出现了 OOM 这种情况。（PS: 案例代码在一直循环创建新的对象）</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过上面的 case 和分析，可以知道，对于重写了 finalize 的类，其对象的生命周期和普通对象的生命周期是完全不一样的。对于重写了 finalize 的类，其生命周期大致如下：</p>\n<ul>\n<li>JVM 创建 TestMain 对象</li>\n<li>JVM 创建一个 Finalizer 对象，指向 TestMain 对象</li>\n</ul>\n<!---->\n\n<ul>\n<li>Finalizer 类持有新创建的 Finalizer 的实例，使得下一次新生代 GC 无法回收这些对象</li>\n<li>新生代 GC 无法清空 Eden 区（引用被持有了），因此会将这些对象移到 Survivor 区或者老生代</li>\n</ul>\n<!---->\n\n<ul>\n<li>垃圾回收器发现这些对象实现了finalize() 方法，因为会把它们添加到 ReferenceQueue 队列中</li>\n<li>FinalizerThread 处理 ReferenceQueue 队列，将里面的对象逐个弹出，并调用它们的 finalize() 方法</li>\n</ul>\n<!---->\n\n<ul>\n<li>finalize() 方法调用完后，FinalizerThread 会将引用从 Finalizer 类中去掉，因此在下一轮 GC 中，这些对象就可以被回收了</li>\n</ul>\n<p>所以，如果你有使用 finalize() 方法的情况，如果不是使用常规的方式来清理对象的话，最好是多考虑一下。</p>\n","text":"关于 Object 的 finalize 方法，在日常开发中可能有超过 99% 的人都没有关注过，因为业务开发很少有重写 finalize 方法的场景；开发者对...","permalink":"/post/java/java-advance-gc-finalize","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[{"name":"SOFA","slug":"SOFA","count":9,"path":"api/categories/SOFA.json"}],"tags":[{"name":"gc","slug":"gc","count":3,"path":"api/tags/gc.json"},{"name":"ClassLoader","slug":"ClassLoader","count":4,"path":"api/tags/ClassLoader.json"},{"name":"SOFAArk","slug":"SOFAArk","count":4,"path":"api/tags/SOFAArk.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#finalize-%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">finalize 方法是什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#finalize-%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E5%AF%B9-GC-%E7%9A%84%E5%BD%B1%E5%93%8D\"><span class=\"toc-text\">finalize 方法重写对 GC 的影响</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%A7%E8%A1%8C-GC-%E7%9A%84%E6%97%B6%E5%80%99\"><span class=\"toc-text\">阶段一：第一次执行 GC 的时候</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%98%B6%E6%AE%B5%E4%BA%8C%EF%BC%9A%E9%A2%91%E7%B9%81-fgc\"><span class=\"toc-text\">阶段二：频繁 fgc</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%9AOOM\"><span class=\"toc-text\">阶段三：OOM</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#GC-%E5%BD%B1%E5%93%8D%E5%88%86%E6%9E%90\"><span class=\"toc-text\">GC 影响分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%BE%E5%88%B0%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%85%83%E5%87%B6\"><span class=\"toc-text\">找到占用空间的元凶</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E8%A2%AB%E5%9B%9E%E6%94%B6%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">如何被回收的？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Finalizer-%E7%BA%BF%E7%A8%8B-FinalizerThread\"><span class=\"toc-text\">Finalizer 线程: FinalizerThread</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"JVM-Java 对象模型","uid":"29ce492a4d6518491078a1705c4387c8","slug":"jvm/jvm-openjdk-oop-klass","date":"2021-11-05T03:23:39.000Z","updated":"2024-07-05T04:09:05.769Z","comments":true,"path":"api/articles/jvm/jvm-openjdk-oop-klass.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"text":"Java对象保存在堆内存中。在内存中，一个Java对象包含三部分：对象头、实例数据和对齐填充。其中对象头是一个很关键的部分，因为对象头中包含锁状态标志、线程持有...","permalink":"/post/jvm/jvm-openjdk-oop-klass","photos":[],"count_time":{"symbolsCount":"7.5k","symbolsTime":"7 mins."},"categories":[{"name":"jvm","slug":"jvm","count":6,"path":"api/categories/jvm.json"}],"tags":[{"name":"jvm","slug":"jvm","count":6,"path":"api/tags/jvm.json"},{"name":"oop-klass","slug":"oop-klass","count":1,"path":"api/tags/oop-klass.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"log4j2 日志 PatternLayout 配置对 SOFAArk PluginClassLoader 的影响","uid":"d159ca8c012acf521f858fbe565b5e98","slug":"sofa/sofa-ark-plugin-classloader-log4j","date":"2021-11-01T03:10:19.000Z","updated":"2024-07-05T04:09:05.800Z","comments":true,"path":"api/articles/sofa/sofa-ark-plugin-classloader-log4j.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"text":"log4j2 相关类在 sofaark 插件中是导出的，因此当出现 log4j2 的类需要被加载时，会委托给 PluginClassLoader 进行加载。 背...","permalink":"/post/sofa/sofa-ark-plugin-classloader-log4j","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[{"name":"SOFA","slug":"SOFA","count":9,"path":"api/categories/SOFA.json"}],"tags":[{"name":"gc","slug":"gc","count":3,"path":"api/tags/gc.json"},{"name":"ClassLoader","slug":"ClassLoader","count":4,"path":"api/tags/ClassLoader.json"},{"name":"SOFAArk","slug":"SOFAArk","count":4,"path":"api/tags/SOFAArk.json"},{"name":"log","slug":"log","count":5,"path":"api/tags/log.json"},{"name":"类加载","slug":"类加载","count":2,"path":"api/tags/类加载.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}