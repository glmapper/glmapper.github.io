{"title":"响应式编程 Reactor","uid":"df38c18caf16ba3a0d7fecc5c412ad01","slug":"java/java-base-reactor-intro","date":"2019-08-24T10:48:19.000Z","updated":"2024-07-05T04:09:05.764Z","comments":true,"path":"api/articles/java/java-base-reactor-intro.json","keywords":null,"cover":[],"content":"<h2 id=\"从响应式编程说起\"><a href=\"#从响应式编程说起\" class=\"headerlink\" title=\"从响应式编程说起\"></a>从响应式编程说起</h2><p>响应式编程是一种关注于数据流（data streams）和变化传递（propagation of change）的异步编程方式。 这意味着它可以用既有的编程语言表达静态（如数组）或动态（如事件源）的数据流。</p>\n<p>在响应式编程方面，微软跨出了第一步，它在 .NET 生态中创建了响应式扩展库（Reactive Extensions library, Rx）。接着 RxJava 在 JVM 上实现了响应式编程。后来，在 JVM 平台出现了一套标准的响应式 编程规范，它定义了一系列标准接口和交互规范。并整合到 Java 9 中（Flow 类）。</p>\n<span id=\"more\"></span>\n\n<p>响应式编程通常作为面向对象编程中的“观察者模式”（Observer design pattern）的一种扩展。 响应式流（reactive streams）与“迭代子模式”（Iterator design pattern）也有相通之处， 因为其中也有 Iterable-Iterator 这样的对应关系。主要的区别在于，Iterator 是基于 “拉取”（pull）方式的，而响应式流是基于“推送”（push）方式的。</p>\n<ul>\n<li>iterator 是一种“命令式”（imperative）编程范式，即使访问元素的方法是 Iterable 的唯一职责。关键在于，什么时候执行 next() 获取元素取决于开发者。</li>\n<li>响应式流中，相对应的角色是 Publisher-Subscriber，但是当有新的值到来的时候 ，却反过来由发布者（Publisher） 通知订阅者（Subscriber），这种“推送”模式是响应式的关键</li>\n</ul>\n<p>此外，对推送来的数据的操作是通过一种声明式（declaratively）而不是命令式（imperatively）的方式表达的：开发者通过描述“控制流程”来定义对数据流的处理逻辑。</p>\n<p>除了数据推送，对错误处理（error handling）和完成（completion）信号的定义也很完善。一个 Publisher 可以推送新的值到它的 Subscriber（调用 onNext 方法）， 同样也可以推送错误（调用 onError 方法）和完成（调用 onComplete 方法）信号。 错误和完成信号都可以终止响应式流。可以用下边的表达式描述：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onNext x <span class=\"number\">0.</span>.N [onError | onComplete]</span><br></pre></td></tr></table></figure>\n\n<p>这种方式非常灵活，无论是有&#x2F;没有值，还是 n 个值（包括有无限个值的流，比如时钟的持续读秒），都可处理。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>以上来自 <a href=\"https://projectreactor.io/docs/core/release/reference/\">https://projectreactor.io/docs/core/release/reference/</a> 翻译</p></blockquote>\n<h2 id=\"Reactive-Streams\"><a href=\"#Reactive-Streams\" class=\"headerlink\" title=\"Reactive Streams\"></a>Reactive Streams</h2><p>Reactive Streams 是上面提到的一套标准的响应式编程规范。它由四个核心概念构成：</p>\n<ul>\n<li>消息发布者：只有一个 subscribe 接口，是订阅者调用的，用来订阅发布者的消息。发布者在订阅者调用 request 之后把消息 push 给订阅者。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Publisher</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">subscribe</span><span class=\"params\">(Subscriber&lt;? <span class=\"built_in\">super</span> T&gt; s)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>订阅者：订阅者包括四个接口，这些接口都由 Publisher 触发调用的。onSubscribe 告诉订阅者订阅成功，并返回了一个 Subscription ；通过 Subscription 订阅者可以告诉发布者发送指定数量的消息（request 完成） ；onNext 是发布者有消息时，调用订阅者这个接口来达到发布消息的目的；onError 通知订阅者，发布者出现了错误；onComplete 通知订阅者消息发送完毕。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Subscriber</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onSubscribe</span><span class=\"params\">(Subscription s)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onNext</span><span class=\"params\">(T t)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onError</span><span class=\"params\">(Throwable t)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onComplete</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>订阅：包括两个接口，请求 n 个消息和取消此次订阅。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Subscription</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// request(n)用来发起请求数据,其中n表示请求数据的数量,它必须大于0,</span></span><br><span class=\"line\">    <span class=\"comment\">// 否则会抛出IllegalArgumentException,并触发onError,request的调用会</span></span><br><span class=\"line\">    <span class=\"comment\">// 累加,如果没有终止,最后会触发相应次数的onNext方法.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request</span><span class=\"params\">(<span class=\"type\">long</span> n)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cancel相当于取消订阅,调用之后,后续不会再收到订阅,onError 和 </span></span><br><span class=\"line\">    <span class=\"comment\">// onComplete也不会被触发</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">cancel</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>处理器：Processor 同时继承了 Subscriber 和 Publisher；其代表一个处理阶段。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Processor</span>&lt;T, R&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">Subscriber</span>&lt;T&gt;, Publisher&lt;R&gt; &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>Reactive Streams 通过上面的四个核心概念和相关的函数，对响应式流进行了一个框架性的约定，它没有具体实现。简单来说，它只提供通用的、合适的解决方案，大家都按照这个规约来实现就好了。</p>\n<p>Java 的 Reactive Programming 类库主要有三个，分别是 Akka-Streams ，RxJava 和 Project Reactor。Spring 5 开始支持 Reactive Programming，其底层使用的是 Project Reactor。本篇主要是对 Project Reactor 中的一些点进行学习总结。</p>\n<h2 id=\"Project-Reactor\"><a href=\"#Project-Reactor\" class=\"headerlink\" title=\"Project Reactor\"></a>Project Reactor</h2><p>Project Reactor 是一个基于 Java 8 的实现了响应式流规范 （Reactive Streams specification）的响应式库。</p>\n<p>Reactor 引入了实现 Publisher 的响应式类 Flux 和 Mono，以及丰富的操作方式。 一个 Flux 对象代表一个包含 0..N 个元素的响应式序列，而一个 Mono 对象代表一个包含零或者一个（0..1）元素的结果。</p>\n<h3 id=\"Flux-和-Mono\"><a href=\"#Flux-和-Mono\" class=\"headerlink\" title=\"Flux 和 Mono\"></a>Flux 和 Mono</h3><p>Flux 是生产者，即我们上面提到的 Publisher，它代表的是一个包含 0-N 个元素的异步序列，Mono可以看做 Flux 的有一个特例，代表 0-1 个元素，如果不需要生产任何元素，只是需要一个完成任务的信号，可以使用 Mono。</p>\n<h4 id=\"Flux-包含-0-N-个元素的异步序列\"><a href=\"#Flux-包含-0-N-个元素的异步序列\" class=\"headerlink\" title=\"Flux-包含 0-N 个元素的异步序列\"></a>Flux-包含 0-N 个元素的异步序列</h4><p><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/reactor/reactor-flux.jpg\" alt=\"Flux\"></p>\n<p>先来看这张图，这里是直接从官方文档上贴过来的。就这张图做下说明，先来关注几个点：</p>\n<ul>\n<li>从左到右的时间序列轴</li>\n<li>1-6 为 Flux enitted（发射）的元素</li>\n<li>上面 6 后面的竖线标识已经成功完成了</li>\n<li>下面的 1-3 表示转换的结果</li>\n<li>❌  表示出现了error，对应的是执行了onError</li>\n<li>operator : 操作符，声明式的可组装的响应式方法，其组装成的链称为“操作链”</li>\n</ul>\n<p>那整体来看就是 Flux 产生元数据，通过一系列 operator 操作得到转换结果，正常成功就是 onCompleted，出现错误就是 onError。看下面的一个小例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Flux.just(<span class=\"string\">&quot;glmapper&quot;</span>,<span class=\"string\">&quot;leishu&quot;</span>).subscribe(<span class=\"keyword\">new</span> <span class=\"title class_\">Subscriber</span>&lt;String&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onSubscribe</span><span class=\"params\">(Subscription subscription)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// subscription 表示订阅关系</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;onSubscribe,&quot;</span>+ subscription.getClass());</span><br><span class=\"line\">        <span class=\"comment\">// subscription 通过 request 来触发 onNext</span></span><br><span class=\"line\">        subscription.request(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onNext</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;currrent value is = &quot;</span> + s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onError</span><span class=\"params\">(Throwable throwable)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;it&#x27;s error.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onComplete</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;it&#x27;s completed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>执行结果:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onSubscribe,class reactor.core.publisher.StrictSubscriber</span><br><span class=\"line\">currrent value is = glmapper</span><br><span class=\"line\">currrent value is = leishu</span><br><span class=\"line\">it&#x27;s completed.</span><br></pre></td></tr></table></figure>\n\n<p>如果在 onSubscribe 方法中我们不执行 request，则不会有后续任何操作。关于 request 下面看。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Flux<T> 是一个能够发出 0 到 N 个元素的标准的 Publisher<T>，它会被一个 “error”  或 “completion” 信号终止。因此，一个 Flux 的结果可能是一个 value、completion 或 error。 就像在响应式流规范中规定的那样，这三种类型的信号被翻译为面向下游的 <code>onNext</code>，<code>onComplete</code>和<code>onError</code>方法。</p></blockquote>\n<h4 id=\"Mono-异步的-0-1-结果\"><a href=\"#Mono-异步的-0-1-结果\" class=\"headerlink\" title=\"Mono-异步的 0-1 结果\"></a>Mono-异步的 0-1 结果</h4><p><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/reactor/reactor-mono.jpg\" alt=\"Mono\"></p>\n<p>这张图也来自官方文档，和上面 Flux 的区别就是，Mono 最多只能 emitted 一个元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mono.just(<span class=\"string\">&quot;glmapper&quot;</span>).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>通过上面两段小的代码来看，最直观的感受是，Flux 相当于一个 List，Mono 相当于 Optional。其实在编程中所有的结果我们都可以用 List 来 表示，但是当只返回一个或者没有结果时，用 Optional 可能会更精确些。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Optional 相关概念可自行搜索 jdk Optional</p></blockquote>\n<p>另外，Mono 和 Flux 都提供了一些工厂方法，用于创建相关的实例，这里简单罗列一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以指定序列中包含的全部元素。创建出来的 Flux </span></span><br><span class=\"line\"><span class=\"comment\">// 序列在发布这些元素之后会自动结束。</span></span><br><span class=\"line\">Flux.just(<span class=\"string\">&quot;glmapper&quot;</span>, <span class=\"string\">&quot;leishu&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 从一个Iterable 对象中创建 Flux 对象,当然还可以是数组、Stream对象等</span></span><br><span class=\"line\">Flux.fromIterable(Arrays.asList(<span class=\"string\">&quot;glmapper&quot;</span>,<span class=\"string\">&quot;leishu&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">// 创建一个只包含错误消息的序列。</span></span><br><span class=\"line\">Flux.error(<span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>());</span><br><span class=\"line\"><span class=\"comment\">// 创建一个包含了从 0 开始递增的 Long 对象的序列。其中包含的元素按照指定的间</span></span><br><span class=\"line\"><span class=\"comment\">// 隔来发布。除了间隔时间之外，还可以指定起始元素发布之前的延迟时间。</span></span><br><span class=\"line\">Flux.interval(Duration.ofMillis(<span class=\"number\">100</span>)).take(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"comment\">// 创建一个不包含任何消息通知的序列。</span></span><br><span class=\"line\">Flux.never();</span><br><span class=\"line\"><span class=\"comment\">// 创建一个不包含任何元素，只发布结束消息的序列。</span></span><br><span class=\"line\">Flux.empty(); </span><br><span class=\"line\"><span class=\"comment\">// 创建包含从 start 起始的 count 个数量的 Integer 对象的序列</span></span><br><span class=\"line\">Flux.range(<span class=\"type\">int</span> start, <span class=\"type\">int</span> count);</span><br><span class=\"line\"><span class=\"comment\">// Mono 同上</span></span><br><span class=\"line\">Mono.empty();</span><br><span class=\"line\">Mono.never();</span><br><span class=\"line\">Mono.just(<span class=\"string\">&quot;glmapper&quot;</span>);</span><br><span class=\"line\">Mono.error(<span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>());</span><br></pre></td></tr></table></figure>\n\n<p>上面的这些静态方法适合于简单的序列生成，当序列的生成需要复杂的逻辑时，则应该使用 generate() 或 create() 方法。</p>\n<h3 id=\"一些概念\"><a href=\"#一些概念\" class=\"headerlink\" title=\"一些概念\"></a>一些概念</h3><ul>\n<li>Operator：Operator 是一系列函数式的便捷操作，可以链式调用。所有函数调用基本都 是 Reactor 的 Operator ，比如 just，map，flatMap，filter 等。</li>\n<li>Processor：上面从 Processor 的接口定义可以看出，它既是一个 Subscriber，又是一个 Publisher；Processor 夹在第一个 Publisher 和最后一个 Subscriber 中间，对数据进行处理。有点类似 stream 里的 map，filter 等方法。具体在数据流转中， Processor 以 Subscriber 的身份订阅 Publisher 接受数据，又以 Publisher 的方式接受其它 Subscriber 的订阅，它从自己订阅的 Publisher 收到数据后，做一些处理，然后转发给订阅它的 Subscriber。</li>\n<li>back pressure：背压。对 MQ 有了解的应该清楚，消息积压一般是在消费端，也就是说生产端只负责生产，并不会关心消费端的消费能力，这样就到导致 pressure 积压在消费端，这个是正向的。从上面对 Reactor 中的一些了解，Subscriber 是主动向 Publisher 请求的，这样当消费端消费的速度没有生产者快时，这些消息还是积压在生产端；这种好处就是生产者可以根据实际情况适当的调整生产消息的速度。</li>\n<li>Hot VS Cold ：参考 <a href=\"https://htmlpreview.github.io/?https://github.com/get-set/reactor-core/blob/master-zh/src/docs/index.html#reactor.hotCold\">Hot VS Cold</a></li>\n</ul>\n<h3 id=\"核心调用过程\"><a href=\"#核心调用过程\" class=\"headerlink\" title=\"核心调用过程\"></a>核心调用过程</h3><p>Reactor 的核心调用过程大致可以分为图中的几个阶段<br><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/reactor/reactor-processor.jpg\"></p>\n<ul>\n<li>声明：无论是使用 just 或者其他什么方式创建反应式流，这个过程都可以称之为声明，因为此时这些代码不会被实际的执行。</li>\n<li>subscribe：当调用 subscribe 时，整个执行过程便进入 subscribe 阶段，经过一系列的调用之后，subscribe 动作会代理给具体的 Flux 来实现。</li>\n<li>onSubscribe：onSubscribe 阶段指的是 Subscriber#onSubscribe 方法被依次调用的阶段。这个阶段会让各 Subscriber 知道 subscribe 方法已被触发，真正的处理流程马上就要开始。</li>\n<li>request：onSubscribe 阶段是表示订阅动作的方式，让各 Subscriber 知悉，准备开始处理数据。当最终的 Subscriber 做好处理数据的准备之后，它便会调用 Subscription 的 request 方法请求数据。</li>\n<li>onNext：通过调用 Subscriber 的 onNext 方法，进行真正的响应式的数据处理。</li>\n<li>onComplete：成功的终端状态，没有进一步的事件将被发送。</li>\n<li>onError：错误的终端状态（和 onComplete 一样，当发生时，后面的将不会在继续执行）。</li>\n</ul>\n<h3 id=\"消息处理\"><a href=\"#消息处理\" class=\"headerlink\" title=\"消息处理\"></a>消息处理</h3><p>当需要处理 Flux 或 Mono 中的消息时，可以通过 subscribe 方法来添加相应的订阅逻辑。在调用 subscribe 方法时可以指定需要处理的消息类型。可以只处理其中包含的正常消息，也可以同时处理错误消息和完成消息。</p>\n<h4 id=\"通过-subscribe-方法处理正常和错误消息\"><a href=\"#通过-subscribe-方法处理正常和错误消息\" class=\"headerlink\" title=\"通过 subscribe() 方法处理正常和错误消息\"></a>通过 subscribe() 方法处理正常和错误消息</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Flux.just(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">   .concatWith(Mono.error(<span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>()))</span><br><span class=\"line\">   .subscribe(System.out::println, System.err::println);</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">java.lang.IllegalStateException</span><br></pre></td></tr></table></figure>\n<p>正常的消息处理相对简单。当出现错误时，有多种不同的处理策略:</p>\n<ul>\n<li>通过 onErrorReturn() 方法返回一个默认值<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Flux.just(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">    .concatWith(Mono.error(<span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>()))</span><br><span class=\"line\">    .onErrorReturn(<span class=\"number\">0</span>)</span><br><span class=\"line\">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过 onErrorResume()方法来根据不同的异常类型来选择要使用的产生元素的流<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Flux.just(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">       .concatWith(Mono.error(<span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>()))</span><br><span class=\"line\">       .onErrorResume(e -&gt; &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> IllegalStateException) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> Mono.just(<span class=\"number\">0</span>);</span><br><span class=\"line\">           &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> IllegalArgumentException) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> Mono.just(-<span class=\"number\">1</span>);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> Mono.empty();</span><br><span class=\"line\">           &#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>\n结果：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">-1</span><br></pre></td></tr></table></figure></li>\n<li>通过 retry 操作符来进行重试，重试的动作是通过重新订阅序列来实现的。在使用 retry 操作符时可以指定重试的次数。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Flux.just(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">    .concatWith(Mono.error(<span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>()))</span><br><span class=\"line\">    .retry(<span class=\"number\">1</span>)</span><br><span class=\"line\">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>\n结果：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">Exception in thread &quot;main&quot; reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.IllegalStateException</span><br><span class=\"line\">Caused by: java.lang.IllegalStateException</span><br><span class=\"line\">\tat com.glmapper.bridge.boot.reactor.SimpleTest.testFluxSub(SimpleTest.java:75)</span><br><span class=\"line\">\tat com.glmapper.bridge.boot.reactor.SimpleTest.main(SimpleTest.java:23)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"调度器-Scheduler\"><a href=\"#调度器-Scheduler\" class=\"headerlink\" title=\"调度器 Scheduler\"></a>调度器 Scheduler</h3><p>在 Reactor 中，执行模式以及执行过程取决于所使用的 Scheduler，Scheduler 是一个拥有广泛实现类的抽象接口，Schedulers 类提供的静态方法用于达成如下的执行环境：</p>\n<ul>\n<li>当前线程（Schedulers.immediate()）<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Schedulers.immediate().schedule(()-&gt;&#123;</span><br><span class=\"line\">   System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;-&quot;</span>+<span class=\"number\">11</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main-11</span></span><br></pre></td></tr></table></figure></li>\n<li>可重用的单线程（Schedulers.single()）。注意，这个方法对所有调用者都提供同一个线程来使用， 直到该调度器（Scheduler）被废弃。如果你想使用专一的线程，就对每一个调用使用 Schedulers.newSingle()。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Schedulers.single().schedule(()-&gt;&#123;</span><br><span class=\"line\">    System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;-&quot;</span>+<span class=\"number\">11</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// single-1-11</span></span><br></pre></td></tr></table></figure></li>\n<li>弹性线程池（Schedulers.elastic()。它根据需要创建一个线程池，重用空闲线程。线程池如果空闲时间过长 （默认为 60s）就会被废弃。对于 I&#x2F;O 阻塞的场景比较适用。 Schedulers.elastic() 能够方便地给一个阻塞 的任务分配它自己的线程，从而不会妨碍其他任务和资源。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Schedulers.elastic().schedule(()-&gt;&#123;</span><br><span class=\"line\">    System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;-&quot;</span>+<span class=\"number\">11</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// elastic-2-11</span></span><br></pre></td></tr></table></figure></li>\n<li>固定大小线程池（Schedulers.parallel()）。所创建线程池的大小与 CPU 个数等同<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Schedulers.parallel().schedule(()-&gt;&#123;</span><br><span class=\"line\">    System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;-&quot;</span>+<span class=\"number\">11</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// parallel-1-11</span></span><br></pre></td></tr></table></figure></li>\n<li>基于现有的 ExecutorService 创建 Scheduler<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ExecutorService</span> <span class=\"variable\">executorService</span> <span class=\"operator\">=</span> Executors.newSingleThreadExecutor();</span><br><span class=\"line\">Schedulers.fromExecutorService(executorService).schedule(()-&gt;&#123;</span><br><span class=\"line\">    System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;-&quot;</span>+<span class=\"number\">11</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"comment\">// pool-4-thread-1-11</span></span><br></pre></td></tr></table></figure></li>\n<li>基于 newXXX 方法来创建调度器<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Schedulers.newElastic(<span class=\"string\">&quot;test-elastic&quot;</span>).schedule(()-&gt;&#123;</span><br><span class=\"line\">    System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;-&quot;</span>+<span class=\"number\">11</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// test-elastic-4-11</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>一些操作符默认会使用一个指定的调度器（通常也允许开发者调整为其他调度器）例如， 通过工厂方法 Flux.interval(Duration.ofMillis(100)) 生成的每 100ms 打点一次的 Flux<Long>， 默认情况下使用的是 Schedulers.parallel()，下边的代码演示了如何将其装换为 Schedulers.single()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Flux&lt;String&gt; intervalResult = Flux.interval(Duration.ofMillis(<span class=\"number\">100</span>),</span><br><span class=\"line\">        Schedulers.newSingle(<span class=\"string\">&quot;test&quot;</span>))</span><br><span class=\"line\">        .map(i -&gt; Thread.currentThread().getName() +<span class=\"string\">&quot;@&quot;</span>+i);</span><br><span class=\"line\">        intervalResult.subscribe(System.out::println);</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test-1@0</span><br><span class=\"line\">test-1@1</span><br><span class=\"line\">test-1@2</span><br><span class=\"line\">test-1@3</span><br><span class=\"line\">test-1@4</span><br><span class=\"line\">// 省略</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"publishOn-和-subscribeOn\"><a href=\"#publishOn-和-subscribeOn\" class=\"headerlink\" title=\"publishOn 和 subscribeOn\"></a>publishOn 和 subscribeOn</h3><p>Reactor 提供了两种在响应式链中调整调度器 Scheduler 的方法：publishOn 和 subscribeOn。 它们都接受一个 Scheduler 作为参数，从而可以改变调度器。但是 publishOn 在链中出现的位置是有讲究的，而 subscribeOn 则无所谓。</p>\n<ul>\n<li>publishOn 的用法和处于订阅链（subscriber chain）中的其他操作符一样。它将上游 信号传给下游，同时执行指定的调度器 Scheduler 的某个工作线程上的回调。 它会 改变后续的操作符的执行所在线程 （直到下一个 publishOn 出现在这个链上）</li>\n<li>subscribeOn 用于订阅（subscription）过程，作用于那个向上的订阅链（发布者在被订阅 时才激活，订阅的传递方向是向上游的）。所以，无论你把 subscribeOn 至于操作链的什么位置， 它都会影响到源头的线程执行环境（context）。 但是，它不会影响到后续的 publishOn，后者仍能够切换其后操作符的线程执行环境。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Flux.create(sink -&gt; &#123;</span><br><span class=\"line\">        sink.next(Thread.currentThread().getName());</span><br><span class=\"line\">        sink.complete();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .publishOn(Schedulers.single())</span><br><span class=\"line\">    .map(x -&gt; String.format(<span class=\"string\">&quot;[%s] %s&quot;</span>, Thread.currentThread().getName(), x))</span><br><span class=\"line\">    .publishOn(Schedulers.elastic())</span><br><span class=\"line\">    .map(x -&gt; String.format(<span class=\"string\">&quot;[%s] %s&quot;</span>, Thread.currentThread().getName(), x))</span><br><span class=\"line\">    .subscribeOn(Schedulers.parallel())</span><br><span class=\"line\">    .toStream()</span><br><span class=\"line\">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[elastic-<span class=\"number\">2</span>] [single-<span class=\"number\">1</span>] parallel-<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>上面这段代码使用 create() 方法创建一个新的 Flux 对象，其中包含唯一的元素是当前线程的名称。</p>\n<p>接着是两对 publishOn() 和 map()方法，其作用是先切换执行时的调度器，再把当前的线程名称作为前缀添加。</p>\n<p>最后通过 subscribeOn()方法来改变流产生时的执行方式。</p>\n<p>最内层的线程名字 parallel-1 来自产生流中元素时使用的 Schedulers.parallel()调度器，中间的线程名称 single-1 来自第一个 map 操作之前的 Schedulers.single() 调度器，最外层的线程名字 elastic-2 来自第二个 map 操作之前的 Schedulers.elastic()调度器。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>先到这里，剩下的想到再补充…</p></blockquote>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://projectreactor.io/docs/core/release/reference/\">https://projectreactor.io/docs/core/release/reference/</a></li>\n<li><a href=\"https://htmlpreview.github.io/?https://github.com/get-set/reactor-core/blob/master-zh/src/docs/index.html#about-doc\">https://htmlpreview.github.io/?https://github.com/get-set/reactor-core/blob/master-zh/src/docs/index.html#about-doc</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-cn-with-reactor-response-encode/index.html?lnk=hmhm\">https://www.ibm.com/developerworks/cn/java/j-cn-with-reactor-response-encode/index.html?lnk=hmhm</a></li>\n</ul>\n","text":"从响应式编程说起响应式编程是一种关注于数据流（data streams）和变化传递（propagation of change）的异步编程方式。 这意味着它可以...","permalink":"/post/java/java-base-reactor-intro","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"JAVA","slug":"JAVA","count":12,"path":"api/categories/JAVA.json"}],"tags":[{"name":"java","slug":"java","count":5,"path":"api/tags/java.json"},{"name":"reactor","slug":"reactor","count":1,"path":"api/tags/reactor.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%AF%B4%E8%B5%B7\"><span class=\"toc-text\">从响应式编程说起</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Reactive-Streams\"><span class=\"toc-text\">Reactive Streams</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Project-Reactor\"><span class=\"toc-text\">Project Reactor</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Flux-%E5%92%8C-Mono\"><span class=\"toc-text\">Flux 和 Mono</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Flux-%E5%8C%85%E5%90%AB-0-N-%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%8F%E5%88%97\"><span class=\"toc-text\">Flux-包含 0-N 个元素的异步序列</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Mono-%E5%BC%82%E6%AD%A5%E7%9A%84-0-1-%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">Mono-异步的 0-1 结果</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">一些概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%B8%E5%BF%83%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">核心调用过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86\"><span class=\"toc-text\">消息处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87-subscribe-%E6%96%B9%E6%B3%95%E5%A4%84%E7%90%86%E6%AD%A3%E5%B8%B8%E5%92%8C%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF\"><span class=\"toc-text\">通过 subscribe() 方法处理正常和错误消息</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B0%83%E5%BA%A6%E5%99%A8-Scheduler\"><span class=\"toc-text\">调度器 Scheduler</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#publishOn-%E5%92%8C-subscribeOn\"><span class=\"toc-text\">publishOn 和 subscribeOn</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"ARK 插件基本规则及注意事项","uid":"965065d167bea41b1f08335d6ffae271","slug":"sofa/sofa-ark-plugin-rule","date":"2019-08-28T10:53:53.000Z","updated":"2024-07-05T04:09:05.801Z","comments":true,"path":"api/articles/sofa/sofa-ark-plugin-rule.json","keywords":null,"cover":[],"text":"SOFAARK 是一个轻量级的类隔离框架，其有两个基本的能力：解决依赖包冲突和多应用(模块)合并部署。本篇将从解决依赖角度来说明下 SOFARK 插件的基本使用...","permalink":"/post/sofa/sofa-ark-plugin-rule","photos":[],"count_time":{"symbolsCount":"7.4k","symbolsTime":"7 mins."},"categories":[{"name":"SOFA","slug":"SOFA","count":9,"path":"api/categories/SOFA.json"}],"tags":[{"name":"ClassLoader","slug":"ClassLoader","count":4,"path":"api/tags/ClassLoader.json"},{"name":"SOFAArk","slug":"SOFAArk","count":4,"path":"api/tags/SOFAArk.json"},{"name":"类加载","slug":"类加载","count":2,"path":"api/tags/类加载.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"聊一聊-JAVA 泛型中的通配符 T，E，K，V，？","uid":"099cbe91c3412d78be7c6de51de68c1a","slug":"java/java-base-generic-wildcard","date":"2019-08-19T10:13:57.000Z","updated":"2024-07-05T04:09:05.763Z","comments":true,"path":"api/articles/java/java-base-generic-wildcard.json","keywords":null,"cover":[],"text":"前言Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许开发者在编译时检测到非法的类型。 泛型的...","permalink":"/post/java/java-base-generic-wildcard","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"JAVA","slug":"JAVA","count":12,"path":"api/categories/JAVA.json"}],"tags":[{"name":"泛型","slug":"泛型","count":2,"path":"api/tags/泛型.json"},{"name":"java","slug":"java","count":5,"path":"api/tags/java.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}