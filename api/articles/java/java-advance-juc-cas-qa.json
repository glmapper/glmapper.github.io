{"title":"并发编程-关于 CAS 的几个问题","uid":"abea11fd3a48225fb287e26d15ad0ab2","slug":"java/java-advance-juc-cas-qa","date":"2019-04-29T11:06:16.000Z","updated":"2024-07-05T04:09:05.762Z","comments":true,"path":"api/articles/java/java-advance-juc-cas-qa.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":null,"content":"<h2 id=\"CAS-相关基础知识\"><a href=\"#CAS-相关基础知识\" class=\"headerlink\" title=\"CAS 相关基础知识\"></a>CAS 相关基础知识</h2><p>CAS的全称是Compare And Swap ,即比较交换。CAS 中一般会设计到3个参数:</p>\n<ul>\n<li>内存值 V</li>\n<li>旧的预期值A</li>\n<li>要修改的新值B</li>\n</ul>\n<p>当且仅当预期值 A 和内存值 V 相同时，将内存值V修改为 B，否则什么都不做。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里关于 CPU 指令对于 CAS 的支持不深入研究,有兴趣的可以自行了解。</p></blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"CAS-几个问题\"><a href=\"#CAS-几个问题\" class=\"headerlink\" title=\"CAS 几个问题\"></a>CAS 几个问题</h2><p>很多书籍和文章中都有提出它存在的几个问题：</p>\n<ul>\n<li>1、循环时间长开销很大</li>\n<li>2、只能保证一个共享变量的原子操作</li>\n<li>3、ABA 问题</li>\n</ul>\n<p>下面就这三个问题展开来聊一下。</p>\n<h3 id=\"1、关于“循环时间长开销很大”的疑惑与验证\"><a href=\"#1、关于“循环时间长开销很大”的疑惑与验证\" class=\"headerlink\" title=\"1、关于“循环时间长开销很大”的疑惑与验证\"></a>1、关于“循环时间长开销很大”的疑惑与验证</h3><p>自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的开销。但是真的是这样吗？到底多大的并发量才造成 CAS 的自旋次数会增加呢？另外，对于当前的机器及JDK，在无锁，无CAS 的情况下，是否对于结果的影响是真的那么明显呢？对于这个问题，下面做了一个简单的测试，但是测试结果也只是针对在我本地环境下，各位看官可以拉一下代码，在自己电脑上 run 一下，把机器信息、JDK版本以及测试结果留言到评论区。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>本文案例可以这里获取：<a href=\"https://github.com/glmapper/glmapper-blog-samples/tree/master/glmapper-blog-sample-cas\">glmapper-blog-sample-cas</a></p></blockquote>\n<p>这里我是用了一个很简单的案例，就是整数自增。使用了两种方式去测试的，一种是无锁，也不用 CAS 操作，另外一种是基于 CAS 的方式。（关于加锁的方式没有验证，有时间再补充吧~）</p>\n<h4 id=\"计数器类\"><a href=\"#计数器类\" class=\"headerlink\" title=\"计数器类\"></a>计数器类</h4><p>计数器里面有两个方法，一种是CAS 自旋方式，一种是直接自增。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Counter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">AtomicInteger</span> <span class=\"variable\">safeCount</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"variable\">unsafe</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 使用自旋的方式</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">safeCount</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> safeCount.get();</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> safeCount.compareAndSet(i,++i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (success)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 普通方式自增</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unsafeCount</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        unsafe++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"模拟并发\"><a href=\"#模拟并发\" class=\"headerlink\" title=\"模拟并发\"></a>模拟并发</h4><p>这里我们模拟使用 1000 个线程，执行 30 次来看下结果，包括总耗时和结果的正确性。</p>\n<ul>\n<li>CAS 方式<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">testSafe</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 记录开始时间</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"comment\">// 实例化一个 Counter 计数器对象</span></span><br><span class=\"line\">    <span class=\"type\">Counter</span> <span class=\"variable\">counter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Counter</span>();</span><br><span class=\"line\">    <span class=\"type\">CountDownLatch</span> <span class=\"variable\">countDownLatch</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountDownLatch</span>(testCounts);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span><span class=\"number\">0</span> ;i &lt; testCounts;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 调用 safeCount 方法</span></span><br><span class=\"line\">                counter. safeCount();</span><br><span class=\"line\">                countDownLatch.countDown();</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    countDownLatch.await();</span><br><span class=\"line\">    <span class=\"comment\">// 结束时间</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    safeTotalCostTime += (end-start);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> counter.safeCount.get();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>普通方式</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">testUnSafe</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 记录开始时间</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"comment\">// 实例化一个 Counter 计数器对象</span></span><br><span class=\"line\">    <span class=\"type\">Counter</span> <span class=\"variable\">counter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Counter</span>();</span><br><span class=\"line\">    <span class=\"type\">CountDownLatch</span> <span class=\"variable\">countDownLatch</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountDownLatch</span>(testCounts);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span><span class=\"number\">0</span> ;i&lt; testCounts;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 调用 unsafeCount 方法</span></span><br><span class=\"line\">            counter.unsafeCount();</span><br><span class=\"line\">            countDownLatch.countDown();</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    countDownLatch.await();</span><br><span class=\"line\">    <span class=\"comment\">// 结束时间</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    unsafeTotalCostTime += (end-start);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> counter.unsafe;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>main 方法</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">    // 执行 300 次</span><br><span class=\"line\">    for (int i =0 ;i&lt; 300;i++)&#123;</span><br><span class=\"line\">        // 普通方式</span><br><span class=\"line\">        int unSafeResult = testUnSafe();</span><br><span class=\"line\">        // cas 方式</span><br><span class=\"line\">        int safeResult = testSafe();</span><br><span class=\"line\">        // 结果验证，若果正确就将成功次数增加</span><br><span class=\"line\">        if (unSafeResult == testCounts)&#123;</span><br><span class=\"line\">            totalUnSafeCount++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 同上</span><br><span class=\"line\">        if (safeResult == testCounts)&#123;</span><br><span class=\"line\">            totalSafeCount++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(&quot;test count = &quot; + testCounts);</span><br><span class=\"line\">    System.out.println(&quot;非安全计数器正确个数 = &quot; + totalUnSafeCount);</span><br><span class=\"line\">    System.out.println(&quot;非安全计数器耗时 = &quot; + unsafeTotalCostTime);</span><br><span class=\"line\">    System.out.println(&quot;安全计数器正确个数 = &quot; + totalSafeCount);</span><br><span class=\"line\">    System.out.println(&quot;安全计数器耗时 = &quot; + safeTotalCostTime);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我的机器信息如下：</p>\n<ul>\n<li>MacBook Pro (Retina, 15-inch, Mid 2015)</li>\n<li>处理器：2.2 GHz Intel Core i7</li>\n<li>内存：16 GB 1600 MHz DDR3</li>\n</ul>\n<p>下面是一些测试数据。</p>\n<h4 id=\"1000-线程数-300-次数\"><a href=\"#1000-线程数-300-次数\" class=\"headerlink\" title=\"1000(线程数) * 300(次数)\"></a>1000(线程数) * 300(次数)</h4><p>测试结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test count = 1000</span><br><span class=\"line\">非安全计数器正确个数 = 300</span><br><span class=\"line\">非安全计数器耗时 = 27193</span><br><span class=\"line\">安全计数器正确个数 = 300</span><br><span class=\"line\">安全计数器耗时 = 26337</span><br></pre></td></tr></table></figure>\n<p>居然发现不使用 CAS 的方式居然比使用自旋 CAS 的耗时要高出将近 1s。另外一个意外的点，我尝试了好几次，不使用 CAS 的情况得到的结果正确率基本也是 4 个 9  以上的比率，极少数会出现计算结果错误的情况。</p>\n<h4 id=\"3000-线程数-30-次数\"><a href=\"#3000-线程数-30-次数\" class=\"headerlink\" title=\"3000(线程数) * 30(次数)\"></a>3000(线程数) * 30(次数)</h4><p>测试结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test count = 3000</span><br><span class=\"line\">非安全计数器正确个数 = 30</span><br><span class=\"line\">非安全计数器耗时 = 7816</span><br><span class=\"line\">安全计数器正确个数 = 30</span><br><span class=\"line\">安全计数器耗时 = 8073</span><br></pre></td></tr></table></figure>\n<p>这里看到在耗时上已经很接近了。这里需要考虑另外一个可能影响的点是，因为 testUnSafe 是 testSafe 之前执行的，“JVM 和 机器本身热身” 影响耗时虽然很小，但是也存在一定的影响。</p>\n<h4 id=\"5000-线程数-30-次数\"><a href=\"#5000-线程数-30-次数\" class=\"headerlink\" title=\"5000(线程数) * 30(次数)\"></a>5000(线程数) * 30(次数)</h4><p>测试结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test count = 5000</span><br><span class=\"line\">非安全计数器正确个数 = 30</span><br><span class=\"line\">非安全计数器耗时 = 23213</span><br><span class=\"line\">安全计数器正确个数 = 30</span><br><span class=\"line\">安全计数器耗时 = 14161</span><br></pre></td></tr></table></figure>\n<p>随着并发量的增加，这里奇怪的是，普通自增方式所消耗的时间要高于CAS方式消耗的时间将近 8-9s 。</p>\n<p>当尝试 10000 次时，是的你没猜错，抛出了 OOM 。但是从执行的结果来看，并没有说随着并发量的增大，普通方式错误的概率会增加，也没有出现预想的 CAS 方式的耗时要比 普通模式耗时多。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>由于测试样本数据比较单一，对于测试结果没法做结论，欢迎大家将各自机器的结果提供出来，以供参考。另外就是，最近看到很多面试的同学，如果有被问道这个问题，还是需要谨慎考虑下。关于是否“打脸”还是“被打脸”还需要更多的测试结果。</p></blockquote>\n<h3 id=\"CAS-到底是怎么操作的\"><a href=\"#CAS-到底是怎么操作的\" class=\"headerlink\" title=\"CAS 到底是怎么操作的\"></a>CAS 到底是怎么操作的</h3><ul>\n<li>CPU 指令</li>\n<li>Unsafe 类</li>\n</ul>\n<h3 id=\"2、ABA-问题的简单复现\"><a href=\"#2、ABA-问题的简单复现\" class=\"headerlink\" title=\"2、ABA 问题的简单复现\"></a>2、ABA 问题的简单复现</h3><p>网上关于 CAS 讨论另外一个点就是 CAS 中的 ABA 问题，相信大多数同学在面试时如果被问到 CAS ，那么 ABA 问题也会被问到，然后接着就是怎么避免这个问题，是的套路就是这么一环扣一环的。</p>\n<p>我相信 90% 以上的开发人员在实际的工程中是没有遇到过这个问题的，即使遇到过，在特定的情况下也是不会影响到计算结果。但是既然这个问题会被反复提到，那就一定有它导致 bug 的场景，找了一个案例供大家参考：<a href=\"https://blog.csdn.net/wufaliang003/article/details/78797203\">CAS下ABA问题及优化方案</a> 。</p>\n<p>这里先不去考虑怎么去规避这个问题，我们想怎么去通过简单的模拟先来复现这个 ABA 问题。其实这个也很简单，如果你对线程交叉、顺序执行了解的话。</p>\n<h3 id=\"如何实现多线程的交叉执行\"><a href=\"#如何实现多线程的交叉执行\" class=\"headerlink\" title=\"如何实现多线程的交叉执行\"></a>如何实现多线程的交叉执行</h3><p>这个点实际上也是一个在面试过程中很常见的一个基础问题，我在提供的代码中给了三种实现方式，有兴趣的同学可以拉代码看下。</p>\n<p>下面以 lock 的方式来模拟下这个场景，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConditionAlternateTest</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 计数器</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">AtomicInteger</span> <span class=\"variable\">safeCount</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// lock</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Lock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">    <span class=\"comment\">// condition 1/2/3 用于三个线程触发执行的条件</span></span><br><span class=\"line\">    <span class=\"type\">Condition</span> <span class=\"variable\">c1</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"type\">Condition</span> <span class=\"variable\">c2</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"type\">Condition</span> <span class=\"variable\">c3</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"comment\">// 模拟并发执行</span></span><br><span class=\"line\">    <span class=\"type\">CountDownLatch</span> <span class=\"variable\">countDownLatch</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountDownLatch</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 线程1 ，A </span></span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (count % <span class=\"number\">3</span> != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                c1.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            safeCount.compareAndSet(<span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;thread1:&quot;</span>+safeCount.get());</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">            <span class=\"comment\">// 唤醒条件2</span></span><br><span class=\"line\">            c2.signal();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">     <span class=\"comment\">// 线程2 ，B </span></span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (count % <span class=\"number\">3</span> != <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                c2.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            safeCount.compareAndSet(<span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;thread2:&quot;</span>+safeCount.get());</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">            <span class=\"comment\">// 唤醒条件3</span></span><br><span class=\"line\">            c3.signal();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 线程2 ，A</span></span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (count % <span class=\"number\">3</span> != <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">                c3.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            safeCount.compareAndSet(<span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;thread3:&quot;</span>+safeCount.get());</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">            <span class=\"comment\">// 唤醒条件1</span></span><br><span class=\"line\">            c1.signal();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 启动启动线程</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">threadStart</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        t3.start();</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">        countDownLatch.countDown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">ConditionAlternateTest</span> <span class=\"variable\">test</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConditionAlternateTest</span>();</span><br><span class=\"line\">        test.threadStart();</span><br><span class=\"line\">        test.countDownLatch.await();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">thread1:<span class=\"number\">1</span></span><br><span class=\"line\">thread2:<span class=\"number\">0</span></span><br><span class=\"line\">thread3:<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>上面线程交叉的案例实际上并不是严格意义上的 ABA 问题的复现，这里仅是模拟下产生的一个最简单的过程。如果大家有好的案例，也可以分享一下。</p>\n<h3 id=\"ABA-问题解决\"><a href=\"#ABA-问题解决\" class=\"headerlink\" title=\"ABA 问题解决\"></a>ABA 问题解决</h3><p>常见实践：“版本号”的比对，一个数据一个版本，版本变化，即使值相同，也不应该修改成功。</p>\n<p>java 中提供了 AtomicStampedReference 这个类来解决这个 ABA 问题。<br>AtomicStampedReference 原子类是一个带有时间戳的对象引用，在每次修改后，AtomicStampedReference 不仅会设置新值而且还会记录更改的时间。当 AtomicStampedReference 设置对象值时，对象值以及时间戳都必须满足期望值才能写入成功，这也就解决了反复读写时，无法预知值是否已被修改的窘境。</p>\n<p>实现代码这里就不贴了，基于前面的代码改造，下面贴一下运行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">thread1,第一次修改;值为=1</span><br><span class=\"line\">thread2,已经改回为原始值;值为=0</span><br><span class=\"line\">thread3,第二次修改;值为=1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、只能保证一个共享变量的原子操作\"><a href=\"#3、只能保证一个共享变量的原子操作\" class=\"headerlink\" title=\"3、只能保证一个共享变量的原子操作\"></a>3、只能保证一个共享变量的原子操作</h3><p>当对一个共享变量执行操作时，我们可以使用 CAS 的方式来保证原子操作，但是对于对多个变量操作时，循环 CAS 就无法保证操作的原子性了，那么这种场景下，我们就需要使用加锁的方式来解决。</p>\n","text":"CAS 相关基础知识CAS的全称是Compare And Swap ,即比较交换。CAS 中一般会设计到3个参数: 内存值 V 旧的预期值A 要修改的新值B 当...","permalink":"/post/java/java-advance-juc-cas-qa","photos":[],"count_time":{"symbolsCount":"7.8k","symbolsTime":"7 mins."},"categories":[{"name":"JAVA","slug":"JAVA","count":12,"path":"api/categories/JAVA.json"}],"tags":[{"name":"并发编程","slug":"并发编程","count":5,"path":"api/tags/并发编程.json"},{"name":"JUC","slug":"JUC","count":3,"path":"api/tags/JUC.json"},{"name":"CAS","slug":"CAS","count":1,"path":"api/tags/CAS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CAS-%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">CAS 相关基础知识</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CAS-%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">CAS 几个问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%85%B3%E4%BA%8E%E2%80%9C%E5%BE%AA%E7%8E%AF%E6%97%B6%E9%97%B4%E9%95%BF%E5%BC%80%E9%94%80%E5%BE%88%E5%A4%A7%E2%80%9D%E7%9A%84%E7%96%91%E6%83%91%E4%B8%8E%E9%AA%8C%E8%AF%81\"><span class=\"toc-text\">1、关于“循环时间长开销很大”的疑惑与验证</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E6%95%B0%E5%99%A8%E7%B1%BB\"><span class=\"toc-text\">计数器类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%8B%9F%E5%B9%B6%E5%8F%91\"><span class=\"toc-text\">模拟并发</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1000-%E7%BA%BF%E7%A8%8B%E6%95%B0-300-%E6%AC%A1%E6%95%B0\"><span class=\"toc-text\">1000(线程数) * 300(次数)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3000-%E7%BA%BF%E7%A8%8B%E6%95%B0-30-%E6%AC%A1%E6%95%B0\"><span class=\"toc-text\">3000(线程数) * 30(次数)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5000-%E7%BA%BF%E7%A8%8B%E6%95%B0-30-%E6%AC%A1%E6%95%B0\"><span class=\"toc-text\">5000(线程数) * 30(次数)</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CAS-%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9C%E7%9A%84\"><span class=\"toc-text\">CAS 到底是怎么操作的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%E3%80%81ABA-%E9%97%AE%E9%A2%98%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0\"><span class=\"toc-text\">2、ABA 问题的简单复现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%A4%E5%8F%89%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">如何实现多线程的交叉执行</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ABA-%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3\"><span class=\"toc-text\">ABA 问题解决</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%8F%AA%E8%83%BD%E4%BF%9D%E8%AF%81%E4%B8%80%E4%B8%AA%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">3、只能保证一个共享变量的原子操作</span></a></li></ol></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"Linux 下安装 Zookeeper","uid":"c6dcfcda5dea0263fc2424962ca2973e","slug":"linux/linux-ops-soft-zookeeper","date":"2019-05-04T12:29:18.000Z","updated":"2024-07-05T04:09:05.775Z","comments":true,"path":"api/articles/linux/linux-ops-soft-zookeeper.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":null,"text":"安装 Zookeeper目前 Curator 有 2.x.x 和 3.x.x 两个系列的版本，支持不同版本的 Zookeeper。其中 Curator 2.x....","permalink":"/post/linux/linux-ops-soft-zookeeper","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"Linux","slug":"Linux","count":9,"path":"api/categories/Linux.json"}],"tags":[{"name":"zookeeper","slug":"zookeeper","count":3,"path":"api/tags/zookeeper.json"},{"name":"linux","slug":"linux","count":9,"path":"api/tags/linux.json"},{"name":"运维","slug":"运维","count":2,"path":"api/tags/运维.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"linux shell 编程小记","uid":"e6e9029e4c940952840addd5ca00ccc2","slug":"linux/linux-program-shell-record","date":"2019-04-20T10:18:42.000Z","updated":"2024-07-05T04:09:05.776Z","comments":true,"path":"api/articles/linux/linux-program-shell-record.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":null,"text":"if 条件 OPTION OPTION 解释 [-a file] 如果file存在则为真 ，也可以表示为 and: 条件与if [ -z “condition1...","permalink":"/post/linux/linux-program-shell-record","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[{"name":"Linux","slug":"Linux","count":9,"path":"api/categories/Linux.json"}],"tags":[{"name":"linux","slug":"linux","count":9,"path":"api/tags/linux.json"},{"name":"shell","slug":"shell","count":1,"path":"api/tags/shell.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}