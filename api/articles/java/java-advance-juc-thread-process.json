{"title":"并发编程---进程、线程安全","uid":"9c34f2d9e4aaac9e5f4272c83ef2d6d2","slug":"java/java-advance-juc-thread-process","date":"2018-11-10T05:39:42.000Z","updated":"2024-07-05T04:09:05.763Z","comments":true,"path":"api/articles/java/java-advance-juc-thread-process.json","keywords":null,"cover":null,"content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>原文：<a href=\"https://juejin.cn/post/6844903502154563597\">https://juejin.cn/post/6844903502154563597</a></p></blockquote>\n<p>在 java 中，所有的变量（实例字段，静态字段，构成数组的元素，不包括局部变量和方法参数）都存储在主内存中，内个线程都有自己的工作内存，线程的工作内存保存被线程使用到的变量的主内存副本拷贝。线程对变量的所有操作都必须在工作内存中进行，为不能直接读写主内存的变量。不同线程之间也不恩能够直接访问对方工作内存中的变量，线程间比变量值的传递通过主内存来完成。</p>\n<p>本文主要是了解并发编程中的涉及一些基础概念，如：临界区、互斥量、CAS、重排序以及 Java 语言中的一些关键字。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"临界区\"><a href=\"#临界区\" class=\"headerlink\" title=\"临界区\"></a>临界区</h2><p>保证在某一时刻只有一个线程能访问数据的简便方法，在任意时刻只允许一个线程对资源进行访问。如果有多个线程试图同时访问临界区，那么在有一个线程进入后，其他所有试图访问临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操作共享资源的目的</p>\n<h2 id=\"互斥量\"><a href=\"#互斥量\" class=\"headerlink\" title=\"互斥量\"></a>互斥量</h2><p>互斥量和临界区很相似，只能拥有互斥对象的线程才能具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下次共享资源都不会同时被多个线程所访问。当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后可以访问资源。互斥量比临界区复杂，因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。</p>\n<h2 id=\"管程-信号量\"><a href=\"#管程-信号量\" class=\"headerlink\" title=\"管程&#x2F;信号量\"></a>管程&#x2F;信号量</h2><p>管程和信号量是同一个概念。指一个互斥独占锁定的对象或称为互斥体。在给定的时间，仅有一个线程可以获得管程。当一个线程需要锁定，他必须进入管程。所有其他的试图进入已经锁定的管程的线程必须挂起直到第一个线程退出管程。这些其他的线程被称为等待线程。一个拥有管程的线程如果愿意的话可以再次进入相同的管程（可重入性）</p>\n<h2 id=\"CAS操作\"><a href=\"#CAS操作\" class=\"headerlink\" title=\"CAS操作\"></a>CAS操作</h2><p>CAS操作（compare  and swap）CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则返回V。这是一种乐观锁的思路，它相信在它修改之前，没有其它线程去修改它；而Synchronized是一种悲观锁，它认为在它修改之前，一定会有其它线程去修改它，悲观锁效率很低。下面来看一下AtomicInteger是如何利用CAS实现原子性操作的。</p>\n<h2 id=\"重排序\"><a href=\"#重排序\" class=\"headerlink\" title=\"重排序\"></a>重排序</h2><p>编译器和处理器为了提高性能，而在程序执行时会对程序进行重排序。他的出现是为了提高程序的并发度。从而提高性能；但是对于多线程程序，重排序可能会导致程序执行的结果不是我们需要的结果，重排序分为编译器和处理器俩个方面。而处理器重排序包括指令级重排序和内存重排序。</p>\n<h2 id=\"JAVA中线程安全相关关键字及类\"><a href=\"#JAVA中线程安全相关关键字及类\" class=\"headerlink\" title=\"JAVA中线程安全相关关键字及类\"></a>JAVA中线程安全相关关键字及类</h2><p>主要包括：synchronized，Volitile，ThreadLocal，Lock，Condition</p>\n<h3 id=\"2-1-Volitile\"><a href=\"#2-1-Volitile\" class=\"headerlink\" title=\"2.1 Volitile\"></a>2.1 Volitile</h3><p>作用：</p>\n<ul>\n<li>1）保证了心智能立即存储到主内存才，每次使用前立即从主内存中刷新</li>\n<li>2）禁止指令重排序优化</li>\n</ul>\n<p>Volitile关键字不能保证在多线程环境下对共享数据的操作的正确性，可以使用在自己状态改变之后需要立即通知所有线程的情况下，只保证可见性，不保证原子性。即通过刷新变量值确保可见性。</p>\n<p>Java中synchronized和final也能保证可见性</p>\n<p>synchronized：同步快通过变量锁定前必须清空工作内存中的变量值，重新从主内存中读取变量值，解锁前必须把变量值同步回主内存来确保可见性。</p>\n<p>final:被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把this引用传递进去，那么在其他线程中就能看见final字段的值，无需同步就可以被其他线程正确访问。</p>\n<h3 id=\"2-2-synchronized\"><a href=\"#2-2-synchronized\" class=\"headerlink\" title=\"2.2 synchronized\"></a>2.2 synchronized</h3><p>把代码块声明为synchronized，有俩个作用，通常是指改代码具有原子性和可见性。如果没有同步机制提供的这种可见性，线程看到的共享比那里可能是修改前的值或不一致的值，这将引发许多严重问题。</p>\n<p>原理：当对象获取锁是，他首先是自己的高速缓存无效，这样就可以保证直接从主内存中装入变量，同样在对象释放锁之前，他会刷新其高速缓存，强制使已做的任何更改都出现在主内存中，这样会保证在同一个锁上同步的俩个线程看到在synchronized块内修改的变量的相同值。</p>\n<p>synchronized 释放由JVM自己管理。</p>\n<p>存在的问题：</p>\n<ul>\n<li>1）无法中断一个正在等待获得锁的线程</li>\n<li>2）无法通过投票得到锁，如果不想等待下去，也就没法得到锁</li>\n<li>3）同步还需要锁的释放只能在与获得锁所在的堆栈帧相同的堆栈中进行，多数情况下，这没问题（而且与一场处理交互的很好），但是，确实存在一些非块结构的锁定更适合情况。</li>\n</ul>\n<h3 id=\"2-3-Lock\"><a href=\"#2-3-Lock\" class=\"headerlink\" title=\"2.3 Lock\"></a>2.3 Lock</h3><p>Lock是有JAVA编写而成的，在java这个层面是无关JVM实现的。包括：ReentrantLock，ReadWriteLock。其本质都依赖于AbstractQueueSynchronized类。Lock提供了很多锁的方式，尝试锁，中断锁等。释放锁的过程由JAVA开发人员自己管理。</p>\n<p>就性能而言，对于资源冲突不多的情况下synchronized更加合理，但如果资源访问冲突多的情况下，synchronized的性能会快速下降，而Lock可以保持平衡。</p>\n<h3 id=\"2-4-condition\"><a href=\"#2-4-condition\" class=\"headerlink\" title=\"2.4 condition\"></a>2.4 condition</h3><p>Condition将Object监视器方法（wait，notify,notifyall）分解成截然不同的对象，以便通过这些对象与任意Lock实现组合使用，为每个对象提供多个等待set(wait-set),，其中Lock替代了synchronized方法和语句的使用，condition替代了Object监视器方法的使用。Condition实例实质上被你绑定到一个锁上。要为特定Lock实例获得Condition实例，请使用其newCondition（）方法。</p>\n<h3 id=\"2-5-ThreadLock\"><a href=\"#2-5-ThreadLock\" class=\"headerlink\" title=\"2.5 ThreadLock\"></a>2.5 ThreadLock</h3><p>线程局部变量。</p>\n<p>变量是同一个，但是每个线程都使用同一个初始值，也就是使用同一个变量的一个新的副本，这种情况下TreadLocal就非常有用。</p>\n<p>应用场景：当很多线程需要多次使用同一个对象，并且需要该对象具有相同初始值的时候，最适合使用TreadLocal。</p>\n<p>事实上，从本质上讲，就是每个线程都维持一个MAP，而这个map的key就是TreadLocal,而值就是我们set的那个值，每次线程在get的时候，都从自己的变量中取值，既然从自己的变量中取值，那就肯定不存在线程安全的问题。总体来讲，TreadLocal这个变量的状态根本没有发生变化。它仅仅是充当了一个key的角色，另外提供给每一个线程一个初始值。如果允许的话，我们自己就能实现一个这样的功能，只不过恰好JDK就已经帮助我们做了这个事情。</p>\n<p>使用TreadLocal维护变量时，TreadLocal为每个使用该变量的线程提供独立地变量副本，所以每一个线程都可以独立地改变自己的副本，而不会英语其他线程所对应的副本。从线程的角度看，目标变量对象是线程的本地变量，这也是类名中Local所需要表达的意思。</p>\n<p>TreadLocal的四个方法：</p>\n<ul>\n<li>void set(Object val),设置当前线程的线程局部变量的值</li>\n<li>Object get（）返回当前线程所对用的线程局部变量。</li>\n<li>void remove() 将当前线程局部变量的值删除，目的是为了减少内存的占用，线程结束后，局部变量自动被GC</li>\n<li>Object  initValue() 返回该线程局部变量的初始值，使用protected修饰，显然是为了让子类覆盖而设计的。</li>\n</ul>\n<h2 id=\"线程安全的实现方式\"><a href=\"#线程安全的实现方式\" class=\"headerlink\" title=\"线程安全的实现方式\"></a>线程安全的实现方式</h2><h2 id=\"3-1-互斥同步\"><a href=\"#3-1-互斥同步\" class=\"headerlink\" title=\"3.1 互斥同步\"></a>3.1 互斥同步</h2><p>在多线程访问的时候，保证同一时间只有一条线程使用。临界区，互斥量，管程都是同步的一种手段。</p>\n<p>java 中最基本的互斥同步手段是synchronized，编译之后会形成monitorenter和monitorexit这俩个字节码指令，这俩个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象，还有一个锁的计数器，来记录加锁的次数，加锁几次就要同样解锁几次才能恢复到无锁状态。</p>\n<p>java 的线程是映射到操作系统的原生线程之上的，不管阻塞还是唤醒都需要操作系统的帮助完成，都需要从用户态转换到核心态，这是很耗费时间的，是 java 语言中的一个重量级的操作，虽然虚拟机本身会做一点优化的操作，比如通知操作系统阻塞之前会加一段自旋等待的过程，避免频繁切换到核心态。</p>\n<h2 id=\"3-2-非阻塞同步\"><a href=\"#3-2-非阻塞同步\" class=\"headerlink\" title=\"3.2 非阻塞同步\"></a>3.2 非阻塞同步</h2><p>互斥和同步最主要的问题就是阻塞和唤醒所带来的性能的问题，所以这通常叫阻塞同步（悲观的并发策略）.随着硬件指令集的发展，我们有另外的选择：基于冲突检测的乐观并发策略，通俗讲就是先操作，如果没有其他线程争用共享的数据，操作就成功，如果有，则进行其他的补偿（最常见的就是不断的重试）。这种乐观的并发策略许多实现都不需要把线程先挂起，这种同步操作被称为非阻塞同步。</p>\n<h2 id=\"3-3-无同步\"><a href=\"#3-3-无同步\" class=\"headerlink\" title=\"3.3 无同步\"></a>3.3 无同步</h2><p>部分代码天生就是线程安全的，不需要同步。</p>\n<ul>\n<li>1）可重入代码：纯代码，具有不依赖存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入，不调用非可重入的方法等特征，它的返回结果是可以预测的。</li>\n<li>2）线程本地存储：把共享数据的可见性范围限制在同一个线程之内，这样就无需同步也能保证线程之间不出现数据争用问题。可以通过java.lang.TreadLocal类来实现线程本地存储的功能。</li>\n</ul>\n","text":" 原文：https://juejin.cn/post/6844903502154563597 在 java 中，所有的变量（实例字段，静态字段，构成数组的元素，...","permalink":"/post/java/java-advance-juc-thread-process","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"JAVA","slug":"JAVA","count":12,"path":"api/categories/JAVA.json"}],"tags":[{"name":"thread","slug":"thread","count":2,"path":"api/tags/thread.json"},{"name":"并发编程","slug":"并发编程","count":5,"path":"api/tags/并发编程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%B4%E7%95%8C%E5%8C%BA\"><span class=\"toc-text\">临界区</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%92%E6%96%A5%E9%87%8F\"><span class=\"toc-text\">互斥量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%A1%E7%A8%8B-%E4%BF%A1%E5%8F%B7%E9%87%8F\"><span class=\"toc-text\">管程&#x2F;信号量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CAS%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">CAS操作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%87%8D%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">重排序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JAVA%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%8A%E7%B1%BB\"><span class=\"toc-text\">JAVA中线程安全相关关键字及类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-Volitile\"><span class=\"toc-text\">2.1 Volitile</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-synchronized\"><span class=\"toc-text\">2.2 synchronized</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-Lock\"><span class=\"toc-text\">2.3 Lock</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-condition\"><span class=\"toc-text\">2.4 condition</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-ThreadLock\"><span class=\"toc-text\">2.5 ThreadLock</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">线程安全的实现方式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">3.1 互斥同步</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">3.2 非阻塞同步</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-%E6%97%A0%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">3.3 无同步</span></a></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"怎么写一个死锁？","uid":"f1ca72d2339ef0d0df0ca0f7ea0b32bd","slug":"java/java-advance-juc-thread-deadlock","date":"2018-11-10T05:55:55.000Z","updated":"2024-07-05T04:09:05.762Z","comments":true,"path":"api/articles/java/java-advance-juc-thread-deadlock.json","keywords":null,"cover":[],"text":" 原文：https://juejin.cn/post/6844903520886325255 看着看着就想着怎么能写一个死锁呢，打开 eclipse，突然感觉无...","permalink":"/post/java/java-advance-juc-thread-deadlock","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"JAVA","slug":"JAVA","count":12,"path":"api/categories/JAVA.json"}],"tags":[{"name":"thread","slug":"thread","count":2,"path":"api/tags/thread.json"},{"name":"lock","slug":"lock","count":1,"path":"api/tags/lock.json"},{"name":"并发编程","slug":"并发编程","count":5,"path":"api/tags/并发编程.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"分布式链路跟踪组件 SOFATracer 和 Zipkin 模型转换原理","uid":"e760e8eb6263e803ada2984a9066d5b1","slug":"sofa/sofa-tracer-zipkin-model-convert","date":"2018-11-10T04:33:56.000Z","updated":"2024-07-05T04:09:05.803Z","comments":true,"path":"api/articles/sofa/sofa-tracer-zipkin-model-convert.json","keywords":null,"cover":null,"text":" 分布式链路跟踪组件 SOFATracer 和 Zipkin 模型转换 ","permalink":"/post/sofa/sofa-tracer-zipkin-model-convert","photos":[],"count_time":{"symbolsCount":44,"symbolsTime":"1 mins."},"categories":[{"name":"SOFA","slug":"SOFA","count":9,"path":"api/categories/SOFA.json"}],"tags":[{"name":"分布式链路跟踪","slug":"分布式链路跟踪","count":4,"path":"api/tags/分布式链路跟踪.json"},{"name":"Tracer","slug":"Tracer","count":4,"path":"api/tags/Tracer.json"},{"name":"Zipkin","slug":"Zipkin","count":1,"path":"api/tags/Zipkin.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}