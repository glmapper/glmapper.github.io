{"title":"启动一个没有 main 函数的 java 程序","uid":"7765f5a7acd8dc6c589523580059b0dd","slug":"java/java-base-non-main","date":"2021-01-17T03:01:11.000Z","updated":"2024-07-05T04:09:05.764Z","comments":true,"path":"api/articles/java/java-base-non-main.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>原文：<a href=\"https://juejin.cn/post/6918637397857009677\">https://juejin.cn/post/6918637397857009677</a></p></blockquote>\n<p>作为一名 <code>JAVA</code> 开发者，不知道大家有没有去想过，<code>JAVA</code>  程序为什么一定要从 main 函数执行开始，其实关于这个话题，我大概从网上搜了下，其实不乏有 <strong>main 方法是我们学习Java语言学习的第一个方法，也是每个 java 使用者最熟悉的方法, 每个 Java 应用程序都必须有且仅有一个 main 方法</strong> 这种说法。那么真的是这样吗？今天就来聊聊这个事情。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"为什么-main-函数是-java-执行入口\"><a href=\"#为什么-main-函数是-java-执行入口\" class=\"headerlink\" title=\"为什么 main 函数是 java 执行入口\"></a>为什么 main 函数是 java 执行入口</h2><p>我们在通过一般的 IDE 去 debug 时，main 函数确实是在堆栈的最开始地方…</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9183d0987463436da7f3f8880364429a~tplv-k3u1fbpfcp-watermark.image\"></p>\n<p>但是如果你熟悉 SpringBoot 的启动过程，你会知道，你看到的 main 函数并不是真正开始执行启动的 main 函数，关于这点，我在之前 <a href=\"https://juejin.cn/post/6844903992330289165\">SpringBoot 系列-FatJar 启动原理</a> 这篇文章中有过说明；即使是通过 JarLaunch 启动，但是入口还是 main，只不过套了一层，然后反射去调用你应用的 main 方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JarLauncher</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ExecutableArchiveLauncher</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// BOOT-INF/classes/</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">BOOT_INF_CLASSES</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;BOOT-INF/classes/&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// BOOT-INF/lib/</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">BOOT_INF_LIB</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;BOOT-INF/lib/&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 空构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">JarLauncher</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 省略无关代码...</span></span><br><span class=\"line\">    <span class=\"comment\">// main 函数</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 引导启动入口</span></span><br><span class=\"line\">    \t<span class=\"keyword\">new</span> <span class=\"title class_\">JarLauncher</span>().launch(args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里抛开 JarLaunch 这种引导启动的方式，单从最普通 java 程序来看，我们来看下 main 函数作为入口的原因。</p>\n<h3 id=\"找的最开始、最遥远的地方\"><a href=\"#找的最开始、最遥远的地方\" class=\"headerlink\" title=\"找的最开始、最遥远的地方\"></a>找的最开始、最遥远的地方</h3><p>JDK 里面的代码太多了，如果在不清楚的情况下去找，那和大海捞针差不多；那我们想一下，既然 java 要去执行 main，首先它要找到这个 main，那 main 方法是写在我们代码里面的，所以对于 java 来说，它就不得不去先把我们包含 main 方法的类加载起来。所以：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50aa54a09cf64810bfe1670fb5c0546d~tplv-k3u1fbpfcp-watermark.image\"></p>\n<p>我们找到了 <code>LauncherHelper#checkAndLoadMain</code> 这个上一层入口；通过这个方法的代码注释，我们就知道了，网上关于介绍 main 作为启动方法的一系列验证是缘起何处了：</p>\n<ul>\n<li>可以从 fatjar manifest 中找到启动类的 classname</li>\n<li>使用 System ClassLoader 加载这个类</li>\n<li>验证这个启动类的合法性<ul>\n<li>这个类是否存在</li>\n<li>有没有 main 函数</li>\n<li>是不是 static 的</li>\n<li>是不是 public 的</li>\n<li>有没有 string 数组作为参数</li>\n</ul>\n</li>\n<li>如果没有 main 函数，那当前的这个类是不是继承了 FX Application（<strong>关键</strong>）</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>PS: 这里摘取一篇关于为什么是 public 的描述：JAVA 指定了一些可访问的修饰符如：private，protected，public。每个修饰符都有它对应的权限，public 权限最大，为了说明问题，我们假设 main 方法是用 private 修饰的，那么 main 方法出了 Demo 这个类对外是不可见的。那么，JVM 就访问不到 main 方法了。因此，为了保证JVM在任何情况下都可以访问到main方法，就用 public修饰</p></blockquote>\n<p>这个说法我个人理解是有点欠妥的，首先是 java 里面有反射机制，访问修饰符的存在在 JVM 规范里面说的最多的是因为<strong>安全</strong>问题，并不是 JVM 能不能访问的问题，因为 JVM 里面有一百种方式去访问一个 private。</p>\n<h3 id=\"LauncherHelper-被执行调用的地方\"><a href=\"#LauncherHelper-被执行调用的地方\" class=\"headerlink\" title=\"LauncherHelper 被执行调用的地方\"></a>LauncherHelper 被执行调用的地方</h3><p>从堆栈看，checkAndLoadMain 上层没有了，那猜测可能就是有底层 JVM（c 部分）来驱动的。继续去扒一下，在 jdk 的 java.c 文件中捞到了如下代码片段：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jclass <span class=\"title function_\">GetLauncherHelperClass</span><span class=\"params\">(JNIEnv *env)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (helperClass == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        NULL_CHECK0(helperClass = FindBootStrapClass(env,</span><br><span class=\"line\">                <span class=\"string\">&quot;sun/launcher/LauncherHelper&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> helperClass;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这也论证了前面的猜测，确实是由底层来驱动执行的。那么既然都看到这里了，也有必要看下我们的 JAVA 程序启动、JVM 启动过程是怎样的。</p>\n<h2 id=\"JVM-是如何驱动-JAVA-程序执行的\"><a href=\"#JVM-是如何驱动-JAVA-程序执行的\" class=\"headerlink\" title=\"JVM 是如何驱动 JAVA 程序执行的\"></a>JVM 是如何驱动 JAVA 程序执行的</h2><p>这里我的思路还是从可以见的代码及堆栈一层一层往上去拨的，通过 GetLauncherHelperClass 找到了 LoadMainClass，后面再找打整体启动入口。</p>\n<h3 id=\"LoadMainClass\"><a href=\"#LoadMainClass\" class=\"headerlink\" title=\"LoadMainClass\"></a>LoadMainClass</h3><p>下面是代码（代码的可读性和理解要比文字更直接）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Loads a class and verifies that the main class is present and it is ok to</span></span><br><span class=\"line\"><span class=\"comment\"> * call it for more details refer to the java implementation.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">static</span> jclass <span class=\"title function_\">LoadMainClass</span><span class=\"params\">(JNIEnv *env, <span class=\"type\">int</span> mode, <span class=\"type\">char</span> *name)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    jmethodID mid;</span><br><span class=\"line\">    jstring str;</span><br><span class=\"line\">    jobject result;</span><br><span class=\"line\">    jlong start, end;</span><br><span class=\"line\">    <span class=\"comment\">// 去找到 LauncherHelper</span></span><br><span class=\"line\">    jclass cls = GetLauncherHelperClass(env);</span><br><span class=\"line\">    NULL_CHECK0(cls);</span><br><span class=\"line\">    <span class=\"comment\">// 根据 _JAVA_LAUNCHER_DEBUG 环境变量决策是否设置来打印 debug 信息</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (JLI_IsTraceLauncher()) &#123;</span><br><span class=\"line\">        start = CounterGet();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这里可以看到就是调用 LauncherHelper#checkAndLoadMain 的入口</span></span><br><span class=\"line\">    NULL_CHECK0(mid = (*env)-&gt;GetStaticMethodID(env, cls,</span><br><span class=\"line\">                <span class=\"string\">&quot;checkAndLoadMain&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;(ZILjava/lang/String;)Ljava/lang/Class;&quot;</span>));</span><br><span class=\"line\">\t<span class=\"comment\">// 创建类名的 String 对象，也就是我们的启动类名</span></span><br><span class=\"line\">    str = NewPlatformString(env, name);</span><br><span class=\"line\">    <span class=\"comment\">// 调用静态对象方法 -&gt; main</span></span><br><span class=\"line\">    result = (*env)-&gt;CallStaticObjectMethod(env, cls, mid, USE_STDERR, mode, str);</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (JLI_IsTraceLauncher()) &#123;</span><br><span class=\"line\">        end   = CounterGet();</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%ld micro seconds to load main class\\n&quot;</span>,</span><br><span class=\"line\">               (<span class=\"type\">long</span>)(jint)Counter2Micros(end-start));</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;----%s----\\n&quot;</span>, JLDEBUG_ENV_ENTRY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (jclass)result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Java-程序的-Entry-point\"><a href=\"#Java-程序的-Entry-point\" class=\"headerlink\" title=\"Java 程序的 Entry point\"></a>Java 程序的 Entry point</h3><p>对于 C&#x2F;C++ 来说，其启动入口和 java 一样，也都是 main。下面我们略过一些无关代码，将 JAVA 程序驱动启动的核心流程代码梳理下</p>\n<p>1、入口，main.c 的 main 方法 -&gt; JLI_Launch</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> **argv)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 省略其他代码 ... </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> JLI_Launch(margc, margv,</span><br><span class=\"line\">                   sizeof(const_jargs) / sizeof(<span class=\"type\">char</span> *), const_jargs,</span><br><span class=\"line\">                   sizeof(const_appclasspath) / sizeof(<span class=\"type\">char</span> *), const_appclasspath,</span><br><span class=\"line\">                   FULL_VERSION,</span><br><span class=\"line\">                   DOT_VERSION,</span><br><span class=\"line\">                   (const_progname != NULL) ? const_progname : *margv,</span><br><span class=\"line\">                   (const_launcher != NULL) ? const_launcher : *margv,</span><br><span class=\"line\">                   (const_jargs != NULL) ? JNI_TRUE : JNI_FALSE,</span><br><span class=\"line\">                   const_cpwildcard, const_javaw, const_ergo_class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、JLI_Launch，JVM 的实际 Entry point</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Entry point.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"title function_\">JLI_Launch</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> ** argv,              <span class=\"comment\">/* main argc, argc */</span></span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"type\">int</span> jargc, <span class=\"type\">const</span> <span class=\"type\">char</span>** jargv,          <span class=\"comment\">/* java args */</span></span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"type\">int</span> appclassc, <span class=\"type\">const</span> <span class=\"type\">char</span>** appclassv,  <span class=\"comment\">/* app classpath */</span></span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"type\">const</span> <span class=\"type\">char</span>* fullversion,                <span class=\"comment\">/* full version defined */</span></span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"type\">const</span> <span class=\"type\">char</span>* dotversion,                 <span class=\"comment\">/* dot version defined */</span></span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"type\">const</span> <span class=\"type\">char</span>* pname,                      <span class=\"comment\">/* program name */</span></span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"type\">const</span> <span class=\"type\">char</span>* lname,                      <span class=\"comment\">/* launcher name */</span></span></span><br><span class=\"line\"><span class=\"params\">        jboolean javaargs,                      <span class=\"comment\">/* JAVA_ARGS */</span></span></span><br><span class=\"line\"><span class=\"params\">        jboolean cpwildcard,                    <span class=\"comment\">/* classpath wildcard*/</span></span></span><br><span class=\"line\"><span class=\"params\">        jboolean javaw,                         <span class=\"comment\">/* windows-only javaw */</span></span></span><br><span class=\"line\"><span class=\"params\">        jint ergo                               <span class=\"comment\">/* ergonomics class policy */</span></span></span><br><span class=\"line\"><span class=\"params\">)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略无关代码</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// main class</span></span><br><span class=\"line\">    <span class=\"type\">char</span> *main_class = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"comment\">// jvm 路径</span></span><br><span class=\"line\">    <span class=\"type\">char</span> jvmpath[MAXPATHLEN];</span><br><span class=\"line\">    <span class=\"comment\">// jre 路径</span></span><br><span class=\"line\">    <span class=\"type\">char</span> jrepath[MAXPATHLEN];</span><br><span class=\"line\">    <span class=\"comment\">// jvm 配置路径</span></span><br><span class=\"line\">    <span class=\"type\">char</span> jvmcfg[MAXPATHLEN];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 省略无关代码 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 选择运行时 jre 的版本，会有一些规则</span></span><br><span class=\"line\">    SelectVersion(argc, argv, &amp;main_class);</span><br><span class=\"line\">    <span class=\"comment\">// 创建执行环境，包括找到 JRE、确定 JVM 类型、初始化 jvmpath 等等</span></span><br><span class=\"line\">    CreateExecutionEnvironment(&amp;argc, &amp;argv,</span><br><span class=\"line\">                               jrepath, <span class=\"keyword\">sizeof</span>(jrepath),</span><br><span class=\"line\">                               jvmpath, <span class=\"keyword\">sizeof</span>(jvmpath),</span><br><span class=\"line\">                               jvmcfg,  <span class=\"keyword\">sizeof</span>(jvmcfg));</span><br><span class=\"line\">    <span class=\"comment\">// 省略无关代码 ...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 从 jvmpath load 一个 jvm</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!LoadJavaVM(jvmpath, &amp;ifn)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>(<span class=\"number\">6</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 设置 classpath</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">   \t<span class=\"comment\">// 解析参数，如 -classpath、-jar、-version、-verbose:gc .....</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ParseArguments(&amp;argc, &amp;argv, &amp;mode, &amp;what, &amp;ret, jrepath))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>(ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* java -jar 启动的话，要覆盖 class path */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mode == LM_JAR) &#123;</span><br><span class=\"line\">        SetClassPath(what);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"comment\">// 省略无关代码 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> JVMInit(&amp;ifn, threadStackSize, argc, argv, mode, what, ret);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JVMInit\"><a href=\"#JVMInit\" class=\"headerlink\" title=\"JVMInit\"></a>JVMInit</h3><p>JVMInit 对于不同的操作系统有不同的实现，这里以 linux 的实现为例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">JVMInit</span><span class=\"params\">(InvocationFunctions* ifn, jlong threadStackSize,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"type\">int</span> argc, <span class=\"type\">char</span> **argv,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"type\">int</span> mode, <span class=\"type\">char</span> *what, <span class=\"type\">int</span> ret)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ShowSplashScreen();</span><br><span class=\"line\">    <span class=\"comment\">// 新线程的入口函数进行执行，新线程创建失败就在原来的线程继续支持这个函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ContinueInNewThread(ifn, threadStackSize, argc, argv, mode, what, ret);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里比较深，ContinueInNewThread 里面又使用了一个 ContinueInNewThread0，从代码解释来看，大概意思是：先把当前线程阻塞，然后使用一个新的线程去执行，如果新线程创建失败就在原来的线程继续支持这个函数。核心代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rslt = ContinueInNewThread0(JavaMain, threadStackSize, (<span class=\"type\">void</span>*)&amp;args);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JavaMain\"><a href=\"#JavaMain\" class=\"headerlink\" title=\"JavaMain\"></a>JavaMain</h3><p>1、这里第一个比较关键的就是 InitializeJVM，初始化创建一个 Java Virtual Machine（jvm.so -&gt; CreateJavaVM 代码比较多，实际上真正的初始化和启动jvm，是由 jvm.so 中的JNI_CreateJavaVM 实现）。</p>\n<p>2、接下来就是到我们前面反推到的 LoadMainClass 了，找到我们真正 java 程序的入口类，就是我们应用程序带有 main 函数的类。</p>\n<p>3、获取应用程序 Class -&gt; GetApplicationClass，这里简单说下，因为和最后的那个 demo 有关，也和本文的题目有关。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在某些情况下，当启动一个需要助手的应用程序时，</span></span><br><span class=\"line\"><span class=\"comment\">// 例如，一个没有主方法的 JavaFX 应用程序，mainClass将不是应用程序自己的主类，</span></span><br><span class=\"line\"><span class=\"comment\">// 而是一个助手类</span></span><br><span class=\"line\">appClass = GetApplicationClass(env);</span><br></pre></td></tr></table></figure>\n\n<p>4、调用 main 函数执行应用进程启动</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"简单回顾\"><a href=\"#简单回顾\" class=\"headerlink\" title=\"简单回顾\"></a>简单回顾</h3><p>对于平常我们常见的 java 应用程序来说，main 函数确实作为执行入口，这个是有底层 JVM 驱动执行逻辑决定。但是从整个分析过程也可以看出，main 函数并不是唯一一种入口，那就是以非 main 入口启动的方式，也就是 JavaFX。</p>\n<h2 id=\"使用-FX-Application-方式启动-java-程序\"><a href=\"#使用-FX-Application-方式启动-java-程序\" class=\"headerlink\" title=\"使用 FX Application 方式启动 java 程序\"></a>使用 FX Application 方式启动 java 程序</h2><p>JAVA GUI 的旅程开始于 AWT，后来被一个更好的 GUI 框架所取代，其被称为 Swing。Swing 在GUI 领域有将近 20 年的历史。但是，它缺乏许多当今需求的视觉功能，其不仅要求可在多个设备上运行，还要有很好的外观和感觉。在 JAVA GUI 领域最有前景的是JavaFX，JAVA 自带的三个 GUI 工具包–AWT，Swing，和 JavaFX  – 它们做几乎相同的工作。而 JavaFX 使用一些不同的方法进行 GUI 编程，本文不针对 JavaFX 展开细说，有兴趣的同学可以自行查阅。</p>\n<p>每一个 JavaFX 应用程序是应用程序类的扩展，其提供了应用程序执行的入口点。一个独立的应用程序通常是通过调用这个类定义的静态方法来运行的。应用程序类定义了三个生命周期的方法：init()， start() 和 stop()。</p>\n<p>那么结合上一节中关于启动入口的讨论，这里给出一个小 demo 来把一个 springboot 工程启动起来（基于 ide，java -jar 可能会有区别，这里未验证）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Log4j2GuidesApplication</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Application</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// main -&gt; mains</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">mains</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        SpringApplication.run(Log4j2GuidesApplication.class, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;222&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">(Stage stage)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        mains(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;111&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/749198d9ed57499988254024f6efbae6~tplv-k3u1fbpfcp-watermark.image\"></p>\n<p>这里有一个有意思的情况，一般情况下，如果没有非守护线程存活（通常是 web 模块提供）时进程会在启动完之后就退出，但是这里我没有开启 web 端口，但是启动完时，进程并没有退出，即使在 start 里面抛出异常，也不能显示的去阻断，这和 JavaFX Application 的生命周期有关，前面有提到。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>JAVA 应用的启动不一定是非要是 main 作为入口，关于其他的引导启动方式没有继续调研，如果大家有知道其他方式，也欢迎留言补充。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.qiqee.net/single?id=179\">理解基本的 JavaFX 类，并知道如何使用它们</a></li>\n</ul>\n","text":" 原文：https://juejin.cn/post/6918637397857009677 作为一名 JAVA 开发者，不知道大家有没有去想过，JAVA 程序...","permalink":"/post/java/java-base-non-main","photos":[],"count_time":{"symbolsCount":"8.8k","symbolsTime":"8 mins."},"categories":[{"name":"JAVA","slug":"JAVA","count":12,"path":"api/categories/JAVA.json"}],"tags":[{"name":"java","slug":"java","count":5,"path":"api/tags/java.json"},{"name":"FX Application","slug":"FX-Application","count":1,"path":"api/tags/FX-Application.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88-main-%E5%87%BD%E6%95%B0%E6%98%AF-java-%E6%89%A7%E8%A1%8C%E5%85%A5%E5%8F%A3\"><span class=\"toc-text\">为什么 main 函数是 java 执行入口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%BE%E7%9A%84%E6%9C%80%E5%BC%80%E5%A7%8B%E3%80%81%E6%9C%80%E9%81%A5%E8%BF%9C%E7%9A%84%E5%9C%B0%E6%96%B9\"><span class=\"toc-text\">找的最开始、最遥远的地方</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#LauncherHelper-%E8%A2%AB%E6%89%A7%E8%A1%8C%E8%B0%83%E7%94%A8%E7%9A%84%E5%9C%B0%E6%96%B9\"><span class=\"toc-text\">LauncherHelper 被执行调用的地方</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JVM-%E6%98%AF%E5%A6%82%E4%BD%95%E9%A9%B1%E5%8A%A8-JAVA-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%9A%84\"><span class=\"toc-text\">JVM 是如何驱动 JAVA 程序执行的</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#LoadMainClass\"><span class=\"toc-text\">LoadMainClass</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Java-%E7%A8%8B%E5%BA%8F%E7%9A%84-Entry-point\"><span class=\"toc-text\">Java 程序的 Entry point</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JVMInit\"><span class=\"toc-text\">JVMInit</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JavaMain\"><span class=\"toc-text\">JavaMain</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E5%9B%9E%E9%A1%BE\"><span class=\"toc-text\">简单回顾</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-FX-Application-%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8-java-%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">使用 FX Application 方式启动 java 程序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"聊一聊 maven 生命周期和 maven 插件编写","uid":"366cd935770e27ff74dc4ef2425c6648","slug":"maven/maven-plugin-lifecycle-program","date":"2021-01-19T03:05:33.000Z","updated":"2024-07-05T04:09:05.782Z","comments":true,"path":"api/articles/maven/maven-plugin-lifecycle-program.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"text":" 原文：https://juejin.cn/post/6919490393893502984 最近接到一个业务同学的诉求：用户会在他们大数据平台新建很多模型表，...","permalink":"/post/maven/maven-plugin-lifecycle-program","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"maven","slug":"maven","count":4,"path":"api/categories/maven.json"}],"tags":[{"name":"maven","slug":"maven","count":4,"path":"api/tags/maven.json"},{"name":"maven plugin","slug":"maven-plugin","count":3,"path":"api/tags/maven-plugin.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"JAVA 进程被 kill 排查","uid":"ac12a67b37981f610a8117ecfb8572d8","slug":"jvm/jvm-problem-command","date":"2021-01-06T08:06:55.000Z","updated":"2024-07-05T04:09:05.769Z","comments":true,"path":"api/articles/jvm/jvm-problem-command.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":null,"text":"可能会导致 JAVA 进程被 kill 的原因 Java 应用程序的问题：发生 OOM 导致进程 Crash JVM 自身故障：JVM 或J DK 自身的 Bu...","permalink":"/post/jvm/jvm-problem-command","photos":[],"count_time":{"symbolsCount":994,"symbolsTime":"1 mins."},"categories":[{"name":"jvm","slug":"jvm","count":6,"path":"api/categories/jvm.json"}],"tags":[{"name":"jvm","slug":"jvm","count":6,"path":"api/tags/jvm.json"},{"name":"OOM","slug":"OOM","count":2,"path":"api/tags/OOM.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}