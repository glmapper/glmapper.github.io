{"title":"聊一聊 CopyOnWriteArraySet 的迭代删除","uid":"90702231598ae749367712a968e7c7e3","slug":"java/java-base-iterator-of-set","date":"2020-03-16T08:20:38.000Z","updated":"2024-07-05T04:09:05.763Z","comments":true,"path":"api/articles/java/java-base-iterator-of-set.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":null,"content":"<p>上周在工程中涉及到一个清理 <code>Set</code> 集合的操作，将满足设定条件的项从 <code>Set</code> 中删除掉。简化版本代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    Set&lt;String&gt; sets = <span class=\"keyword\">new</span> <span class=\"title class_\">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class=\"line\">    sets.add(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">    sets.add(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\">    sets.add(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\">    sets.add(<span class=\"string\">&quot;4&quot;</span>);</span><br><span class=\"line\">    Iterator&lt;String&gt; iterator = sets.iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (iterator.hasNext())&#123;</span><br><span class=\"line\">        iterator.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(sets);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这个看起来是个很常规的问题，没有验证就直接发了线下环境，然后就收到了业务方反馈的服务无法正常使用的问题了。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"问题现象\"><a href=\"#问题现象\" class=\"headerlink\" title=\"问题现象\"></a>问题现象</h3><p>先来看下上述代码所抛出的异常：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread <span class=\"string\">&quot;main&quot;</span> java.lang.UnsupportedOperationException</span><br><span class=\"line\">\tat java.util.concurrent.CopyOnWriteArrayList$COWIterator.remove(CopyOnWriteArrayList.java:<span class=\"number\">1178</span>)</span><br><span class=\"line\">\tat com.glmapper.bridge.boot.TestMain.main(TestMain.java:<span class=\"number\">21</span>)</span><br></pre></td></tr></table></figure>\n\n<p>关于 <code>UnsupportedOperationException</code> 这个异常没有什么好说的，在集合操作中经常出现，网上也有很多关于这个异常的说明，这里不再赘述。这里我比较关注的是，我使用的是 <code>CopyOnWriteArraySet</code>，迭代器也是 <code>sets</code> 的，但是异常中居然出现了<code>CopyOnWriteArrayList</code>，查看了 <code>CopyOnWriteArraySet</code> 的类继承关系，和 <code>CopyOnWriteArrayList</code> 也没啥关系。</p>\n<h3 id=\"排查-结果\"><a href=\"#排查-结果\" class=\"headerlink\" title=\"排查&amp;结果\"></a>排查&amp;结果</h3><p>通过查看了 <code>CopyOnWriteArraySet</code> 的代码，发现 <code>CopyOnWriteArraySet</code> 内部其实是持有了一个 <code>CopyOnWriteArrayList</code> 的对象实例，其内部的所有操作都是基于 <code>CopyOnWriteArrayList</code> 这个对象来进行的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CopyOnWriteArraySet</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractSet</span>&lt;E&gt;</span><br><span class=\"line\">        <span class=\"keyword\">implements</span> <span class=\"title class_\">java</span>.io.Serializable &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略其他代码</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * Creates an empty set.</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">CopyOnWriteArraySet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        al = <span class=\"keyword\">new</span> <span class=\"title class_\">CopyOnWriteArrayList</span>&lt;E&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 省略其他代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"关于-CopyOnWriteArrayList-的操作\"><a href=\"#关于-CopyOnWriteArrayList-的操作\" class=\"headerlink\" title=\"关于 CopyOnWriteArrayList 的操作\"></a>关于 CopyOnWriteArrayList 的操作</h3><p><strong>写操作</strong></p>\n<p>在 <code>CopyOnWriteArrayList</code> 里处理写操作（包括 <code>add、remove、set</code> 等）是先将原始的数据通过 <code>JDK1.6</code> 的 <code>Arrays.copyof()</code> 来生成一份新的数组。<code>add</code> 的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.lock;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Object[] elements = getArray();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> elements.length;</span><br><span class=\"line\">        <span class=\"comment\">// 这里是生产新的数组</span></span><br><span class=\"line\">        Object[] newElements = Arrays.copyOf(elements, len + <span class=\"number\">1</span>);</span><br><span class=\"line\">        newElements[len] = e;</span><br><span class=\"line\">        setArray(newElements);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>后续的操作都是在新的数据对象上进行写，写完后再将原来的引用指向到当前这个数据对象，这样保证了每次写都是在新的对象上（因为要保证写的一致性，这里要对各种写操作要加一把锁，JDK1.6 在这里用了重入锁），</p>\n<p><strong>读操作</strong></p>\n<p>读的时候就是在引用的当前对象上进行读（包括 <code>get，iterator</code> 等），不存在加锁和阻塞，针对 <code>iterator</code> 使用了一个叫 <code>COWIterator</code> 的简化版迭代器，因为不支持写操作，当获取 <code>CopyOnWriteArrayList</code> 的迭代器时，是将迭代器里的数据引用指向当前引用指向的数据对象，无论未来发生什么写操作，都不会再更改迭代器里的数据对象引用，所以迭代器也很安全。</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>因为 <code>CopyOnWriteArraySet</code> 的内部操作都是基于 <code>CopyOnWriteArrayList</code> 的，从异常来看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.util.concurrent.CopyOnWriteArrayList$COWIterator.remove(CopyOnWriteArrayList.java:<span class=\"number\">1178</span>)</span><br></pre></td></tr></table></figure>\n<p><code>COWIterator</code> 是 <code>CopyOnWriteArrayList</code> 内部提供的一个简化版的迭代器。所以异常里面出现这个就理所应当了。在来看下 <code>COWIterator</code> 这里简化版的迭代器的 <code>remove</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Not supported. Always throws UnsupportedOperationException.</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@throws</span> UnsupportedOperationException always; &#123;<span class=\"doctag\">@code</span> remove&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*         is not supported by this iterator.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">remove</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里实际上是直接就会抛出异常的，另外这里在多补充一个关于 <code>HashSet</code> 的迭代器移除，<code>HashSet</code> 其实内部是持有的 <code>HashMap</code> 实例，因此它的迭代器是 <code>HashMap</code> 内部提供的 <code>HashIterator</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">remove</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; p = current;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (modCount != expectedModCount)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentModificationException</span>();</span><br><span class=\"line\">    current = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"type\">K</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> p.key;</span><br><span class=\"line\">    removeNode(hash(key), key, <span class=\"literal\">null</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    expectedModCount = modCount;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里其实也可以看到，在对非安全的集合做 <code>remove</code> 操作时会经常遇到的 <code>ConcurrentModificationException</code> 这个异常。</p>\n","text":"上周在工程中涉及到一个清理 Set 集合的操作，将满足设定条件的项从 Set 中删除掉。简化版本代码如下： 123456789101112public stat...","permalink":"/post/java/java-base-iterator-of-set","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"JAVA","slug":"JAVA","count":12,"path":"api/categories/JAVA.json"}],"tags":[{"name":"set","slug":"set","count":1,"path":"api/tags/set.json"},{"name":"迭代器","slug":"迭代器","count":1,"path":"api/tags/迭代器.json"},{"name":"CopyOnWriteArraySet","slug":"CopyOnWriteArraySet","count":1,"path":"api/tags/CopyOnWriteArraySet.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E7%8E%B0%E8%B1%A1\"><span class=\"toc-text\">问题现象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%92%E6%9F%A5-%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">排查&amp;结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E-CopyOnWriteArrayList-%E7%9A%84%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">关于 CopyOnWriteArrayList 的操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E8%AE%BA\"><span class=\"toc-text\">结论</span></a></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"解决方案系列-基于 SOFAArk 实现应用的动态装载和卸载","uid":"29bf6d756e74758621dce6f471f701c6","slug":"solutions/solution-series-dynamic-module","date":"2020-04-03T08:12:22.000Z","updated":"2024-07-05T04:09:05.811Z","comments":true,"path":"api/articles/solutions/solution-series-dynamic-module.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"text":" 原文链接：解决方案系列-基于 SOFAArk 实现应用的动态装载和卸载 本篇主要来看下蚂蚁金服开源的 SOFAArk 这个产品。SOFAArk 是一款基于 J...","permalink":"/post/solutions/solution-series-dynamic-module","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"解决方案","slug":"解决方案","count":5,"path":"api/categories/解决方案.json"}],"tags":[{"name":"ClassLoader","slug":"ClassLoader","count":4,"path":"api/tags/ClassLoader.json"},{"name":"SOFAArk","slug":"SOFAArk","count":4,"path":"api/tags/SOFAArk.json"},{"name":"架构","slug":"架构","count":4,"path":"api/tags/架构.json"},{"name":"SOFAStack","slug":"SOFAStack","count":1,"path":"api/tags/SOFAStack.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"SpringBoot 实践系列-Filter 中的异常处理和 Controller 中的异常处理","uid":"0df03a60d15d7b7ab424fe228bc8cf70","slug":"springboot/springboot-series-filter-exception","date":"2020-02-12T08:24:11.000Z","updated":"2024-07-05T04:09:05.829Z","comments":true,"path":"api/articles/springboot/springboot-series-filter-exception.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":null,"text":"本篇主要是记录如何使用 SpringBoot 所提供的 ErrorController 这个接口能力；其内置了一个 BasicErrorController 对...","permalink":"/post/springboot/springboot-series-filter-exception","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/categories/SpringBoot.json"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/tags/SpringBoot.json"},{"name":"Exception","slug":"Exception","count":1,"path":"api/tags/Exception.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}