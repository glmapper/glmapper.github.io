{"title":"关于 rpc 的整理和理解","uid":"80757c505c28d656f4a66a57e05f0132","slug":"middleware/middleware-rpc-about","date":"2018-11-12T13:22:44.000Z","updated":"2024-07-05T04:09:05.790Z","comments":true,"path":"api/articles/middleware/middleware-rpc-about.json","keywords":null,"cover":[],"content":"<p>RPC 的主要目标就是为了让构建分布式计算（应用）变得更加简单，在提供强大的远程调用能力时不损失本地调用的语义简洁性。 为实现该目标，RPC 框架需提供一种透明调用机制让使用者不必显式的区分本地调用和远程调用。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"架构演变\"><a href=\"#架构演变\" class=\"headerlink\" title=\"架构演变\"></a>架构演变</h1><ul>\n<li><p>所有的界面和服务均在同一个进程下<br><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/3/11/1621576f8c29c490~tplv-t2oaga2asx-image.image\"></p>\n</li>\n<li><p>基于mvc的视图与服务分离，但是实际上还是在一个应用系统中，只不过在功能层次上划分的更加细致<br><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/3/11/16215773671e27af~tplv-t2oaga2asx-image.image\"></p>\n</li>\n<li><p>粒度更细，对于不同的功能服务进行切分，并进行单独的部署<br><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/3/11/1621577911209db2~tplv-t2oaga2asx-image.image\"></p>\n</li>\n<li><p>面向服务的架构，将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来<br><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/3/11/1621577ae54199ff~tplv-t2oaga2asx-image.image\"></p>\n</li>\n<li><p>微服务</p>\n<p>  此处不支持图片展示，自行脑补！！！</p>\n</li>\n</ul>\n<p>随着业务量和用户量的增加，架构也是从单一系统走向分布式系统，我能想到的是，这种架构的演变主要解决的问题在于：</p>\n<ul>\n<li>通过业务模块的拆分，使得每个模块的职责更加清晰，但是模块的职责边界的划分往往也是很疼头的事情。</li>\n<li>细致的划分使得项目在管理上面会更加方面，从代码的角度来说，开发和维护的成本也会降低，不会因为一个bug去跑整个项目了。</li>\n<li>提高了系统的容错率，单一系统如果宕机那就真的gg了，另外就是，单个环节出现问题也会导致项目无法正常运行（比如数据库出问题了）。对于分布式系统来说，一般都会使用冗余的方式来提高可用性，个人理解就是可以提供多个一样的服务，它们之间可以进行切换。</li>\n<li>分布式系统带来的问题一个是成本，硬件成本，运维成本都会增加。</li>\n</ul>\n<h1 id=\"rpc简介及常用的rpc框架\"><a href=\"#rpc简介及常用的rpc框架\" class=\"headerlink\" title=\"rpc简介及常用的rpc框架\"></a>rpc简介及常用的rpc框架</h1><p>随着集中式架构向分布式架构的转变，应用系统之间的服务调用与通讯问题成为了首要解决的需求。</p>\n<p><strong>而RPC 的主要目标就是为了让构建分布式计算（应用）变得更加简单，在提供强大的远程调用能力时不损失本地调用的语义简洁性。 为实现该目标，RPC 框架需提供一种透明调用机制让使用者不必显式的区分本地调用和远程调用。</strong></p>\n<p>如下代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   @Autowired</span><br><span class=\"line\">private GlRpcAgent glRpcAgent; //rpc代理</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @param param 此处约定参数以Map键值对的形式传递</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public List&lt;OrderInfo&gt; queryOrdersByUserId(Map&lt;String, Object&gt; param) &#123;</span><br><span class=\"line\">\t//创建远程调用代理（远程服务的类的全限定名）</span><br><span class=\"line\">\tOrderConsumeAgent orderConsumer=glRpcAgent.getAgent(&quot;com.glmapper.rpc.interface.OrderConsumeInterface&quot;);</span><br><span class=\"line\">\t//通过代理获取返回结果  此处getOrders为远程服务器上的com.glmapper.rpc.interface.OrderConsumeInterface接口中的方法，param为参数</span><br><span class=\"line\">\tMap&lt;String,Object&gt; resultMap=(Map)orderConsumer.call(&quot;getOrders&quot;,param);</span><br><span class=\"line\">\t//解析返回结果（远程方法同样以Map集合的方式放回）</span><br><span class=\"line\">\tList&lt;OrderInfo&gt; orders = parseResultMap(resultMap);</span><br><span class=\"line\">\treturn orders;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为什么要以全限定名来获取呢，这个我们将会在后面来说。</p>\n<h2 id=\"什么是RPC\"><a href=\"#什么是RPC\" class=\"headerlink\" title=\"什么是RPC\"></a>什么是RPC</h2><p>In distributed computing a remote procedure call (RPC) is when a computer program causes a procedure (subroutine) to execute in another address space(commonly on another computer on a shared network), which is coded as if it were a normal (local) procedure call, without the programmer explicitly coding the details for the remote interaction.<br>RPC 的全称是 Remote Procedure Call 是一种<strong>进程间通信</strong>方式。 它允许程序调用另一个进程上（通常是共享网络的另一台机器上）的过程或函数，而<strong>不用程序员显式编码这个远程调用的细节</strong>。即程序员<strong>无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同</strong>。</p>\n<p>从定义中可以得知，RPC主要来解决三件事情：</p>\n<ul>\n<li>进程间通讯</li>\n<li>提供和本地方法调用一样的调用机制</li>\n<li>屏蔽程序员对远程调用的细节实现</li>\n</ul>\n<p>首先是进程间的通信问题，对于分布式环境，rpc能够帮助我们解决不同服务器之间的通信及数据传输问题，即<strong>做好方法调用到数据的转换，然后借助网络进行数据传递；</strong>rpc客户端向rpc服务端发起远程服务调用，通过请求的封装，参数的封装，序列化、编码、约定协议传输、解析请求、处理请求、封装返回消息数据、在进行返回数据的序列化、编码、在通过网络返回给客户端。再者是提供和本地方法调用一样的调用机制，为什么这么说，对于业务系统来说，我们更多的关注点在于如何解决实际的业务需求问题，而不想花更多的时间和心思在诸如上述过程中关于网络传输及编解码过程，因此对于rpc来说，需要将这些编解码、协议约定、网络传输等进行一个整体的封装，然后只向业务系统提供最简单的调用方式。最后一个屏蔽程序员对远程调用的细节实现，其实也就是第二点中提到的那些功能的封装，我们不用去关系rpc到底是如何实现的，也不用关心它是如何运作的，对于业务开发人员来说，通过约定的方式进行类似于本地方法调用的形式来调用远程服务接口就可以了。<br><strong>那么如何实现透明化的远程调用呢？</strong><br><strong>什么样的内部封装才能让我们觉得像以本地调用方式调用远程服务呢？</strong><br>对于java来说就是使用代理。java代理有两种方式：1） jdk 动态代理（接口代理）；2）cglib代理（子类代理）。尽管字节码生成方式实现的代理更为强大和高效，但代码不易维护，大部分公司实现RPC框架时还是选择动态代理方式。这部分也将会在后续的章节中展开来说。</p>\n<h2 id=\"RPC基本原理\"><a href=\"#RPC基本原理\" class=\"headerlink\" title=\"RPC基本原理\"></a>RPC基本原理</h2><p>上面说到，rpc需要对一些远程调用的内部实现进行封装。我们说到有以下几个点：</p>\n<ul>\n<li>序列化</li>\n<li>编解码</li>\n<li>协议</li>\n<li>网络</li>\n</ul>\n<p>从发起远程调用到接收到数据返回结果，大致过程是：</p>\n<p>1）服务消费方（client）调用以本地调用方式调用服务；<br>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；<br>3）client stub找到服务地址，并将消息发送到服务端；<br>4）server stub收到消息后进行解码；<br>5）server stub根据解码结果调用本地的服务；<br>6）本地服务执行并将结果返回给server stub；<br>7）server stub将返回结果打包成消息并发送至消费方；<br>8）client stub接收到消息，并进行解码；<br>9）服务消费方得到最终结果。</p>\n<p>那么rpc就相当于将step2-step8的步骤进行了封装。下面借用一张网上的图片来帮助我们理解这个过程。</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/23/15fe93fb307ec7e9~tplv-t2oaga2asx-image.image\"></p>\n<h2 id=\"RPC模型\"><a href=\"#RPC模型\" class=\"headerlink\" title=\"RPC模型\"></a>RPC模型</h2><p>对于上图，我们进行进一步的拆解得到（来自网络）：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/23/15fe94c7fd4edb39~tplv-t2oaga2asx-image.image\"><br>RPC 服务端通过 RpcServer 去暴露服务接口，而客户端通过 RpcClient 去获取服务接口。客户端像调用本地方法一样去调用远程接口方法，RPC 框架提供接口的代理实现，实际的调用将委托给代理 RpcProxy。代理封装调用信息并将调用转交给 RpcInvoker 去实际执行。在客户端的 RpcInvoker 通过连接器 RpcConnector 去维持与服务端的通道 RpcChannel，并使用 RpcProtocol 执行协议编码（encode）并将编码后的请求消息通过通道发送给服务端。RPC 服务端接收器 RpcAcceptor接收客户端的调用请求，同样使用 RpcProtocol 执行协议解码（decode）。<br>解码后的调用信息传递给 RpcProcessor 去控制处理调用过程，最后再委托调用给 RpcInvoker 去实际执行并返回调用结果。</p>\n<p>通过上述分析可知，这里面包括以下核心组件：</p>\n<ul>\n<li>用于暴露服务接口的RpcServer </li>\n<li>用于发现服务接口的RpcClient </li>\n<li>远程接口的代理实现RpcProxy </li>\n<li>负责协议编解码的RpcProtocol（实际的rpc框架中一般会提供多种不同的实现）</li>\n<li>网络连接器<br>（之前看过一篇文章说9个组件，对于咱们这个来说，部分模块可以集成在client和server中）</li>\n</ul>\n<h2 id=\"常见的RPC框架\"><a href=\"#常见的RPC框架\" class=\"headerlink\" title=\"常见的RPC框架\"></a>常见的RPC框架</h2><p>目前常见的分布式RPC框架有以下几个：</p>\n<ul>\n<li>dubbo<br>阿里巴巴公司开源的一个Java高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成</li>\n<li>motan<br>新浪微博开源的一个Java 框架。它诞生的比较晚，起于2013年，2016年5月开源。Motan 在微博平台中已经广泛应用，每天为数百个服务完成近千亿次的调用。</li>\n<li>rpcx<br>Go语言生态圈的Dubbo， 比Dubbo更轻量，实现了Dubbo的许多特性，借助于Go语言优秀的并发特性和简洁语法，可以使用较少的代码实现分布式的RPC服务。</li>\n<li>gRPC<br>Google开发的高性能、通用的开源RPC框架，主要面向移动应用开发并基于HTTP&#x2F;2协议标准而设计，基于ProtoBuf(Protocol Buffers)序列化协议开发，且支持众多开发语言。本身它不是分布式的，所以要实现上面的框架的功能需要进一步的开发。</li>\n<li>thrift<br>Apache的一个跨语言的高性能的服务框架</li>\n</ul>\n<h2 id=\"RPC与MQ\"><a href=\"#RPC与MQ\" class=\"headerlink\" title=\"RPC与MQ\"></a>RPC与MQ</h2><p>MQ(message queue)消息队列，从某种程度上来说，同样可以实现RPC的功能。从功能特点上来说，MQ可以把消息存储，而RPC不行。关于MQ和RPC做了以下简单的对比，如下图所示：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/23/15fe963722bccc10~tplv-t2oaga2asx-image.image\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文对RPC的基本原理、特点以及基本组件进行了简单的说明，让我们可以对RPC有一个基本的了解。关于常见的RPC框架也做了基本认识，对于这些优秀的框架，我们在实现我们自己RPC时可以借鉴一下这些架构里的一些模式以及技术。最后说明了下为什么我们会在分布式架构中要使用RPC而不是MQ，对于MQ来说，在处理同步调用无法满足实际的生产需求，而RPC才更加适合分布式应用的实际需要。</p>\n","text":"RPC 的主要目标就是为了让构建分布式计算（应用）变得更加简单，在提供强大的远程调用能力时不损失本地调用的语义简洁性。 为实现该目标，RPC 框架需提供一种透明...","permalink":"/post/middleware/middleware-rpc-about","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"Middleware","slug":"Middleware","count":13,"path":"api/categories/Middleware.json"}],"tags":[{"name":"rpc","slug":"rpc","count":1,"path":"api/tags/rpc.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98\"><span class=\"toc-text\">架构演变</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#rpc%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%9A%84rpc%E6%A1%86%E6%9E%B6\"><span class=\"toc-text\">rpc简介及常用的rpc框架</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFRPC\"><span class=\"toc-text\">什么是RPC</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RPC%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">RPC基本原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RPC%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">RPC模型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E7%9A%84RPC%E6%A1%86%E6%9E%B6\"><span class=\"toc-text\">常见的RPC框架</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RPC%E4%B8%8EMQ\"><span class=\"toc-text\">RPC与MQ</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"nginx 反向代理和负载均衡策略实战案例","uid":"91728ee079160c4f8cfcf9d960a59096","slug":"middleware/middleware-nginx-proxy","date":"2018-11-15T13:24:52.000Z","updated":"2024-07-05T04:09:05.790Z","comments":true,"path":"api/articles/middleware/middleware-nginx-proxy.json","keywords":null,"cover":[],"text":" 原文：https://juejin.cn/post/6844903594244702215 引言先来看下nginx在web服务器排名上的趋势： 存在即合理，那...","permalink":"/post/middleware/middleware-nginx-proxy","photos":[],"count_time":{"symbolsCount":"7.8k","symbolsTime":"7 mins."},"categories":[{"name":"Middleware","slug":"Middleware","count":13,"path":"api/categories/Middleware.json"}],"tags":[{"name":"nginx","slug":"nginx","count":2,"path":"api/tags/nginx.json"},{"name":"反向代理","slug":"反向代理","count":2,"path":"api/tags/反向代理.json"},{"name":"负载均衡","slug":"负载均衡","count":3,"path":"api/tags/负载均衡.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"JUC·ThreadPoolExecutor 线程池","uid":"9c68ad813f6c311ba3519d423fc2af91","slug":"java/java-advance-juc-thread-pool-executor","date":"2018-11-11T07:39:42.000Z","updated":"2024-07-05T04:09:05.762Z","comments":true,"path":"api/articles/java/java-advance-juc-thread-pool-executor.json","keywords":null,"cover":[],"text":" 原文：https://juejin.cn/post/6844903560899985415 ThreadPoolExecutor算是JUC中最常用的类之一了。...","permalink":"/post/java/java-advance-juc-thread-pool-executor","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"JAVA","slug":"JAVA","count":12,"path":"api/categories/JAVA.json"}],"tags":[{"name":"并发编程","slug":"并发编程","count":5,"path":"api/tags/并发编程.json"},{"name":"JUC","slug":"JUC","count":3,"path":"api/tags/JUC.json"},{"name":"ThreadPoolExecutor","slug":"ThreadPoolExecutor","count":1,"path":"api/tags/ThreadPoolExecutor.json"},{"name":"线程池","slug":"线程池","count":1,"path":"api/tags/线程池.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}