{"title":"聊一聊 session 和 cookie","uid":"4394df75e93e562a0f93dd0d5cccdf72","slug":"middleware/middleware-http-session-cookie","date":"2018-05-12T21:10:25.000Z","updated":"2024-07-05T04:09:05.789Z","comments":true,"path":"api/articles/middleware/middleware-http-session-cookie.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"content":"<p>本来是想写 aop 设计机制的，但是最近被 session 这个东西搞得有点头大，所以就抽点时间来整理下关于 session 的一些东西。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ul>\n<li><a href=\"\">从http协议的无状态性说起</a><ul>\n<li><a href=\"\">无连接和无状态</a></li>\n<li><a href=\"\">持久连接</a></li>\n<li><a href=\"\">http无状态</a></li>\n<li><a href=\"\">如何保持状态信息</a></li>\n</ul>\n</li>\n<li>Cookie<ul>\n<li><a href=\"\">Cookie机制原理</a></li>\n<li><a href=\"\">Cookie在servlet-api中的定义</a></li>\n<li><a href=\"\">Cookie属性</a></li>\n<li><a href=\"\">创建Cookie</a></li>\n<li><a href=\"\">Cookie更新</a></li>\n<li><a href=\"\">Cookie删除</a></li>\n<li><a href=\"\">从请求中获取Cookie</a></li>\n<li><a href=\"\">Cookie同源与跨域</a></li>\n<li><a href=\"\">Cookie数量&amp;大小限制及处理策略</a></li>\n</ul>\n</li>\n<li>Session<ul>\n<li><a href=\"\">session机制原理</a></li>\n<li><a href=\"\">HttpSession</a></li>\n<li><a href=\"\">创建session</a></li>\n<li><a href=\"\">生命周期</a></li>\n<li><a href=\"\">session的有效期</a></li>\n<li><a href=\"\">分布式session</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"从http协议的无状态性说起\"><a href=\"#从http协议的无状态性说起\" class=\"headerlink\" title=\"从http协议的无状态性说起\"></a>从http协议的无状态性说起</h2><p>HTTP是一种无状态协议。关于这个无状态之前我也不太理解，因为HTTP底层是TCP，既然是TCP，就是长连接，这个过程是保持连接状态的，又为什么说http是无状态的呢？先来搞清楚这两个概念：</p>\n<h3 id=\"无连接和无状态\"><a href=\"#无连接和无状态\" class=\"headerlink\" title=\"无连接和无状态\"></a>无连接和无状态</h3><ul>\n<li><p>无连接</p>\n<p>  每次连接只处理一个请求，服务端处理完客户端一次请求，等到客户端作出回应之后便断开连接；</p>\n</li>\n<li><p>无状态</p>\n<p>  是指服务端对于客户端每次发送的请求都认为它是一个新的请求，上一次会话和下一次会话没有联系；</p>\n</li>\n</ul>\n<p>无连接的维度是连接，无状态的维度是请求；http是基于tcp的，而从http1.1开始默认使用持久连接；在这个连接过程中，客户端可以向服务端发送多次请求，但是各个请求之间的并没有什么联系；这样来考虑，就很好理解无状态这个概念了。</p>\n<h3 id=\"持久连接\"><a href=\"#持久连接\" class=\"headerlink\" title=\"持久连接\"></a>持久连接</h3><p><code>持久连接，本质上是客户端与服务器通信的时候，建立一个持久化的TCP连接，这个连接不会随着请求结束而关闭，通常会保持连接一段时间。</code></p>\n<p>现有的持久连接类型有两种：HTTP&#x2F;1.0+的keep-alive和HTTP&#x2F;1.1的persistent。</p>\n<ul>\n<li>HTTP&#x2F;1.0+的keep-alive</li>\n</ul>\n<p>先来开一张图：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/13/163551ad5795255d~tplv-t2oaga2asx-image.image\"><br>这张图是请求<a href=\"http://www.baidu.com时的请求头信息。这里面我们需要注意的是：\">www.baidu.com时的请求头信息。这里面我们需要注意的是：</a></p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connection<span class=\"punctuation\">:</span> keep-alive</span><br></pre></td></tr></table></figure>\n<p>我们每次发送一个HTTP请求，会附带一个connection:keep-alive，这个参数就是声明一个持久连接。</p>\n<ul>\n<li>HTTP&#x2F;1.1的persistent</li>\n</ul>\n<p>HTTP&#x2F;1.1的持久连接默认是开启的，只有首部中包含connection：close，才会事务结束之后关闭连接。当然服务器和客户端仍可以随时关闭持久连接。</p>\n<p>当发送了connection：close首部之后客户端就没有办法在那条连接上发送更多的请求了。当然根据持久连接的特性，一定要传输正确的content-length。</p>\n<p>还有根据HTTP&#x2F;1.1的特性，是不应该和HTTP&#x2F;1.0客户端建立持久连接的。最后，一定要做好重发的准备。</p>\n<h3 id=\"http无状态\"><a href=\"#http无状态\" class=\"headerlink\" title=\"http无状态\"></a>http无状态</h3><p>OK，首先来明确下，这个状态的主体指的是什么？应该是信息，这些信息是由服务端所维护的与客户端交互的信息（也称为状态信息）；<br>因为HTTP本身是不保存任何用户的状态信息的，所以HTTP是无状态的协议。</p>\n<h3 id=\"如何保持状态信息\"><a href=\"#如何保持状态信息\" class=\"headerlink\" title=\"如何保持状态信息\"></a>如何保持状态信息</h3><p>在聊这个这个问题之前，我们来考虑下为什么http自己不来做这个事情：也就是让http变成有状态的。</p>\n<ul>\n<li><p>http本身来实现状态维护</p>\n<p>  从上面关于无状态的理解，如果现在需要让http自己变成有状态的，就意味着http协议需要保存交互的状态信息；暂且不说这种方式是否合适，但从维护状态信息这一点来说，代价就很高，因为既然保存了状态信息，那后续的一些行为必定也会受到状态信息的影响。</p>\n<p>  从历史角度来说，最初的http协议只是用来浏览静态文件的，无状态协议已经足够，这样实现的负担也很轻。但是随着web技术的不断发展，越来越多的场景需要状态信息能够得以保存；一方面是http本身不会去改变它的这种无状态的特性（至少目前是这样的），另一方面业务场景又迫切的需要保持状态；那么这个时候就需要来“装饰”一下http，引入一些其他机制来实现有状态。</p>\n</li>\n<li><p>cookie和session体系</p>\n<p>  通过引入cookie和session体系机制来维护状态信息。即用户第一次访问服务器的时候，服务器响应报头通常会出现一个Set-Cookie响应头，这里其实就是在本地设置一个cookie，当用户再次访问服务器的时候，http会附带这个cookie过去，cookie中存有sessionId这样的信息来到服务器这边确认是否属于同一次会话。</p>\n</li>\n</ul>\n<h2 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h2><p> cookie是由服务器发送给客户端（浏览器）的小量信息，以{key：value}的形式存在。</p>\n<h3 id=\"Cookie机制原理\"><a href=\"#Cookie机制原理\" class=\"headerlink\" title=\"Cookie机制原理\"></a>Cookie机制原理</h3><p> 客户端请求服务器时，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。而客户端浏览器会把Cookie保存起来。当浏览器再请求 服务器时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器通过检查该Cookie来获取用户状态。</p>\n<p> 我们通过看下servlet-api中Cookie类的定义及属性，来更加具体的了解Cookie。</p>\n<h3 id=\"Cookie在servlet-api中的定义\"><a href=\"#Cookie在servlet-api中的定义\" class=\"headerlink\" title=\"Cookie在servlet-api中的定义\"></a>Cookie在servlet-api中的定义</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Cookie</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Cloneable</span>, Serializable &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">serialVersionUID</span> <span class=\"operator\">=</span> -<span class=\"number\">6454587001725327448L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TSPECIALS;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">LSTRING_FILE</span> <span class=\"operator\">=</span></span><br><span class=\"line\">    <span class=\"string\">&quot;javax.servlet.http.LocalStrings&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">ResourceBundle</span> <span class=\"variable\">lStrings</span> <span class=\"operator\">=</span></span><br><span class=\"line\">    ResourceBundle.getBundle(<span class=\"string\">&quot;javax.servlet.http.LocalStrings&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String value;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String comment;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String domain;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxAge</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String path;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> secure;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">version</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"variable\">isHttpOnly</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//....省略其他方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Cookie属性\"><a href=\"#Cookie属性\" class=\"headerlink\" title=\"Cookie属性\"></a>Cookie属性</h3><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>name</td>\n<td>cookie 的名字，Cookie 一旦创建，名称便不可更改</td>\n</tr>\n<tr>\n<td>value</td>\n<td>cookie 值</td>\n</tr>\n<tr>\n<td>comment</td>\n<td>该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明</td>\n</tr>\n<tr>\n<td>domain</td>\n<td>可以访问该Cookie的域名。如果设置为“.baidu.com”，则所有以“baidu.com”结尾的域名都可以访问该Cookie；第一个字符必须为“.”</td>\n</tr>\n<tr>\n<td>maxAge</td>\n<td>Cookie失效的时间，单位秒。正数: 则超过maxAge秒之后失效。负数: 该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。0: 表示删除该 Cookie。</td>\n</tr>\n<tr>\n<td>path</td>\n<td>该 Cookie的使用路径。path设置时，其以“&#x2F;”结尾。例如：path&#x3D;&#x2F;，说明本域名下contextPath都可以访问该Cookie; path&#x3D;&#x2F;app&#x2F;，则只有contextPath为“&#x2F;app”的程序可以访问该Cookie</td>\n</tr>\n<tr>\n<td>secure</td>\n<td>该Cookie是否仅被使用安全协议传输。这里的安全协议包括HTTPS，SSL等。默认为false。</td>\n</tr>\n<tr>\n<td>version</td>\n<td>该Cookie使用的版本号，在servlet规范中默认是 0；0 表示遵循Netscape的Cookie规范，目前大多数用的都是这种规范；1 表示遵循W3C的RFC2109规范；规范过于严格，实施起来很难。</td>\n</tr>\n<tr>\n<td>isHttpOnly</td>\n<td>HttpOnly属性是用来限制非HTTP协议程序接口对客户端Cookie进行访问；也就是说如果想要在客户端取到httponly的Cookie的唯一方法就是使用AJAX，将取Cookie的操作放到服务端，接收客户端发送的ajax请求后将取值结果通过HTTP返回客户端。这样能有效的防止XSS攻击。</td>\n</tr>\n</tbody></table>\n<p>上述的这些属性，除了 name 与 value 属性会被提交外，其他的属性对于客户端来说都是不可读的，也是不可被提交的。</p>\n<h3 id=\"创建Cookie\"><a href=\"#创建Cookie\" class=\"headerlink\" title=\"创建Cookie\"></a>创建Cookie</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Cookie</span> <span class=\"variable\">cookie</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Cookie</span>(<span class=\"string\">&quot;cookieSessionId&quot;</span>,<span class=\"string\">&quot;qwertyuiop&quot;</span>);</span><br><span class=\"line\">cookie.setDomain(<span class=\"string\">&quot;.baidu.com&quot;</span>);             <span class=\"comment\">// 设置域名</span></span><br><span class=\"line\">cookie.setPath(<span class=\"string\">&quot;/&quot;</span>);                        <span class=\"comment\">// 设置路径</span></span><br><span class=\"line\">cookie.setMaxAge(Integer.MAX_VALUE);        <span class=\"comment\">// 设置有效期为永久</span></span><br><span class=\"line\">response.addCookie(cookie);                 <span class=\"comment\">// 回写到客户端</span></span><br></pre></td></tr></table></figure>\n<p>创建Cookie只能通过上述方式来创建，因为在Cookie类中只提供了这样一个构造函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Cookie的构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">Cookie</span><span class=\"params\">(String name, String value)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name != <span class=\"literal\">null</span> &amp;&amp; name.length() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//判断下是不是token</span></span><br><span class=\"line\">        <span class=\"comment\">//判断是不是和Cookie的属性字段重复</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isToken(name) &amp;&amp; !name.equalsIgnoreCase(<span class=\"string\">&quot;Comment&quot;</span>) &amp;&amp;</span><br><span class=\"line\">        !name.equalsIgnoreCase(<span class=\"string\">&quot;Discard&quot;</span>) &amp;&amp;</span><br><span class=\"line\">        !name.equalsIgnoreCase(<span class=\"string\">&quot;Domain&quot;</span>) &amp;&amp;</span><br><span class=\"line\">        !name.equalsIgnoreCase(<span class=\"string\">&quot;Expires&quot;</span>) &amp;&amp;</span><br><span class=\"line\">        !name.equalsIgnoreCase(<span class=\"string\">&quot;Max-Age&quot;</span>) &amp;&amp;</span><br><span class=\"line\">        !name.equalsIgnoreCase(<span class=\"string\">&quot;Path&quot;</span>) &amp;&amp;</span><br><span class=\"line\">        !name.equalsIgnoreCase(<span class=\"string\">&quot;Secure&quot;</span>) &amp;&amp;</span><br><span class=\"line\">        !name.equalsIgnoreCase(<span class=\"string\">&quot;Version&quot;</span>) &amp;&amp; !name.startsWith(<span class=\"string\">&quot;$&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.value = value;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">errMsg</span> <span class=\"operator\">=</span></span><br><span class=\"line\">            lStrings.getString(<span class=\"string\">&quot;err.cookie_name_is_token&quot;</span>);</span><br><span class=\"line\">            Object[] errArgs = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[]&#123;name&#125;;</span><br><span class=\"line\">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(errMsg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(lStrings.getString</span><br><span class=\"line\">        (<span class=\"string\">&quot;err.cookie_name_blank&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Cookie更新\"><a href=\"#Cookie更新\" class=\"headerlink\" title=\"Cookie更新\"></a>Cookie更新</h3><p>在源码中可以知道，Cookie本身并没有提供修改的方法；在实际应用中，一般通过使用相同name的Cookie来覆盖原来的Cookie,以达到更新的目的。</p>\n<p>但是这个修改的前提是需要具有相同domain，path的 Set-Cookie 消息头</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Cookie</span> <span class=\"variable\">cookie</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Cookie</span>(<span class=\"string\">&quot;cookieSessionId&quot;</span>,<span class=\"string\">&quot;new-qwertyuiop&quot;</span>);</span><br><span class=\"line\">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Cookie删除\"><a href=\"#Cookie删除\" class=\"headerlink\" title=\"Cookie删除\"></a>Cookie删除</h3><p>与Cookie更新一样，Cookie本身也没有提供删除的方法；但是从前面分析Cookie属性时了解到，删除Cookie可以通过将maxAge设置为0即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Cookie</span> <span class=\"variable\">cookie</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Cookie</span>(<span class=\"string\">&quot;cookieSessionId&quot;</span>,<span class=\"string\">&quot;new-qwertyuiop&quot;</span>);</span><br><span class=\"line\">cookie.setMaxAge(<span class=\"number\">0</span>);</span><br><span class=\"line\">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>\n\n<p>上面的删除是我们自己可控的；但是也存在一些我们不可控或者说无意识情况下的删除操作：</p>\n<ul>\n<li>如果maxAge是负值，则cookie在浏览器关闭时被删除</li>\n<li>持久化cookie在到达失效日期时会被删除</li>\n<li>浏览器中的 cookie 数量达到上限，那么 cookie 会被删除以为新建的 cookie 创建空间。</li>\n</ul>\n<p>其实很多情况下，我们关注的都是后者。关于数量上限后面会说到。</p>\n<h3 id=\"从请求中获取Cookie\"><a href=\"#从请求中获取Cookie\" class=\"headerlink\" title=\"从请求中获取Cookie\"></a>从请求中获取Cookie</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cookie[] cookies = request.getCookies();</span><br></pre></td></tr></table></figure>\n<h3 id=\"Cookie同源与跨域\"><a href=\"#Cookie同源与跨域\" class=\"headerlink\" title=\"Cookie同源与跨域\"></a>Cookie同源与跨域</h3><p>我们知道浏览器的同源策略：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。浏览器的同源策略，限制了来自不同源的”document”或脚本，对当前”document”读取或设置某些属性。 </p></blockquote>\n<p>对于Cookie来说，Cookie的同源只关注域名，是忽略协议和端口的。所以一般情况下，<a href=\"https://localhost:80/%E5%92%8Chttp://localhost:8080/%E7%9A%84Cookie%E6%98%AF%E5%85%B1%E4%BA%AB%E7%9A%84%E3%80%82\">https://localhost:80/和http://localhost:8080/的Cookie是共享的。</a></p>\n<p>Cookie是不可跨域的；在没有经过任何处理的情况下，二级域名不同也是不行的。(wenku.baidu.com和baike.baidu.com)。</p>\n<h3 id=\"Cookie数量-大小限制及处理策略\"><a href=\"#Cookie数量-大小限制及处理策略\" class=\"headerlink\" title=\"Cookie数量&amp;大小限制及处理策略\"></a>Cookie数量&amp;大小限制及处理策略</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>IE6.0</th>\n<th>IE7.0&#x2F;8.0</th>\n<th>Opera</th>\n<th>FF</th>\n<th>Safari</th>\n<th>Chrome</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>个数&#x2F;个</td>\n<td>20&#x2F;域</td>\n<td>50&#x2F;域</td>\n<td>30&#x2F;域</td>\n<td>50&#x2F;域</td>\n<td>无限制</td>\n<td>53&#x2F;域</td>\n</tr>\n<tr>\n<td>大小&#x2F;Byte</td>\n<td>4095</td>\n<td>4095</td>\n<td>4096</td>\n<td>4097</td>\n<td>4097</td>\n<td>4097</td>\n</tr>\n</tbody></table>\n<p><code>注：数据来自网络，仅供参考</code></p>\n<p>因为浏览器对于Cookie在数量上是有限制的，如果超过了自然会有一些剔除策略。在这篇文章中<a href=\"https://www.nczonline.net/blog/2008/05/17/browser-cookie-restrictions/\">Browser cookie restrictions</a>提到的剔除策略如下：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>The least recently used (LRU) approach automatically kicks out the oldest cookie when the cookie limit has been reached in order to allow the newest cookie some space. Internet Explorer and Opera use this approach.</p></blockquote>\n<p>最近最少使用（LRU）方法：在达到cookie限制时自动地剔除最老的cookie，以便腾出空间给许最新的cookie。Internet Explorer和Opera使用这种方法。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Firefox does something strange: it seems to randomly decide which cookies to keep although the last cookie set is always kept. There doesn’t seem to be any scheme it’s following at all. The takeaway? Don’t go above the cookie limit in Firefox.</p></blockquote>\n<p>Firefox决定随机删除Cookie集中的一个Cookie，并没有什么章法。所以最好不要超过Firefox中的Cookie限制。</p>\n<p>超过大小长度的话就是直接被截取丢弃；</p>\n<h2 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h2><p>Cookie机制弥补了HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。</p>\n<p>与Cookie不同的是，session是以服务端保存状态的。</p>\n<h3 id=\"session机制原理\"><a href=\"#session机制原理\" class=\"headerlink\" title=\"session机制原理\"></a>session机制原理</h3><p>当客户端请求创建一个session的时候，服务器会先检查这个客户端的请求里是否已包含了一个session标识 - sessionId，</p>\n<ul>\n<li>如果已包含这个sessionId，则说明以前已经为此客户端创建过session，服务器就按照sessionId把这个session检索出来使用（如果检索不到，可能会新建一个）</li>\n<li>如果客户端请求不包含sessionId，则为此客户端创建一个session并且生成一个与此session相关联的sessionId</li>\n</ul>\n<p>sessionId的值一般是一个既不会重复，又不容易被仿造的字符串，这个sessionId将被在本次响应中返回给客户端保存。保存sessionId的方式大多情况下用的是cookie。</p>\n<h3 id=\"HttpSession\"><a href=\"#HttpSession\" class=\"headerlink\" title=\"HttpSession\"></a>HttpSession</h3><p>HttpSession和Cookie一样，都是javax.servlet.http下面的；Cookie是一个类，它描述了Cookie的很多内部细节。而HttpSession是一个接口，它为session的实现提供了一些行为约束。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">HttpSession</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回session的创建时间</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getCreationTime</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回一个sessionId,唯一标识</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getId</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *返回客户端最后一次发送与该 session 会话相关的请求的时间</span></span><br><span class=\"line\"><span class=\"comment\">     *自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getLastAccessedTime</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回当前session所在的ServletContext</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ServletContext <span class=\"title function_\">getServletContext</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setMaxInactiveInterval</span><span class=\"params\">(<span class=\"type\">int</span> interval)</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回 Servlet 容器在客户端访问时保持 session</span></span><br><span class=\"line\"><span class=\"comment\">     * 会话打开的最大时间间隔</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getMaxInactiveInterval</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> HttpSessionContext <span class=\"title function_\">getSessionContext</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回在该 session会话中具有指定名称的对象，</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果没有指定名称的对象，则返回 null。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">getAttribute</span><span class=\"params\">(String name)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">getValue</span><span class=\"params\">(String name)</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回 String 对象的枚举，String 对象包含所有绑定到该 session</span></span><br><span class=\"line\"><span class=\"comment\">     * 会话的对象的名称。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span>    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Enumeration&lt;String&gt; <span class=\"title function_\">getAttributeNames</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String[] getValueNames();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAttribute</span><span class=\"params\">(String name, Object value)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">putValue</span><span class=\"params\">(String name, Object value)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">removeAttribute</span><span class=\"params\">(String name)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">removeValue</span><span class=\"params\">(String name)</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 指示该 session 会话无效，并解除绑定到它上面的任何对象。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">invalidate</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果客户端不知道该 session 会话，或者如果客户选择不参入该</span></span><br><span class=\"line\"><span class=\"comment\">     * session 会话，则该方法返回 true。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isNew</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建session\"><a href=\"#创建session\" class=\"headerlink\" title=\"创建session\"></a>创建session</h3><p>创建session的方式是通过request来创建；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1、创建Session对象</span></span><br><span class=\"line\"><span class=\"type\">HttpSession</span> <span class=\"variable\">session</span> <span class=\"operator\">=</span> request.getSession(); </span><br><span class=\"line\"><span class=\"comment\">// 2、创建Session对象</span></span><br><span class=\"line\"><span class=\"type\">HttpSession</span> <span class=\"variable\">session</span> <span class=\"operator\">=</span> request.getSession(<span class=\"literal\">true</span>); </span><br></pre></td></tr></table></figure>\n<p>这两种是一样的；如果session不存在，就新建一个；如果是false的话，标识如果不存在就返回null；</p>\n<h3 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h3><p>session的生命周期指的是从Servlet容器创建session对象到销毁的过程。Servlet容器会依据session对象设置的存活时间，在达到session时间后将session对象销毁。session生成后，只要用户继续访问，服务器就会更新session的最后访问时间，并维护该session。</p>\n<p>之前在单进程应用中，session我一般是存在内存中的，不会做持久化操作或者说使用三方的服务来存session信息，如redis。但是在分布式场景下，这种存在本机内存中的方式显然是不适用的，因为session无法共享。这个后面说。</p>\n<h3 id=\"session的有效期\"><a href=\"#session的有效期\" class=\"headerlink\" title=\"session的有效期\"></a>session的有效期</h3><p>session一般在内存中存放，内存空间本身大小就有一定的局限性，因此session需要采用一种过期删除的机制来确保session信息不会一直累积，来防止内存溢出的发生。</p>\n<p>session的超时时间可以通过maxInactiveInterval属性来设置。</p>\n<p>如果我们想让session失效的话，也可以当通过调用session的invalidate()来完成。</p>\n<h3 id=\"分布式session\"><a href=\"#分布式session\" class=\"headerlink\" title=\"分布式session\"></a>分布式session</h3><p>首先是为什么会有这样的概念出现？</p>\n<p>先考虑这样一个问题，现在我的应用需要部署在3台机器上。是不是出现这样一种情况，我第一次登陆，请求去了机器1，然后再机器1上创建了一个session；但是我第二次访问时，请求被路由到机器2了，但是机器2上并没有我的session信息，所以得重新登录。当然这种可以通过nginx的IP HASH负载策略来解决。对于同一个IP请求都会去同一个机器。</p>\n<p>但是业务发展的越来越大，拆分的越来越多，机器数不断增加；很显然那种方案就不行了。那么这个时候就需要考虑是不是应该将session信息放在一个独立的机器上，所以分布式session要解决的问题其实就是分布式环境下的session共享的问题。</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/13/163562469179fe66~tplv-t2oaga2asx-image.image\"></p>\n<p>上图中的关于session独立部署的方式有很多种，可以是一个独立的数据库服务，也可以是一个缓存服务(redis，目前比较常用的一种方式，即使用Redis来作为session缓存服务器)。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.cnblogs.com/icelin/p/3974935.html\">https://www.cnblogs.com/icelin/p/3974935.html</a></li>\n<li><a href=\"https://www.nczonline.net/blog/2008/05/17/browser-cookie-restrictions/\">https://www.nczonline.net/blog/2008/05/17/browser-cookie-restrictions/</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE\">https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE</a></li>\n</ul>\n","text":"本来是想写 aop 设计机制的，但是最近被 session 这个东西搞得有点头大，所以就抽点时间来整理下关于 session 的一些东西。 目录 从http协议...","permalink":"/post/middleware/middleware-http-session-cookie","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Middleware","slug":"Middleware","count":14,"path":"api/categories/Middleware.json"}],"tags":[{"name":"http","slug":"http","count":3,"path":"api/tags/http.json"},{"name":"session","slug":"session","count":6,"path":"api/tags/session.json"},{"name":"cookie","slug":"cookie","count":1,"path":"api/tags/cookie.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">目录</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%8Ehttp%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%97%A0%E7%8A%B6%E6%80%81%E6%80%A7%E8%AF%B4%E8%B5%B7\"><span class=\"toc-text\">从http协议的无状态性说起</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%A0%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">无连接和无状态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5\"><span class=\"toc-text\">持久连接</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#http%E6%97%A0%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">http无状态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">如何保持状态信息</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Cookie\"><span class=\"toc-text\">Cookie</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Cookie%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Cookie机制原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Cookie%E5%9C%A8servlet-api%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">Cookie在servlet-api中的定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Cookie%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">Cookie属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BACookie\"><span class=\"toc-text\">创建Cookie</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Cookie%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">Cookie更新</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Cookie%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">Cookie删除</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E8%AF%B7%E6%B1%82%E4%B8%AD%E8%8E%B7%E5%8F%96Cookie\"><span class=\"toc-text\">从请求中获取Cookie</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Cookie%E5%90%8C%E6%BA%90%E4%B8%8E%E8%B7%A8%E5%9F%9F\"><span class=\"toc-text\">Cookie同源与跨域</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Cookie%E6%95%B0%E9%87%8F-%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6%E5%8F%8A%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">Cookie数量&amp;大小限制及处理策略</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Session\"><span class=\"toc-text\">Session</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#session%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">session机制原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HttpSession\"><span class=\"toc-text\">HttpSession</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BAsession\"><span class=\"toc-text\">创建session</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">生命周期</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#session%E7%9A%84%E6%9C%89%E6%95%88%E6%9C%9F\"><span class=\"toc-text\">session的有效期</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E5%B8%83%E5%BC%8Fsession\"><span class=\"toc-text\">分布式session</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"聊一聊 AOP ：表现形式与基础概念","uid":"740732400e76d891c8b7f2d184b75bcc","slug":"spring/spring-aop-form-concept","date":"2018-06-20T16:43:21.000Z","updated":"2024-07-05T04:09:05.815Z","comments":true,"path":"api/articles/spring/spring-aop-form-concept.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"text":" 原文：https://juejin.cn/post/6844903623101513735 aop 终于提上日程来写一写了。 本系列分为 上、中、下三篇。上篇...","permalink":"/post/spring/spring-aop-form-concept","photos":[],"count_time":{"symbolsCount":"23k","symbolsTime":"21 mins."},"categories":[{"name":"spring","slug":"spring","count":15,"path":"api/categories/spring.json"}],"tags":[{"name":"spring","slug":"spring","count":11,"path":"api/tags/spring.json"},{"name":"aop","slug":"aop","count":3,"path":"api/tags/aop.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"关于 Mybatis 中 SQL 语句的整理","uid":"123d621baee081af1f177335cc7a300f","slug":"middleware/middleware-data-mybatis-sql","date":"2018-04-17T09:37:54.000Z","updated":"2024-07-05T04:09:05.788Z","comments":true,"path":"api/articles/middleware/middleware-data-mybatis-sql.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":null,"text":"随着业务的发展，越来越多的应用系统都从一个大的系统分拆成多个小的系统，各个系统之间通过一定的通信协议进行数据交换。这样就会导致一些小的应用系统自己不用去进行数据...","permalink":"/post/middleware/middleware-data-mybatis-sql","photos":[],"count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"categories":[{"name":"Middleware","slug":"Middleware","count":14,"path":"api/categories/Middleware.json"}],"tags":[{"name":"mysql","slug":"mysql","count":4,"path":"api/tags/mysql.json"},{"name":"mybatis","slug":"mybatis","count":1,"path":"api/tags/mybatis.json"},{"name":"sql","slug":"sql","count":1,"path":"api/tags/sql.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}