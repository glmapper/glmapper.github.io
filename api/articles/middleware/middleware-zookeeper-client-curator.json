{"title":"ZooKeeper 客户端之 Curator","uid":"e185413cf7dca9c0efdf1f0b1164cf4f","slug":"middleware/middleware-zookeeper-client-curator","date":"2019-04-13T14:09:30.000Z","updated":"2024-07-05T04:09:05.790Z","comments":true,"path":"api/articles/middleware/middleware-zookeeper-client-curator.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"content":"<p>ZooKeeper 是一个分布式的、开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现。它是集群的管理者，监视着集群中各个节点的状态，根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p>\n<p>Curator 是 Netflix 公司开源的一套  Zookeeper 客户端框架，解决了很多 Zookeeper 客户端非常底层的细节开发工作，包括连接重连、反复注册 Watcher 和 NodeExistsException 异常等等。</p>\n<span id=\"more\"></span>\n\n<p>Curator 包含了几个包：</p>\n<ul>\n<li>curator-framework：对 Zookeeper 的底层 api 的一些封装</li>\n<li>curator-client：提供一些客户端的操作，例如重试策略等</li>\n<li>curator-recipes：封装了一些高级特性，如：Cache 事件监听、选举、分布式锁、分布式计数器、分布式Barrier 等</li>\n</ul>\n<h2 id=\"Curator-和-zookeeper-的版本问题\"><a href=\"#Curator-和-zookeeper-的版本问题\" class=\"headerlink\" title=\"Curator 和 zookeeper 的版本问题\"></a>Curator 和 zookeeper 的版本问题</h2><p>目前 Curator 有 2.x.x 和 3.x.x 两个系列的版本，支持不同版本的 Zookeeper。其中Curator 2.x.x 兼容 Zookeeper的 3.4.x 和 3.5.x。而 Curator 3.x.x 只兼容 Zookeeper 3.5.x，并且提供了一些诸如动态重新配置、watch删除等新特性。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Curator 2.x.x - compatible with both ZooKeeper 3.4.x and ZooKeeper 3.5.x</span><br><span class=\"line\">Curator 3.x.x - compatible only with ZooKeeper 3.5.x and includes support for new</span><br></pre></td></tr></table></figure>\n\n<p>如果跨版本会有兼容性问题，很有可能导致节点操作失败，当时在使用的时候就踩了这个坑，抛了如下的异常：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KeeperErrorCode = Unimplemented for /***</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Curator-API\"><a href=\"#Curator-API\" class=\"headerlink\" title=\"Curator   API\"></a>Curator   API</h2><p>这里就不对比与原生 API 的区别了，Curator 的 API 直接通过 org.apache.curator.framework.CuratorFramework 接口来看，并结合相应的案例进行使用，以备后用。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>为了可以直观的看到 Zookeeper 的节点信息，可以考虑弄一个 zk 的管控界面，常见的有 zkui 和 zkweb。</p>\n<ul>\n<li>zkui：<a href=\"https://github.com/DeemOpen/zkui\">https://github.com/DeemOpen/zkui</a></li>\n<li>zkweb：<a href=\"https://github.com/zhitom/zkweb\">https://github.com/zhitom/zkweb</a></li>\n</ul>\n<p>我用的 zkweb ，虽然界面上看起来没有 zkui 精简，但是在层次展示和一些细节上感觉比 zkui 好一点</p></blockquote>\n<h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><p>之前写的一个在 <a href=\"/2019/05/04/linux/linux-ops-soft-zookeeper/\">Linux 上安装部署 Zookeeper</a> 的笔记，其他操作系统请自行谷歌教程吧。</p>\n<p>本文案例工程已经同步到了 github，<a href=\"https://github.com/glmapper/glmapper-blog-samples\">传送门</a>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>PS : 目前还没有看过Curator的具体源码，所以不会涉及到任何源码解析、实现原理的东西；本篇主要是实际使用时的一些记录，以备后用。如果文中错误之处，希望各位指出。</p></blockquote>\n<h2 id=\"Curator-客户端的初始化和初始化时机\"><a href=\"#Curator-客户端的初始化和初始化时机\" class=\"headerlink\" title=\"Curator 客户端的初始化和初始化时机\"></a>Curator 客户端的初始化和初始化时机</h2><p>在实际的工程中，Zookeeper 客户端的初始化会在程序启动期间完成。</p>\n<h3 id=\"初始化时机\"><a href=\"#初始化时机\" class=\"headerlink\" title=\"初始化时机\"></a>初始化时机</h3><p>在 Spring 或者 SpringBoot 工程中最常见的就是绑定到容器启动的生命周期或者应用启动的生命周期中：</p>\n<ul>\n<li>监听 ContextRefreshedEvent 事件，在容器刷新完成之后初始化 Zookeeper</li>\n<li>监听 ApplicationReadyEvent&#x2F;ApplicationStartedEvent 事件，初始化 Zookeeper 客户端</li>\n</ul>\n<p>除了上面的方式之外，还有一种常见的是绑定到 bean 的生命周期中</p>\n<ul>\n<li>实现 InitializingBean 接口 ，在 afterPropertiesSet 中完成 Zookeeper 客户端初始化</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>关于 SpringBoot中的事件机制可以参考之前写过的一篇文章：<a href=\"/2019/04/13/springboot/springboot-series-event/\">SpringBoot-SpringBoot中的事件机制</a>。</p></blockquote>\n<h3 id=\"Curator-初始化\"><a href=\"#Curator-初始化\" class=\"headerlink\" title=\"Curator 初始化\"></a>Curator 初始化</h3><p>这里使用 InitializingBean 的这种方式，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZookeeperCuratorClient</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InitializingBean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> CuratorFramework curatorClient;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;glmapper.zookeeper.address:localhost:2181&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String           connectString;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;glmapper.zookeeper.baseSleepTimeMs:1000&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span>              baseSleepTimeMs;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;glmapper.zookeeper.maxRetries:3&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span>              maxRetries;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;glmapper.zookeeper.sessionTimeoutMs:6000&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span>              sessionTimeoutMs;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;glmapper.zookeeper.connectionTimeoutMs:6000&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span>              connectionTimeoutMs;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">// custom policy</span></span><br><span class=\"line\">        <span class=\"type\">RetryPolicy</span> <span class=\"variable\">retryPolicy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExponentialBackoffRetry</span>(baseSleepTimeMs, maxRetries);</span><br><span class=\"line\">        <span class=\"comment\">// to build curatorClient</span></span><br><span class=\"line\">        curatorClient = CuratorFrameworkFactory.builder().connectString(connectString)</span><br><span class=\"line\">                .sessionTimeoutMs(sessionTimeoutMs).connectionTimeoutMs(connectionTimeoutMs)</span><br><span class=\"line\">                .retryPolicy(retryPolicy).build();</span><br><span class=\"line\">        curatorClient.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CuratorFramework <span class=\"title function_\">getCuratorClient</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> curatorClient;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>glmapper.zookeeper.xxx 是本例中需要在配置文件中配置的 zookeeper 的一些参数，参数解释如下：</p>\n<ul>\n<li>baseSleepTimeMs：重试之间等待的初始时间</li>\n<li>maxRetries：最大重试次数</li>\n<li>connectString：要连接的服务器列表</li>\n<li>sessionTimeoutMs：session 超时时间</li>\n<li>connectionTimeoutMs：连接超时时间</li>\n</ul>\n<p>另外，Curator 客户端初始化时还需要指定重试策略，RetryPolicy 接口是 Curator 中重试连接(当zookeeper失去连接时使用)策略的顶级接口，其类继承体系如下图所示：</p>\n<p><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/zookeeper/curator-classes.jpg\"></p>\n<ul>\n<li>RetryOneTime：只重连一次</li>\n<li>RetryNTime：指定重连的次数N</li>\n<li>RetryUtilElapsed：指定最大重连超时时间和重连时间间隔，间歇性重连直到超时或者链接成功</li>\n<li>ExponentialBackoffRetry：基于 “backoff”方式重连，和 RetryUtilElapsed 的区别是重连的时间间隔是动态的。</li>\n<li>BoundedExponentialBackoffRetry： 同 ExponentialBackoffRetry的区别是增加了最大重试次数的控制</li>\n</ul>\n<p>除上述之外，在一些场景中，需要对不同的业务进行隔离，这种情况下，可以通过设置 namespace 来解决，namespace 实际上就是指定zookeeper的根路径，设置之后，后面的所有操作都会基于该根目录。</p>\n<h2 id=\"Curator-基础-API-使用\"><a href=\"#Curator-基础-API-使用\" class=\"headerlink\" title=\"Curator 基础 API 使用\"></a>Curator 基础 API 使用</h2><h3 id=\"检查节点是否存在\"><a href=\"#检查节点是否存在\" class=\"headerlink\" title=\"检查节点是否存在\"></a>检查节点是否存在</h3><p>checkExists 方法返回的是一个 ExistsBuilder 构造器，这个构建器将返回一个 Stat 对象，就像调用了 org.apache.zookeeper.ZooKeeper.exists()一样。null 表示它不存在，而实际的 Stat 对象表示存在。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkNodeExist</span><span class=\"params\">(String path)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"type\">Stat</span> <span class=\"variable\">stat</span> <span class=\"operator\">=</span> curatorClient.checkExists().forPath(path);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stat != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;path = &quot;</span>+path +<span class=\"string\">&quot; has bean exist.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>建议在实际的应用中，操作节点时对所需操作的节点进行 checkExists。</p>\n<h3 id=\"新增节点\"><a href=\"#新增节点\" class=\"headerlink\" title=\"新增节点\"></a>新增节点</h3><ul>\n<li><p>非递归方式创建节点</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curatorClient.create().forPath(&quot;/glmapper&quot;);</span><br><span class=\"line\">curatorClient.create().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>先创建&#x2F;glmapper，然后再在&#x2F;glmapper 下面创建 &#x2F;test ，如果直接使用 &#x2F;glmapper&#x2F;test 没有先创建 &#x2F;glmapper 时，会抛出异常：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.apache.zookeeper.KeeperException$NoNodeException: KeeperErrorCode = NoNode for /glmapper/test</span><br></pre></td></tr></table></figure>\n\n<p>如果需要在创建节点时指定节点中数据，则可以这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curatorClient.create().forPath(&quot;/glmapper&quot;,&quot;data&quot;.getBytes());</span><br></pre></td></tr></table></figure>\n\n<p>指定节点类型(EPHEMERAL 临时节点)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curatorClient.create().withMode(CreateMode.EPHEMERAL).forPath(&quot;/glmapper&quot;,&quot;data&quot;.getBytes());</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>递归方式创建节点</p>\n<p>递归方式创建节点有两个方法，creatingParentsIfNeeded 和 creatingParentContainersIfNeeded。在新版本的 zookeeper 这两个递归创建方法会有区别； creatingParentContainersIfNeeded() 以容器模式递归创建节点，如果旧版本 zookeeper，此方法等于creatingParentsIfNeeded()。</p>\n<p>在非递归方式情况下，如果直接创建 &#x2F;glmapper&#x2F;test 会报错，那么在递归的方式下则是可以的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curatorClient.create().creatingParentContainersIfNeeded().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>在递归调用中，如果不指定 CreateMode，则默认<code>PERSISTENT</code>，如果指定为临时节点，则最终节点会是临时节点，父节点仍旧是<code>PERSISTENT</code></p>\n</li>\n</ul>\n<h3 id=\"删除节点\"><a href=\"#删除节点\" class=\"headerlink\" title=\"删除节点\"></a>删除节点</h3><ul>\n<li><p>非递归删除节点</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curatorClient.delete().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>指定具体版本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curatorClient.delete().withVersion(-1).forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>使用 guaranteed 方式删除，guaranteed 会保证在session有效的情况下，后台持续进行该节点的删除操作，直到删除掉</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curatorClient.delete().guaranteed().withVersion(-1).forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>递归删除当前节点及其子节点</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curatorClient.delete().deletingChildrenIfNeeded().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"获取节点数据\"><a href=\"#获取节点数据\" class=\"headerlink\" title=\"获取节点数据\"></a>获取节点数据</h3><p>获取节点数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte[] data = curatorClient.getData().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>根据配置的压缩提供程序对数据进行解压缩处理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte[] data = curatorClient.getData().decompressed().forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>读取数据并获得Stat信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stat stat = new Stat();</span><br><span class=\"line\">byte[] data = curatorClient.getData().storingStatIn(stat).forPath(&quot;/glmapper/test&quot;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更新节点数据\"><a href=\"#更新节点数据\" class=\"headerlink\" title=\"更新节点数据\"></a>更新节点数据</h3><p>设置指定值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curatorClient.setData().forPath(&quot;/glmapper/test&quot;,&quot;newData&quot;.getBytes());</span><br></pre></td></tr></table></figure>\n\n<p>设置数据并使用配置的压缩提供程序压缩数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curatorClient.setData().compressed().forPath(&quot;/glmapper/test&quot;,&quot;newData&quot;.getBytes());</span><br></pre></td></tr></table></figure>\n\n<p>设置数据，并指定版本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curatorClient.setData().withVersion(-1).forPath(&quot;/glmapper/test&quot;,&quot;newData&quot;.getBytes());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取子列表\"><a href=\"#获取子列表\" class=\"headerlink\" title=\"获取子列表\"></a>获取子列表</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; childrenList = curatorClient.getChildren().forPath(&quot;/glmapper&quot;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><p>Curator 也对 Zookeeper 典型场景之事件监听进行封装，这部分能力实在 curator-recipes 包下的。</p>\n<h3 id=\"事件类型\"><a href=\"#事件类型\" class=\"headerlink\" title=\"事件类型\"></a>事件类型</h3><p>在使用不同的方法时会有不同的事件发生</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">CuratorEventType</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//Corresponds to &#123;@link CuratorFramework#create()&#125;</span></span><br><span class=\"line\">    CREATE,</span><br><span class=\"line\">    <span class=\"comment\">//Corresponds to &#123;@link CuratorFramework#delete()&#125;</span></span><br><span class=\"line\">    DELETE,</span><br><span class=\"line\">\t\t<span class=\"comment\">//Corresponds to &#123;@link CuratorFramework#checkExists()&#125;</span></span><br><span class=\"line\">    EXISTS,</span><br><span class=\"line\">\t\t<span class=\"comment\">//Corresponds to &#123;@link CuratorFramework#getData()&#125;</span></span><br><span class=\"line\">    GET_DATA,</span><br><span class=\"line\">\t\t<span class=\"comment\">//Corresponds to &#123;@link CuratorFramework#setData()&#125;</span></span><br><span class=\"line\">    SET_DATA,</span><br><span class=\"line\">\t\t<span class=\"comment\">//Corresponds to &#123;@link CuratorFramework#getChildren()&#125;</span></span><br><span class=\"line\">    CHILDREN,</span><br><span class=\"line\">\t\t<span class=\"comment\">//Corresponds to &#123;@link CuratorFramework#sync(String, Object)&#125;</span></span><br><span class=\"line\">    SYNC,</span><br><span class=\"line\">\t\t<span class=\"comment\">//Corresponds to &#123;@link CuratorFramework#getACL()&#125;</span></span><br><span class=\"line\">    GET_ACL,</span><br><span class=\"line\">\t\t<span class=\"comment\">//Corresponds to &#123;@link CuratorFramework#setACL()&#125;</span></span><br><span class=\"line\">    SET_ACL,</span><br><span class=\"line\">\t\t<span class=\"comment\">//Corresponds to &#123;@link Watchable#usingWatcher(Watcher)&#125; or &#123;@link Watchable#watched()&#125;</span></span><br><span class=\"line\">    WATCHED,</span><br><span class=\"line\">\t\t<span class=\"comment\">//Event sent when client is being closed</span></span><br><span class=\"line\">    CLOSING</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"事件监听\"><a href=\"#事件监听\" class=\"headerlink\" title=\"事件监听\"></a>事件监听</h3><h4 id=\"一次性监听方式：Watcher\"><a href=\"#一次性监听方式：Watcher\" class=\"headerlink\" title=\"一次性监听方式：Watcher\"></a>一次性监听方式：Watcher</h4><p>利用 Watcher 来对节点进行监听操作，可以典型业务场景需要使用可考虑，但一般情况不推荐使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"type\">byte</span>[] data = curatorClient.getData().usingWatcher(<span class=\"keyword\">new</span> <span class=\"title class_\">Watcher</span>() &#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">process</span><span class=\"params\">(WatchedEvent watchedEvent)</span> &#123;</span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;监听器 watchedEvent：&quot;</span> + watchedEvent);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;).forPath(<span class=\"string\">&quot;/glmapper/test&quot;</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;监听节点内容：&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(data));</span><br><span class=\"line\"><span class=\"comment\">// 第一次变更节点数据</span></span><br><span class=\"line\">curatorClient.setData().forPath(<span class=\"string\">&quot;/glmapper/test&quot;</span>,<span class=\"string\">&quot;newData&quot;</span>.getBytes());</span><br><span class=\"line\"><span class=\"comment\">// 第二次变更节点数据</span></span><br><span class=\"line\">curatorClient.setData().forPath(<span class=\"string\">&quot;/glmapper/test&quot;</span>,<span class=\"string\">&quot;newChangedData&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>\n\n<p>上面这段代码对 &#x2F;glmapper&#x2F;test 节点注册了一个 Watcher 监听事件，并且返回当前节点的内容。后面进行两次数据变更，实际上第二次变更时，监听已经失效，无法再次获得节点变动事件了。测试中控制台输出的信息如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">监听节点内容：data</span><br><span class=\"line\">watchedEvent：WatchedEvent state:SyncConnected type:NodeDataChanged path:/glmapper/test</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"CuratorListener-方式\"><a href=\"#CuratorListener-方式\" class=\"headerlink\" title=\"CuratorListener 方式\"></a>CuratorListener 方式</h4><p>CuratorListener 监听，此监听主要针对 background 通知和错误通知。使用此监听器之后，调用inBackground 方法会异步获得监听，对于节点的创建或修改则不会触发监听事件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">CuratorListener</span> <span class=\"variable\">listener</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CuratorListener</span>()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eventReceived</span><span class=\"params\">(CuratorFramework client, CuratorEvent event)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;event : &quot;</span> + event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 绑定监听器</span></span><br><span class=\"line\">curatorClient.getCuratorListenable().addListener(listener);</span><br><span class=\"line\"><span class=\"comment\">// 异步获取节点数据</span></span><br><span class=\"line\">curatorClient.getData().inBackground().forPath(<span class=\"string\">&quot;/glmapper/test&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 更新节点数据</span></span><br><span class=\"line\">curatorClient.setData().forPath(<span class=\"string\">&quot;/glmapper/test&quot;</span>,<span class=\"string\">&quot;newData&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>\n\n<p>测试中控制台输出的信息如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">event : CuratorEventImpl&#123;type=GET_DATA, resultCode=0, path=&#x27;/glmapper/test&#x27;, name=&#x27;null&#x27;, children=null, context=null, stat=5867,5867,1555140974671,1555140974671,0,0,0,0,4,0,5867</span><br><span class=\"line\">, data=[100, 97, 116, 97], watchedEvent=null, aclList=null&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里只触发了一次监听回调，就是 getData 。</p>\n<h4 id=\"Curator-引入的-Cache-事件监听机制\"><a href=\"#Curator-引入的-Cache-事件监听机制\" class=\"headerlink\" title=\"Curator 引入的 Cache 事件监听机制\"></a>Curator 引入的 Cache 事件监听机制</h4><p>Curator 引入了 Cache 来实现对 Zookeeper 服务端事件监听，Cache 事件监听可以理解为一个本地缓存视图与远程 Zookeeper 视图的对比过程。Cache 提供了反复注册的功能。Cache 分为两类注册类型：节点监听和子节点监听。</p>\n<ul>\n<li><p>NodeCache</p>\n<p>监听数据节点本身的变化。对节点的监听需要配合回调函数来进行处理接收到监听事件之后的业务处理。NodeCache 通过 NodeCacheListener 来完成后续处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;/glmapper/test&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">NodeCache</span> <span class=\"variable\">nodeCache</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NodeCache</span>(curatorClient,path);</span><br><span class=\"line\"><span class=\"comment\">//如果设置为true则在首次启动时就会缓存节点内容到Cache中。 nodeCache.start(true);</span></span><br><span class=\"line\">nodeCache.start();</span><br><span class=\"line\">nodeCache.getListenable().addListener(<span class=\"keyword\">new</span> <span class=\"title class_\">NodeCacheListener</span>() &#123;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">nodeChanged</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;触发监听回调，当前节点数据为：&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(nodeCache.getCurrentData().getData()));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">curatorClient.setData().forPath(path,<span class=\"string\">&quot;1&quot;</span>.getBytes());</span><br><span class=\"line\">curatorClient.setData().forPath(path,<span class=\"string\">&quot;2&quot;</span>.getBytes());</span><br><span class=\"line\">curatorClient.setData().forPath(path,<span class=\"string\">&quot;3&quot;</span>.getBytes());</span><br><span class=\"line\">curatorClient.setData().forPath(path,<span class=\"string\">&quot;4&quot;</span>.getBytes());</span><br><span class=\"line\">curatorClient.setData().forPath(path,<span class=\"string\">&quot;5&quot;</span>.getBytes());</span><br><span class=\"line\">curatorClient.setData().forPath(path,<span class=\"string\">&quot;6&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>\n\n<p>注意：在测试过程中，nodeCache.start()，NodeCache 在先后多次修改监听节点的内容时，出现了丢失事件现象，在用例执行的5次中，仅一次监听到了全部事件；如果 nodeCache.start(true)，NodeCache 在先后多次修改监听节点的内容时，不会出现丢失现象。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>NodeCache不仅可以监听节点内容变化，还可以监听指定节点是否存在。如果原本节点不存在，那么Cache就会在节点被创建时触发监听事件，如果该节点被删除，就无法再触发监听事件。</p></blockquote>\n</li>\n<li><p>PathChildrenCache</p>\n<p>PathChildrenCache 不会对二级子节点进行监听，只会对子节点进行监听。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;/glmapper&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">PathChildrenCache</span> <span class=\"variable\">pathChildrenCache</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PathChildrenCache</span>(curatorClient,path,<span class=\"literal\">true</span>);</span><br><span class=\"line\"><span class=\"comment\">// 如果设置为true则在首次启动时就会缓存节点内容到Cache中。 nodeCache.start(true);</span></span><br><span class=\"line\">pathChildrenCache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);</span><br><span class=\"line\">pathChildrenCache.getListenable().addListener(<span class=\"keyword\">new</span> <span class=\"title class_\">PathChildrenCacheListener</span>() &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">childEvent</span><span class=\"params\">(CuratorFramework curatorFramework, PathChildrenCacheEvent event)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;-----------------------------&quot;</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;event:&quot;</span>  + event.getType());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (event.getData()!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;path:&quot;</span> + event.getData().getPath());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;-----------------------------&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">zookeeperCuratorClient.createNode(<span class=\"string\">&quot;/glmapper/test&quot;</span>,<span class=\"string\">&quot;data&quot;</span>.getBytes(),CreateMode.PERSISTENT);</span><br><span class=\"line\">Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">curatorClient.setData().forPath(<span class=\"string\">&quot;/glmapper/test&quot;</span>,<span class=\"string\">&quot;1&quot;</span>.getBytes());</span><br><span class=\"line\">Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">curatorClient.setData().forPath(<span class=\"string\">&quot;/glmapper/test&quot;</span>,<span class=\"string\">&quot;2&quot;</span>.getBytes());</span><br><span class=\"line\">Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">zookeeperCuratorClient.createNode(<span class=\"string\">&quot;/glmapper/test/second&quot;</span>,<span class=\"string\">&quot;data&quot;</span>.getBytes(),CreateMode.PERSISTENT);</span><br><span class=\"line\">Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">curatorClient.setData().forPath(<span class=\"string\">&quot;/glmapper/test/second&quot;</span>,<span class=\"string\">&quot;1&quot;</span>.getBytes());</span><br><span class=\"line\">Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">curatorClient.setData().forPath(<span class=\"string\">&quot;/glmapper/test/second&quot;</span>,<span class=\"string\">&quot;2&quot;</span>.getBytes());</span><br><span class=\"line\">Thread.sleep(<span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n\n<p>注意：在测试过程中发现，如果连续两个操作之间不进行一定时间的间隔，会导致无法监听到下一次事件。因此只会监听子节点，所以对二级子节点 &#x2F;second 下面的操作是监听不到的。测试中控制台输出的信息如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------------------------</span><br><span class=\"line\">event:CHILD_ADDED</span><br><span class=\"line\">path:/glmapper/test</span><br><span class=\"line\">-----------------------------</span><br><span class=\"line\">-----------------------------</span><br><span class=\"line\">event:INITIALIZED</span><br><span class=\"line\">-----------------------------</span><br><span class=\"line\">-----------------------------</span><br><span class=\"line\">event:CHILD_UPDATED</span><br><span class=\"line\">path:/glmapper/test</span><br><span class=\"line\">-----------------------------</span><br><span class=\"line\">-----------------------------</span><br><span class=\"line\">event:CHILD_UPDATED</span><br><span class=\"line\">path:/glmapper/test</span><br><span class=\"line\">-----------------------------</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>TreeCache</p>\n<p>TreeCache 使用一个内部类<code>TreeNode</code>来维护这个一个树结构。并将这个树结构与ZK节点进行了映射。所以TreeCache 可以监听当前节点下所有节点的事件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;/glmapper&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">TreeCache</span> <span class=\"variable\">treeCache</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeCache</span>(curatorClient,path);</span><br><span class=\"line\">treeCache.getListenable().addListener((client,event)-&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;-----------------------------&quot;</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;event:&quot;</span>  + event.getType());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (event.getData()!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;path:&quot;</span> + event.getData().getPath());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;-----------------------------&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">treeCache.start();</span><br><span class=\"line\">zookeeperCuratorClient.createNode(<span class=\"string\">&quot;/glmapper/test&quot;</span>,<span class=\"string\">&quot;data&quot;</span>.getBytes(),CreateMode.PERSISTENT);</span><br><span class=\"line\">Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">curatorClient.setData().forPath(<span class=\"string\">&quot;/glmapper/test&quot;</span>,<span class=\"string\">&quot;1&quot;</span>.getBytes());</span><br><span class=\"line\">Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">curatorClient.setData().forPath(<span class=\"string\">&quot;/glmapper/test&quot;</span>,<span class=\"string\">&quot;2&quot;</span>.getBytes());</span><br><span class=\"line\">Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">zookeeperCuratorClient.createNode(<span class=\"string\">&quot;/glmapper/test/second&quot;</span>,<span class=\"string\">&quot;data&quot;</span>.getBytes(),CreateMode.PERSISTENT);</span><br><span class=\"line\">Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">curatorClient.setData().forPath(<span class=\"string\">&quot;/glmapper/test/second&quot;</span>,<span class=\"string\">&quot;1&quot;</span>.getBytes());</span><br><span class=\"line\">Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">curatorClient.setData().forPath(<span class=\"string\">&quot;/glmapper/test/second&quot;</span>,<span class=\"string\">&quot;2&quot;</span>.getBytes());</span><br><span class=\"line\">Thread.sleep(<span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n\n<p>测试中控制台输出的信息如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------------------------</span><br><span class=\"line\">event:NODE_ADDED</span><br><span class=\"line\">path:/glmapper</span><br><span class=\"line\">-----------------------------</span><br><span class=\"line\">-----------------------------</span><br><span class=\"line\">event:NODE_ADDED</span><br><span class=\"line\">path:/glmapper/test</span><br><span class=\"line\">-----------------------------</span><br><span class=\"line\">-----------------------------</span><br><span class=\"line\">event:NODE_UPDATED</span><br><span class=\"line\">path:/glmapper/test</span><br><span class=\"line\">-----------------------------</span><br><span class=\"line\">-----------------------------</span><br><span class=\"line\">event:NODE_UPDATED</span><br><span class=\"line\">path:/glmapper/test</span><br><span class=\"line\">-----------------------------</span><br><span class=\"line\">-----------------------------</span><br><span class=\"line\">event:NODE_ADDED</span><br><span class=\"line\">path:/glmapper/test/second</span><br><span class=\"line\">-----------------------------</span><br><span class=\"line\">-----------------------------</span><br><span class=\"line\">event:NODE_UPDATED</span><br><span class=\"line\">path:/glmapper/test/second</span><br><span class=\"line\">-----------------------------</span><br><span class=\"line\">-----------------------------</span><br><span class=\"line\">event:NODE_UPDATED</span><br><span class=\"line\">path:/glmapper/test/second</span><br><span class=\"line\">-----------------------------</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"事务操作\"><a href=\"#事务操作\" class=\"headerlink\" title=\"事务操作\"></a>事务操作</h2><p> CuratorFramework 的实例包含 inTransaction( ) 接口方法，调用此方法开启一个 ZooKeeper 事务。 可以复合create、 setData、 check、and&#x2F;or delete 等操作然后调用 commit() 作为一个原子操作提交。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 开启事务  </span></span><br><span class=\"line\"><span class=\"type\">CuratorTransaction</span> <span class=\"variable\">curatorTransaction</span> <span class=\"operator\">=</span> curatorClient.inTransaction();</span><br><span class=\"line\">Collection&lt;CuratorTransactionResult&gt; commit = </span><br><span class=\"line\">  <span class=\"comment\">// 操作1 </span></span><br><span class=\"line\">curatorTransaction.create().withMode(CreateMode.EPHEMERAL).forPath(<span class=\"string\">&quot;/glmapper/transaction&quot;</span>)</span><br><span class=\"line\">  .and()</span><br><span class=\"line\">  <span class=\"comment\">// 操作2 </span></span><br><span class=\"line\">  .delete().forPath(<span class=\"string\">&quot;/glmapper/test&quot;</span>)</span><br><span class=\"line\">  .and()</span><br><span class=\"line\">  <span class=\"comment\">// 操作3</span></span><br><span class=\"line\">  .setData().forPath(<span class=\"string\">&quot;/glmapper/transaction&quot;</span>, <span class=\"string\">&quot;data&quot;</span>.getBytes())</span><br><span class=\"line\">  .and()</span><br><span class=\"line\">  <span class=\"comment\">// 提交事务</span></span><br><span class=\"line\">  .commit();</span><br><span class=\"line\">Iterator&lt;CuratorTransactionResult&gt; iterator = commit.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext())&#123;</span><br><span class=\"line\">  <span class=\"type\">CuratorTransactionResult</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> iterator.next();</span><br><span class=\"line\">  System.out.println(next.getForPath());</span><br><span class=\"line\">  System.out.println(next.getResultPath());</span><br><span class=\"line\">  System.out.println(next.getType());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里debug看了下Collection<CuratorTransactionResult>信息，面板如下：</p>\n<p><img src=\"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/zookeeper/curator-demo.jpg\"></p>\n<h2 id=\"异步操作\"><a href=\"#异步操作\" class=\"headerlink\" title=\"异步操作\"></a>异步操作</h2><p>前面提到的增删改查都是同步的，但是 Curator 也提供了异步接口，引入了 BackgroundCallback 接口用于处理异步接口调用之后服务端返回的结果信息。BackgroundCallback 接口中一个重要的回调值为 CuratorEvent，里面包含事件类型、响应吗和节点的详细信息。</p>\n<p>在使用上也是非常简单的，只需要带上 inBackground() 就行，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curatorClient.getData().inBackground().forPath(<span class=\"string\">&quot;/glmapper/test&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>通过查看 inBackground 方法定义可以看到，inBackground 支持自定义线程池来处理返回结果之后的业务逻辑。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> T <span class=\"title function_\">inBackground</span><span class=\"params\">(BackgroundCallback callback, Executor executor)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这里就不贴代码了。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本文主要围绕 Curator 的基本 API 进行了学习记录，对于原理及源码部分没有涉及。这部分如果有时间在慢慢研究吧。另外像分布式锁、分布式自增序列等实现停留在理论阶段，没有实践，不敢妄论，用到再码吧。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.cnblogs.com/felixzh/p/5869212.html\">http://www.cnblogs.com/felixzh/p/5869212.html</a></li>\n<li><a href=\"https://my.oschina.net/roccn/blog/918209\">https://my.oschina.net/roccn/blog/918209</a></li>\n</ul>\n","text":"ZooKeeper 是一个分布式的、开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现。它是集群的管理者，监视着集群中各个节点...","permalink":"/post/middleware/middleware-zookeeper-client-curator","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"Middleware","slug":"Middleware","count":14,"path":"api/categories/Middleware.json"}],"tags":[{"name":"curator","slug":"curator","count":1,"path":"api/tags/curator.json"},{"name":"zookeeper","slug":"zookeeper","count":3,"path":"api/tags/zookeeper.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Curator-%E5%92%8C-zookeeper-%E7%9A%84%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">Curator 和 zookeeper 的版本问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Curator-API\"><span class=\"toc-text\">Curator   API</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87\"><span class=\"toc-text\">环境准备</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Curator-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">Curator 客户端的初始化和初始化时机</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">初始化时机</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Curator-%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">Curator 初始化</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Curator-%E5%9F%BA%E7%A1%80-API-%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">Curator 基础 API 使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A3%80%E6%9F%A5%E8%8A%82%E7%82%B9%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8\"><span class=\"toc-text\">检查节点是否存在</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B0%E5%A2%9E%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">新增节点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">删除节点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">获取节点数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E6%96%B0%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">更新节点数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E5%AD%90%E5%88%97%E8%A1%A8\"><span class=\"toc-text\">获取子列表</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">事件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">事件类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC\"><span class=\"toc-text\">事件监听</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%80%E6%AC%A1%E6%80%A7%E7%9B%91%E5%90%AC%E6%96%B9%E5%BC%8F%EF%BC%9AWatcher\"><span class=\"toc-text\">一次性监听方式：Watcher</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#CuratorListener-%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">CuratorListener 方式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Curator-%E5%BC%95%E5%85%A5%E7%9A%84-Cache-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">Curator 引入的 Cache 事件监听机制</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">事务操作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">异步操作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"linux shell 编程小记","uid":"e6e9029e4c940952840addd5ca00ccc2","slug":"linux/linux-program-shell-record","date":"2019-04-20T10:18:42.000Z","updated":"2024-07-05T04:09:05.776Z","comments":true,"path":"api/articles/linux/linux-program-shell-record.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":null,"text":"if 条件 OPTION OPTION 解释 [-a file] 如果file存在则为真 ，也可以表示为 and: 条件与if [ -z “condition1...","permalink":"/post/linux/linux-program-shell-record","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[{"name":"Linux","slug":"Linux","count":9,"path":"api/categories/Linux.json"}],"tags":[{"name":"linux","slug":"linux","count":9,"path":"api/tags/linux.json"},{"name":"shell","slug":"shell","count":1,"path":"api/tags/shell.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"SpringBoot 源码系列-事件机制详解","uid":"7b12c81b8791d99dc46d122cdc93aac5","slug":"springboot/springboot-series-event","date":"2019-04-13T09:53:12.000Z","updated":"2024-07-05T04:09:05.828Z","comments":true,"path":"api/articles/springboot/springboot-series-event.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"text":"在这篇文章中聊一聊 Spring 中的扩展机制（一）中对Spring中的事件机制进行了分析。那么对于 SpringBoot 来说，它在 Spring 的基础上又...","permalink":"/post/springboot/springboot-series-event","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/categories/SpringBoot.json"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","count":17,"path":"api/tags/SpringBoot.json"},{"name":"event","slug":"event","count":1,"path":"api/tags/event.json"},{"name":"事件机制","slug":"事件机制","count":1,"path":"api/tags/事件机制.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}