{"title":"RocketMQ Push 消费模型","uid":"58f683d88937558e07ea2c785aa7588a","slug":"mq/rocketmq/rocketmq-push-consumer-model","date":"2022-09-22T13:31:29.000Z","updated":"2024-07-05T04:09:05.794Z","comments":true,"path":"api/articles/mq/rocketmq/rocketmq-push-consumer-model.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"content":"<p>Push 模式是指由 Server 端来控制消息的推送，即当有消息到 Server 之后，会将消息主动投递给 client(Consumer 端)。</p>\n<h2 id=\"使用-DefaultMQPushConsumer-消费消息\"><a href=\"#使用-DefaultMQPushConsumer-消费消息\" class=\"headerlink\" title=\"使用 DefaultMQPushConsumer 消费消息\"></a>使用 DefaultMQPushConsumer 消费消息</h2><p>下面是使用 DefaultMQPushConsumer 消费消息的官方示例代码：</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化consumer，并设置consumer group name</span></span><br><span class=\"line\"><span class=\"type\">DefaultMQPushConsumer</span> <span class=\"variable\">consumer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultMQPushConsumer</span>(<span class=\"string\">&quot;MyGroup&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置NameServer地址</span></span><br><span class=\"line\">consumer.setNamesrvAddr(<span class=\"string\">&quot;localhost:9876&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//订阅一个或多个topic，并指定tag过滤条件，这里指定*表示接收所有tag的消息</span></span><br><span class=\"line\">consumer.subscribe(<span class=\"string\">&quot;TopicTest&quot;</span>, <span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//注册回调接口来处理从Broker中收到的消息</span></span><br><span class=\"line\">consumer.registerMessageListener(<span class=\"keyword\">new</span> <span class=\"title class_\">MessageListenerConcurrently</span>() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ConsumeConcurrentlyStatus <span class=\"title function_\">consumeMessage</span><span class=\"params\">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class=\"line\">        <span class=\"comment\">// 返回消息消费状态，ConsumeConcurrentlyStatus.CONSUME_SUCCESS 为消费成功</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 启动Consumer</span></span><br><span class=\"line\">consumer.start();</span><br></pre></td></tr></table></figure>\n\n<p>这里看到主要是通过 consumer 注册回调接口来处理从 Broker 中收到的消息。这种监听回调的机制很容易想到是一种观察者模式或者事件机制；<strong>对于这种 C-S 模型的架构来说，如果要做到 Server 在有新消息时立即推送给 Client，那么 Client 和 Server 之间应该是有连接存在的，Client 端开放端口来 watch Server 的推送</strong>。这里好论证，即可以查看当前 Client 端所在进程开启了什么端口即可，通过如下指令查看：</p>\n<ul>\n<li>1、先通过 jps 查看 Consumer Client 的进程号</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  rocketmq-4.9.4 git:(06f2208a3) jps</span><br><span class=\"line\">10722 Jps</span><br><span class=\"line\">4676 rocketmq-dashboard-1.0.1-SNAPSHOT.jar</span><br><span class=\"line\">1766</span><br><span class=\"line\">4121 BrokerStartup</span><br><span class=\"line\">4009 NamesrvStartup</span><br><span class=\"line\">9419 PushConsumer</span><br><span class=\"line\">9692 RemoteMavenServer36</span><br></pre></td></tr></table></figure>\n\n<p>可以看到 PushConsumer 的进程号是 9419</p>\n<ul>\n<li>2、通过 lsof 命令查看进程端口占用</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  rocketmq-4.9.4 git:(06f2208a3) lsof -nP -p 9419| grep LISTEN</span><br><span class=\"line\">➜  </span><br></pre></td></tr></table></figure>\n\n<p>这里没有看到 PushConsumer 有开启端口。同样，这里可以看看 Broker 的进程端口占用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  rocketmq-4.9.4 git:(06f2208a3) lsof -nP -p 4121| grep LISTEN</span><br><span class=\"line\">java    4121 glmapper  137u    IPv6 0xca1142b0f200067d        0t0                 TCP *:10912 (LISTEN)</span><br><span class=\"line\">java    4121 glmapper  141u    IPv6 0xca1142b0f1fc8cfd        0t0                 TCP *:10911 (LISTEN)</span><br><span class=\"line\">java    4121 glmapper  142u    IPv6 0xca1142b0f1fc935d        0t0                 TCP *:10909 (LISTEN)</span><br></pre></td></tr></table></figure>\n\n\n<p>所以得到一个初步的结论是，<strong>在 Push 模式下，Consumer Client 并没有启动端口来接收 Server 的消息推送。</strong> 那么 RocketMQ 是怎么实现的？</p>\n<h2 id=\"基于长轮询机制的伪-push-实现\"><a href=\"#基于长轮询机制的伪-push-实现\" class=\"headerlink\" title=\"基于长轮询机制的伪 push 实现\"></a>基于长轮询机制的伪 push 实现</h2><p>真正的 Push 方式，是 Server 端接收到消息后，主动把消息推送给 Client 端，这种情况一般需要 Client 和 Server 之间建立长连接。通过前面的分析，Client 既然没有开启端口用于接收 Server 的信息推送，那么只有一种可能就是 Client 自己去拉了消息，但是这种主动拉消息的方式是对于用户无感的，从使用上体验上来看，做到了和 push 一样的效果；这种机制就是“长轮询”。</p>\n<p>为啥不用长连接方式，让 Server 主动 Push 呢？其实很好理解，对于一个提供队列服务的 Server 来说，用 Push方式主动推送有两个问题：</p>\n<ul>\n<li>1、会增加 Server 端的工作量，进而影响 Server 的性能</li>\n<li>2、Client 的处理能力存在差异，Client 的状态不受 Server 控制，如果 Client 不能及时处理 Server 推送过来的消息，会造成各种潜在问题</li>\n</ul>\n<h3 id=\"客户端侧发起的长轮询请求\"><a href=\"#客户端侧发起的长轮询请求\" class=\"headerlink\" title=\"客户端侧发起的长轮询请求\"></a>客户端侧发起的长轮询请求</h3><p>下图是初始化相关资源的过程，DefaultMQPushConsumer 是面向用户使用的 API client 类，内部处理实际上是委托给 DefaultMQPushConsumerImpl 来处理的。DefaultMQPushConsumerImpl#start 时，会初始化 MQClientInstance ，MQClientInstance 初始化过程中又会初始化一堆资源，比如请求-响应的通道，开启各种各样的调度任务（定期拉去 NameServerAddress、定期更新 Topic 路由信息、定期清理 Offline状态的 Broker、定期发送心跳给 Broker、定期持久化所有 Consumer Offset等等），开启 pullMessageService，开启 rebalance Service 等等。大致的调用链如下图</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05bcceec7c6f4301994fbef776e71664~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>下面这个代码片段是 pullMessageService 的 run 方法（pullMessageService 是 Runnable 子类）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    log.info(<span class=\"built_in\">this</span>.getServiceName() + <span class=\"string\">&quot; service started&quot;</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!<span class=\"built_in\">this</span>.isStopped()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从 pullRequestQueue 中取 pullRequest</span></span><br><span class=\"line\">            <span class=\"type\">PullRequest</span> <span class=\"variable\">pullRequest</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.pullRequestQueue.take();</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.pullMessage(pullRequest);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException ignored) &#123;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;Pull Message Service Run Method exception&quot;</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    log.info(<span class=\"built_in\">this</span>.getServiceName() + <span class=\"string\">&quot; service end&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过代码，可以直观的看起，pullMessageService 会一直从 pullRequestQueue 中取 pullRequest，然后执行 pullMessage 请求。实际上 MessageQueue 是和 pullRequest 一一对应的 ，pullRequest 全部存储到该 Consumer 的 pullRequestQueue 队列里面；消费者会不停的从 PullRequest 的队列里取 request 然后向broker 请求消息。</p>\n<p>这里还有一个问题是队列取出之后什么时候放回去的？在 pullMessage 的回调方法中，如果正常得到了 broker 的响应，那么会把 PullRequest放回队列，相关代码可以从 <code>org.apache.rocketmq.client.consumer.PullCallback</code>onSuccess 方法中得到答案。</p>\n<h3 id=\"服务端阻塞请求\"><a href=\"#服务端阻塞请求\" class=\"headerlink\" title=\"服务端阻塞请求\"></a>服务端阻塞请求</h3><p>服务端处理 pullRequest 请求的是 PullMessageProcessor，当没有消息时，则通过 PullRequestHoldService 将当前请求先 hold 住。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> ResponseCode.PULL_NOT_FOUND:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (brokerAllowSuspend &amp;&amp; hasSuspendFlag) &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">pollingTimeMills</span> <span class=\"operator\">=</span> suspendTimeoutMillisLong;</span><br><span class=\"line\">        <span class=\"comment\">// 如果是 LongPolling，则 hold 住</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class=\"line\">            pollingTimeMills = <span class=\"built_in\">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">topic</span> <span class=\"operator\">=</span> requestHeader.getTopic();</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">offset</span> <span class=\"operator\">=</span> requestHeader.getQueueOffset();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">queueId</span> <span class=\"operator\">=</span> requestHeader.getQueueId();</span><br><span class=\"line\">        <span class=\"type\">PullRequest</span> <span class=\"variable\">pullRequest</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PullRequest</span>(request, channel, pollingTimeMills,</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);</span><br><span class=\"line\">        response = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>PullRequestHoldService 中会将所有的 PullRequest 缓存到 pullRequestTable。PullRequestHoldService 也是一个 task，默认每次 hold 5s 然后再去检查是否有新的消息过来，如果有新的消息到来，则唤醒对应的线程来将消息返回给客户端。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 已省略无关代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// loop</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!<span class=\"built_in\">this</span>.isStopped()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// default hold 5s</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.waitForRunning(<span class=\"number\">5</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.waitForRunning(<span class=\"built_in\">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">beginLockTimestamp</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.systemClock.now();</span><br><span class=\"line\">        <span class=\"comment\">// 检查是否有新的消息到达</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.checkHoldRequest();</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">costTime</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.systemClock.now() - beginLockTimestamp;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (costTime &gt; <span class=\"number\">5</span> * <span class=\"number\">1000</span>) &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;[NOTIFYME] check hold request cost &#123;&#125; ms.&quot;</span>, costTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"客户端回调处理\"><a href=\"#客户端回调处理\" class=\"headerlink\" title=\"客户端回调处理\"></a>客户端回调处理</h3><p>我们在编写 consumer 代码时，基于 push 模式是通过如下方式来监听消息的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注册回调接口来处理从Broker中收到的消息</span></span><br><span class=\"line\">consumer.registerMessageListener(<span class=\"keyword\">new</span> <span class=\"title class_\">MessageListenerConcurrently</span>() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ConsumeConcurrentlyStatus <span class=\"title function_\">consumeMessage</span><span class=\"params\">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class=\"line\">        <span class=\"comment\">// 返回消息消费状态，ConsumeConcurrentlyStatus.CONSUME_SUCCESS 为消费成功</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>通过前面的分析，对于如何通过“长轮询”实现伪“push” 有了大概得了解；客户端通过一个定时任务不断向 Broker 发请求，Broker 在没有消息时先 hold 住一小段时间，当有新的消息时会立即将消息返回给 consumer；本节就主要探讨 consumer 在收到消息之后的处理逻辑，以及是怎么触发 MessageListener 回调执行的。</p>\n<h4 id=\"客户端发起请求的底层逻辑\"><a href=\"#客户端发起请求的底层逻辑\" class=\"headerlink\" title=\"客户端发起请求的底层逻辑\"></a>客户端发起请求的底层逻辑</h4><p>以异步调用为例，代码在</p>\n<p><code>org.apache.rocketmq.client.impl.MQClientAPIImpl#pullMessageAsync</code>中，截取部分代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.remotingClient.invokeAsync(addr, request, timeoutMillis, <span class=\"keyword\">new</span> <span class=\"title class_\">InvokeCallback</span>() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">operationComplete</span><span class=\"params\">(ResponseFuture responseFuture)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">RemotingCommand</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> responseFuture.getResponseCommand();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (response != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">PullResult</span> <span class=\"variable\">pullResult</span> <span class=\"operator\">=</span> MQClientAPIImpl.<span class=\"built_in\">this</span>.processPullResponse(response, addr);</span><br><span class=\"line\">                <span class=\"keyword\">assert</span> pullResult != <span class=\"literal\">null</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 成功回调</span></span><br><span class=\"line\">                pullCallback.onSuccess(pullResult);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 异常回调</span></span><br><span class=\"line\">                pullCallback.onException(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!responseFuture.isSendRequestOK()) &#123;</span><br><span class=\"line\">                 <span class=\"comment\">// 异常回调</span></span><br><span class=\"line\">                pullCallback.onException(<span class=\"keyword\">new</span> <span class=\"title class_\">MQClientException</span>(<span class=\"string\">&quot;send request failed to &quot;</span> + addr + <span class=\"string\">&quot;. Request: &quot;</span> + request, responseFuture.getCause()));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (responseFuture.isTimeout()) &#123;</span><br><span class=\"line\">                 <span class=\"comment\">// 异常回调</span></span><br><span class=\"line\">                pullCallback.onException(<span class=\"keyword\">new</span> <span class=\"title class_\">MQClientException</span>(<span class=\"string\">&quot;wait response from &quot;</span> + addr + <span class=\"string\">&quot; timeout :&quot;</span> + responseFuture.getTimeoutMillis() + <span class=\"string\">&quot;ms&quot;</span> + <span class=\"string\">&quot;. Request: &quot;</span> + request,</span><br><span class=\"line\">                    responseFuture.getCause()));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                 <span class=\"comment\">// 异常回调</span></span><br><span class=\"line\">                pullCallback.onException(<span class=\"keyword\">new</span> <span class=\"title class_\">MQClientException</span>(<span class=\"string\">&quot;unknown reason. addr: &quot;</span> + addr + <span class=\"string\">&quot;, timeoutMillis: &quot;</span> + timeoutMillis + <span class=\"string\">&quot;. Request: &quot;</span> + request, responseFuture.getCause()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"PullCallback-回调\"><a href=\"#PullCallback-回调\" class=\"headerlink\" title=\"PullCallback 回调\"></a>PullCallback 回调</h4><p>PullCallback 回调逻辑在 <code>org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl#pullMessage</code>方法中，以正常返回消息为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 已省略无关代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onSuccess</span><span class=\"params\">(PullResult pullResult)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将接收到的消息 交给 consumeMessageService 处理</span></span><br><span class=\"line\">    DefaultMQPushConsumerImpl.<span class=\"built_in\">this</span>.consumeMessageService.submitConsumeRequest(</span><br><span class=\"line\">        pullResult.getMsgFoundList(),</span><br><span class=\"line\">        processQueue,</span><br><span class=\"line\">        pullRequest.getMessageQueue(),</span><br><span class=\"line\">        dispatchToConsume);</span><br><span class=\"line\">    <span class=\"comment\">// 将 pullRequest 放回 pullRequestQueue</span></span><br><span class=\"line\"> DefaultMQPushConsumerImpl.<span class=\"built_in\">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ConsumeRequest 是一个 Runnable，submitConsumeRequest 就是将返回结果丢在一个单独的线程池中去处理返回结果的。ConsumeRequest 的 run 方法中，会拿到 messageListener，然后执行 consumeMessage 方法。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>到此，关于 RocketMQ push 消费模型基本就探讨完了。从实现机制上来看，push 本质上并不是在建立双向通道的前提下，由 Server 主动推送给 Client 的，而是由 Client 端触发 pullRequest 请求，以长轮询的方式“伪装”的结果。从代码上来，RocketMQ 代码中使用了非常多的异步机制，如 pullRequestQueue 来解耦发送请求和等待结果，各种定时任务等等。</p>\n<p>整体看，PushConsumer 采用了 <strong>长轮询+超时时间+Pull的模式，</strong> 这种方式带来的好处总结如下 <strong>：</strong></p>\n<ul>\n<li>1、减少 Broker 的压力，避免由于不同 Consumer 消费能力导致 Broker 出现问题</li>\n<li>2、确保了 Consumer 不会负载过高，Consumer 在校验自己的缓存消息没有超过阈值才会去从 Broker 拉取消息，Broker 不会主动推过来</li>\n<li>3、兼顾了消息的即时性，Broker 在没有消息的时候会先 hold 一小段时间，有消息会立即唤起线程将消息返回给 Consumer</li>\n<li>4、Broker 端无效请求的次数大大降低，Broker 在没有消息时会挂起 PullRequest，而 Consumer 在未接收到Response 且未超时时，也不会重新发起 PullRequest</li>\n</ul>\n","text":"Push 模式是指由 Server 端来控制消息的推送，即当有消息到 Server 之后，会将消息主动投递给 client(Consumer 端)。 使用 De...","permalink":"/post/mq/rocketmq/rocketmq-push-consumer-model","photos":[],"count_time":{"symbolsCount":"9.6k","symbolsTime":"9 mins."},"categories":[{"name":"RocketMQ","slug":"RocketMQ","count":2,"path":"api/categories/RocketMQ.json"}],"tags":[{"name":"RocketMQ","slug":"RocketMQ","count":3,"path":"api/tags/RocketMQ.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-DefaultMQPushConsumer-%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF\"><span class=\"toc-text\">使用 DefaultMQPushConsumer 消费消息</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8E%E9%95%BF%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BC%AA-push-%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">基于长轮询机制的伪 push 实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BE%A7%E5%8F%91%E8%B5%B7%E7%9A%84%E9%95%BF%E8%BD%AE%E8%AF%A2%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">客户端侧发起的长轮询请求</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%98%BB%E5%A1%9E%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">服务端阻塞请求</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9B%9E%E8%B0%83%E5%A4%84%E7%90%86\"><span class=\"toc-text\">客户端回调处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82%E7%9A%84%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91\"><span class=\"toc-text\">客户端发起请求的底层逻辑</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#PullCallback-%E5%9B%9E%E8%B0%83\"><span class=\"toc-text\">PullCallback 回调</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"Mysql - 从一个小 case 理解 MVCC","uid":"6c139a1ec6733d215aeb28747f12a741","slug":"db/mysql-transaction-mvcc-case","date":"2022-11-12T03:23:22.000Z","updated":"2024-07-05T04:09:05.751Z","comments":true,"path":"api/articles/db/mysql-transaction-mvcc-case.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"text":" 原文链接： https://juejin.cn/post/7163934829984088095 从 innoDB 的一致性非锁定读说起非锁定读和行快照数据一...","permalink":"/post/db/mysql-transaction-mvcc-case","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"数据库","slug":"数据库","count":1,"path":"api/categories/数据库.json"}],"tags":[{"name":"mysql","slug":"mysql","count":4,"path":"api/tags/mysql.json"},{"name":"mvcc","slug":"mvcc","count":1,"path":"api/tags/mvcc.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}},"next_post":{"title":"RocketMQ 本地部署问题总结","uid":"8c745d5436d89ed91d5d8624c45dc15a","slug":"mq/rocketmq/rocketmq-deploy-issue","date":"2022-09-22T13:29:02.000Z","updated":"2024-07-05T04:09:05.794Z","comments":true,"path":"api/articles/mq/rocketmq/rocketmq-deploy-issue.json","keywords":"宋国磊, glmapper, 卫恒, 分享, 开源","cover":[],"text":"本篇分为 RocketMQ 部署和 RocketMQ-dashboard 部署两部分，主要是 RocketMQ 部署问题较多，汇总了下网上各路大神以及官方 is...","permalink":"/post/mq/rocketmq/rocketmq-deploy-issue","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"RocketMQ","slug":"RocketMQ","count":2,"path":"api/categories/RocketMQ.json"}],"tags":[{"name":"RocketMQ","slug":"RocketMQ","count":3,"path":"api/tags/RocketMQ.json"}],"author":{"name":"glmapper","slug":"blog-author","avatar":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/favicon.ico","link":"/","description":"开放，开源，分享，共享","socials":{"github":"https://github.com/glmapper","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2412872703","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3227821827961806","customs":{"sofastack":{"icon":"https://glmapper-blog.oss-cn-hangzhou.aliyuncs.com/common/sofastack.svg","link":"https://www.sofastack.tech/"}}}}}}